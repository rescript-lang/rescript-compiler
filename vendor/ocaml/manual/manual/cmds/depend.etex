\chapter{Dependency generator (ocamldep)} \label{c:camldep}
\pdfchapter{Dependency generator (ocamldep)}
%HEVEA\cutname{depend.html}

The "ocamldep" command scans a set of OCaml source files
(".ml" and ".mli" files) for references to external compilation units,
and outputs dependency lines in a format suitable for the "make"
utility. This ensures that "make" will compile the source files in the
correct order, and recompile those files that need to when a source
file is modified.

The typical usage is:
\begin{alltt}
        ocamldep \var{options} *.mli *.ml > .depend
\end{alltt}
where "*.mli *.ml" expands to all source files in the current
directory and ".depend" is the file that should contain the
dependencies. (See below for a typical "Makefile".)

Dependencies are generated both for compiling with the bytecode
compiler "ocamlc" and with the native-code compiler "ocamlopt".

\section{Options}

The following command-line options are recognized by "ocamldep".

\begin{options}

\item["-absname"]
Show absolute filenames in error messages.

\item["-all"]
Generate dependencies on all required files, rather than assuming
implicit dependencies.

\item["-allow-approx"]
Allow falling back on a lexer-based approximation when parsing fails.

\item["-args" \var{filename}]
 Read additional newline-terminated command line arguments from \var{filename}.

\item["-args0" \var{filename}]
 Read additional null character terminated command line arguments from \var{filename}.

\item["-as-map"]
For the following files, do not include delayed dependencies for
module aliases.
This option assumes that they are compiled using options
"-no-alias-deps -w -49", and that those files or their interface are
passed with the "-map" option when computing dependencies for other
files. Note also that for dependencies to be correct in the
implementation of a map file, its interface should not coerce any of
the aliases it contains.

\item["-debug-map"]
Dump the delayed dependency map for each map file.

\item["-I" \var{directory}]
Add the given directory to the list of directories searched for
source files. If a source file "foo.ml" mentions an external
compilation unit "Bar", a dependency on that unit's interface
"bar.cmi" is generated only if the source for "bar" is found in the
current directory or in one of the directories specified with "-I".
Otherwise, "Bar" is assumed to be a module from the standard library,
and no dependencies are generated. For programs that span multiple
directories, it is recommended to pass "ocamldep" the same "-I" options
that are passed to the compiler.

\item["-impl" \var{file}]
Process \var{file} as a ".ml" file.

\item["-intf" \var{file}]
Process \var{file} as a ".mli" file.

\item["-map" \var{file}]
Read an propagate the delayed dependencies for module aliases in
\var{file}, so that the following files will depend on the
exported aliased modules if they use them. See the example below.

\item["-ml-synonym" \var{.ext}]
Consider the given extension (with leading dot) to be a synonym for .ml.

\item["-mli-synonym" \var{.ext}]
Consider the given extension (with leading dot) to be a synonym for .mli.

\item["-modules"]
Output raw dependencies of the form
\begin{verbatim}
      filename: Module1 Module2 ... ModuleN
\end{verbatim}
where "Module1", \ldots, "ModuleN" are the names of the compilation
units referenced within the file "filename", but these names are not
resolved to source file names.  Such raw dependencies cannot be used
by "make", but can be post-processed by other tools such as "Omake".

\item["-native"]
Generate dependencies for a pure native-code program (no bytecode
version).  When an implementation file (".ml" file) has no explicit
interface file (".mli" file), "ocamldep" generates dependencies on the
bytecode compiled file (".cmo" file) to reflect interface changes.
This can cause unnecessary bytecode recompilations for programs that
are compiled to native-code only.  The flag "-native" causes
dependencies on native compiled files (".cmx") to be generated instead
of on ".cmo" files.  (This flag makes no difference if all source files
have explicit ".mli" interface files.)

\item["-one-line"]
Output one line per file, regardless of the length.

\item["-open" \var{module}]
Assume that module \var{module} is opened before parsing each of the
following files.

\item["-plugin" \var{plugin}]
Dynamically load the code of the given \var{plugin}
(a ".cmo", ".cma" or ".cmxs" file) in "ocamldep". \var{plugin} must exist in
the same kind of code as "ocamldep" ("ocamldep.byte" must load bytecode
plugins, while "ocamldep.opt" must load native code plugins), and
extension adaptation is done automatically for ".cma" files (to ".cmxs" files
if "ocamldep" is compiled in native code).

\item["-pp" \var{command}]
Cause "ocamldep" to call the given \var{command} as a preprocessor
for each source file.

\item["-ppx" \var{command}]
Pipe abstract syntax trees through preprocessor \var{command}.

\item["-shared"]
Generate dependencies for native plugin files (.cmxs) in addition to
native compiled files (.cmx).

\item["-slash"]
Under Windows, use a forward slash (/) as the path separator instead
of the usual backward slash ($\backslash$).  Under Unix, this option does
nothing.

\item["-sort"]
Sort files according to their dependencies.

\item["-version"]
Print version string and exit.

\item["-vnum"]
Print short version number and exit.

\item["-help" or "--help"]
Display a short usage summary and exit.
%
\end{options}

\section{A typical Makefile}

Here is a template "Makefile" for a OCaml program.

\begin{verbatim}
OCAMLC=ocamlc
OCAMLOPT=ocamlopt
OCAMLDEP=ocamldep
INCLUDES=                 # all relevant -I options here
OCAMLFLAGS=$(INCLUDES)    # add other options for ocamlc here
OCAMLOPTFLAGS=$(INCLUDES) # add other options for ocamlopt here

# prog1 should be compiled to bytecode, and is composed of three
# units: mod1, mod2 and mod3.

# The list of object files for prog1
PROG1_OBJS=mod1.cmo mod2.cmo mod3.cmo

prog1: $(PROG1_OBJS)
        $(OCAMLC) -o prog1 $(OCAMLFLAGS) $(PROG1_OBJS)

# prog2 should be compiled to native-code, and is composed of two
# units: mod4 and mod5.

# The list of object files for prog2
PROG2_OBJS=mod4.cmx mod5.cmx

prog2: $(PROG2_OBJS)
        $(OCAMLOPT) -o prog2 $(OCAMLFLAGS) $(PROG2_OBJS)

# Common rules
.SUFFIXES: .ml .mli .cmo .cmi .cmx

.ml.cmo:
        $(OCAMLC) $(OCAMLFLAGS) -c $<

.mli.cmi:
        $(OCAMLC) $(OCAMLFLAGS) -c $<

.ml.cmx:
        $(OCAMLOPT) $(OCAMLOPTFLAGS) -c $<

# Clean up
clean:
        rm -f prog1 prog2
        rm -f *.cm[iox]

# Dependencies
depend:
        $(OCAMLDEP) $(INCLUDES) *.mli *.ml > .depend

include .depend
\end{verbatim}

If you use module aliases to give shorter names to modules, you need
to change the above definitions. Assuming that your map file is called
"mylib.mli", here are minimal modifications.
\begin{verbatim}
OCAMLFLAGS=$(INCLUDES) -open Mylib

mylib.cmi: mylib.mli
        $(OCAMLC) $(INCLUDES) -no-alias-deps -w -49 -c $<

depend:
        $(OCAMLDEP) $(INCLUDES) -map mylib.mli $(PROG1_OBJS:.cmo=.ml) > .depend
\end{verbatim}
Note that in this case you should not compute dependencies for
"mylib.mli" together with the other files, hence the need to pass
explicitly the list of files to process.
If "mylib.mli" itself has dependencies, you should compute them using
"-as-map".
