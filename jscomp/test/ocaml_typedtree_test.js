'use strict';

var Arg = require("../../lib/js/arg.js");
var Sys = require("../../lib/js/sys.js");
var Char = require("../../lib/js/char.js");
var List = require("../../lib/js/list.js");
var Path = require("path");
var $$Array = require("../../lib/js/array.js");
var Block = require("../../lib/js/block.js");
var Bytes = require("../../lib/js/bytes.js");
var Curry = require("../../lib/js/curry.js");
var Int32 = require("../../lib/js/int32.js");
var Int64 = require("../../lib/js/int64.js");
var $$Buffer = require("../../lib/js/buffer.js");
var Digest = require("../../lib/js/digest.js");
var Format = require("../../lib/js/format.js");
var Lexing = require("../../lib/js/lexing.js");
var Printf = require("../../lib/js/printf.js");
var $$String = require("../../lib/js/string.js");
var Assert = require("assert");
var Caml_io = require("../../lib/js/caml_io.js");
var Hashtbl = require("../../lib/js/hashtbl.js");
var Marshal = require("../../lib/js/marshal.js");
var Parsing = require("../../lib/js/parsing.js");
var Process = require("process");
var Caml_obj = require("../../lib/js/caml_obj.js");
var Caml_sys = require("../../lib/js/caml_sys.js");
var Filename = require("../../lib/js/filename.js");
var Caml_weak = require("../../lib/js/caml_weak.js");
var Nativeint = require("../../lib/js/nativeint.js");
var Caml_array = require("../../lib/js/caml_array.js");
var Caml_bytes = require("../../lib/js/caml_bytes.js");
var Caml_int32 = require("../../lib/js/caml_int32.js");
var Caml_int64 = require("../../lib/js/caml_int64.js");
var Pervasives = require("../../lib/js/pervasives.js");
var Caml_format = require("../../lib/js/caml_format.js");
var Caml_option = require("../../lib/js/caml_option.js");
var Caml_string = require("../../lib/js/caml_string.js");
var Caml_primitive = require("../../lib/js/caml_primitive.js");
var Caml_exceptions = require("../../lib/js/caml_exceptions.js");
var CamlinternalLazy = require("../../lib/js/camlinternalLazy.js");
var Caml_js_exceptions = require("../../lib/js/caml_js_exceptions.js");
var Caml_external_polyfill = require("../../lib/js/caml_external_polyfill.js");
var Caml_builtin_exceptions = require("../../lib/js/caml_builtin_exceptions.js");

var cmi_magic_number = "Caml1999I017";

var load_path = {
  contents: /* [] */0
};

var interface_suffix = {
  contents: ".mli"
};

var print_types = {
  contents: false
};

var debug = false;

var fast = {
  contents: false
};

var classic = {
  contents: false
};

var nopervasives = false;

var annotations = {
  contents: false
};

var binary_annotations = {
  contents: false
};

var principal = {
  contents: false
};

var real_paths = {
  contents: true
};

var recursive_types = {
  contents: false
};

var strict_sequence = {
  contents: false
};

var applicative_functors = {
  contents: true
};

var error_size = {
  contents: 500
};

var transparent_modules = {
  contents: false
};

var native_code = {
  contents: false
};

var dont_write_files = {
  contents: false
};

var keep_docs = {
  contents: false
};

var keep_locs = {
  contents: false
};

var unsafe_string = true;

var assume_no_mli = {
  contents: /* Mli_na */0
};

var record_event_when_debug = true;

var bs_vscode;

try {
  Caml_sys.caml_sys_getenv("BS_VSCODE");
  bs_vscode = true;
}
catch (exn){
  bs_vscode = false;
}

var dont_record_crc_unit = {
  contents: void 0
};

var bs_only = {
  contents: false
};

var color = {
  contents: void 0
};

var Fatal_error = Caml_exceptions.create("Ocaml_typedtree_test.Misc.Fatal_error");

function fatal_error(msg) {
  Pervasives.prerr_string(">> Fatal error: ");
  console.error(msg);
  throw Fatal_error;
}

function try_finally(work, cleanup) {
  var result;
  try {
    result = Curry._1(work, void 0);
  }
  catch (e){
    Curry._1(cleanup, void 0);
    throw e;
  }
  Curry._1(cleanup, void 0);
  return result;
}

function map_end(f, l1, l2) {
  if (l1) {
    return /* :: */[
            Curry._1(f, l1[0]),
            map_end(f, l1[1], l2)
          ];
  } else {
    return l2;
  }
}

function for_all2(pred, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (!l1) {
      if (l2) {
        return false;
      } else {
        return true;
      }
    }
    if (!l2) {
      return false;
    }
    if (!Curry._2(pred, l1[0], l2[0])) {
      return false;
    }
    _l2 = l2[1];
    _l1 = l1[1];
    continue ;
  };
}

function replicate_list(elem, n) {
  if (n <= 0) {
    return /* [] */0;
  } else {
    return /* :: */[
            elem,
            replicate_list(elem, n - 1 | 0)
          ];
  }
}

function split_last(param) {
  if (!param) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "misc.ml",
            54,
            10
          ]
        ];
  }
  var tl = param[1];
  var x = param[0];
  if (!tl) {
    return /* tuple */[
            /* [] */0,
            x
          ];
  }
  var match = split_last(tl);
  return /* tuple */[
          /* :: */[
            x,
            match[0]
          ],
          match[1]
        ];
}

function may(f, param) {
  if (param !== void 0) {
    return Curry._1(f, Caml_option.valFromOption(param));
  }
  
}

function may_map(f, param) {
  if (param !== void 0) {
    return Caml_option.some(Curry._1(f, Caml_option.valFromOption(param)));
  }
  
}

function find_in_path_uncap(path, name) {
  var uname = Caml_bytes.bytes_to_string(Bytes.uncapitalize(Caml_bytes.bytes_of_string(name)));
  var _param = path;
  while(true) {
    var param = _param;
    if (!param) {
      throw Caml_builtin_exceptions.not_found;
    }
    var dir = param[0];
    var fullname = Filename.concat(dir, name);
    var ufullname = Filename.concat(dir, uname);
    if (Caml_external_polyfill.resolve("caml_sys_file_exists")(ufullname)) {
      return ufullname;
    }
    if (Caml_external_polyfill.resolve("caml_sys_file_exists")(fullname)) {
      return fullname;
    }
    _param = param[1];
    continue ;
  };
}

function remove_file(filename) {
  try {
    return Caml_external_polyfill.resolve("caml_sys_remove")(filename);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.sys_error) {
      return ;
    }
    throw exn;
  }
}

function create_hashtable(size, init) {
  var tbl = Hashtbl.create(void 0, size);
  List.iter((function (param) {
          return Hashtbl.add(tbl, param[0], param[1]);
        }), init);
  return tbl;
}

function chop_extension_if_any(fname) {
  try {
    return Filename.chop_extension(fname);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.invalid_argument) {
      return fname;
    }
    throw exn;
  }
}

function get_ref(r) {
  var v = r.contents;
  r.contents = /* [] */0;
  return v;
}

function edit_distance(a, b, cutoff) {
  var la = a.length;
  var lb = b.length;
  var cutoff$1 = Caml_primitive.caml_int_min(la > lb ? la : lb, cutoff);
  if (Pervasives.abs(la - lb | 0) > cutoff$1) {
    return ;
  }
  var m = $$Array.make_matrix(la + 1 | 0, lb + 1 | 0, cutoff$1 + 1 | 0);
  Caml_array.caml_array_set(Caml_array.caml_array_get(m, 0), 0, 0);
  for(var i = 1; i <= la; ++i){
    Caml_array.caml_array_set(Caml_array.caml_array_get(m, i), 0, i);
  }
  for(var j = 1; j <= lb; ++j){
    Caml_array.caml_array_set(Caml_array.caml_array_get(m, 0), j, j);
  }
  for(var i$1 = 1; i$1 <= la; ++i$1){
    for(var j$1 = Caml_primitive.caml_int_max(1, (i$1 - cutoff$1 | 0) - 1 | 0) ,j_finish = Caml_primitive.caml_int_min(lb, (i$1 + cutoff$1 | 0) + 1 | 0); j$1 <= j_finish; ++j$1){
      var cost = Caml_string.get(a, i$1 - 1 | 0) === Caml_string.get(b, j$1 - 1 | 0) ? 0 : 1;
      var best = Caml_primitive.caml_int_min(1 + Caml_primitive.caml_int_min(Caml_array.caml_array_get(Caml_array.caml_array_get(m, i$1 - 1 | 0), j$1), Caml_array.caml_array_get(Caml_array.caml_array_get(m, i$1), j$1 - 1 | 0)) | 0, Caml_array.caml_array_get(Caml_array.caml_array_get(m, i$1 - 1 | 0), j$1 - 1 | 0) + cost | 0);
      var best$1 = i$1 > 1 && j$1 > 1 && Caml_string.get(a, i$1 - 1 | 0) === Caml_string.get(b, j$1 - 2 | 0) && Caml_string.get(a, i$1 - 2 | 0) === Caml_string.get(b, j$1 - 1 | 0) ? Caml_primitive.caml_int_min(best, Caml_array.caml_array_get(Caml_array.caml_array_get(m, i$1 - 2 | 0), j$1 - 2 | 0) + cost | 0) : best;
      Caml_array.caml_array_set(Caml_array.caml_array_get(m, i$1), j$1, best$1);
    }
  }
  var result = Caml_array.caml_array_get(Caml_array.caml_array_get(m, la), lb);
  if (result > cutoff$1) {
    return ;
  } else {
    return result;
  }
}

function ansi_of_color(param) {
  switch (param) {
    case /* Black */0 :
        return "0";
    case /* Red */1 :
        return "1";
    case /* Green */2 :
        return "2";
    case /* Yellow */3 :
        return "3";
    case /* Blue */4 :
        return "4";
    case /* Magenta */5 :
        return "5";
    case /* Cyan */6 :
        return "6";
    case /* White */7 :
        return "7";
    
  }
}

function code_of_style(param) {
  if (typeof param !== "number") {
    if (param.tag) {
      return "4" + ansi_of_color(param[0]);
    } else {
      return "3" + ansi_of_color(param[0]);
    }
  }
  switch (param) {
    case /* Bold */0 :
        return "1";
    case /* Reset */1 :
        return "0";
    case /* Dim */2 :
        return "2";
    
  }
}

function ansi_of_style_l(l) {
  var s = l ? (
      l[1] ? $$String.concat(";", List.map(code_of_style, l)) : code_of_style(l[0])
    ) : "0";
  return "\x1b[" + (s + "m");
}

var default_styles = {
  error: /* :: */[
    /* Bold */0,
    /* :: */[
      /* FG */Block.__(0, [/* Red */1]),
      /* [] */0
    ]
  ],
  warning: /* :: */[
    /* Bold */0,
    /* :: */[
      /* FG */Block.__(0, [/* Magenta */5]),
      /* [] */0
    ]
  ],
  loc: /* :: */[
    /* Bold */0,
    /* [] */0
  ]
};

var cur_styles = {
  contents: default_styles
};

function get_styles(param) {
  return cur_styles.contents;
}

function set_styles(s) {
  cur_styles.contents = s;
  
}

function style_of_tag(s) {
  switch (s) {
    case "dim" :
        return /* :: */[
                /* Dim */2,
                /* [] */0
              ];
    case "error" :
        return cur_styles.contents.error;
    case "filename" :
        return /* :: */[
                /* FG */Block.__(0, [/* Cyan */6]),
                /* [] */0
              ];
    case "info" :
        return /* :: */[
                /* Bold */0,
                /* :: */[
                  /* FG */Block.__(0, [/* Yellow */3]),
                  /* [] */0
                ]
              ];
    case "loc" :
        return cur_styles.contents.loc;
    case "warning" :
        return cur_styles.contents.warning;
    default:
      throw Caml_builtin_exceptions.not_found;
  }
}

var color_enabled = {
  contents: true
};

function set_color_tag_handling(ppf) {
  var functions = Format.pp_get_formatter_tag_functions(ppf, void 0);
  var partial_arg = functions.mark_open_tag;
  var partial_arg$1 = functions.mark_close_tag;
  var functions$prime_mark_open_tag = function (param) {
    try {
      var style = style_of_tag(param);
      if (color_enabled.contents) {
        return ansi_of_style_l(style);
      } else {
        return "";
      }
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return Curry._1(partial_arg, param);
      }
      throw exn;
    }
  };
  var functions$prime_mark_close_tag = function (param) {
    try {
      style_of_tag(param);
      if (color_enabled.contents) {
        return ansi_of_style_l(/* :: */[
                    /* Reset */1,
                    /* [] */0
                  ]);
      } else {
        return "";
      }
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return Curry._1(partial_arg$1, param);
      }
      throw exn;
    }
  };
  var functions$prime_print_open_tag = functions.print_open_tag;
  var functions$prime_print_close_tag = functions.print_close_tag;
  var functions$prime = {
    mark_open_tag: functions$prime_mark_open_tag,
    mark_close_tag: functions$prime_mark_close_tag,
    print_open_tag: functions$prime_print_open_tag,
    print_close_tag: functions$prime_print_close_tag
  };
  ppf.pp_mark_tags = true;
  return Format.pp_set_formatter_tag_functions(ppf, functions$prime);
}

var first = {
  contents: true
};

var formatter_l_001 = /* :: */[
  Format.err_formatter,
  /* :: */[
    Format.str_formatter,
    /* [] */0
  ]
];

var formatter_l = /* :: */[
  Format.std_formatter,
  formatter_l_001
];

function setup(o) {
  if (first.contents) {
    first.contents = false;
    Format.set_mark_tags(true);
    List.iter(set_color_tag_handling, formatter_l);
    var tmp;
    if (o !== void 0) {
      switch (o) {
        case /* Always */1 :
            tmp = true;
            break;
        case /* Auto */0 :
        case /* Never */2 :
            tmp = false;
            break;
        
      }
    } else {
      tmp = false;
    }
    color_enabled.contents = tmp;
  }
  
}

var Misc_Color = {
  ansi_of_style_l: ansi_of_style_l,
  default_styles: default_styles,
  get_styles: get_styles,
  set_styles: set_styles,
  setup: setup,
  set_color_tag_handling: set_color_tag_handling
};

function number(param) {
  if (typeof param === "number") {
    switch (param) {
      case /* Comment_start */0 :
          return 1;
      case /* Comment_not_end */1 :
          return 2;
      case /* Partial_application */2 :
          return 5;
      case /* Labels_omitted */3 :
          return 6;
      case /* Statement_type */4 :
          return 10;
      case /* Unused_match */5 :
          return 11;
      case /* Unused_pat */6 :
          return 12;
      case /* Illegal_backslash */7 :
          return 14;
      case /* Unerasable_optional_argument */8 :
          return 16;
      case /* Unused_argument */9 :
          return 20;
      case /* Nonreturning_statement */10 :
          return 21;
      case /* Useless_record_with */11 :
          return 23;
      case /* All_clauses_guarded */12 :
          return 25;
      case /* Wildcard_arg_to_constant_constr */13 :
          return 28;
      case /* Eol_in_string */14 :
          return 29;
      case /* Unused_rec_flag */15 :
          return 39;
      case /* Bs_polymorphic_comparison */16 :
          return 102;
      
    }
  } else {
    switch (param.tag | 0) {
      case /* Deprecated */0 :
          return 3;
      case /* Fragile_match */1 :
          return 4;
      case /* Method_override */2 :
          return 7;
      case /* Partial_match */3 :
          return 8;
      case /* Non_closed_record_pattern */4 :
          return 9;
      case /* Instance_variable_override */5 :
          return 13;
      case /* Implicit_public_methods */6 :
          return 15;
      case /* Undeclared_virtual_method */7 :
          return 17;
      case /* Not_principal */8 :
          return 18;
      case /* Without_principality */9 :
          return 19;
      case /* Preprocessor */10 :
          return 22;
      case /* Bad_module_name */11 :
          return 24;
      case /* Unused_var */12 :
          return 26;
      case /* Unused_var_strict */13 :
          return 27;
      case /* Duplicate_definitions */14 :
          return 30;
      case /* Multiple_definition */15 :
          return 31;
      case /* Unused_value_declaration */16 :
          return 32;
      case /* Unused_open */17 :
          return 33;
      case /* Unused_type_declaration */18 :
          return 34;
      case /* Unused_for_index */19 :
          return 35;
      case /* Unused_ancestor */20 :
          return 36;
      case /* Unused_constructor */21 :
          return 37;
      case /* Unused_extension */22 :
          return 38;
      case /* Name_out_of_scope */23 :
          return 40;
      case /* Ambiguous_name */24 :
          return 41;
      case /* Disambiguated_name */25 :
          return 42;
      case /* Nonoptional_label */26 :
          return 43;
      case /* Open_shadow_identifier */27 :
          return 44;
      case /* Open_shadow_label_constructor */28 :
          return 45;
      case /* Bad_env_variable */29 :
          return 46;
      case /* Attribute_payload */30 :
          return 47;
      case /* Eliminated_optional_arguments */31 :
          return 48;
      case /* No_cmi_file */32 :
          return 49;
      case /* Bad_docstring */33 :
          return 50;
      case /* Bs_unused_attribute */34 :
          return 101;
      case /* Bs_ffi_warning */35 :
          return 103;
      case /* Bs_derive_warning */36 :
          return 104;
      
    }
  }
}

function loop(i) {
  if (i === 0) {
    return /* [] */0;
  } else {
    return /* :: */[
            i,
            loop(i - 1 | 0)
          ];
  }
}

var letter_all = loop(104);

function letter(param) {
  switch (param) {
    case 97 :
        return letter_all;
    case 99 :
        return /* :: */[
                1,
                /* :: */[
                  2,
                  /* [] */0
                ]
              ];
    case 100 :
        return /* :: */[
                3,
                /* [] */0
              ];
    case 101 :
        return /* :: */[
                4,
                /* [] */0
              ];
    case 102 :
        return /* :: */[
                5,
                /* [] */0
              ];
    case 107 :
        return /* :: */[
                32,
                /* :: */[
                  33,
                  /* :: */[
                    34,
                    /* :: */[
                      35,
                      /* :: */[
                        36,
                        /* :: */[
                          37,
                          /* :: */[
                            38,
                            /* :: */[
                              39,
                              /* [] */0
                            ]
                          ]
                        ]
                      ]
                    ]
                  ]
                ]
              ];
    case 108 :
        return /* :: */[
                6,
                /* [] */0
              ];
    case 109 :
        return /* :: */[
                7,
                /* [] */0
              ];
    case 112 :
        return /* :: */[
                8,
                /* [] */0
              ];
    case 114 :
        return /* :: */[
                9,
                /* [] */0
              ];
    case 115 :
        return /* :: */[
                10,
                /* [] */0
              ];
    case 117 :
        return /* :: */[
                11,
                /* :: */[
                  12,
                  /* [] */0
                ]
              ];
    case 118 :
        return /* :: */[
                13,
                /* [] */0
              ];
    case 98 :
    case 103 :
    case 104 :
    case 105 :
    case 106 :
    case 110 :
    case 111 :
    case 113 :
    case 116 :
    case 119 :
        return /* [] */0;
    case 120 :
        return /* :: */[
                14,
                /* :: */[
                  15,
                  /* :: */[
                    16,
                    /* :: */[
                      17,
                      /* :: */[
                        18,
                        /* :: */[
                          19,
                          /* :: */[
                            20,
                            /* :: */[
                              21,
                              /* :: */[
                                22,
                                /* :: */[
                                  23,
                                  /* :: */[
                                    24,
                                    /* :: */[
                                      25,
                                      /* :: */[
                                        30,
                                        /* [] */0
                                      ]
                                    ]
                                  ]
                                ]
                              ]
                            ]
                          ]
                        ]
                      ]
                    ]
                  ]
                ]
              ];
    case 121 :
        return /* :: */[
                26,
                /* [] */0
              ];
    case 122 :
        return /* :: */[
                27,
                /* [] */0
              ];
    default:
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "warnings.ml",
              176,
              9
            ]
          ];
  }
}

var current = {
  contents: {
    active: Caml_array.caml_make_vect(105, true),
    error: Caml_array.caml_make_vect(105, false)
  }
};

function is_active(x) {
  return Caml_array.caml_array_get(current.contents.active, number(x));
}

function parse_opt(error, active, flags, s) {
  var set = function (i) {
    return Caml_array.caml_array_set(flags, i, true);
  };
  var clear = function (i) {
    return Caml_array.caml_array_set(flags, i, false);
  };
  var set_all = function (i) {
    Caml_array.caml_array_set(active, i, true);
    return Caml_array.caml_array_set(error, i, true);
  };
  var get_num = function (_n, _i) {
    while(true) {
      var i = _i;
      var n = _n;
      if (i >= s.length) {
        return /* tuple */[
                i,
                n
              ];
      }
      var match = Caml_string.get(s, i);
      if (match > 57 || match < 48) {
        return /* tuple */[
                i,
                n
              ];
      }
      _i = i + 1 | 0;
      _n = (Caml_int32.imul(10, n) + Caml_string.get(s, i) | 0) - /* "0" */48 | 0;
      continue ;
    };
  };
  var get_range = function (i) {
    var match = get_num(0, i);
    var n1 = match[1];
    var i$1 = match[0];
    if (!((i$1 + 2 | 0) < s.length && Caml_string.get(s, i$1) === /* "." */46 && Caml_string.get(s, i$1 + 1 | 0) === /* "." */46)) {
      return /* tuple */[
              i$1,
              n1,
              n1
            ];
    }
    var match$1 = get_num(0, i$1 + 2 | 0);
    var n2 = match$1[1];
    if (n2 < n1) {
      throw [
            Arg.Bad,
            "Ill-formed list of warnings"
          ];
    }
    return /* tuple */[
            match$1[0],
            n1,
            n2
          ];
  };
  var loop = function (_i) {
    while(true) {
      var i = _i;
      if (i >= s.length) {
        return ;
      }
      var c = Caml_string.get(s, i);
      if (c >= 65) {
        if (c >= 97) {
          if (c >= 123) {
            throw [
                  Arg.Bad,
                  "Ill-formed list of warnings"
                ];
          }
          List.iter(clear, letter(Caml_string.get(s, i)));
          _i = i + 1 | 0;
          continue ;
        } else {
          if (c >= 91) {
            throw [
                  Arg.Bad,
                  "Ill-formed list of warnings"
                ];
          }
          List.iter(set, letter(Char.lowercase(Caml_string.get(s, i))));
          _i = i + 1 | 0;
          continue ;
        }
      } else if (c >= 46) {
        if (c >= 64) {
          return loop_letter_num(set_all, i + 1 | 0);
        }
        throw [
              Arg.Bad,
              "Ill-formed list of warnings"
            ];
      } else {
        if (c < 43) {
          throw [
                Arg.Bad,
                "Ill-formed list of warnings"
              ];
        }
        switch (c - 43 | 0) {
          case 0 :
              return loop_letter_num(set, i + 1 | 0);
          case 1 :
              throw [
                    Arg.Bad,
                    "Ill-formed list of warnings"
                  ];
          case 2 :
              return loop_letter_num(clear, i + 1 | 0);
          
        }
      }
    };
  };
  var loop_letter_num = function (myset, i) {
    if (i >= s.length) {
      throw [
            Arg.Bad,
            "Ill-formed list of warnings"
          ];
    }
    var match = Caml_string.get(s, i);
    if (match >= 65) {
      if (match >= 97) {
        if (match >= 123) {
          throw [
                Arg.Bad,
                "Ill-formed list of warnings"
              ];
        }
        List.iter(myset, letter(Caml_string.get(s, i)));
        return loop(i + 1 | 0);
      } else {
        if (match >= 91) {
          throw [
                Arg.Bad,
                "Ill-formed list of warnings"
              ];
        }
        List.iter(myset, letter(Char.lowercase(Caml_string.get(s, i))));
        return loop(i + 1 | 0);
      }
    } else {
      if (match > 57 || match < 48) {
        throw [
              Arg.Bad,
              "Ill-formed list of warnings"
            ];
      }
      var match$1 = get_range(i);
      for(var n = match$1[1] ,n_finish = Caml_primitive.caml_int_min(match$1[2], 104); n <= n_finish; ++n){
        Curry._1(myset, n);
      }
      return loop(match$1[0]);
    }
  };
  return loop(0);
}

function parse_options(errflag, s) {
  var error = $$Array.copy(current.contents.error);
  var active = $$Array.copy(current.contents.active);
  parse_opt(error, active, errflag ? error : active, s);
  current.contents = {
    active: active,
    error: error
  };
  
}

parse_options(false, "+a-4-6-7-9-27-29-32..39-41..42-44-45-48-50-102");

parse_options(true, "-a");

function message(param) {
  if (typeof param === "number") {
    switch (param) {
      case /* Comment_start */0 :
          return "this is the start of a comment.";
      case /* Comment_not_end */1 :
          return "this is not the end of a comment.";
      case /* Partial_application */2 :
          return "this function application is partial,\nmaybe some arguments are missing.";
      case /* Labels_omitted */3 :
          return "labels were omitted in the application of this function.";
      case /* Statement_type */4 :
          return "this expression should have type unit.";
      case /* Unused_match */5 :
          return "this match case is unused.";
      case /* Unused_pat */6 :
          return "this sub-pattern is unused.";
      case /* Illegal_backslash */7 :
          return "illegal backslash escape in string.";
      case /* Unerasable_optional_argument */8 :
          return "this optional argument cannot be erased.";
      case /* Unused_argument */9 :
          return "this argument will not be used by the function.";
      case /* Nonreturning_statement */10 :
          return "this statement never returns (or has an unsound type.)";
      case /* Useless_record_with */11 :
          return "all the fields are explicitly listed in this record:\nthe 'with' clause is useless.";
      case /* All_clauses_guarded */12 :
          return "bad style, all clauses in this pattern-matching are guarded.";
      case /* Wildcard_arg_to_constant_constr */13 :
          return "wildcard pattern given as argument to a constant constructor";
      case /* Eol_in_string */14 :
          return "unescaped end-of-line in a string constant (non-portable code)";
      case /* Unused_rec_flag */15 :
          return "unused rec flag.";
      case /* Bs_polymorphic_comparison */16 :
          return "polymorphic comparison introduced (maybe unsafe)";
      
    }
  } else {
    switch (param.tag | 0) {
      case /* Deprecated */0 :
          return "deprecated: " + param[0];
      case /* Fragile_match */1 :
          var s = param[0];
          if (s === "") {
            return "this pattern-matching is fragile.";
          } else {
            return "this pattern-matching is fragile.\nIt will remain exhaustive when constructors are added to type " + (s + ".");
          }
      case /* Method_override */2 :
          var match = param[0];
          if (!match) {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  /* tuple */[
                    "warnings.ml",
                    283,
                    26
                  ]
                ];
          }
          var slist = match[1];
          var lab = match[0];
          if (slist) {
            return $$String.concat(" ", /* :: */[
                        "the following methods are overridden by the class",
                        /* :: */[
                          lab,
                          /* :: */[
                            ":\n ",
                            slist
                          ]
                        ]
                      ]);
          } else {
            return "the method " + (lab + " is overridden.");
          }
      case /* Partial_match */3 :
          var s$1 = param[0];
          if (s$1 === "") {
            return "this pattern-matching is not exhaustive.";
          } else {
            return "this pattern-matching is not exhaustive.\nHere is an example of a value that is not matched:\n" + s$1;
          }
      case /* Non_closed_record_pattern */4 :
          return "the following labels are not bound in this record pattern:\n" + (param[0] + "\nEither bind these labels explicitly or add '; _' to the pattern.");
      case /* Instance_variable_override */5 :
          var match$1 = param[0];
          if (!match$1) {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  /* tuple */[
                    "warnings.ml",
                    303,
                    37
                  ]
                ];
          }
          var slist$1 = match$1[1];
          var lab$1 = match$1[0];
          if (slist$1) {
            return $$String.concat(" ", /* :: */[
                        "the following instance variables are overridden by the class",
                        /* :: */[
                          lab$1,
                          /* :: */[
                            ":\n ",
                            slist$1
                          ]
                        ]
                      ]) + "\nThe behaviour changed in ocaml 3.10 (previous behaviour was hiding.)";
          } else {
            return "the instance variable " + (lab$1 + " is overridden.\nThe behaviour changed in ocaml 3.10 (previous behaviour was hiding.)");
          }
      case /* Implicit_public_methods */6 :
          return "the following private methods were made public implicitly:\n " + ($$String.concat(" ", param[0]) + ".");
      case /* Undeclared_virtual_method */7 :
          return "the virtual method " + (param[0] + " is not declared.");
      case /* Not_principal */8 :
          return param[0] + " is not principal.";
      case /* Without_principality */9 :
          return param[0] + " without principality.";
      case /* Preprocessor */10 :
          return param[0];
      case /* Bad_module_name */11 :
          return "bad source file name: \"" + (param[0] + "\" is not a valid module name.");
      case /* Unused_var */12 :
      case /* Unused_var_strict */13 :
          return "unused variable " + (param[0] + ".");
      case /* Duplicate_definitions */14 :
          return Curry._4(Printf.sprintf(/* Format */[
                          /* String_literal */Block.__(11, [
                              "the ",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* Char_literal */Block.__(12, [
                                      /* " " */32,
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* String_literal */Block.__(11, [
                                              " is defined in both types ",
                                              /* String */Block.__(2, [
                                                  /* No_padding */0,
                                                  /* String_literal */Block.__(11, [
                                                      " and ",
                                                      /* String */Block.__(2, [
                                                          /* No_padding */0,
                                                          /* Char_literal */Block.__(12, [
                                                              /* "." */46,
                                                              /* End_of_format */0
                                                            ])
                                                        ])
                                                    ])
                                                ])
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "the %s %s is defined in both types %s and %s."
                        ]), param[0], param[1], param[2], param[3]);
      case /* Multiple_definition */15 :
          return Curry._3(Printf.sprintf(/* Format */[
                          /* String_literal */Block.__(11, [
                              "files ",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* String_literal */Block.__(11, [
                                      " and ",
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* String_literal */Block.__(11, [
                                              " both define a module named ",
                                              /* String */Block.__(2, [
                                                  /* No_padding */0,
                                                  /* End_of_format */0
                                                ])
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "files %s and %s both define a module named %s"
                        ]), param[1], param[2], param[0]);
      case /* Unused_value_declaration */16 :
          return "unused value " + (param[0] + ".");
      case /* Unused_open */17 :
          return "unused open " + (param[0] + ".");
      case /* Unused_type_declaration */18 :
          return "unused type " + (param[0] + ".");
      case /* Unused_for_index */19 :
          return "unused for-loop index " + (param[0] + ".");
      case /* Unused_ancestor */20 :
          return "unused ancestor variable " + (param[0] + ".");
      case /* Unused_constructor */21 :
          var s$2 = param[0];
          if (param[1]) {
            return "constructor " + (s$2 + " is never used to build values.\n(However, this constructor appears in patterns.)");
          } else if (param[2]) {
            return "constructor " + (s$2 + " is never used to build values.\nIts type is exported as a private type.");
          } else {
            return "unused constructor " + (s$2 + ".");
          }
      case /* Unused_extension */22 :
          var s$3 = param[0];
          if (param[1]) {
            return "extension constructor " + (s$3 + " is never used to build values.\n(However, this constructor appears in patterns.)");
          } else if (param[2]) {
            return "extension constructor " + (s$3 + " is never used to build values.\nIt is exported or rebound as a private extension.");
          } else {
            return "unused extension constructor " + (s$3 + ".");
          }
      case /* Name_out_of_scope */23 :
          var slist$2 = param[1];
          var ty = param[0];
          if (slist$2 && !slist$2[1] && !param[2]) {
            return slist$2[0] + (" was selected from type " + (ty + ".\nIt is not visible in the current scope, and will not \nbe selected if the type becomes unknown."));
          }
          if (param[2]) {
            return "this record of type " + (ty + (" contains fields that are \nnot visible in the current scope: " + ($$String.concat(" ", slist$2) + ".\nThey will not be selected if the type becomes unknown.")));
          }
          throw [
                Caml_builtin_exceptions.assert_failure,
                /* tuple */[
                  "warnings.ml",
                  365,
                  39
                ]
              ];
          break;
      case /* Ambiguous_name */24 :
          var slist$3 = param[0];
          if (slist$3 && !slist$3[1] && !param[2]) {
            return slist$3[0] + (" belongs to several types: " + ($$String.concat(" ", param[1]) + "\nThe first one was selected. Please disambiguate if this is wrong."));
          }
          if (param[2]) {
            return "these field labels belong to several types: " + ($$String.concat(" ", param[1]) + "\nThe first one was selected. Please disambiguate if this is wrong.");
          }
          throw [
                Caml_builtin_exceptions.assert_failure,
                /* tuple */[
                  "warnings.ml",
                  374,
                  36
                ]
              ];
          break;
      case /* Disambiguated_name */25 :
          return "this use of " + (param[0] + " required disambiguation.");
      case /* Nonoptional_label */26 :
          return "the label " + (param[0] + " is not optional.");
      case /* Open_shadow_identifier */27 :
          return Curry._2(Printf.sprintf(/* Format */[
                          /* String_literal */Block.__(11, [
                              "this open statement shadows the ",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* String_literal */Block.__(11, [
                                      " identifier ",
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* String_literal */Block.__(11, [
                                              " (which is later used)",
                                              /* End_of_format */0
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "this open statement shadows the %s identifier %s (which is later used)"
                        ]), param[0], param[1]);
      case /* Open_shadow_label_constructor */28 :
          return Curry._2(Printf.sprintf(/* Format */[
                          /* String_literal */Block.__(11, [
                              "this open statement shadows the ",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* Char_literal */Block.__(12, [
                                      /* " " */32,
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* String_literal */Block.__(11, [
                                              " (which is later used)",
                                              /* End_of_format */0
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "this open statement shadows the %s %s (which is later used)"
                        ]), param[0], param[1]);
      case /* Bad_env_variable */29 :
          return Curry._2(Printf.sprintf(/* Format */[
                          /* String_literal */Block.__(11, [
                              "illegal environment variable ",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* String_literal */Block.__(11, [
                                      " : ",
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* End_of_format */0
                                        ])
                                    ])
                                ])
                            ]),
                          "illegal environment variable %s : %s"
                        ]), param[0], param[1]);
      case /* Attribute_payload */30 :
          return Curry._2(Printf.sprintf(/* Format */[
                          /* String_literal */Block.__(11, [
                              "illegal payload for attribute '",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* String_literal */Block.__(11, [
                                      "'.\n",
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* End_of_format */0
                                        ])
                                    ])
                                ])
                            ]),
                          "illegal payload for attribute '%s'.\n%s"
                        ]), param[0], param[1]);
      case /* Eliminated_optional_arguments */31 :
          var sl = param[0];
          return Curry._2(Printf.sprintf(/* Format */[
                          /* String_literal */Block.__(11, [
                              "implicit elimination of optional argument",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* Char_literal */Block.__(12, [
                                      /* " " */32,
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* End_of_format */0
                                        ])
                                    ])
                                ])
                            ]),
                          "implicit elimination of optional argument%s %s"
                        ]), List.length(sl) === 1 ? "" : "s", $$String.concat(", ", sl));
      case /* No_cmi_file */32 :
          return "no cmi file was found in path for module " + param[0];
      case /* Bad_docstring */33 :
          if (param[0]) {
            return "unattached documentation comment (ignored)";
          } else {
            return "ambiguous documentation comment";
          }
      case /* Bs_unused_attribute */34 :
          return "Unused BuckleScript attribute: " + param[0];
      case /* Bs_ffi_warning */35 :
          return "BuckleScript FFI warning: " + param[0];
      case /* Bs_derive_warning */36 :
          return "BuckleScript bs.deriving warning: " + param[0];
      
    }
  }
}

var nerrors = {
  contents: 0
};

function print(ppf, w) {
  var msg = message(w);
  var num = number(w);
  Curry._2(Format.fprintf(ppf, /* Format */[
            /* Int */Block.__(4, [
                /* Int_d */0,
                /* No_padding */0,
                /* No_precision */0,
                /* String_literal */Block.__(11, [
                    ": ",
                    /* String */Block.__(2, [
                        /* No_padding */0,
                        /* End_of_format */0
                      ])
                  ])
              ]),
            "%d: %s"
          ]), num, msg);
  Format.pp_print_flush(ppf, void 0);
  if (Caml_array.caml_array_get(current.contents.error, num)) {
    nerrors.contents = nerrors.contents + 1 | 0;
    return ;
  }
  
}

var Errors = Caml_exceptions.create("Ocaml_typedtree_test.Warnings.Errors");

var absname = {
  contents: false
};

function in_file(name) {
  var loc = {
    pos_fname: name,
    pos_lnum: 1,
    pos_bol: 0,
    pos_cnum: -1
  };
  return {
          loc_start: loc,
          loc_end: loc,
          loc_ghost: true
        };
}

var none = in_file("_none_");

function curr(lexbuf) {
  return {
          loc_start: lexbuf.lex_start_p,
          loc_end: lexbuf.lex_curr_p,
          loc_ghost: false
        };
}

function symbol_rloc(param) {
  return {
          loc_start: Parsing.symbol_start_pos(void 0),
          loc_end: Parsing.symbol_end_pos(void 0),
          loc_ghost: false
        };
}

function symbol_gloc(param) {
  return {
          loc_start: Parsing.symbol_start_pos(void 0),
          loc_end: Parsing.symbol_end_pos(void 0),
          loc_ghost: true
        };
}

function rhs_loc(n) {
  return {
          loc_start: Parsing.rhs_start_pos(n),
          loc_end: Parsing.rhs_end_pos(n),
          loc_ghost: false
        };
}

var input_name = {
  contents: "_none_"
};

var input_lexbuf = {
  contents: void 0
};

var status = {
  contents: /* Uninitialised */0
};

var num_loc_lines = {
  contents: 0
};

function highlight_terminfo(ppf, num_lines, lb, locs) {
  Format.pp_print_flush(ppf, void 0);
  var pos0 = -lb.lex_abs_pos | 0;
  if (pos0 < 0) {
    throw Pervasives.Exit;
  }
  var lines = num_loc_lines.contents;
  for(var i = pos0 ,i_finish = lb.lex_buffer_len - 1 | 0; i <= i_finish; ++i){
    if (Caml_bytes.get(lb.lex_buffer, i) === /* "\n" */10) {
      lines = lines + 1 | 0;
    }
    
  }
  if (lines >= (num_lines - 2 | 0)) {
    throw Pervasives.Exit;
  }
  Caml_io.caml_ml_flush(Pervasives.stdout);
  Caml_external_polyfill.resolve("caml_terminfo_backup")(lines);
  var bol = false;
  Pervasives.print_string("# ");
  for(var pos = 0 ,pos_finish = (lb.lex_buffer_len - pos0 | 0) - 1 | 0; pos <= pos_finish; ++pos){
    if (bol) {
      Pervasives.print_string("  ");
      bol = false;
    }
    if (List.exists((function(pos){
          return function (loc) {
            return pos === loc.loc_start.pos_cnum;
          }
          }(pos)), locs)) {
      Caml_external_polyfill.resolve("caml_terminfo_standout")(true);
    }
    if (List.exists((function(pos){
          return function (loc) {
            return pos === loc.loc_end.pos_cnum;
          }
          }(pos)), locs)) {
      Caml_external_polyfill.resolve("caml_terminfo_standout")(false);
    }
    var c = Caml_bytes.get(lb.lex_buffer, pos + pos0 | 0);
    Pervasives.print_char(c);
    bol = c === /* "\n" */10;
  }
  Caml_external_polyfill.resolve("caml_terminfo_standout")(false);
  Caml_external_polyfill.resolve("caml_terminfo_resume")(num_loc_lines.contents);
  return Caml_io.caml_ml_flush(Pervasives.stdout);
}

function highlight_dumb(ppf, lb, loc) {
  var pos0 = -lb.lex_abs_pos | 0;
  if (pos0 < 0) {
    throw Pervasives.Exit;
  }
  var end_pos = (lb.lex_buffer_len - pos0 | 0) - 1 | 0;
  var line_start = 0;
  var line_end = 0;
  for(var pos = 0; pos <= end_pos; ++pos){
    if (Caml_bytes.get(lb.lex_buffer, pos + pos0 | 0) === /* "\n" */10) {
      if (loc.loc_start.pos_cnum > pos) {
        line_start = line_start + 1 | 0;
      }
      if (loc.loc_end.pos_cnum > pos) {
        line_end = line_end + 1 | 0;
      }
      
    }
    
  }
  Curry._2(Format.fprintf(ppf, /* Format */[
            /* String_literal */Block.__(11, [
                "Characters ",
                /* Int */Block.__(4, [
                    /* Int_i */3,
                    /* No_padding */0,
                    /* No_precision */0,
                    /* Char_literal */Block.__(12, [
                        /* "-" */45,
                        /* Int */Block.__(4, [
                            /* Int_i */3,
                            /* No_padding */0,
                            /* No_precision */0,
                            /* Char_literal */Block.__(12, [
                                /* ":" */58,
                                /* Formatting_lit */Block.__(17, [
                                    /* Flush_newline */4,
                                    /* End_of_format */0
                                  ])
                              ])
                          ])
                      ])
                  ])
              ]),
            "Characters %i-%i:@."
          ]), loc.loc_start.pos_cnum, loc.loc_end.pos_cnum);
  Format.pp_print_string(ppf, "  ");
  var line = 0;
  var pos_at_bol = 0;
  for(var pos$1 = 0; pos$1 <= end_pos; ++pos$1){
    var c = Caml_bytes.get(lb.lex_buffer, pos$1 + pos0 | 0);
    if (c !== 10) {
      if (c !== 13) {
        if (line === line_start && line === line_end) {
          Format.pp_print_char(ppf, c);
        } else if (line === line_start) {
          if (pos$1 < loc.loc_start.pos_cnum) {
            Format.pp_print_char(ppf, /* "." */46);
          } else {
            Format.pp_print_char(ppf, c);
          }
        } else if (line === line_end) {
          if (pos$1 < loc.loc_end.pos_cnum) {
            Format.pp_print_char(ppf, c);
          } else {
            Format.pp_print_char(ppf, /* "." */46);
          }
        } else if (line > line_start && line < line_end) {
          Format.pp_print_char(ppf, c);
        }
        
      }
      
    } else {
      if (line === line_start && line === line_end) {
        Format.fprintf(ppf, /* Format */[
              /* Formatting_lit */Block.__(17, [
                  /* Flush_newline */4,
                  /* String_literal */Block.__(11, [
                      "  ",
                      /* End_of_format */0
                    ])
                ]),
              "@.  "
            ]);
        for(var _i = pos_at_bol ,_i_finish = loc.loc_start.pos_cnum - 1 | 0; _i <= _i_finish; ++_i){
          Format.pp_print_char(ppf, /* " " */32);
        }
        for(var _i$1 = loc.loc_start.pos_cnum ,_i_finish$1 = loc.loc_end.pos_cnum - 1 | 0; _i$1 <= _i_finish$1; ++_i$1){
          Format.pp_print_char(ppf, /* "^" */94);
        }
      }
      if (line >= line_start && line <= line_end) {
        Format.fprintf(ppf, /* Format */[
              /* Formatting_lit */Block.__(17, [
                  /* Flush_newline */4,
                  /* End_of_format */0
                ]),
              "@."
            ]);
        if (pos$1 < loc.loc_end.pos_cnum) {
          Format.pp_print_string(ppf, "  ");
        }
        
      }
      line = line + 1 | 0;
      pos_at_bol = pos$1 + 1 | 0;
    }
  }
  
}

function highlight_locations(ppf, locs) {
  while(true) {
    var match = status.contents;
    if (typeof match === "number") {
      if (match !== 0) {
        var match$1 = input_lexbuf.contents;
        if (match$1 === void 0) {
          return false;
        }
        var norepeat;
        try {
          norepeat = Caml_sys.caml_sys_getenv("TERM") === "norepeat";
        }
        catch (exn){
          if (exn !== Caml_builtin_exceptions.not_found) {
            throw exn;
          }
          norepeat = false;
        }
        if (norepeat) {
          return false;
        }
        var loc1 = List.hd(locs);
        try {
          highlight_dumb(ppf, match$1, loc1);
          return true;
        }
        catch (exn$1){
          if (exn$1 === Pervasives.Exit) {
            return false;
          }
          throw exn$1;
        }
      } else {
        status.contents = Caml_external_polyfill.resolve("caml_terminfo_setup")(Pervasives.stdout);
        continue ;
      }
    } else {
      var match$2 = input_lexbuf.contents;
      if (match$2 === void 0) {
        return false;
      }
      try {
        highlight_terminfo(ppf, match[0], match$2, locs);
        return true;
      }
      catch (exn$2){
        if (exn$2 === Pervasives.Exit) {
          return false;
        }
        throw exn$2;
      }
    }
  };
}

function show_filename(file) {
  if (absname.contents) {
    var s = Curry._1(Filename.is_relative, file) ? Filename.concat(Caml_sys.caml_sys_getcwd(void 0), file) : file;
    var aux = function (_s) {
      while(true) {
        var s = _s;
        var base = Curry._1(Filename.basename, s);
        var dir = Curry._1(Filename.dirname, s);
        if (dir === s) {
          return dir;
        }
        if (base !== Filename.current_dir_name) {
          if (base === Filename.parent_dir_name) {
            return Curry._1(Filename.dirname, aux(dir));
          } else {
            return Filename.concat(aux(dir), base);
          }
        }
        _s = dir;
        continue ;
      };
    };
    return aux(s);
  } else {
    return file;
  }
}

function print_filename(ppf, file) {
  return Curry._1(Format.fprintf(ppf, /* Format */[
                  /* String */Block.__(2, [
                      /* No_padding */0,
                      /* End_of_format */0
                    ]),
                  "%s"
                ]), show_filename(file));
}

function get_pos_info(pos) {
  return /* tuple */[
          pos.pos_fname,
          pos.pos_lnum,
          pos.pos_cnum - pos.pos_bol | 0
        ];
}

function print_loc(ppf, loc) {
  Curry._1(Misc_Color.setup, color.contents);
  var match = get_pos_info(loc.loc_start);
  var startchar = match[2];
  var file = match[0];
  var startchar$1 = bs_vscode ? startchar + 1 | 0 : startchar;
  var endchar = (loc.loc_end.pos_cnum - loc.loc_start.pos_cnum | 0) + startchar$1 | 0;
  if (file === "//toplevel//") {
    if (highlight_locations(ppf, /* :: */[
            loc,
            /* [] */0
          ])) {
      return ;
    } else {
      return Curry._2(Format.fprintf(ppf, /* Format */[
                      /* String_literal */Block.__(11, [
                          "Characters ",
                          /* Int */Block.__(4, [
                              /* Int_i */3,
                              /* No_padding */0,
                              /* No_precision */0,
                              /* Char_literal */Block.__(12, [
                                  /* "-" */45,
                                  /* Int */Block.__(4, [
                                      /* Int_i */3,
                                      /* No_padding */0,
                                      /* No_precision */0,
                                      /* End_of_format */0
                                    ])
                                ])
                            ])
                        ]),
                      "Characters %i-%i"
                    ]), loc.loc_start.pos_cnum, loc.loc_end.pos_cnum);
    }
  } else {
    Curry._5(Format.fprintf(ppf, /* Format */[
              /* String */Block.__(2, [
                  /* No_padding */0,
                  /* Formatting_gen */Block.__(18, [
                      /* Open_tag */Block.__(0, [/* Format */[
                            /* String_literal */Block.__(11, [
                                "<loc>",
                                /* End_of_format */0
                              ]),
                            "<loc>"
                          ]]),
                      /* Alpha */Block.__(15, [/* String */Block.__(2, [
                              /* No_padding */0,
                              /* Int */Block.__(4, [
                                  /* Int_i */3,
                                  /* No_padding */0,
                                  /* No_precision */0,
                                  /* End_of_format */0
                                ])
                            ])])
                    ])
                ]),
              "%s@{<loc>%a%s%i"
            ]), "File \"", print_filename, file, "\", line ", match[1]);
    if (startchar$1 >= 0) {
      Curry._4(Format.fprintf(ppf, /* Format */[
                /* String */Block.__(2, [
                    /* No_padding */0,
                    /* Int */Block.__(4, [
                        /* Int_i */3,
                        /* No_padding */0,
                        /* No_precision */0,
                        /* String */Block.__(2, [
                            /* No_padding */0,
                            /* Int */Block.__(4, [
                                /* Int_i */3,
                                /* No_padding */0,
                                /* No_precision */0,
                                /* End_of_format */0
                              ])
                          ])
                      ])
                  ]),
                "%s%i%s%i"
              ]), ", characters ", startchar$1, "-", endchar);
    }
    return Format.fprintf(ppf, /* Format */[
                /* Formatting_lit */Block.__(17, [
                    /* Close_tag */1,
                    /* End_of_format */0
                  ]),
                "@}"
              ]);
  }
}

function print$1(ppf, loc) {
  Curry._1(Misc_Color.setup, color.contents);
  if (loc.loc_start.pos_fname === "//toplevel//" && highlight_locations(ppf, /* :: */[
          loc,
          /* [] */0
        ])) {
    return ;
  } else {
    return Curry._3(Format.fprintf(ppf, /* Format */[
                    /* Formatting_gen */Block.__(18, [
                        /* Open_tag */Block.__(0, [/* Format */[
                              /* String_literal */Block.__(11, [
                                  "<loc>",
                                  /* End_of_format */0
                                ]),
                              "<loc>"
                            ]]),
                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                /* Close_tag */1,
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* Formatting_lit */Block.__(17, [
                                        /* Flush_newline */4,
                                        /* End_of_format */0
                                      ])
                                  ])
                              ])])
                      ]),
                    "@{<loc>%a@}%s@."
                  ]), print_loc, loc, ":");
  }
}

var error_prefix = "Error";

function print_error(ppf, loc) {
  print$1(ppf, loc);
  var param;
  Curry._1(Misc_Color.setup, color.contents);
  Curry._1(Format.fprintf(ppf, /* Format */[
            /* Formatting_gen */Block.__(18, [
                /* Open_tag */Block.__(0, [/* Format */[
                      /* String_literal */Block.__(11, [
                          "<error>",
                          /* End_of_format */0
                        ]),
                      "<error>"
                    ]]),
                /* String */Block.__(2, [
                    /* No_padding */0,
                    /* Formatting_lit */Block.__(17, [
                        /* Close_tag */1,
                        /* Char_literal */Block.__(12, [
                            /* ":" */58,
                            /* End_of_format */0
                          ])
                      ])
                  ])
              ]),
            "@{<error>%s@}:"
          ]), error_prefix);
  
}

function default_warning_printer(loc, ppf, w) {
  if (is_active(w)) {
    Curry._1(Misc_Color.setup, color.contents);
    print$1(ppf, loc);
    return Curry._3(Format.fprintf(ppf, /* Format */[
                    /* Formatting_gen */Block.__(18, [
                        /* Open_tag */Block.__(0, [/* Format */[
                              /* String_literal */Block.__(11, [
                                  "<warning>",
                                  /* End_of_format */0
                                ]),
                              "<warning>"
                            ]]),
                        /* String */Block.__(2, [
                            /* No_padding */0,
                            /* Formatting_lit */Block.__(17, [
                                /* Close_tag */1,
                                /* Char_literal */Block.__(12, [
                                    /* " " */32,
                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                            /* Flush_newline */4,
                                            /* End_of_format */0
                                          ])])
                                  ])
                              ])
                          ])
                      ]),
                    "@{<warning>%s@} %a@."
                  ]), "Warning", print, w);
  }
  
}

var warning_printer = {
  contents: default_warning_printer
};

var formatter_for_warnings = {
  contents: Format.err_formatter
};

function prerr_warning(loc, w) {
  var ppf = formatter_for_warnings.contents;
  var f = Curry._1(warning_printer.contents, loc);
  var out_functions = Format.pp_get_formatter_out_functions(ppf, void 0);
  var out_string = function (str, start, len) {
    var count = function (_i, _c) {
      while(true) {
        var c = _c;
        var i = _i;
        if (i === (start + len | 0)) {
          return c;
        }
        if (Caml_string.get(str, i) === /* "\n" */10) {
          _c = c + 1 | 0;
          _i = i + 1 | 0;
          continue ;
        } else {
          _i = i + 1 | 0;
          continue ;
        }
      };
    };
    num_loc_lines.contents = num_loc_lines.contents + count(start, 0) | 0;
    return Curry._3(out_functions.out_string, str, start, len);
  };
  Format.pp_set_formatter_out_functions(ppf, {
        out_string: out_string,
        out_flush: out_functions.out_flush,
        out_newline: out_functions.out_newline,
        out_spaces: out_functions.out_spaces,
        out_indent: out_functions.out_indent
      });
  Curry._2(f, ppf, w);
  Format.pp_print_flush(ppf, void 0);
  return Format.pp_set_formatter_out_functions(ppf, out_functions);
}

function print_phanton_error_prefix(ppf) {
  return Format.pp_print_as(ppf, error_prefix.length + 2 | 0, "");
}

function errorf(locOpt, subOpt, if_highlightOpt, fmt) {
  var loc = locOpt !== void 0 ? locOpt : none;
  var sub = subOpt !== void 0 ? subOpt : /* [] */0;
  var if_highlight = if_highlightOpt !== void 0 ? if_highlightOpt : "";
  var before = print_phanton_error_prefix;
  var k = function (msg) {
    return {
            loc: loc,
            msg: msg,
            sub: sub,
            if_highlight: if_highlight
          };
  };
  var buf = $$Buffer.create(64);
  var ppf = Format.formatter_of_buffer(buf);
  Curry._1(Misc_Color.set_color_tag_handling, ppf);
  if (before !== void 0) {
    Curry._1(before, ppf);
  }
  return Format.kfprintf((function (param) {
                Format.pp_print_flush(ppf, void 0);
                return Curry._1(k, $$Buffer.contents(buf));
              }), ppf, fmt);
}

function error(locOpt, subOpt, if_highlightOpt, msg) {
  var loc = locOpt !== void 0 ? locOpt : none;
  var sub = subOpt !== void 0 ? subOpt : /* [] */0;
  var if_highlight = if_highlightOpt !== void 0 ? if_highlightOpt : "";
  return {
          loc: loc,
          msg: msg,
          sub: sub,
          if_highlight: if_highlight
        };
}

var error_of_exn = {
  contents: /* [] */0
};

function register_error_of_exn(f) {
  error_of_exn.contents = /* :: */[
    f,
    error_of_exn.contents
  ];
  
}

function error_of_printer(loc, print, x) {
  return Curry._2(errorf(loc, void 0, void 0, /* Format */[
                  /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                          /* FFlush */2,
                          /* End_of_format */0
                        ])]),
                  "%a@?"
                ]), print, x);
}

function error_of_printer_file(print, x) {
  return error_of_printer(in_file(input_name.contents), print, x);
}

register_error_of_exn((function (param) {
        if (param[0] === Caml_builtin_exceptions.sys_error) {
          return Curry._1(errorf(in_file(input_name.contents), void 0, void 0, /* Format */[
                          /* String_literal */Block.__(11, [
                              "I/O error: ",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* End_of_format */0
                                ])
                            ]),
                          "I/O error: %s"
                        ]), param[1]);
        } else if (param[0] === Errors) {
          return Curry._1(errorf(in_file(input_name.contents), void 0, void 0, /* Format */[
                          /* String_literal */Block.__(11, [
                              "Some fatal warnings were triggered (",
                              /* Int */Block.__(4, [
                                  /* Int_d */0,
                                  /* No_padding */0,
                                  /* No_precision */0,
                                  /* String_literal */Block.__(11, [
                                      " occurrences)",
                                      /* End_of_format */0
                                    ])
                                ])
                            ]),
                          "Some fatal warnings were triggered (%d occurrences)"
                        ]), param[1]);
        } else {
          return ;
        }
      }));

var $$Error = Caml_exceptions.create("Ocaml_typedtree_test.Location.Error");

register_error_of_exn((function (param) {
        if (param[0] === $$Error) {
          return param[1];
        }
        
      }));

var currentstamp = {
  contents: 0
};

function create(s) {
  currentstamp.contents = currentstamp.contents + 1 | 0;
  return {
          stamp: currentstamp.contents,
          name: s,
          flags: 0
        };
}

function create_predef_exn(s) {
  currentstamp.contents = currentstamp.contents + 1 | 0;
  return {
          stamp: currentstamp.contents,
          name: s,
          flags: 2
        };
}

function rename(i) {
  currentstamp.contents = currentstamp.contents + 1 | 0;
  return {
          stamp: currentstamp.contents,
          name: i.name,
          flags: i.flags
        };
}

function unique_toplevel_name(i) {
  return i.name + ("/" + String(i.stamp));
}

function equal(i1, i2) {
  return i1.name === i2.name;
}

function set_current_time(t) {
  currentstamp.contents = currentstamp.contents > t ? currentstamp.contents : t;
  
}

function hide(i) {
  return {
          stamp: -1,
          name: i.name,
          flags: i.flags
        };
}

function make_global(i) {
  i.flags = i.flags | 1;
  
}

function $$global(i) {
  return (i.flags & 1) !== 0;
}

function print$2(ppf, i) {
  var n = i.stamp;
  if (n !== -1) {
    if (n !== 0) {
      return Curry._3(Format.fprintf(ppf, /* Format */[
                      /* String */Block.__(2, [
                          /* No_padding */0,
                          /* Char_literal */Block.__(12, [
                              /* "/" */47,
                              /* Int */Block.__(4, [
                                  /* Int_i */3,
                                  /* No_padding */0,
                                  /* No_precision */0,
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* End_of_format */0
                                    ])
                                ])
                            ])
                        ]),
                      "%s/%i%s"
                    ]), i.name, n, $$global(i) ? "g" : "");
    } else {
      return Curry._1(Format.fprintf(ppf, /* Format */[
                      /* String */Block.__(2, [
                          /* No_padding */0,
                          /* Char_literal */Block.__(12, [
                              /* "!" */33,
                              /* End_of_format */0
                            ])
                        ]),
                      "%s!"
                    ]), i.name);
    }
  } else {
    return Curry._1(Format.fprintf(ppf, /* Format */[
                    /* String */Block.__(2, [
                        /* No_padding */0,
                        /* Char_literal */Block.__(12, [
                            /* "#" */35,
                            /* End_of_format */0
                          ])
                      ]),
                    "%s#"
                  ]), i.name);
  }
}

function mknode(l, d, r) {
  var hl = l ? l[3] : 0;
  var hr = r ? r[3] : 0;
  return /* Node */[
          l,
          d,
          r,
          hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        ];
}

function balance(l, d, r) {
  var hl = l ? l[3] : 0;
  var hr = r ? r[3] : 0;
  if (hl > (hr + 1 | 0)) {
    if (!l) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "ident.ml",
              120,
              11
            ]
          ];
    }
    var lr = l[2];
    var ld = l[1];
    var ll = l[0];
    if ((
        ll ? ll[3] : 0
      ) >= (
        lr ? lr[3] : 0
      )) {
      return mknode(ll, ld, mknode(lr, d, r));
    }
    if (lr) {
      return mknode(mknode(ll, ld, lr[0]), lr[1], mknode(lr[2], d, r));
    }
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "ident.ml",
            120,
            11
          ]
        ];
  } else {
    if (hr <= (hl + 1 | 0)) {
      return mknode(l, d, r);
    }
    if (!r) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "ident.ml",
              129,
              11
            ]
          ];
    }
    var rl = r[0];
    var rr = r[2];
    if ((
        rr ? rr[3] : 0
      ) >= (
        rl ? rl[3] : 0
      )) {
      return mknode(mknode(l, d, rl), r[1], rr);
    }
    if (rl) {
      return mknode(mknode(l, d, rl[0]), rl[1], mknode(rl[2], r[1], r[2]));
    }
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "ident.ml",
            129,
            11
          ]
        ];
  }
}

function add(id, data, param) {
  if (!param) {
    return /* Node */[
            /* Empty */0,
            {
              ident: id,
              data: data,
              previous: void 0
            },
            /* Empty */0,
            1
          ];
  }
  var r = param[2];
  var k = param[1];
  var l = param[0];
  var c = Caml_primitive.caml_string_compare(id.name, k.ident.name);
  if (c === 0) {
    return /* Node */[
            l,
            {
              ident: id,
              data: data,
              previous: k
            },
            r,
            param[3]
          ];
  } else if (c < 0) {
    return balance(add(id, data, l), k, r);
  } else {
    return balance(l, k, add(id, data, r));
  }
}

function find_same(id, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      throw Caml_builtin_exceptions.not_found;
    }
    var k = param[1];
    var c = Caml_primitive.caml_string_compare(id.name, k.ident.name);
    if (c === 0) {
      if (id.stamp === k.ident.stamp) {
        return k.data;
      } else {
        var s = id.stamp;
        var _param$1 = k.previous;
        while(true) {
          var param$1 = _param$1;
          if (param$1 === void 0) {
            throw Caml_builtin_exceptions.not_found;
          }
          var k$1 = param$1;
          if (k$1.ident.stamp === s) {
            return k$1.data;
          }
          _param$1 = k$1.previous;
          continue ;
        };
      }
    }
    _param = c < 0 ? param[0] : param[2];
    continue ;
  };
}

function find_name(name, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      throw Caml_builtin_exceptions.not_found;
    }
    var k = param[1];
    var c = Caml_primitive.caml_string_compare(name, k.ident.name);
    if (c === 0) {
      return k.data;
    }
    _param = c < 0 ? param[0] : param[2];
    continue ;
  };
}

function get_all(param) {
  if (param === void 0) {
    return /* [] */0;
  }
  var k = param;
  return /* :: */[
          k.data,
          get_all(k.previous)
        ];
}

function find_all(name, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return /* [] */0;
    }
    var k = param[1];
    var c = Caml_primitive.caml_string_compare(name, k.ident.name);
    if (c === 0) {
      return /* :: */[
              k.data,
              get_all(k.previous)
            ];
    }
    _param = c < 0 ? param[0] : param[2];
    continue ;
  };
}

function iter(f, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return ;
    }
    var k = param[1];
    iter(f, param[0]);
    Curry._2(f, k.ident, k.data);
    _param = param[2];
    continue ;
  };
}

function same(_p1, _p2) {
  while(true) {
    var p2 = _p2;
    var p1 = _p1;
    switch (p1.tag | 0) {
      case /* Pident */0 :
          switch (p2.tag | 0) {
            case /* Pident */0 :
                return Caml_obj.caml_equal(p1[0], p2[0]);
            case /* Pdot */1 :
            case /* Papply */2 :
                return false;
            
          }
      case /* Pdot */1 :
          switch (p2.tag | 0) {
            case /* Pdot */1 :
                if (p1[1] !== p2[1]) {
                  return false;
                }
                _p2 = p2[0];
                _p1 = p1[0];
                continue ;
            case /* Pident */0 :
            case /* Papply */2 :
                return false;
            
          }
      case /* Papply */2 :
          switch (p2.tag | 0) {
            case /* Pident */0 :
            case /* Pdot */1 :
                return false;
            case /* Papply */2 :
                if (!same(p1[0], p2[0])) {
                  return false;
                }
                _p2 = p2[1];
                _p1 = p1[1];
                continue ;
            
          }
      
    }
  };
}

function isfree(id, _param) {
  while(true) {
    var param = _param;
    switch (param.tag | 0) {
      case /* Pident */0 :
          return Caml_obj.caml_equal(id, param[0]);
      case /* Pdot */1 :
          _param = param[0];
          continue ;
      case /* Papply */2 :
          if (isfree(id, param[0])) {
            return true;
          }
          _param = param[1];
          continue ;
      
    }
  };
}

function binding_time(_param) {
  while(true) {
    var param = _param;
    switch (param.tag | 0) {
      case /* Pident */0 :
          return param[0].stamp;
      case /* Pdot */1 :
          _param = param[0];
          continue ;
      case /* Papply */2 :
          return Caml_primitive.caml_int_max(binding_time(param[0]), binding_time(param[1]));
      
    }
  };
}

function kfalse(x) {
  return false;
}

function name($staropt$star, param) {
  var paren = $staropt$star !== void 0 ? $staropt$star : kfalse;
  switch (param.tag | 0) {
    case /* Pident */0 :
        return param[0].name;
    case /* Pdot */1 :
        var s = param[1];
        return name(paren, param[0]) + (
                Curry._1(paren, s) ? ".( " + (s + " )") : "." + s
              );
    case /* Papply */2 :
        return name(paren, param[0]) + ("(" + (name(paren, param[1]) + ")"));
    
  }
}

function head(_param) {
  while(true) {
    var param = _param;
    switch (param.tag | 0) {
      case /* Pident */0 :
          return param[0];
      case /* Pdot */1 :
          _param = param[0];
          continue ;
      case /* Papply */2 :
          throw [
                Caml_builtin_exceptions.assert_failure,
                /* tuple */[
                  "path.ml",
                  49,
                  22
                ]
              ];
      
    }
  };
}

function last(_param) {
  while(true) {
    var param = _param;
    switch (param.tag | 0) {
      case /* Pident */0 :
          return param[0].name;
      case /* Pdot */1 :
          return param[1];
      case /* Papply */2 :
          _param = param[1];
          continue ;
      
    }
  };
}

function flat(_accu, _param) {
  while(true) {
    var param = _param;
    var accu = _accu;
    switch (param.tag | 0) {
      case /* Lident */0 :
          return /* :: */[
                  param[0],
                  accu
                ];
      case /* Ldot */1 :
          _param = param[0];
          _accu = /* :: */[
            param[1],
            accu
          ];
          continue ;
      case /* Lapply */2 :
          return fatal_error("Longident.flat");
      
    }
  };
}

function flatten(lid) {
  return flat(/* [] */0, lid);
}

function last$1(param) {
  switch (param.tag | 0) {
    case /* Lident */0 :
        return param[0];
    case /* Ldot */1 :
        return param[1];
    case /* Lapply */2 :
        return fatal_error("Longident.last");
    
  }
}

function parse_declaration(arity, decl) {
  if (!decl) {
    return fatal_error("Primitive.parse_declaration");
  }
  var match = decl[1];
  var name = decl[0];
  if (!match) {
    return {
            prim_name: name,
            prim_arity: arity,
            prim_alloc: true,
            prim_native_name: "",
            prim_native_float: false
          };
  }
  var name2 = match[0];
  if (name2 === "noalloc") {
    var match$1 = match[1];
    if (match$1) {
      var match$2 = match$1[1];
      var name2$1 = match$1[0];
      if (match$2 && match$2[0] === "float") {
        return {
                prim_name: name,
                prim_arity: arity,
                prim_alloc: false,
                prim_native_name: name2$1,
                prim_native_float: true
              };
      } else {
        return {
                prim_name: name,
                prim_arity: arity,
                prim_alloc: false,
                prim_native_name: name2$1,
                prim_native_float: false
              };
      }
    }
    
  } else {
    var match$3 = match[1];
    if (match$3 && match$3[0] === "float") {
      return {
              prim_name: name,
              prim_arity: arity,
              prim_alloc: true,
              prim_native_name: name2,
              prim_native_float: true
            };
    }
    
  }
  if (name2 === "noalloc") {
    return {
            prim_name: name,
            prim_arity: arity,
            prim_alloc: false,
            prim_native_name: "",
            prim_native_float: false
          };
  } else {
    return {
            prim_name: name,
            prim_arity: arity,
            prim_alloc: true,
            prim_native_name: name2,
            prim_native_float: false
          };
  }
}

function description_list(p) {
  var list_000 = p.prim_name;
  var list = /* :: */[
    list_000,
    /* [] */0
  ];
  var list$1 = p.prim_alloc ? list : /* :: */[
      "noalloc",
      list
    ];
  var list$2 = p.prim_native_name !== "" ? /* :: */[
      p.prim_native_name,
      list$1
    ] : list$1;
  return List.rev(p.prim_native_float ? /* :: */[
                "float",
                list$2
              ] : list$2);
}

function compare(t1, t2) {
  return t1.id - t2.id | 0;
}

function hash(t) {
  return t.id;
}

function equal$1(t1, t2) {
  return t1 === t2;
}

function height(param) {
  if (param) {
    return param[/* h */4];
  } else {
    return 0;
  }
}

function create$1(l, x, d, r) {
  var hl = height(l);
  var hr = height(r);
  return /* Node */[
          /* l */l,
          /* v */x,
          /* d */d,
          /* r */r,
          /* h */hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        ];
}

function bal(l, x, d, r) {
  var hl = l ? l[/* h */4] : 0;
  var hr = r ? r[/* h */4] : 0;
  if (hl > (hr + 2 | 0)) {
    if (!l) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Map.bal"
          ];
    }
    var lr = l[/* r */3];
    var ld = l[/* d */2];
    var lv = l[/* v */1];
    var ll = l[/* l */0];
    if (height(ll) >= height(lr)) {
      return create$1(ll, lv, ld, create$1(lr, x, d, r));
    }
    if (lr) {
      return create$1(create$1(ll, lv, ld, lr[/* l */0]), lr[/* v */1], lr[/* d */2], create$1(lr[/* r */3], x, d, r));
    }
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Map.bal"
        ];
  } else {
    if (hr <= (hl + 2 | 0)) {
      return /* Node */[
              /* l */l,
              /* v */x,
              /* d */d,
              /* r */r,
              /* h */hl >= hr ? hl + 1 | 0 : hr + 1 | 0
            ];
    }
    if (!r) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Map.bal"
          ];
    }
    var rr = r[/* r */3];
    var rd = r[/* d */2];
    var rv = r[/* v */1];
    var rl = r[/* l */0];
    if (height(rr) >= height(rl)) {
      return create$1(create$1(l, x, d, rl), rv, rd, rr);
    }
    if (rl) {
      return create$1(create$1(l, x, d, rl[/* l */0]), rl[/* v */1], rl[/* d */2], create$1(rl[/* r */3], rv, rd, rr));
    }
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Map.bal"
        ];
  }
}

function add$1(x, data, m) {
  if (!m) {
    return /* Node */[
            /* l : Empty */0,
            /* v */x,
            /* d */data,
            /* r : Empty */0,
            /* h */1
          ];
  }
  var r = m[/* r */3];
  var d = m[/* d */2];
  var v = m[/* v */1];
  var l = m[/* l */0];
  var c = Caml_primitive.caml_string_compare(x, v);
  if (c === 0) {
    if (d === data) {
      return m;
    } else {
      return /* Node */[
              /* l */l,
              /* v */x,
              /* d */data,
              /* r */r,
              /* h */m[/* h */4]
            ];
    }
  }
  if (c < 0) {
    var ll = add$1(x, data, l);
    if (l === ll) {
      return m;
    } else {
      return bal(ll, v, d, r);
    }
  } else {
    var rr = add$1(x, data, r);
    if (r === rr) {
      return m;
    } else {
      return bal(l, v, d, rr);
    }
  }
}

function find(x, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      throw Caml_builtin_exceptions.not_found;
    }
    var c = Caml_primitive.caml_string_compare(x, param[/* v */1]);
    if (c === 0) {
      return param[/* d */2];
    }
    _param = c < 0 ? param[/* l */0] : param[/* r */3];
    continue ;
  };
}

function mem(x, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return false;
    }
    var c = Caml_primitive.caml_string_compare(x, param[/* v */1]);
    if (c === 0) {
      return true;
    }
    _param = c < 0 ? param[/* l */0] : param[/* r */3];
    continue ;
  };
}

function iter$1(f, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return ;
    }
    iter$1(f, param[/* l */0]);
    Curry._2(f, param[/* v */1], param[/* d */2]);
    _param = param[/* r */3];
    continue ;
  };
}

function map(f, param) {
  if (!param) {
    return /* Empty */0;
  }
  var l$prime = map(f, param[/* l */0]);
  var d$prime = Curry._1(f, param[/* d */2]);
  var r$prime = map(f, param[/* r */3]);
  return /* Node */[
          /* l */l$prime,
          /* v */param[/* v */1],
          /* d */d$prime,
          /* r */r$prime,
          /* h */param[/* h */4]
        ];
}

function fold(f, _m, _accu) {
  while(true) {
    var accu = _accu;
    var m = _m;
    if (!m) {
      return accu;
    }
    _accu = Curry._3(f, m[/* v */1], m[/* d */2], fold(f, m[/* l */0], accu));
    _m = m[/* r */3];
    continue ;
  };
}

function single(param) {
  switch (param) {
    case /* May_pos */0 :
        return 1;
    case /* May_neg */1 :
        return 2;
    case /* May_weak */2 :
        return 4;
    case /* Inj */3 :
        return 8;
    case /* Pos */4 :
        return 16;
    case /* Neg */5 :
        return 32;
    case /* Inv */6 :
        return 64;
    
  }
}

function union(v1, v2) {
  return v1 | v2;
}

function inter(v1, v2) {
  return v1 & v2;
}

function subset(v1, v2) {
  return (v1 & v2) === v1;
}

function set(x, b, v) {
  if (b) {
    return v | single(x);
  } else {
    return v & (single(x) ^ -1);
  }
}

function mem$1(x) {
  var partial_arg = single(x);
  return (function (param) {
      return subset(partial_arg, param);
    });
}

function swap(f1, f2, v) {
  var v$prime = set(f1, mem$1(f2)(v), v);
  return set(f2, mem$1(f1)(v), v$prime);
}

function conjugate(v) {
  return swap(/* May_pos */0, /* May_neg */1, swap(/* Pos */4, /* Neg */5, v));
}

function get_upper(v) {
  return /* tuple */[
          mem$1(/* May_pos */0)(v),
          mem$1(/* May_neg */1)(v)
        ];
}

function get_lower(v) {
  return /* tuple */[
          mem$1(/* Pos */4)(v),
          mem$1(/* Neg */5)(v),
          mem$1(/* Inv */6)(v),
          mem$1(/* Inj */3)(v)
        ];
}

function height$1(param) {
  if (param) {
    return param[/* h */3];
  } else {
    return 0;
  }
}

function create$2(l, v, r) {
  var hl = l ? l[/* h */3] : 0;
  var hr = r ? r[/* h */3] : 0;
  return /* Node */[
          /* l */l,
          /* v */v,
          /* r */r,
          /* h */hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        ];
}

function bal$1(l, v, r) {
  var hl = l ? l[/* h */3] : 0;
  var hr = r ? r[/* h */3] : 0;
  if (hl > (hr + 2 | 0)) {
    if (!l) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          ];
    }
    var lr = l[/* r */2];
    var lv = l[/* v */1];
    var ll = l[/* l */0];
    if (height$1(ll) >= height$1(lr)) {
      return create$2(ll, lv, create$2(lr, v, r));
    }
    if (lr) {
      return create$2(create$2(ll, lv, lr[/* l */0]), lr[/* v */1], create$2(lr[/* r */2], v, r));
    }
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Set.bal"
        ];
  } else {
    if (hr <= (hl + 2 | 0)) {
      return /* Node */[
              /* l */l,
              /* v */v,
              /* r */r,
              /* h */hl >= hr ? hl + 1 | 0 : hr + 1 | 0
            ];
    }
    if (!r) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          ];
    }
    var rr = r[/* r */2];
    var rv = r[/* v */1];
    var rl = r[/* l */0];
    if (height$1(rr) >= height$1(rl)) {
      return create$2(create$2(l, v, rl), rv, rr);
    }
    if (rl) {
      return create$2(create$2(l, v, rl[/* l */0]), rl[/* v */1], create$2(rl[/* r */2], rv, rr));
    }
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Set.bal"
        ];
  }
}

function add$2(x, t) {
  if (!t) {
    return /* Node */[
            /* l : Empty */0,
            /* v */x,
            /* r : Empty */0,
            /* h */1
          ];
  }
  var r = t[/* r */2];
  var v = t[/* v */1];
  var l = t[/* l */0];
  var c = Caml_primitive.caml_string_compare(x, v);
  if (c === 0) {
    return t;
  }
  if (c < 0) {
    var ll = add$2(x, l);
    if (l === ll) {
      return t;
    } else {
      return bal$1(ll, v, r);
    }
  } else {
    var rr = add$2(x, r);
    if (r === rr) {
      return t;
    } else {
      return bal$1(l, v, rr);
    }
  }
}

function singleton(x) {
  return /* Node */[
          /* l : Empty */0,
          /* v */x,
          /* r : Empty */0,
          /* h */1
        ];
}

function add_min_element(x, param) {
  if (param) {
    return bal$1(add_min_element(x, param[/* l */0]), param[/* v */1], param[/* r */2]);
  } else {
    return singleton(x);
  }
}

function add_max_element(x, param) {
  if (param) {
    return bal$1(param[/* l */0], param[/* v */1], add_max_element(x, param[/* r */2]));
  } else {
    return singleton(x);
  }
}

function join(l, v, r) {
  if (!l) {
    return add_min_element(v, r);
  }
  if (!r) {
    return add_max_element(v, l);
  }
  var rh = r[/* h */3];
  var lh = l[/* h */3];
  if (lh > (rh + 2 | 0)) {
    return bal$1(l[/* l */0], l[/* v */1], join(l[/* r */2], v, r));
  } else if (rh > (lh + 2 | 0)) {
    return bal$1(join(l, v, r[/* l */0]), r[/* v */1], r[/* r */2]);
  } else {
    return create$2(l, v, r);
  }
}

function min_elt(_param) {
  while(true) {
    var param = _param;
    if (!param) {
      throw Caml_builtin_exceptions.not_found;
    }
    var l = param[/* l */0];
    if (!l) {
      return param[/* v */1];
    }
    _param = l;
    continue ;
  };
}

function remove_min_elt(param) {
  if (!param) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Set.remove_min_elt"
        ];
  }
  var l = param[/* l */0];
  if (l) {
    return bal$1(remove_min_elt(l), param[/* v */1], param[/* r */2]);
  } else {
    return param[/* r */2];
  }
}

function concat(t1, t2) {
  if (t1) {
    if (t2) {
      return join(t1, min_elt(t2), remove_min_elt(t2));
    } else {
      return t1;
    }
  } else {
    return t2;
  }
}

function split(x, param) {
  if (!param) {
    return /* tuple */[
            /* Empty */0,
            false,
            /* Empty */0
          ];
  }
  var r = param[/* r */2];
  var v = param[/* v */1];
  var l = param[/* l */0];
  var c = Caml_primitive.caml_string_compare(x, v);
  if (c === 0) {
    return /* tuple */[
            l,
            true,
            r
          ];
  }
  if (c < 0) {
    var match = split(x, l);
    return /* tuple */[
            match[0],
            match[1],
            join(match[2], v, r)
          ];
  } else {
    var match$1 = split(x, r);
    return /* tuple */[
            join(l, v, match$1[0]),
            match$1[1],
            match$1[2]
          ];
  }
}

function mem$2(x, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return false;
    }
    var c = Caml_primitive.caml_string_compare(x, param[/* v */1]);
    if (c === 0) {
      return true;
    }
    _param = c < 0 ? param[/* l */0] : param[/* r */2];
    continue ;
  };
}

function union$1(s1, s2) {
  if (!s1) {
    return s2;
  }
  if (!s2) {
    return s1;
  }
  var h2 = s2[/* h */3];
  var v2 = s2[/* v */1];
  var h1 = s1[/* h */3];
  var v1 = s1[/* v */1];
  if (h1 >= h2) {
    if (h2 === 1) {
      return add$2(v2, s1);
    }
    var match = split(v1, s2);
    return join(union$1(s1[/* l */0], match[0]), v1, union$1(s1[/* r */2], match[2]));
  } else {
    if (h1 === 1) {
      return add$2(v1, s2);
    }
    var match$1 = split(v2, s1);
    return join(union$1(match$1[0], s2[/* l */0]), v2, union$1(match$1[2], s2[/* r */2]));
  }
}

function inter$1(s1, s2) {
  if (!s1) {
    return /* Empty */0;
  }
  if (!s2) {
    return /* Empty */0;
  }
  var r1 = s1[/* r */2];
  var v1 = s1[/* v */1];
  var l1 = s1[/* l */0];
  var match = split(v1, s2);
  var l2 = match[0];
  if (match[1]) {
    return join(inter$1(l1, l2), v1, inter$1(r1, match[2]));
  } else {
    return concat(inter$1(l1, l2), inter$1(r1, match[2]));
  }
}

function diff(s1, s2) {
  if (!s1) {
    return /* Empty */0;
  }
  if (!s2) {
    return s1;
  }
  var r1 = s1[/* r */2];
  var v1 = s1[/* v */1];
  var l1 = s1[/* l */0];
  var match = split(v1, s2);
  var l2 = match[0];
  if (match[1]) {
    return concat(diff(l1, l2), diff(r1, match[2]));
  } else {
    return join(diff(l1, l2), v1, diff(r1, match[2]));
  }
}

function cons_enum(_s, _e) {
  while(true) {
    var e = _e;
    var s = _s;
    if (!s) {
      return e;
    }
    _e = /* More */[
      s[/* v */1],
      s[/* r */2],
      e
    ];
    _s = s[/* l */0];
    continue ;
  };
}

function compare$1(s1, s2) {
  var _e1 = cons_enum(s1, /* End */0);
  var _e2 = cons_enum(s2, /* End */0);
  while(true) {
    var e2 = _e2;
    var e1 = _e1;
    if (!e1) {
      if (e2) {
        return -1;
      } else {
        return 0;
      }
    }
    if (!e2) {
      return 1;
    }
    var c = Caml_primitive.caml_string_compare(e1[0], e2[0]);
    if (c !== 0) {
      return c;
    }
    _e2 = cons_enum(e2[1], e2[2]);
    _e1 = cons_enum(e1[1], e1[2]);
    continue ;
  };
}

function equal$2(s1, s2) {
  return compare$1(s1, s2) === 0;
}

function fold$1(f, _s, _accu) {
  while(true) {
    var accu = _accu;
    var s = _s;
    if (!s) {
      return accu;
    }
    _accu = Curry._2(f, s[/* v */1], fold$1(f, s[/* l */0], accu));
    _s = s[/* r */2];
    continue ;
  };
}

function elements_aux(_accu, _param) {
  while(true) {
    var param = _param;
    var accu = _accu;
    if (!param) {
      return accu;
    }
    _param = param[/* l */0];
    _accu = /* :: */[
      param[/* v */1],
      elements_aux(accu, param[/* r */2])
    ];
    continue ;
  };
}

function equal_tag(t1, t2) {
  switch (t1.tag | 0) {
    case /* Cstr_constant */0 :
        switch (t2.tag | 0) {
          case /* Cstr_constant */0 :
              return t2[0] === t1[0];
          case /* Cstr_block */1 :
          case /* Cstr_extension */2 :
              return false;
          
        }
    case /* Cstr_block */1 :
        switch (t2.tag | 0) {
          case /* Cstr_block */1 :
              return t2[0] === t1[0];
          case /* Cstr_constant */0 :
          case /* Cstr_extension */2 :
              return false;
          
        }
    case /* Cstr_extension */2 :
        switch (t2.tag | 0) {
          case /* Cstr_constant */0 :
          case /* Cstr_block */1 :
              return false;
          case /* Cstr_extension */2 :
              if (same(t1[0], t2[0])) {
                return t1[1] === t2[1];
              } else {
                return false;
              }
          
        }
    
  }
}

var Types_TypeOps = {
  compare: compare,
  equal: equal$1,
  hash: hash
};

var Types_Variance = {
  $$null: 0,
  full: 127,
  covariant: 25,
  may_inv: 7,
  union: union,
  inter: inter,
  subset: subset,
  set: set,
  mem: mem$1,
  conjugate: conjugate,
  get_upper: get_upper,
  get_lower: get_lower
};

var funarg = Types_TypeOps;

function height$2(param) {
  if (param) {
    return param[/* h */3];
  } else {
    return 0;
  }
}

function create$3(l, v, r) {
  var hl = l ? l[/* h */3] : 0;
  var hr = r ? r[/* h */3] : 0;
  return /* Node */[
          /* l */l,
          /* v */v,
          /* r */r,
          /* h */hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        ];
}

function bal$2(l, v, r) {
  var hl = l ? l[/* h */3] : 0;
  var hr = r ? r[/* h */3] : 0;
  if (hl > (hr + 2 | 0)) {
    if (!l) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          ];
    }
    var lr = l[/* r */2];
    var lv = l[/* v */1];
    var ll = l[/* l */0];
    if (height$2(ll) >= height$2(lr)) {
      return create$3(ll, lv, create$3(lr, v, r));
    }
    if (lr) {
      return create$3(create$3(ll, lv, lr[/* l */0]), lr[/* v */1], create$3(lr[/* r */2], v, r));
    }
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Set.bal"
        ];
  } else {
    if (hr <= (hl + 2 | 0)) {
      return /* Node */[
              /* l */l,
              /* v */v,
              /* r */r,
              /* h */hl >= hr ? hl + 1 | 0 : hr + 1 | 0
            ];
    }
    if (!r) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          ];
    }
    var rr = r[/* r */2];
    var rv = r[/* v */1];
    var rl = r[/* l */0];
    if (height$2(rr) >= height$2(rl)) {
      return create$3(create$3(l, v, rl), rv, rr);
    }
    if (rl) {
      return create$3(create$3(l, v, rl[/* l */0]), rl[/* v */1], create$3(rl[/* r */2], rv, rr));
    }
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Set.bal"
        ];
  }
}

function add$3(x, t) {
  if (!t) {
    return /* Node */[
            /* l : Empty */0,
            /* v */x,
            /* r : Empty */0,
            /* h */1
          ];
  }
  var r = t[/* r */2];
  var v = t[/* v */1];
  var l = t[/* l */0];
  var c = Curry._2(funarg.compare, x, v);
  if (c === 0) {
    return t;
  }
  if (c < 0) {
    var ll = add$3(x, l);
    if (l === ll) {
      return t;
    } else {
      return bal$2(ll, v, r);
    }
  } else {
    var rr = add$3(x, r);
    if (r === rr) {
      return t;
    } else {
      return bal$2(l, v, rr);
    }
  }
}

function singleton$1(x) {
  return /* Node */[
          /* l : Empty */0,
          /* v */x,
          /* r : Empty */0,
          /* h */1
        ];
}

function add_min_element$1(x, param) {
  if (param) {
    return bal$2(add_min_element$1(x, param[/* l */0]), param[/* v */1], param[/* r */2]);
  } else {
    return singleton$1(x);
  }
}

function add_max_element$1(x, param) {
  if (param) {
    return bal$2(param[/* l */0], param[/* v */1], add_max_element$1(x, param[/* r */2]));
  } else {
    return singleton$1(x);
  }
}

function join$1(l, v, r) {
  if (!l) {
    return add_min_element$1(v, r);
  }
  if (!r) {
    return add_max_element$1(v, l);
  }
  var rh = r[/* h */3];
  var lh = l[/* h */3];
  if (lh > (rh + 2 | 0)) {
    return bal$2(l[/* l */0], l[/* v */1], join$1(l[/* r */2], v, r));
  } else if (rh > (lh + 2 | 0)) {
    return bal$2(join$1(l, v, r[/* l */0]), r[/* v */1], r[/* r */2]);
  } else {
    return create$3(l, v, r);
  }
}

function min_elt$1(_param) {
  while(true) {
    var param = _param;
    if (!param) {
      throw Caml_builtin_exceptions.not_found;
    }
    var l = param[/* l */0];
    if (!l) {
      return param[/* v */1];
    }
    _param = l;
    continue ;
  };
}

function remove_min_elt$1(param) {
  if (!param) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Set.remove_min_elt"
        ];
  }
  var l = param[/* l */0];
  if (l) {
    return bal$2(remove_min_elt$1(l), param[/* v */1], param[/* r */2]);
  } else {
    return param[/* r */2];
  }
}

function concat$1(t1, t2) {
  if (t1) {
    if (t2) {
      return join$1(t1, min_elt$1(t2), remove_min_elt$1(t2));
    } else {
      return t1;
    }
  } else {
    return t2;
  }
}

function split$1(x, param) {
  if (!param) {
    return /* tuple */[
            /* Empty */0,
            false,
            /* Empty */0
          ];
  }
  var r = param[/* r */2];
  var v = param[/* v */1];
  var l = param[/* l */0];
  var c = Curry._2(funarg.compare, x, v);
  if (c === 0) {
    return /* tuple */[
            l,
            true,
            r
          ];
  }
  if (c < 0) {
    var match = split$1(x, l);
    return /* tuple */[
            match[0],
            match[1],
            join$1(match[2], v, r)
          ];
  } else {
    var match$1 = split$1(x, r);
    return /* tuple */[
            join$1(l, v, match$1[0]),
            match$1[1],
            match$1[2]
          ];
  }
}

function mem$3(x, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return false;
    }
    var c = Curry._2(funarg.compare, x, param[/* v */1]);
    if (c === 0) {
      return true;
    }
    _param = c < 0 ? param[/* l */0] : param[/* r */2];
    continue ;
  };
}

function union$2(s1, s2) {
  if (!s1) {
    return s2;
  }
  if (!s2) {
    return s1;
  }
  var h2 = s2[/* h */3];
  var v2 = s2[/* v */1];
  var h1 = s1[/* h */3];
  var v1 = s1[/* v */1];
  if (h1 >= h2) {
    if (h2 === 1) {
      return add$3(v2, s1);
    }
    var match = split$1(v1, s2);
    return join$1(union$2(s1[/* l */0], match[0]), v1, union$2(s1[/* r */2], match[2]));
  } else {
    if (h1 === 1) {
      return add$3(v1, s2);
    }
    var match$1 = split$1(v2, s1);
    return join$1(union$2(match$1[0], s2[/* l */0]), v2, union$2(match$1[2], s2[/* r */2]));
  }
}

function inter$2(s1, s2) {
  if (!s1) {
    return /* Empty */0;
  }
  if (!s2) {
    return /* Empty */0;
  }
  var r1 = s1[/* r */2];
  var v1 = s1[/* v */1];
  var l1 = s1[/* l */0];
  var match = split$1(v1, s2);
  var l2 = match[0];
  if (match[1]) {
    return join$1(inter$2(l1, l2), v1, inter$2(r1, match[2]));
  } else {
    return concat$1(inter$2(l1, l2), inter$2(r1, match[2]));
  }
}

function diff$1(s1, s2) {
  if (!s1) {
    return /* Empty */0;
  }
  if (!s2) {
    return s1;
  }
  var r1 = s1[/* r */2];
  var v1 = s1[/* v */1];
  var l1 = s1[/* l */0];
  var match = split$1(v1, s2);
  var l2 = match[0];
  if (match[1]) {
    return concat$1(diff$1(l1, l2), diff$1(r1, match[2]));
  } else {
    return join$1(diff$1(l1, l2), v1, diff$1(r1, match[2]));
  }
}

function subset$1(_s1, _s2) {
  while(true) {
    var s2 = _s2;
    var s1 = _s1;
    if (!s1) {
      return true;
    }
    if (!s2) {
      return false;
    }
    var r2 = s2[/* r */2];
    var l2 = s2[/* l */0];
    var r1 = s1[/* r */2];
    var v1 = s1[/* v */1];
    var l1 = s1[/* l */0];
    var c = Curry._2(funarg.compare, v1, s2[/* v */1]);
    if (c === 0) {
      if (!subset$1(l1, l2)) {
        return false;
      }
      _s2 = r2;
      _s1 = r1;
      continue ;
    } else if (c < 0) {
      if (!subset$1(/* Node */[
              /* l */l1,
              /* v */v1,
              /* r : Empty */0,
              /* h */0
            ], l2)) {
        return false;
      }
      _s1 = r1;
      continue ;
    } else {
      if (!subset$1(/* Node */[
              /* l : Empty */0,
              /* v */v1,
              /* r */r1,
              /* h */0
            ], r2)) {
        return false;
      }
      _s1 = l1;
      continue ;
    }
  };
}

function fold$2(f, _s, _accu) {
  while(true) {
    var accu = _accu;
    var s = _s;
    if (!s) {
      return accu;
    }
    _accu = Curry._2(f, s[/* v */1], fold$2(f, s[/* l */0], accu));
    _s = s[/* r */2];
    continue ;
  };
}

function exists(p, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return false;
    }
    if (Curry._1(p, param[/* v */1])) {
      return true;
    }
    if (exists(p, param[/* l */0])) {
      return true;
    }
    _param = param[/* r */2];
    continue ;
  };
}

function elements_aux$1(_accu, _param) {
  while(true) {
    var param = _param;
    var accu = _accu;
    if (!param) {
      return accu;
    }
    _param = param[/* l */0];
    _accu = /* :: */[
      param[/* v */1],
      elements_aux$1(accu, param[/* r */2])
    ];
    continue ;
  };
}

var funarg$1 = Types_TypeOps;

function height$3(param) {
  if (param) {
    return param[/* h */4];
  } else {
    return 0;
  }
}

function create$4(l, x, d, r) {
  var hl = height$3(l);
  var hr = height$3(r);
  return /* Node */[
          /* l */l,
          /* v */x,
          /* d */d,
          /* r */r,
          /* h */hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        ];
}

function bal$3(l, x, d, r) {
  var hl = l ? l[/* h */4] : 0;
  var hr = r ? r[/* h */4] : 0;
  if (hl > (hr + 2 | 0)) {
    if (!l) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Map.bal"
          ];
    }
    var lr = l[/* r */3];
    var ld = l[/* d */2];
    var lv = l[/* v */1];
    var ll = l[/* l */0];
    if (height$3(ll) >= height$3(lr)) {
      return create$4(ll, lv, ld, create$4(lr, x, d, r));
    }
    if (lr) {
      return create$4(create$4(ll, lv, ld, lr[/* l */0]), lr[/* v */1], lr[/* d */2], create$4(lr[/* r */3], x, d, r));
    }
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Map.bal"
        ];
  } else {
    if (hr <= (hl + 2 | 0)) {
      return /* Node */[
              /* l */l,
              /* v */x,
              /* d */d,
              /* r */r,
              /* h */hl >= hr ? hl + 1 | 0 : hr + 1 | 0
            ];
    }
    if (!r) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Map.bal"
          ];
    }
    var rr = r[/* r */3];
    var rd = r[/* d */2];
    var rv = r[/* v */1];
    var rl = r[/* l */0];
    if (height$3(rr) >= height$3(rl)) {
      return create$4(create$4(l, x, d, rl), rv, rd, rr);
    }
    if (rl) {
      return create$4(create$4(l, x, d, rl[/* l */0]), rl[/* v */1], rl[/* d */2], create$4(rl[/* r */3], rv, rd, rr));
    }
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Map.bal"
        ];
  }
}

function add$4(x, data, m) {
  if (!m) {
    return /* Node */[
            /* l : Empty */0,
            /* v */x,
            /* d */data,
            /* r : Empty */0,
            /* h */1
          ];
  }
  var r = m[/* r */3];
  var d = m[/* d */2];
  var v = m[/* v */1];
  var l = m[/* l */0];
  var c = Curry._2(funarg$1.compare, x, v);
  if (c === 0) {
    if (d === data) {
      return m;
    } else {
      return /* Node */[
              /* l */l,
              /* v */x,
              /* d */data,
              /* r */r,
              /* h */m[/* h */4]
            ];
    }
  }
  if (c < 0) {
    var ll = add$4(x, data, l);
    if (l === ll) {
      return m;
    } else {
      return bal$3(ll, v, d, r);
    }
  } else {
    var rr = add$4(x, data, r);
    if (r === rr) {
      return m;
    } else {
      return bal$3(l, v, d, rr);
    }
  }
}

function find$1(x, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      throw Caml_builtin_exceptions.not_found;
    }
    var c = Curry._2(funarg$1.compare, x, param[/* v */1]);
    if (c === 0) {
      return param[/* d */2];
    }
    _param = c < 0 ? param[/* l */0] : param[/* r */3];
    continue ;
  };
}

function fold$3(f, _m, _accu) {
  while(true) {
    var accu = _accu;
    var m = _m;
    if (!m) {
      return accu;
    }
    _accu = Curry._3(f, m[/* v */1], m[/* d */2], fold$3(f, m[/* l */0], accu));
    _m = m[/* r */3];
    continue ;
  };
}

var $$let = Types_TypeOps;

var TypeHash = Hashtbl.Make({
      equal: $$let.equal,
      hash: $$let.hash
    });

function print_raw(param) {
  throw [
        Caml_builtin_exceptions.assert_failure,
        /* tuple */[
          "btype.ml",
          27,
          16
        ]
      ];
}

var pivot_level = -1;

var new_id = {
  contents: -1
};

function newty2(level, desc) {
  new_id.contents = new_id.contents + 1 | 0;
  return {
          desc: desc,
          level: level,
          id: new_id.contents
        };
}

function is_Tvar(param) {
  var match = param.desc;
  if (typeof match === "number" || match.tag) {
    return false;
  } else {
    return true;
  }
}

function is_Tunivar(param) {
  var match = param.desc;
  if (typeof match === "number" || match.tag !== /* Tunivar */9) {
    return false;
  } else {
    return true;
  }
}

var dummy_method = "*dummy method*";

function default_mty(param) {
  if (param !== void 0) {
    return param;
  } else {
    return /* Mty_signature */Block.__(1, [/* [] */0]);
  }
}

function field_kind_repr(_kind) {
  while(true) {
    var kind = _kind;
    if (typeof kind === "number") {
      return kind;
    }
    var match = kind[0].contents;
    if (match === void 0) {
      return kind;
    }
    _kind = match;
    continue ;
  };
}

function repr(_t) {
  while(true) {
    var t = _t;
    var match = t.desc;
    if (typeof match === "number") {
      return t;
    }
    switch (match.tag | 0) {
      case /* Tfield */5 :
          if (field_kind_repr(match[1]) !== /* Fabsent */1) {
            return t;
          }
          _t = match[3];
          continue ;
      case /* Tlink */6 :
          _t = match[0];
          continue ;
      default:
        return t;
    }
  };
}

function commu_repr(_c) {
  while(true) {
    var c = _c;
    if (typeof c === "number") {
      return c;
    }
    var r = c[0];
    if (r.contents === /* Cunknown */1) {
      return c;
    }
    _c = r.contents;
    continue ;
  };
}

function row_field_repr_aux(_tl, _fi) {
  while(true) {
    var fi = _fi;
    var tl = _tl;
    if (typeof fi === "number") {
      return fi;
    }
    if (!fi.tag) {
      if (fi[0] !== void 0 && tl !== /* [] */0) {
        return /* Rpresent */Block.__(0, [List.hd(tl)]);
      } else {
        return fi;
      }
    }
    var r = fi[3];
    var tl$prime = fi[1];
    var match = r.contents;
    if (match === void 0) {
      return /* Reither */Block.__(1, [
                fi[0],
                Pervasives.$at(tl, tl$prime),
                fi[2],
                r
              ]);
    }
    _fi = match;
    _tl = Pervasives.$at(tl, tl$prime);
    continue ;
  };
}

function rev_concat(_l, _ll) {
  while(true) {
    var ll = _ll;
    var l = _l;
    if (!ll) {
      return l;
    }
    _ll = ll[1];
    _l = Pervasives.$at(ll[0], l);
    continue ;
  };
}

function row_repr_aux(_ll, _row) {
  while(true) {
    var row = _row;
    var ll = _ll;
    var match = repr(row.row_more).desc;
    if (typeof match !== "number" && match.tag === /* Tvariant */8) {
      var f = row.row_fields;
      _row = match[0];
      _ll = f === /* [] */0 ? ll : /* :: */[
          f,
          ll
        ];
      continue ;
    }
    if (ll === /* [] */0) {
      return row;
    } else {
      return {
              row_fields: rev_concat(row.row_fields, ll),
              row_more: row.row_more,
              row_bound: row.row_bound,
              row_closed: row.row_closed,
              row_fixed: row.row_fixed,
              row_name: row.row_name
            };
    }
  };
}

function row_field(tag, row) {
  var _param = row.row_fields;
  while(true) {
    var param = _param;
    if (param) {
      var match = param[0];
      if (tag === match[0]) {
        return row_field_repr_aux(/* [] */0, match[1]);
      }
      _param = param[1];
      continue ;
    } else {
      var match$1 = repr(row.row_more);
      var match$2 = match$1.desc;
      if (typeof match$2 === "number" || match$2.tag !== /* Tvariant */8) {
        return /* Rabsent */0;
      } else {
        return row_field(tag, match$2[0]);
      }
    }
  };
}

function row_more(_row) {
  while(true) {
    var row = _row;
    var ty = repr(row.row_more);
    var match = ty.desc;
    if (typeof match === "number") {
      return ty;
    }
    if (match.tag !== /* Tvariant */8) {
      return ty;
    }
    _row = match[0];
    continue ;
  };
}

function row_fixed(row) {
  var row$1 = row_repr_aux(/* [] */0, row);
  if (row$1.row_fixed) {
    return true;
  }
  var match = repr(row$1.row_more).desc;
  if (typeof match === "number") {
    return false;
  }
  switch (match.tag | 0) {
    case /* Tvar */0 :
        return false;
    case /* Tconstr */3 :
    case /* Tunivar */9 :
        return true;
    default:
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "btype.ml",
              137,
              9
            ]
          ];
  }
}

function static_row(row) {
  var row$1 = row_repr_aux(/* [] */0, row);
  if (row$1.row_closed) {
    return List.for_all((function (param) {
                  var match = row_field_repr_aux(/* [] */0, param[1]);
                  if (typeof match === "number" || !match.tag) {
                    return true;
                  } else {
                    return false;
                  }
                }), row$1.row_fields);
  } else {
    return false;
  }
}

function hash_variant(s) {
  var accu = 0;
  for(var i = 0 ,i_finish = s.length - 1 | 0; i <= i_finish; ++i){
    accu = Caml_int32.imul(223, accu) + Caml_string.get(s, i) | 0;
  }
  accu = accu & 2147483647;
  if (accu > 1073741823) {
    return accu - -2147483648 | 0;
  } else {
    return accu;
  }
}

function proxy(ty) {
  var ty0 = repr(ty);
  var match = ty0.desc;
  if (typeof match === "number") {
    return ty0;
  }
  switch (match.tag | 0) {
    case /* Tobject */4 :
        var _ty = match[0];
        while(true) {
          var ty$1 = _ty;
          var match$1 = ty$1.desc;
          if (typeof match$1 === "number") {
            return ty0;
          }
          switch (match$1.tag | 0) {
            case /* Tfield */5 :
                _ty = match$1[3];
                continue ;
            case /* Tlink */6 :
                _ty = match$1[0];
                continue ;
            case /* Tvar */0 :
            case /* Tconstr */3 :
            case /* Tunivar */9 :
                return ty$1;
            default:
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    /* tuple */[
                      "btype.ml",
                      167,
                      15
                    ]
                  ];
          }
        };
    case /* Tvariant */8 :
        var row = match[0];
        if (static_row(row)) {
          return ty0;
        } else {
          return row_more(row);
        }
    default:
      return ty0;
  }
}

function has_constr_row(t) {
  var match = repr(t).desc;
  if (typeof match === "number") {
    return false;
  }
  switch (match.tag | 0) {
    case /* Tobject */4 :
        var _t = match[0];
        while(true) {
          var t$1 = _t;
          var match$1 = repr(t$1).desc;
          if (typeof match$1 === "number") {
            return false;
          }
          switch (match$1.tag | 0) {
            case /* Tconstr */3 :
                return true;
            case /* Tfield */5 :
                _t = match$1[3];
                continue ;
            default:
              return false;
          }
        };
    case /* Tvariant */8 :
        var match$2 = row_more(match[0]);
        var match$3 = match$2.desc;
        if (typeof match$3 === "number" || match$3.tag !== /* Tconstr */3) {
          return false;
        } else {
          return true;
        }
    default:
      return false;
  }
}

function is_row_name(s) {
  var l = s.length;
  if (l < 4) {
    return false;
  } else {
    return $$String.sub(s, l - 4 | 0, 4) === "#row";
  }
}

function is_constr_row(t) {
  var match = t.desc;
  if (typeof match === "number") {
    return false;
  }
  if (match.tag !== /* Tconstr */3) {
    return false;
  }
  var match$1 = match[0];
  switch (match$1.tag | 0) {
    case /* Pident */0 :
        return is_row_name(match$1[0].name);
    case /* Pdot */1 :
        return is_row_name(match$1[1]);
    case /* Papply */2 :
        return false;
    
  }
}

function iter_row(f, _row) {
  while(true) {
    var row = _row;
    List.iter((function (param) {
            var match = row_field_repr_aux(/* [] */0, param[1]);
            if (typeof match === "number") {
              return ;
            }
            if (match.tag) {
              return List.iter(f, match[1]);
            }
            var match$1 = match[0];
            if (match$1 !== void 0) {
              return Curry._1(f, match$1);
            }
            
          }), row.row_fields);
    var match = repr(row.row_more).desc;
    if (typeof match !== "number") {
      switch (match.tag | 0) {
        case /* Tvariant */8 :
            _row = match[0];
            continue ;
        case /* Tvar */0 :
        case /* Tconstr */3 :
        case /* Tsubst */7 :
        case /* Tunivar */9 :
            break;
        default:
          throw [
                Caml_builtin_exceptions.assert_failure,
                /* tuple */[
                  "btype.ml",
                  214,
                  9
                ]
              ];
      }
    }
    return may((function (param) {
                  return List.iter(f, param[1]);
                }), row.row_name);
  };
}

function iter_type_expr(f, ty) {
  var match = ty.desc;
  if (typeof match === "number") {
    return ;
  }
  switch (match.tag | 0) {
    case /* Tarrow */1 :
        Curry._1(f, match[1]);
        return Curry._1(f, match[2]);
    case /* Ttuple */2 :
        return List.iter(f, match[0]);
    case /* Tconstr */3 :
        return List.iter(f, match[1]);
    case /* Tobject */4 :
        var ty$1 = match[0];
        var match$1 = match[1].contents;
        if (match$1 !== void 0) {
          Curry._1(f, ty$1);
          return List.iter(f, match$1[1]);
        } else {
          return Curry._1(f, ty$1);
        }
    case /* Tfield */5 :
        Curry._1(f, match[2]);
        return Curry._1(f, match[3]);
    case /* Tlink */6 :
    case /* Tsubst */7 :
        return Curry._1(f, match[0]);
    case /* Tvariant */8 :
        var row = match[0];
        iter_row(f, row);
        return Curry._1(f, row_more(row));
    case /* Tpoly */10 :
        Curry._1(f, match[0]);
        return List.iter(f, match[1]);
    case /* Tpackage */11 :
        return List.iter(f, match[2]);
    default:
      return ;
  }
}

function iter_abbrev(f, _param) {
  while(true) {
    var param = _param;
    if (typeof param === "number") {
      return ;
    }
    if (param.tag) {
      _param = param[0].contents;
      continue ;
    } else {
      Curry._1(f, param[2]);
      Curry._1(f, param[3]);
      _param = param[4];
      continue ;
    }
  };
}

function it_signature(it) {
  var partial_arg = Curry._1(it.it_signature_item, it);
  return (function (param) {
      return List.iter(partial_arg, param);
    });
}

function it_signature_item(it, param) {
  switch (param.tag | 0) {
    case /* Sig_value */0 :
        return Curry._2(it.it_value_description, it, param[1]);
    case /* Sig_type */1 :
        return Curry._2(it.it_type_declaration, it, param[1]);
    case /* Sig_typext */2 :
        return Curry._2(it.it_extension_constructor, it, param[1]);
    case /* Sig_module */3 :
        return Curry._2(it.it_module_declaration, it, param[1]);
    case /* Sig_modtype */4 :
        return Curry._2(it.it_modtype_declaration, it, param[1]);
    case /* Sig_class */5 :
        return Curry._2(it.it_class_declaration, it, param[1]);
    case /* Sig_class_type */6 :
        return Curry._2(it.it_class_type_declaration, it, param[1]);
    
  }
}

function it_value_description(it, vd) {
  return Curry._2(it.it_type_expr, it, vd.val_type);
}

function it_type_declaration(it, td) {
  List.iter(Curry._1(it.it_type_expr, it), td.type_params);
  may(Curry._1(it.it_type_expr, it), td.type_manifest);
  return Curry._2(it.it_type_kind, it, td.type_kind);
}

function it_extension_constructor(it, td) {
  Curry._1(it.it_path, td.ext_type_path);
  List.iter(Curry._1(it.it_type_expr, it), td.ext_type_params);
  List.iter(Curry._1(it.it_type_expr, it), td.ext_args);
  return may(Curry._1(it.it_type_expr, it), td.ext_ret_type);
}

function it_module_declaration(it, md) {
  return Curry._2(it.it_module_type, it, md.md_type);
}

function it_modtype_declaration(it, mtd) {
  return may(Curry._1(it.it_module_type, it), mtd.mtd_type);
}

function it_class_declaration(it, cd) {
  List.iter(Curry._1(it.it_type_expr, it), cd.cty_params);
  Curry._2(it.it_class_type, it, cd.cty_type);
  may(Curry._1(it.it_type_expr, it), cd.cty_new);
  return Curry._1(it.it_path, cd.cty_path);
}

function it_class_type_declaration(it, ctd) {
  List.iter(Curry._1(it.it_type_expr, it), ctd.clty_params);
  Curry._2(it.it_class_type, it, ctd.clty_type);
  return Curry._1(it.it_path, ctd.clty_path);
}

function it_module_type(it, param) {
  switch (param.tag | 0) {
    case /* Mty_signature */1 :
        return Curry._2(it.it_signature, it, param[0]);
    case /* Mty_functor */2 :
        may(Curry._1(it.it_module_type, it), param[1]);
        return Curry._2(it.it_module_type, it, param[2]);
    case /* Mty_ident */0 :
    case /* Mty_alias */3 :
        return Curry._1(it.it_path, param[0]);
    
  }
}

function it_class_type(it, param) {
  switch (param.tag | 0) {
    case /* Cty_constr */0 :
        Curry._1(it.it_path, param[0]);
        List.iter(Curry._1(it.it_type_expr, it), param[1]);
        return Curry._2(it.it_class_type, it, param[2]);
    case /* Cty_signature */1 :
        var cs = param[0];
        Curry._2(it.it_type_expr, it, cs.csig_self);
        iter$1((function (param, param$1) {
                return Curry._2(it.it_type_expr, it, param$1[2]);
              }), cs.csig_vars);
        return List.iter((function (param) {
                      Curry._1(it.it_path, param[0]);
                      return List.iter(Curry._1(it.it_type_expr, it), param[1]);
                    }), cs.csig_inher);
    case /* Cty_arrow */2 :
        Curry._2(it.it_type_expr, it, param[1]);
        return Curry._2(it.it_class_type, it, param[2]);
    
  }
}

function it_type_kind(it, param) {
  if (typeof param === "number") {
    return ;
  } else if (param.tag) {
    return List.iter((function (cd) {
                  List.iter(Curry._1(it.it_type_expr, it), cd.cd_args);
                  return may(Curry._1(it.it_type_expr, it), cd.cd_res);
                }), param[0]);
  } else {
    return List.iter((function (ld) {
                  return Curry._2(it.it_type_expr, it, ld.ld_type);
                }), param[0]);
  }
}

function it_do_type_expr(it, ty) {
  iter_type_expr(Curry._1(it.it_type_expr, it), ty);
  var match = ty.desc;
  if (typeof match === "number") {
    return ;
  }
  switch (match.tag | 0) {
    case /* Tobject */4 :
        var match$1 = match[1].contents;
        if (match$1 !== void 0) {
          return Curry._1(it.it_path, match$1[0]);
        } else {
          return ;
        }
    case /* Tvariant */8 :
        return may((function (param) {
                      return Curry._1(it.it_path, param[0]);
                    }), row_repr_aux(/* [] */0, match[0]).row_name);
    case /* Tconstr */3 :
    case /* Tpackage */11 :
        return Curry._1(it.it_path, match[0]);
    default:
      return ;
  }
}

function it_path(p) {
  
}

function copy_row(f, fixed, row, keep, more) {
  var fields = List.map((function (param) {
          var fi = param[1];
          var match = row_field_repr_aux(/* [] */0, fi);
          var tmp;
          if (typeof match === "number") {
            tmp = fi;
          } else if (match.tag) {
            var e = keep ? match[3] : ({
                  contents: void 0
                });
            var m = row.row_fixed ? fixed : match[2];
            var tl = List.map(f, match[1]);
            tmp = /* Reither */Block.__(1, [
                match[0],
                tl,
                m,
                e
              ]);
          } else {
            var match$1 = match[0];
            tmp = match$1 !== void 0 ? /* Rpresent */Block.__(0, [Curry._1(f, match$1)]) : fi;
          }
          return /* tuple */[
                  param[0],
                  tmp
                ];
        }), row.row_fields);
  var match = row.row_name;
  var name;
  if (match !== void 0) {
    var match$1 = match;
    name = /* tuple */[
      match$1[0],
      List.map(f, match$1[1])
    ];
  } else {
    name = void 0;
  }
  return {
          row_fields: fields,
          row_more: more,
          row_bound: void 0,
          row_closed: row.row_closed,
          row_fixed: row.row_fixed && fixed,
          row_name: name
        };
}

function copy_kind(_param) {
  while(true) {
    var param = _param;
    if (typeof param === "number") {
      if (param !== 0) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "btype.ml",
                363,
                16
              ]
            ];
      }
      return /* Fpresent */0;
    } else {
      var match = param[0].contents;
      if (match === void 0) {
        return /* Fvar */[{
                  contents: void 0
                }];
      }
      _param = match;
      continue ;
    }
  };
}

function copy_commu(c) {
  if (commu_repr(c) === /* Cok */0) {
    return /* Cok */0;
  } else {
    return /* Clink */[{
              contents: /* Cunknown */1
            }];
  }
}

function copy_type_desc(_keep_namesOpt, f, _ty) {
  while(true) {
    var keep_namesOpt = _keep_namesOpt;
    var ty = _ty;
    var keep_names = keep_namesOpt !== void 0 ? keep_namesOpt : false;
    if (typeof ty === "number") {
      return /* Tnil */0;
    }
    switch (ty.tag | 0) {
      case /* Tvar */0 :
          if (keep_names) {
            return ty;
          } else {
            return /* Tvar */Block.__(0, [void 0]);
          }
      case /* Tarrow */1 :
          return /* Tarrow */Block.__(1, [
                    ty[0],
                    Curry._1(f, ty[1]),
                    Curry._1(f, ty[2]),
                    copy_commu(ty[3])
                  ]);
      case /* Ttuple */2 :
          return /* Ttuple */Block.__(2, [List.map(f, ty[0])]);
      case /* Tconstr */3 :
          return /* Tconstr */Block.__(3, [
                    ty[0],
                    List.map(f, ty[1]),
                    {
                      contents: /* Mnil */0
                    }
                  ]);
      case /* Tobject */4 :
          var ty$1 = ty[0];
          var match = ty[1].contents;
          if (match === void 0) {
            return /* Tobject */Block.__(4, [
                      Curry._1(f, ty$1),
                      {
                        contents: void 0
                      }
                    ]);
          }
          var match$1 = match;
          return /* Tobject */Block.__(4, [
                    Curry._1(f, ty$1),
                    {
                      contents: /* tuple */[
                        match$1[0],
                        List.map(f, match$1[1])
                      ]
                    }
                  ]);
      case /* Tfield */5 :
          return /* Tfield */Block.__(5, [
                    ty[0],
                    field_kind_repr(ty[1]),
                    Curry._1(f, ty[2]),
                    Curry._1(f, ty[3])
                  ]);
      case /* Tlink */6 :
          _ty = ty[0].desc;
          _keep_namesOpt = void 0;
          continue ;
      case /* Tsubst */7 :
          throw [
                Caml_builtin_exceptions.assert_failure,
                /* tuple */[
                  "btype.ml",
                  390,
                  27
                ]
              ];
      case /* Tvariant */8 :
          throw [
                Caml_builtin_exceptions.assert_failure,
                /* tuple */[
                  "btype.ml",
                  385,
                  27
                ]
              ];
      case /* Tunivar */9 :
          return ty;
      case /* Tpoly */10 :
          var tyl = List.map((function (x) {
                  var _ty = Curry._1(f, x);
                  while(true) {
                    var ty = _ty;
                    var match = ty.desc;
                    if (typeof match !== "number") {
                      switch (match.tag | 0) {
                        case /* Ttuple */2 :
                            var match$1 = match[0];
                            if (match$1) {
                              _ty = match$1[0];
                              continue ;
                            }
                            break;
                        case /* Tlink */6 :
                            _ty = match[0];
                            continue ;
                        case /* Tsubst */7 :
                        case /* Tunivar */9 :
                            return ty;
                        default:
                          
                      }
                    }
                    throw [
                          Caml_builtin_exceptions.assert_failure,
                          /* tuple */[
                            "btype.ml",
                            375,
                            26
                          ]
                        ];
                  };
                }), ty[1]);
          return /* Tpoly */Block.__(10, [
                    Curry._1(f, ty[0]),
                    tyl
                  ]);
      case /* Tpackage */11 :
          return /* Tpackage */Block.__(11, [
                    ty[0],
                    ty[1],
                    List.map(f, ty[2])
                  ]);
      
    }
  };
}

var saved_desc = {
  contents: /* [] */0
};

function save_desc(ty, desc) {
  saved_desc.contents = /* :: */[
    /* tuple */[
      ty,
      desc
    ],
    saved_desc.contents
  ];
  
}

var saved_kinds = {
  contents: /* [] */0
};

var new_kinds = {
  contents: /* [] */0
};

function dup_kind(r) {
  var match = r.contents;
  if (match !== void 0) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "btype.ml",
            408,
            40
          ]
        ];
  }
  if (List.memq(r, new_kinds.contents)) {
    return ;
  }
  saved_kinds.contents = /* :: */[
    r,
    saved_kinds.contents
  ];
  var r$prime = {
    contents: void 0
  };
  new_kinds.contents = /* :: */[
    r$prime,
    new_kinds.contents
  ];
  r.contents = /* Fvar */[r$prime];
  
}

function cleanup_types(param) {
  List.iter((function (param) {
          param[0].desc = param[1];
          
        }), saved_desc.contents);
  List.iter((function (r) {
          r.contents = void 0;
          
        }), saved_kinds.contents);
  saved_desc.contents = /* [] */0;
  saved_kinds.contents = /* [] */0;
  new_kinds.contents = /* [] */0;
  
}

function mark_type(ty) {
  var ty$1 = repr(ty);
  if (ty$1.level >= 0) {
    ty$1.level = pivot_level - ty$1.level | 0;
    return iter_type_expr(mark_type, ty$1);
  }
  
}

function mark_type_node(ty) {
  var ty$1 = repr(ty);
  if (ty$1.level >= 0) {
    ty$1.level = pivot_level - ty$1.level | 0;
    return ;
  }
  
}

function it_type_expr(it, ty) {
  var ty$1 = repr(ty);
  if (ty$1.level >= 0) {
    mark_type_node(ty$1);
    return Curry._2(it.it_do_type_expr, it, ty$1);
  }
  
}

function unmark_type(ty) {
  var ty$1 = repr(ty);
  if (ty$1.level < 0) {
    ty$1.level = pivot_level - ty$1.level | 0;
    return iter_type_expr(unmark_type, ty$1);
  }
  
}

function it_type_expr$1(it, ty) {
  return unmark_type(ty);
}

var unmark_iterators = {
  it_signature: it_signature,
  it_signature_item: it_signature_item,
  it_value_description: it_value_description,
  it_type_declaration: it_type_declaration,
  it_extension_constructor: it_extension_constructor,
  it_module_declaration: it_module_declaration,
  it_modtype_declaration: it_modtype_declaration,
  it_class_declaration: it_class_declaration,
  it_class_type_declaration: it_class_type_declaration,
  it_module_type: it_module_type,
  it_class_type: it_class_type,
  it_type_kind: it_type_kind,
  it_do_type_expr: it_do_type_expr,
  it_type_expr: it_type_expr$1,
  it_path: it_path
};

function unmark_extension_constructor(ext) {
  List.iter(unmark_type, ext.ext_type_params);
  List.iter(unmark_type, ext.ext_args);
  return may(unmark_type, ext.ext_ret_type);
}

function unmark_class_signature(sign) {
  unmark_type(sign.csig_self);
  return iter$1((function (l, param) {
                return unmark_type(param[2]);
              }), sign.csig_vars);
}

function find_expans(priv, p1, _param) {
  while(true) {
    var param = _param;
    if (typeof param === "number") {
      return ;
    }
    if (param.tag) {
      var rem = param[0].contents;
      _param = rem;
      continue ;
    } else {
      if (param[0] >= priv && same(p1, param[1])) {
        return param[3];
      }
      _param = param[4];
      continue ;
    }
  };
}

var memo = {
  contents: /* [] */0
};

function cleanup_abbrev(param) {
  List.iter((function (abbr) {
          abbr.contents = /* Mnil */0;
          
        }), memo.contents);
  memo.contents = /* [] */0;
  
}

function memorize_abbrev(mem, priv, path, v, v$prime) {
  mem.contents = /* Mcons */Block.__(0, [
      priv,
      path,
      v,
      v$prime,
      mem.contents
    ]);
  memo.contents = /* :: */[
    mem,
    memo.contents
  ];
  
}

function forget_abbrev_rec(mem, path) {
  if (typeof mem === "number") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "btype.ml",
            520,
            6
          ]
        ];
  }
  if (mem.tag) {
    var mem$prime = mem[0];
    mem$prime.contents = forget_abbrev_rec(mem$prime.contents, path);
    throw Pervasives.Exit;
  } else {
    var rem = mem[4];
    var path$prime = mem[1];
    if (same(path, path$prime)) {
      return rem;
    } else {
      return /* Mcons */Block.__(0, [
                mem[0],
                path$prime,
                mem[2],
                mem[3],
                forget_abbrev_rec(rem, path)
              ]);
    }
  }
}

function forget_abbrev(mem, path) {
  try {
    mem.contents = forget_abbrev_rec(mem.contents, path);
    return ;
  }
  catch (exn){
    if (exn === Pervasives.Exit) {
      return ;
    }
    throw exn;
  }
}

function is_optional(l) {
  if (l.length !== 0) {
    return Caml_string.get(l, 0) === /* "?" */63;
  } else {
    return false;
  }
}

function label_name(l) {
  if (is_optional(l)) {
    return $$String.sub(l, 1, l.length - 1 | 0);
  } else {
    return l;
  }
}

function prefixed_label_name(l) {
  if (is_optional(l)) {
    return l;
  } else {
    return "~" + l;
  }
}

function extract_label_aux(_hd, l, _param) {
  while(true) {
    var param = _param;
    var hd = _hd;
    if (!param) {
      throw Caml_builtin_exceptions.not_found;
    }
    var ls = param[1];
    var p = param[0];
    var l$prime = p[0];
    if (label_name(l$prime) === l) {
      return /* tuple */[
              l$prime,
              p[1],
              List.rev(hd),
              ls
            ];
    }
    _param = ls;
    _hd = /* :: */[
      p,
      hd
    ];
    continue ;
  };
}

function undo_change(param) {
  switch (param.tag | 0) {
    case /* Ctype */0 :
        param[0].desc = param[1];
        return ;
    case /* Clevel */1 :
        param[0].level = param[1];
        return ;
    default:
      param[0].contents = param[1];
      return ;
  }
}

var trail = Caml_weak.caml_weak_create(1);

var last_snapshot = {
  contents: 0
};

function log_change(ch) {
  var match = Caml_weak.caml_weak_get(trail, 0);
  if (match === void 0) {
    return ;
  }
  var r$prime = {
    contents: /* Unchanged */0
  };
  match.contents = /* Change */[
    ch,
    r$prime
  ];
  return Caml_weak.caml_weak_set(trail, 0, r$prime);
}

function log_type(ty) {
  if (ty.id <= last_snapshot.contents) {
    return log_change(/* Ctype */Block.__(0, [
                  ty,
                  ty.desc
                ]));
  }
  
}

function link_type(ty, ty$prime) {
  log_type(ty);
  var desc = ty.desc;
  ty.desc = /* Tlink */Block.__(6, [ty$prime]);
  var match = ty$prime.desc;
  if (typeof desc === "number") {
    return ;
  }
  if (desc.tag) {
    return ;
  }
  if (typeof match === "number") {
    return ;
  }
  if (match.tag) {
    return ;
  }
  var name = desc[0];
  if (name !== void 0 && !(match[0] !== void 0 && ty.level >= ty$prime.level)) {
    log_type(ty$prime);
    ty$prime.desc = /* Tvar */Block.__(0, [name]);
    return ;
  }
  
}

function set_level(ty, level) {
  if (ty.id <= last_snapshot.contents) {
    log_change(/* Clevel */Block.__(1, [
            ty,
            ty.level
          ]));
  }
  ty.level = level;
  
}

function set_univar(rty, ty) {
  log_change(/* Cuniv */Block.__(6, [
          rty,
          rty.contents
        ]));
  rty.contents = ty;
  
}

function set_name(nm, v) {
  log_change(/* Cname */Block.__(2, [
          nm,
          nm.contents
        ]));
  nm.contents = v;
  
}

function set_row_field(e, v) {
  log_change(/* Crow */Block.__(3, [
          e,
          e.contents
        ]));
  e.contents = v;
  
}

function set_kind(rk, k) {
  log_change(/* Ckind */Block.__(4, [
          rk,
          rk.contents
        ]));
  rk.contents = k;
  
}

function set_commu(rc, c) {
  log_change(/* Ccommu */Block.__(5, [
          rc,
          rc.contents
        ]));
  rc.contents = c;
  
}

function set_typeset(rs, s) {
  log_change(/* Ctypeset */Block.__(7, [
          rs,
          rs.contents
        ]));
  rs.contents = s;
  
}

function snapshot(param) {
  var old = last_snapshot.contents;
  last_snapshot.contents = new_id.contents;
  var match = Caml_weak.caml_weak_get(trail, 0);
  if (match !== void 0) {
    return /* tuple */[
            match,
            old
          ];
  }
  var r = {
    contents: /* Unchanged */0
  };
  Caml_weak.caml_weak_set(trail, 0, r);
  return /* tuple */[
          r,
          old
        ];
}

function rev_log(_accu, _param) {
  while(true) {
    var param = _param;
    var accu = _accu;
    if (typeof param === "number") {
      if (param !== 0) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "btype.ml",
                656,
                15
              ]
            ];
      }
      return accu;
    } else {
      var next = param[1];
      var d = next.contents;
      next.contents = /* Invalid */1;
      _param = d;
      _accu = /* :: */[
        param[0],
        accu
      ];
      continue ;
    }
  };
}

function backtrack(param) {
  var old = param[1];
  var changes = param[0];
  var change = changes.contents;
  if (typeof change === "number") {
    if (change !== 0) {
      throw [
            Caml_builtin_exceptions.failure,
            "Btype.backtrack"
          ];
    }
    last_snapshot.contents = old;
    return ;
  } else {
    cleanup_abbrev(void 0);
    var backlog = rev_log(/* [] */0, change);
    List.iter(undo_change, backlog);
    changes.contents = /* Unchanged */0;
    last_snapshot.contents = old;
    return Caml_weak.caml_weak_set(trail, 0, changes);
  }
}

var $$Error$1 = Caml_exceptions.create("Ocaml_typedtree_test.Cmi_format.Error");

function input_cmi(ic) {
  var match = Caml_external_polyfill.resolve("caml_input_value")(ic);
  var crcs = Caml_external_polyfill.resolve("caml_input_value")(ic);
  var flags = Caml_external_polyfill.resolve("caml_input_value")(ic);
  return {
          cmi_name: match[0],
          cmi_sign: match[1],
          cmi_crcs: crcs,
          cmi_flags: flags
        };
}

function read_cmi(filename) {
  var ic = Pervasives.open_in_bin(filename);
  try {
    var buffer = Pervasives.really_input_string(ic, cmi_magic_number.length);
    if (buffer !== cmi_magic_number) {
      Caml_external_polyfill.resolve("caml_ml_close_channel")(ic);
      var pre_len = cmi_magic_number.length - 3 | 0;
      if ($$String.sub(buffer, 0, pre_len) !== $$String.sub(cmi_magic_number, 0, pre_len)) {
        throw [
              $$Error$1,
              /* Not_an_interface */Block.__(0, [filename])
            ];
      }
      var msg = buffer < cmi_magic_number ? "an older" : "a newer";
      throw [
            $$Error$1,
            /* Wrong_version_interface */Block.__(1, [
                filename,
                msg
              ])
          ];
    }
    var cmi = input_cmi(ic);
    Caml_external_polyfill.resolve("caml_ml_close_channel")(ic);
    return cmi;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn === Caml_builtin_exceptions.end_of_file) {
      Caml_external_polyfill.resolve("caml_ml_close_channel")(ic);
      throw [
            $$Error$1,
            /* Corrupted_interface */Block.__(2, [filename])
          ];
    } else if (exn[0] === Caml_builtin_exceptions.failure) {
      Caml_external_polyfill.resolve("caml_ml_close_channel")(ic);
      throw [
            $$Error$1,
            /* Corrupted_interface */Block.__(2, [filename])
          ];
    } else {
      if (exn[0] !== $$Error$1) {
        throw exn;
      }
      Caml_external_polyfill.resolve("caml_ml_close_channel")(ic);
      throw [
            $$Error$1,
            exn[1]
          ];
    }
  }
}

function output_cmi(filename, oc, cmi) {
  Pervasives.output_string(oc, cmi_magic_number);
  Caml_external_polyfill.resolve("caml_output_value")(oc, /* tuple */[
        cmi.cmi_name,
        cmi.cmi_sign
      ], /* [] */0);
  Caml_io.caml_ml_flush(oc);
  var crc = Digest.file(filename);
  var crcs_000 = /* tuple */[
    cmi.cmi_name,
    crc
  ];
  var crcs_001 = cmi.cmi_crcs;
  var crcs = /* :: */[
    crcs_000,
    crcs_001
  ];
  Caml_external_polyfill.resolve("caml_output_value")(oc, crcs, /* [] */0);
  Caml_external_polyfill.resolve("caml_output_value")(oc, cmi.cmi_flags, /* [] */0);
  return crc;
}

function report_error(ppf, param) {
  switch (param.tag | 0) {
    case /* Not_an_interface */0 :
        return Curry._2(Format.fprintf(ppf, /* Format */[
                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                /* Break */Block.__(0, [
                                    "@ ",
                                    1,
                                    0
                                  ]),
                                /* String_literal */Block.__(11, [
                                    "is not a compiled interface",
                                    /* End_of_format */0
                                  ])
                              ])]),
                        "%a@ is not a compiled interface"
                      ]), print_filename, param[0]);
    case /* Wrong_version_interface */1 :
        return Curry._3(Format.fprintf(ppf, /* Format */[
                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                /* Break */Block.__(0, [
                                    "@ ",
                                    1,
                                    0
                                  ]),
                                /* String_literal */Block.__(11, [
                                    "is not a compiled interface for this version of OCaml.",
                                    /* Formatting_lit */Block.__(17, [
                                        /* Flush_newline */4,
                                        /* String_literal */Block.__(11, [
                                            "It seems to be for ",
                                            /* String */Block.__(2, [
                                                /* No_padding */0,
                                                /* String_literal */Block.__(11, [
                                                    " version of OCaml.",
                                                    /* End_of_format */0
                                                  ])
                                              ])
                                          ])
                                      ])
                                  ])
                              ])]),
                        "%a@ is not a compiled interface for this version of OCaml.@.It seems to be for %s version of OCaml."
                      ]), print_filename, param[0], param[1]);
    case /* Corrupted_interface */2 :
        return Curry._2(Format.fprintf(ppf, /* Format */[
                        /* String_literal */Block.__(11, [
                            "Corrupted compiled interface",
                            /* Formatting_lit */Block.__(17, [
                                /* Break */Block.__(0, [
                                    "@ ",
                                    1,
                                    0
                                  ]),
                                /* Alpha */Block.__(15, [/* End_of_format */0])
                              ])
                          ]),
                        "Corrupted compiled interface@ %a"
                      ]), print_filename, param[0]);
    
  }
}

register_error_of_exn((function (param) {
        if (param[0] === $$Error$1) {
          return error_of_printer_file(report_error, param[1]);
        }
        
      }));

var Inconsistency = Caml_exceptions.create("Ocaml_typedtree_test.Consistbl.Inconsistency");

function set$1(tbl, name, crc, source) {
  return Hashtbl.add(tbl, name, /* tuple */[
              crc,
              source
            ]);
}

function extract(l, tbl) {
  var l$1 = List.sort_uniq($$String.compare, l);
  return List.fold_left((function (assc, name) {
                try {
                  var match = Hashtbl.find(tbl, name);
                  return /* :: */[
                          /* tuple */[
                            name,
                            Caml_option.some(match[0])
                          ],
                          assc
                        ];
                }
                catch (exn){
                  if (exn === Caml_builtin_exceptions.not_found) {
                    return /* :: */[
                            /* tuple */[
                              name,
                              void 0
                            ],
                            assc
                          ];
                  }
                  throw exn;
                }
              }), /* [] */0, l$1);
}

function free_vars(ty) {
  var ret = {
    contents: /* Empty */0
  };
  var loop = function (_ty) {
    while(true) {
      var ty = _ty;
      var ty$1 = repr(ty);
      if (ty$1.level < 0) {
        return ;
      }
      ty$1.level = pivot_level - ty$1.level | 0;
      var match = ty$1.desc;
      if (typeof match === "number") {
        return iter_type_expr(loop, ty$1);
      }
      switch (match.tag | 0) {
        case /* Tvar */0 :
            ret.contents = add$3(ty$1, ret.contents);
            return ;
        case /* Tvariant */8 :
            var row = row_repr_aux(/* [] */0, match[0]);
            iter_row(loop, row);
            if (static_row(row)) {
              return ;
            }
            _ty = row.row_more;
            continue ;
        default:
          return iter_type_expr(loop, ty$1);
      }
    };
  };
  loop(ty);
  unmark_type(ty);
  return ret.contents;
}

var optional_shape_000 = {
  txt: "internal.optional",
  loc: none
};

var optional_shape_001 = /* PStr */Block.__(0, [/* [] */0]);

var optional_shape = /* tuple */[
  optional_shape_000,
  optional_shape_001
];

function extension_descr(path_ext, ext) {
  var match = ext.ext_ret_type;
  var ty_res = match !== void 0 ? match : newty2(100000000, /* Tconstr */Block.__(3, [
            ext.ext_type_path,
            ext.ext_type_params,
            {
              contents: /* Mnil */0
            }
          ]));
  var tag_001 = ext.ext_args === /* [] */0;
  var tag = /* Cstr_extension */Block.__(2, [
      path_ext,
      tag_001
    ]);
  var match$1 = ext.ext_ret_type;
  var existentials;
  if (match$1 !== void 0) {
    var ret_vars = free_vars(match$1);
    var arg_vars = free_vars(newty2(100000000, /* Ttuple */Block.__(2, [ext.ext_args])));
    existentials = elements_aux$1(/* [] */0, diff$1(arg_vars, ret_vars));
  } else {
    existentials = /* [] */0;
  }
  return {
          cstr_name: last(path_ext),
          cstr_res: ty_res,
          cstr_existentials: existentials,
          cstr_args: ext.ext_args,
          cstr_arity: List.length(ext.ext_args),
          cstr_tag: tag,
          cstr_consts: -1,
          cstr_nonconsts: -1,
          cstr_normal: -1,
          cstr_generalized: ext.ext_ret_type !== void 0,
          cstr_private: ext.ext_private,
          cstr_loc: ext.ext_loc,
          cstr_attributes: ext.ext_attributes
        };
}

var none$1 = {
  desc: /* Ttuple */Block.__(2, [/* [] */0]),
  level: -1,
  id: -1
};

var dummy_label_lbl_all = [];

var dummy_label = {
  lbl_name: "",
  lbl_res: none$1,
  lbl_arg: none$1,
  lbl_mut: /* Immutable */0,
  lbl_pos: -1,
  lbl_all: dummy_label_lbl_all,
  lbl_repres: /* Record_regular */0,
  lbl_private: /* Public */1,
  lbl_loc: none,
  lbl_attributes: /* [] */0
};

var builtin_idents = {
  contents: /* [] */0
};

function wrap(create, s) {
  var id = Curry._1(create, s);
  builtin_idents.contents = /* :: */[
    /* tuple */[
      s,
      id
    ],
    builtin_idents.contents
  ];
  return id;
}

var ident_int = wrap(create, "int");

var ident_char = wrap(create, "char");

var ident_string = wrap(create, "string");

var ident_float = wrap(create, "float");

var ident_bool = wrap(create, "bool");

var ident_unit = wrap(create, "unit");

var ident_exn = wrap(create, "exn");

var ident_array = wrap(create, "array");

var ident_list = wrap(create, "list");

var ident_option = wrap(create, "option");

var ident_nativeint = wrap(create, "nativeint");

var ident_int32 = wrap(create, "int32");

var ident_int64 = wrap(create, "int64");

var ident_lazy_t = wrap(create, "lazy_t");

var ident_bytes = wrap(create, "bytes");

var path_int = /* Pident */Block.__(0, [ident_int]);

var path_char = /* Pident */Block.__(0, [ident_char]);

var path_string = /* Pident */Block.__(0, [ident_string]);

var path_float = /* Pident */Block.__(0, [ident_float]);

var path_bool = /* Pident */Block.__(0, [ident_bool]);

var path_unit = /* Pident */Block.__(0, [ident_unit]);

var path_exn = /* Pident */Block.__(0, [ident_exn]);

var path_array = /* Pident */Block.__(0, [ident_array]);

var path_list = /* Pident */Block.__(0, [ident_list]);

var path_option = /* Pident */Block.__(0, [ident_option]);

var path_nativeint = /* Pident */Block.__(0, [ident_nativeint]);

var path_int32 = /* Pident */Block.__(0, [ident_int32]);

var path_int64 = /* Pident */Block.__(0, [ident_int64]);

var path_lazy_t = /* Pident */Block.__(0, [ident_lazy_t]);

var path_bytes = /* Pident */Block.__(0, [ident_bytes]);

var type_int = newty2(100000000, /* Tconstr */Block.__(3, [
        path_int,
        /* [] */0,
        {
          contents: /* Mnil */0
        }
      ]));

var type_char = newty2(100000000, /* Tconstr */Block.__(3, [
        path_char,
        /* [] */0,
        {
          contents: /* Mnil */0
        }
      ]));

var type_string = newty2(100000000, /* Tconstr */Block.__(3, [
        path_string,
        /* [] */0,
        {
          contents: /* Mnil */0
        }
      ]));

var type_float = newty2(100000000, /* Tconstr */Block.__(3, [
        path_float,
        /* [] */0,
        {
          contents: /* Mnil */0
        }
      ]));

var type_bool = newty2(100000000, /* Tconstr */Block.__(3, [
        path_bool,
        /* [] */0,
        {
          contents: /* Mnil */0
        }
      ]));

var type_unit = newty2(100000000, /* Tconstr */Block.__(3, [
        path_unit,
        /* [] */0,
        {
          contents: /* Mnil */0
        }
      ]));

var type_exn = newty2(100000000, /* Tconstr */Block.__(3, [
        path_exn,
        /* [] */0,
        {
          contents: /* Mnil */0
        }
      ]));

function type_array(t) {
  return newty2(100000000, /* Tconstr */Block.__(3, [
                path_array,
                /* :: */[
                  t,
                  /* [] */0
                ],
                {
                  contents: /* Mnil */0
                }
              ]));
}

function type_list(t) {
  return newty2(100000000, /* Tconstr */Block.__(3, [
                path_list,
                /* :: */[
                  t,
                  /* [] */0
                ],
                {
                  contents: /* Mnil */0
                }
              ]));
}

function type_option(t) {
  return newty2(100000000, /* Tconstr */Block.__(3, [
                path_option,
                /* :: */[
                  t,
                  /* [] */0
                ],
                {
                  contents: /* Mnil */0
                }
              ]));
}

var type_nativeint = newty2(100000000, /* Tconstr */Block.__(3, [
        path_nativeint,
        /* [] */0,
        {
          contents: /* Mnil */0
        }
      ]));

var type_int32 = newty2(100000000, /* Tconstr */Block.__(3, [
        path_int32,
        /* [] */0,
        {
          contents: /* Mnil */0
        }
      ]));

var type_int64 = newty2(100000000, /* Tconstr */Block.__(3, [
        path_int64,
        /* [] */0,
        {
          contents: /* Mnil */0
        }
      ]));

function type_lazy_t(t) {
  return newty2(100000000, /* Tconstr */Block.__(3, [
                path_lazy_t,
                /* :: */[
                  t,
                  /* [] */0
                ],
                {
                  contents: /* Mnil */0
                }
              ]));
}

newty2(100000000, /* Tconstr */Block.__(3, [
        path_bytes,
        /* [] */0,
        {
          contents: /* Mnil */0
        }
      ]));

var ident_match_failure = wrap(create_predef_exn, "Match_failure");

var ident_out_of_memory = wrap(create_predef_exn, "Out_of_memory");

var ident_invalid_argument = wrap(create_predef_exn, "Invalid_argument");

var ident_failure = wrap(create_predef_exn, "Failure");

var ident_not_found = wrap(create_predef_exn, "Not_found");

var ident_sys_error = wrap(create_predef_exn, "Sys_error");

var ident_end_of_file = wrap(create_predef_exn, "End_of_file");

var ident_division_by_zero = wrap(create_predef_exn, "Division_by_zero");

var ident_stack_overflow = wrap(create_predef_exn, "Stack_overflow");

var ident_sys_blocked_io = wrap(create_predef_exn, "Sys_blocked_io");

var ident_assert_failure = wrap(create_predef_exn, "Assert_failure");

var ident_undefined_recursive_module = wrap(create_predef_exn, "Undefined_recursive_module");

var decl_abstr = {
  type_params: /* [] */0,
  type_arity: 0,
  type_kind: /* Type_abstract */0,
  type_private: /* Public */1,
  type_manifest: void 0,
  type_variance: /* [] */0,
  type_newtype_level: void 0,
  type_loc: none,
  type_attributes: /* [] */0
};

function cstr(id, args) {
  return {
          cd_id: id,
          cd_args: args,
          cd_res: void 0,
          cd_loc: none,
          cd_attributes: /* [] */0
        };
}

var ident_false = wrap(create, "false");

var ident_true = wrap(create, "true");

var ident_void = wrap(create, "()");

var ident_nil = wrap(create, "[]");

var ident_cons = wrap(create, "::");

var ident_none = wrap(create, "None");

var ident_some = wrap(create, "Some");

function common_initial_env(add_type, add_extension, empty_env) {
  var decl_bool_type_kind = /* Type_variant */Block.__(1, [/* :: */[
        cstr(ident_false, /* [] */0),
        /* :: */[
          cstr(ident_true, /* [] */0),
          /* [] */0
        ]
      ]]);
  var decl_bool = {
    type_params: /* [] */0,
    type_arity: 0,
    type_kind: decl_bool_type_kind,
    type_private: /* Public */1,
    type_manifest: void 0,
    type_variance: /* [] */0,
    type_newtype_level: void 0,
    type_loc: none,
    type_attributes: /* [] */0
  };
  var decl_unit_type_kind = /* Type_variant */Block.__(1, [/* :: */[
        cstr(ident_void, /* [] */0),
        /* [] */0
      ]]);
  var decl_unit = {
    type_params: /* [] */0,
    type_arity: 0,
    type_kind: decl_unit_type_kind,
    type_private: /* Public */1,
    type_manifest: void 0,
    type_variance: /* [] */0,
    type_newtype_level: void 0,
    type_loc: none,
    type_attributes: /* [] */0
  };
  var decl_exn = {
    type_params: /* [] */0,
    type_arity: 0,
    type_kind: /* Type_open */1,
    type_private: /* Public */1,
    type_manifest: void 0,
    type_variance: /* [] */0,
    type_newtype_level: void 0,
    type_loc: none,
    type_attributes: /* [] */0
  };
  var tvar = newty2(100000000, /* Tvar */Block.__(0, [void 0]));
  var decl_array_type_params = /* :: */[
    tvar,
    /* [] */0
  ];
  var decl_array_type_variance = /* :: */[
    Types_Variance.full,
    /* [] */0
  ];
  var decl_array = {
    type_params: decl_array_type_params,
    type_arity: 1,
    type_kind: /* Type_abstract */0,
    type_private: /* Public */1,
    type_manifest: void 0,
    type_variance: decl_array_type_variance,
    type_newtype_level: void 0,
    type_loc: none,
    type_attributes: /* [] */0
  };
  var tvar$1 = newty2(100000000, /* Tvar */Block.__(0, [void 0]));
  var decl_list_type_params = /* :: */[
    tvar$1,
    /* [] */0
  ];
  var decl_list_type_kind = /* Type_variant */Block.__(1, [/* :: */[
        cstr(ident_nil, /* [] */0),
        /* :: */[
          cstr(ident_cons, /* :: */[
                tvar$1,
                /* :: */[
                  type_list(tvar$1),
                  /* [] */0
                ]
              ]),
          /* [] */0
        ]
      ]]);
  var decl_list_type_variance = /* :: */[
    Types_Variance.covariant,
    /* [] */0
  ];
  var decl_list = {
    type_params: decl_list_type_params,
    type_arity: 1,
    type_kind: decl_list_type_kind,
    type_private: /* Public */1,
    type_manifest: void 0,
    type_variance: decl_list_type_variance,
    type_newtype_level: void 0,
    type_loc: none,
    type_attributes: /* [] */0
  };
  var tvar$2 = newty2(100000000, /* Tvar */Block.__(0, [void 0]));
  var decl_option_type_params = /* :: */[
    tvar$2,
    /* [] */0
  ];
  var decl_option_type_kind = /* Type_variant */Block.__(1, [/* :: */[
        cstr(ident_none, /* [] */0),
        /* :: */[
          cstr(ident_some, /* :: */[
                tvar$2,
                /* [] */0
              ]),
          /* [] */0
        ]
      ]]);
  var decl_option_type_variance = /* :: */[
    Types_Variance.covariant,
    /* [] */0
  ];
  var decl_option = {
    type_params: decl_option_type_params,
    type_arity: 1,
    type_kind: decl_option_type_kind,
    type_private: /* Public */1,
    type_manifest: void 0,
    type_variance: decl_option_type_variance,
    type_newtype_level: void 0,
    type_loc: none,
    type_attributes: /* [] */0
  };
  var tvar$3 = newty2(100000000, /* Tvar */Block.__(0, [void 0]));
  var decl_lazy_t_type_params = /* :: */[
    tvar$3,
    /* [] */0
  ];
  var decl_lazy_t_type_variance = /* :: */[
    Types_Variance.covariant,
    /* [] */0
  ];
  var decl_lazy_t = {
    type_params: decl_lazy_t_type_params,
    type_arity: 1,
    type_kind: /* Type_abstract */0,
    type_private: /* Public */1,
    type_manifest: void 0,
    type_variance: decl_lazy_t_type_variance,
    type_newtype_level: void 0,
    type_loc: none,
    type_attributes: /* [] */0
  };
  var add_extension$1 = function (id, l) {
    return Curry._2(add_extension, id, {
                ext_type_path: path_exn,
                ext_type_params: /* [] */0,
                ext_args: l,
                ext_ret_type: void 0,
                ext_private: /* Public */1,
                ext_loc: none,
                ext_attributes: /* [] */0
              });
  };
  return Curry._1(add_extension$1(ident_match_failure, /* :: */[
                  newty2(100000000, /* Ttuple */Block.__(2, [/* :: */[
                            type_string,
                            /* :: */[
                              type_int,
                              /* :: */[
                                type_int,
                                /* [] */0
                              ]
                            ]
                          ]])),
                  /* [] */0
                ]), Curry._1(add_extension$1(ident_out_of_memory, /* [] */0), Curry._1(add_extension$1(ident_stack_overflow, /* [] */0), Curry._1(add_extension$1(ident_invalid_argument, /* :: */[
                              type_string,
                              /* [] */0
                            ]), Curry._1(add_extension$1(ident_failure, /* :: */[
                                  type_string,
                                  /* [] */0
                                ]), Curry._1(add_extension$1(ident_not_found, /* [] */0), Curry._1(add_extension$1(ident_sys_blocked_io, /* [] */0), Curry._1(add_extension$1(ident_sys_error, /* :: */[
                                              type_string,
                                              /* [] */0
                                            ]), Curry._1(add_extension$1(ident_end_of_file, /* [] */0), Curry._1(add_extension$1(ident_division_by_zero, /* [] */0), Curry._1(add_extension$1(ident_assert_failure, /* :: */[
                                                          newty2(100000000, /* Ttuple */Block.__(2, [/* :: */[
                                                                    type_string,
                                                                    /* :: */[
                                                                      type_int,
                                                                      /* :: */[
                                                                        type_int,
                                                                        /* [] */0
                                                                      ]
                                                                    ]
                                                                  ]])),
                                                          /* [] */0
                                                        ]), Curry._1(add_extension$1(ident_undefined_recursive_module, /* :: */[
                                                              newty2(100000000, /* Ttuple */Block.__(2, [/* :: */[
                                                                        type_string,
                                                                        /* :: */[
                                                                          type_int,
                                                                          /* :: */[
                                                                            type_int,
                                                                            /* [] */0
                                                                          ]
                                                                        ]
                                                                      ]])),
                                                              /* [] */0
                                                            ]), Curry._3(add_type, ident_int64, decl_abstr, Curry._3(add_type, ident_int32, decl_abstr, Curry._3(add_type, ident_nativeint, decl_abstr, Curry._3(add_type, ident_lazy_t, decl_lazy_t, Curry._3(add_type, ident_option, decl_option, Curry._3(add_type, ident_list, decl_list, Curry._3(add_type, ident_array, decl_array, Curry._3(add_type, ident_exn, decl_exn, Curry._3(add_type, ident_unit, decl_unit, Curry._3(add_type, ident_bool, decl_bool, Curry._3(add_type, ident_float, decl_abstr, Curry._3(add_type, ident_string, decl_abstr, Curry._3(add_type, ident_char, decl_abstr, Curry._3(add_type, ident_int, decl_abstr, empty_env))))))))))))))))))))))))));
}

function build_initial_env(add_type, add_exception, empty_env) {
  var common = common_initial_env(add_type, add_exception, empty_env);
  var safe_string = Curry._3(add_type, ident_bytes, decl_abstr, common);
  var decl_bytes_unsafe_type_manifest = type_string;
  var decl_bytes_unsafe = {
    type_params: /* [] */0,
    type_arity: 0,
    type_kind: /* Type_abstract */0,
    type_private: /* Public */1,
    type_manifest: decl_bytes_unsafe_type_manifest,
    type_variance: /* [] */0,
    type_newtype_level: void 0,
    type_loc: none,
    type_attributes: /* [] */0
  };
  var unsafe_string = Curry._3(add_type, ident_bytes, decl_bytes_unsafe, common);
  return /* tuple */[
          safe_string,
          unsafe_string
        ];
}

List.map((function (id) {
        make_global(id);
        return /* tuple */[
                id.name,
                id
              ];
      }), /* :: */[
      ident_match_failure,
      /* :: */[
        ident_out_of_memory,
        /* :: */[
          ident_stack_overflow,
          /* :: */[
            ident_invalid_argument,
            /* :: */[
              ident_failure,
              /* :: */[
                ident_not_found,
                /* :: */[
                  ident_sys_error,
                  /* :: */[
                    ident_end_of_file,
                    /* :: */[
                      ident_division_by_zero,
                      /* :: */[
                        ident_sys_blocked_io,
                        /* :: */[
                          ident_assert_failure,
                          /* :: */[
                            ident_undefined_recursive_module,
                            /* [] */0
                          ]
                        ]
                      ]
                    ]
                  ]
                ]
              ]
            ]
          ]
        ]
      ]
    ]);

set_current_time(999);

List.rev(builtin_idents.contents);

var docstrings = {
  contents: /* [] */0
};

function warn_bad_docstrings(param) {
  if (is_active(/* Bad_docstring */Block.__(33, [true]))) {
    return List.iter((function (ds) {
                  var match = ds.ds_attached;
                  switch (match) {
                    case /* Unattached */0 :
                        return prerr_warning(ds.ds_loc, /* Bad_docstring */Block.__(33, [true]));
                    case /* Info */1 :
                        return ;
                    case /* Docs */2 :
                        var match$1 = ds.ds_associated;
                        if (match$1 >= 2) {
                          return prerr_warning(ds.ds_loc, /* Bad_docstring */Block.__(33, [false]));
                        } else {
                          return ;
                        }
                    
                  }
                }), List.rev(docstrings.contents));
  }
  
}

function docstring(body, loc) {
  var ds = {
    ds_body: body,
    ds_loc: loc,
    ds_attached: /* Unattached */0,
    ds_associated: /* Zero */0
  };
  docstrings.contents = /* :: */[
    ds,
    docstrings.contents
  ];
  return ds;
}

var empty_docs = {
  docs_pre: void 0,
  docs_post: void 0
};

var doc_loc = {
  txt: "ocaml.doc",
  loc: none
};

function docs_attr(ds) {
  var exp_pexp_desc = /* Pexp_constant */Block.__(1, [/* Const_string */Block.__(2, [
          ds.ds_body,
          void 0
        ])]);
  var exp_pexp_loc = ds.ds_loc;
  var exp = {
    pexp_desc: exp_pexp_desc,
    pexp_loc: exp_pexp_loc,
    pexp_attributes: /* [] */0
  };
  var item_pstr_desc = /* Pstr_eval */Block.__(0, [
      exp,
      /* [] */0
    ]);
  var item_pstr_loc = exp_pexp_loc;
  var item = {
    pstr_desc: item_pstr_desc,
    pstr_loc: item_pstr_loc
  };
  return /* tuple */[
          doc_loc,
          /* PStr */Block.__(0, [/* :: */[
                item,
                /* [] */0
              ]])
        ];
}

function add_docs_attrs(docs, attrs) {
  var match = docs.docs_pre;
  var attrs$1 = match !== void 0 ? /* :: */[
      docs_attr(match),
      attrs
    ] : attrs;
  var match$1 = docs.docs_post;
  if (match$1 !== void 0) {
    return Pervasives.$at(attrs$1, /* :: */[
                docs_attr(match$1),
                /* [] */0
              ]);
  } else {
    return attrs$1;
  }
}

function add_info_attrs(info, attrs) {
  if (info !== void 0) {
    return Pervasives.$at(attrs, /* :: */[
                docs_attr(info),
                /* [] */0
              ]);
  } else {
    return attrs;
  }
}

var text_loc = {
  txt: "ocaml.text",
  loc: none
};

function text_attr(ds) {
  var exp_pexp_desc = /* Pexp_constant */Block.__(1, [/* Const_string */Block.__(2, [
          ds.ds_body,
          void 0
        ])]);
  var exp_pexp_loc = ds.ds_loc;
  var exp = {
    pexp_desc: exp_pexp_desc,
    pexp_loc: exp_pexp_loc,
    pexp_attributes: /* [] */0
  };
  var item_pstr_desc = /* Pstr_eval */Block.__(0, [
      exp,
      /* [] */0
    ]);
  var item_pstr_loc = exp_pexp_loc;
  var item = {
    pstr_desc: item_pstr_desc,
    pstr_loc: item_pstr_loc
  };
  return /* tuple */[
          text_loc,
          /* PStr */Block.__(0, [/* :: */[
                item,
                /* [] */0
              ]])
        ];
}

function add_text_attrs(dsl, attrs) {
  return Pervasives.$at(List.map(text_attr, dsl), attrs);
}

function get_docstring(info, dsl) {
  var _param = dsl;
  while(true) {
    var param = _param;
    if (!param) {
      return ;
    }
    var ds = param[0];
    var match = ds.ds_attached;
    if (match !== 1) {
      ds.ds_attached = info ? /* Info */1 : /* Docs */2;
      return ds;
    } else {
      _param = param[1];
      continue ;
    }
  };
}

function get_docstrings(dsl) {
  var _acc = /* [] */0;
  var _param = dsl;
  while(true) {
    var param = _param;
    var acc = _acc;
    if (!param) {
      return List.rev(acc);
    }
    var ds = param[0];
    var match = ds.ds_attached;
    if (match !== 1) {
      ds.ds_attached = /* Docs */2;
      _param = param[1];
      _acc = /* :: */[
        ds,
        acc
      ];
      continue ;
    } else {
      _param = param[1];
      continue ;
    }
  };
}

function associate_docstrings(dsl) {
  return List.iter((function (ds) {
                var match = ds.ds_associated;
                if (match !== 0) {
                  ds.ds_associated = /* Many */2;
                  return ;
                } else {
                  ds.ds_associated = /* One */1;
                  return ;
                }
              }), dsl);
}

var pre_table = Hashtbl.create(void 0, 50);

function set_pre_docstrings(pos, dsl) {
  if (dsl !== /* [] */0) {
    return Hashtbl.add(pre_table, pos, dsl);
  }
  
}

function get_pre_docs(pos) {
  try {
    var dsl = Hashtbl.find(pre_table, pos);
    associate_docstrings(dsl);
    return get_docstring(false, dsl);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return ;
    }
    throw exn;
  }
}

function mark_pre_docs(pos) {
  try {
    return associate_docstrings(Hashtbl.find(pre_table, pos));
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return ;
    }
    throw exn;
  }
}

var post_table = Hashtbl.create(void 0, 50);

function set_post_docstrings(pos, dsl) {
  if (dsl !== /* [] */0) {
    return Hashtbl.add(post_table, pos, dsl);
  }
  
}

function get_post_docs(pos) {
  try {
    var dsl = Hashtbl.find(post_table, pos);
    associate_docstrings(dsl);
    return get_docstring(false, dsl);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return ;
    }
    throw exn;
  }
}

function mark_post_docs(pos) {
  try {
    return associate_docstrings(Hashtbl.find(post_table, pos));
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return ;
    }
    throw exn;
  }
}

function get_info(pos) {
  try {
    var dsl = Hashtbl.find(post_table, pos);
    return get_docstring(true, dsl);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return ;
    }
    throw exn;
  }
}

var floating_table = Hashtbl.create(void 0, 50);

function set_floating_docstrings(pos, dsl) {
  if (dsl !== /* [] */0) {
    return Hashtbl.add(floating_table, pos, dsl);
  }
  
}

function get_text(pos) {
  try {
    return get_docstrings(Hashtbl.find(floating_table, pos));
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* [] */0;
    }
    throw exn;
  }
}

var pre_extra_table = Hashtbl.create(void 0, 50);

function set_pre_extra_docstrings(pos, dsl) {
  if (dsl !== /* [] */0) {
    return Hashtbl.add(pre_extra_table, pos, dsl);
  }
  
}

function get_pre_extra_text(pos) {
  try {
    return get_docstrings(Hashtbl.find(pre_extra_table, pos));
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* [] */0;
    }
    throw exn;
  }
}

var post_extra_table = Hashtbl.create(void 0, 50);

function set_post_extra_docstrings(pos, dsl) {
  if (dsl !== /* [] */0) {
    return Hashtbl.add(post_extra_table, pos, dsl);
  }
  
}

function get_post_extra_text(pos) {
  try {
    return get_docstrings(Hashtbl.find(post_extra_table, pos));
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* [] */0;
    }
    throw exn;
  }
}

function symbol_docs(param) {
  return {
          docs_pre: get_pre_docs(Parsing.symbol_start_pos(void 0)),
          docs_post: get_post_docs(Parsing.symbol_end_pos(void 0))
        };
}

function symbol_docs_lazy(param) {
  var p1 = Parsing.symbol_start_pos(void 0);
  var p2 = Parsing.symbol_end_pos(void 0);
  return Caml_obj.caml_lazy_make((function (param) {
                return {
                        docs_pre: get_pre_docs(p1),
                        docs_post: get_post_docs(p2)
                      };
              }));
}

function mark_symbol_docs(param) {
  mark_pre_docs(Parsing.symbol_start_pos(void 0));
  return mark_post_docs(Parsing.symbol_end_pos(void 0));
}

function mark_rhs_docs(pos1, pos2) {
  mark_pre_docs(Parsing.rhs_start_pos(pos1));
  return mark_post_docs(Parsing.rhs_end_pos(pos2));
}

function symbol_text_lazy(param) {
  var pos = Parsing.symbol_start_pos(void 0);
  return Caml_obj.caml_lazy_make((function (param) {
                return get_text(pos);
              }));
}

function init(param) {
  docstrings.contents = /* [] */0;
  Hashtbl.reset(pre_table);
  Hashtbl.reset(post_table);
  Hashtbl.reset(floating_table);
  Hashtbl.reset(pre_extra_table);
  return Hashtbl.reset(post_extra_table);
}

var default_loc = {
  contents: none
};

function mk(locOpt, attrsOpt, d) {
  var loc = locOpt !== void 0 ? locOpt : default_loc.contents;
  var attrs = attrsOpt !== void 0 ? attrsOpt : /* [] */0;
  return {
          ptyp_desc: d,
          ptyp_loc: loc,
          ptyp_attributes: attrs
        };
}

function attr(d, a) {
  return {
          ptyp_desc: d.ptyp_desc,
          ptyp_loc: d.ptyp_loc,
          ptyp_attributes: Pervasives.$at(d.ptyp_attributes, /* :: */[
                a,
                /* [] */0
              ])
        };
}

function $$var(loc, attrs, a) {
  return mk(loc, attrs, /* Ptyp_var */Block.__(0, [a]));
}

function arrow(loc, attrs, a, b, c) {
  return mk(loc, attrs, /* Ptyp_arrow */Block.__(1, [
                a,
                b,
                c
              ]));
}

function tuple(loc, attrs, a) {
  return mk(loc, attrs, /* Ptyp_tuple */Block.__(2, [a]));
}

function constr(loc, attrs, a, b) {
  return mk(loc, attrs, /* Ptyp_constr */Block.__(3, [
                a,
                b
              ]));
}

function object_(loc, attrs, a, b) {
  return mk(loc, attrs, /* Ptyp_object */Block.__(4, [
                a,
                b
              ]));
}

function class_(loc, attrs, a, b) {
  return mk(loc, attrs, /* Ptyp_class */Block.__(5, [
                a,
                b
              ]));
}

function alias(loc, attrs, a, b) {
  return mk(loc, attrs, /* Ptyp_alias */Block.__(6, [
                a,
                b
              ]));
}

function variant(loc, attrs, a, b, c) {
  return mk(loc, attrs, /* Ptyp_variant */Block.__(7, [
                a,
                b,
                c
              ]));
}

function poly(loc, attrs, a, b) {
  return mk(loc, attrs, /* Ptyp_poly */Block.__(8, [
                a,
                b
              ]));
}

function $$package(loc, attrs, a, b) {
  return mk(loc, attrs, /* Ptyp_package */Block.__(9, [/* tuple */[
                  a,
                  b
                ]]));
}

function extension(loc, attrs, a) {
  return mk(loc, attrs, /* Ptyp_extension */Block.__(10, [a]));
}

function force_poly(t) {
  var match = t.ptyp_desc;
  if (typeof match !== "number" && match.tag === /* Ptyp_poly */8) {
    return t;
  }
  return poly(t.ptyp_loc, void 0, /* [] */0, t);
}

function mk$1(locOpt, attrsOpt, d) {
  var loc = locOpt !== void 0 ? locOpt : default_loc.contents;
  var attrs = attrsOpt !== void 0 ? attrsOpt : /* [] */0;
  return {
          ppat_desc: d,
          ppat_loc: loc,
          ppat_attributes: attrs
        };
}

function attr$1(d, a) {
  return {
          ppat_desc: d.ppat_desc,
          ppat_loc: d.ppat_loc,
          ppat_attributes: Pervasives.$at(d.ppat_attributes, /* :: */[
                a,
                /* [] */0
              ])
        };
}

function $$var$1(loc, attrs, a) {
  return mk$1(loc, attrs, /* Ppat_var */Block.__(0, [a]));
}

function alias$1(loc, attrs, a, b) {
  return mk$1(loc, attrs, /* Ppat_alias */Block.__(1, [
                a,
                b
              ]));
}

function constant(loc, attrs, a) {
  return mk$1(loc, attrs, /* Ppat_constant */Block.__(2, [a]));
}

function interval(loc, attrs, a, b) {
  return mk$1(loc, attrs, /* Ppat_interval */Block.__(3, [
                a,
                b
              ]));
}

function tuple$1(loc, attrs, a) {
  return mk$1(loc, attrs, /* Ppat_tuple */Block.__(4, [a]));
}

function construct(loc, attrs, a, b) {
  return mk$1(loc, attrs, /* Ppat_construct */Block.__(5, [
                a,
                b
              ]));
}

function variant$1(loc, attrs, a, b) {
  return mk$1(loc, attrs, /* Ppat_variant */Block.__(6, [
                a,
                b
              ]));
}

function record(loc, attrs, a, b) {
  return mk$1(loc, attrs, /* Ppat_record */Block.__(7, [
                a,
                b
              ]));
}

function array(loc, attrs, a) {
  return mk$1(loc, attrs, /* Ppat_array */Block.__(8, [a]));
}

function or_(loc, attrs, a, b) {
  return mk$1(loc, attrs, /* Ppat_or */Block.__(9, [
                a,
                b
              ]));
}

function constraint_(loc, attrs, a, b) {
  return mk$1(loc, attrs, /* Ppat_constraint */Block.__(10, [
                a,
                b
              ]));
}

function type_(loc, attrs, a) {
  return mk$1(loc, attrs, /* Ppat_type */Block.__(11, [a]));
}

function lazy_(loc, attrs, a) {
  return mk$1(loc, attrs, /* Ppat_lazy */Block.__(12, [a]));
}

function unpack(loc, attrs, a) {
  return mk$1(loc, attrs, /* Ppat_unpack */Block.__(13, [a]));
}

function exception_(loc, attrs, a) {
  return mk$1(loc, attrs, /* Ppat_exception */Block.__(14, [a]));
}

function extension$1(loc, attrs, a) {
  return mk$1(loc, attrs, /* Ppat_extension */Block.__(15, [a]));
}

function mk$2(locOpt, attrsOpt, d) {
  var loc = locOpt !== void 0 ? locOpt : default_loc.contents;
  var attrs = attrsOpt !== void 0 ? attrsOpt : /* [] */0;
  return {
          pexp_desc: d,
          pexp_loc: loc,
          pexp_attributes: attrs
        };
}

function attr$2(d, a) {
  return {
          pexp_desc: d.pexp_desc,
          pexp_loc: d.pexp_loc,
          pexp_attributes: Pervasives.$at(d.pexp_attributes, /* :: */[
                a,
                /* [] */0
              ])
        };
}

function ident(loc, attrs, a) {
  return mk$2(loc, attrs, /* Pexp_ident */Block.__(0, [a]));
}

function constant$1(loc, attrs, a) {
  return mk$2(loc, attrs, /* Pexp_constant */Block.__(1, [a]));
}

function let_(loc, attrs, a, b, c) {
  return mk$2(loc, attrs, /* Pexp_let */Block.__(2, [
                a,
                b,
                c
              ]));
}

function fun_(loc, attrs, a, b, c, d) {
  return mk$2(loc, attrs, /* Pexp_fun */Block.__(4, [
                a,
                b,
                c,
                d
              ]));
}

function function_(loc, attrs, a) {
  return mk$2(loc, attrs, /* Pexp_function */Block.__(3, [a]));
}

function apply(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_apply */Block.__(5, [
                a,
                b
              ]));
}

function match_(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_match */Block.__(6, [
                a,
                b
              ]));
}

function try_(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_try */Block.__(7, [
                a,
                b
              ]));
}

function tuple$2(loc, attrs, a) {
  return mk$2(loc, attrs, /* Pexp_tuple */Block.__(8, [a]));
}

function construct$1(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_construct */Block.__(9, [
                a,
                b
              ]));
}

function variant$2(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_variant */Block.__(10, [
                a,
                b
              ]));
}

function record$1(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_record */Block.__(11, [
                a,
                b
              ]));
}

function field(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_field */Block.__(12, [
                a,
                b
              ]));
}

function setfield(loc, attrs, a, b, c) {
  return mk$2(loc, attrs, /* Pexp_setfield */Block.__(13, [
                a,
                b,
                c
              ]));
}

function array$1(loc, attrs, a) {
  return mk$2(loc, attrs, /* Pexp_array */Block.__(14, [a]));
}

function ifthenelse(loc, attrs, a, b, c) {
  return mk$2(loc, attrs, /* Pexp_ifthenelse */Block.__(15, [
                a,
                b,
                c
              ]));
}

function sequence(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_sequence */Block.__(16, [
                a,
                b
              ]));
}

function while_(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_while */Block.__(17, [
                a,
                b
              ]));
}

function for_(loc, attrs, a, b, c, d, e) {
  return mk$2(loc, attrs, /* Pexp_for */Block.__(18, [
                a,
                b,
                c,
                d,
                e
              ]));
}

function constraint_$1(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_constraint */Block.__(19, [
                a,
                b
              ]));
}

function coerce(loc, attrs, a, b, c) {
  return mk$2(loc, attrs, /* Pexp_coerce */Block.__(20, [
                a,
                b,
                c
              ]));
}

function send(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_send */Block.__(21, [
                a,
                b
              ]));
}

function new_(loc, attrs, a) {
  return mk$2(loc, attrs, /* Pexp_new */Block.__(22, [a]));
}

function setinstvar(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_setinstvar */Block.__(23, [
                a,
                b
              ]));
}

function override(loc, attrs, a) {
  return mk$2(loc, attrs, /* Pexp_override */Block.__(24, [a]));
}

function letmodule(loc, attrs, a, b, c) {
  return mk$2(loc, attrs, /* Pexp_letmodule */Block.__(25, [
                a,
                b,
                c
              ]));
}

function assert_(loc, attrs, a) {
  return mk$2(loc, attrs, /* Pexp_assert */Block.__(26, [a]));
}

function lazy_$1(loc, attrs, a) {
  return mk$2(loc, attrs, /* Pexp_lazy */Block.__(27, [a]));
}

function poly$1(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_poly */Block.__(28, [
                a,
                b
              ]));
}

function object_$1(loc, attrs, a) {
  return mk$2(loc, attrs, /* Pexp_object */Block.__(29, [a]));
}

function newtype(loc, attrs, a, b) {
  return mk$2(loc, attrs, /* Pexp_newtype */Block.__(30, [
                a,
                b
              ]));
}

function pack(loc, attrs, a) {
  return mk$2(loc, attrs, /* Pexp_pack */Block.__(31, [a]));
}

function open_(loc, attrs, a, b, c) {
  return mk$2(loc, attrs, /* Pexp_open */Block.__(32, [
                a,
                b,
                c
              ]));
}

function extension$2(loc, attrs, a) {
  return mk$2(loc, attrs, /* Pexp_extension */Block.__(33, [a]));
}

function $$case(lhs, guard, rhs) {
  return {
          pc_lhs: lhs,
          pc_guard: guard,
          pc_rhs: rhs
        };
}

function mk$3(locOpt, attrsOpt, d) {
  var loc = locOpt !== void 0 ? locOpt : default_loc.contents;
  var attrs = attrsOpt !== void 0 ? attrsOpt : /* [] */0;
  return {
          pmty_desc: d,
          pmty_loc: loc,
          pmty_attributes: attrs
        };
}

function attr$3(d, a) {
  return {
          pmty_desc: d.pmty_desc,
          pmty_loc: d.pmty_loc,
          pmty_attributes: Pervasives.$at(d.pmty_attributes, /* :: */[
                a,
                /* [] */0
              ])
        };
}

function ident$1(loc, attrs, a) {
  return mk$3(loc, attrs, /* Pmty_ident */Block.__(0, [a]));
}

function alias$2(loc, attrs, a) {
  return mk$3(loc, attrs, /* Pmty_alias */Block.__(6, [a]));
}

function signature(loc, attrs, a) {
  return mk$3(loc, attrs, /* Pmty_signature */Block.__(1, [a]));
}

function functor_(loc, attrs, a, b, c) {
  return mk$3(loc, attrs, /* Pmty_functor */Block.__(2, [
                a,
                b,
                c
              ]));
}

function with_(loc, attrs, a, b) {
  return mk$3(loc, attrs, /* Pmty_with */Block.__(3, [
                a,
                b
              ]));
}

function typeof_(loc, attrs, a) {
  return mk$3(loc, attrs, /* Pmty_typeof */Block.__(4, [a]));
}

function extension$3(loc, attrs, a) {
  return mk$3(loc, attrs, /* Pmty_extension */Block.__(5, [a]));
}

function mk$4(locOpt, attrsOpt, d) {
  var loc = locOpt !== void 0 ? locOpt : default_loc.contents;
  var attrs = attrsOpt !== void 0 ? attrsOpt : /* [] */0;
  return {
          pmod_desc: d,
          pmod_loc: loc,
          pmod_attributes: attrs
        };
}

function attr$4(d, a) {
  return {
          pmod_desc: d.pmod_desc,
          pmod_loc: d.pmod_loc,
          pmod_attributes: Pervasives.$at(d.pmod_attributes, /* :: */[
                a,
                /* [] */0
              ])
        };
}

function ident$2(loc, attrs, x) {
  return mk$4(loc, attrs, /* Pmod_ident */Block.__(0, [x]));
}

function structure(loc, attrs, x) {
  return mk$4(loc, attrs, /* Pmod_structure */Block.__(1, [x]));
}

function functor_$1(loc, attrs, arg, arg_ty, body) {
  return mk$4(loc, attrs, /* Pmod_functor */Block.__(2, [
                arg,
                arg_ty,
                body
              ]));
}

function apply$1(loc, attrs, m1, m2) {
  return mk$4(loc, attrs, /* Pmod_apply */Block.__(3, [
                m1,
                m2
              ]));
}

function constraint_$2(loc, attrs, m, mty) {
  return mk$4(loc, attrs, /* Pmod_constraint */Block.__(4, [
                m,
                mty
              ]));
}

function unpack$1(loc, attrs, e) {
  return mk$4(loc, attrs, /* Pmod_unpack */Block.__(5, [e]));
}

function extension$4(loc, attrs, a) {
  return mk$4(loc, attrs, /* Pmod_extension */Block.__(6, [a]));
}

function mk$5(locOpt, d) {
  var loc = locOpt !== void 0 ? locOpt : default_loc.contents;
  return {
          psig_desc: d,
          psig_loc: loc
        };
}

function extension$5(loc, attrsOpt, a) {
  var attrs = attrsOpt !== void 0 ? attrsOpt : /* [] */0;
  return mk$5(loc, /* Psig_extension */Block.__(12, [
                a,
                attrs
              ]));
}

function text(txt) {
  return List.map((function (ds) {
                var a = text_attr(ds);
                var loc = ds.ds_loc;
                return mk$5(loc, /* Psig_attribute */Block.__(11, [a]));
              }), txt);
}

function mk$6(locOpt, d) {
  var loc = locOpt !== void 0 ? locOpt : default_loc.contents;
  return {
          pstr_desc: d,
          pstr_loc: loc
        };
}

function $$eval(loc, attrsOpt, a) {
  var attrs = attrsOpt !== void 0 ? attrsOpt : /* [] */0;
  return mk$6(loc, /* Pstr_eval */Block.__(0, [
                a,
                attrs
              ]));
}

function value(loc, a, b) {
  return mk$6(loc, /* Pstr_value */Block.__(1, [
                a,
                b
              ]));
}

function extension$6(loc, attrsOpt, a) {
  var attrs = attrsOpt !== void 0 ? attrsOpt : /* [] */0;
  return mk$6(loc, /* Pstr_extension */Block.__(14, [
                a,
                attrs
              ]));
}

function text$1(txt) {
  return List.map((function (ds) {
                var a = text_attr(ds);
                var loc = ds.ds_loc;
                return mk$6(loc, /* Pstr_attribute */Block.__(13, [a]));
              }), txt);
}

function mk$7(locOpt, attrsOpt, d) {
  var loc = locOpt !== void 0 ? locOpt : default_loc.contents;
  var attrs = attrsOpt !== void 0 ? attrsOpt : /* [] */0;
  return {
          pcl_desc: d,
          pcl_loc: loc,
          pcl_attributes: attrs
        };
}

function attr$5(d, a) {
  return {
          pcl_desc: d.pcl_desc,
          pcl_loc: d.pcl_loc,
          pcl_attributes: Pervasives.$at(d.pcl_attributes, /* :: */[
                a,
                /* [] */0
              ])
        };
}

function constr$1(loc, attrs, a, b) {
  return mk$7(loc, attrs, /* Pcl_constr */Block.__(0, [
                a,
                b
              ]));
}

function structure$1(loc, attrs, a) {
  return mk$7(loc, attrs, /* Pcl_structure */Block.__(1, [a]));
}

function fun_$1(loc, attrs, a, b, c, d) {
  return mk$7(loc, attrs, /* Pcl_fun */Block.__(2, [
                a,
                b,
                c,
                d
              ]));
}

function apply$2(loc, attrs, a, b) {
  return mk$7(loc, attrs, /* Pcl_apply */Block.__(3, [
                a,
                b
              ]));
}

function let_$1(loc, attrs, a, b, c) {
  return mk$7(loc, attrs, /* Pcl_let */Block.__(4, [
                a,
                b,
                c
              ]));
}

function constraint_$3(loc, attrs, a, b) {
  return mk$7(loc, attrs, /* Pcl_constraint */Block.__(5, [
                a,
                b
              ]));
}

function extension$7(loc, attrs, a) {
  return mk$7(loc, attrs, /* Pcl_extension */Block.__(6, [a]));
}

function mk$8(locOpt, attrsOpt, d) {
  var loc = locOpt !== void 0 ? locOpt : default_loc.contents;
  var attrs = attrsOpt !== void 0 ? attrsOpt : /* [] */0;
  return {
          pcty_desc: d,
          pcty_loc: loc,
          pcty_attributes: attrs
        };
}

function attr$6(d, a) {
  return {
          pcty_desc: d.pcty_desc,
          pcty_loc: d.pcty_loc,
          pcty_attributes: Pervasives.$at(d.pcty_attributes, /* :: */[
                a,
                /* [] */0
              ])
        };
}

function constr$2(loc, attrs, a, b) {
  return mk$8(loc, attrs, /* Pcty_constr */Block.__(0, [
                a,
                b
              ]));
}

function signature$1(loc, attrs, a) {
  return mk$8(loc, attrs, /* Pcty_signature */Block.__(1, [a]));
}

function arrow$1(loc, attrs, a, b, c) {
  return mk$8(loc, attrs, /* Pcty_arrow */Block.__(2, [
                a,
                b,
                c
              ]));
}

function extension$8(loc, attrs, a) {
  return mk$8(loc, attrs, /* Pcty_extension */Block.__(3, [a]));
}

function mk$9(locOpt, attrsOpt, docsOpt, d) {
  var loc = locOpt !== void 0 ? locOpt : default_loc.contents;
  var attrs = attrsOpt !== void 0 ? attrsOpt : /* [] */0;
  var docs = docsOpt !== void 0 ? docsOpt : empty_docs;
  return {
          pctf_desc: d,
          pctf_loc: loc,
          pctf_attributes: add_docs_attrs(docs, attrs)
        };
}

function inherit_(loc, attrs, a) {
  return mk$9(loc, attrs, void 0, /* Pctf_inherit */Block.__(0, [a]));
}

function val_(loc, attrs, a, b, c, d) {
  return mk$9(loc, attrs, void 0, /* Pctf_val */Block.__(1, [/* tuple */[
                  a,
                  b,
                  c,
                  d
                ]]));
}

function method_(loc, attrs, a, b, c, d) {
  return mk$9(loc, attrs, void 0, /* Pctf_method */Block.__(2, [/* tuple */[
                  a,
                  b,
                  c,
                  d
                ]]));
}

function constraint_$4(loc, attrs, a, b) {
  return mk$9(loc, attrs, void 0, /* Pctf_constraint */Block.__(3, [/* tuple */[
                  a,
                  b
                ]]));
}

function extension$9(loc, attrs, a) {
  return mk$9(loc, attrs, void 0, /* Pctf_extension */Block.__(5, [a]));
}

function attribute(loc, a) {
  return mk$9(loc, void 0, void 0, /* Pctf_attribute */Block.__(4, [a]));
}

function text$2(txt) {
  return List.map((function (ds) {
                return attribute(ds.ds_loc, text_attr(ds));
              }), txt);
}

function attr$7(d, a) {
  return {
          pctf_desc: d.pctf_desc,
          pctf_loc: d.pctf_loc,
          pctf_attributes: Pervasives.$at(d.pctf_attributes, /* :: */[
                a,
                /* [] */0
              ])
        };
}

function mk$10(locOpt, attrsOpt, docsOpt, d) {
  var loc = locOpt !== void 0 ? locOpt : default_loc.contents;
  var attrs = attrsOpt !== void 0 ? attrsOpt : /* [] */0;
  var docs = docsOpt !== void 0 ? docsOpt : empty_docs;
  return {
          pcf_desc: d,
          pcf_loc: loc,
          pcf_attributes: add_docs_attrs(docs, attrs)
        };
}

function inherit_$1(loc, attrs, a, b, c) {
  return mk$10(loc, attrs, void 0, /* Pcf_inherit */Block.__(0, [
                a,
                b,
                c
              ]));
}

function val_$1(loc, attrs, a, b, c) {
  return mk$10(loc, attrs, void 0, /* Pcf_val */Block.__(1, [/* tuple */[
                  a,
                  b,
                  c
                ]]));
}

function method_$1(loc, attrs, a, b, c) {
  return mk$10(loc, attrs, void 0, /* Pcf_method */Block.__(2, [/* tuple */[
                  a,
                  b,
                  c
                ]]));
}

function constraint_$5(loc, attrs, a, b) {
  return mk$10(loc, attrs, void 0, /* Pcf_constraint */Block.__(3, [/* tuple */[
                  a,
                  b
                ]]));
}

function initializer_(loc, attrs, a) {
  return mk$10(loc, attrs, void 0, /* Pcf_initializer */Block.__(4, [a]));
}

function extension$10(loc, attrs, a) {
  return mk$10(loc, attrs, void 0, /* Pcf_extension */Block.__(6, [a]));
}

function attribute$1(loc, a) {
  return mk$10(loc, void 0, void 0, /* Pcf_attribute */Block.__(5, [a]));
}

function text$3(txt) {
  return List.map((function (ds) {
                return attribute$1(ds.ds_loc, text_attr(ds));
              }), txt);
}

function virtual_(ct) {
  return /* Cfk_virtual */Block.__(0, [ct]);
}

function concrete(o, e) {
  return /* Cfk_concrete */Block.__(1, [
            o,
            e
          ]);
}

function attr$8(d, a) {
  return {
          pcf_desc: d.pcf_desc,
          pcf_loc: d.pcf_loc,
          pcf_attributes: Pervasives.$at(d.pcf_attributes, /* :: */[
                a,
                /* [] */0
              ])
        };
}

function mk$11(locOpt, attrsOpt, docsOpt, primOpt, name, typ) {
  var loc = locOpt !== void 0 ? locOpt : default_loc.contents;
  var attrs = attrsOpt !== void 0 ? attrsOpt : /* [] */0;
  var docs = docsOpt !== void 0 ? docsOpt : empty_docs;
  var prim = primOpt !== void 0 ? primOpt : /* [] */0;
  return {
          pval_name: name,
          pval_type: typ,
          pval_prim: prim,
          pval_attributes: add_docs_attrs(docs, attrs),
          pval_loc: loc
        };
}

function mk$12(locOpt, attrsOpt, docsOpt, textOpt, name, typ) {
  var loc = locOpt !== void 0 ? locOpt : default_loc.contents;
  var attrs = attrsOpt !== void 0 ? attrsOpt : /* [] */0;
  var docs = docsOpt !== void 0 ? docsOpt : empty_docs;
  var text = textOpt !== void 0 ? textOpt : /* [] */0;
  return {
          pmd_name: name,
          pmd_type: typ,
          pmd_attributes: add_text_attrs(text, add_docs_attrs(docs, attrs)),
          pmd_loc: loc
        };
}

function mk$13(locOpt, attrsOpt, docsOpt, textOpt, typ, name) {
  var loc = locOpt !== void 0 ? locOpt : default_loc.contents;
  var attrs = attrsOpt !== void 0 ? attrsOpt : /* [] */0;
  var docs = docsOpt !== void 0 ? docsOpt : empty_docs;
  var text = textOpt !== void 0 ? textOpt : /* [] */0;
  return {
          pmtd_name: name,
          pmtd_type: typ,
          pmtd_attributes: add_text_attrs(text, add_docs_attrs(docs, attrs)),
          pmtd_loc: loc
        };
}

function mk$14(locOpt, attrsOpt, docsOpt, textOpt, name, expr) {
  var loc = locOpt !== void 0 ? locOpt : default_loc.contents;
  var attrs = attrsOpt !== void 0 ? attrsOpt : /* [] */0;
  var docs = docsOpt !== void 0 ? docsOpt : empty_docs;
  var text = textOpt !== void 0 ? textOpt : /* [] */0;
  return {
          pmb_name: name,
          pmb_expr: expr,
          pmb_attributes: add_text_attrs(text, add_docs_attrs(docs, attrs)),
          pmb_loc: loc
        };
}

function mk$15(locOpt, attrsOpt, docsOpt, overrideOpt, lid) {
  var loc = locOpt !== void 0 ? locOpt : default_loc.contents;
  var attrs = attrsOpt !== void 0 ? attrsOpt : /* [] */0;
  var docs = docsOpt !== void 0 ? docsOpt : empty_docs;
  var override = overrideOpt !== void 0 ? overrideOpt : /* Fresh */1;
  return {
          popen_lid: lid,
          popen_override: override,
          popen_loc: loc,
          popen_attributes: add_docs_attrs(docs, attrs)
        };
}

function mk$16(locOpt, attrsOpt, docsOpt, mexpr) {
  var loc = locOpt !== void 0 ? locOpt : default_loc.contents;
  var attrs = attrsOpt !== void 0 ? attrsOpt : /* [] */0;
  var docs = docsOpt !== void 0 ? docsOpt : empty_docs;
  return {
          pincl_mod: mexpr,
          pincl_loc: loc,
          pincl_attributes: add_docs_attrs(docs, attrs)
        };
}

function mk$17(locOpt, attrsOpt, docsOpt, textOpt, pat, expr) {
  var loc = locOpt !== void 0 ? locOpt : default_loc.contents;
  var attrs = attrsOpt !== void 0 ? attrsOpt : /* [] */0;
  var docs = docsOpt !== void 0 ? docsOpt : empty_docs;
  var text = textOpt !== void 0 ? textOpt : /* [] */0;
  return {
          pvb_pat: pat,
          pvb_expr: expr,
          pvb_attributes: add_text_attrs(text, add_docs_attrs(docs, attrs)),
          pvb_loc: loc
        };
}

function mk$18(locOpt, attrsOpt, docsOpt, textOpt, virtOpt, paramsOpt, name, expr) {
  var loc = locOpt !== void 0 ? locOpt : default_loc.contents;
  var attrs = attrsOpt !== void 0 ? attrsOpt : /* [] */0;
  var docs = docsOpt !== void 0 ? docsOpt : empty_docs;
  var text = textOpt !== void 0 ? textOpt : /* [] */0;
  var virt = virtOpt !== void 0 ? virtOpt : /* Concrete */1;
  var params = paramsOpt !== void 0 ? paramsOpt : /* [] */0;
  return {
          pci_virt: virt,
          pci_params: params,
          pci_name: name,
          pci_expr: expr,
          pci_loc: loc,
          pci_attributes: add_text_attrs(text, add_docs_attrs(docs, attrs))
        };
}

function mk$19(locOpt, attrsOpt, docsOpt, textOpt, paramsOpt, cstrsOpt, kindOpt, privOpt, manifest, name) {
  var loc = locOpt !== void 0 ? locOpt : default_loc.contents;
  var attrs = attrsOpt !== void 0 ? attrsOpt : /* [] */0;
  var docs = docsOpt !== void 0 ? docsOpt : empty_docs;
  var text = textOpt !== void 0 ? textOpt : /* [] */0;
  var params = paramsOpt !== void 0 ? paramsOpt : /* [] */0;
  var cstrs = cstrsOpt !== void 0 ? cstrsOpt : /* [] */0;
  var kind = kindOpt !== void 0 ? kindOpt : /* Ptype_abstract */0;
  var priv = privOpt !== void 0 ? privOpt : /* Public */1;
  return {
          ptype_name: name,
          ptype_params: params,
          ptype_cstrs: cstrs,
          ptype_kind: kind,
          ptype_private: priv,
          ptype_manifest: manifest,
          ptype_attributes: add_text_attrs(text, add_docs_attrs(docs, attrs)),
          ptype_loc: loc
        };
}

function constructor(locOpt, attrsOpt, infoOpt, argsOpt, res, name) {
  var loc = locOpt !== void 0 ? locOpt : default_loc.contents;
  var attrs = attrsOpt !== void 0 ? attrsOpt : /* [] */0;
  var info = infoOpt !== void 0 ? Caml_option.valFromOption(infoOpt) : void 0;
  var args = argsOpt !== void 0 ? argsOpt : /* [] */0;
  return {
          pcd_name: name,
          pcd_args: args,
          pcd_res: res,
          pcd_loc: loc,
          pcd_attributes: add_info_attrs(info, attrs)
        };
}

function field$1(locOpt, attrsOpt, infoOpt, mutOpt, name, typ) {
  var loc = locOpt !== void 0 ? locOpt : default_loc.contents;
  var attrs = attrsOpt !== void 0 ? attrsOpt : /* [] */0;
  var info = infoOpt !== void 0 ? Caml_option.valFromOption(infoOpt) : void 0;
  var mut = mutOpt !== void 0 ? mutOpt : /* Immutable */0;
  return {
          pld_name: name,
          pld_mutable: mut,
          pld_type: typ,
          pld_loc: loc,
          pld_attributes: add_info_attrs(info, attrs)
        };
}

function mk$20(attrsOpt, docsOpt, paramsOpt, privOpt, path, constructors) {
  var attrs = attrsOpt !== void 0 ? attrsOpt : /* [] */0;
  var docs = docsOpt !== void 0 ? docsOpt : empty_docs;
  var params = paramsOpt !== void 0 ? paramsOpt : /* [] */0;
  var priv = privOpt !== void 0 ? privOpt : /* Public */1;
  return {
          ptyext_path: path,
          ptyext_params: params,
          ptyext_constructors: constructors,
          ptyext_private: priv,
          ptyext_attributes: add_docs_attrs(docs, attrs)
        };
}

function constructor$1(locOpt, attrsOpt, docsOpt, infoOpt, name, kind) {
  var loc = locOpt !== void 0 ? locOpt : default_loc.contents;
  var attrs = attrsOpt !== void 0 ? attrsOpt : /* [] */0;
  var docs = docsOpt !== void 0 ? docsOpt : empty_docs;
  var info = infoOpt !== void 0 ? Caml_option.valFromOption(infoOpt) : void 0;
  return {
          pext_name: name,
          pext_kind: kind,
          pext_loc: loc,
          pext_attributes: add_docs_attrs(docs, add_info_attrs(info, attrs))
        };
}

function decl(locOpt, attrsOpt, docsOpt, infoOpt, argsOpt, res, name) {
  var loc = locOpt !== void 0 ? locOpt : default_loc.contents;
  var attrs = attrsOpt !== void 0 ? attrsOpt : /* [] */0;
  var docs = docsOpt !== void 0 ? docsOpt : empty_docs;
  var info = infoOpt !== void 0 ? Caml_option.valFromOption(infoOpt) : void 0;
  var args = argsOpt !== void 0 ? argsOpt : /* [] */0;
  return {
          pext_name: name,
          pext_kind: /* Pext_decl */Block.__(0, [
              args,
              res
            ]),
          pext_loc: loc,
          pext_attributes: add_docs_attrs(docs, add_info_attrs(info, attrs))
        };
}

function rebind(locOpt, attrsOpt, docsOpt, infoOpt, name, lid) {
  var loc = locOpt !== void 0 ? locOpt : default_loc.contents;
  var attrs = attrsOpt !== void 0 ? attrsOpt : /* [] */0;
  var docs = docsOpt !== void 0 ? docsOpt : empty_docs;
  var info = infoOpt !== void 0 ? Caml_option.valFromOption(infoOpt) : void 0;
  return {
          pext_name: name,
          pext_kind: /* Pext_rebind */Block.__(1, [lid]),
          pext_loc: loc,
          pext_attributes: add_docs_attrs(docs, add_info_attrs(info, attrs))
        };
}

var Ast_helper_Exp = {
  mk: mk$2,
  attr: attr$2,
  ident: ident,
  constant: constant$1,
  let_: let_,
  fun_: fun_,
  function_: function_,
  apply: apply,
  match_: match_,
  try_: try_,
  tuple: tuple$2,
  construct: construct$1,
  variant: variant$2,
  record: record$1,
  field: field,
  setfield: setfield,
  array: array$1,
  ifthenelse: ifthenelse,
  sequence: sequence,
  while_: while_,
  for_: for_,
  coerce: coerce,
  constraint_: constraint_$1,
  send: send,
  new_: new_,
  setinstvar: setinstvar,
  override: override,
  letmodule: letmodule,
  assert_: assert_,
  lazy_: lazy_$1,
  poly: poly$1,
  object_: object_$1,
  newtype: newtype,
  pack: pack,
  open_: open_,
  extension: extension$2,
  $$case: $$case
};

var Ast_helper_Ctf = {
  mk: mk$9,
  attr: attr$7,
  inherit_: inherit_,
  val_: val_,
  method_: method_,
  constraint_: constraint_$4,
  extension: extension$9,
  attribute: attribute,
  text: text$2
};

var Ast_helper_Cf = {
  mk: mk$10,
  attr: attr$8,
  inherit_: inherit_$1,
  val_: val_$1,
  method_: method_$1,
  constraint_: constraint_$5,
  initializer_: initializer_,
  extension: extension$10,
  attribute: attribute$1,
  text: text$3,
  virtual_: virtual_,
  concrete: concrete
};

function map_fst(f, param) {
  return /* tuple */[
          Curry._1(f, param[0]),
          param[1]
        ];
}

function map_snd(f, param) {
  return /* tuple */[
          param[0],
          Curry._1(f, param[1])
        ];
}

function map_tuple(f1, f2, param) {
  return /* tuple */[
          Curry._1(f1, param[0]),
          Curry._1(f2, param[1])
        ];
}

function map_opt(f, param) {
  if (param !== void 0) {
    return Caml_option.some(Curry._1(f, Caml_option.valFromOption(param)));
  }
  
}

function map_loc(sub, param) {
  return {
          txt: param.txt,
          loc: Curry._2(sub.location, sub, param.loc)
        };
}

function map$1(sub, param) {
  var desc = param.ptyp_desc;
  var loc = Curry._2(sub.location, sub, param.ptyp_loc);
  var attrs = Curry._2(sub.attributes, sub, param.ptyp_attributes);
  if (typeof desc === "number") {
    return mk(loc, attrs, /* Ptyp_any */0);
  }
  switch (desc.tag | 0) {
    case /* Ptyp_var */0 :
        return $$var(loc, attrs, desc[0]);
    case /* Ptyp_arrow */1 :
        return arrow(loc, attrs, desc[0], Curry._2(sub.typ, sub, desc[1]), Curry._2(sub.typ, sub, desc[2]));
    case /* Ptyp_tuple */2 :
        return tuple(loc, attrs, List.map(Curry._1(sub.typ, sub), desc[0]));
    case /* Ptyp_constr */3 :
        return constr(loc, attrs, map_loc(sub, desc[0]), List.map(Curry._1(sub.typ, sub), desc[1]));
    case /* Ptyp_object */4 :
        var f = function (param) {
          return /* tuple */[
                  param[0],
                  Curry._2(sub.attributes, sub, param[1]),
                  Curry._2(sub.typ, sub, param[2])
                ];
        };
        return object_(loc, attrs, List.map(f, desc[0]), desc[1]);
    case /* Ptyp_class */5 :
        return class_(loc, attrs, map_loc(sub, desc[0]), List.map(Curry._1(sub.typ, sub), desc[1]));
    case /* Ptyp_alias */6 :
        return alias(loc, attrs, Curry._2(sub.typ, sub, desc[0]), desc[1]);
    case /* Ptyp_variant */7 :
        return variant(loc, attrs, List.map((function (param) {
                          if (param.tag) {
                            return /* Rinherit */Block.__(1, [Curry._2(sub.typ, sub, param[0])]);
                          } else {
                            return /* Rtag */Block.__(0, [
                                      param[0],
                                      Curry._2(sub.attributes, sub, param[1]),
                                      param[2],
                                      List.map(Curry._1(sub.typ, sub), param[3])
                                    ]);
                          }
                        }), desc[0]), desc[1], desc[2]);
    case /* Ptyp_poly */8 :
        return poly(loc, attrs, desc[0], Curry._2(sub.typ, sub, desc[1]));
    case /* Ptyp_package */9 :
        var match = desc[0];
        var partial_arg = Curry._1(sub.typ, sub);
        return $$package(loc, attrs, map_loc(sub, match[0]), List.map((function (param) {
                          return map_tuple((function (param) {
                                        return map_loc(sub, param);
                                      }), partial_arg, param);
                        }), match[1]));
    case /* Ptyp_extension */10 :
        return extension(loc, attrs, Curry._2(sub.extension, sub, desc[0]));
    
  }
}

function map_type_declaration(sub, param) {
  var partial_arg = Curry._1(sub.typ, sub);
  var partial_arg$1 = Curry._1(sub.location, sub);
  var partial_arg$2 = Curry._1(sub.typ, sub);
  var partial_arg$3 = Curry._1(sub.typ, sub);
  return mk$19(Curry._2(sub.location, sub, param.ptype_loc), Curry._2(sub.attributes, sub, param.ptype_attributes), void 0, void 0, List.map((function (param) {
                    return map_fst(partial_arg, param);
                  }), param.ptype_params), List.map((function (param) {
                    return /* tuple */[
                            Curry._1(partial_arg$3, param[0]),
                            Curry._1(partial_arg$2, param[1]),
                            Curry._1(partial_arg$1, param[2])
                          ];
                  }), param.ptype_cstrs), Curry._2(sub.type_kind, sub, param.ptype_kind), param.ptype_private, map_opt(Curry._1(sub.typ, sub), param.ptype_manifest), map_loc(sub, param.ptype_name));
}

function map_type_kind(sub, param) {
  if (typeof param === "number") {
    if (param === /* Ptype_abstract */0) {
      return /* Ptype_abstract */0;
    } else {
      return /* Ptype_open */1;
    }
  } else if (param.tag) {
    return /* Ptype_record */Block.__(1, [List.map(Curry._1(sub.label_declaration, sub), param[0])]);
  } else {
    return /* Ptype_variant */Block.__(0, [List.map(Curry._1(sub.constructor_declaration, sub), param[0])]);
  }
}

function map_type_extension(sub, param) {
  var partial_arg = Curry._1(sub.typ, sub);
  return mk$20(Curry._2(sub.attributes, sub, param.ptyext_attributes), void 0, List.map((function (param) {
                    return map_fst(partial_arg, param);
                  }), param.ptyext_params), param.ptyext_private, map_loc(sub, param.ptyext_path), List.map(Curry._1(sub.extension_constructor, sub), param.ptyext_constructors));
}

function map_extension_constructor_kind(sub, param) {
  if (param.tag) {
    return /* Pext_rebind */Block.__(1, [map_loc(sub, param[0])]);
  } else {
    return /* Pext_decl */Block.__(0, [
              List.map(Curry._1(sub.typ, sub), param[0]),
              map_opt(Curry._1(sub.typ, sub), param[1])
            ]);
  }
}

function map_extension_constructor(sub, param) {
  return constructor$1(Curry._2(sub.location, sub, param.pext_loc), Curry._2(sub.attributes, sub, param.pext_attributes), void 0, void 0, map_loc(sub, param.pext_name), map_extension_constructor_kind(sub, param.pext_kind));
}

function map$2(sub, param) {
  var desc = param.pcty_desc;
  var loc = Curry._2(sub.location, sub, param.pcty_loc);
  var attrs = Curry._2(sub.attributes, sub, param.pcty_attributes);
  switch (desc.tag | 0) {
    case /* Pcty_constr */0 :
        return constr$2(loc, attrs, map_loc(sub, desc[0]), List.map(Curry._1(sub.typ, sub), desc[1]));
    case /* Pcty_signature */1 :
        return signature$1(loc, attrs, Curry._2(sub.class_signature, sub, desc[0]));
    case /* Pcty_arrow */2 :
        return arrow$1(loc, attrs, desc[0], Curry._2(sub.typ, sub, desc[1]), Curry._2(sub.class_type, sub, desc[2]));
    case /* Pcty_extension */3 :
        return extension$8(loc, attrs, Curry._2(sub.extension, sub, desc[0]));
    
  }
}

function map_field(sub, param) {
  var desc = param.pctf_desc;
  var loc = Curry._2(sub.location, sub, param.pctf_loc);
  var attrs = Curry._2(sub.attributes, sub, param.pctf_attributes);
  switch (desc.tag | 0) {
    case /* Pctf_inherit */0 :
        return Curry._3(Ast_helper_Ctf.inherit_, loc, attrs, Curry._2(sub.class_type, sub, desc[0]));
    case /* Pctf_val */1 :
        var match = desc[0];
        return Curry._6(Ast_helper_Ctf.val_, loc, attrs, match[0], match[1], match[2], Curry._2(sub.typ, sub, match[3]));
    case /* Pctf_method */2 :
        var match$1 = desc[0];
        return Curry._6(Ast_helper_Ctf.method_, loc, attrs, match$1[0], match$1[1], match$1[2], Curry._2(sub.typ, sub, match$1[3]));
    case /* Pctf_constraint */3 :
        var match$2 = desc[0];
        return Curry._4(Ast_helper_Ctf.constraint_, loc, attrs, Curry._2(sub.typ, sub, match$2[0]), Curry._2(sub.typ, sub, match$2[1]));
    case /* Pctf_attribute */4 :
        return Curry._2(Ast_helper_Ctf.attribute, loc, Curry._2(sub.attribute, sub, desc[0]));
    case /* Pctf_extension */5 :
        return Curry._3(Ast_helper_Ctf.extension, loc, attrs, Curry._2(sub.extension, sub, desc[0]));
    
  }
}

function map_signature(sub, param) {
  return {
          pcsig_self: Curry._2(sub.typ, sub, param.pcsig_self),
          pcsig_fields: List.map(Curry._1(sub.class_type_field, sub), param.pcsig_fields)
        };
}

function map$3(sub, param) {
  var desc = param.pmty_desc;
  var loc = Curry._2(sub.location, sub, param.pmty_loc);
  var attrs = Curry._2(sub.attributes, sub, param.pmty_attributes);
  switch (desc.tag | 0) {
    case /* Pmty_ident */0 :
        return ident$1(loc, attrs, map_loc(sub, desc[0]));
    case /* Pmty_signature */1 :
        return signature(loc, attrs, Curry._2(sub.signature, sub, desc[0]));
    case /* Pmty_functor */2 :
        return functor_(loc, attrs, map_loc(sub, desc[0]), may_map(Curry._1(sub.module_type, sub), desc[1]), Curry._2(sub.module_type, sub, desc[2]));
    case /* Pmty_with */3 :
        return with_(loc, attrs, Curry._2(sub.module_type, sub, desc[0]), List.map(Curry._1(sub.with_constraint, sub), desc[1]));
    case /* Pmty_typeof */4 :
        return typeof_(loc, attrs, Curry._2(sub.module_expr, sub, desc[0]));
    case /* Pmty_extension */5 :
        return extension$3(loc, attrs, Curry._2(sub.extension, sub, desc[0]));
    case /* Pmty_alias */6 :
        return alias$2(loc, attrs, map_loc(sub, desc[0]));
    
  }
}

function map_with_constraint(sub, param) {
  switch (param.tag | 0) {
    case /* Pwith_type */0 :
        return /* Pwith_type */Block.__(0, [
                  map_loc(sub, param[0]),
                  Curry._2(sub.type_declaration, sub, param[1])
                ]);
    case /* Pwith_module */1 :
        return /* Pwith_module */Block.__(1, [
                  map_loc(sub, param[0]),
                  map_loc(sub, param[1])
                ]);
    case /* Pwith_typesubst */2 :
        return /* Pwith_typesubst */Block.__(2, [Curry._2(sub.type_declaration, sub, param[0])]);
    case /* Pwith_modsubst */3 :
        return /* Pwith_modsubst */Block.__(3, [
                  map_loc(sub, param[0]),
                  map_loc(sub, param[1])
                ]);
    
  }
}

function map_signature_item(sub, param) {
  var desc = param.psig_desc;
  var loc = Curry._2(sub.location, sub, param.psig_loc);
  switch (desc.tag | 0) {
    case /* Psig_value */0 :
        var a = Curry._2(sub.value_description, sub, desc[0]);
        return mk$5(loc, /* Psig_value */Block.__(0, [a]));
    case /* Psig_type */1 :
        var a$1 = List.map(Curry._1(sub.type_declaration, sub), desc[0]);
        return mk$5(loc, /* Psig_type */Block.__(1, [a$1]));
    case /* Psig_typext */2 :
        var a$2 = Curry._2(sub.type_extension, sub, desc[0]);
        return mk$5(loc, /* Psig_typext */Block.__(2, [a$2]));
    case /* Psig_exception */3 :
        var a$3 = Curry._2(sub.extension_constructor, sub, desc[0]);
        return mk$5(loc, /* Psig_exception */Block.__(3, [a$3]));
    case /* Psig_module */4 :
        var a$4 = Curry._2(sub.module_declaration, sub, desc[0]);
        return mk$5(loc, /* Psig_module */Block.__(4, [a$4]));
    case /* Psig_recmodule */5 :
        var a$5 = List.map(Curry._1(sub.module_declaration, sub), desc[0]);
        return mk$5(loc, /* Psig_recmodule */Block.__(5, [a$5]));
    case /* Psig_modtype */6 :
        var a$6 = Curry._2(sub.module_type_declaration, sub, desc[0]);
        return mk$5(loc, /* Psig_modtype */Block.__(6, [a$6]));
    case /* Psig_open */7 :
        var a$7 = Curry._2(sub.open_description, sub, desc[0]);
        return mk$5(loc, /* Psig_open */Block.__(7, [a$7]));
    case /* Psig_include */8 :
        var a$8 = Curry._2(sub.include_description, sub, desc[0]);
        return mk$5(loc, /* Psig_include */Block.__(8, [a$8]));
    case /* Psig_class */9 :
        var a$9 = List.map(Curry._1(sub.class_description, sub), desc[0]);
        return mk$5(loc, /* Psig_class */Block.__(9, [a$9]));
    case /* Psig_class_type */10 :
        var a$10 = List.map(Curry._1(sub.class_type_declaration, sub), desc[0]);
        return mk$5(loc, /* Psig_class_type */Block.__(10, [a$10]));
    case /* Psig_attribute */11 :
        var a$11 = Curry._2(sub.attribute, sub, desc[0]);
        return mk$5(loc, /* Psig_attribute */Block.__(11, [a$11]));
    case /* Psig_extension */12 :
        return extension$5(loc, Curry._2(sub.attributes, sub, desc[1]), Curry._2(sub.extension, sub, desc[0]));
    
  }
}

function map$4(sub, param) {
  var desc = param.pmod_desc;
  var loc = Curry._2(sub.location, sub, param.pmod_loc);
  var attrs = Curry._2(sub.attributes, sub, param.pmod_attributes);
  switch (desc.tag | 0) {
    case /* Pmod_ident */0 :
        return ident$2(loc, attrs, map_loc(sub, desc[0]));
    case /* Pmod_structure */1 :
        return structure(loc, attrs, Curry._2(sub.structure, sub, desc[0]));
    case /* Pmod_functor */2 :
        return functor_$1(loc, attrs, map_loc(sub, desc[0]), may_map(Curry._1(sub.module_type, sub), desc[1]), Curry._2(sub.module_expr, sub, desc[2]));
    case /* Pmod_apply */3 :
        return apply$1(loc, attrs, Curry._2(sub.module_expr, sub, desc[0]), Curry._2(sub.module_expr, sub, desc[1]));
    case /* Pmod_constraint */4 :
        return constraint_$2(loc, attrs, Curry._2(sub.module_expr, sub, desc[0]), Curry._2(sub.module_type, sub, desc[1]));
    case /* Pmod_unpack */5 :
        return unpack$1(loc, attrs, Curry._2(sub.expr, sub, desc[0]));
    case /* Pmod_extension */6 :
        return extension$4(loc, attrs, Curry._2(sub.extension, sub, desc[0]));
    
  }
}

function map_structure_item(sub, param) {
  var desc = param.pstr_desc;
  var loc = Curry._2(sub.location, sub, param.pstr_loc);
  switch (desc.tag | 0) {
    case /* Pstr_eval */0 :
        return $$eval(loc, Curry._2(sub.attributes, sub, desc[1]), Curry._2(sub.expr, sub, desc[0]));
    case /* Pstr_value */1 :
        return value(loc, desc[0], List.map(Curry._1(sub.value_binding, sub), desc[1]));
    case /* Pstr_primitive */2 :
        var a = Curry._2(sub.value_description, sub, desc[0]);
        return mk$6(loc, /* Pstr_primitive */Block.__(2, [a]));
    case /* Pstr_type */3 :
        var a$1 = List.map(Curry._1(sub.type_declaration, sub), desc[0]);
        return mk$6(loc, /* Pstr_type */Block.__(3, [a$1]));
    case /* Pstr_typext */4 :
        var a$2 = Curry._2(sub.type_extension, sub, desc[0]);
        return mk$6(loc, /* Pstr_typext */Block.__(4, [a$2]));
    case /* Pstr_exception */5 :
        var a$3 = Curry._2(sub.extension_constructor, sub, desc[0]);
        return mk$6(loc, /* Pstr_exception */Block.__(5, [a$3]));
    case /* Pstr_module */6 :
        var a$4 = Curry._2(sub.module_binding, sub, desc[0]);
        return mk$6(loc, /* Pstr_module */Block.__(6, [a$4]));
    case /* Pstr_recmodule */7 :
        var a$5 = List.map(Curry._1(sub.module_binding, sub), desc[0]);
        return mk$6(loc, /* Pstr_recmodule */Block.__(7, [a$5]));
    case /* Pstr_modtype */8 :
        var a$6 = Curry._2(sub.module_type_declaration, sub, desc[0]);
        return mk$6(loc, /* Pstr_modtype */Block.__(8, [a$6]));
    case /* Pstr_open */9 :
        var a$7 = Curry._2(sub.open_description, sub, desc[0]);
        return mk$6(loc, /* Pstr_open */Block.__(9, [a$7]));
    case /* Pstr_class */10 :
        var a$8 = List.map(Curry._1(sub.class_declaration, sub), desc[0]);
        return mk$6(loc, /* Pstr_class */Block.__(10, [a$8]));
    case /* Pstr_class_type */11 :
        var a$9 = List.map(Curry._1(sub.class_type_declaration, sub), desc[0]);
        return mk$6(loc, /* Pstr_class_type */Block.__(11, [a$9]));
    case /* Pstr_include */12 :
        var a$10 = Curry._2(sub.include_declaration, sub, desc[0]);
        return mk$6(loc, /* Pstr_include */Block.__(12, [a$10]));
    case /* Pstr_attribute */13 :
        var a$11 = Curry._2(sub.attribute, sub, desc[0]);
        return mk$6(loc, /* Pstr_attribute */Block.__(13, [a$11]));
    case /* Pstr_extension */14 :
        return extension$6(loc, Curry._2(sub.attributes, sub, desc[1]), Curry._2(sub.extension, sub, desc[0]));
    
  }
}

function map$5(sub, param) {
  var desc = param.pexp_desc;
  var loc = Curry._2(sub.location, sub, param.pexp_loc);
  var attrs = Curry._2(sub.attributes, sub, param.pexp_attributes);
  switch (desc.tag | 0) {
    case /* Pexp_ident */0 :
        return Curry._3(Ast_helper_Exp.ident, loc, attrs, map_loc(sub, desc[0]));
    case /* Pexp_constant */1 :
        return Curry._3(Ast_helper_Exp.constant, loc, attrs, desc[0]);
    case /* Pexp_let */2 :
        return Curry._5(Ast_helper_Exp.let_, loc, attrs, desc[0], List.map(Curry._1(sub.value_binding, sub), desc[1]), Curry._2(sub.expr, sub, desc[2]));
    case /* Pexp_function */3 :
        return Curry._3(Ast_helper_Exp.function_, loc, attrs, Curry._2(sub.cases, sub, desc[0]));
    case /* Pexp_fun */4 :
        return Curry._6(Ast_helper_Exp.fun_, loc, attrs, desc[0], map_opt(Curry._1(sub.expr, sub), desc[1]), Curry._2(sub.pat, sub, desc[2]), Curry._2(sub.expr, sub, desc[3]));
    case /* Pexp_apply */5 :
        var partial_arg = Curry._1(sub.expr, sub);
        return Curry._4(Ast_helper_Exp.apply, loc, attrs, Curry._2(sub.expr, sub, desc[0]), List.map((function (param) {
                          return map_snd(partial_arg, param);
                        }), desc[1]));
    case /* Pexp_match */6 :
        return Curry._4(Ast_helper_Exp.match_, loc, attrs, Curry._2(sub.expr, sub, desc[0]), Curry._2(sub.cases, sub, desc[1]));
    case /* Pexp_try */7 :
        return Curry._4(Ast_helper_Exp.try_, loc, attrs, Curry._2(sub.expr, sub, desc[0]), Curry._2(sub.cases, sub, desc[1]));
    case /* Pexp_tuple */8 :
        return Curry._3(Ast_helper_Exp.tuple, loc, attrs, List.map(Curry._1(sub.expr, sub), desc[0]));
    case /* Pexp_construct */9 :
        return Curry._4(Ast_helper_Exp.construct, loc, attrs, map_loc(sub, desc[0]), map_opt(Curry._1(sub.expr, sub), desc[1]));
    case /* Pexp_variant */10 :
        return Curry._4(Ast_helper_Exp.variant, loc, attrs, desc[0], map_opt(Curry._1(sub.expr, sub), desc[1]));
    case /* Pexp_record */11 :
        var partial_arg$1 = Curry._1(sub.expr, sub);
        return Curry._4(Ast_helper_Exp.record, loc, attrs, List.map((function (param) {
                          return map_tuple((function (param) {
                                        return map_loc(sub, param);
                                      }), partial_arg$1, param);
                        }), desc[0]), map_opt(Curry._1(sub.expr, sub), desc[1]));
    case /* Pexp_field */12 :
        return Curry._4(Ast_helper_Exp.field, loc, attrs, Curry._2(sub.expr, sub, desc[0]), map_loc(sub, desc[1]));
    case /* Pexp_setfield */13 :
        return Curry._5(Ast_helper_Exp.setfield, loc, attrs, Curry._2(sub.expr, sub, desc[0]), map_loc(sub, desc[1]), Curry._2(sub.expr, sub, desc[2]));
    case /* Pexp_array */14 :
        return Curry._3(Ast_helper_Exp.array, loc, attrs, List.map(Curry._1(sub.expr, sub), desc[0]));
    case /* Pexp_ifthenelse */15 :
        return Curry._5(Ast_helper_Exp.ifthenelse, loc, attrs, Curry._2(sub.expr, sub, desc[0]), Curry._2(sub.expr, sub, desc[1]), map_opt(Curry._1(sub.expr, sub), desc[2]));
    case /* Pexp_sequence */16 :
        return Curry._4(Ast_helper_Exp.sequence, loc, attrs, Curry._2(sub.expr, sub, desc[0]), Curry._2(sub.expr, sub, desc[1]));
    case /* Pexp_while */17 :
        return Curry._4(Ast_helper_Exp.while_, loc, attrs, Curry._2(sub.expr, sub, desc[0]), Curry._2(sub.expr, sub, desc[1]));
    case /* Pexp_for */18 :
        return Curry._7(Ast_helper_Exp.for_, loc, attrs, Curry._2(sub.pat, sub, desc[0]), Curry._2(sub.expr, sub, desc[1]), Curry._2(sub.expr, sub, desc[2]), desc[3], Curry._2(sub.expr, sub, desc[4]));
    case /* Pexp_constraint */19 :
        return Curry._4(Ast_helper_Exp.constraint_, loc, attrs, Curry._2(sub.expr, sub, desc[0]), Curry._2(sub.typ, sub, desc[1]));
    case /* Pexp_coerce */20 :
        return Curry._5(Ast_helper_Exp.coerce, loc, attrs, Curry._2(sub.expr, sub, desc[0]), map_opt(Curry._1(sub.typ, sub), desc[1]), Curry._2(sub.typ, sub, desc[2]));
    case /* Pexp_send */21 :
        return Curry._4(Ast_helper_Exp.send, loc, attrs, Curry._2(sub.expr, sub, desc[0]), desc[1]);
    case /* Pexp_new */22 :
        return Curry._3(Ast_helper_Exp.new_, loc, attrs, map_loc(sub, desc[0]));
    case /* Pexp_setinstvar */23 :
        return Curry._4(Ast_helper_Exp.setinstvar, loc, attrs, map_loc(sub, desc[0]), Curry._2(sub.expr, sub, desc[1]));
    case /* Pexp_override */24 :
        var partial_arg$2 = Curry._1(sub.expr, sub);
        return Curry._3(Ast_helper_Exp.override, loc, attrs, List.map((function (param) {
                          return map_tuple((function (param) {
                                        return map_loc(sub, param);
                                      }), partial_arg$2, param);
                        }), desc[0]));
    case /* Pexp_letmodule */25 :
        return Curry._5(Ast_helper_Exp.letmodule, loc, attrs, map_loc(sub, desc[0]), Curry._2(sub.module_expr, sub, desc[1]), Curry._2(sub.expr, sub, desc[2]));
    case /* Pexp_assert */26 :
        return Curry._3(Ast_helper_Exp.assert_, loc, attrs, Curry._2(sub.expr, sub, desc[0]));
    case /* Pexp_lazy */27 :
        return Curry._3(Ast_helper_Exp.lazy_, loc, attrs, Curry._2(sub.expr, sub, desc[0]));
    case /* Pexp_poly */28 :
        return Curry._4(Ast_helper_Exp.poly, loc, attrs, Curry._2(sub.expr, sub, desc[0]), map_opt(Curry._1(sub.typ, sub), desc[1]));
    case /* Pexp_object */29 :
        return Curry._3(Ast_helper_Exp.object_, loc, attrs, Curry._2(sub.class_structure, sub, desc[0]));
    case /* Pexp_newtype */30 :
        return Curry._4(Ast_helper_Exp.newtype, loc, attrs, desc[0], Curry._2(sub.expr, sub, desc[1]));
    case /* Pexp_pack */31 :
        return Curry._3(Ast_helper_Exp.pack, loc, attrs, Curry._2(sub.module_expr, sub, desc[0]));
    case /* Pexp_open */32 :
        return Curry._5(Ast_helper_Exp.open_, loc, attrs, desc[0], map_loc(sub, desc[1]), Curry._2(sub.expr, sub, desc[2]));
    case /* Pexp_extension */33 :
        return Curry._3(Ast_helper_Exp.extension, loc, attrs, Curry._2(sub.extension, sub, desc[0]));
    
  }
}

function map$6(sub, param) {
  var desc = param.ppat_desc;
  var loc = Curry._2(sub.location, sub, param.ppat_loc);
  var attrs = Curry._2(sub.attributes, sub, param.ppat_attributes);
  if (typeof desc === "number") {
    return mk$1(loc, attrs, /* Ppat_any */0);
  }
  switch (desc.tag | 0) {
    case /* Ppat_var */0 :
        return $$var$1(loc, attrs, map_loc(sub, desc[0]));
    case /* Ppat_alias */1 :
        return alias$1(loc, attrs, Curry._2(sub.pat, sub, desc[0]), map_loc(sub, desc[1]));
    case /* Ppat_constant */2 :
        return constant(loc, attrs, desc[0]);
    case /* Ppat_interval */3 :
        return interval(loc, attrs, desc[0], desc[1]);
    case /* Ppat_tuple */4 :
        return tuple$1(loc, attrs, List.map(Curry._1(sub.pat, sub), desc[0]));
    case /* Ppat_construct */5 :
        return construct(loc, attrs, map_loc(sub, desc[0]), map_opt(Curry._1(sub.pat, sub), desc[1]));
    case /* Ppat_variant */6 :
        return variant$1(loc, attrs, desc[0], map_opt(Curry._1(sub.pat, sub), desc[1]));
    case /* Ppat_record */7 :
        var partial_arg = Curry._1(sub.pat, sub);
        return record(loc, attrs, List.map((function (param) {
                          return map_tuple((function (param) {
                                        return map_loc(sub, param);
                                      }), partial_arg, param);
                        }), desc[0]), desc[1]);
    case /* Ppat_array */8 :
        return array(loc, attrs, List.map(Curry._1(sub.pat, sub), desc[0]));
    case /* Ppat_or */9 :
        return or_(loc, attrs, Curry._2(sub.pat, sub, desc[0]), Curry._2(sub.pat, sub, desc[1]));
    case /* Ppat_constraint */10 :
        return constraint_(loc, attrs, Curry._2(sub.pat, sub, desc[0]), Curry._2(sub.typ, sub, desc[1]));
    case /* Ppat_type */11 :
        return type_(loc, attrs, map_loc(sub, desc[0]));
    case /* Ppat_lazy */12 :
        return lazy_(loc, attrs, Curry._2(sub.pat, sub, desc[0]));
    case /* Ppat_unpack */13 :
        return unpack(loc, attrs, map_loc(sub, desc[0]));
    case /* Ppat_exception */14 :
        return exception_(loc, attrs, Curry._2(sub.pat, sub, desc[0]));
    case /* Ppat_extension */15 :
        return extension$1(loc, attrs, Curry._2(sub.extension, sub, desc[0]));
    
  }
}

function map$7(sub, param) {
  var desc = param.pcl_desc;
  var loc = Curry._2(sub.location, sub, param.pcl_loc);
  var attrs = Curry._2(sub.attributes, sub, param.pcl_attributes);
  switch (desc.tag | 0) {
    case /* Pcl_constr */0 :
        return constr$1(loc, attrs, map_loc(sub, desc[0]), List.map(Curry._1(sub.typ, sub), desc[1]));
    case /* Pcl_structure */1 :
        return structure$1(loc, attrs, Curry._2(sub.class_structure, sub, desc[0]));
    case /* Pcl_fun */2 :
        return fun_$1(loc, attrs, desc[0], map_opt(Curry._1(sub.expr, sub), desc[1]), Curry._2(sub.pat, sub, desc[2]), Curry._2(sub.class_expr, sub, desc[3]));
    case /* Pcl_apply */3 :
        var partial_arg = Curry._1(sub.expr, sub);
        return apply$2(loc, attrs, Curry._2(sub.class_expr, sub, desc[0]), List.map((function (param) {
                          return map_snd(partial_arg, param);
                        }), desc[1]));
    case /* Pcl_let */4 :
        return let_$1(loc, attrs, desc[0], List.map(Curry._1(sub.value_binding, sub), desc[1]), Curry._2(sub.class_expr, sub, desc[2]));
    case /* Pcl_constraint */5 :
        return constraint_$3(loc, attrs, Curry._2(sub.class_expr, sub, desc[0]), Curry._2(sub.class_type, sub, desc[1]));
    case /* Pcl_extension */6 :
        return extension$7(loc, attrs, Curry._2(sub.extension, sub, desc[0]));
    
  }
}

function map_kind(sub, param) {
  if (param.tag) {
    return /* Cfk_concrete */Block.__(1, [
              param[0],
              Curry._2(sub.expr, sub, param[1])
            ]);
  } else {
    return /* Cfk_virtual */Block.__(0, [Curry._2(sub.typ, sub, param[0])]);
  }
}

function map_field$1(sub, param) {
  var desc = param.pcf_desc;
  var loc = Curry._2(sub.location, sub, param.pcf_loc);
  var attrs = Curry._2(sub.attributes, sub, param.pcf_attributes);
  switch (desc.tag | 0) {
    case /* Pcf_inherit */0 :
        return Curry._5(Ast_helper_Cf.inherit_, loc, attrs, desc[0], Curry._2(sub.class_expr, sub, desc[1]), desc[2]);
    case /* Pcf_val */1 :
        var match = desc[0];
        return Curry._5(Ast_helper_Cf.val_, loc, attrs, map_loc(sub, match[0]), match[1], map_kind(sub, match[2]));
    case /* Pcf_method */2 :
        var match$1 = desc[0];
        return Curry._5(Ast_helper_Cf.method_, loc, attrs, map_loc(sub, match$1[0]), match$1[1], map_kind(sub, match$1[2]));
    case /* Pcf_constraint */3 :
        var match$2 = desc[0];
        return Curry._4(Ast_helper_Cf.constraint_, loc, attrs, Curry._2(sub.typ, sub, match$2[0]), Curry._2(sub.typ, sub, match$2[1]));
    case /* Pcf_initializer */4 :
        return Curry._3(Ast_helper_Cf.initializer_, loc, attrs, Curry._2(sub.expr, sub, desc[0]));
    case /* Pcf_attribute */5 :
        return Curry._2(Ast_helper_Cf.attribute, loc, Curry._2(sub.attribute, sub, desc[0]));
    case /* Pcf_extension */6 :
        return Curry._3(Ast_helper_Cf.extension, loc, attrs, Curry._2(sub.extension, sub, desc[0]));
    
  }
}

function map_structure(sub, param) {
  return {
          pcstr_self: Curry._2(sub.pat, sub, param.pcstr_self),
          pcstr_fields: List.map(Curry._1(sub.class_field, sub), param.pcstr_fields)
        };
}

function class_infos(sub, f, param) {
  var partial_arg = Curry._1(sub.typ, sub);
  return mk$18(Curry._2(sub.location, sub, param.pci_loc), Curry._2(sub.attributes, sub, param.pci_attributes), void 0, void 0, param.pci_virt, List.map((function (param) {
                    return map_fst(partial_arg, param);
                  }), param.pci_params), map_loc(sub, param.pci_name), Curry._1(f, param.pci_expr));
}

function default_mapper_attribute($$this, param) {
  return /* tuple */[
          map_loc($$this, param[0]),
          Curry._2($$this.payload, $$this, param[1])
        ];
}

function default_mapper_attributes($$this, l) {
  return List.map(Curry._1($$this.attribute, $$this), l);
}

function default_mapper_case($$this, param) {
  return {
          pc_lhs: Curry._2($$this.pat, $$this, param.pc_lhs),
          pc_guard: map_opt(Curry._1($$this.expr, $$this), param.pc_guard),
          pc_rhs: Curry._2($$this.expr, $$this, param.pc_rhs)
        };
}

function default_mapper_cases($$this, l) {
  return List.map(Curry._1($$this.case, $$this), l);
}

function default_mapper_class_declaration($$this) {
  var partial_arg = Curry._1($$this.class_expr, $$this);
  return (function (param) {
      return class_infos($$this, partial_arg, param);
    });
}

function default_mapper_class_description($$this) {
  var partial_arg = Curry._1($$this.class_type, $$this);
  return (function (param) {
      return class_infos($$this, partial_arg, param);
    });
}

function default_mapper_class_type_declaration($$this) {
  var partial_arg = Curry._1($$this.class_type, $$this);
  return (function (param) {
      return class_infos($$this, partial_arg, param);
    });
}

function default_mapper_constructor_declaration($$this, param) {
  return constructor(Curry._2($$this.location, $$this, param.pcd_loc), Curry._2($$this.attributes, $$this, param.pcd_attributes), void 0, List.map(Curry._1($$this.typ, $$this), param.pcd_args), map_opt(Curry._1($$this.typ, $$this), param.pcd_res), map_loc($$this, param.pcd_name));
}

function default_mapper_extension($$this, param) {
  return /* tuple */[
          map_loc($$this, param[0]),
          Curry._2($$this.payload, $$this, param[1])
        ];
}

function default_mapper_include_declaration($$this, param) {
  return mk$16(Curry._2($$this.location, $$this, param.pincl_loc), Curry._2($$this.attributes, $$this, param.pincl_attributes), void 0, Curry._2($$this.module_expr, $$this, param.pincl_mod));
}

function default_mapper_include_description($$this, param) {
  return mk$16(Curry._2($$this.location, $$this, param.pincl_loc), Curry._2($$this.attributes, $$this, param.pincl_attributes), void 0, Curry._2($$this.module_type, $$this, param.pincl_mod));
}

function default_mapper_label_declaration($$this, param) {
  return field$1(Curry._2($$this.location, $$this, param.pld_loc), Curry._2($$this.attributes, $$this, param.pld_attributes), void 0, param.pld_mutable, map_loc($$this, param.pld_name), Curry._2($$this.typ, $$this, param.pld_type));
}

function default_mapper_location($$this, l) {
  return l;
}

function default_mapper_module_binding($$this, param) {
  return mk$14(Curry._2($$this.location, $$this, param.pmb_loc), Curry._2($$this.attributes, $$this, param.pmb_attributes), void 0, void 0, map_loc($$this, param.pmb_name), Curry._2($$this.module_expr, $$this, param.pmb_expr));
}

function default_mapper_module_declaration($$this, param) {
  return mk$12(Curry._2($$this.location, $$this, param.pmd_loc), Curry._2($$this.attributes, $$this, param.pmd_attributes), void 0, void 0, map_loc($$this, param.pmd_name), Curry._2($$this.module_type, $$this, param.pmd_type));
}

function default_mapper_module_type_declaration($$this, param) {
  return mk$13(Curry._2($$this.location, $$this, param.pmtd_loc), Curry._2($$this.attributes, $$this, param.pmtd_attributes), void 0, void 0, map_opt(Curry._1($$this.module_type, $$this), param.pmtd_type), map_loc($$this, param.pmtd_name));
}

function default_mapper_open_description($$this, param) {
  return mk$15(Curry._2($$this.location, $$this, param.popen_loc), Curry._2($$this.attributes, $$this, param.popen_attributes), void 0, param.popen_override, map_loc($$this, param.popen_lid));
}

function default_mapper_payload($$this, param) {
  switch (param.tag | 0) {
    case /* PStr */0 :
        return /* PStr */Block.__(0, [Curry._2($$this.structure, $$this, param[0])]);
    case /* PTyp */1 :
        return /* PTyp */Block.__(1, [Curry._2($$this.typ, $$this, param[0])]);
    case /* PPat */2 :
        return /* PPat */Block.__(2, [
                  Curry._2($$this.pat, $$this, param[0]),
                  map_opt(Curry._1($$this.expr, $$this), param[1])
                ]);
    
  }
}

function default_mapper_signature($$this, l) {
  return List.map(Curry._1($$this.signature_item, $$this), l);
}

function default_mapper_structure($$this, l) {
  return List.map(Curry._1($$this.structure_item, $$this), l);
}

function default_mapper_value_binding($$this, param) {
  return mk$17(Curry._2($$this.location, $$this, param.pvb_loc), Curry._2($$this.attributes, $$this, param.pvb_attributes), void 0, void 0, Curry._2($$this.pat, $$this, param.pvb_pat), Curry._2($$this.expr, $$this, param.pvb_expr));
}

function default_mapper_value_description($$this, param) {
  return mk$11(Curry._2($$this.location, $$this, param.pval_loc), Curry._2($$this.attributes, $$this, param.pval_attributes), void 0, param.pval_prim, map_loc($$this, param.pval_name), Curry._2($$this.typ, $$this, param.pval_type));
}

var default_mapper = {
  attribute: default_mapper_attribute,
  attributes: default_mapper_attributes,
  case: default_mapper_case,
  cases: default_mapper_cases,
  class_declaration: default_mapper_class_declaration,
  class_description: default_mapper_class_description,
  class_expr: map$7,
  class_field: map_field$1,
  class_signature: map_signature,
  class_structure: map_structure,
  class_type: map$2,
  class_type_declaration: default_mapper_class_type_declaration,
  class_type_field: map_field,
  constructor_declaration: default_mapper_constructor_declaration,
  expr: map$5,
  extension: default_mapper_extension,
  extension_constructor: map_extension_constructor,
  include_declaration: default_mapper_include_declaration,
  include_description: default_mapper_include_description,
  label_declaration: default_mapper_label_declaration,
  location: default_mapper_location,
  module_binding: default_mapper_module_binding,
  module_declaration: default_mapper_module_declaration,
  module_expr: map$4,
  module_type: map$3,
  module_type_declaration: default_mapper_module_type_declaration,
  open_description: default_mapper_open_description,
  pat: map$6,
  payload: default_mapper_payload,
  signature: default_mapper_signature,
  signature_item: map_signature_item,
  structure: default_mapper_structure,
  structure_item: map_structure_item,
  typ: map$1,
  type_declaration: map_type_declaration,
  type_extension: map_type_extension,
  type_kind: map_type_kind,
  value_binding: default_mapper_value_binding,
  value_description: default_mapper_value_description,
  with_constraint: map_with_constraint
};

function height$4(param) {
  if (param) {
    return param[4];
  } else {
    return 0;
  }
}

function create$5(l, x, d, r) {
  var hl = height$4(l);
  var hr = height$4(r);
  return /* Node */[
          l,
          x,
          d,
          r,
          hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        ];
}

function bal$4(l, x, d, r) {
  var hl = height$4(l);
  var hr = height$4(r);
  if (hl > (hr + 1 | 0)) {
    if (!l) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "tbl.ml",
              35,
              11
            ]
          ];
    }
    var lr = l[3];
    var ld = l[2];
    var lv = l[1];
    var ll = l[0];
    if (height$4(ll) >= height$4(lr)) {
      return create$5(ll, lv, ld, create$5(lr, x, d, r));
    }
    if (lr) {
      return create$5(create$5(ll, lv, ld, lr[0]), lr[1], lr[2], create$5(lr[3], x, d, r));
    }
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "tbl.ml",
            35,
            11
          ]
        ];
  } else {
    if (hr <= (hl + 1 | 0)) {
      return create$5(l, x, d, r);
    }
    if (!r) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "tbl.ml",
              42,
              11
            ]
          ];
    }
    var rl = r[0];
    var rr = r[3];
    if (height$4(rr) >= height$4(rl)) {
      return create$5(create$5(l, x, d, rl), r[1], r[2], rr);
    }
    if (rl) {
      return create$5(create$5(l, x, d, rl[0]), rl[1], rl[2], create$5(rl[3], r[1], r[2], r[3]));
    }
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "tbl.ml",
            42,
            11
          ]
        ];
  }
}

function add$5(x, data, param) {
  if (!param) {
    return /* Node */[
            /* Empty */0,
            x,
            data,
            /* Empty */0,
            1
          ];
  }
  var r = param[3];
  var d = param[2];
  var v = param[1];
  var l = param[0];
  var c = Caml_obj.caml_compare(x, v);
  if (c === 0) {
    return /* Node */[
            l,
            x,
            data,
            r,
            param[4]
          ];
  } else if (c < 0) {
    return bal$4(add$5(x, data, l), v, d, r);
  } else {
    return bal$4(l, v, d, add$5(x, data, r));
  }
}

function find$2(x, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      throw Caml_builtin_exceptions.not_found;
    }
    var c = Caml_obj.caml_compare(x, param[1]);
    if (c === 0) {
      return param[2];
    }
    _param = c < 0 ? param[0] : param[3];
    continue ;
  };
}

function mem$4(x, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return false;
    }
    var c = Caml_obj.caml_compare(x, param[1]);
    if (c === 0) {
      return true;
    }
    _param = c < 0 ? param[0] : param[3];
    continue ;
  };
}

function iter$2(f, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return ;
    }
    iter$2(f, param[0]);
    Curry._2(f, param[1], param[2]);
    _param = param[3];
    continue ;
  };
}

function fold$4(f, _m, _accu) {
  while(true) {
    var accu = _accu;
    var m = _m;
    if (!m) {
      return accu;
    }
    _accu = Curry._3(f, m[1], m[2], fold$4(f, m[0], accu));
    _m = m[3];
    continue ;
  };
}

var identity = {
  types: /* Empty */0,
  modules: /* Empty */0,
  modtypes: /* Empty */0,
  for_saving: false
};

function add_type(id, p, s) {
  return {
          types: add$5(id, p, s.types),
          modules: s.modules,
          modtypes: s.modtypes,
          for_saving: s.for_saving
        };
}

function add_module(id, p, s) {
  return {
          types: s.types,
          modules: add$5(id, p, s.modules),
          modtypes: s.modtypes,
          for_saving: s.for_saving
        };
}

function add_modtype(id, ty, s) {
  return {
          types: s.types,
          modules: s.modules,
          modtypes: add$5(id, ty, s.modtypes),
          for_saving: s.for_saving
        };
}

function for_saving(s) {
  return {
          types: s.types,
          modules: s.modules,
          modtypes: s.modtypes,
          for_saving: true
        };
}

function loc(s, x) {
  if (s.for_saving && !keep_locs.contents) {
    return none;
  } else {
    return x;
  }
}

var newrecord = Caml_obj.caml_obj_dup(default_mapper);

newrecord.location = (function (_this, _loc) {
    return none;
  });

function is_not_doc(param) {
  switch (param[0].txt) {
    case "doc" :
    case "ocaml.doc" :
    case "ocaml.text" :
    case "text" :
        return false;
    default:
      return true;
  }
}

function attrs(s, x) {
  var x$1 = s.for_saving && !keep_docs.contents ? List.filter(is_not_doc)(x) : x;
  if (s.for_saving && !keep_locs.contents) {
    return Curry._2(newrecord.attributes, newrecord, x$1);
  } else {
    return x$1;
  }
}

function module_path(s, p) {
  switch (p.tag | 0) {
    case /* Pident */0 :
        try {
          return find$2(p[0], s.modules);
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            return p;
          }
          throw exn;
        }
    case /* Pdot */1 :
        return /* Pdot */Block.__(1, [
                  module_path(s, p[0]),
                  p[1],
                  p[2]
                ]);
    case /* Papply */2 :
        return /* Papply */Block.__(2, [
                  module_path(s, p[0]),
                  module_path(s, p[1])
                ]);
    
  }
}

function modtype_path(s, p) {
  switch (p.tag | 0) {
    case /* Pident */0 :
        try {
          var match = find$2(p[0], s.modtypes);
          if (match.tag) {
            return fatal_error("Subst.modtype_path");
          } else {
            return match[0];
          }
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            return p;
          }
          throw exn;
        }
    case /* Pdot */1 :
        return /* Pdot */Block.__(1, [
                  module_path(s, p[0]),
                  p[1],
                  p[2]
                ]);
    case /* Papply */2 :
        return fatal_error("Subst.modtype_path");
    
  }
}

function type_path(s, p) {
  switch (p.tag | 0) {
    case /* Pident */0 :
        try {
          return find$2(p[0], s.types);
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            return p;
          }
          throw exn;
        }
    case /* Pdot */1 :
        return /* Pdot */Block.__(1, [
                  module_path(s, p[0]),
                  p[1],
                  p[2]
                ]);
    case /* Papply */2 :
        return fatal_error("Subst.type_path");
    
  }
}

var new_id$1 = {
  contents: -1
};

function newpersty(desc) {
  new_id$1.contents = new_id$1.contents - 1 | 0;
  return {
          desc: desc,
          level: 100000000,
          id: new_id$1.contents
        };
}

function norm(d) {
  if (typeof d === "number") {
    return d;
  }
  switch (d.tag | 0) {
    case /* Tvar */0 :
        if (d[0] !== void 0) {
          return d;
        } else {
          return /* Tvar */Block.__(0, [void 0]);
        }
    case /* Tunivar */9 :
        if (d[0] !== void 0) {
          return d;
        } else {
          return /* Tunivar */Block.__(9, [void 0]);
        }
    default:
      return d;
  }
}

function typexp(s, ty) {
  var ty$1 = repr(ty);
  var desc = ty$1.desc;
  var exit = 0;
  if (typeof desc === "number") {
    exit = 1;
  } else {
    switch (desc.tag | 0) {
      case /* Tsubst */7 :
          return desc[0];
      case /* Tvar */0 :
      case /* Tunivar */9 :
          exit = 2;
          break;
      default:
        exit = 1;
    }
  }
  switch (exit) {
    case 1 :
        var desc$1 = ty$1.desc;
        save_desc(ty$1, desc$1);
        var ty$prime = s.for_saving ? newpersty(/* Tvar */Block.__(0, [void 0])) : newty2(100000000, /* Tvar */Block.__(0, [void 0]));
        ty$1.desc = /* Tsubst */Block.__(7, [ty$prime]);
        var tmp;
        var exit$1 = 0;
        if (typeof desc$1 === "number") {
          exit$1 = 3;
        } else {
          switch (desc$1.tag | 0) {
            case /* Tconstr */3 :
                tmp = /* Tconstr */Block.__(3, [
                    type_path(s, desc$1[0]),
                    List.map((function (param) {
                            return typexp(s, param);
                          }), desc$1[1]),
                    {
                      contents: /* Mnil */0
                    }
                  ]);
                break;
            case /* Tobject */4 :
                var match = desc$1[1].contents;
                var tmp$1;
                if (match !== void 0) {
                  var match$1 = match;
                  tmp$1 = /* tuple */[
                    type_path(s, match$1[0]),
                    List.map((function (param) {
                            return typexp(s, param);
                          }), match$1[1])
                  ];
                } else {
                  tmp$1 = void 0;
                }
                tmp = /* Tobject */Block.__(4, [
                    typexp(s, desc$1[0]),
                    {
                      contents: tmp$1
                    }
                  ]);
                break;
            case /* Tfield */5 :
                var t2 = desc$1[3];
                var k = desc$1[1];
                var m = desc$1[0];
                if (s === identity && ty$1.level < 100000000 && m === dummy_method) {
                  tmp = /* Tfield */Block.__(5, [
                      m,
                      k,
                      desc$1[2],
                      typexp(s, t2)
                    ]);
                } else if (field_kind_repr(k) === /* Fabsent */1) {
                  tmp = /* Tlink */Block.__(6, [typexp(s, t2)]);
                } else {
                  exit$1 = 3;
                }
                break;
            case /* Tvariant */8 :
                var row = row_repr_aux(/* [] */0, desc$1[0]);
                var more = repr(row.row_more);
                var match$2 = more.desc;
                var exit$2 = 0;
                if (typeof match$2 === "number" || match$2.tag !== /* Tsubst */7) {
                  exit$2 = 4;
                } else {
                  var match$3 = match$2[0].desc;
                  if (typeof match$3 === "number" || match$3.tag !== /* Ttuple */2) {
                    exit$2 = 4;
                  } else {
                    var match$4 = match$3[0];
                    if (match$4) {
                      var match$5 = match$4[1];
                      if (match$5 && !match$5[1]) {
                        var ty2 = match$5[0];
                        ty$1.desc = /* Tsubst */Block.__(7, [ty2]);
                        tmp = /* Tlink */Block.__(6, [ty2]);
                      } else {
                        exit$2 = 4;
                      }
                    } else {
                      exit$2 = 4;
                    }
                  }
                }
                if (exit$2 === 4) {
                  var dup = true;
                  if (!s.for_saving) {
                    var tmp$2 = true;
                    if (more.level !== 100000000) {
                      var tmp$3 = true;
                      if (!static_row(row)) {
                        var match$6 = more.desc;
                        var tmp$4;
                        tmp$4 = typeof match$6 === "number" || match$6.tag !== /* Tconstr */3 ? false : true;
                        tmp$3 = tmp$4;
                      }
                      tmp$2 = tmp$3;
                    }
                    dup = tmp$2;
                  }
                  var match$7 = more.desc;
                  var more$prime;
                  var exit$3 = 0;
                  if (typeof match$7 === "number") {
                    more$prime = typexp(s, more);
                  } else {
                    switch (match$7.tag | 0) {
                      case /* Tconstr */3 :
                          more$prime = typexp(s, more);
                          break;
                      case /* Tsubst */7 :
                          more$prime = match$7[0];
                          break;
                      case /* Tvar */0 :
                      case /* Tunivar */9 :
                          exit$3 = 5;
                          break;
                      default:
                        throw [
                              Caml_builtin_exceptions.assert_failure,
                              /* tuple */[
                                "subst.ml",
                                170,
                                23
                              ]
                            ];
                    }
                  }
                  if (exit$3 === 5) {
                    save_desc(more, more.desc);
                    more$prime = s.for_saving ? newpersty(norm(more.desc)) : (
                        dup && is_Tvar(more) ? newty2(100000000, more.desc) : more
                      );
                  }
                  more.desc = /* Tsubst */Block.__(7, [newty2(100000000, /* Ttuple */Block.__(2, [/* :: */[
                                more$prime,
                                /* :: */[
                                  ty$prime,
                                  /* [] */0
                                ]
                              ]]))]);
                  var row$1 = copy_row((function (param) {
                          return typexp(s, param);
                        }), true, row, !dup, more$prime);
                  var match$8 = row$1.row_name;
                  if (match$8 !== void 0) {
                    var match$9 = match$8;
                    tmp = /* Tvariant */Block.__(8, [{
                          row_fields: row$1.row_fields,
                          row_more: row$1.row_more,
                          row_bound: row$1.row_bound,
                          row_closed: row$1.row_closed,
                          row_fixed: row$1.row_fixed,
                          row_name: /* tuple */[
                            type_path(s, match$9[0]),
                            match$9[1]
                          ]
                        }]);
                  } else {
                    tmp = /* Tvariant */Block.__(8, [row$1]);
                  }
                }
                break;
            case /* Tpackage */11 :
                tmp = /* Tpackage */Block.__(11, [
                    modtype_path(s, desc$1[0]),
                    desc$1[1],
                    List.map((function (param) {
                            return typexp(s, param);
                          }), desc$1[2])
                  ]);
                break;
            default:
              exit$1 = 3;
          }
        }
        if (exit$1 === 3) {
          tmp = copy_type_desc(void 0, (function (param) {
                  return typexp(s, param);
                }), desc$1);
        }
        ty$prime.desc = tmp;
        return ty$prime;
    case 2 :
        if (!(s.for_saving || ty$1.id < 0)) {
          return ty$1;
        }
        var ty$prime$1 = s.for_saving ? newpersty(norm(desc)) : newty2(ty$1.level, desc);
        save_desc(ty$1, desc);
        ty$1.desc = /* Tsubst */Block.__(7, [ty$prime$1]);
        return ty$prime$1;
    
  }
}

function type_expr(s, ty) {
  var ty$prime = typexp(s, ty);
  cleanup_types(void 0);
  return ty$prime;
}

function type_declaration(s, decl) {
  var match = decl.type_kind;
  var tmp;
  tmp = typeof match === "number" ? (
      match === /* Type_abstract */0 ? /* Type_abstract */0 : /* Type_open */1
    ) : (
      match.tag ? /* Type_variant */Block.__(1, [List.map((function (c) {
                    return {
                            cd_id: c.cd_id,
                            cd_args: List.map((function (param) {
                                    return typexp(s, param);
                                  }), c.cd_args),
                            cd_res: may_map((function (param) {
                                    return typexp(s, param);
                                  }), c.cd_res),
                            cd_loc: loc(s, c.cd_loc),
                            cd_attributes: attrs(s, c.cd_attributes)
                          };
                  }), match[0])]) : /* Type_record */Block.__(0, [
            List.map((function (l) {
                    return {
                            ld_id: l.ld_id,
                            ld_mutable: l.ld_mutable,
                            ld_type: typexp(s, l.ld_type),
                            ld_loc: loc(s, l.ld_loc),
                            ld_attributes: attrs(s, l.ld_attributes)
                          };
                  }), match[0]),
            match[1]
          ])
    );
  var match$1 = decl.type_manifest;
  var decl_type_params = List.map((function (param) {
          return typexp(s, param);
        }), decl.type_params);
  var decl_type_arity = decl.type_arity;
  var decl_type_private = decl.type_private;
  var decl_type_manifest = match$1 !== void 0 ? typexp(s, match$1) : void 0;
  var decl_type_variance = decl.type_variance;
  var decl_type_loc = loc(s, decl.type_loc);
  var decl_type_attributes = attrs(s, decl.type_attributes);
  var decl$1 = {
    type_params: decl_type_params,
    type_arity: decl_type_arity,
    type_kind: tmp,
    type_private: decl_type_private,
    type_manifest: decl_type_manifest,
    type_variance: decl_type_variance,
    type_newtype_level: void 0,
    type_loc: decl_type_loc,
    type_attributes: decl_type_attributes
  };
  cleanup_types(void 0);
  return decl$1;
}

function class_signature(s, sign) {
  return {
          csig_self: typexp(s, sign.csig_self),
          csig_vars: map((function (param) {
                  return /* tuple */[
                          param[0],
                          param[1],
                          typexp(s, param[2])
                        ];
                }), sign.csig_vars),
          csig_concr: sign.csig_concr,
          csig_inher: List.map((function (param) {
                  return /* tuple */[
                          type_path(s, param[0]),
                          List.map((function (param) {
                                  return typexp(s, param);
                                }), param[1])
                        ];
                }), sign.csig_inher)
        };
}

function class_type(s, param) {
  switch (param.tag | 0) {
    case /* Cty_constr */0 :
        return /* Cty_constr */Block.__(0, [
                  type_path(s, param[0]),
                  List.map((function (param) {
                          return typexp(s, param);
                        }), param[1]),
                  class_type(s, param[2])
                ]);
    case /* Cty_signature */1 :
        return /* Cty_signature */Block.__(1, [class_signature(s, param[0])]);
    case /* Cty_arrow */2 :
        return /* Cty_arrow */Block.__(2, [
                  param[0],
                  typexp(s, param[1]),
                  class_type(s, param[2])
                ]);
    
  }
}

function class_declaration(s, decl) {
  var match = decl.cty_new;
  var decl$1 = {
    cty_params: List.map((function (param) {
            return typexp(s, param);
          }), decl.cty_params),
    cty_type: class_type(s, decl.cty_type),
    cty_path: type_path(s, decl.cty_path),
    cty_new: match !== void 0 ? typexp(s, match) : void 0,
    cty_variance: decl.cty_variance,
    cty_loc: loc(s, decl.cty_loc),
    cty_attributes: attrs(s, decl.cty_attributes)
  };
  if (!s.for_saving) {
    cleanup_types(void 0);
  }
  return decl$1;
}

function cltype_declaration(s, decl) {
  var decl_clty_params = List.map((function (param) {
          return typexp(s, param);
        }), decl.clty_params);
  var decl_clty_type = class_type(s, decl.clty_type);
  var decl_clty_path = type_path(s, decl.clty_path);
  var decl_clty_variance = decl.clty_variance;
  var decl_clty_loc = loc(s, decl.clty_loc);
  var decl_clty_attributes = attrs(s, decl.clty_attributes);
  var decl$1 = {
    clty_params: decl_clty_params,
    clty_type: decl_clty_type,
    clty_path: decl_clty_path,
    clty_variance: decl_clty_variance,
    clty_loc: decl_clty_loc,
    clty_attributes: decl_clty_attributes
  };
  cleanup_types(void 0);
  return decl$1;
}

function class_type$1(s, cty) {
  var cty$1 = class_type(s, cty);
  cleanup_types(void 0);
  return cty$1;
}

function value_description(s, descr) {
  return {
          val_type: type_expr(s, descr.val_type),
          val_kind: descr.val_kind,
          val_loc: loc(s, descr.val_loc),
          val_attributes: attrs(s, descr.val_attributes)
        };
}

function extension_constructor(s, ext) {
  var ext_ext_type_path = type_path(s, ext.ext_type_path);
  var ext_ext_type_params = List.map((function (param) {
          return typexp(s, param);
        }), ext.ext_type_params);
  var ext_ext_args = List.map((function (param) {
          return typexp(s, param);
        }), ext.ext_args);
  var ext_ext_ret_type = may_map((function (param) {
          return typexp(s, param);
        }), ext.ext_ret_type);
  var ext_ext_private = ext.ext_private;
  var ext_ext_loc = s.for_saving ? none : ext.ext_loc;
  var ext_ext_attributes = attrs(s, ext.ext_attributes);
  var ext$1 = {
    ext_type_path: ext_ext_type_path,
    ext_type_params: ext_ext_type_params,
    ext_args: ext_ext_args,
    ext_ret_type: ext_ext_ret_type,
    ext_private: ext_ext_private,
    ext_loc: ext_ext_loc,
    ext_attributes: ext_ext_attributes
  };
  cleanup_types(void 0);
  return ext$1;
}

function rename_bound_idents(_s, _idents, _param) {
  while(true) {
    var param = _param;
    var idents = _idents;
    var s = _s;
    if (!param) {
      return /* tuple */[
              List.rev(idents),
              s
            ];
    }
    var match = param[0];
    switch (match.tag | 0) {
      case /* Sig_type */1 :
          var id = match[0];
          var id$prime = rename(id);
          _param = param[1];
          _idents = /* :: */[
            id$prime,
            idents
          ];
          _s = add_type(id, /* Pident */Block.__(0, [id$prime]), s);
          continue ;
      case /* Sig_module */3 :
          var id$1 = match[0];
          var id$prime$1 = rename(id$1);
          _param = param[1];
          _idents = /* :: */[
            id$prime$1,
            idents
          ];
          _s = add_module(id$1, /* Pident */Block.__(0, [id$prime$1]), s);
          continue ;
      case /* Sig_modtype */4 :
          var id$2 = match[0];
          var id$prime$2 = rename(id$2);
          _param = param[1];
          _idents = /* :: */[
            id$prime$2,
            idents
          ];
          _s = add_modtype(id$2, /* Mty_ident */Block.__(0, [/* Pident */Block.__(0, [id$prime$2])]), s);
          continue ;
      default:
        var id$prime$3 = rename(match[0]);
        _param = param[1];
        _idents = /* :: */[
          id$prime$3,
          idents
        ];
        continue ;
    }
  };
}

function modtype(s, mty) {
  switch (mty.tag | 0) {
    case /* Mty_ident */0 :
        var p = mty[0];
        switch (p.tag | 0) {
          case /* Pident */0 :
              try {
                return find$2(p[0], s.modtypes);
              }
              catch (exn){
                if (exn === Caml_builtin_exceptions.not_found) {
                  return mty;
                }
                throw exn;
              }
          case /* Pdot */1 :
              return /* Mty_ident */Block.__(0, [/* Pdot */Block.__(1, [
                            module_path(s, p[0]),
                            p[1],
                            p[2]
                          ])]);
          case /* Papply */2 :
              return fatal_error("Subst.modtype");
          
        }
    case /* Mty_signature */1 :
        return /* Mty_signature */Block.__(1, [signature$2(s, mty[0])]);
    case /* Mty_functor */2 :
        var id = mty[0];
        var id$prime = rename(id);
        return /* Mty_functor */Block.__(2, [
                  id$prime,
                  may_map((function (param) {
                          return modtype(s, param);
                        }), mty[1]),
                  modtype(add_module(id, /* Pident */Block.__(0, [id$prime]), s), mty[2])
                ]);
    case /* Mty_alias */3 :
        return /* Mty_alias */Block.__(3, [module_path(s, mty[0])]);
    
  }
}

function signature$2(s, sg) {
  var match = rename_bound_idents(s, /* [] */0, sg);
  var s$prime = match[1];
  return List.map2((function (param, param$1) {
                switch (param.tag | 0) {
                  case /* Sig_value */0 :
                      return /* Sig_value */Block.__(0, [
                                param$1,
                                value_description(s$prime, param[1])
                              ]);
                  case /* Sig_type */1 :
                      return /* Sig_type */Block.__(1, [
                                param$1,
                                type_declaration(s$prime, param[1]),
                                param[2]
                              ]);
                  case /* Sig_typext */2 :
                      return /* Sig_typext */Block.__(2, [
                                param$1,
                                extension_constructor(s$prime, param[1]),
                                param[2]
                              ]);
                  case /* Sig_module */3 :
                      return /* Sig_module */Block.__(3, [
                                param$1,
                                module_declaration(s$prime, param[1]),
                                param[2]
                              ]);
                  case /* Sig_modtype */4 :
                      return /* Sig_modtype */Block.__(4, [
                                param$1,
                                modtype_declaration(s$prime, param[1])
                              ]);
                  case /* Sig_class */5 :
                      return /* Sig_class */Block.__(5, [
                                param$1,
                                class_declaration(s$prime, param[1]),
                                param[2]
                              ]);
                  case /* Sig_class_type */6 :
                      return /* Sig_class_type */Block.__(6, [
                                param$1,
                                cltype_declaration(s$prime, param[1]),
                                param[2]
                              ]);
                  
                }
              }), sg, match[0]);
}

function module_declaration(s, decl) {
  return {
          md_type: modtype(s, decl.md_type),
          md_attributes: attrs(s, decl.md_attributes),
          md_loc: loc(s, decl.md_loc)
        };
}

function modtype_declaration(s, decl) {
  return {
          mtd_type: may_map((function (param) {
                  return modtype(s, param);
                }), decl.mtd_type),
          mtd_attributes: attrs(s, decl.mtd_attributes),
          mtd_loc: loc(s, decl.mtd_loc)
        };
}

var add_delayed_check_forward = {
  contents: (function (param) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "env.ml",
              24,
              46
            ]
          ];
    })
};

var value_declarations = Hashtbl.create(void 0, 16);

var type_declarations = Hashtbl.create(void 0, 16);

function add_constructor_usage(cu, param) {
  switch (param) {
    case /* Positive */0 :
        cu.cu_positive = true;
        return ;
    case /* Pattern */1 :
        cu.cu_pattern = true;
        return ;
    case /* Privatize */2 :
        cu.cu_privatize = true;
        return ;
    
  }
}

var used_constructors = Hashtbl.create(void 0, 16);

var prefixed_sg = Hashtbl.create(void 0, 113);

var $$Error$2 = Caml_exceptions.create("Ocaml_typedtree_test.Env.Error");

function force(f, x) {
  var match = x.contents;
  switch (match.tag | 0) {
    case /* Done */0 :
        return match[0];
    case /* Raise */1 :
        throw match[0];
    case /* Thunk */2 :
        try {
          var y = Curry._1(f, match[0]);
          x.contents = /* Done */Block.__(0, [y]);
          return y;
        }
        catch (raw_e){
          var e = Caml_js_exceptions.internalToOCamlException(raw_e);
          x.contents = /* Raise */Block.__(1, [e]);
          throw e;
        }
    
  }
}

function get_arg(x) {
  var match = x.contents;
  switch (match.tag | 0) {
    case /* Done */0 :
    case /* Raise */1 :
        return ;
    case /* Thunk */2 :
        return Caml_option.some(match[0]);
    
  }
}

function nothing(param) {
  
}

function already_defined(s, tbl) {
  try {
    find_name(s, tbl);
    return true;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return false;
    }
    throw exn;
  }
}

function add$6(kind, slot, id, x, tbl, ref_tbl) {
  var slot$1;
  if (slot !== void 0) {
    var f = slot;
    slot$1 = (function (param) {
        var s = id.name;
        return Curry._3(f, kind, s, already_defined(s, ref_tbl));
      });
  } else {
    slot$1 = nothing;
  }
  return add(id, /* tuple */[
              x,
              slot$1
            ], tbl);
}

function find_same$1(id, tbl) {
  var match = find_same(id, tbl);
  Curry._1(match[1], void 0);
  return match[0];
}

function find_name$1(s, tbl) {
  var match = find_name(s, tbl);
  Curry._1(match[1], void 0);
  return match[0];
}

function fold_name(f) {
  return (function (param, param$1) {
      var f$1 = function (k, param) {
        return Curry._2(f, k, param[0]);
      };
      var f$2 = function (k) {
        return Curry._2(f$1, k.ident, k.data);
      };
      var _stack = /* [] */0;
      var _accu = param$1;
      var _param = param;
      while(true) {
        var param$2 = _param;
        var accu = _accu;
        var stack = _stack;
        if (param$2) {
          _param = param$2[2];
          _accu = Curry._2(f$2, param$2[1], accu);
          _stack = /* :: */[
            param$2[0],
            stack
          ];
          continue ;
        } else {
          if (!stack) {
            return accu;
          }
          _param = stack[0];
          _stack = stack[1];
          continue ;
        }
      };
    });
}

function subst_modtype_maker(param) {
  return modtype(param[0], param[1]);
}

var empty = {
  values: /* Empty */0,
  constrs: /* Empty */0,
  labels: /* Empty */0,
  types: /* Empty */0,
  modules: /* Empty */0,
  modtypes: /* Empty */0,
  components: /* Empty */0,
  classes: /* Empty */0,
  cltypes: /* Empty */0,
  functor_args: /* Empty */0,
  summary: /* Env_empty */0,
  local_constraints: false,
  gadt_instances: /* [] */0,
  flags: 0
};

function in_signature(env) {
  return {
          values: env.values,
          constrs: env.constrs,
          labels: env.labels,
          types: env.types,
          modules: env.modules,
          modtypes: env.modtypes,
          components: env.components,
          classes: env.classes,
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: env.summary,
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags | 1
        };
}

function implicit_coercion(env) {
  return {
          values: env.values,
          constrs: env.constrs,
          labels: env.labels,
          types: env.types,
          modules: env.modules,
          modtypes: env.modtypes,
          components: env.components,
          classes: env.classes,
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: env.summary,
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags | 2
        };
}

function is_in_signature(env) {
  return (env.flags & 1) !== 0;
}

function is_implicit_coercion(env) {
  return (env.flags & 2) !== 0;
}

var components_of_module$prime = {
  contents: (function (env, sub, path, mty) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "env.ml",
              272,
              32
            ]
          ];
    })
};

var components_of_module_maker$prime = {
  contents: (function (param) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "env.ml",
              275,
              37
            ]
          ];
    })
};

var components_of_functor_appl$prime = {
  contents: (function (f, p1, p2) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "env.ml",
              278,
              23
            ]
          ];
    })
};

var check_modtype_inclusion = {
  contents: (function (env, mty1, path1, mty2) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "env.ml",
              282,
              35
            ]
          ];
    })
};

var strengthen = {
  contents: (function (env, mty, path) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "env.ml",
              286,
              28
            ]
          ];
    })
};

var current_unit = {
  contents: ""
};

var persistent_structures = Hashtbl.create(void 0, 17);

var crc_units = Hashtbl.create(void 0, 13);

function height$5(param) {
  if (param) {
    return param[/* h */3];
  } else {
    return 0;
  }
}

function create$6(l, v, r) {
  var hl = l ? l[/* h */3] : 0;
  var hr = r ? r[/* h */3] : 0;
  return /* Node */[
          /* l */l,
          /* v */v,
          /* r */r,
          /* h */hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        ];
}

function bal$5(l, v, r) {
  var hl = l ? l[/* h */3] : 0;
  var hr = r ? r[/* h */3] : 0;
  if (hl > (hr + 2 | 0)) {
    if (!l) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          ];
    }
    var lr = l[/* r */2];
    var lv = l[/* v */1];
    var ll = l[/* l */0];
    if (height$5(ll) >= height$5(lr)) {
      return create$6(ll, lv, create$6(lr, v, r));
    }
    if (lr) {
      return create$6(create$6(ll, lv, lr[/* l */0]), lr[/* v */1], create$6(lr[/* r */2], v, r));
    }
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Set.bal"
        ];
  } else {
    if (hr <= (hl + 2 | 0)) {
      return /* Node */[
              /* l */l,
              /* v */v,
              /* r */r,
              /* h */hl >= hr ? hl + 1 | 0 : hr + 1 | 0
            ];
    }
    if (!r) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          ];
    }
    var rr = r[/* r */2];
    var rv = r[/* v */1];
    var rl = r[/* l */0];
    if (height$5(rr) >= height$5(rl)) {
      return create$6(create$6(l, v, rl), rv, rr);
    }
    if (rl) {
      return create$6(create$6(l, v, rl[/* l */0]), rl[/* v */1], create$6(rl[/* r */2], rv, rr));
    }
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Set.bal"
        ];
  }
}

function add$7(x, t) {
  if (!t) {
    return /* Node */[
            /* l : Empty */0,
            /* v */x,
            /* r : Empty */0,
            /* h */1
          ];
  }
  var r = t[/* r */2];
  var v = t[/* v */1];
  var l = t[/* l */0];
  var c = Caml_primitive.caml_string_compare(x, v);
  if (c === 0) {
    return t;
  }
  if (c < 0) {
    var ll = add$7(x, l);
    if (l === ll) {
      return t;
    } else {
      return bal$5(ll, v, r);
    }
  } else {
    var rr = add$7(x, r);
    if (r === rr) {
      return t;
    } else {
      return bal$5(l, v, rr);
    }
  }
}

function fold$5(f, _s, _accu) {
  while(true) {
    var accu = _accu;
    var s = _s;
    if (!s) {
      return accu;
    }
    _accu = Curry._2(f, s[/* v */1], fold$5(f, s[/* l */0], accu));
    _s = s[/* r */2];
    continue ;
  };
}

function elements_aux$2(_accu, _param) {
  while(true) {
    var param = _param;
    var accu = _accu;
    if (!param) {
      return accu;
    }
    _param = param[/* l */0];
    _accu = /* :: */[
      param[/* v */1],
      elements_aux$2(accu, param[/* r */2])
    ];
    continue ;
  };
}

var imported_units = {
  contents: /* Empty */0
};

function add_import(s) {
  imported_units.contents = add$7(s, imported_units.contents);
  
}

function check_consistency(ps) {
  if (ps.ps_crcs_checked) {
    return ;
  }
  try {
    List.iter((function (param) {
            var crco = param[1];
            if (crco === void 0) {
              return ;
            }
            var name = param[0];
            add_import(name);
            var source = ps.ps_filename;
            try {
              var match = Hashtbl.find(crc_units, name);
              if (Caml_obj.caml_notequal(crco, match[0])) {
                throw [
                      Inconsistency,
                      name,
                      source,
                      match[1]
                    ];
              }
              return ;
            }
            catch (exn){
              if (exn === Caml_builtin_exceptions.not_found) {
                return Hashtbl.add(crc_units, name, /* tuple */[
                            crco,
                            source
                          ]);
              }
              throw exn;
            }
          }), ps.ps_crcs);
    ps.ps_crcs_checked = true;
    return ;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === Inconsistency) {
      throw [
            $$Error$2,
            /* Inconsistent_import */Block.__(1, [
                exn[1],
                exn[3],
                exn[2]
              ])
          ];
    }
    throw exn;
  }
}

function save_pers_struct(crc, ps) {
  var modname = ps.ps_name;
  Hashtbl.add(persistent_structures, modname, ps);
  set$1(crc_units, modname, crc, ps.ps_filename);
  return add_import(modname);
}

function read_pers_struct(modname, filename) {
  var cmi = read_cmi(filename);
  var name = cmi.cmi_name;
  var sign = cmi.cmi_sign;
  var crcs = cmi.cmi_crcs;
  var flags = cmi.cmi_flags;
  var comps = Curry._4(components_of_module$prime.contents, empty, identity, /* Pident */Block.__(0, [{
            stamp: 0,
            name: name,
            flags: 1
          }]), /* Mty_signature */Block.__(1, [sign]));
  var ps = {
    ps_name: name,
    ps_sig: sign,
    ps_comps: comps,
    ps_crcs: crcs,
    ps_crcs_checked: false,
    ps_filename: filename,
    ps_flags: flags
  };
  if (ps.ps_name !== modname) {
    throw [
          $$Error$2,
          /* Illegal_renaming */Block.__(0, [
              modname,
              ps.ps_name,
              filename
            ])
        ];
  }
  add_import(name);
  List.iter((function (param) {
          if (recursive_types.contents) {
            return ;
          }
          throw [
                $$Error$2,
                /* Need_recursive_types */Block.__(2, [
                    ps.ps_name,
                    current_unit.contents
                  ])
              ];
        }), ps.ps_flags);
  Hashtbl.add(persistent_structures, modname, ps);
  return ps;
}

function find_pers_struct(checkOpt, name) {
  var check = checkOpt !== void 0 ? checkOpt : true;
  if (name === "*predef*") {
    throw Caml_builtin_exceptions.not_found;
  }
  var r;
  try {
    r = Caml_option.some(Hashtbl.find(persistent_structures, name));
  }
  catch (exn){
    if (exn !== Caml_builtin_exceptions.not_found) {
      throw exn;
    }
    r = void 0;
  }
  var ps;
  if (r !== void 0) {
    var match = Caml_option.valFromOption(r);
    if (match === void 0) {
      throw Caml_builtin_exceptions.not_found;
    }
    ps = match;
  } else {
    add_import(name);
    var filename;
    try {
      filename = find_in_path_uncap(load_path.contents, name + ".cmi");
    }
    catch (exn$1){
      if (exn$1 !== Caml_builtin_exceptions.not_found) {
        throw exn$1;
      }
      Hashtbl.add(persistent_structures, name, void 0);
      throw Caml_builtin_exceptions.not_found;
    }
    ps = read_pers_struct(name, filename);
  }
  if (check) {
    check_consistency(ps);
  }
  return ps;
}

function find_module_descr(path, env) {
  switch (path.tag | 0) {
    case /* Pident */0 :
        var id = path[0];
        try {
          return find_same$1(id, env.components)[1];
        }
        catch (exn){
          if (exn !== Caml_builtin_exceptions.not_found) {
            throw exn;
          }
          if (id.stamp === 0 && id.name !== current_unit.contents) {
            return find_pers_struct(void 0, id.name).ps_comps;
          }
          throw Caml_builtin_exceptions.not_found;
        }
    case /* Pdot */1 :
        var match = force(components_of_module_maker$prime.contents, find_module_descr(path[0], env));
        if (match.tag) {
          throw Caml_builtin_exceptions.not_found;
        }
        return find$2(path[1], match[0].comp_components)[0];
    case /* Papply */2 :
        var p1 = path[0];
        var match$1 = force(components_of_module_maker$prime.contents, find_module_descr(p1, env));
        if (match$1.tag) {
          return Curry._3(components_of_functor_appl$prime.contents, match$1[0], p1, path[1]);
        }
        throw Caml_builtin_exceptions.not_found;
    
  }
}

function find$3(proj1, proj2, path, env) {
  switch (path.tag | 0) {
    case /* Pident */0 :
        return find_same$1(path[0], Curry._1(proj1, env))[1];
    case /* Pdot */1 :
        var match = force(components_of_module_maker$prime.contents, find_module_descr(path[0], env));
        if (match.tag) {
          throw Caml_builtin_exceptions.not_found;
        }
        return find$2(path[1], Curry._1(proj2, match[0]))[0];
    case /* Papply */2 :
        throw Caml_builtin_exceptions.not_found;
    
  }
}

function find_value(param, param$1) {
  return find$3((function (env) {
                return env.values;
              }), (function (sc) {
                return sc.comp_values;
              }), param, param$1);
}

function find_type_full(param, param$1) {
  return find$3((function (env) {
                return env.types;
              }), (function (sc) {
                return sc.comp_types;
              }), param, param$1);
}

function find_modtype(param, param$1) {
  return find$3((function (env) {
                return env.modtypes;
              }), (function (sc) {
                return sc.comp_modtypes;
              }), param, param$1);
}

function find_class(param, param$1) {
  return find$3((function (env) {
                return env.classes;
              }), (function (sc) {
                return sc.comp_classes;
              }), param, param$1);
}

function find_module(alias, path, env) {
  switch (path.tag | 0) {
    case /* Pident */0 :
        var id = path[0];
        try {
          return find_same$1(id, env.modules)[1];
        }
        catch (exn){
          if (exn !== Caml_builtin_exceptions.not_found) {
            throw exn;
          }
          if (!(id.stamp === 0 && id.name !== current_unit.contents)) {
            throw Caml_builtin_exceptions.not_found;
          }
          var ps = find_pers_struct(void 0, id.name);
          return {
                  md_type: /* Mty_signature */Block.__(1, [ps.ps_sig]),
                  md_attributes: /* [] */0,
                  md_loc: none
                };
        }
    case /* Pdot */1 :
        var match = force(components_of_module_maker$prime.contents, find_module_descr(path[0], env));
        if (match.tag) {
          throw Caml_builtin_exceptions.not_found;
        }
        var match$1 = find$2(path[1], match[0].comp_modules);
        var md_type = force(subst_modtype_maker, match$1[0]);
        return {
                md_type: md_type,
                md_attributes: /* [] */0,
                md_loc: none
              };
    case /* Papply */2 :
        var p2 = path[1];
        var desc1 = find_module_descr(path[0], env);
        var match$2 = force(components_of_module_maker$prime.contents, desc1);
        if (!match$2.tag) {
          throw Caml_builtin_exceptions.not_found;
        }
        var f = match$2[0];
        var mty = f.fcomp_res;
        var md_type$1;
        if (mty.tag === /* Mty_alias */3) {
          md_type$1 = /* Mty_alias */Block.__(3, [module_path(f.fcomp_subst, mty[0])]);
        } else if (alias) {
          md_type$1 = mty;
        } else {
          try {
            md_type$1 = Hashtbl.find(f.fcomp_subst_cache, p2);
          }
          catch (exn$1){
            if (exn$1 !== Caml_builtin_exceptions.not_found) {
              throw exn$1;
            }
            var mty$1 = modtype(add_module(f.fcomp_param, p2, f.fcomp_subst), f.fcomp_res);
            Hashtbl.add(f.fcomp_subst_cache, p2, mty$1);
            md_type$1 = mty$1;
          }
        }
        return {
                md_type: md_type$1,
                md_attributes: /* [] */0,
                md_loc: none
              };
    
  }
}

var required_globals = {
  contents: /* [] */0
};

function add_required_global(id) {
  if ($$global(id) && !transparent_modules.contents && !List.exists((function (param) {
            return Caml_obj.caml_equal(id, param);
          }), required_globals.contents)) {
    required_globals.contents = /* :: */[
      id,
      required_globals.contents
    ];
    return ;
  }
  
}

function normalize_path(lax, env, path) {
  var path$1;
  switch (path.tag | 0) {
    case /* Pident */0 :
        path$1 = path;
        break;
    case /* Pdot */1 :
        path$1 = /* Pdot */Block.__(1, [
            normalize_path(lax, env, path[0]),
            path[1],
            path[2]
          ]);
        break;
    case /* Papply */2 :
        path$1 = /* Papply */Block.__(2, [
            normalize_path(lax, env, path[0]),
            normalize_path(true, env, path[1])
          ]);
        break;
    
  }
  try {
    var match = find_module(true, path$1, env);
    var match$1 = match.md_type;
    if (match$1.tag !== /* Mty_alias */3) {
      return path$1;
    }
    var path$prime = normalize_path(lax, env, match$1[0]);
    if (lax || transparent_modules.contents) {
      return path$prime;
    }
    var id = head(path$1);
    if ($$global(id) && !Caml_obj.caml_equal(id, head(path$prime))) {
      add_required_global(id);
    }
    return path$prime;
  }
  catch (exn){
    if (exn !== Caml_builtin_exceptions.not_found) {
      throw exn;
    }
    var tmp = true;
    if (!lax) {
      var tmp$1;
      switch (path$1.tag | 0) {
        case /* Pident */0 :
            tmp$1 = path$1[0].stamp !== 0;
            break;
        case /* Pdot */1 :
        case /* Papply */2 :
            tmp$1 = true;
            break;
        
      }
      tmp = tmp$1;
    }
    if (tmp) {
      return path$1;
    }
    throw exn;
  }
}

function normalize_path$1(oloc, env, path) {
  try {
    return normalize_path(oloc === void 0, env, path);
  }
  catch (exn){
    if (exn !== Caml_builtin_exceptions.not_found) {
      throw exn;
    }
    if (oloc !== void 0) {
      throw [
            $$Error$2,
            /* Missing_module */Block.__(3, [
                oloc,
                path,
                normalize_path(true, env, path)
              ])
          ];
    }
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "env.ml",
            579,
            28
          ]
        ];
  }
}

function find_type_expansion(path, env) {
  var decl = find_type_full(path, env)[0];
  var match = decl.type_manifest;
  if (match !== void 0) {
    var body = match;
    if (decl.type_private === /* Public */1 || decl.type_kind !== /* Type_abstract */0 || has_constr_row(body)) {
      return /* tuple */[
              decl.type_params,
              body,
              may_map((function (prim) {
                      return prim[1];
                    }), decl.type_newtype_level)
            ];
    }
    
  }
  var path$prime = normalize_path$1(void 0, env, path);
  if (same(path, path$prime)) {
    throw Caml_builtin_exceptions.not_found;
  }
  return /* tuple */[
          decl.type_params,
          newty2(100000000, /* Tconstr */Block.__(3, [
                  path$prime,
                  decl.type_params,
                  {
                    contents: /* Mnil */0
                  }
                ])),
          may_map((function (prim) {
                  return prim[1];
                }), decl.type_newtype_level)
        ];
}

function find_type_expansion_opt(path, env) {
  var decl = find_type_full(path, env)[0];
  var match = decl.type_manifest;
  if (match !== void 0) {
    return /* tuple */[
            decl.type_params,
            match,
            may_map((function (prim) {
                    return prim[1];
                  }), decl.type_newtype_level)
          ];
  }
  var path$prime = normalize_path$1(void 0, env, path);
  if (same(path, path$prime)) {
    throw Caml_builtin_exceptions.not_found;
  }
  return /* tuple */[
          decl.type_params,
          newty2(100000000, /* Tconstr */Block.__(3, [
                  path$prime,
                  decl.type_params,
                  {
                    contents: /* Mnil */0
                  }
                ])),
          may_map((function (prim) {
                  return prim[1];
                }), decl.type_newtype_level)
        ];
}

function find_modtype_expansion(path, env) {
  var match = find_modtype(path, env).mtd_type;
  if (match !== void 0) {
    return match;
  }
  throw Caml_builtin_exceptions.not_found;
}

function is_functor_arg(_path, env) {
  while(true) {
    var path = _path;
    switch (path.tag | 0) {
      case /* Pident */0 :
          try {
            find_same(path[0], env.functor_args);
            return true;
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              return false;
            }
            throw exn;
          }
      case /* Pdot */1 :
          _path = path[0];
          continue ;
      case /* Papply */2 :
          return true;
      
    }
  };
}

var Recmodule = Caml_exceptions.create("Ocaml_typedtree_test.Env.Recmodule");

function lookup_module_descr(lid, env) {
  switch (lid.tag | 0) {
    case /* Lident */0 :
        var s = lid[0];
        try {
          return find_name$1(s, env.components);
        }
        catch (exn){
          if (exn !== Caml_builtin_exceptions.not_found) {
            throw exn;
          }
          if (s === current_unit.contents) {
            throw Caml_builtin_exceptions.not_found;
          }
          var ps = find_pers_struct(void 0, s);
          return /* tuple */[
                  /* Pident */Block.__(0, [{
                        stamp: 0,
                        name: s,
                        flags: 1
                      }]),
                  ps.ps_comps
                ];
        }
    case /* Ldot */1 :
        var s$1 = lid[1];
        var match = lookup_module_descr(lid[0], env);
        var match$1 = force(components_of_module_maker$prime.contents, match[1]);
        if (match$1.tag) {
          throw Caml_builtin_exceptions.not_found;
        }
        var match$2 = find$2(s$1, match$1[0].comp_components);
        return /* tuple */[
                /* Pdot */Block.__(1, [
                    match[0],
                    s$1,
                    match$2[1]
                  ]),
                match$2[0]
              ];
    case /* Lapply */2 :
        var match$3 = lookup_module_descr(lid[0], env);
        var p1 = match$3[0];
        var p2 = lookup_module(true, lid[1], env);
        var match$4 = find_module(false, p2, env);
        var match$5 = force(components_of_module_maker$prime.contents, match$3[1]);
        if (!match$5.tag) {
          throw Caml_builtin_exceptions.not_found;
        }
        var f = match$5[0];
        may(Curry._3(check_modtype_inclusion.contents, env, match$4.md_type, p2), f.fcomp_arg);
        return /* tuple */[
                /* Papply */Block.__(2, [
                    p1,
                    p2
                  ]),
                Curry._3(components_of_functor_appl$prime.contents, f, p1, p2)
              ];
    
  }
}

function lookup_module(load, lid, env) {
  switch (lid.tag | 0) {
    case /* Lident */0 :
        var s = lid[0];
        try {
          var r = find_name$1(s, env.modules);
          var md_type = r[1].md_type;
          if (!md_type.tag) {
            var match = md_type[0];
            switch (match.tag | 0) {
              case /* Pident */0 :
                  if (match[0].name === "#recmod#") {
                    throw Recmodule;
                  }
                  break;
              case /* Pdot */1 :
              case /* Papply */2 :
                  break;
              
            }
          }
          return r[0];
        }
        catch (exn){
          if (exn !== Caml_builtin_exceptions.not_found) {
            throw exn;
          }
          if (s === current_unit.contents) {
            throw Caml_builtin_exceptions.not_found;
          }
          if (transparent_modules.contents && !load) {
            try {
              find_pers_struct(false, s);
            }
            catch (exn$1){
              if (exn$1 !== Caml_builtin_exceptions.not_found) {
                throw exn$1;
              }
              prerr_warning(none, /* No_cmi_file */Block.__(32, [s]));
            }
          } else {
            find_pers_struct(void 0, s);
          }
          return /* Pident */Block.__(0, [{
                      stamp: 0,
                      name: s,
                      flags: 1
                    }]);
        }
    case /* Ldot */1 :
        var s$1 = lid[1];
        var match$1 = lookup_module_descr(lid[0], env);
        var match$2 = force(components_of_module_maker$prime.contents, match$1[1]);
        if (match$2.tag) {
          throw Caml_builtin_exceptions.not_found;
        }
        var match$3 = find$2(s$1, match$2[0].comp_modules);
        return /* Pdot */Block.__(1, [
                  match$1[0],
                  s$1,
                  match$3[1]
                ]);
    case /* Lapply */2 :
        var match$4 = lookup_module_descr(lid[0], env);
        var p2 = lookup_module(true, lid[1], env);
        var match$5 = find_module(false, p2, env);
        var p_000 = match$4[0];
        var p = /* Papply */Block.__(2, [
            p_000,
            p2
          ]);
        var match$6 = force(components_of_module_maker$prime.contents, match$4[1]);
        if (!match$6.tag) {
          throw Caml_builtin_exceptions.not_found;
        }
        may(Curry._3(check_modtype_inclusion.contents, env, match$5.md_type, p2), match$6[0].fcomp_arg);
        return p;
    
  }
}

function lookup(proj1, proj2, lid, env) {
  switch (lid.tag | 0) {
    case /* Lident */0 :
        return find_name$1(lid[0], Curry._1(proj1, env));
    case /* Ldot */1 :
        var s = lid[1];
        var match = lookup_module_descr(lid[0], env);
        var match$1 = force(components_of_module_maker$prime.contents, match[1]);
        if (match$1.tag) {
          throw Caml_builtin_exceptions.not_found;
        }
        var match$2 = find$2(s, Curry._1(proj2, match$1[0]));
        return /* tuple */[
                /* Pdot */Block.__(1, [
                    match[0],
                    s,
                    match$2[1]
                  ]),
                match$2[0]
              ];
    case /* Lapply */2 :
        throw Caml_builtin_exceptions.not_found;
    
  }
}

function lookup_all_simple(proj1, proj2, shadow, lid, env) {
  switch (lid.tag | 0) {
    case /* Lident */0 :
        var xl = find_all(lid[0], Curry._1(proj1, env));
        var do_shadow = function (param) {
          if (!param) {
            return /* [] */0;
          }
          var match = param[0];
          var x = match[0];
          return /* :: */[
                  /* tuple */[
                    x,
                    match[1]
                  ],
                  do_shadow(List.filter((function (param) {
                                return !Curry._2(shadow, x, param[0]);
                              }))(param[1]))
                ];
        };
        return do_shadow(xl);
    case /* Ldot */1 :
        var match = lookup_module_descr(lid[0], env);
        var match$1 = force(components_of_module_maker$prime.contents, match[1]);
        if (match$1.tag) {
          throw Caml_builtin_exceptions.not_found;
        }
        var comps;
        try {
          comps = find$2(lid[1], Curry._1(proj2, match$1[0]));
        }
        catch (exn){
          if (exn !== Caml_builtin_exceptions.not_found) {
            throw exn;
          }
          comps = /* [] */0;
        }
        return List.map((function (param) {
                      return /* tuple */[
                              param[0],
                              (function (param) {
                                  
                                })
                            ];
                    }), comps);
    case /* Lapply */2 :
        throw Caml_builtin_exceptions.not_found;
    
  }
}

function cstr_shadow(cstr1, cstr2) {
  var match = cstr1.cstr_tag;
  var match$1 = cstr2.cstr_tag;
  switch (match.tag | 0) {
    case /* Cstr_constant */0 :
    case /* Cstr_block */1 :
        return false;
    case /* Cstr_extension */2 :
        switch (match$1.tag | 0) {
          case /* Cstr_constant */0 :
          case /* Cstr_block */1 :
              return false;
          case /* Cstr_extension */2 :
              return true;
          
        }
    
  }
}

function lbl_shadow(lbl1, lbl2) {
  return false;
}

function lookup_value(param, param$1) {
  return lookup((function (env) {
                return env.values;
              }), (function (sc) {
                return sc.comp_values;
              }), param, param$1);
}

function lookup_all_constructors(param, param$1) {
  return lookup_all_simple((function (env) {
                return env.constrs;
              }), (function (sc) {
                return sc.comp_constrs;
              }), cstr_shadow, param, param$1);
}

function lookup_all_labels(param, param$1) {
  return lookup_all_simple((function (env) {
                return env.labels;
              }), (function (sc) {
                return sc.comp_labels;
              }), lbl_shadow, param, param$1);
}

function lookup_type(param, param$1) {
  return lookup((function (env) {
                return env.types;
              }), (function (sc) {
                return sc.comp_types;
              }), param, param$1);
}

function lookup_modtype(param, param$1) {
  return lookup((function (env) {
                return env.modtypes;
              }), (function (sc) {
                return sc.comp_modtypes;
              }), param, param$1);
}

function lookup_class(param, param$1) {
  return lookup((function (env) {
                return env.classes;
              }), (function (sc) {
                return sc.comp_classes;
              }), param, param$1);
}

function lookup_cltype(param, param$1) {
  return lookup((function (env) {
                return env.cltypes;
              }), (function (sc) {
                return sc.comp_cltypes;
              }), param, param$1);
}

function mark_value_used(env, name, vd) {
  if (is_implicit_coercion(env)) {
    return ;
  }
  try {
    return Curry._1(Hashtbl.find(value_declarations, /* tuple */[
                    name,
                    vd.val_loc
                  ]), void 0);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return ;
    }
    throw exn;
  }
}

function mark_type_used(env, name, vd) {
  if (is_implicit_coercion(env)) {
    return ;
  }
  try {
    return Curry._1(Hashtbl.find(type_declarations, /* tuple */[
                    name,
                    vd.type_loc
                  ]), void 0);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return ;
    }
    throw exn;
  }
}

function mark_constructor_used(usage, env, name, vd, constr) {
  if (is_implicit_coercion(env)) {
    return ;
  }
  try {
    return Curry._1(Hashtbl.find(used_constructors, /* tuple */[
                    name,
                    vd.type_loc,
                    constr
                  ]), usage);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return ;
    }
    throw exn;
  }
}

function mark_extension_used(usage, env, ext, name) {
  if (is_implicit_coercion(env)) {
    return ;
  }
  var ty_name = last(ext.ext_type_path);
  try {
    return Curry._1(Hashtbl.find(used_constructors, /* tuple */[
                    ty_name,
                    ext.ext_loc,
                    name
                  ]), usage);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return ;
    }
    throw exn;
  }
}

function set_type_used_callback(name, td, callback) {
  var loc = td.type_loc;
  if (loc.loc_ghost) {
    return ;
  }
  var key = /* tuple */[
    name,
    loc
  ];
  var old;
  try {
    old = Hashtbl.find(type_declarations, key);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "env.ml",
              841,
              22
            ]
          ];
    }
    throw exn;
  }
  return Hashtbl.replace(type_declarations, key, (function (param) {
                return Curry._1(callback, old);
              }));
}

function lookup_value$1(lid, env) {
  var r = lookup_value(lid, env);
  mark_value_used(env, last$1(lid), r[1]);
  return r;
}

function lookup_type$1(lid, env) {
  var match = lookup_type(lid, env);
  var decl = match[1][0];
  mark_type_used(env, last$1(lid), decl);
  return /* tuple */[
          match[0],
          decl
        ];
}

function mark_type_path(env, path) {
  try {
    var decl = find_type_full(path, env)[0];
    return mark_type_used(env, last(path), decl);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return ;
    }
    throw exn;
  }
}

function ty_path(t) {
  var match = repr(t);
  var match$1 = match.desc;
  if (typeof match$1 === "number") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "env.ml",
            871,
            9
          ]
        ];
  }
  if (match$1.tag === /* Tconstr */3) {
    return match$1[0];
  }
  throw [
        Caml_builtin_exceptions.assert_failure,
        /* tuple */[
          "env.ml",
          871,
          9
        ]
      ];
}

function lookup_constructor(lid, env) {
  var match = lookup_all_constructors(lid, env);
  if (!match) {
    throw Caml_builtin_exceptions.not_found;
  }
  var match$1 = match[0];
  var desc = match$1[0];
  mark_type_path(env, ty_path(desc.cstr_res));
  Curry._1(match$1[1], void 0);
  return desc;
}

function is_lident(param) {
  switch (param.tag | 0) {
    case /* Lident */0 :
        return true;
    case /* Ldot */1 :
    case /* Lapply */2 :
        return false;
    
  }
}

function lookup_all_constructors$1(lid, env) {
  try {
    var cstrs = lookup_all_constructors(lid, env);
    return List.map((function (param) {
                  var use = param[1];
                  var cstr = param[0];
                  return /* tuple */[
                          cstr,
                          (function (param) {
                              mark_type_path(env, ty_path(cstr.cstr_res));
                              return Curry._1(use, void 0);
                            })
                        ];
                }), cstrs);
  }
  catch (exn){
    if (exn !== Caml_builtin_exceptions.not_found) {
      throw exn;
    }
    if (is_lident(lid)) {
      return /* [] */0;
    }
    throw exn;
  }
}

function mark_constructor(usage, env, name, desc) {
  if (is_implicit_coercion(env)) {
    return ;
  }
  var match = desc.cstr_tag;
  switch (match.tag | 0) {
    case /* Cstr_constant */0 :
    case /* Cstr_block */1 :
        break;
    case /* Cstr_extension */2 :
        var ty_path$1 = ty_path(desc.cstr_res);
        var ty_name = last(ty_path$1);
        try {
          return Curry._1(Hashtbl.find(used_constructors, /* tuple */[
                          ty_name,
                          desc.cstr_loc,
                          name
                        ]), usage);
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            return ;
          }
          throw exn;
        }
    
  }
  var ty_path$2 = ty_path(desc.cstr_res);
  var ty_decl;
  try {
    ty_decl = find_type_full(ty_path$2, env)[0];
  }
  catch (exn$1){
    if (exn$1 === Caml_builtin_exceptions.not_found) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "env.ml",
              908,
              64
            ]
          ];
    }
    throw exn$1;
  }
  var ty_name$1 = last(ty_path$2);
  return mark_constructor_used(usage, env, ty_name$1, ty_decl, name);
}

function lookup_all_labels$1(lid, env) {
  try {
    var lbls = lookup_all_labels(lid, env);
    return List.map((function (param) {
                  var use = param[1];
                  var lbl = param[0];
                  return /* tuple */[
                          lbl,
                          (function (param) {
                              mark_type_path(env, ty_path(lbl.lbl_res));
                              return Curry._1(use, void 0);
                            })
                        ];
                }), lbls);
  }
  catch (exn){
    if (exn !== Caml_builtin_exceptions.not_found) {
      throw exn;
    }
    if (is_lident(lid)) {
      return /* [] */0;
    }
    throw exn;
  }
}

function lookup_class$1(lid, env) {
  var r = lookup_class(lid, env);
  var desc = r[1];
  if (name(void 0, desc.cty_path) === "") {
    lookup_type$1(lid, env);
  } else {
    mark_type_path(env, desc.cty_path);
  }
  return r;
}

function lookup_cltype$1(lid, env) {
  var r = lookup_cltype(lid, env);
  var desc = r[1];
  if (name(void 0, desc.clty_path) === "") {
    lookup_type$1(lid, env);
  } else {
    mark_type_path(env, desc.clty_path);
  }
  mark_type_path(env, desc.clty_path);
  return r;
}

var iter_env_cont = {
  contents: /* [] */0
};

function scrape_alias_safe(env, _mty) {
  while(true) {
    var mty = _mty;
    if (mty.tag !== /* Mty_alias */3) {
      return true;
    }
    var path = mty[0];
    switch (path.tag | 0) {
      case /* Pident */0 :
          if (path[0].stamp === 0) {
            return false;
          }
          break;
      case /* Pdot */1 :
      case /* Papply */2 :
          break;
      
    }
    _mty = find_module(false, path, env).md_type;
    continue ;
  };
}

function run_iter_cont(l) {
  iter_env_cont.contents = /* [] */0;
  List.iter((function (c) {
          return Curry._1(c, void 0);
        }), l);
  var cont = List.rev(iter_env_cont.contents);
  iter_env_cont.contents = /* [] */0;
  return cont;
}

function iter_types(f) {
  return (function (param, param$1) {
      var proj1 = function (env) {
        return env.types;
      };
      var proj2 = function (sc) {
        return sc.comp_types;
      };
      iter((function (id, param) {
              return Curry._2(f, /* Pident */Block.__(0, [id]), param[0]);
            }), Curry._1(proj1, param));
      var iter_components = function (path, path$prime, mcomps) {
        var cont = function (param) {
          var match = get_arg(mcomps);
          var safe;
          if (match !== void 0) {
            var match$1 = match;
            try {
              safe = scrape_alias_safe(match$1[0], match$1[3]);
            }
            catch (exn){
              if (exn !== Caml_builtin_exceptions.not_found) {
                throw exn;
              }
              safe = false;
            }
          } else {
            safe = true;
          }
          if (!safe) {
            return ;
          }
          var match$2 = force(components_of_module_maker$prime.contents, mcomps);
          if (match$2.tag) {
            return ;
          }
          var comps = match$2[0];
          iter$2((function (s, param) {
                  var n = param[1];
                  return Curry._2(f, /* Pdot */Block.__(1, [
                                path,
                                s,
                                n
                              ]), /* tuple */[
                              /* Pdot */Block.__(1, [
                                  path$prime,
                                  s,
                                  n
                                ]),
                              param[0]
                            ]);
                }), Curry._1(proj2, comps));
          return iter$2((function (s, param) {
                        var n = param[1];
                        return iter_components(/* Pdot */Block.__(1, [
                                      path,
                                      s,
                                      n
                                    ]), /* Pdot */Block.__(1, [
                                      path$prime,
                                      s,
                                      n
                                    ]), param[0]);
                      }), comps.comp_components);
        };
        iter_env_cont.contents = /* :: */[
          /* tuple */[
            path,
            cont
          ],
          iter_env_cont.contents
        ];
        
      };
      Hashtbl.iter((function (s, pso) {
              if (pso === void 0) {
                return ;
              }
              var id = /* Pident */Block.__(0, [{
                    stamp: 0,
                    name: s,
                    flags: 1
                  }]);
              return iter_components(id, id, pso.ps_comps);
            }), persistent_structures);
      return iter((function (id, param) {
                    var match = param[0];
                    return iter_components(/* Pident */Block.__(0, [id]), match[0], match[1]);
                  }), param.components);
    });
}

function same_types(env1, env2) {
  if (env1.types === env2.types) {
    return env1.components === env2.components;
  } else {
    return false;
  }
}

function used_persistent(param) {
  var r = {
    contents: /* Empty */0
  };
  Hashtbl.iter((function (s, pso) {
          if (pso !== void 0) {
            r.contents = add$2(s, r.contents);
            return ;
          }
          
        }), persistent_structures);
  return r.contents;
}

function find_all_comps(proj, s, param) {
  var match = force(components_of_module_maker$prime.contents, param[1]);
  if (match.tag) {
    return /* [] */0;
  }
  try {
    var match$1 = find$2(s, Curry._1(proj, match[0]));
    return /* :: */[
            /* tuple */[
              /* Pdot */Block.__(1, [
                  param[0],
                  s,
                  match$1[1]
                ]),
              match$1[0]
            ],
            /* [] */0
          ];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* [] */0;
    }
    throw exn;
  }
}

function find_shadowed_comps(path, env) {
  switch (path.tag | 0) {
    case /* Pident */0 :
        return List.map((function (prim) {
                      return prim[0];
                    }), find_all(path[0].name, env.components));
    case /* Pdot */1 :
        var s = path[1];
        var l = find_shadowed_comps(path[0], env);
        return List.flatten(List.map((function (param) {
                          return find_all_comps((function (comps) {
                                        return comps.comp_components;
                                      }), s, param);
                        }), l));
    case /* Papply */2 :
        return /* [] */0;
    
  }
}

function find_shadowed(proj1, proj2, path, env) {
  switch (path.tag | 0) {
    case /* Pident */0 :
        return List.map((function (prim) {
                      return prim[0];
                    }), find_all(path[0].name, Curry._1(proj1, env)));
    case /* Pdot */1 :
        var s = path[1];
        var l = find_shadowed_comps(path[0], env);
        return List.flatten(List.map((function (param) {
                          return find_all_comps(proj2, s, param);
                        }), l));
    case /* Papply */2 :
        return /* [] */0;
    
  }
}

function find_shadowed_types(path, env) {
  var l = find_shadowed((function (env) {
          return env.types;
        }), (function (comps) {
          return comps.comp_types;
        }), path, env);
  return List.map((function (prim) {
                return prim[0];
              }), l);
}

function add_gadt_instance_level(lv, env) {
  return {
          values: env.values,
          constrs: env.constrs,
          labels: env.labels,
          types: env.types,
          modules: env.modules,
          modtypes: env.modtypes,
          components: env.components,
          classes: env.classes,
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: env.summary,
          local_constraints: env.local_constraints,
          gadt_instances: /* :: */[
            /* tuple */[
              lv,
              {
                contents: /* Empty */0
              }
            ],
            env.gadt_instances
          ],
          flags: env.flags
        };
}

function is_Tlink(param) {
  var match = param.desc;
  if (typeof match === "number" || match.tag !== /* Tlink */6) {
    return false;
  } else {
    return true;
  }
}

function gadt_instance_level(env, t) {
  var _param = env.gadt_instances;
  while(true) {
    var param = _param;
    if (!param) {
      return ;
    }
    var match = param[0];
    var r = match[1];
    if (exists(is_Tlink, r.contents)) {
      r.contents = fold$2((function (ty) {
              var partial_arg = repr(ty);
              return (function (param) {
                  return add$3(partial_arg, param);
                });
            }), r.contents, /* Empty */0);
    }
    if (mem$3(t, r.contents)) {
      return Caml_option.some(match[0]);
    }
    _param = param[1];
    continue ;
  };
}

function add_gadt_instances(env, lv, tl) {
  var r;
  try {
    r = List.assoc(lv, env.gadt_instances);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "env.ml",
              1066,
              59
            ]
          ];
    }
    throw exn;
  }
  return set_typeset(r, List.fold_right(add$3, tl, r.contents));
}

function add_gadt_instance_chain(env, lv, t) {
  var r;
  try {
    r = List.assoc(lv, env.gadt_instances);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "env.ml",
              1075,
              59
            ]
          ];
    }
    throw exn;
  }
  var add_instance = function (t) {
    var t$1 = repr(t);
    if (mem$3(t$1, r.contents)) {
      return ;
    }
    set_typeset(r, add$3(t$1, r.contents));
    var match = t$1.desc;
    if (typeof match === "number" || match.tag !== /* Tconstr */3) {
      return ;
    } else {
      return may(add_instance, find_expans(/* Private */0, match[0], match[2].contents));
    }
  };
  return add_instance(t);
}

function scrape_alias(env, path, mty) {
  switch (mty.tag | 0) {
    case /* Mty_ident */0 :
        try {
          return scrape_alias(env, path, find_modtype_expansion(mty[0], env));
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            return mty;
          }
          throw exn;
        }
    case /* Mty_signature */1 :
    case /* Mty_functor */2 :
        break;
    case /* Mty_alias */3 :
        var path$1 = mty[0];
        try {
          return scrape_alias(env, path$1, find_module(false, path$1, env).md_type);
        }
        catch (exn$1){
          if (exn$1 === Caml_builtin_exceptions.not_found) {
            return mty;
          }
          throw exn$1;
        }
    
  }
  if (path !== void 0) {
    return Curry._3(strengthen.contents, env, mty, path);
  } else {
    return mty;
  }
}

function constructors_of_type(ty_path, decl) {
  var match = decl.type_kind;
  if (typeof match === "number" || match.tag !== /* Type_variant */1) {
    return /* [] */0;
  } else {
    var cstrs = match[0];
    var ty_res = newty2(100000000, /* Tconstr */Block.__(3, [
            ty_path,
            decl.type_params,
            {
              contents: /* Mnil */0
            }
          ]));
    var priv = decl.type_private;
    var num_consts = {
      contents: 0
    };
    var num_nonconsts = {
      contents: 0
    };
    var num_normal = {
      contents: 0
    };
    List.iter((function (param) {
            if (param.cd_args === /* [] */0) {
              num_consts.contents = num_consts.contents + 1 | 0;
            } else {
              num_nonconsts.contents = num_nonconsts.contents + 1 | 0;
            }
            if (param.cd_res === void 0) {
              num_normal.contents = num_normal.contents + 1 | 0;
              return ;
            }
            
          }), cstrs);
    var describe_constructors = function (idx_const, idx_nonconst, param) {
      if (!param) {
        return /* [] */0;
      }
      var rem = param[1];
      var match = param[0];
      var cd_res = match.cd_res;
      var cd_args = match.cd_args;
      var cd_id = match.cd_id;
      var ty_res$1 = cd_res !== void 0 ? cd_res : ty_res;
      var match$1 = cd_args ? /* tuple */[
          /* Cstr_block */Block.__(1, [idx_nonconst]),
          describe_constructors(idx_const, idx_nonconst + 1 | 0, rem)
        ] : /* tuple */[
          /* Cstr_constant */Block.__(0, [idx_const]),
          describe_constructors(idx_const + 1 | 0, idx_nonconst, rem)
        ];
      var existentials;
      if (cd_res !== void 0) {
        var res_vars = free_vars(cd_res);
        var arg_vars = free_vars(newty2(100000000, /* Ttuple */Block.__(2, [cd_args])));
        existentials = elements_aux$1(/* [] */0, diff$1(arg_vars, res_vars));
      } else {
        existentials = /* [] */0;
      }
      var cstr_cstr_name = cd_id.name;
      var cstr_cstr_arity = List.length(cd_args);
      var cstr_cstr_tag = match$1[0];
      var cstr_cstr_consts = num_consts.contents;
      var cstr_cstr_nonconsts = num_nonconsts.contents;
      var cstr_cstr_normal = num_normal.contents;
      var cstr_cstr_generalized = cd_res !== void 0;
      var cstr_cstr_loc = match.cd_loc;
      var cstr_cstr_attributes = match.cd_attributes;
      var cstr = {
        cstr_name: cstr_cstr_name,
        cstr_res: ty_res$1,
        cstr_existentials: existentials,
        cstr_args: cd_args,
        cstr_arity: cstr_cstr_arity,
        cstr_tag: cstr_cstr_tag,
        cstr_consts: cstr_cstr_consts,
        cstr_nonconsts: cstr_cstr_nonconsts,
        cstr_normal: cstr_cstr_normal,
        cstr_generalized: cstr_cstr_generalized,
        cstr_private: priv,
        cstr_loc: cstr_cstr_loc,
        cstr_attributes: cstr_cstr_attributes
      };
      return /* :: */[
              /* tuple */[
                cd_id,
                cstr
              ],
              match$1[1]
            ];
    };
    var result = describe_constructors(0, 0, cstrs);
    var a_id;
    var a_descr;
    var b_id;
    var b_descr;
    if (!result) {
      return result;
    }
    var match$1 = result[0];
    var a_id$1 = match$1[0];
    switch (a_id$1.name) {
      case "None" :
          var a_descr$1 = match$1[1];
          if (a_descr$1.cstr_args) {
            return result;
          }
          var match$2 = result[1];
          if (!match$2) {
            return result;
          }
          var match$3 = match$2[0];
          var b_id$1 = match$3[0];
          if (b_id$1.name !== "Some") {
            return result;
          }
          var b_descr$1 = match$3[1];
          var match$4 = b_descr$1.cstr_args;
          if (!match$4) {
            return result;
          }
          if (match$4[1]) {
            return result;
          }
          if (match$2[1]) {
            return result;
          }
          a_id = a_id$1;
          a_descr = a_descr$1;
          b_id = b_id$1;
          b_descr = b_descr$1;
          break;
      case "Some" :
          var a_descr$2 = match$1[1];
          var match$5 = a_descr$2.cstr_args;
          if (!match$5) {
            return result;
          }
          if (match$5[1]) {
            return result;
          }
          var match$6 = result[1];
          if (!match$6) {
            return result;
          }
          var match$7 = match$6[0];
          var b_id$2 = match$7[0];
          if (b_id$2.name !== "None") {
            return result;
          }
          var b_descr$2 = match$7[1];
          if (b_descr$2.cstr_args) {
            return result;
          }
          if (match$6[1]) {
            return result;
          }
          a_id = a_id$1;
          a_descr = a_descr$2;
          b_id = b_id$2;
          b_descr = b_descr$2;
          break;
      default:
        return result;
    }
    return /* :: */[
            /* tuple */[
              a_id,
              {
                cstr_name: a_descr.cstr_name,
                cstr_res: a_descr.cstr_res,
                cstr_existentials: a_descr.cstr_existentials,
                cstr_args: a_descr.cstr_args,
                cstr_arity: a_descr.cstr_arity,
                cstr_tag: a_descr.cstr_tag,
                cstr_consts: a_descr.cstr_consts,
                cstr_nonconsts: a_descr.cstr_nonconsts,
                cstr_normal: a_descr.cstr_normal,
                cstr_generalized: a_descr.cstr_generalized,
                cstr_private: a_descr.cstr_private,
                cstr_loc: a_descr.cstr_loc,
                cstr_attributes: /* :: */[
                  optional_shape,
                  a_descr.cstr_attributes
                ]
              }
            ],
            /* :: */[
              /* tuple */[
                b_id,
                {
                  cstr_name: b_descr.cstr_name,
                  cstr_res: b_descr.cstr_res,
                  cstr_existentials: b_descr.cstr_existentials,
                  cstr_args: b_descr.cstr_args,
                  cstr_arity: b_descr.cstr_arity,
                  cstr_tag: b_descr.cstr_tag,
                  cstr_consts: b_descr.cstr_consts,
                  cstr_nonconsts: b_descr.cstr_nonconsts,
                  cstr_normal: b_descr.cstr_normal,
                  cstr_generalized: b_descr.cstr_generalized,
                  cstr_private: b_descr.cstr_private,
                  cstr_loc: b_descr.cstr_loc,
                  cstr_attributes: /* :: */[
                    optional_shape,
                    b_descr.cstr_attributes
                  ]
                }
              ],
              /* [] */0
            ]
          ];
  }
}

function labels_of_type(ty_path, decl) {
  var match = decl.type_kind;
  if (typeof match === "number" || match.tag) {
    return /* [] */0;
  } else {
    var ty_res = newty2(100000000, /* Tconstr */Block.__(3, [
            ty_path,
            decl.type_params,
            {
              contents: /* Mnil */0
            }
          ]));
    var lbls = match[0];
    var repres = match[1];
    var priv = decl.type_private;
    var all_labels = Caml_array.caml_make_vect(List.length(lbls), dummy_label);
    var describe_labels = function (num, param) {
      if (!param) {
        return /* [] */0;
      }
      var l = param[0];
      var lbl_lbl_name = l.ld_id.name;
      var lbl_lbl_arg = l.ld_type;
      var lbl_lbl_mut = l.ld_mutable;
      var lbl_lbl_loc = l.ld_loc;
      var lbl_lbl_attributes = l.ld_attributes;
      var lbl = {
        lbl_name: lbl_lbl_name,
        lbl_res: ty_res,
        lbl_arg: lbl_lbl_arg,
        lbl_mut: lbl_lbl_mut,
        lbl_pos: num,
        lbl_all: all_labels,
        lbl_repres: repres,
        lbl_private: priv,
        lbl_loc: lbl_lbl_loc,
        lbl_attributes: lbl_lbl_attributes
      };
      Caml_array.caml_array_set(all_labels, num, lbl);
      return /* :: */[
              /* tuple */[
                l.ld_id,
                lbl
              ],
              describe_labels(num + 1 | 0, param[1])
            ];
    };
    return describe_labels(0, lbls);
  }
}

function prefix_idents(root, pos, sub, param) {
  if (!param) {
    return /* tuple */[
            /* [] */0,
            sub
          ];
  }
  var match = param[0];
  switch (match.tag | 0) {
    case /* Sig_value */0 :
        var p_001 = match[0].name;
        var p = /* Pdot */Block.__(1, [
            root,
            p_001,
            pos
          ]);
        var match$1 = match[1].val_kind;
        var nextpos;
        nextpos = typeof match$1 === "number" || match$1.tag ? pos + 1 | 0 : pos;
        var match$2 = prefix_idents(root, nextpos, sub, param[1]);
        return /* tuple */[
                /* :: */[
                  p,
                  match$2[0]
                ],
                match$2[1]
              ];
    case /* Sig_type */1 :
        var id = match[0];
        var p_001$1 = id.name;
        var p$1 = /* Pdot */Block.__(1, [
            root,
            p_001$1,
            -1
          ]);
        var match$3 = prefix_idents(root, pos, add_type(id, p$1, sub), param[1]);
        return /* tuple */[
                /* :: */[
                  p$1,
                  match$3[0]
                ],
                match$3[1]
              ];
    case /* Sig_typext */2 :
        var p_001$2 = match[0].name;
        var p$2 = /* Pdot */Block.__(1, [
            root,
            p_001$2,
            pos
          ]);
        var match$4 = prefix_idents(root, pos + 1 | 0, sub, param[1]);
        return /* tuple */[
                /* :: */[
                  p$2,
                  match$4[0]
                ],
                match$4[1]
              ];
    case /* Sig_module */3 :
        var id$1 = match[0];
        var p_001$3 = id$1.name;
        var p$3 = /* Pdot */Block.__(1, [
            root,
            p_001$3,
            pos
          ]);
        var match$5 = prefix_idents(root, pos + 1 | 0, add_module(id$1, p$3, sub), param[1]);
        return /* tuple */[
                /* :: */[
                  p$3,
                  match$5[0]
                ],
                match$5[1]
              ];
    case /* Sig_modtype */4 :
        var id$2 = match[0];
        var p_001$4 = id$2.name;
        var p$4 = /* Pdot */Block.__(1, [
            root,
            p_001$4,
            -1
          ]);
        var match$6 = prefix_idents(root, pos, add_modtype(id$2, /* Mty_ident */Block.__(0, [p$4]), sub), param[1]);
        return /* tuple */[
                /* :: */[
                  p$4,
                  match$6[0]
                ],
                match$6[1]
              ];
    case /* Sig_class */5 :
        var p_001$5 = match[0].name;
        var p$5 = /* Pdot */Block.__(1, [
            root,
            p_001$5,
            pos
          ]);
        var match$7 = prefix_idents(root, pos + 1 | 0, sub, param[1]);
        return /* tuple */[
                /* :: */[
                  p$5,
                  match$7[0]
                ],
                match$7[1]
              ];
    case /* Sig_class_type */6 :
        var p_001$6 = match[0].name;
        var p$6 = /* Pdot */Block.__(1, [
            root,
            p_001$6,
            -1
          ]);
        var match$8 = prefix_idents(root, pos, sub, param[1]);
        return /* tuple */[
                /* :: */[
                  p$6,
                  match$8[0]
                ],
                match$8[1]
              ];
    
  }
}

function prefix_idents_and_subst(root, sub, sg) {
  var match = prefix_idents(root, 0, sub, sg);
  var sub$1 = match[1];
  return /* tuple */[
          match[0],
          sub$1,
          Caml_obj.caml_lazy_make((function (param) {
                  return List.map((function (item) {
                                switch (item.tag | 0) {
                                  case /* Sig_value */0 :
                                      return /* Sig_value */Block.__(0, [
                                                item[0],
                                                value_description(sub$1, item[1])
                                              ]);
                                  case /* Sig_type */1 :
                                      return /* Sig_type */Block.__(1, [
                                                item[0],
                                                type_declaration(sub$1, item[1]),
                                                item[2]
                                              ]);
                                  case /* Sig_typext */2 :
                                      return /* Sig_typext */Block.__(2, [
                                                item[0],
                                                extension_constructor(sub$1, item[1]),
                                                item[2]
                                              ]);
                                  case /* Sig_module */3 :
                                      return /* Sig_module */Block.__(3, [
                                                item[0],
                                                module_declaration(sub$1, item[1]),
                                                item[2]
                                              ]);
                                  case /* Sig_modtype */4 :
                                      return /* Sig_modtype */Block.__(4, [
                                                item[0],
                                                modtype_declaration(sub$1, item[1])
                                              ]);
                                  case /* Sig_class */5 :
                                      return /* Sig_class */Block.__(5, [
                                                item[0],
                                                class_declaration(sub$1, item[1]),
                                                item[2]
                                              ]);
                                  case /* Sig_class_type */6 :
                                      return /* Sig_class_type */Block.__(6, [
                                                item[0],
                                                cltype_declaration(sub$1, item[1]),
                                                item[2]
                                              ]);
                                  
                                }
                              }), sg);
                }))
        ];
}

function prefix_idents_and_subst$1(root, sub, sg) {
  if (!Caml_obj.caml_equal(sub, identity)) {
    return prefix_idents_and_subst(root, sub, sg);
  }
  var sgs;
  try {
    sgs = Hashtbl.find(prefixed_sg, root);
  }
  catch (exn){
    if (exn !== Caml_builtin_exceptions.not_found) {
      throw exn;
    }
    var sgs$1 = {
      contents: /* [] */0
    };
    Hashtbl.add(prefixed_sg, root, sgs$1);
    sgs = sgs$1;
  }
  try {
    return List.assq(sg, sgs.contents);
  }
  catch (exn$1){
    if (exn$1 !== Caml_builtin_exceptions.not_found) {
      throw exn$1;
    }
    var r = prefix_idents_and_subst(root, sub, sg);
    sgs.contents = /* :: */[
      /* tuple */[
        sg,
        r
      ],
      sgs.contents
    ];
    return r;
  }
}

function add_to_tbl(id, decl, tbl) {
  var decls;
  try {
    decls = find$2(id, tbl);
  }
  catch (exn){
    if (exn !== Caml_builtin_exceptions.not_found) {
      throw exn;
    }
    decls = /* [] */0;
  }
  return add$5(id, /* :: */[
              decl,
              decls
            ], tbl);
}

function components_of_module(env, sub, path, mty) {
  return {
          contents: /* Thunk */Block.__(2, [/* tuple */[
                env,
                sub,
                path,
                mty
              ]])
        };
}

function check_usage(loc, id, warn, tbl) {
  if (!(!loc.loc_ghost && is_active(Curry._1(warn, "")))) {
    return ;
  }
  var name = id.name;
  var key = /* tuple */[
    name,
    loc
  ];
  if (Hashtbl.mem(tbl, key)) {
    return ;
  }
  var used = {
    contents: false
  };
  Hashtbl.add(tbl, key, (function (param) {
          used.contents = true;
          
        }));
  if (!(name === "" || Caml_string.get(name, 0) === /* "_" */95 || Caml_string.get(name, 0) === /* "#" */35)) {
    return Curry._1(add_delayed_check_forward.contents, (function (param) {
                  if (!used.contents) {
                    return prerr_warning(loc, Curry._1(warn, name));
                  }
                  
                }));
  }
  
}

function check_value_name(name, loc) {
  if (bs_only.contents && name === "|.") {
    throw [
          $$Error$2,
          /* Illegal_value_name */Block.__(4, [
              loc,
              name
            ])
        ];
  }
  if (!(name.length !== 0 && Caml_string.get(name, 0) === /* "#" */35)) {
    return ;
  }
  for(var i = 1 ,i_finish = name.length - 1 | 0; i <= i_finish; ++i){
    if (Caml_string.get(name, i) === /* "#" */35) {
      throw [
            $$Error$2,
            /* Illegal_value_name */Block.__(4, [
                loc,
                name
              ])
          ];
    }
    
  }
  
}

function store_modtype(slot, id, path, info, env, renv) {
  return {
          values: env.values,
          constrs: env.constrs,
          labels: env.labels,
          types: env.types,
          modules: env.modules,
          modtypes: add$6("module type", slot, id, /* tuple */[
                path,
                info
              ], env.modtypes, renv.modtypes),
          components: env.components,
          classes: env.classes,
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: /* Env_modtype */Block.__(4, [
              env.summary,
              id,
              info
            ]),
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags
        };
}

function store_type_infos(slot, id, path, info, env, renv) {
  return {
          values: env.values,
          constrs: env.constrs,
          labels: env.labels,
          types: add$6("type", slot, id, /* tuple */[
                path,
                /* tuple */[
                  info,
                  /* tuple */[
                    /* [] */0,
                    /* [] */0
                  ]
                ]
              ], env.types, renv.types),
          modules: env.modules,
          modtypes: env.modtypes,
          components: env.components,
          classes: env.classes,
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: /* Env_type */Block.__(1, [
              env.summary,
              id,
              info
            ]),
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags
        };
}

function store_module(slot, id, path, md, env, renv) {
  return {
          values: env.values,
          constrs: env.constrs,
          labels: env.labels,
          types: env.types,
          modules: add$6("module", slot, id, /* tuple */[
                path,
                md
              ], env.modules, renv.modules),
          modtypes: env.modtypes,
          components: add$6("module", slot, id, /* tuple */[
                path,
                components_of_module(env, identity, path, md.md_type)
              ], env.components, renv.components),
          classes: env.classes,
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: /* Env_module */Block.__(3, [
              env.summary,
              id,
              md
            ]),
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags
        };
}

function components_of_module_maker(param) {
  var sub = param[1];
  var env = param[0];
  var match = scrape_alias(env, void 0, param[3]);
  switch (match.tag | 0) {
    case /* Mty_signature */1 :
        var sg = match[0];
        var c = {
          comp_values: /* Empty */0,
          comp_constrs: /* Empty */0,
          comp_labels: /* Empty */0,
          comp_types: /* Empty */0,
          comp_modules: /* Empty */0,
          comp_modtypes: /* Empty */0,
          comp_components: /* Empty */0,
          comp_classes: /* Empty */0,
          comp_cltypes: /* Empty */0
        };
        var match$1 = prefix_idents_and_subst$1(param[2], sub, sg);
        var sub$1 = match$1[1];
        var env$1 = {
          contents: env
        };
        var pos = {
          contents: 0
        };
        List.iter2((function (item, path) {
                switch (item.tag | 0) {
                  case /* Sig_value */0 :
                      var decl = item[1];
                      var decl$prime = value_description(sub$1, decl);
                      c.comp_values = add$5(item[0].name, /* tuple */[
                            decl$prime,
                            pos.contents
                          ], c.comp_values);
                      var match = decl.val_kind;
                      if (typeof match === "number" || match.tag) {
                        pos.contents = pos.contents + 1 | 0;
                        return ;
                      } else {
                        return ;
                      }
                  case /* Sig_type */1 :
                      var decl$1 = item[1];
                      var id = item[0];
                      var decl$prime$1 = type_declaration(sub$1, decl$1);
                      var constructors = List.map((function (prim) {
                              return prim[1];
                            }), constructors_of_type(path, decl$prime$1));
                      var labels = List.map((function (prim) {
                              return prim[1];
                            }), labels_of_type(path, decl$prime$1));
                      c.comp_types = add$5(id.name, /* tuple */[
                            /* tuple */[
                              decl$prime$1,
                              /* tuple */[
                                constructors,
                                labels
                              ]
                            ],
                            -1
                          ], c.comp_types);
                      List.iter((function (descr) {
                              c.comp_constrs = add_to_tbl(descr.cstr_name, /* tuple */[
                                    descr,
                                    -1
                                  ], c.comp_constrs);
                              
                            }), constructors);
                      List.iter((function (descr) {
                              c.comp_labels = add_to_tbl(descr.lbl_name, /* tuple */[
                                    descr,
                                    -1
                                  ], c.comp_labels);
                              
                            }), labels);
                      env$1.contents = store_type_infos(void 0, id, /* Pident */Block.__(0, [id]), decl$1, env$1.contents, env$1.contents);
                      return ;
                  case /* Sig_typext */2 :
                      var ext$prime = extension_constructor(sub$1, item[1]);
                      var descr = extension_descr(path, ext$prime);
                      c.comp_constrs = add_to_tbl(item[0].name, /* tuple */[
                            descr,
                            pos.contents
                          ], c.comp_constrs);
                      pos.contents = pos.contents + 1 | 0;
                      return ;
                  case /* Sig_module */3 :
                      var md = item[1];
                      var id$1 = item[0];
                      var mty = md.md_type;
                      var mty$prime = {
                        contents: /* Thunk */Block.__(2, [/* tuple */[
                              sub$1,
                              mty
                            ]])
                      };
                      c.comp_modules = add$5(id$1.name, /* tuple */[
                            mty$prime,
                            pos.contents
                          ], c.comp_modules);
                      var comps = components_of_module(env$1.contents, sub$1, path, mty);
                      c.comp_components = add$5(id$1.name, /* tuple */[
                            comps,
                            pos.contents
                          ], c.comp_components);
                      env$1.contents = store_module(void 0, id$1, /* Pident */Block.__(0, [id$1]), md, env$1.contents, env$1.contents);
                      pos.contents = pos.contents + 1 | 0;
                      return ;
                  case /* Sig_modtype */4 :
                      var decl$2 = item[1];
                      var id$2 = item[0];
                      var decl$prime$2 = modtype_declaration(sub$1, decl$2);
                      c.comp_modtypes = add$5(id$2.name, /* tuple */[
                            decl$prime$2,
                            -1
                          ], c.comp_modtypes);
                      env$1.contents = store_modtype(void 0, id$2, /* Pident */Block.__(0, [id$2]), decl$2, env$1.contents, env$1.contents);
                      return ;
                  case /* Sig_class */5 :
                      var decl$prime$3 = class_declaration(sub$1, item[1]);
                      c.comp_classes = add$5(item[0].name, /* tuple */[
                            decl$prime$3,
                            pos.contents
                          ], c.comp_classes);
                      pos.contents = pos.contents + 1 | 0;
                      return ;
                  case /* Sig_class_type */6 :
                      var decl$prime$4 = cltype_declaration(sub$1, item[1]);
                      c.comp_cltypes = add$5(item[0].name, /* tuple */[
                            decl$prime$4,
                            pos.contents
                          ], c.comp_cltypes);
                      return ;
                  
                }
              }), sg, match$1[0]);
        return /* Structure_comps */Block.__(0, [c]);
    case /* Mty_functor */2 :
        return /* Functor_comps */Block.__(1, [{
                    fcomp_param: match[0],
                    fcomp_arg: may_map((function (param) {
                            return modtype(sub, param);
                          }), match[1]),
                    fcomp_res: match[2],
                    fcomp_env: env,
                    fcomp_subst: sub,
                    fcomp_cache: Hashtbl.create(void 0, 17),
                    fcomp_subst_cache: Hashtbl.create(void 0, 17)
                  }]);
    case /* Mty_ident */0 :
    case /* Mty_alias */3 :
        break;
    
  }
  return /* Structure_comps */Block.__(0, [{
              comp_values: /* Empty */0,
              comp_constrs: /* Empty */0,
              comp_labels: /* Empty */0,
              comp_types: /* Empty */0,
              comp_modules: /* Empty */0,
              comp_modtypes: /* Empty */0,
              comp_components: /* Empty */0,
              comp_classes: /* Empty */0,
              comp_cltypes: /* Empty */0
            }]);
}

function store_value(check, slot, id, path, decl, env, renv) {
  check_value_name(id.name, decl.val_loc);
  may((function (f) {
          return check_usage(decl.val_loc, id, f, value_declarations);
        }), check);
  return {
          values: add$6("value", slot, id, /* tuple */[
                path,
                decl
              ], env.values, renv.values),
          constrs: env.constrs,
          labels: env.labels,
          types: env.types,
          modules: env.modules,
          modtypes: env.modtypes,
          components: env.components,
          classes: env.classes,
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: /* Env_value */Block.__(0, [
              env.summary,
              id,
              decl
            ]),
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags
        };
}

function store_type(check, slot, id, path, info, env, renv) {
  var loc = info.type_loc;
  if (check) {
    check_usage(loc, id, (function (s) {
            return /* Unused_type_declaration */Block.__(18, [s]);
          }), type_declarations);
  }
  var constructors = constructors_of_type(path, info);
  var labels = labels_of_type(path, info);
  var descrs_000 = List.map((function (prim) {
          return prim[1];
        }), constructors);
  var descrs_001 = List.map((function (prim) {
          return prim[1];
        }), labels);
  var descrs = /* tuple */[
    descrs_000,
    descrs_001
  ];
  if (check && !loc.loc_ghost && is_active(/* Unused_constructor */Block.__(21, [
            "",
            false,
            false
          ]))) {
    var ty = id.name;
    List.iter((function (param) {
            var c = param[1].cstr_name;
            var k = /* tuple */[
              ty,
              loc,
              c
            ];
            if (Hashtbl.mem(used_constructors, k)) {
              return ;
            }
            var used = {
              cu_positive: false,
              cu_pattern: false,
              cu_privatize: false
            };
            Hashtbl.add(used_constructors, k, (function (param) {
                    return add_constructor_usage(used, param);
                  }));
            if (!(ty === "" || Caml_string.get(ty, 0) === /* "_" */95)) {
              return Curry._1(add_delayed_check_forward.contents, (function (param) {
                            if (!is_in_signature(env) && !used.cu_positive) {
                              return prerr_warning(loc, /* Unused_constructor */Block.__(21, [
                                            c,
                                            used.cu_pattern,
                                            used.cu_privatize
                                          ]));
                            }
                            
                          }));
            }
            
          }), constructors);
  }
  return {
          values: env.values,
          constrs: List.fold_right((function (param, constrs) {
                  return add$6("constructor", slot, param[0], param[1], constrs, renv.constrs);
                }), constructors, env.constrs),
          labels: List.fold_right((function (param, labels) {
                  return add$6("label", slot, param[0], param[1], labels, renv.labels);
                }), labels, env.labels),
          types: add$6("type", slot, id, /* tuple */[
                path,
                /* tuple */[
                  info,
                  descrs
                ]
              ], env.types, renv.types),
          modules: env.modules,
          modtypes: env.modtypes,
          components: env.components,
          classes: env.classes,
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: /* Env_type */Block.__(1, [
              env.summary,
              id,
              info
            ]),
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags
        };
}

function store_extension(check, slot, id, path, ext, env, renv) {
  var loc = ext.ext_loc;
  if (check && !loc.loc_ghost && is_active(/* Unused_extension */Block.__(22, [
            "",
            false,
            false
          ]))) {
    var ty = last(ext.ext_type_path);
    var n = id.name;
    var k = /* tuple */[
      ty,
      loc,
      n
    ];
    if (!Hashtbl.mem(used_constructors, k)) {
      var used = {
        cu_positive: false,
        cu_pattern: false,
        cu_privatize: false
      };
      Hashtbl.add(used_constructors, k, (function (param) {
              return add_constructor_usage(used, param);
            }));
      Curry._1(add_delayed_check_forward.contents, (function (param) {
              if (!is_in_signature(env) && !used.cu_positive) {
                return prerr_warning(loc, /* Unused_extension */Block.__(22, [
                              n,
                              used.cu_pattern,
                              used.cu_privatize
                            ]));
              }
              
            }));
    }
    
  }
  return {
          values: env.values,
          constrs: add$6("constructor", slot, id, extension_descr(path, ext), env.constrs, renv.constrs),
          labels: env.labels,
          types: env.types,
          modules: env.modules,
          modtypes: env.modtypes,
          components: env.components,
          classes: env.classes,
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: /* Env_extension */Block.__(2, [
              env.summary,
              id,
              ext
            ]),
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags
        };
}

function store_class(slot, id, path, desc, env, renv) {
  return {
          values: env.values,
          constrs: env.constrs,
          labels: env.labels,
          types: env.types,
          modules: env.modules,
          modtypes: env.modtypes,
          components: env.components,
          classes: add$6("class", slot, id, /* tuple */[
                path,
                desc
              ], env.classes, renv.classes),
          cltypes: env.cltypes,
          functor_args: env.functor_args,
          summary: /* Env_class */Block.__(5, [
              env.summary,
              id,
              desc
            ]),
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags
        };
}

function store_cltype(slot, id, path, desc, env, renv) {
  return {
          values: env.values,
          constrs: env.constrs,
          labels: env.labels,
          types: env.types,
          modules: env.modules,
          modtypes: env.modtypes,
          components: env.components,
          classes: env.classes,
          cltypes: add$6("class type", slot, id, /* tuple */[
                path,
                desc
              ], env.cltypes, renv.cltypes),
          functor_args: env.functor_args,
          summary: /* Env_cltype */Block.__(6, [
              env.summary,
              id,
              desc
            ]),
          local_constraints: env.local_constraints,
          gadt_instances: env.gadt_instances,
          flags: env.flags
        };
}

function components_of_functor_appl(f, p1, p2) {
  try {
    return Hashtbl.find(f.fcomp_cache, p2);
  }
  catch (exn){
    if (exn !== Caml_builtin_exceptions.not_found) {
      throw exn;
    }
    var p = /* Papply */Block.__(2, [
        p1,
        p2
      ]);
    var mty = modtype(add_module(f.fcomp_param, p2, identity), f.fcomp_res);
    var comps = components_of_module(f.fcomp_env, f.fcomp_subst, p, mty);
    Hashtbl.add(f.fcomp_cache, p2, comps);
    return comps;
  }
}

components_of_module$prime.contents = components_of_module;

components_of_functor_appl$prime.contents = components_of_functor_appl;

components_of_module_maker$prime.contents = components_of_module_maker;

function add_value(check, id, desc, env) {
  return store_value(check, void 0, id, /* Pident */Block.__(0, [id]), desc, env, env);
}

function add_type$1(check, id, info, env) {
  return store_type(check, void 0, id, /* Pident */Block.__(0, [id]), info, env, env);
}

function add_extension(check, id, ext, env) {
  return store_extension(check, void 0, id, /* Pident */Block.__(0, [id]), ext, env, env);
}

function add_module_declaration(arg, id, md, env) {
  var path = /* Pident */Block.__(0, [id]);
  var env$1 = store_module(void 0, id, path, md, env, env);
  var arg$1 = arg !== void 0 ? arg : false;
  if (arg$1) {
    return {
            values: env$1.values,
            constrs: env$1.constrs,
            labels: env$1.labels,
            types: env$1.types,
            modules: env$1.modules,
            modtypes: env$1.modtypes,
            components: env$1.components,
            classes: env$1.classes,
            cltypes: env$1.cltypes,
            functor_args: add(id, void 0, env$1.functor_args),
            summary: /* Env_functor_arg */Block.__(8, [
                env$1.summary,
                id
              ]),
            local_constraints: env$1.local_constraints,
            gadt_instances: env$1.gadt_instances,
            flags: env$1.flags
          };
  } else {
    return env$1;
  }
}

function add_modtype$1(id, info, env) {
  return store_modtype(void 0, id, /* Pident */Block.__(0, [id]), info, env, env);
}

function add_class(id, ty, env) {
  return store_class(void 0, id, /* Pident */Block.__(0, [id]), ty, env, env);
}

function add_cltype(id, ty, env) {
  return store_cltype(void 0, id, /* Pident */Block.__(0, [id]), ty, env, env);
}

function add_module$1(arg, id, mty, env) {
  return add_module_declaration(arg, id, {
              md_type: mty,
              md_attributes: /* [] */0,
              md_loc: none
            }, env);
}

function add_local_constraint(id, info, elv, env) {
  if (info.type_manifest === void 0) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "env.ml",
            1538,
            9
          ]
        ];
  }
  var match = info.type_newtype_level;
  if (match === void 0) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "env.ml",
            1538,
            9
          ]
        ];
  }
  var env$1 = add_type$1(false, id, {
        type_params: info.type_params,
        type_arity: info.type_arity,
        type_kind: info.type_kind,
        type_private: info.type_private,
        type_manifest: info.type_manifest,
        type_variance: info.type_variance,
        type_newtype_level: /* tuple */[
          match[0],
          elv
        ],
        type_loc: info.type_loc,
        type_attributes: info.type_attributes
      }, env);
  return {
          values: env$1.values,
          constrs: env$1.constrs,
          labels: env$1.labels,
          types: env$1.types,
          modules: env$1.modules,
          modtypes: env$1.modtypes,
          components: env$1.components,
          classes: env$1.classes,
          cltypes: env$1.cltypes,
          functor_args: env$1.functor_args,
          summary: env$1.summary,
          local_constraints: true,
          gadt_instances: env$1.gadt_instances,
          flags: env$1.flags
        };
}

function enter(store_fun, name, data, env) {
  var id = create(name);
  return /* tuple */[
          id,
          Curry._6(store_fun, void 0, id, /* Pident */Block.__(0, [id]), data, env, env)
        ];
}

function enter_value(check) {
  return (function (param, param$1, param$2) {
      return enter((function (param, param$1, param$2, param$3, param$4, param$5) {
                    return store_value(check, param, param$1, param$2, param$3, param$4, param$5);
                  }), param, param$1, param$2);
    });
}

function enter_type(param, param$1, param$2) {
  return enter((function (param, param$1, param$2, param$3, param$4, param$5) {
                return store_type(true, param, param$1, param$2, param$3, param$4, param$5);
              }), param, param$1, param$2);
}

function enter_module_declaration(arg, name, md, env) {
  var id = create(name);
  return /* tuple */[
          id,
          add_module_declaration(arg, id, md, env)
        ];
}

function enter_modtype(param, param$1, param$2) {
  return enter(store_modtype, param, param$1, param$2);
}

function enter_module(arg, s, mty, env) {
  return enter_module_declaration(arg, s, {
              md_type: mty,
              md_attributes: /* [] */0,
              md_loc: none
            }, env);
}

function add_item(comp, env) {
  switch (comp.tag | 0) {
    case /* Sig_value */0 :
        return add_value(void 0, comp[0], comp[1], env);
    case /* Sig_type */1 :
        return add_type$1(false, comp[0], comp[1], env);
    case /* Sig_typext */2 :
        return add_extension(false, comp[0], comp[1], env);
    case /* Sig_module */3 :
        return add_module_declaration(void 0, comp[0], comp[1], env);
    case /* Sig_modtype */4 :
        return add_modtype$1(comp[0], comp[1], env);
    case /* Sig_class */5 :
        return add_class(comp[0], comp[1], env);
    case /* Sig_class_type */6 :
        return add_cltype(comp[0], comp[1], env);
    
  }
}

function add_signature(_sg, _env) {
  while(true) {
    var env = _env;
    var sg = _sg;
    if (!sg) {
      return env;
    }
    _env = add_item(sg[0], env);
    _sg = sg[1];
    continue ;
  };
}

function open_signature(slot, root, sg, env0) {
  var match = prefix_idents_and_subst$1(root, identity, sg);
  var sg$1 = CamlinternalLazy.force(match[2]);
  var newenv = List.fold_left2((function (env, item, p) {
          switch (item.tag | 0) {
            case /* Sig_value */0 :
                return store_value(void 0, slot, hide(item[0]), p, item[1], env, env0);
            case /* Sig_type */1 :
                return store_type(false, slot, hide(item[0]), p, item[1], env, env0);
            case /* Sig_typext */2 :
                return store_extension(false, slot, hide(item[0]), p, item[1], env, env0);
            case /* Sig_module */3 :
                return store_module(slot, hide(item[0]), p, item[1], env, env0);
            case /* Sig_modtype */4 :
                return store_modtype(slot, hide(item[0]), p, item[1], env, env0);
            case /* Sig_class */5 :
                return store_class(slot, hide(item[0]), p, item[1], env, env0);
            case /* Sig_class_type */6 :
                return store_cltype(slot, hide(item[0]), p, item[1], env, env0);
            
          }
        }), env0, sg$1, match[0]);
  return {
          values: newenv.values,
          constrs: newenv.constrs,
          labels: newenv.labels,
          types: newenv.types,
          modules: newenv.modules,
          modtypes: newenv.modtypes,
          components: newenv.components,
          classes: newenv.classes,
          cltypes: newenv.cltypes,
          functor_args: newenv.functor_args,
          summary: /* Env_open */Block.__(7, [
              env0.summary,
              root
            ]),
          local_constraints: newenv.local_constraints,
          gadt_instances: newenv.gadt_instances,
          flags: newenv.flags
        };
}

function open_signature$1(locOpt, toplevelOpt, ovf, root, sg, env) {
  var loc = locOpt !== void 0 ? locOpt : none;
  var toplevel = toplevelOpt !== void 0 ? toplevelOpt : false;
  if (!(!toplevel && ovf === /* Fresh */1 && !loc.loc_ghost && (is_active(/* Unused_open */Block.__(17, [""])) || is_active(/* Open_shadow_identifier */Block.__(27, [
                "",
                ""
              ])) || is_active(/* Open_shadow_label_constructor */Block.__(28, [
                "",
                ""
              ]))))) {
    return open_signature(void 0, root, sg, env);
  }
  var used = {
    contents: false
  };
  Curry._1(add_delayed_check_forward.contents, (function (param) {
          if (!used.contents) {
            return prerr_warning(loc, /* Unused_open */Block.__(17, [name(void 0, root)]));
          }
          
        }));
  var shadowed = {
    contents: /* [] */0
  };
  var slot = function (kind, s, b) {
    if (b && !List.mem(/* tuple */[
            kind,
            s
          ], shadowed.contents)) {
      shadowed.contents = /* :: */[
        /* tuple */[
          kind,
          s
        ],
        shadowed.contents
      ];
      var w;
      switch (kind) {
        case "constructor" :
        case "label" :
            w = /* Open_shadow_label_constructor */Block.__(28, [
                kind,
                s
              ]);
            break;
        default:
          w = /* Open_shadow_identifier */Block.__(27, [
              kind,
              s
            ]);
      }
      prerr_warning(loc, w);
    }
    used.contents = true;
    
  };
  return open_signature(slot, root, sg, env);
}

function read_signature(modname, filename) {
  var ps = read_pers_struct(modname, filename);
  check_consistency(ps);
  return ps.ps_sig;
}

function imports(param) {
  var dont_record_crc_unit$1 = dont_record_crc_unit.contents;
  if (dont_record_crc_unit$1 === void 0) {
    return extract(elements_aux$2(/* [] */0, imported_units.contents), crc_units);
  }
  var x = dont_record_crc_unit$1;
  return extract(fold$5((function (m, acc) {
                    if (m === x) {
                      return acc;
                    } else {
                      return /* :: */[
                              m,
                              acc
                            ];
                    }
                  }), imported_units.contents, /* [] */0), crc_units);
}

function save_signature(sg, modname, filename) {
  var imports$1 = imports(void 0);
  cleanup_abbrev(void 0);
  new_id$1.contents = -1;
  var sg$1 = signature$2(for_saving(identity), sg);
  var oc = Pervasives.open_out_bin(filename);
  try {
    var cmi_cmi_flags = recursive_types.contents ? /* :: */[
        /* Rectypes */0,
        /* [] */0
      ] : /* [] */0;
    var cmi = {
      cmi_name: modname,
      cmi_sign: sg$1,
      cmi_crcs: imports$1,
      cmi_flags: cmi_cmi_flags
    };
    var crc = output_cmi(filename, oc, cmi);
    Caml_io.caml_ml_flush(oc);
    Caml_external_polyfill.resolve("caml_ml_close_channel")(oc);
    var comps = components_of_module(empty, identity, /* Pident */Block.__(0, [{
              stamp: 0,
              name: modname,
              flags: 1
            }]), /* Mty_signature */Block.__(1, [sg$1]));
    var ps = {
      ps_name: modname,
      ps_sig: sg$1,
      ps_comps: comps,
      ps_crcs: /* :: */[
        /* tuple */[
          modname,
          crc
        ],
        imports$1
      ],
      ps_crcs_checked: false,
      ps_filename: filename,
      ps_flags: cmi_cmi_flags
    };
    save_pers_struct(crc, ps);
    return sg$1;
  }
  catch (exn){
    Caml_io.caml_ml_flush(oc);
    Caml_external_polyfill.resolve("caml_ml_close_channel")(oc);
    remove_file(filename);
    throw exn;
  }
}

function find_all$1(proj1, proj2, f, lid, env, acc) {
  if (lid === void 0) {
    return fold_name((function (id, param, acc) {
                    return Curry._4(f, id.name, param[0], param[1], acc);
                  }))(Curry._1(proj1, env), acc);
  }
  var match = lookup_module_descr(lid, env);
  var p = match[0];
  var match$1 = force(components_of_module_maker, match[1]);
  if (match$1.tag) {
    return acc;
  } else {
    return fold$4((function (s, param, acc) {
                  return Curry._4(f, s, /* Pdot */Block.__(1, [
                                p,
                                s,
                                param[1]
                              ]), param[0], acc);
                }), Curry._1(proj2, match$1[0]), acc);
  }
}

function find_all_simple_list(proj1, proj2, f, lid, env, acc) {
  if (lid === void 0) {
    return fold_name((function (id, data, acc) {
                    return Curry._2(f, data, acc);
                  }))(Curry._1(proj1, env), acc);
  }
  var match = lookup_module_descr(lid, env);
  var match$1 = force(components_of_module_maker, match[1]);
  if (match$1.tag) {
    return acc;
  } else {
    return fold$4((function (s, comps, acc) {
                  if (comps) {
                    return Curry._2(f, comps[0][0], acc);
                  } else {
                    return acc;
                  }
                }), Curry._1(proj2, match$1[0]), acc);
  }
}

function fold_modules(f, lid, env, acc) {
  if (lid !== void 0) {
    var match = lookup_module_descr(lid, env);
    var p = match[0];
    var match$1 = force(components_of_module_maker, match[1]);
    if (match$1.tag) {
      return acc;
    } else {
      return fold$4((function (s, param, acc) {
                    var md_type = force(subst_modtype_maker, param[0]);
                    return Curry._4(f, s, /* Pdot */Block.__(1, [
                                  p,
                                  s,
                                  param[1]
                                ]), {
                                md_type: md_type,
                                md_attributes: /* [] */0,
                                md_loc: none
                              }, acc);
                  }), match$1[0].comp_modules, acc);
    }
  } else {
    var acc$1 = fold_name((function (id, param, acc) {
              return Curry._4(f, id.name, param[0], param[1], acc);
            }))(env.modules, acc);
    return Hashtbl.fold((function (name, ps, acc) {
                  if (ps !== void 0) {
                    return Curry._4(f, name, /* Pident */Block.__(0, [{
                                    stamp: 0,
                                    name: name,
                                    flags: 1
                                  }]), {
                                md_type: /* Mty_signature */Block.__(1, [ps.ps_sig]),
                                md_attributes: /* [] */0,
                                md_loc: none
                              }, acc);
                  } else {
                    return acc;
                  }
                }), persistent_structures, acc$1);
  }
}

function fold_values(f) {
  return (function (param, param$1, param$2) {
      return find_all$1((function (env) {
                    return env.values;
                  }), (function (sc) {
                    return sc.comp_values;
                  }), f, param, param$1, param$2);
    });
}

function fold_constructors(f) {
  return (function (param, param$1, param$2) {
      return find_all_simple_list((function (env) {
                    return env.constrs;
                  }), (function (sc) {
                    return sc.comp_constrs;
                  }), f, param, param$1, param$2);
    });
}

function fold_labels(f) {
  return (function (param, param$1, param$2) {
      return find_all_simple_list((function (env) {
                    return env.labels;
                  }), (function (sc) {
                    return sc.comp_labels;
                  }), f, param, param$1, param$2);
    });
}

function fold_types(f) {
  return (function (param, param$1, param$2) {
      return find_all$1((function (env) {
                    return env.types;
                  }), (function (sc) {
                    return sc.comp_types;
                  }), f, param, param$1, param$2);
    });
}

function fold_modtypes(f) {
  return (function (param, param$1, param$2) {
      return find_all$1((function (env) {
                    return env.modtypes;
                  }), (function (sc) {
                    return sc.comp_modtypes;
                  }), f, param, param$1, param$2);
    });
}

function fold_classs(f) {
  return (function (param, param$1, param$2) {
      return find_all$1((function (env) {
                    return env.classes;
                  }), (function (sc) {
                    return sc.comp_classes;
                  }), f, param, param$1, param$2);
    });
}

function fold_cltypes(f) {
  return (function (param, param$1, param$2) {
      return find_all$1((function (env) {
                    return env.cltypes;
                  }), (function (sc) {
                    return sc.comp_cltypes;
                  }), f, param, param$1, param$2);
    });
}

var match = build_initial_env((function (param, param$1, param$2) {
        return add_type$1(false, param, param$1, param$2);
      }), (function (param, param$1, param$2) {
        return add_extension(false, param, param$1, param$2);
      }), empty);

var initial_safe_string = match[0];

var last_env = {
  contents: empty
};

var last_reduced_env = {
  contents: empty
};

function keep_only_summary(env) {
  if (last_env.contents === env) {
    return last_reduced_env.contents;
  }
  var new_env_summary = env.summary;
  var new_env_local_constraints = env.local_constraints;
  var new_env_flags = env.flags;
  var new_env = {
    values: /* Empty */0,
    constrs: /* Empty */0,
    labels: /* Empty */0,
    types: /* Empty */0,
    modules: /* Empty */0,
    modtypes: /* Empty */0,
    components: /* Empty */0,
    classes: /* Empty */0,
    cltypes: /* Empty */0,
    functor_args: /* Empty */0,
    summary: new_env_summary,
    local_constraints: new_env_local_constraints,
    gadt_instances: /* [] */0,
    flags: new_env_flags
  };
  last_env.contents = env;
  last_reduced_env.contents = new_env;
  return new_env;
}

function report_error$1(ppf, param) {
  switch (param.tag | 0) {
    case /* Illegal_renaming */0 :
        return Curry._4(Format.fprintf(ppf, /* Format */[
                        /* String_literal */Block.__(11, [
                            "Wrong file naming: ",
                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                    /* Break */Block.__(0, [
                                        "@ ",
                                        1,
                                        0
                                      ]),
                                    /* String_literal */Block.__(11, [
                                        "contains the compiled interface for ",
                                        /* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@ ",
                                                1,
                                                0
                                              ]),
                                            /* String */Block.__(2, [
                                                /* No_padding */0,
                                                /* String_literal */Block.__(11, [
                                                    " when ",
                                                    /* String */Block.__(2, [
                                                        /* No_padding */0,
                                                        /* String_literal */Block.__(11, [
                                                            " was expected",
                                                            /* End_of_format */0
                                                          ])
                                                      ])
                                                  ])
                                              ])
                                          ])
                                      ])
                                  ])])
                          ]),
                        "Wrong file naming: %a@ contains the compiled interface for @ %s when %s was expected"
                      ]), print_filename, param[2], param[0], param[1]);
    case /* Inconsistent_import */1 :
        return Curry._5(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<hov>",
                                      /* End_of_format */0
                                    ]),
                                  "<hov>"
                                ]]),
                            /* String_literal */Block.__(11, [
                                "The files ",
                                /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                        /* Break */Block.__(0, [
                                            "@ ",
                                            1,
                                            0
                                          ]),
                                        /* String_literal */Block.__(11, [
                                            "and ",
                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@ ",
                                                        1,
                                                        0
                                                      ]),
                                                    /* String_literal */Block.__(11, [
                                                        "make inconsistent assumptions",
                                                        /* Formatting_lit */Block.__(17, [
                                                            /* Break */Block.__(0, [
                                                                "@ ",
                                                                1,
                                                                0
                                                              ]),
                                                            /* String_literal */Block.__(11, [
                                                                "over interface ",
                                                                /* String */Block.__(2, [
                                                                    /* No_padding */0,
                                                                    /* Formatting_lit */Block.__(17, [
                                                                        /* Close_box */0,
                                                                        /* End_of_format */0
                                                                      ])
                                                                  ])
                                                              ])
                                                          ])
                                                      ])
                                                  ])])
                                          ])
                                      ])])
                              ])
                          ]),
                        "@[<hov>The files %a@ and %a@ make inconsistent assumptions@ over interface %s@]"
                      ]), print_filename, param[1], print_filename, param[2], param[0]);
    case /* Need_recursive_types */2 :
        return Curry._3(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<hov>",
                                      /* End_of_format */0
                                    ]),
                                  "<hov>"
                                ]]),
                            /* String_literal */Block.__(11, [
                                "Unit ",
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* String_literal */Block.__(11, [
                                        " imports from ",
                                        /* String */Block.__(2, [
                                            /* No_padding */0,
                                            /* String_literal */Block.__(11, [
                                                ", which uses recursive types.",
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@ ",
                                                        1,
                                                        0
                                                      ]),
                                                    /* String */Block.__(2, [
                                                        /* No_padding */0,
                                                        /* Formatting_lit */Block.__(17, [
                                                            /* Close_box */0,
                                                            /* End_of_format */0
                                                          ])
                                                      ])
                                                  ])
                                              ])
                                          ])
                                      ])
                                  ])
                              ])
                          ]),
                        "@[<hov>Unit %s imports from %s, which uses recursive types.@ %s@]"
                      ]), param[1], param[0], "The compilation flag -rectypes is required");
    case /* Missing_module */3 :
        var path2 = param[2];
        var path1 = param[1];
        Format.fprintf(ppf, /* Format */[
              /* Formatting_gen */Block.__(18, [
                  /* Open_box */Block.__(1, [/* Format */[
                        /* End_of_format */0,
                        ""
                      ]]),
                  /* Formatting_gen */Block.__(18, [
                      /* Open_box */Block.__(1, [/* Format */[
                            /* String_literal */Block.__(11, [
                                "<hov>",
                                /* End_of_format */0
                              ]),
                            "<hov>"
                          ]]),
                      /* End_of_format */0
                    ])
                ]),
              "@[@[<hov>"
            ]);
        if (same(path1, path2)) {
          Curry._1(Format.fprintf(ppf, /* Format */[
                    /* String_literal */Block.__(11, [
                        "Internal path",
                        /* Formatting_lit */Block.__(17, [
                            /* Break */Block.__(0, [
                                "@ ",
                                1,
                                0
                              ]),
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* Formatting_lit */Block.__(17, [
                                    /* Break */Block.__(0, [
                                        "@ ",
                                        1,
                                        0
                                      ]),
                                    /* String_literal */Block.__(11, [
                                        "is dangling.",
                                        /* End_of_format */0
                                      ])
                                  ])
                              ])
                          ])
                      ]),
                    "Internal path@ %s@ is dangling."
                  ]), name(void 0, path1));
        } else {
          Curry._2(Format.fprintf(ppf, /* Format */[
                    /* String_literal */Block.__(11, [
                        "Internal path",
                        /* Formatting_lit */Block.__(17, [
                            /* Break */Block.__(0, [
                                "@ ",
                                1,
                                0
                              ]),
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* Formatting_lit */Block.__(17, [
                                    /* Break */Block.__(0, [
                                        "@ ",
                                        1,
                                        0
                                      ]),
                                    /* String_literal */Block.__(11, [
                                        "expands to",
                                        /* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@ ",
                                                1,
                                                0
                                              ]),
                                            /* String */Block.__(2, [
                                                /* No_padding */0,
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@ ",
                                                        1,
                                                        0
                                                      ]),
                                                    /* String_literal */Block.__(11, [
                                                        "which is dangling.",
                                                        /* End_of_format */0
                                                      ])
                                                  ])
                                              ])
                                          ])
                                      ])
                                  ])
                              ])
                          ])
                      ]),
                    "Internal path@ %s@ expands to@ %s@ which is dangling."
                  ]), name(void 0, path1), name(void 0, path2));
        }
        return Curry._3(Format.fprintf(ppf, /* Format */[
                        /* Formatting_lit */Block.__(17, [
                            /* Close_box */0,
                            /* Formatting_lit */Block.__(17, [
                                /* Break */Block.__(0, [
                                    "@ ",
                                    1,
                                    0
                                  ]),
                                /* Formatting_gen */Block.__(18, [
                                    /* Open_box */Block.__(1, [/* Format */[
                                          /* End_of_format */0,
                                          ""
                                        ]]),
                                    /* String */Block.__(2, [
                                        /* No_padding */0,
                                        /* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@ ",
                                                1,
                                                0
                                              ]),
                                            /* String */Block.__(2, [
                                                /* No_padding */0,
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@ ",
                                                        1,
                                                        0
                                                      ]),
                                                    /* String */Block.__(2, [
                                                        /* No_padding */0,
                                                        /* Char_literal */Block.__(12, [
                                                            /* "." */46,
                                                            /* Formatting_lit */Block.__(17, [
                                                                /* Close_box */0,
                                                                /* Formatting_lit */Block.__(17, [
                                                                    /* Close_box */0,
                                                                    /* End_of_format */0
                                                                  ])
                                                              ])
                                                          ])
                                                      ])
                                                  ])
                                              ])
                                          ])
                                      ])
                                  ])
                              ])
                          ]),
                        "@]@ @[%s@ %s@ %s.@]@]"
                      ]), "The compiled interface for module", head(path2).name, "was not found");
    case /* Illegal_value_name */4 :
        return Curry._1(Format.fprintf(ppf, /* Format */[
                        /* Char_literal */Block.__(12, [
                            /* "'" */39,
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* String_literal */Block.__(11, [
                                    "' is not a valid value identifier.",
                                    /* End_of_format */0
                                  ])
                              ])
                          ]),
                        "'%s' is not a valid value identifier."
                      ]), param[1]);
    
  }
}

register_error_of_exn((function (param) {
        if (param[0] !== $$Error$2) {
          return ;
        }
        var err = param[1];
        switch (err.tag | 0) {
          case /* Missing_module */3 :
          case /* Illegal_value_name */4 :
              break;
          default:
            return error_of_printer_file(report_error$1, err);
        }
        var loc = err[0];
        if (Caml_obj.caml_notequal(loc, none)) {
          return error_of_printer(loc, report_error$1, err);
        } else {
          return error_of_printer_file(report_error$1, err);
        }
      }));

function assert_fail(msg) {
  Assert.fail(void 0, void 0, msg, "");
  
}

function is_mocha(param) {
  var match = $$Array.to_list(Process.argv);
  if (!match) {
    return false;
  }
  var match$1 = match[1];
  if (!match$1) {
    return false;
  }
  var exec = Path.basename(match$1[0]);
  if (exec === "mocha") {
    return true;
  } else {
    return exec === "_mocha";
  }
}

function close_enough(thresholdOpt, a, b) {
  var threshold = thresholdOpt !== void 0 ? thresholdOpt : 0.0000001;
  return Math.abs(a - b) < threshold;
}

function from_pair_suites(name, suites) {
  var match = $$Array.to_list(Process.argv);
  if (match) {
    if (is_mocha(void 0)) {
      describe(name, (function () {
              return List.iter((function (param) {
                            var code = param[1];
                            it(param[0], (function () {
                                    var spec = Curry._1(code, void 0);
                                    switch (spec.tag | 0) {
                                      case /* Eq */0 :
                                          Assert.deepEqual(spec[0], spec[1]);
                                          return ;
                                      case /* Neq */1 :
                                          Assert.notDeepEqual(spec[0], spec[1]);
                                          return ;
                                      case /* StrictEq */2 :
                                          Assert.strictEqual(spec[0], spec[1]);
                                          return ;
                                      case /* StrictNeq */3 :
                                          Assert.notStrictEqual(spec[0], spec[1]);
                                          return ;
                                      case /* Ok */4 :
                                          Assert.ok(spec[0]);
                                          return ;
                                      case /* Approx */5 :
                                          var b = spec[1];
                                          var a = spec[0];
                                          if (!close_enough(void 0, a, b)) {
                                            Assert.deepEqual(a, b);
                                            return ;
                                          } else {
                                            return ;
                                          }
                                      case /* ApproxThreshold */6 :
                                          var b$1 = spec[2];
                                          var a$1 = spec[1];
                                          if (!close_enough(spec[0], a$1, b$1)) {
                                            Assert.deepEqual(a$1, b$1);
                                            return ;
                                          } else {
                                            return ;
                                          }
                                      case /* ThrowAny */7 :
                                          Assert.throws(spec[0]);
                                          return ;
                                      case /* Fail */8 :
                                          return assert_fail("failed");
                                      case /* FailWith */9 :
                                          return assert_fail(spec[0]);
                                      
                                    }
                                  }));
                            
                          }), suites);
            }));
      return ;
    } else {
      console.log(/* tuple */[
            name,
            "testing"
          ]);
      return List.iter((function (param) {
                    var name = param[0];
                    var match = Curry._1(param[1], void 0);
                    switch (match.tag | 0) {
                      case /* Eq */0 :
                          console.log(/* tuple */[
                                name,
                                match[0],
                                "eq?",
                                match[1]
                              ]);
                          return ;
                      case /* Neq */1 :
                          console.log(/* tuple */[
                                name,
                                match[0],
                                "neq?",
                                match[1]
                              ]);
                          return ;
                      case /* StrictEq */2 :
                          console.log(/* tuple */[
                                name,
                                match[0],
                                "strict_eq?",
                                match[1]
                              ]);
                          return ;
                      case /* StrictNeq */3 :
                          console.log(/* tuple */[
                                name,
                                match[0],
                                "strict_neq?",
                                match[1]
                              ]);
                          return ;
                      case /* Ok */4 :
                          console.log(/* tuple */[
                                name,
                                match[0],
                                "ok?"
                              ]);
                          return ;
                      case /* Approx */5 :
                          console.log(/* tuple */[
                                name,
                                match[0],
                                "~",
                                match[1]
                              ]);
                          return ;
                      case /* ApproxThreshold */6 :
                          console.log(/* tuple */[
                                name,
                                match[1],
                                "~",
                                match[2],
                                " (",
                                match[0],
                                ")"
                              ]);
                          return ;
                      case /* ThrowAny */7 :
                          return ;
                      case /* Fail */8 :
                          console.log("failed");
                          return ;
                      case /* FailWith */9 :
                          console.log("failed: " + match[0]);
                          return ;
                      
                    }
                  }), suites);
    }
  }
  
}

Promise.resolve(void 0);

var $$Error$3 = Caml_exceptions.create("Ocaml_typedtree_test.Syntaxerr.Error");

var Escape_error = Caml_exceptions.create("Ocaml_typedtree_test.Syntaxerr.Escape_error");

function prepare_error(param) {
  switch (param.tag | 0) {
    case /* Unclosed */0 :
        var closing = param[3];
        var opening = param[1];
        return Curry._1(errorf(param[2], /* :: */[
                        Curry._1(errorf(param[0], void 0, void 0, /* Format */[
                                  /* String_literal */Block.__(11, [
                                      "This '",
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* String_literal */Block.__(11, [
                                              "' might be unmatched",
                                              /* End_of_format */0
                                            ])
                                        ])
                                    ]),
                                  "This '%s' might be unmatched"
                                ]), opening),
                        /* [] */0
                      ], Curry._2(Printf.sprintf(/* Format */[
                                /* String_literal */Block.__(11, [
                                    "Syntax error: '",
                                    /* String */Block.__(2, [
                                        /* No_padding */0,
                                        /* String_literal */Block.__(11, [
                                            "' expected, the highlighted '",
                                            /* String */Block.__(2, [
                                                /* No_padding */0,
                                                /* String_literal */Block.__(11, [
                                                    "' might be unmatched",
                                                    /* End_of_format */0
                                                  ])
                                              ])
                                          ])
                                      ])
                                  ]),
                                "Syntax error: '%s' expected, the highlighted '%s' might be unmatched"
                              ]), closing, opening), /* Format */[
                        /* String_literal */Block.__(11, [
                            "Syntax error: '",
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* String_literal */Block.__(11, [
                                    "' expected",
                                    /* End_of_format */0
                                  ])
                              ])
                          ]),
                        "Syntax error: '%s' expected"
                      ]), closing);
    case /* Expecting */1 :
        return Curry._1(errorf(param[0], void 0, void 0, /* Format */[
                        /* String_literal */Block.__(11, [
                            "Syntax error: ",
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* String_literal */Block.__(11, [
                                    " expected.",
                                    /* End_of_format */0
                                  ])
                              ])
                          ]),
                        "Syntax error: %s expected."
                      ]), param[1]);
    case /* Not_expecting */2 :
        return Curry._1(errorf(param[0], void 0, void 0, /* Format */[
                        /* String_literal */Block.__(11, [
                            "Syntax error: ",
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* String_literal */Block.__(11, [
                                    " not expected.",
                                    /* End_of_format */0
                                  ])
                              ])
                          ]),
                        "Syntax error: %s not expected."
                      ]), param[1]);
    case /* Applicative_path */3 :
        return errorf(param[0], void 0, void 0, /* Format */[
                    /* String_literal */Block.__(11, [
                        "Syntax error: applicative paths of the form F(X).t are not supported when the option -no-app-func is set.",
                        /* End_of_format */0
                      ]),
                    "Syntax error: applicative paths of the form F(X).t are not supported when the option -no-app-func is set."
                  ]);
    case /* Variable_in_scope */4 :
        var $$var = param[1];
        return Curry._2(errorf(param[0], void 0, void 0, /* Format */[
                        /* String_literal */Block.__(11, [
                            "In this scoped type, variable '",
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* String_literal */Block.__(11, [
                                    " is reserved for the local type ",
                                    /* String */Block.__(2, [
                                        /* No_padding */0,
                                        /* Char_literal */Block.__(12, [
                                            /* "." */46,
                                            /* End_of_format */0
                                          ])
                                      ])
                                  ])
                              ])
                          ]),
                        "In this scoped type, variable '%s is reserved for the local type %s."
                      ]), $$var, $$var);
    case /* Other */5 :
        return errorf(param[0], void 0, void 0, /* Format */[
                    /* String_literal */Block.__(11, [
                        "Syntax error",
                        /* End_of_format */0
                      ]),
                    "Syntax error"
                  ]);
    case /* Ill_formed_ast */6 :
        return Curry._1(errorf(param[0], void 0, void 0, /* Format */[
                        /* String_literal */Block.__(11, [
                            "broken invariant in parsetree: ",
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* End_of_format */0
                              ])
                          ]),
                        "broken invariant in parsetree: %s"
                      ]), param[1]);
    
  }
}

register_error_of_exn((function (param) {
        if (param[0] === $$Error$3) {
          return prepare_error(param[1]);
        }
        
      }));

function ill_formed_ast(loc, s) {
  throw [
        $$Error$3,
        /* Ill_formed_ast */Block.__(6, [
            loc,
            s
          ])
      ];
}

function mktyp(d) {
  return mk(symbol_rloc(void 0), void 0, d);
}

function mkpat(d) {
  return mk$1(symbol_rloc(void 0), void 0, d);
}

function mkexp(d) {
  return Curry._3(Ast_helper_Exp.mk, symbol_rloc(void 0), void 0, d);
}

function mkmty(d) {
  return mk$3(symbol_rloc(void 0), void 0, d);
}

function mksig(d) {
  return mk$5(symbol_rloc(void 0), d);
}

function mkmod(d) {
  return mk$4(symbol_rloc(void 0), void 0, d);
}

function mkstr(d) {
  return mk$6(symbol_rloc(void 0), d);
}

function mkclass(d) {
  return mk$7(symbol_rloc(void 0), void 0, d);
}

function mkcty(d) {
  return mk$8(symbol_rloc(void 0), void 0, d);
}

function mkctf(attrs, docs, d) {
  return Curry._4(Ast_helper_Ctf.mk, symbol_rloc(void 0), attrs, docs, d);
}

function mkcf(attrs, docs, d) {
  return Curry._4(Ast_helper_Cf.mk, symbol_rloc(void 0), attrs, docs, d);
}

function mkoption(d) {
  var init = d.ptyp_loc;
  var loc_loc_start = init.loc_start;
  var loc_loc_end = init.loc_end;
  var loc = {
    loc_start: loc_loc_start,
    loc_end: loc_loc_end,
    loc_ghost: true
  };
  return mk(loc, void 0, /* Ptyp_constr */Block.__(3, [
                {
                  txt: /* Ldot */Block.__(1, [
                      /* Lident */Block.__(0, ["*predef*"]),
                      "option"
                    ]),
                  loc: loc
                },
                /* :: */[
                  d,
                  /* [] */0
                ]
              ]));
}

function reloc_pat(x) {
  return {
          ppat_desc: x.ppat_desc,
          ppat_loc: symbol_rloc(void 0),
          ppat_attributes: x.ppat_attributes
        };
}

function reloc_exp(x) {
  return {
          pexp_desc: x.pexp_desc,
          pexp_loc: symbol_rloc(void 0),
          pexp_attributes: x.pexp_attributes
        };
}

function mkoperator(name, pos) {
  var loc = rhs_loc(pos);
  return Curry._3(Ast_helper_Exp.mk, loc, void 0, /* Pexp_ident */Block.__(0, [{
                  txt: /* Lident */Block.__(0, [name]),
                  loc: loc
                }]));
}

function mkpatvar(name, pos) {
  return mk$1(rhs_loc(pos), void 0, /* Ppat_var */Block.__(0, [{
                  txt: name,
                  loc: rhs_loc(pos)
                }]));
}

function ghexp(d) {
  return Curry._3(Ast_helper_Exp.mk, symbol_gloc(void 0), void 0, d);
}

function ghpat(d) {
  return mk$1(symbol_gloc(void 0), void 0, d);
}

function ghtyp(d) {
  return mk(symbol_gloc(void 0), void 0, d);
}

function mkinfix(arg1, name, arg2) {
  return mkexp(/* Pexp_apply */Block.__(5, [
                mkoperator(name, 2),
                /* :: */[
                  /* tuple */[
                    "",
                    arg1
                  ],
                  /* :: */[
                    /* tuple */[
                      "",
                      arg2
                    ],
                    /* [] */0
                  ]
                ]
              ]));
}

function neg_float_string(f) {
  if (f.length !== 0 && Caml_string.get(f, 0) === /* "-" */45) {
    return $$String.sub(f, 1, f.length - 1 | 0);
  } else {
    return "-" + f;
  }
}

function mkexp_cons(consloc, args, loc) {
  return Curry._3(Ast_helper_Exp.mk, loc, void 0, /* Pexp_construct */Block.__(9, [
                {
                  txt: /* Lident */Block.__(0, ["::"]),
                  loc: consloc
                },
                args
              ]));
}

function mkpat_cons(consloc, args, loc) {
  return mk$1(loc, void 0, /* Ppat_construct */Block.__(5, [
                {
                  txt: /* Lident */Block.__(0, ["::"]),
                  loc: consloc
                },
                args
              ]));
}

function mktailexp(nilloc, param) {
  if (param) {
    var e1 = param[0];
    var exp_el = mktailexp(nilloc, param[1]);
    var loc_loc_start = e1.pexp_loc.loc_start;
    var loc_loc_end = exp_el.pexp_loc.loc_end;
    var loc = {
      loc_start: loc_loc_start,
      loc_end: loc_loc_end,
      loc_ghost: true
    };
    var arg = Curry._3(Ast_helper_Exp.mk, loc, void 0, /* Pexp_tuple */Block.__(8, [/* :: */[
              e1,
              /* :: */[
                exp_el,
                /* [] */0
              ]
            ]]));
    return mkexp_cons({
                loc_start: loc_loc_start,
                loc_end: loc_loc_end,
                loc_ghost: true
              }, arg, loc);
  } else {
    var loc_loc_start$1 = nilloc.loc_start;
    var loc_loc_end$1 = nilloc.loc_end;
    var loc$1 = {
      loc_start: loc_loc_start$1,
      loc_end: loc_loc_end$1,
      loc_ghost: true
    };
    var nil_txt = /* Lident */Block.__(0, ["[]"]);
    var nil = {
      txt: nil_txt,
      loc: loc$1
    };
    return Curry._3(Ast_helper_Exp.mk, loc$1, void 0, /* Pexp_construct */Block.__(9, [
                  nil,
                  void 0
                ]));
  }
}

function mktailpat(nilloc, param) {
  if (param) {
    var p1 = param[0];
    var pat_pl = mktailpat(nilloc, param[1]);
    var loc_loc_start = p1.ppat_loc.loc_start;
    var loc_loc_end = pat_pl.ppat_loc.loc_end;
    var loc = {
      loc_start: loc_loc_start,
      loc_end: loc_loc_end,
      loc_ghost: true
    };
    var arg = mk$1(loc, void 0, /* Ppat_tuple */Block.__(4, [/* :: */[
              p1,
              /* :: */[
                pat_pl,
                /* [] */0
              ]
            ]]));
    return mkpat_cons({
                loc_start: loc_loc_start,
                loc_end: loc_loc_end,
                loc_ghost: true
              }, arg, loc);
  } else {
    var loc_loc_start$1 = nilloc.loc_start;
    var loc_loc_end$1 = nilloc.loc_end;
    var loc$1 = {
      loc_start: loc_loc_start$1,
      loc_end: loc_loc_end$1,
      loc_ghost: true
    };
    var nil_txt = /* Lident */Block.__(0, ["[]"]);
    var nil = {
      txt: nil_txt,
      loc: loc$1
    };
    return mk$1(loc$1, void 0, /* Ppat_construct */Block.__(5, [
                  nil,
                  void 0
                ]));
  }
}

function mkstrexp(e, attrs) {
  return {
          pstr_desc: /* Pstr_eval */Block.__(0, [
              e,
              attrs
            ]),
          pstr_loc: e.pexp_loc
        };
}

function mkexp_constraint(e, param) {
  var t2 = param[1];
  var t1 = param[0];
  if (t1 !== void 0) {
    if (t2 !== void 0) {
      return ghexp(/* Pexp_coerce */Block.__(20, [
                    e,
                    t1,
                    t2
                  ]));
    } else {
      return ghexp(/* Pexp_constraint */Block.__(19, [
                    e,
                    t1
                  ]));
    }
  }
  if (t2 !== void 0) {
    return ghexp(/* Pexp_coerce */Block.__(20, [
                  e,
                  t1,
                  t2
                ]));
  }
  throw [
        Caml_builtin_exceptions.assert_failure,
        /* tuple */[
          "parser.mly",
          153,
          18
        ]
      ];
}

function array_function(str, name) {
  return {
          txt: /* Ldot */Block.__(1, [
              /* Lident */Block.__(0, [str]),
              fast.contents ? "unsafe_" + name : name
            ]),
          loc: symbol_gloc(void 0)
        };
}

function unclosed(opening_name, opening_num, closing_name, closing_num) {
  throw [
        $$Error$3,
        /* Unclosed */Block.__(0, [
            rhs_loc(opening_num),
            opening_name,
            rhs_loc(closing_num),
            closing_name
          ])
      ];
}

function expecting(pos, nonterm) {
  throw [
        $$Error$3,
        /* Expecting */Block.__(1, [
            rhs_loc(pos),
            nonterm
          ])
      ];
}

function not_expecting(pos, nonterm) {
  throw [
        $$Error$3,
        /* Not_expecting */Block.__(2, [
            rhs_loc(pos),
            nonterm
          ])
      ];
}

function bigarray_function(str, name) {
  return {
          txt: /* Ldot */Block.__(1, [
              /* Ldot */Block.__(1, [
                  /* Lident */Block.__(0, ["Bigarray"]),
                  str
                ]),
              name
            ]),
          loc: symbol_gloc(void 0)
        };
}

function bigarray_untuplify(exp) {
  var match = exp.pexp_desc;
  if (match.tag === /* Pexp_tuple */8) {
    return match[0];
  } else {
    return /* :: */[
            exp,
            /* [] */0
          ];
  }
}

function exp_of_label(lbl, pos) {
  var rhs = /* Lident */Block.__(0, [last$1(lbl)]);
  return mkexp(/* Pexp_ident */Block.__(0, [{
                  txt: rhs,
                  loc: rhs_loc(pos)
                }]));
}

function pat_of_label(lbl, pos) {
  var rhs = last$1(lbl);
  return mkpat(/* Ppat_var */Block.__(0, [{
                  txt: rhs,
                  loc: rhs_loc(pos)
                }]));
}

function check_variable(vl, loc, v) {
  if (List.mem(v, vl)) {
    throw [
          $$Error$3,
          /* Variable_in_scope */Block.__(4, [
              loc,
              v
            ])
        ];
  }
  
}

function varify_constructors(var_names, t) {
  var loop = function (t) {
    var match = t.ptyp_desc;
    var desc;
    if (typeof match === "number") {
      desc = /* Ptyp_any */0;
    } else {
      switch (match.tag | 0) {
        case /* Ptyp_var */0 :
            var x = match[0];
            check_variable(var_names, t.ptyp_loc, x);
            desc = /* Ptyp_var */Block.__(0, [x]);
            break;
        case /* Ptyp_arrow */1 :
            desc = /* Ptyp_arrow */Block.__(1, [
                match[0],
                loop(match[1]),
                loop(match[2])
              ]);
            break;
        case /* Ptyp_tuple */2 :
            desc = /* Ptyp_tuple */Block.__(2, [List.map(loop, match[0])]);
            break;
        case /* Ptyp_constr */3 :
            var longident = match[0];
            var match$1 = longident.txt;
            var exit = 0;
            switch (match$1.tag | 0) {
              case /* Lident */0 :
                  if (match[1]) {
                    exit = 1;
                  } else {
                    var s = match$1[0];
                    if (List.mem(s, var_names)) {
                      desc = /* Ptyp_var */Block.__(0, [s]);
                    } else {
                      exit = 1;
                    }
                  }
                  break;
              case /* Ldot */1 :
              case /* Lapply */2 :
                  exit = 1;
                  break;
              
            }
            if (exit === 1) {
              desc = /* Ptyp_constr */Block.__(3, [
                  longident,
                  List.map(loop, match[1])
                ]);
            }
            break;
        case /* Ptyp_object */4 :
            desc = /* Ptyp_object */Block.__(4, [
                List.map((function (param) {
                        return /* tuple */[
                                param[0],
                                param[1],
                                loop(param[2])
                              ];
                      }), match[0]),
                match[1]
              ]);
            break;
        case /* Ptyp_class */5 :
            desc = /* Ptyp_class */Block.__(5, [
                match[0],
                List.map(loop, match[1])
              ]);
            break;
        case /* Ptyp_alias */6 :
            var string = match[1];
            check_variable(var_names, t.ptyp_loc, string);
            desc = /* Ptyp_alias */Block.__(6, [
                loop(match[0]),
                string
              ]);
            break;
        case /* Ptyp_variant */7 :
            desc = /* Ptyp_variant */Block.__(7, [
                List.map(loop_row_field, match[0]),
                match[1],
                match[2]
              ]);
            break;
        case /* Ptyp_poly */8 :
            var string_lst = match[0];
            var partial_arg = t.ptyp_loc;
            List.iter((function (param) {
                    return check_variable(var_names, partial_arg, param);
                  }), string_lst);
            desc = /* Ptyp_poly */Block.__(8, [
                string_lst,
                loop(match[1])
              ]);
            break;
        case /* Ptyp_package */9 :
            var match$2 = match[0];
            desc = /* Ptyp_package */Block.__(9, [/* tuple */[
                  match$2[0],
                  List.map((function (param) {
                          return /* tuple */[
                                  param[0],
                                  loop(param[1])
                                ];
                        }), match$2[1])
                ]]);
            break;
        case /* Ptyp_extension */10 :
            var match$3 = match[0];
            desc = /* Ptyp_extension */Block.__(10, [/* tuple */[
                  match$3[0],
                  match$3[1]
                ]]);
            break;
        
      }
    }
    return {
            ptyp_desc: desc,
            ptyp_loc: t.ptyp_loc,
            ptyp_attributes: t.ptyp_attributes
          };
  };
  var loop_row_field = function (param) {
    if (param.tag) {
      return /* Rinherit */Block.__(1, [loop(param[0])]);
    } else {
      return /* Rtag */Block.__(0, [
                param[0],
                param[1],
                param[2],
                List.map(loop, param[3])
              ]);
    }
  };
  return loop(t);
}

function wrap_type_annotation(newtypes, core_type, body) {
  var exp = mkexp(/* Pexp_constraint */Block.__(19, [
          body,
          core_type
        ]));
  var exp$1 = List.fold_right((function (newtype, exp) {
          return mkexp(/* Pexp_newtype */Block.__(30, [
                        newtype,
                        exp
                      ]));
        }), newtypes, exp);
  return /* tuple */[
          exp$1,
          ghtyp(/* Ptyp_poly */Block.__(8, [
                  newtypes,
                  varify_constructors(newtypes, core_type)
                ]))
        ];
}

function wrap_exp_attrs(body, param) {
  var ext = param[0];
  var body_pexp_desc = body.pexp_desc;
  var body_pexp_loc = body.pexp_loc;
  var body_pexp_attributes = Pervasives.$at(param[1], body.pexp_attributes);
  var body$1 = {
    pexp_desc: body_pexp_desc,
    pexp_loc: body_pexp_loc,
    pexp_attributes: body_pexp_attributes
  };
  if (ext !== void 0) {
    return ghexp(/* Pexp_extension */Block.__(33, [/* tuple */[
                    ext,
                    /* PStr */Block.__(0, [/* :: */[
                          mkstrexp(body$1, /* [] */0),
                          /* [] */0
                        ]])
                  ]]));
  } else {
    return body$1;
  }
}

function text_def(pos) {
  return /* :: */[
          /* Ptop_def */Block.__(0, [text$1(get_text(Parsing.rhs_start_pos(pos)))]),
          /* [] */0
        ];
}

function extra_text(text, pos, items) {
  var pre_extras = get_pre_extra_text(Parsing.rhs_start_pos(pos));
  var post_extras = get_post_extra_text(Parsing.rhs_end_pos(pos));
  return Pervasives.$at(Curry._1(text, pre_extras), Pervasives.$at(items, Curry._1(text, post_extras)));
}

function extra_cstr(pos, items) {
  return extra_text(Ast_helper_Cf.text, pos, items);
}

function extra_csig(pos, items) {
  return extra_text(Ast_helper_Ctf.text, pos, items);
}

function add_nonrec(rf, attrs, pos) {
  if (rf) {
    return attrs;
  }
  var name_loc = rhs_loc(pos);
  var name = {
    txt: "nonrec",
    loc: name_loc
  };
  return /* :: */[
          /* tuple */[
            name,
            /* PStr */Block.__(0, [/* [] */0])
          ],
          attrs
        ];
}

function mklb(param, attrs) {
  return {
          lb_pattern: param[0],
          lb_expression: param[1],
          lb_attributes: attrs,
          lb_docs: symbol_docs_lazy(void 0),
          lb_text: symbol_text_lazy(void 0),
          lb_loc: symbol_rloc(void 0)
        };
}

var yytransl_const = [
  257,
  258,
  259,
  260,
  261,
  262,
  263,
  264,
  265,
  266,
  267,
  269,
  270,
  271,
  272,
  273,
  274,
  275,
  276,
  277,
  278,
  279,
  280,
  281,
  282,
  0,
  283,
  284,
  285,
  286,
  288,
  289,
  290,
  291,
  292,
  293,
  294,
  295,
  296,
  297,
  303,
  304,
  309,
  310,
  311,
  312,
  313,
  314,
  315,
  316,
  317,
  318,
  319,
  320,
  322,
  323,
  324,
  325,
  326,
  327,
  328,
  329,
  330,
  331,
  332,
  334,
  335,
  336,
  337,
  338,
  340,
  341,
  342,
  343,
  344,
  346,
  347,
  348,
  349,
  350,
  351,
  352,
  353,
  354,
  355,
  357,
  358,
  360,
  361,
  362,
  363,
  364,
  365,
  366,
  368,
  369,
  370,
  371,
  372,
  373,
  376,
  0
];

var yytransl_block = [
  268,
  287,
  298,
  299,
  300,
  301,
  302,
  305,
  306,
  307,
  308,
  321,
  333,
  339,
  345,
  356,
  359,
  367,
  374,
  375,
  0
];

var yyact = [
  (function (param) {
      throw [
            Caml_builtin_exceptions.failure,
            "parser"
          ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      return extra_text(text$1, 1, _1);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      return extra_text(text, 1, _1);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      return /* Ptop_def */Block.__(0, [extra_text(text$1, 1, _1)]);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 1);
    }),
  (function (__caml_parser_env) {
      throw Caml_builtin_exceptions.end_of_file;
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(text$1(get_text(Parsing.rhs_start_pos(1))), /* :: */[
                  mkstrexp(_1, _2),
                  /* [] */0
                ]);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return /* [] */0;
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(text$1(get_text(Parsing.rhs_start_pos(1))), /* :: */[
                  _1,
                  _2
                ]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      var pos = 1;
      return extra_text((function (txt) {
                    return /* :: */[
                            /* Ptop_def */Block.__(0, [text$1(txt)]),
                            /* [] */0
                          ];
                  }), pos, _1);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(text_def(1), /* :: */[
                  /* Ptop_def */Block.__(0, [/* :: */[
                        mkstrexp(_1, _2),
                        /* [] */0
                      ]]),
                  _3
                ]);
    }),
  (function (__caml_parser_env) {
      return /* [] */0;
    }),
  (function (__caml_parser_env) {
      return text_def(1);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      mark_rhs_docs(2, 3);
      return Pervasives.$at(text_def(1), Pervasives.$at(text_def(2), /* :: */[
                      /* Ptop_def */Block.__(0, [/* :: */[
                            mkstrexp(_2, _3),
                            /* [] */0
                          ]]),
                      _4
                    ]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(text_def(1), Pervasives.$at(text_def(2), /* :: */[
                      /* Ptop_def */Block.__(0, [/* :: */[
                            _2,
                            /* [] */0
                          ]]),
                      _3
                    ]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      mark_rhs_docs(2, 3);
      return Pervasives.$at(text_def(1), Pervasives.$at(text_def(2), /* :: */[
                      _2,
                      _3
                    ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(text_def(1), /* :: */[
                  /* Ptop_def */Block.__(0, [/* :: */[
                        _1,
                        /* [] */0
                      ]]),
                  _2
                ]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      mark_rhs_docs(1, 1);
      return Pervasives.$at(text_def(1), /* :: */[
                  _1,
                  _2
                ]);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 1);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 1);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 1);
    }),
  (function (__caml_parser_env) {
      return /* tuple */[
              {
                txt: "*",
                loc: rhs_loc(2)
              },
              void 0
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      return /* tuple */[
              {
                txt: _2,
                loc: rhs_loc(2)
              },
              _4
            ];
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return "_";
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _2,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmod(/* Pmod_ident */Block.__(0, [{
                      txt: _1,
                      loc: rhs_loc(1)
                    }]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      return mkmod(/* Pmod_structure */Block.__(1, [extra_text(text$1, 2, _2)]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("struct", 1, "end", 3);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return List.fold_left((function (acc, param) {
                    return mkmod(/* Pmod_functor */Block.__(2, [
                                  param[0],
                                  param[1],
                                  acc
                                ]));
                  }), _4, _2);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 3);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      return mkmod(/* Pmod_apply */Block.__(3, [
                    _1,
                    _3
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      return mkmod(/* Pmod_apply */Block.__(3, [
                    _1,
                    mkmod(/* Pmod_structure */Block.__(1, [/* [] */0]))
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 2, ")", 4);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      return mkmod(/* Pmod_constraint */Block.__(4, [
                    _2,
                    _4
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 5);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 1);
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 3);
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      return mkmod(/* Pmod_unpack */Block.__(5, [_3]));
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 3);
      var _5 = Parsing.peek_val(__caml_parser_env, 1);
      return mkmod(/* Pmod_unpack */Block.__(5, [ghexp(/* Pexp_constraint */Block.__(19, [
                            _3,
                            ghtyp(/* Ptyp_package */Block.__(9, [_5]))
                          ]))]));
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 5);
      var _5 = Parsing.peek_val(__caml_parser_env, 3);
      var _7 = Parsing.peek_val(__caml_parser_env, 1);
      return mkmod(/* Pmod_unpack */Block.__(5, [ghexp(/* Pexp_coerce */Block.__(20, [
                            _3,
                            ghtyp(/* Ptyp_package */Block.__(9, [_5])),
                            ghtyp(/* Ptyp_package */Block.__(9, [_7]))
                          ]))]));
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 3);
      var _5 = Parsing.peek_val(__caml_parser_env, 1);
      return mkmod(/* Pmod_unpack */Block.__(5, [ghexp(/* Pexp_coerce */Block.__(20, [
                            _3,
                            void 0,
                            ghtyp(/* Ptyp_package */Block.__(9, [_5]))
                          ]))]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 2);
      return unclosed("(", 1, ")", 5);
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 2);
      return unclosed("(", 1, ")", 5);
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 4);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return attr$4(_1, _2);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmod(/* Pmod_extension */Block.__(6, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      mark_rhs_docs(1, 2);
      return Pervasives.$at(text$1(get_text(Parsing.rhs_start_pos(1))), /* :: */[
                  mkstrexp(_1, _2),
                  _3
                ]);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return /* [] */0;
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(text$1(get_text(Parsing.rhs_start_pos(1))), _2);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(text$1(get_text(Parsing.rhs_start_pos(1))), /* :: */[
                  _1,
                  _2
                ]);
    }),
  (function (__caml_parser_env) {
      var lbs = Parsing.peek_val(__caml_parser_env, 0);
      var bindings = lbs.lbs_bindings;
      var str;
      var exit = 0;
      if (bindings) {
        var lb = bindings[0];
        if (typeof lb.lb_pattern.ppat_desc === "number" && !bindings[1]) {
          var exp = wrap_exp_attrs(lb.lb_expression, /* tuple */[
                void 0,
                lbs.lbs_attributes
              ]);
          str = mkstr(/* Pstr_eval */Block.__(0, [
                  exp,
                  lb.lb_attributes
                ]));
        } else {
          exit = 1;
        }
      } else {
        exit = 1;
      }
      if (exit === 1) {
        if (lbs.lbs_attributes !== /* [] */0) {
          throw [
                $$Error$3,
                /* Not_expecting */Block.__(2, [
                    lbs.lbs_loc,
                    "attributes"
                  ])
              ];
        }
        var bindings$1 = List.map((function (lb) {
                return mk$17(lb.lb_loc, lb.lb_attributes, CamlinternalLazy.force(lb.lb_docs), CamlinternalLazy.force(lb.lb_text), lb.lb_pattern, lb.lb_expression);
              }), bindings);
        str = mkstr(/* Pstr_value */Block.__(1, [
                lbs.lbs_rec,
                List.rev(bindings$1)
              ]));
      }
      var match = lbs.lbs_extension;
      if (match !== void 0) {
        var d = /* Pstr_extension */Block.__(14, [
            /* tuple */[
              match,
              /* PStr */Block.__(0, [/* :: */[
                    str,
                    /* [] */0
                  ]])
            ],
            /* [] */0
          ]);
        return mk$6(symbol_gloc(void 0), d);
      } else {
        return str;
      }
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(/* Pstr_primitive */Block.__(2, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(/* Pstr_type */Block.__(3, [List.rev(_1)]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(/* Pstr_typext */Block.__(4, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(/* Pstr_exception */Block.__(5, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(/* Pstr_module */Block.__(6, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(/* Pstr_recmodule */Block.__(7, [List.rev(_1)]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(/* Pstr_modtype */Block.__(8, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(/* Pstr_open */Block.__(9, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(/* Pstr_class */Block.__(10, [List.rev(_1)]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(/* Pstr_class_type */Block.__(11, [List.rev(_1)]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(/* Pstr_include */Block.__(12, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkstr(/* Pstr_extension */Block.__(14, [
                    _1,
                    add_docs_attrs(symbol_docs(void 0), _2)
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      mark_symbol_docs(void 0);
      return mkstr(/* Pstr_attribute */Block.__(13, [_1]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$16(symbol_rloc(void 0), _3, symbol_docs(void 0), _2);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmod(/* Pmod_constraint */Block.__(4, [
                    _4,
                    _2
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmod(/* Pmod_functor */Block.__(2, [
                    _1[0],
                    _1[1],
                    _2
                  ]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$14(symbol_rloc(void 0), _4, symbol_docs(void 0), void 0, {
                  txt: _2,
                  loc: rhs_loc(2)
                }, _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _2,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$14(symbol_rloc(void 0), _5, symbol_docs(void 0), void 0, {
                  txt: _3,
                  loc: rhs_loc(3)
                }, _4);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$14(symbol_rloc(void 0), _4, symbol_docs(void 0), get_text(Parsing.symbol_start_pos(void 0)), {
                  txt: _2,
                  loc: rhs_loc(2)
                }, _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmty(/* Pmty_ident */Block.__(0, [{
                      txt: _1,
                      loc: rhs_loc(1)
                    }]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      return mkmty(/* Pmty_signature */Block.__(1, [extra_text(text, 2, _2)]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("sig", 1, "end", 3);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return List.fold_left((function (acc, param) {
                    return mkmty(/* Pmty_functor */Block.__(2, [
                                  param[0],
                                  param[1],
                                  acc
                                ]));
                  }), _4, _2);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmty(/* Pmty_with */Block.__(3, [
                    _1,
                    List.rev(_3)
                  ]));
    }),
  (function (__caml_parser_env) {
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmty(/* Pmty_typeof */Block.__(4, [_4]));
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 1);
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmty(/* Pmty_extension */Block.__(5, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return attr$3(_1, _2);
    }),
  (function (__caml_parser_env) {
      return /* [] */0;
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(text(get_text(Parsing.rhs_start_pos(1))), _2);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(text(get_text(Parsing.rhs_start_pos(1))), /* :: */[
                  _1,
                  _2
                ]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(/* Psig_value */Block.__(0, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(/* Psig_value */Block.__(0, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(/* Psig_type */Block.__(1, [List.rev(_1)]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(/* Psig_typext */Block.__(2, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(/* Psig_exception */Block.__(3, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(/* Psig_module */Block.__(4, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(/* Psig_module */Block.__(4, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(/* Psig_recmodule */Block.__(5, [List.rev(_1)]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(/* Psig_modtype */Block.__(6, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(/* Psig_open */Block.__(7, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(/* Psig_include */Block.__(8, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(/* Psig_class */Block.__(9, [List.rev(_1)]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(/* Psig_class_type */Block.__(10, [List.rev(_1)]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mksig(/* Psig_extension */Block.__(12, [
                    _1,
                    add_docs_attrs(symbol_docs(void 0), _2)
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      mark_symbol_docs(void 0);
      return mksig(/* Psig_attribute */Block.__(11, [_1]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$15(symbol_rloc(void 0), _4, symbol_docs(void 0), _2, {
                  txt: _3,
                  loc: rhs_loc(3)
                });
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$16(symbol_rloc(void 0), _3, symbol_docs(void 0), _2);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 4);
      var _4 = Parsing.peek_val(__caml_parser_env, 2);
      var _6 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmty(/* Pmty_functor */Block.__(2, [
                    {
                      txt: _2,
                      loc: rhs_loc(2)
                    },
                    _4,
                    _6
                  ]));
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkmty(/* Pmty_functor */Block.__(2, [
                    {
                      txt: "*",
                      loc: rhs_loc(1)
                    },
                    void 0,
                    _3
                  ]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$12(symbol_rloc(void 0), _4, symbol_docs(void 0), void 0, {
                  txt: _2,
                  loc: rhs_loc(2)
                }, _3);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$12(symbol_rloc(void 0), _5, symbol_docs(void 0), void 0, {
                  txt: _2,
                  loc: rhs_loc(2)
                }, alias$2(rhs_loc(4), void 0, {
                      txt: _4,
                      loc: rhs_loc(4)
                    }));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _2,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 3);
      var _5 = Parsing.peek_val(__caml_parser_env, 1);
      var _6 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$12(symbol_rloc(void 0), _6, symbol_docs(void 0), void 0, {
                  txt: _3,
                  loc: rhs_loc(3)
                }, _5);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$12(symbol_rloc(void 0), _5, symbol_docs(void 0), get_text(Parsing.symbol_start_pos(void 0)), {
                  txt: _2,
                  loc: rhs_loc(2)
                }, _4);
    }),
  (function (__caml_parser_env) {
      
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$13(symbol_rloc(void 0), _5, symbol_docs(void 0), void 0, _4, {
                  txt: _3,
                  loc: rhs_loc(3)
                });
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _2,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 4);
      var _3 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 2);
      var _5 = Parsing.peek_val(__caml_parser_env, 1);
      var _6 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$18(symbol_rloc(void 0), _6, symbol_docs(void 0), void 0, _2, _3, {
                  txt: _4,
                  loc: rhs_loc(4)
                }, _5);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 4);
      var _3 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 2);
      var _5 = Parsing.peek_val(__caml_parser_env, 1);
      var _6 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$18(symbol_rloc(void 0), _6, symbol_docs(void 0), get_text(Parsing.symbol_start_pos(void 0)), _2, _3, {
                  txt: _4,
                  loc: rhs_loc(4)
                }, _5);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mkclass(/* Pcl_constraint */Block.__(5, [
                    _4,
                    _2
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkclass(/* Pcl_fun */Block.__(2, [
                    _1[0],
                    _1[1],
                    _1[2],
                    _2
                  ]));
    }),
  (function (__caml_parser_env) {
      return /* [] */0;
    }),
  (function (__caml_parser_env) {
      return List.rev(Parsing.peek_val(__caml_parser_env, 1));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkclass(/* Pcl_fun */Block.__(2, [
                    _1[0],
                    _1[1],
                    _1[2],
                    _3
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkclass(/* Pcl_fun */Block.__(2, [
                    _1[0],
                    _1[1],
                    _1[2],
                    _2
                  ]));
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkclass(/* Pcl_apply */Block.__(3, [
                    _1,
                    List.rev(_2)
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      var bindings = List.map((function (lb) {
              if (lb.lb_attributes !== /* [] */0) {
                throw [
                      $$Error$3,
                      /* Not_expecting */Block.__(2, [
                          lb.lb_loc,
                          "item attribute"
                        ])
                    ];
              }
              return mk$17(lb.lb_loc, void 0, void 0, void 0, lb.lb_pattern, lb.lb_expression);
            }), _1.lbs_bindings);
      if (_1.lbs_extension !== void 0) {
        throw [
              $$Error$3,
              /* Not_expecting */Block.__(2, [
                  _1.lbs_loc,
                  "extension"
                ])
            ];
      }
      if (_1.lbs_attributes !== /* [] */0) {
        throw [
              $$Error$3,
              /* Not_expecting */Block.__(2, [
                  _1.lbs_loc,
                  "attributes"
                ])
            ];
      }
      return mkclass(/* Pcl_let */Block.__(4, [
                    _1.lbs_rec,
                    List.rev(bindings),
                    _3
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return attr$5(_1, _2);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkclass(/* Pcl_extension */Block.__(6, [_1]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mkclass(/* Pcl_constr */Block.__(0, [
                    {
                      txt: _4,
                      loc: rhs_loc(4)
                    },
                    List.rev(_2)
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkclass(/* Pcl_constr */Block.__(0, [
                    {
                      txt: _1,
                      loc: rhs_loc(1)
                    },
                    /* [] */0
                  ]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      return mkclass(/* Pcl_structure */Block.__(1, [_2]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("object", 1, "end", 3);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      return mkclass(/* Pcl_constraint */Block.__(5, [
                    _2,
                    _4
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 5);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 1);
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return {
              pcstr_self: _1,
              pcstr_fields: extra_cstr(2, List.rev(_2))
            };
    }),
  (function (__caml_parser_env) {
      return reloc_pat(Parsing.peek_val(__caml_parser_env, 1));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      return mkpat(/* Ppat_constraint */Block.__(10, [
                    _2,
                    _4
                  ]));
    }),
  (function (__caml_parser_env) {
      return ghpat(/* Ppat_any */0);
    }),
  (function (__caml_parser_env) {
      return /* [] */0;
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(/* :: */[
                  _2,
                  Curry._1(Ast_helper_Cf.text, get_text(Parsing.rhs_start_pos(2)))
                ], _1);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcf(_5, symbol_docs(void 0), /* Pcf_inherit */Block.__(0, [
                    _2,
                    _3,
                    _4
                  ]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcf(_3, symbol_docs(void 0), /* Pcf_val */Block.__(1, [_2]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcf(_3, symbol_docs(void 0), /* Pcf_method */Block.__(2, [_2]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcf(_3, symbol_docs(void 0), /* Pcf_constraint */Block.__(3, [_2]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcf(_3, symbol_docs(void 0), /* Pcf_initializer */Block.__(4, [_2]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcf(_2, symbol_docs(void 0), /* Pcf_extension */Block.__(6, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      mark_symbol_docs(void 0);
      return mkcf(void 0, void 0, /* Pcf_attribute */Block.__(5, [_1]));
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 5);
      var _4 = Parsing.peek_val(__caml_parser_env, 2);
      var _6 = Parsing.peek_val(__caml_parser_env, 0);
      if (_1 === /* Override */0) {
        throw Escape_error;
      }
      return /* tuple */[
              {
                txt: _4,
                loc: rhs_loc(4)
              },
              /* Mutable */1,
              /* Cfk_virtual */Block.__(0, [_6])
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              {
                txt: _3,
                loc: rhs_loc(3)
              },
              _2,
              /* Cfk_virtual */Block.__(0, [_5])
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 4);
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              {
                txt: _3,
                loc: rhs_loc(3)
              },
              _2,
              /* Cfk_concrete */Block.__(1, [
                  _1,
                  _5
                ])
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 5);
      var _2 = Parsing.peek_val(__caml_parser_env, 4);
      var _3 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 2);
      var _6 = Parsing.peek_val(__caml_parser_env, 0);
      var e = mkexp_constraint(_6, _4);
      return /* tuple */[
              {
                txt: _3,
                loc: rhs_loc(3)
              },
              _2,
              /* Cfk_concrete */Block.__(1, [
                  _1,
                  e
                ])
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 5);
      var _4 = Parsing.peek_val(__caml_parser_env, 2);
      var _6 = Parsing.peek_val(__caml_parser_env, 0);
      if (_1 === /* Override */0) {
        throw Escape_error;
      }
      return /* tuple */[
              {
                txt: _4,
                loc: rhs_loc(4)
              },
              /* Private */0,
              /* Cfk_virtual */Block.__(0, [_6])
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 5);
      var _3 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 2);
      var _6 = Parsing.peek_val(__caml_parser_env, 0);
      if (_1 === /* Override */0) {
        throw Escape_error;
      }
      return /* tuple */[
              {
                txt: _4,
                loc: rhs_loc(4)
              },
              _3,
              /* Cfk_virtual */Block.__(0, [_6])
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 3);
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              {
                txt: _3,
                loc: rhs_loc(3)
              },
              _2,
              /* Cfk_concrete */Block.__(1, [
                  _1,
                  ghexp(/* Pexp_poly */Block.__(28, [
                          _4,
                          void 0
                        ]))
                ])
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 6);
      var _2 = Parsing.peek_val(__caml_parser_env, 5);
      var _3 = Parsing.peek_val(__caml_parser_env, 4);
      var _5 = Parsing.peek_val(__caml_parser_env, 2);
      var _7 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              {
                txt: _3,
                loc: rhs_loc(3)
              },
              _2,
              /* Cfk_concrete */Block.__(1, [
                  _1,
                  ghexp(/* Pexp_poly */Block.__(28, [
                          _7,
                          _5
                        ]))
                ])
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 9);
      var _2 = Parsing.peek_val(__caml_parser_env, 8);
      var _3 = Parsing.peek_val(__caml_parser_env, 7);
      var _6 = Parsing.peek_val(__caml_parser_env, 4);
      var _8 = Parsing.peek_val(__caml_parser_env, 2);
      var _10 = Parsing.peek_val(__caml_parser_env, 0);
      var match = wrap_type_annotation(_6, _8, _10);
      return /* tuple */[
              {
                txt: _3,
                loc: rhs_loc(3)
              },
              _2,
              /* Cfk_concrete */Block.__(1, [
                  _1,
                  ghexp(/* Pexp_poly */Block.__(28, [
                          match[0],
                          match[1]
                        ]))
                ])
            ];
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 4);
      var _4 = Parsing.peek_val(__caml_parser_env, 2);
      var _6 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcty(/* Pcty_arrow */Block.__(2, [
                    "?" + _2,
                    mkoption(_4),
                    _6
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 3);
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcty(/* Pcty_arrow */Block.__(2, [
                    "?" + _1,
                    mkoption(_2),
                    _4
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 4);
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcty(/* Pcty_arrow */Block.__(2, [
                    _1,
                    _3,
                    _5
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcty(/* Pcty_arrow */Block.__(2, [
                    "",
                    _1,
                    _3
                  ]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcty(/* Pcty_constr */Block.__(0, [
                    {
                      txt: _4,
                      loc: rhs_loc(4)
                    },
                    List.rev(_2)
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcty(/* Pcty_constr */Block.__(0, [
                    {
                      txt: _1,
                      loc: rhs_loc(1)
                    },
                    /* [] */0
                  ]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      return mkcty(/* Pcty_signature */Block.__(1, [_2]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("object", 1, "end", 3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return attr$6(_1, _2);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkcty(/* Pcty_extension */Block.__(3, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return {
              pcsig_self: _1,
              pcsig_fields: extra_csig(2, List.rev(_2))
            };
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 1);
    }),
  (function (__caml_parser_env) {
      return mktyp(/* Ptyp_any */0);
    }),
  (function (__caml_parser_env) {
      return /* [] */0;
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Pervasives.$at(/* :: */[
                  _2,
                  Curry._1(Ast_helper_Ctf.text, get_text(Parsing.rhs_start_pos(2)))
                ], _1);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkctf(_3, symbol_docs(void 0), /* Pctf_inherit */Block.__(0, [_2]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkctf(_3, symbol_docs(void 0), /* Pctf_val */Block.__(1, [_2]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 4);
      var _3 = Parsing.peek_val(__caml_parser_env, 3);
      var _5 = Parsing.peek_val(__caml_parser_env, 1);
      var _6 = Parsing.peek_val(__caml_parser_env, 0);
      return mkctf(_6, symbol_docs(void 0), /* Pctf_method */Block.__(2, [/* tuple */[
                      _3,
                      _2[0],
                      _2[1],
                      _5
                    ]]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkctf(_3, symbol_docs(void 0), /* Pctf_constraint */Block.__(3, [_2]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkctf(_2, symbol_docs(void 0), /* Pctf_extension */Block.__(5, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      mark_symbol_docs(void 0);
      return mkctf(void 0, void 0, /* Pctf_attribute */Block.__(4, [_1]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              _3,
              _2,
              /* Virtual */0,
              _5
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              _3,
              /* Mutable */1,
              _2,
              _5
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              _1,
              /* Immutable */0,
              /* Concrete */1,
              _3
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              _1,
              _3,
              symbol_rloc(void 0)
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              _1,
              _3
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _2,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 5);
      var _3 = Parsing.peek_val(__caml_parser_env, 4);
      var _4 = Parsing.peek_val(__caml_parser_env, 3);
      var _6 = Parsing.peek_val(__caml_parser_env, 1);
      var _7 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$18(symbol_rloc(void 0), _7, symbol_docs(void 0), void 0, _2, _3, {
                  txt: _4,
                  loc: rhs_loc(4)
                }, _6);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 5);
      var _3 = Parsing.peek_val(__caml_parser_env, 4);
      var _4 = Parsing.peek_val(__caml_parser_env, 3);
      var _6 = Parsing.peek_val(__caml_parser_env, 1);
      var _7 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$18(symbol_rloc(void 0), _7, symbol_docs(void 0), get_text(Parsing.symbol_start_pos(void 0)), _2, _3, {
                  txt: _4,
                  loc: rhs_loc(4)
                }, _6);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _2,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 5);
      var _4 = Parsing.peek_val(__caml_parser_env, 4);
      var _5 = Parsing.peek_val(__caml_parser_env, 3);
      var _7 = Parsing.peek_val(__caml_parser_env, 1);
      var _8 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$18(symbol_rloc(void 0), _8, symbol_docs(void 0), void 0, _3, _4, {
                  txt: _5,
                  loc: rhs_loc(5)
                }, _7);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 5);
      var _3 = Parsing.peek_val(__caml_parser_env, 4);
      var _4 = Parsing.peek_val(__caml_parser_env, 3);
      var _6 = Parsing.peek_val(__caml_parser_env, 1);
      var _7 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$18(symbol_rloc(void 0), _7, symbol_docs(void 0), get_text(Parsing.symbol_start_pos(void 0)), _2, _3, {
                  txt: _4,
                  loc: rhs_loc(4)
                }, _6);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return reloc_exp(Parsing.peek_val(__caml_parser_env, 1));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_sequence */Block.__(16, [
                    _1,
                    _3
                  ]));
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      return /* tuple */[
              "?" + _3[0],
              _4,
              _3[1]
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              "?" + _2[0],
              void 0,
              _2[1]
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 4);
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      return /* tuple */[
              "?" + _1,
              _4,
              _3
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              "?" + _1,
              void 0,
              _2
            ];
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      return /* tuple */[
              _3[0],
              void 0,
              _3[1]
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              _2[0],
              void 0,
              _2[1]
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              _1,
              void 0,
              _2
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              "",
              void 0,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(/* Ppat_var */Block.__(0, [{
                      txt: _1,
                      loc: rhs_loc(1)
                    }]));
    }),
  (function (__caml_parser_env) {
      return mkpat(/* Ppat_any */0);
    }),
  (function (__caml_parser_env) {
      
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              _1[0],
              mkpat(/* Ppat_constraint */Block.__(10, [
                      _1[1],
                      _3
                    ]))
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              _1,
              mkpat(/* Ppat_var */Block.__(0, [{
                        txt: _1,
                        loc: rhs_loc(1)
                      }]))
            ];
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(/* Ppat_constraint */Block.__(10, [
                    _1,
                    _3
                  ]));
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_apply */Block.__(5, [
                    _1,
                    List.rev(_2)
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      var bindings = List.map((function (lb) {
              if (lb.lb_attributes !== /* [] */0) {
                throw [
                      $$Error$3,
                      /* Not_expecting */Block.__(2, [
                          lb.lb_loc,
                          "item attribute"
                        ])
                    ];
              }
              return mk$17(lb.lb_loc, void 0, void 0, void 0, lb.lb_pattern, lb.lb_expression);
            }), _1.lbs_bindings);
      var d_000 = _1.lbs_rec;
      var d_001 = List.rev(bindings);
      var d = /* Pexp_let */Block.__(2, [
          d_000,
          d_001,
          _3
        ]);
      return wrap_exp_attrs(mkexp(d), /* tuple */[
                  _1.lbs_extension,
                  _1.lbs_attributes
                ]);
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 4);
      var _4 = Parsing.peek_val(__caml_parser_env, 3);
      var _5 = Parsing.peek_val(__caml_parser_env, 2);
      var _7 = Parsing.peek_val(__caml_parser_env, 0);
      var d_000 = {
        txt: _4,
        loc: rhs_loc(4)
      };
      var d = /* Pexp_letmodule */Block.__(25, [
          d_000,
          _5,
          _7
        ]);
      return wrap_exp_attrs(mkexp(d), _3);
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 4);
      var _4 = Parsing.peek_val(__caml_parser_env, 3);
      var _5 = Parsing.peek_val(__caml_parser_env, 2);
      var _7 = Parsing.peek_val(__caml_parser_env, 0);
      var d_001 = {
        txt: _5,
        loc: rhs_loc(5)
      };
      var d = /* Pexp_open */Block.__(32, [
          _3,
          d_001,
          _7
        ]);
      return wrap_exp_attrs(mkexp(d), _4);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      var d = /* Pexp_function */Block.__(3, [List.rev(_4)]);
      return wrap_exp_attrs(mkexp(d), _2);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return wrap_exp_attrs(mkexp(/* Pexp_fun */Block.__(4, [
                        _3[0],
                        _3[1],
                        _3[2],
                        _4
                      ])), _2);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 5);
      var _5 = Parsing.peek_val(__caml_parser_env, 2);
      var _7 = Parsing.peek_val(__caml_parser_env, 0);
      return wrap_exp_attrs(mkexp(/* Pexp_newtype */Block.__(30, [
                        _5,
                        _7
                      ])), _2);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 4);
      var _3 = Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 1);
      var _6 = Parsing.peek_val(__caml_parser_env, 0);
      var d_001 = List.rev(_6);
      var d = /* Pexp_match */Block.__(6, [
          _3,
          d_001
        ]);
      return wrap_exp_attrs(mkexp(d), _2);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 4);
      var _3 = Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 1);
      var _6 = Parsing.peek_val(__caml_parser_env, 0);
      var d_001 = List.rev(_6);
      var d = /* Pexp_try */Block.__(7, [
          _3,
          d_001
        ]);
      return wrap_exp_attrs(mkexp(d), _2);
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 2);
      throw Escape_error;
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_tuple */Block.__(8, [List.rev(_1)]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_construct */Block.__(9, [
                    {
                      txt: _1,
                      loc: rhs_loc(1)
                    },
                    _2
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_variant */Block.__(10, [
                    _1,
                    _2
                  ]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 5);
      var _3 = Parsing.peek_val(__caml_parser_env, 4);
      var _5 = Parsing.peek_val(__caml_parser_env, 2);
      var _7 = Parsing.peek_val(__caml_parser_env, 0);
      return wrap_exp_attrs(mkexp(/* Pexp_ifthenelse */Block.__(15, [
                        _3,
                        _5,
                        _7
                      ])), _2);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return wrap_exp_attrs(mkexp(/* Pexp_ifthenelse */Block.__(15, [
                        _3,
                        _5,
                        void 0
                      ])), _2);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 4);
      var _3 = Parsing.peek_val(__caml_parser_env, 3);
      var _5 = Parsing.peek_val(__caml_parser_env, 1);
      return wrap_exp_attrs(mkexp(/* Pexp_while */Block.__(17, [
                        _3,
                        _5
                      ])), _2);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 8);
      var _3 = Parsing.peek_val(__caml_parser_env, 7);
      var _5 = Parsing.peek_val(__caml_parser_env, 5);
      var _6 = Parsing.peek_val(__caml_parser_env, 4);
      var _7 = Parsing.peek_val(__caml_parser_env, 3);
      var _9 = Parsing.peek_val(__caml_parser_env, 1);
      return wrap_exp_attrs(mkexp(/* Pexp_for */Block.__(18, [
                        _3,
                        _5,
                        _7,
                        _6,
                        _9
                      ])), _2);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp_cons(rhs_loc(2), ghexp(/* Pexp_tuple */Block.__(8, [/* :: */[
                          _1,
                          /* :: */[
                            _3,
                            /* [] */0
                          ]
                        ]])), symbol_rloc(void 0));
    }),
  (function (__caml_parser_env) {
      var _5 = Parsing.peek_val(__caml_parser_env, 3);
      var _7 = Parsing.peek_val(__caml_parser_env, 1);
      return mkexp_cons(rhs_loc(2), ghexp(/* Pexp_tuple */Block.__(8, [/* :: */[
                          _5,
                          /* :: */[
                            _7,
                            /* [] */0
                          ]
                        ]])), symbol_rloc(void 0));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, _2, _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, _2, _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, _2, _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, _2, _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, _2, _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "+", _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "+.", _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "+=", _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "-", _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "-.", _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "*", _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "%", _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "=", _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "<", _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, ">", _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "or", _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "||", _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "&", _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, "&&", _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, ":=", _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      var match = _2.pexp_desc;
      var exit = 0;
      switch (_1) {
        case "-" :
            if (match.tag === /* Pexp_constant */1) {
              var match$1 = match[0];
              switch (match$1.tag | 0) {
                case /* Const_int */0 :
                    return mkexp(/* Pexp_constant */Block.__(1, [/* Const_int */Block.__(0, [-match$1[0] | 0])]));
                case /* Const_int32 */4 :
                    return mkexp(/* Pexp_constant */Block.__(1, [/* Const_int32 */Block.__(4, [-match$1[0] | 0])]));
                case /* Const_int64 */5 :
                    return mkexp(/* Pexp_constant */Block.__(1, [/* Const_int64 */Block.__(5, [Caml_int64.neg(match$1[0])])]));
                case /* Const_nativeint */6 :
                    return mkexp(/* Pexp_constant */Block.__(1, [/* Const_nativeint */Block.__(6, [-match$1[0]])]));
                default:
                  exit = 2;
              }
            } else {
              exit = 2;
            }
            break;
        case "-." :
            exit = 2;
            break;
        default:
          
      }
      if (exit === 2 && match.tag === /* Pexp_constant */1) {
        var match$2 = match[0];
        if (match$2.tag === /* Const_float */3) {
          return mkexp(/* Pexp_constant */Block.__(1, [/* Const_float */Block.__(3, [neg_float_string(match$2[0])])]));
        }
        
      }
      return mkexp(/* Pexp_apply */Block.__(5, [
                    mkoperator("~" + _1, 1),
                    /* :: */[
                      /* tuple */[
                        "",
                        _2
                      ],
                      /* [] */0
                    ]
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      var desc = _2.pexp_desc;
      var exit = 0;
      switch (_1) {
        case "+" :
            if (desc.tag === /* Pexp_constant */1) {
              switch (desc[0].tag | 0) {
                case /* Const_char */1 :
                case /* Const_string */2 :
                case /* Const_float */3 :
                    exit = 2;
                    break;
                default:
                  return mkexp(desc);
              }
            } else {
              exit = 2;
            }
            break;
        case "+." :
            exit = 2;
            break;
        default:
          
      }
      if (exit === 2 && desc.tag === /* Pexp_constant */1 && desc[0].tag === /* Const_float */3) {
        return mkexp(desc);
      }
      return mkexp(/* Pexp_apply */Block.__(5, [
                    mkoperator("~" + _1, 1),
                    /* :: */[
                      /* tuple */[
                        "",
                        _2
                      ],
                      /* [] */0
                    ]
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 4);
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_setfield */Block.__(13, [
                    _1,
                    {
                      txt: _3,
                      loc: rhs_loc(3)
                    },
                    _5
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 6);
      var _4 = Parsing.peek_val(__caml_parser_env, 3);
      var _7 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_apply */Block.__(5, [
                    ghexp(/* Pexp_ident */Block.__(0, [array_function("Array", "set")])),
                    /* :: */[
                      /* tuple */[
                        "",
                        _1
                      ],
                      /* :: */[
                        /* tuple */[
                          "",
                          _4
                        ],
                        /* :: */[
                          /* tuple */[
                            "",
                            _7
                          ],
                          /* [] */0
                        ]
                      ]
                    ]
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 6);
      var _4 = Parsing.peek_val(__caml_parser_env, 3);
      var _7 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_apply */Block.__(5, [
                    ghexp(/* Pexp_ident */Block.__(0, [array_function("String", "set")])),
                    /* :: */[
                      /* tuple */[
                        "",
                        _1
                      ],
                      /* :: */[
                        /* tuple */[
                          "",
                          _4
                        ],
                        /* :: */[
                          /* tuple */[
                            "",
                            _7
                          ],
                          /* [] */0
                        ]
                      ]
                    ]
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 6);
      var _4 = Parsing.peek_val(__caml_parser_env, 3);
      var _7 = Parsing.peek_val(__caml_parser_env, 0);
      var set = fast.contents ? "unsafe_set" : "set";
      var coords = bigarray_untuplify(_4);
      if (coords) {
        var match = coords[1];
        var c1 = coords[0];
        if (!match) {
          return mkexp(/* Pexp_apply */Block.__(5, [
                        ghexp(/* Pexp_ident */Block.__(0, [bigarray_function("Array1", set)])),
                        /* :: */[
                          /* tuple */[
                            "",
                            _1
                          ],
                          /* :: */[
                            /* tuple */[
                              "",
                              c1
                            ],
                            /* :: */[
                              /* tuple */[
                                "",
                                _7
                              ],
                              /* [] */0
                            ]
                          ]
                        ]
                      ]));
        }
        var match$1 = match[1];
        var c2 = match[0];
        if (!match$1) {
          return mkexp(/* Pexp_apply */Block.__(5, [
                        ghexp(/* Pexp_ident */Block.__(0, [bigarray_function("Array2", set)])),
                        /* :: */[
                          /* tuple */[
                            "",
                            _1
                          ],
                          /* :: */[
                            /* tuple */[
                              "",
                              c1
                            ],
                            /* :: */[
                              /* tuple */[
                                "",
                                c2
                              ],
                              /* :: */[
                                /* tuple */[
                                  "",
                                  _7
                                ],
                                /* [] */0
                              ]
                            ]
                          ]
                        ]
                      ]));
        }
        if (!match$1[1]) {
          return mkexp(/* Pexp_apply */Block.__(5, [
                        ghexp(/* Pexp_ident */Block.__(0, [bigarray_function("Array3", set)])),
                        /* :: */[
                          /* tuple */[
                            "",
                            _1
                          ],
                          /* :: */[
                            /* tuple */[
                              "",
                              c1
                            ],
                            /* :: */[
                              /* tuple */[
                                "",
                                c2
                              ],
                              /* :: */[
                                /* tuple */[
                                  "",
                                  match$1[0]
                                ],
                                /* :: */[
                                  /* tuple */[
                                    "",
                                    _7
                                  ],
                                  /* [] */0
                                ]
                              ]
                            ]
                          ]
                        ]
                      ]));
        }
        
      }
      return mkexp(/* Pexp_apply */Block.__(5, [
                    ghexp(/* Pexp_ident */Block.__(0, [bigarray_function("Genarray", "set")])),
                    /* :: */[
                      /* tuple */[
                        "",
                        _1
                      ],
                      /* :: */[
                        /* tuple */[
                          "",
                          ghexp(/* Pexp_array */Block.__(14, [coords]))
                        ],
                        /* :: */[
                          /* tuple */[
                            "",
                            _7
                          ],
                          /* [] */0
                        ]
                      ]
                    ]
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_setinstvar */Block.__(23, [
                    {
                      txt: _1,
                      loc: rhs_loc(1)
                    },
                    _3
                  ]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return wrap_exp_attrs(mkexp(/* Pexp_assert */Block.__(26, [_3])), _2);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return wrap_exp_attrs(mkexp(/* Pexp_lazy */Block.__(27, [_3])), _2);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      return wrap_exp_attrs(mkexp(/* Pexp_object */Block.__(29, [_3])), _2);
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("object", 1, "end", 4);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return Curry._2(Ast_helper_Exp.attr, _1, _2);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_ident */Block.__(0, [{
                      txt: _1,
                      loc: rhs_loc(1)
                    }]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_constant */Block.__(1, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_construct */Block.__(9, [
                    {
                      txt: _1,
                      loc: rhs_loc(1)
                    },
                    void 0
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_variant */Block.__(10, [
                    _1,
                    void 0
                  ]));
    }),
  (function (__caml_parser_env) {
      return reloc_exp(Parsing.peek_val(__caml_parser_env, 1));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 3);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      return wrap_exp_attrs(reloc_exp(_3), _2);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var d_000 = {
        txt: /* Lident */Block.__(0, ["()"]),
        loc: symbol_rloc(void 0)
      };
      var d = /* Pexp_construct */Block.__(9, [
          d_000,
          void 0
        ]);
      return wrap_exp_attrs(mkexp(d), _2);
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("begin", 1, "end", 3);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      return mkexp_constraint(_2, _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_field */Block.__(12, [
                    _1,
                    {
                      txt: _3,
                      loc: rhs_loc(3)
                    }
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 4);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(/* Pexp_open */Block.__(32, [
                    /* Fresh */1,
                    {
                      txt: _1,
                      loc: rhs_loc(1)
                    },
                    _4
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 4);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 3, ")", 5);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 4);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(/* Pexp_apply */Block.__(5, [
                    ghexp(/* Pexp_ident */Block.__(0, [array_function("Array", "get")])),
                    /* :: */[
                      /* tuple */[
                        "",
                        _1
                      ],
                      /* :: */[
                        /* tuple */[
                          "",
                          _4
                        ],
                        /* [] */0
                      ]
                    ]
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 4);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 3, ")", 5);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 4);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(/* Pexp_apply */Block.__(5, [
                    ghexp(/* Pexp_ident */Block.__(0, [array_function("String", "get")])),
                    /* :: */[
                      /* tuple */[
                        "",
                        _1
                      ],
                      /* :: */[
                        /* tuple */[
                          "",
                          _4
                        ],
                        /* [] */0
                      ]
                    ]
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 4);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("[", 3, "]", 5);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 4);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      var get = fast.contents ? "unsafe_get" : "get";
      var coords = bigarray_untuplify(_4);
      if (coords) {
        var match = coords[1];
        var c1 = coords[0];
        if (!match) {
          return mkexp(/* Pexp_apply */Block.__(5, [
                        ghexp(/* Pexp_ident */Block.__(0, [bigarray_function("Array1", get)])),
                        /* :: */[
                          /* tuple */[
                            "",
                            _1
                          ],
                          /* :: */[
                            /* tuple */[
                              "",
                              c1
                            ],
                            /* [] */0
                          ]
                        ]
                      ]));
        }
        var match$1 = match[1];
        var c2 = match[0];
        if (!match$1) {
          return mkexp(/* Pexp_apply */Block.__(5, [
                        ghexp(/* Pexp_ident */Block.__(0, [bigarray_function("Array2", get)])),
                        /* :: */[
                          /* tuple */[
                            "",
                            _1
                          ],
                          /* :: */[
                            /* tuple */[
                              "",
                              c1
                            ],
                            /* :: */[
                              /* tuple */[
                                "",
                                c2
                              ],
                              /* [] */0
                            ]
                          ]
                        ]
                      ]));
        }
        if (!match$1[1]) {
          return mkexp(/* Pexp_apply */Block.__(5, [
                        ghexp(/* Pexp_ident */Block.__(0, [bigarray_function("Array3", get)])),
                        /* :: */[
                          /* tuple */[
                            "",
                            _1
                          ],
                          /* :: */[
                            /* tuple */[
                              "",
                              c1
                            ],
                            /* :: */[
                              /* tuple */[
                                "",
                                c2
                              ],
                              /* :: */[
                                /* tuple */[
                                  "",
                                  match$1[0]
                                ],
                                /* [] */0
                              ]
                            ]
                          ]
                        ]
                      ]));
        }
        
      }
      return mkexp(/* Pexp_apply */Block.__(5, [
                    ghexp(/* Pexp_ident */Block.__(0, [bigarray_function("Genarray", "get")])),
                    /* :: */[
                      /* tuple */[
                        "",
                        _1
                      ],
                      /* :: */[
                        /* tuple */[
                          "",
                          ghexp(/* Pexp_array */Block.__(14, [coords]))
                        ],
                        /* [] */0
                      ]
                    ]
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 4);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("{", 3, "}", 5);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(/* Pexp_record */Block.__(11, [
                    _2[1],
                    _2[0]
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("{", 1, "}", 3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 4);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      var rec_exp = mkexp(/* Pexp_record */Block.__(11, [
              _4[1],
              _4[0]
            ]));
      return mkexp(/* Pexp_open */Block.__(32, [
                    /* Fresh */1,
                    {
                      txt: _1,
                      loc: rhs_loc(1)
                    },
                    rec_exp
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 4);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("{", 3, "}", 5);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(/* Pexp_array */Block.__(14, [List.rev(_2)]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("[|", 1, "|]", 4);
    }),
  (function (__caml_parser_env) {
      return mkexp(/* Pexp_array */Block.__(14, [/* [] */0]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 5);
      var _4 = Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(/* Pexp_open */Block.__(32, [
                    /* Fresh */1,
                    {
                      txt: _1,
                      loc: rhs_loc(1)
                    },
                    mkexp(/* Pexp_array */Block.__(14, [List.rev(_4)]))
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 5);
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("[|", 3, "|]", 6);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return reloc_exp(mktailexp(rhs_loc(4), List.rev(_2)));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("[", 1, "]", 4);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 5);
      var _4 = Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      var list_exp = reloc_exp(mktailexp(rhs_loc(6), List.rev(_4)));
      return mkexp(/* Pexp_open */Block.__(32, [
                    /* Fresh */1,
                    {
                      txt: _1,
                      loc: rhs_loc(1)
                    },
                    list_exp
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 5);
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("[", 3, "]", 6);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_apply */Block.__(5, [
                    mkoperator(_1, 1),
                    /* :: */[
                      /* tuple */[
                        "",
                        _2
                      ],
                      /* [] */0
                    ]
                  ]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_apply */Block.__(5, [
                    mkoperator("!", 1),
                    /* :: */[
                      /* tuple */[
                        "",
                        _2
                      ],
                      /* [] */0
                    ]
                  ]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      var d = /* Pexp_new */Block.__(22, [{
            txt: _3,
            loc: rhs_loc(3)
          }]);
      return wrap_exp_attrs(mkexp(d), _2);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(/* Pexp_override */Block.__(24, [List.rev(_2)]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("{<", 1, ">}", 4);
    }),
  (function (__caml_parser_env) {
      return mkexp(/* Pexp_override */Block.__(24, [/* [] */0]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 5);
      var _4 = Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(/* Pexp_open */Block.__(32, [
                    /* Fresh */1,
                    {
                      txt: _1,
                      loc: rhs_loc(1)
                    },
                    mkexp(/* Pexp_override */Block.__(24, [List.rev(_4)]))
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 5);
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("{<", 3, ">}", 6);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_send */Block.__(21, [
                    _1,
                    _3
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkinfix(_1, _2, _3);
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(/* Pexp_pack */Block.__(31, [_3]));
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 3);
      var _5 = Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(/* Pexp_constraint */Block.__(19, [
                    ghexp(/* Pexp_pack */Block.__(31, [_3])),
                    ghtyp(/* Ptyp_package */Block.__(9, [_5]))
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 2);
      return unclosed("(", 1, ")", 5);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 7);
      var _5 = Parsing.peek_val(__caml_parser_env, 3);
      var _7 = Parsing.peek_val(__caml_parser_env, 1);
      return mkexp(/* Pexp_open */Block.__(32, [
                    /* Fresh */1,
                    {
                      txt: _1,
                      loc: rhs_loc(1)
                    },
                    mkexp(/* Pexp_constraint */Block.__(19, [
                            ghexp(/* Pexp_pack */Block.__(31, [_5])),
                            ghtyp(/* Ptyp_package */Block.__(9, [_7]))
                          ]))
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 6);
      Parsing.peek_val(__caml_parser_env, 2);
      return unclosed("(", 3, ")", 7);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_extension */Block.__(33, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _2,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              "",
              _1
            ];
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              _1,
              _2
            ];
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              "?" + _2[0],
              _2[1]
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              "?" + _1,
              _2
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              _1,
              mkexp(/* Pexp_ident */Block.__(0, [{
                        txt: /* Lident */Block.__(0, [_1]),
                        loc: rhs_loc(1)
                      }]))
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              _2
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              mkpatvar(_1, 1),
              _2
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 6);
      var _3 = Parsing.peek_val(__caml_parser_env, 4);
      var _5 = Parsing.peek_val(__caml_parser_env, 2);
      var _7 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              ghpat(/* Ppat_constraint */Block.__(10, [
                      mkpatvar(_1, 1),
                      ghtyp(/* Ptyp_poly */Block.__(8, [
                              List.rev(_3),
                              _5
                            ]))
                    ])),
              _7
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 7);
      var _4 = Parsing.peek_val(__caml_parser_env, 4);
      var _6 = Parsing.peek_val(__caml_parser_env, 2);
      var _8 = Parsing.peek_val(__caml_parser_env, 0);
      var match = wrap_type_annotation(_4, _6, _8);
      return /* tuple */[
              ghpat(/* Ppat_constraint */Block.__(10, [
                      mkpatvar(_1, 1),
                      match[1]
                    ])),
              match[0]
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              _1,
              _3
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 4);
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              ghpat(/* Ppat_constraint */Block.__(10, [
                      _1,
                      _3
                    ])),
              _5
            ];
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return {
              lbs_bindings: /* :: */[
                _2,
                _1.lbs_bindings
              ],
              lbs_rec: _1.lbs_rec,
              lbs_extension: _1.lbs_extension,
              lbs_attributes: _1.lbs_attributes,
              lbs_loc: _1.lbs_loc
            };
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      var lb = mklb(_4, _5);
      return {
              lbs_bindings: /* :: */[
                lb,
                /* [] */0
              ],
              lbs_rec: _3,
              lbs_extension: _2[0],
              lbs_attributes: _2[1],
              lbs_loc: symbol_rloc(void 0)
            };
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mklb(_2, _3);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp_constraint(_3, _1);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return ghexp(/* Pexp_fun */Block.__(4, [
                    _1[0],
                    _1[1],
                    _1[2],
                    _2
                  ]));
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_newtype */Block.__(30, [
                    _3,
                    _5
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _3,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return Curry._3(Ast_helper_Exp.$$case, _1, void 0, _3);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 4);
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return Curry._3(Ast_helper_Exp.$$case, _1, _3, _5);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return ghexp(/* Pexp_fun */Block.__(4, [
                    _1[0],
                    _1[1],
                    _1[2],
                    _2
                  ]));
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mkexp(/* Pexp_newtype */Block.__(30, [
                    _3,
                    _5
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _3,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _3,
              /* :: */[
                _1,
                /* [] */0
              ]
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              _1,
              _3
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              void 0,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              _3
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              {
                txt: _1,
                loc: rhs_loc(1)
              },
              _3
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              {
                txt: _1,
                loc: rhs_loc(1)
              },
              exp_of_label(_1, 1)
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              /* tuple */[
                {
                  txt: _1,
                  loc: rhs_loc(1)
                },
                _3
              ],
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 4);
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              /* tuple */[
                {
                  txt: _3,
                  loc: rhs_loc(3)
                },
                _5
              ],
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _3,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              _2,
              void 0
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              _2,
              _4
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              void 0,
              _2
            ];
    }),
  (function (__caml_parser_env) {
      throw Escape_error;
    }),
  (function (__caml_parser_env) {
      throw Escape_error;
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(/* Ppat_alias */Block.__(1, [
                    _1,
                    {
                      txt: _3,
                      loc: rhs_loc(3)
                    }
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 2);
      return expecting(3, "identifier");
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(/* Ppat_tuple */Block.__(4, [List.rev(_1)]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(/* Ppat_construct */Block.__(5, [
                    {
                      txt: _1,
                      loc: rhs_loc(1)
                    },
                    _2
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(/* Ppat_variant */Block.__(6, [
                    _1,
                    _2
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat_cons(rhs_loc(2), ghpat(/* Ppat_tuple */Block.__(4, [/* :: */[
                          _1,
                          /* :: */[
                            _3,
                            /* [] */0
                          ]
                        ]])), symbol_rloc(void 0));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 2);
      return expecting(3, "pattern");
    }),
  (function (__caml_parser_env) {
      var _5 = Parsing.peek_val(__caml_parser_env, 3);
      var _7 = Parsing.peek_val(__caml_parser_env, 1);
      return mkpat_cons(rhs_loc(2), ghpat(/* Ppat_tuple */Block.__(4, [/* :: */[
                          _5,
                          /* :: */[
                            _7,
                            /* [] */0
                          ]
                        ]])), symbol_rloc(void 0));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 4, ")", 8);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(/* Ppat_or */Block.__(9, [
                    _1,
                    _3
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 2);
      return expecting(3, "pattern");
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(/* Ppat_lazy */Block.__(12, [_2]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(/* Ppat_exception */Block.__(14, [_2]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return attr$1(_1, _2);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(/* Ppat_var */Block.__(0, [{
                      txt: _1,
                      loc: rhs_loc(1)
                    }]));
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return mkpat(/* Ppat_any */0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(/* Ppat_constant */Block.__(2, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(/* Ppat_interval */Block.__(3, [
                    _1,
                    _3
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(/* Ppat_construct */Block.__(5, [
                    {
                      txt: _1,
                      loc: rhs_loc(1)
                    },
                    void 0
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(/* Ppat_variant */Block.__(6, [
                    _1,
                    void 0
                  ]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(/* Ppat_type */Block.__(11, [{
                      txt: _2,
                      loc: rhs_loc(2)
                    }]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      return mkpat(/* Ppat_record */Block.__(7, [
                    _2[0],
                    _2[1]
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("{", 1, "}", 3);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return reloc_pat(mktailpat(rhs_loc(4), List.rev(_2)));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("[", 1, "]", 4);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return mkpat(/* Ppat_array */Block.__(8, [List.rev(_2)]));
    }),
  (function (__caml_parser_env) {
      return mkpat(/* Ppat_array */Block.__(8, [/* [] */0]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 2);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("[|", 1, "|]", 4);
    }),
  (function (__caml_parser_env) {
      return reloc_pat(Parsing.peek_val(__caml_parser_env, 1));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 3);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      return mkpat(/* Ppat_constraint */Block.__(10, [
                    _2,
                    _4
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 5);
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 2);
      return expecting(4, "type");
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      return mkpat(/* Ppat_unpack */Block.__(13, [{
                      txt: _3,
                      loc: rhs_loc(3)
                    }]));
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 3);
      var _5 = Parsing.peek_val(__caml_parser_env, 1);
      return mkpat(/* Ppat_constraint */Block.__(10, [
                    mkpat(/* Ppat_unpack */Block.__(13, [{
                              txt: _3,
                              loc: rhs_loc(3)
                            }])),
                    ghtyp(/* Ptyp_package */Block.__(9, [_5]))
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 6);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mkpat(/* Ppat_extension */Block.__(15, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _3,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _3,
              /* :: */[
                _1,
                /* [] */0
              ]
            ];
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 2);
      return expecting(3, "pattern");
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _3,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              /* :: */[
                _1,
                /* [] */0
              ],
              /* Closed */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      return /* tuple */[
              /* :: */[
                _1,
                /* [] */0
              ],
              /* Closed */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 3);
      Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              /* :: */[
                _1,
                /* [] */0
              ],
              /* Open */1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              /* :: */[
                _1,
                _3[0]
              ],
              _3[1]
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              {
                txt: _1,
                loc: rhs_loc(1)
              },
              _3
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              {
                txt: _1,
                loc: rhs_loc(1)
              },
              pat_of_label(_1, 1)
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$11(symbol_rloc(void 0), _5, symbol_docs(void 0), void 0, {
                  txt: _2,
                  loc: rhs_loc(2)
                }, _4);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1[0],
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1[0],
              _2
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 5);
      var _4 = Parsing.peek_val(__caml_parser_env, 3);
      var _6 = Parsing.peek_val(__caml_parser_env, 1);
      var _7 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$11(symbol_rloc(void 0), _7, symbol_docs(void 0), _6, {
                  txt: _2,
                  loc: rhs_loc(2)
                }, _4);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _2,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 5);
      var _3 = Parsing.peek_val(__caml_parser_env, 4);
      var _4 = Parsing.peek_val(__caml_parser_env, 3);
      var _5 = Parsing.peek_val(__caml_parser_env, 2);
      var _6 = Parsing.peek_val(__caml_parser_env, 1);
      var _7 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$19(symbol_rloc(void 0), add_nonrec(_2, _7, 2), symbol_docs(void 0), void 0, _3, List.rev(_6), _5[0], _5[1], _5[2], {
                  txt: _4,
                  loc: rhs_loc(4)
                });
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 4);
      var _3 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 2);
      var _5 = Parsing.peek_val(__caml_parser_env, 1);
      var _6 = Parsing.peek_val(__caml_parser_env, 0);
      return mk$19(symbol_rloc(void 0), _6, symbol_docs(void 0), get_text(Parsing.symbol_start_pos(void 0)), _2, List.rev(_5), _4[0], _4[1], _4[2], {
                  txt: _3,
                  loc: rhs_loc(3)
                });
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _3,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      return /* [] */0;
    }),
  (function (__caml_parser_env) {
      return /* tuple */[
              /* Ptype_abstract */0,
              /* Public */1,
              void 0
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              /* Ptype_abstract */0,
              /* Public */1,
              _2
            ];
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              /* Ptype_abstract */0,
              /* Private */0,
              _3
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              /* Ptype_variant */Block.__(0, [List.rev(_2)]),
              /* Public */1,
              void 0
            ];
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              /* Ptype_variant */Block.__(0, [List.rev(_3)]),
              /* Private */0,
              void 0
            ];
    }),
  (function (__caml_parser_env) {
      return /* tuple */[
              /* Ptype_open */1,
              /* Public */1,
              void 0
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      return /* tuple */[
              /* Ptype_record */Block.__(1, [_4]),
              _2,
              void 0
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              /* Ptype_variant */Block.__(0, [List.rev(_5)]),
              _4,
              _2
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      return /* tuple */[
              /* Ptype_open */1,
              /* Public */1,
              _2
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 5);
      var _4 = Parsing.peek_val(__caml_parser_env, 3);
      var _6 = Parsing.peek_val(__caml_parser_env, 1);
      return /* tuple */[
              /* Ptype_record */Block.__(1, [_6]),
              _4,
              _2
            ];
    }),
  (function (__caml_parser_env) {
      return /* [] */0;
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      return List.rev(Parsing.peek_val(__caml_parser_env, 1));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              _2,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _3,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(/* Ptyp_var */Block.__(0, [_2]));
    }),
  (function (__caml_parser_env) {
      return mktyp(/* Ptyp_any */0);
    }),
  (function (__caml_parser_env) {
      return /* [] */0;
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      return List.rev(Parsing.peek_val(__caml_parser_env, 1));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              _2,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      return /* Invariant */2;
    }),
  (function (__caml_parser_env) {
      return /* Covariant */0;
    }),
  (function (__caml_parser_env) {
      return /* Contravariant */1;
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(/* Ptyp_var */Block.__(0, [_2]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _3,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _2,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return constructor(symbol_rloc(void 0), _3, Caml_option.some(get_info(Parsing.symbol_end_pos(void 0))), _2[0], _2[1], {
                  txt: _1,
                  loc: rhs_loc(1)
                });
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return constructor(symbol_rloc(void 0), _4, Caml_option.some(get_info(Parsing.symbol_end_pos(void 0))), _3[0], _3[1], {
                  txt: _2,
                  loc: rhs_loc(2)
                });
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 4);
      var _4 = Parsing.peek_val(__caml_parser_env, 2);
      var _5 = Parsing.peek_val(__caml_parser_env, 1);
      var _6 = Parsing.peek_val(__caml_parser_env, 0);
      return rebind(symbol_rloc(void 0), Pervasives.$at(_5, _6), symbol_docs(void 0), void 0, {
                  txt: _2,
                  loc: rhs_loc(2)
                }, {
                  txt: _4,
                  loc: rhs_loc(4)
                });
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return decl(symbol_rloc(void 0), Pervasives.$at(_4, _5), symbol_docs(void 0), void 0, _3[0], _3[1], {
                  txt: _2,
                  loc: rhs_loc(2)
                });
    }),
  (function (__caml_parser_env) {
      return /* tuple */[
              /* [] */0,
              void 0
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              List.rev(_2),
              void 0
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              List.rev(_2),
              _4
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              /* [] */0,
              _2
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              _2
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 4);
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return field$1(symbol_rloc(void 0), _5, Caml_option.some(get_info(Parsing.symbol_end_pos(void 0))), _1, {
                  txt: _2,
                  loc: rhs_loc(2)
                }, _4);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 6);
      var _2 = Parsing.peek_val(__caml_parser_env, 5);
      var _4 = Parsing.peek_val(__caml_parser_env, 3);
      var _5 = Parsing.peek_val(__caml_parser_env, 2);
      var _7 = Parsing.peek_val(__caml_parser_env, 0);
      var info_before_semi = get_info(Parsing.rhs_end_pos(5));
      var info = info_before_semi !== void 0 ? info_before_semi : get_info(Parsing.symbol_end_pos(void 0));
      return field$1(symbol_rloc(void 0), Pervasives.$at(_5, _7), Caml_option.some(info), _1, {
                  txt: _2,
                  loc: rhs_loc(2)
                }, _4);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 6);
      var _3 = Parsing.peek_val(__caml_parser_env, 5);
      var _4 = Parsing.peek_val(__caml_parser_env, 4);
      var _6 = Parsing.peek_val(__caml_parser_env, 2);
      var _7 = Parsing.peek_val(__caml_parser_env, 1);
      var _8 = Parsing.peek_val(__caml_parser_env, 0);
      if (_2 !== /* Recursive */1) {
        not_expecting(2, "nonrec flag");
      }
      return mk$20(_8, symbol_docs(void 0), _3, _6, {
                  txt: _4,
                  loc: rhs_loc(4)
                }, List.rev(_7));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 6);
      var _3 = Parsing.peek_val(__caml_parser_env, 5);
      var _4 = Parsing.peek_val(__caml_parser_env, 4);
      var _6 = Parsing.peek_val(__caml_parser_env, 2);
      var _7 = Parsing.peek_val(__caml_parser_env, 1);
      var _8 = Parsing.peek_val(__caml_parser_env, 0);
      if (_2 !== /* Recursive */1) {
        not_expecting(2, "nonrec flag");
      }
      return mk$20(_8, symbol_docs(void 0), _3, _6, {
                  txt: _4,
                  loc: rhs_loc(4)
                }, List.rev(_7));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _2,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _2,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _2,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return decl(symbol_rloc(void 0), _3, void 0, Caml_option.some(get_info(Parsing.symbol_end_pos(void 0))), _2[0], _2[1], {
                  txt: _1,
                  loc: rhs_loc(1)
                });
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return decl(symbol_rloc(void 0), _4, void 0, Caml_option.some(get_info(Parsing.symbol_end_pos(void 0))), _3[0], _3[1], {
                  txt: _2,
                  loc: rhs_loc(2)
                });
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 3);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return rebind(symbol_rloc(void 0), _4, void 0, Caml_option.some(get_info(Parsing.symbol_end_pos(void 0))), {
                  txt: _1,
                  loc: rhs_loc(1)
                }, {
                  txt: _3,
                  loc: rhs_loc(3)
                });
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return rebind(symbol_rloc(void 0), _5, void 0, Caml_option.some(get_info(Parsing.symbol_end_pos(void 0))), {
                  txt: _2,
                  loc: rhs_loc(2)
                }, {
                  txt: _4,
                  loc: rhs_loc(4)
                });
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _3,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 4);
      var _3 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 2);
      var _5 = Parsing.peek_val(__caml_parser_env, 1);
      var _6 = Parsing.peek_val(__caml_parser_env, 0);
      var rhs = last$1(_3);
      return /* Pwith_type */Block.__(0, [
                {
                  txt: _3,
                  loc: rhs_loc(3)
                },
                mk$19(symbol_rloc(void 0), void 0, void 0, void 0, _2, List.rev(_6), void 0, _4, _5, {
                      txt: rhs,
                      loc: rhs_loc(3)
                    })
              ]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Pwith_typesubst */Block.__(2, [mk$19(symbol_rloc(void 0), void 0, void 0, void 0, _2, void 0, void 0, void 0, _5, {
                      txt: _3,
                      loc: rhs_loc(3)
                    })]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Pwith_module */Block.__(1, [
                {
                  txt: _2,
                  loc: rhs_loc(2)
                },
                {
                  txt: _4,
                  loc: rhs_loc(4)
                }
              ]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Pwith_modsubst */Block.__(3, [
                {
                  txt: _2,
                  loc: rhs_loc(2)
                },
                {
                  txt: _4,
                  loc: rhs_loc(4)
                }
              ]);
    }),
  (function (__caml_parser_env) {
      return /* Public */1;
    }),
  (function (__caml_parser_env) {
      return /* Private */0;
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _2,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _3,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(/* Ptyp_poly */Block.__(8, [
                    List.rev(_1),
                    _3
                  ]));
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(/* Ptyp_poly */Block.__(8, [
                    List.rev(_1),
                    _3
                  ]));
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return attr(_1, _2);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(/* Ptyp_alias */Block.__(6, [
                    _1,
                    _4
                  ]));
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 4);
      var _4 = Parsing.peek_val(__caml_parser_env, 2);
      var _6 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(/* Ptyp_arrow */Block.__(1, [
                    "?" + _2,
                    mkoption(_4),
                    _6
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 3);
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(/* Ptyp_arrow */Block.__(1, [
                    "?" + _1,
                    mkoption(_2),
                    _4
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 4);
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(/* Ptyp_arrow */Block.__(1, [
                    _1,
                    _3,
                    _5
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(/* Ptyp_arrow */Block.__(1, [
                    "",
                    _1,
                    _3
                  ]));
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      if (!_2) {
        throw Parsing.Parse_error;
      }
      if (_2[1]) {
        throw Parsing.Parse_error;
      }
      return _2[0];
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      if (!_2) {
        throw Parsing.Parse_error;
      }
      if (_2[1]) {
        throw Parsing.Parse_error;
      }
      return _2[0];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(/* Ptyp_var */Block.__(0, [_2]));
    }),
  (function (__caml_parser_env) {
      return mktyp(/* Ptyp_any */0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(/* Ptyp_constr */Block.__(3, [
                    {
                      txt: _1,
                      loc: rhs_loc(1)
                    },
                    /* [] */0
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(/* Ptyp_constr */Block.__(3, [
                    {
                      txt: _2,
                      loc: rhs_loc(2)
                    },
                    /* :: */[
                      _1,
                      /* [] */0
                    ]
                  ]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(/* Ptyp_constr */Block.__(3, [
                    {
                      txt: _4,
                      loc: rhs_loc(4)
                    },
                    List.rev(_2)
                  ]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      return mktyp(/* Ptyp_object */Block.__(4, [
                    _2[0],
                    _2[1]
                  ]));
    }),
  (function (__caml_parser_env) {
      return mktyp(/* Ptyp_object */Block.__(4, [
                    /* [] */0,
                    /* Closed */0
                  ]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(/* Ptyp_class */Block.__(5, [
                    {
                      txt: _2,
                      loc: rhs_loc(2)
                    },
                    /* [] */0
                  ]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(/* Ptyp_class */Block.__(5, [
                    {
                      txt: _3,
                      loc: rhs_loc(3)
                    },
                    /* :: */[
                      _1,
                      /* [] */0
                    ]
                  ]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(/* Ptyp_class */Block.__(5, [
                    {
                      txt: _5,
                      loc: rhs_loc(5)
                    },
                    List.rev(_2)
                  ]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      return mktyp(/* Ptyp_variant */Block.__(7, [
                    /* :: */[
                      _2,
                      /* [] */0
                    ],
                    /* Closed */0,
                    void 0
                  ]));
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      return mktyp(/* Ptyp_variant */Block.__(7, [
                    List.rev(_3),
                    /* Closed */0,
                    void 0
                  ]));
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 3);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      return mktyp(/* Ptyp_variant */Block.__(7, [
                    /* :: */[
                      _2,
                      List.rev(_4)
                    ],
                    /* Closed */0,
                    void 0
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      return mktyp(/* Ptyp_variant */Block.__(7, [
                    List.rev(_3),
                    /* Open */1,
                    void 0
                  ]));
    }),
  (function (__caml_parser_env) {
      return mktyp(/* Ptyp_variant */Block.__(7, [
                    /* [] */0,
                    /* Open */1,
                    void 0
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      return mktyp(/* Ptyp_variant */Block.__(7, [
                    List.rev(_3),
                    /* Closed */0,
                    /* [] */0
                  ]));
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 4);
      var _3 = Parsing.peek_val(__caml_parser_env, 3);
      var _5 = Parsing.peek_val(__caml_parser_env, 1);
      return mktyp(/* Ptyp_variant */Block.__(7, [
                    List.rev(_3),
                    /* Closed */0,
                    List.rev(_5)
                  ]));
    }),
  (function (__caml_parser_env) {
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      return mktyp(/* Ptyp_package */Block.__(9, [_3]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(/* Ptyp_extension */Block.__(10, [_1]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              {
                txt: _1,
                loc: rhs_loc(1)
              },
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              {
                txt: _1,
                loc: rhs_loc(1)
              },
              _3
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              {
                txt: _2,
                loc: rhs_loc(2)
              },
              _4
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              _3
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _3,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Rinherit */Block.__(1, [_1]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 4);
      var _3 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 1);
      var _5 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Rtag */Block.__(0, [
                _1,
                _5,
                _3,
                List.rev(_4)
              ]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Rtag */Block.__(0, [
                _1,
                _2,
                true,
                /* [] */0
              ]);
    }),
  (function (__caml_parser_env) {
      return true;
    }),
  (function (__caml_parser_env) {
      return false;
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _3,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _2,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(/* Ptyp_tuple */Block.__(2, [/* :: */[
                      _1,
                      List.rev(_3)
                    ]]));
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return mktyp(/* Ptyp_tuple */Block.__(2, [/* :: */[
                      _1,
                      List.rev(_3)
                    ]]));
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _3,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _3,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _3,
              _1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              /* :: */[
                _1,
                _3[0]
              ],
              _3[1]
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              /* :: */[
                _1,
                /* [] */0
              ],
              /* Closed */0
            ];
    }),
  (function (__caml_parser_env) {
      return /* tuple */[
              /* [] */0,
              /* Open */1
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 3);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              _1,
              _4,
              _3
            ];
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Const_int */Block.__(0, [_1]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Const_char */Block.__(1, [_1]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Const_string */Block.__(2, [
                _1[0],
                _1[1]
              ]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Const_float */Block.__(3, [_1]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Const_int32 */Block.__(4, [_1]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Const_int64 */Block.__(5, [_1]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Const_nativeint */Block.__(6, [_1]);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Const_int */Block.__(0, [-_2 | 0]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Const_float */Block.__(3, ["-" + _2]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Const_int32 */Block.__(4, [-_2 | 0]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Const_int64 */Block.__(5, [Caml_int64.neg(_2)]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Const_nativeint */Block.__(6, [-_2]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Const_int */Block.__(0, [_2]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Const_float */Block.__(3, [_2]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Const_int32 */Block.__(4, [_2]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Const_int64 */Block.__(5, [_2]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Const_nativeint */Block.__(6, [_2]);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 1);
    }),
  (function (__caml_parser_env) {
      Parsing.peek_val(__caml_parser_env, 1);
      return unclosed("(", 1, ")", 3);
    }),
  (function (__caml_parser_env) {
      return expecting(2, "operator");
    }),
  (function (__caml_parser_env) {
      return expecting(3, "module-expr");
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return "!";
    }),
  (function (__caml_parser_env) {
      return "+";
    }),
  (function (__caml_parser_env) {
      return "+.";
    }),
  (function (__caml_parser_env) {
      return "-";
    }),
  (function (__caml_parser_env) {
      return "-.";
    }),
  (function (__caml_parser_env) {
      return "*";
    }),
  (function (__caml_parser_env) {
      return "=";
    }),
  (function (__caml_parser_env) {
      return "<";
    }),
  (function (__caml_parser_env) {
      return ">";
    }),
  (function (__caml_parser_env) {
      return "or";
    }),
  (function (__caml_parser_env) {
      return "||";
    }),
  (function (__caml_parser_env) {
      return "&";
    }),
  (function (__caml_parser_env) {
      return "&&";
    }),
  (function (__caml_parser_env) {
      return ":=";
    }),
  (function (__caml_parser_env) {
      return "+=";
    }),
  (function (__caml_parser_env) {
      return "%";
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return "()";
    }),
  (function (__caml_parser_env) {
      return "::";
    }),
  (function (__caml_parser_env) {
      return "false";
    }),
  (function (__caml_parser_env) {
      return "true";
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Lident */Block.__(0, [_1]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Ldot */Block.__(1, [
                _1,
                _3
              ]);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return /* Lident */Block.__(0, ["[]"]);
    }),
  (function (__caml_parser_env) {
      return /* Lident */Block.__(0, ["()"]);
    }),
  (function (__caml_parser_env) {
      return /* Lident */Block.__(0, ["false"]);
    }),
  (function (__caml_parser_env) {
      return /* Lident */Block.__(0, ["true"]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Lident */Block.__(0, [_1]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Ldot */Block.__(1, [
                _1,
                _3
              ]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Lident */Block.__(0, [_1]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Ldot */Block.__(1, [
                _1,
                _3
              ]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Lident */Block.__(0, [_1]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Ldot */Block.__(1, [
                _1,
                _3
              ]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Lident */Block.__(0, [_1]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Ldot */Block.__(1, [
                _1,
                _3
              ]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 3);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      if (applicative_functors.contents) {
        return /* Lapply */Block.__(2, [
                  _1,
                  _3
                ]);
      }
      throw [
            $$Error$3,
            /* Applicative_path */Block.__(3, [symbol_rloc(void 0)])
          ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Lident */Block.__(0, [_1]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Ldot */Block.__(1, [
                _1,
                _3
              ]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Lident */Block.__(0, [_1]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Ldot */Block.__(1, [
                _1,
                _3
              ]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Lident */Block.__(0, [_1]);
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Ldot */Block.__(1, [
                _1,
                _3
              ]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Ptop_dir */Block.__(1, [
                _2,
                /* Pdir_none */0
              ]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Ptop_dir */Block.__(1, [
                _2,
                /* Pdir_string */Block.__(0, [_3[0]])
              ]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Ptop_dir */Block.__(1, [
                _2,
                /* Pdir_int */Block.__(1, [_3])
              ]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Ptop_dir */Block.__(1, [
                _2,
                /* Pdir_ident */Block.__(2, [_3])
              ]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* Ptop_dir */Block.__(1, [
                _2,
                /* Pdir_ident */Block.__(2, [_3])
              ]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      return /* Ptop_dir */Block.__(1, [
                _2,
                /* Pdir_bool */Block.__(3, [false])
              ]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      return /* Ptop_dir */Block.__(1, [
                _2,
                /* Pdir_bool */Block.__(3, [true])
              ]);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return /* Nonrecursive */0;
    }),
  (function (__caml_parser_env) {
      return /* Recursive */1;
    }),
  (function (__caml_parser_env) {
      return /* Recursive */1;
    }),
  (function (__caml_parser_env) {
      return /* Nonrecursive */0;
    }),
  (function (__caml_parser_env) {
      return /* Upto */0;
    }),
  (function (__caml_parser_env) {
      return /* Downto */1;
    }),
  (function (__caml_parser_env) {
      return /* Public */1;
    }),
  (function (__caml_parser_env) {
      return /* Private */0;
    }),
  (function (__caml_parser_env) {
      return /* Immutable */0;
    }),
  (function (__caml_parser_env) {
      return /* Mutable */1;
    }),
  (function (__caml_parser_env) {
      return /* Concrete */1;
    }),
  (function (__caml_parser_env) {
      return /* Virtual */0;
    }),
  (function (__caml_parser_env) {
      return /* tuple */[
              /* Public */1,
              /* Concrete */1
            ];
    }),
  (function (__caml_parser_env) {
      return /* tuple */[
              /* Private */0,
              /* Concrete */1
            ];
    }),
  (function (__caml_parser_env) {
      return /* tuple */[
              /* Public */1,
              /* Virtual */0
            ];
    }),
  (function (__caml_parser_env) {
      return /* tuple */[
              /* Private */0,
              /* Virtual */0
            ];
    }),
  (function (__caml_parser_env) {
      return /* tuple */[
              /* Private */0,
              /* Virtual */0
            ];
    }),
  (function (__caml_parser_env) {
      return /* Fresh */1;
    }),
  (function (__caml_parser_env) {
      return /* Override */0;
    }),
  (function (__caml_parser_env) {
      
    }),
  (function (__caml_parser_env) {
      
    }),
  (function (__caml_parser_env) {
      
    }),
  (function (__caml_parser_env) {
      
    }),
  (function (__caml_parser_env) {
      return "-";
    }),
  (function (__caml_parser_env) {
      return "-.";
    }),
  (function (__caml_parser_env) {
      return "+";
    }),
  (function (__caml_parser_env) {
      return "+.";
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return Parsing.peek_val(__caml_parser_env, 0);
    }),
  (function (__caml_parser_env) {
      return "and";
    }),
  (function (__caml_parser_env) {
      return "as";
    }),
  (function (__caml_parser_env) {
      return "assert";
    }),
  (function (__caml_parser_env) {
      return "begin";
    }),
  (function (__caml_parser_env) {
      return "class";
    }),
  (function (__caml_parser_env) {
      return "constraint";
    }),
  (function (__caml_parser_env) {
      return "do";
    }),
  (function (__caml_parser_env) {
      return "done";
    }),
  (function (__caml_parser_env) {
      return "downto";
    }),
  (function (__caml_parser_env) {
      return "else";
    }),
  (function (__caml_parser_env) {
      return "end";
    }),
  (function (__caml_parser_env) {
      return "exception";
    }),
  (function (__caml_parser_env) {
      return "external";
    }),
  (function (__caml_parser_env) {
      return "false";
    }),
  (function (__caml_parser_env) {
      return "for";
    }),
  (function (__caml_parser_env) {
      return "fun";
    }),
  (function (__caml_parser_env) {
      return "function";
    }),
  (function (__caml_parser_env) {
      return "functor";
    }),
  (function (__caml_parser_env) {
      return "if";
    }),
  (function (__caml_parser_env) {
      return "in";
    }),
  (function (__caml_parser_env) {
      return "include";
    }),
  (function (__caml_parser_env) {
      return "inherit";
    }),
  (function (__caml_parser_env) {
      return "initializer";
    }),
  (function (__caml_parser_env) {
      return "lazy";
    }),
  (function (__caml_parser_env) {
      return "let";
    }),
  (function (__caml_parser_env) {
      return "match";
    }),
  (function (__caml_parser_env) {
      return "method";
    }),
  (function (__caml_parser_env) {
      return "module";
    }),
  (function (__caml_parser_env) {
      return "mutable";
    }),
  (function (__caml_parser_env) {
      return "new";
    }),
  (function (__caml_parser_env) {
      return "object";
    }),
  (function (__caml_parser_env) {
      return "of";
    }),
  (function (__caml_parser_env) {
      return "open";
    }),
  (function (__caml_parser_env) {
      return "or";
    }),
  (function (__caml_parser_env) {
      return "private";
    }),
  (function (__caml_parser_env) {
      return "rec";
    }),
  (function (__caml_parser_env) {
      return "sig";
    }),
  (function (__caml_parser_env) {
      return "struct";
    }),
  (function (__caml_parser_env) {
      return "then";
    }),
  (function (__caml_parser_env) {
      return "to";
    }),
  (function (__caml_parser_env) {
      return "true";
    }),
  (function (__caml_parser_env) {
      return "try";
    }),
  (function (__caml_parser_env) {
      return "type";
    }),
  (function (__caml_parser_env) {
      return "val";
    }),
  (function (__caml_parser_env) {
      return "virtual";
    }),
  (function (__caml_parser_env) {
      return "when";
    }),
  (function (__caml_parser_env) {
      return "while";
    }),
  (function (__caml_parser_env) {
      return "with";
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return {
              txt: _1,
              loc: symbol_rloc(void 0)
            };
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return {
              txt: _1 + ("." + _3.txt),
              loc: symbol_rloc(void 0)
            };
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      return /* tuple */[
              _2,
              _3
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      return /* tuple */[
              _2,
              _3
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      return /* tuple */[
              _2,
              _3
            ];
    }),
  (function (__caml_parser_env) {
      return /* [] */0;
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              _2
            ];
    }),
  (function (__caml_parser_env) {
      return /* [] */0;
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* :: */[
              _1,
              _2
            ];
    }),
  (function (__caml_parser_env) {
      return /* tuple */[
              void 0,
              /* [] */0
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 1);
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              void 0,
              /* :: */[
                _1,
                _2
              ]
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 1);
      var _3 = Parsing.peek_val(__caml_parser_env, 0);
      return /* tuple */[
              _2,
              _3
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      return /* tuple */[
              _2,
              _3
            ];
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _3 = Parsing.peek_val(__caml_parser_env, 1);
      return /* tuple */[
              _2,
              _3
            ];
    }),
  (function (__caml_parser_env) {
      var _1 = Parsing.peek_val(__caml_parser_env, 0);
      return /* PStr */Block.__(0, [_1]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* PTyp */Block.__(1, [_2]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 0);
      return /* PPat */Block.__(2, [
                _2,
                void 0
              ]);
    }),
  (function (__caml_parser_env) {
      var _2 = Parsing.peek_val(__caml_parser_env, 2);
      var _4 = Parsing.peek_val(__caml_parser_env, 0);
      return /* PPat */Block.__(2, [
                _2,
                _4
              ]);
    }),
  (function (__caml_parser_env) {
      throw [
            Parsing.YYexit,
            Parsing.peek_val(__caml_parser_env, 0)
          ];
    }),
  (function (__caml_parser_env) {
      throw [
            Parsing.YYexit,
            Parsing.peek_val(__caml_parser_env, 0)
          ];
    }),
  (function (__caml_parser_env) {
      throw [
            Parsing.YYexit,
            Parsing.peek_val(__caml_parser_env, 0)
          ];
    }),
  (function (__caml_parser_env) {
      throw [
            Parsing.YYexit,
            Parsing.peek_val(__caml_parser_env, 0)
          ];
    }),
  (function (__caml_parser_env) {
      throw [
            Parsing.YYexit,
            Parsing.peek_val(__caml_parser_env, 0)
          ];
    }),
  (function (__caml_parser_env) {
      throw [
            Parsing.YYexit,
            Parsing.peek_val(__caml_parser_env, 0)
          ];
    }),
  (function (__caml_parser_env) {
      throw [
            Parsing.YYexit,
            Parsing.peek_val(__caml_parser_env, 0)
          ];
    })
];

var yytables = {
  actions: yyact,
  transl_const: yytransl_const,
  transl_block: yytransl_block,
  lhs: "\xff\xff\x01\0\x02\0\x03\0\x03\0\x03\0\n\0\n\0\x0e\0\x0e\0\x04\0\x10\0\x10\0\x11\0\x11\0\x11\0\x11\0\x11\0\x11\0\x11\0\x05\0\x06\0\x07\0\x14\0\x14\0\x15\0\x15\0\x17\0\x17\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\b\0\b\0\x1e\0\x1e\0\x1e\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0*\0-\0-\0-\0$\0%\0%\0.\0/\0\x16\0\x16\0\x16\0\x16\0\x16\0\x16\0\x16\0\x16\0\x16\0\x16\0\t\0\t\0\t\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\0'\x009\0<\0<\0<\x006\x007\x008\x008\0=\0>\0?\0?\0&\0(\0(\0A\0B\0E\0E\0E\0D\0D\0J\0J\0F\0F\0F\0F\0F\0F\0K\0K\0K\0K\0K\0K\0K\0K\0O\0P\0P\0P\0Q\0Q\0R\0R\0R\0R\0R\0R\0R\0S\0S\0T\0T\0T\0T\0U\0U\0U\0U\0U\0G\0G\0G\0G\0G\0^\0^\0^\0^\0^\0^\0a\0b\0b\0c\0c\0d\0d\0d\0d\0d\0d\0e\0e\0e\0g\0V\0:\0:\0h\0i\0)\0)\0j\0k\0\f\0\f\0\f\0H\0H\0H\0H\0H\0H\0H\0H\0p\0p\0m\0m\0l\0l\0n\0o\0o\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0r\0L\0L\0\x84\0\x84\0\x85\0\x85\0\x85\0\x85\0\x86\0]\0]\0\x87\0\x87\0\x87\0\x87\0\x87\0\x1f\0\x1f\0\x8c\0\x8d\0\x89\0\x89\0\\\0\\\0\\\0u\0u\0\x8f\0\x8f\0v\0v\0v\0w\0w\0\x80\0\x80\0\x90\0\x90\0\x90\0\x91\0\x91\0\x83\0\x83\0\x81\0\x81\0Y\0Y\0Y\0Y\0Y\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0q\0q\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x8b\0\x92\0\x92\0\x92\0\x96\0\x96\0\x95\0\x95\0\x95\0\x95\0\x97\0\x97\x003\0\x98\0\x98\0 \0!\0!\0\x99\0\x9a\0\x9e\0\x9e\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9c\0\x9c\0\x9c\0\xa1\0\xa2\0\xa2\0\xa4\0\xa4\0\xa5\0\xa5\0\xa5\0\xa6\0\xa3\0\xa3\0\xa3\0\xa7\0I\0I\0\x9f\0\x9f\0\x9f\0\xa8\0\xa9\0#\0#\x005\0\xab\0\xab\0\xab\0\xab\0\xa0\0\xa0\0\xa0\0\xaf\0\xb0\0\"\x004\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb3\0\xb3\0\xb3\0\xb4\0\xb5\0\xb6\0\xb7\x001\x001\0\xb8\0\xb8\0\xb8\0\xb8\0\xb9\0\xb9\0\x8a\0\x8a\0Z\0Z\0\xb1\0\xb1\0\x12\0\x12\0\xba\0\xba\0\xbc\0\xbc\0\xbc\0\xbc\0\xbc\0\xbe\0\xbe\0\xae\0\xae\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\x1b\0\x1b\0\xc6\0\xc5\0\xc5\0\xc2\0\xc2\0\xc3\0\xc3\0\xc1\0\xc1\0\xc7\0\xc7\0\xc8\0\xc8\0\xc4\0\xc4\0\xbd\0\xbd\0_\0_\0M\0M\0\xc9\0\xc9\0\xad\0\xad\0\xc0\0\xc0\0\xc0\0\xca\0W\0\x7f\0\x7f\0\x7f\0\x7f\0\x7f\0\x7f\0\x7f\0\x93\0\x93\0\x93\0\x93\0\x93\0\x93\0\x93\0\x93\0\x93\0\x93\0\x93\0@\0@\0\x88\0\x88\0\x88\0\x88\0\x88\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xcb\0\xaa\0\xaa\0\xaa\0\xaa\0\xaa\0~\0~\0x\0x\0x\0x\0x\0}\0}\0\x94\0\x94\0\x19\0\x19\0\xbb\0\xbb\0\xbb\x000\x000\0`\0`\0N\0N\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0y\0\x8e\0\x8e\0\x9b\0\x9b\0z\0z\0[\0[\0X\0X\0C\0C\0f\0f\0f\0f\0f\0;\0;\0t\0t\0\x82\0\x82\0{\0{\0|\0|\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcd\0\xcd\0\x1c\0\xcf\0,\0\r\0\r\0\xac\0\xac\0s\0s\0s\0\x1d\0+\0\xce\0\xce\0\xce\0\xce\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
  len: "\x02\0\x02\0\x02\0\x02\0\x02\0\x01\0\x02\0\x01\0\0\0\x02\0\x01\0\x01\0\x03\0\x01\0\x02\0\x04\0\x03\0\x03\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x05\0\x01\0\x01\0\x02\0\x01\0\x01\0\x03\0\x03\0\x04\0\x04\0\x03\0\x04\0\x05\0\x05\0\x03\0\x03\0\x04\0\x06\0\b\0\x06\0\x05\0\x05\0\x04\0\x02\0\x01\0\x03\0\x01\0\0\0\x02\0\x02\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x02\0\x01\0\x03\0\x02\0\x04\0\x02\0\x04\0\x01\0\x02\0\x05\0\x04\0\x01\0\x03\0\x03\0\x04\0\x03\0\x04\0\x03\0\x03\0\x01\0\x02\0\0\0\x02\0\x02\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x02\0\x01\0\x04\0\x03\0\x02\0\x06\0\x03\0\x04\0\x05\0\x01\0\x02\0\x06\0\x05\0\0\0\x02\0\x05\0\x01\0\x02\0\x06\0\x06\0\x02\0\x04\0\x02\0\0\0\x03\0\x03\0\x02\0\x01\0\x02\0\x02\0\x03\0\x02\0\x01\0\x04\0\x01\0\x03\0\x03\0\x05\0\x05\0\x03\0\x03\0\x02\0\x03\0\x05\0\0\0\0\0\x02\0\x05\0\x03\0\x03\0\x03\0\x03\0\x02\0\x01\0\x02\0\0\0\x06\0\x05\0\x05\0\x06\0\x06\0\x06\0\x04\0\x07\0\n\0\x01\0\x06\0\x04\0\x05\0\x03\0\x04\0\x01\0\x03\0\x03\0\x02\0\x01\0\x02\0\x03\0\0\0\0\0\x02\0\x03\0\x03\0\x06\0\x03\0\x02\0\x01\0\x05\0\x05\0\x03\0\x03\0\x03\0\x01\0\x02\0\x07\0\x07\0\x01\0\x02\0\b\0\x07\0\x01\0\x02\0\x03\0\x05\0\x02\0\x05\0\x02\0\x04\0\x02\0\x02\0\x01\0\x01\0\x01\0\0\0\x02\0\x01\0\x03\0\x01\0\x01\0\x03\0\x01\0\x02\0\x03\0\x07\0\x07\0\x04\0\x04\0\x07\0\x06\0\x06\0\x05\0\x01\0\x02\0\x02\0\x07\0\x05\0\x06\0\n\0\x03\0\b\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x02\0\x02\0\x05\0\x07\0\x07\0\x07\0\x03\0\x03\0\x03\0\x04\0\x04\0\x02\0\x01\0\x01\0\x01\0\x01\0\x03\0\x03\0\x04\0\x03\0\x04\0\x04\0\x03\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x03\0\x03\0\x05\0\x05\0\x04\0\x04\0\x02\0\x06\0\x06\0\x04\0\x04\0\x06\0\x06\0\x02\0\x02\0\x03\0\x04\0\x04\0\x02\0\x06\0\x06\0\x03\0\x03\0\x04\0\x06\0\x05\0\b\0\x07\0\x01\0\x01\0\x02\0\x01\0\x01\0\x02\0\x02\0\x02\0\x02\0\x01\0\x01\0\x02\0\x02\0\x07\0\b\0\x03\0\x05\0\x01\0\x02\0\x05\0\x03\0\x01\0\x03\0\x02\0\x02\0\x05\0\x01\0\x03\0\x03\0\x05\0\x02\0\x02\0\x05\0\x03\0\x03\0\x03\0\x01\0\x01\0\x03\0\x02\0\x03\0\x01\0\x03\0\x05\0\x01\0\x03\0\x02\0\x04\0\x02\0\x02\0\x02\0\x01\0\x03\0\x03\0\x01\0\x02\0\x02\0\x03\0\x03\0\b\0\b\0\x03\0\x03\0\x02\0\x02\0\x02\0\x01\0\x01\0\x01\0\x01\0\x03\0\x01\0\x01\0\x02\0\x03\0\x03\0\x04\0\x04\0\x04\0\x02\0\x04\0\x03\0\x03\0\x05\0\x05\0\x04\0\x04\0\x06\0\x06\0\x01\0\x03\0\x03\0\x03\0\x01\0\x03\0\x01\0\x02\0\x04\0\x03\0\x03\0\x01\0\x05\0\x01\0\x02\0\x07\0\x01\0\x02\0\x07\0\x06\0\x03\0\0\0\0\0\x02\0\x03\0\x02\0\x03\0\x02\0\x05\0\x05\0\x04\0\x07\0\0\0\x01\0\x03\0\x02\0\x01\0\x03\0\x02\0\x01\0\0\0\x01\0\x03\0\x02\0\0\0\x01\0\x01\0\x02\0\x01\0\x03\0\x01\0\x01\0\x02\0\x03\0\x04\0\x01\0\x06\0\x05\0\0\0\x02\0\x04\0\x02\0\x01\0\x01\0\x02\0\x05\0\x07\0\b\0\b\0\x01\0\x01\0\x01\0\x01\0\x02\0\x02\0\x01\0\x01\0\x02\0\x03\0\x04\0\x04\0\x05\0\x01\0\x03\0\x06\0\x05\0\x04\0\x04\0\x01\0\x02\0\x02\0\x03\0\x01\0\x03\0\x01\0\x03\0\x01\0\x02\0\x01\0\x04\0\x01\0\x06\0\x04\0\x05\0\x03\0\x01\0\x03\0\x01\0\x03\0\x02\0\x01\0\x01\0\x02\0\x04\0\x03\0\x02\0\x02\0\x03\0\x05\0\x03\0\x04\0\x05\0\x04\0\x02\0\x04\0\x06\0\x04\0\x01\0\x01\0\x03\0\x04\0\x01\0\x03\0\x01\0\x03\0\x01\0\x01\0\x05\0\x02\0\x01\0\0\0\x01\0\x03\0\x01\0\x02\0\x01\0\x03\0\x01\0\x03\0\x01\0\x03\0\x01\0\x03\0\x01\0\x03\0\x03\0\x02\0\x01\0\x04\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x01\0\x01\0\x01\0\x03\0\x03\0\x02\0\x03\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x02\0\x01\0\x01\0\x01\0\x01\0\x03\0\x01\0\x02\0\x02\0\x01\0\x01\0\x01\0\x03\0\x01\0\x03\0\x01\0\x03\0\x01\0\x03\0\x04\0\x01\0\x03\0\x01\0\x03\0\x01\0\x03\0\x02\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x02\0\0\0\x01\0\0\0\x01\0\x01\0\x01\0\0\0\x01\0\0\0\x01\0\0\0\x01\0\0\0\x01\0\x01\0\x02\0\x02\0\0\0\x01\0\0\0\x01\0\0\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x03\0\x04\0\x04\0\x04\0\0\0\x02\0\0\0\x02\0\0\0\x02\0\x03\0\x04\0\x04\0\x01\0\x02\0\x02\0\x04\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0",
  defred: "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0<\x02\0\0\0\0\0\0u\x02>\x02\0\0\0\0\0\0\0\0\0\0;\x02?\x02@\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa5\x02\xa6\x02\0\0A\x02\0\0\0\0\0\0\xa7\x02\xa8\x02\0\0\0\0=\x02v\x02\0\0\0\0{\x02\0\0\xed\x02\0\0\0\0\0\0\0\0\0\0B\x012\0\0\x007\0\0\x009\0:\0;\0\0\0=\0>\0\0\0\0\0A\0\0\0C\0I\0\xd2\x01w\0\0\0\xc7\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\x01\x14\x01p\x02S\x01\xab\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xee\x02\0\0[\0\0\0b\0c\0\0\0\0\0h\0\0\0Z\0]\0^\0_\0`\0\0\0d\0\0\0p\0\xc3\0\x05\0\0\0\xef\x02\0\0\0\0\0\0\x07\0\0\0\r\0\0\0\xf0\x02\0\0\0\0\0\0\n\0\x0b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0}\x02\t\x02\xf1\x02\0\0\x1a\x02\n\x02\xfb\x01\0\0\0\0\xff\x01\0\0\0\0\xf2\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0O\x02\0\0\0\0\0\0\0\0\x86\x01\xf3\x02\0\0\0\0\x9b\x01u\x01\0\0\0\0B\x02\x84\x01\x85\x01\0\0\0\0\0\0\0\0\0\0\0\0N\x02M\x02\x8d\x02\0\x004\x01\x15\x01\x16\x01\0\0\0\0\x99\x02\0\0m\x02n\x02\0\0o\x02k\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x000\0\0\0\0\0\0\0\0\0\0\0\0\0f\x01\0\x008\x01:\x02\0\0\0\0s\x02\0\0\0\0,\x01\0\0\xab\x02\xac\x02\xad\x02\xae\x02\xaf\x02\xb0\x02\xb1\x02\xb2\x02\xb3\x02\xb4\x02\xb5\x02\xb6\x02\xb7\x02\xb8\x02\xb9\x02\xba\x02\xbb\x02\xbc\x02\xbd\x02\xbe\x02\xbf\x02\xc0\x02\xc1\x02\xc2\x02\xc3\x02\xa9\x02\xc4\x02\xc5\x02\xc6\x02\xc7\x02\xc8\x02\xc9\x02\xca\x02\xcb\x02\xcc\x02\xcd\x02\xce\x02\xcf\x02\xd0\x02\xd1\x02\xd2\x02\xd3\x02\xd4\x02\xd5\x02\xaa\x02\xd6\x02\xd7\x02\xd8\x02\xd9\x02\xda\x02\0\0\0\0\0\0\0\0\0\0\0\0R\x02g\x02f\x02\0\0e\x02\0\0h\x02a\x02c\x02U\x02V\x02W\x02X\x02Y\x02b\x02\0\0\0\0\0\0d\x02j\x02\0\0\0\0i\x02\0\0t\x02Z\x02`\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa0\x02\0\x003\x014\0\0\0\x91\x02\0\0\0\0\x01\0\0\0\0\0\0\0\0\x005\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x12\x01\0\0\0\0T\x01\0\0\xac\x01\0\0J\0\0\0x\0\0\0\xc8\0B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0C\x01F\x01\0\0\0\0\0\0\x07\x01\b\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0U\0M\0\x80\x02\0\0\0\0\0\0X\0\0\0\0\0\x02\0g\0Y\0\0\0q\0\0\0\xc4\0\0\0\x03\0\x04\0\x06\0\t\0\x0e\0\0\0\0\0\0\0\x13\0\0\0\x12\0\0\0y\x02\0\0#\x02\0\0\0\0\xa2\x02\0\0\x16\x02\0\x008\x02\x0e\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\b\x02\x84\x02\0\0\x0f\x02\x14\0\xfc\x01\0\0\0\0\0\0\0\0\0\0\0\0\x0b\x02\x15\0\x82\x01\0\0\x81\x01\x89\x01\x8a\x01w\x02\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01\0\0[\x02\0\0\0\0_\x02\0\0\0\0]\x02T\x02\0\0D\x02C\x02E\x02F\x02G\x02I\x02H\x02J\x02K\x02L\x02\x8b\x01\0\0\0\0\0\0\0\0\x16\0\x83\x01\0\0y\x01z\x01\0\0\0\0\0\0\0\0\0\0\xe5\x02\0\0\0\0\x1a\x01\0\0\0\0\0\0\0\0l\x02\0\0\0\0\0\0\0\0^\x02\0\0\\\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd5\0\0\0\0\0\0\0\x1c\0\0\0\0\0\0\0\0\0\0\0D\0/\0\0\0\0\0\0\0\0\0'\x01&\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe9\x02\0\0\0\0\0\0\0\0\x8f\x02\0\0\0\0S\x02\0\0\x18\x01\0\0\0\0\x17\x01\0\0Q\x02P\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x005\x01\0\0\0\0\x94\0\0\0\0\0\0\0\xc9\x01\xc8\x01\0\0\xbc\x01\0\0\0\0\0\x001\0\xe1\x02\0\0\0\0\0\0\0\0\0\0|\x02q\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xcd\0\0\0\0\0\0\0\0\0\0\0\xe1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0K\x01I\x01;\x01\0\0H\x01D\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0j\0V\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8b\x02\x88\x02\x87\x02\x8c\x02\0\0\x89\x02\x11\0\0\0\x10\0\f\0\"\x02\0\0 \x02\0\0%\x02\x12\x02\0\0\0\0\0\0\0\0\r\x02\0\x007\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0z\x02~\x02\0\0\0\0\0\x002\x02\0\0\x10\x02\0\0\0\0\x8d\x01\x8c\x01\0\0\0\0\0\0\0\0\0\0\0\0\x94\x01\0\0\x93\x01w\x01v\x01\x80\x01\0\0|\x01\0\0\x9e\x01\0\0\0\0\x88\x01\0\0\xe6\x02\xe3\x02\0\0\0\0\0\0\x1d\x01\x1b\x01\x19\x01\0\0\0\0\0\0\xcb\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd6\x014\x02\0\0\0\0\0\0\xd4\0\0\0\xd6\0\0\0\xd7\0\xd1\0\xdc\0\0\0\xcf\0\0\0\xd3\0\0\0\0\0\0\0\xe5\0\0\0\0\0\\\x01\0\0\x17\0\x19\0\x1a\0\0\0\0\0\x1b\0\0\0'\0\0\0&\0\x1f\0\x1e\0\"\0\0\0\0\0e\x01\0\0h\x01\0\0\0\x007\x016\x01\0\x000\x01/\x01+\x01*\x01\xdc\x02\0\0\0\0\xe7\x02\xe8\x02\0\0\0\0\0\0\0\0\0\0=\x01s\x01\0\0t\x01\0\0\x1c\x01\xdf\x02\0\0\0\0\0\0\0\0\0\0\0\0G\0H\0\0\0\x11\x01\x10\x01\0\0i\0\0\0\xbf\x01\0\0\0\0\0\0\0\0\xc2\x01\xbe\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0V\x01\0\0\0\0\0\0\0\0\0\0W\x01N\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0T\0S\0\0\0O\0N\0\0\0\0\0\0\0\xed\x01\0\0\x81\x02\0\0\0\0\0\0\0\0\0\0n\0\0\0\0\0\0\0\0\0\0\0\x0f\0\0\0\x13\x02&\x02\0\0\0\0\0\0\x17\x02\x15\x02\0\0\0\0\0\0\xf9\x016\x02\0\0\x19\x02\0\0\0\0\0\0\f\x02\0\0\0\0\x85\x02\0\0\x7f\x02\xfe\x01\0\0x\x02\0\0\0\0\xa4\x01\0\0\x8f\x01\x8e\x01\x92\x01\x90\x01\0\0\0\0\x98\x01\x97\x01\0\0\xdd\x02\0\0\0\0\0\0\0\0\0\0\x7f\0\0\0\xc6\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd4\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01a\x01\0\0\0\0\0\0\0\0\0\0\0\0.\0\0\0\0\0(\0\0\0#\0!\0\0\0\0\0\0\0\0\0U\x01\0\0?\x01\0\0\0\0\0\0K\0\0\0v\0\0\0\0\0\x91\0\0\0\0\0\0\0\0\0\0\0\0\0\x9c\0\x95\0\xe9\0\0\0\0\0\xbd\x01\0\0\xb0\x01\0\0\xc1\x01\0\0\xde\x02)\x01(\x01\0\0\0\0\0\0\0\0\x1f\x01\x1e\x01Q\x01\0\0\0\0Y\x01\0\0Z\x01\0\0\0\0\xb0\x01L\0\0\0\0\0\0\0%\x01#\x01\0\0!\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xc4\x01\0\0\0\0o\0m\0\0\0\0\0\xa7\x01\0\0\0\0!\x02(\x02\0\0\x14\x02*\x02\0\0\0\0\0\0\0\x009\x02\0\0\0\0\x1c\x02\0\0\x11\x02\0\x003\x02\xa4\x02\xa3\x01\0\0\0\0\x96\x01\x95\x01$\x01\"\x01 \x01\0\0\xcc\x01\xca\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xae\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x87\0\0\0\0\0\0\0\x89\0y\0}\0\0\0\xd7\x015\x02\xd3\x01\0\0\0\0\x93\x02\x92\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd2\0\0\0^\x01\0\0]\x01\0\0\0\0,\0\0\0-\0\0\0%\0$\0\0\0\xec\x02\0\0\0\0\0\0>\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x9b\0\0\0\xc0\x01\0\0\xb6\x01\0\0\0\0\0\0\0\0\0\0\0\0\xcd\x01\xce\x01\0\0\0\0\x95\x02\0\0\xef\0:\x019\x012\x011\x01.\x01-\x01\0\0\0\0\0\0\0\0\0\0X\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xee\x01r\0\0\0\0\0s\0\0\0\0\0$\x02\x18\x02+\x02\xfa\x01\xf6\x01\0\0\0\0\0\0\0\0\x9a\x01\x99\x01\0\0\x82\x02\xb2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb6\0\0\0\0\0\0\0\xb1\0\0\0\0\0\0\0\0\0\x83\0\0\0\0\0\0\0\0\0\x86\0\0\0\xa9\x01\xaa\x01\0\0\xe6\0\0\0\xd9\0\xd0\0\xce\0\0\0\0\0\0\0\0\0\x18\0\0\0)\0+\0\xe2\0\xe3\0\0\0\x92\0\0\0\x99\0\0\0\x9a\0\0\0\0\0\0\0\x98\0\x97\x02\0\0\0\0\0\0\x97\0\0\0\0\0\0\0\0\0\0\0\xcf\x01\0\0\0\0\xad\x01\0\0\0\0\0\0\xe0\x01\xe1\x01\xe2\x01\xe3\x01A\x01\0\0M\x01\0\0\0\0\0\0R\x01\xae\x01z\0\0\0\0\0\0\0\0\0\xc5\0\0\0\0\0\xc5\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe6\x01\xe7\x01\0\0)\x02\0\0\x1f\x02\0\0\xc9\0\0\0\0\0\0\0\0\0\0\0\xb0\0\xaf\0\0\0\0\0\0\0\0\0\xac\0/\x02\0\0\0\0\x81\0\0\0\x8f\0\0\0\x8e\0\x8b\0\x8a\0\0\0\0\0b\x01_\x01\0\0\xf2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb9\x01\0\0\0\0\0\0\xd9\x01\0\0\xd0\x01\0\0\xaf\x01\0\0\0\0\0\0\xde\x01\xe4\x01\xe5\x01@\x01\0\0\0\0[\x01\xca\0\xf0\x01\xf4\x01\xb0\x01l\0\0\0\xdf\x01\xe8\x01\xc6\0\0\0~\x01}\x01\x83\x02\xad\0\0\0\xb4\0\0\0\0\0\0\0\0\0\0\0\xbd\0\xb7\0\xaa\0\0\0\0\0\x88\0\0\0\0\0*\0\x9d\0\x96\0\0\0\0\0\0\0\xa5\0\0\0\0\0\0\0\0\0\xd1\x01\0\0\0\0\0\0\xb7\x01\xdb\x01\0\0\0\0\0\0\0\0\xe9\x01\0\0O\x01\0\0\xab\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xbc\0\0\0\x8d\0\x8c\0\xf0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa1\0\0\0\0\0\0\0\0\0\0\0\xea\x01\xeb\x01P\x01\xbb\0\xb8\0\x9d\x02\x9e\x02\0\0\0\0\0\0\0\0\xb9\0\xa9\0\xa3\0\xa4\0\0\0\0\0\0\0\0\0\xa2\0\xba\x01\0\0\xec\x01\0\0\0\0\0\0\0\0\0\0\xa6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xba\0\0\0\0\0\0\0\xdd\x01\xa7\0",
  dgoto: "\b\x008\0e\0{\0\x83\0\x95\0\x9f\0\xad\x007\x02f\0|\0\x84\0:\0Q\x01\x7f\0;\0\x87\0\x88\0\xc1\x01\xe9\x01N\x02\x16\x03\x93\x01 \x02\xd7\0<\0=\0\xbf\x02n\x01>\0?\0\xa1\0A\0B\0C\0D\0E\0F\0G\0H\0I\0J\0K\0L\0M\0O\x02N\0u\x01\x95\x01x\x03n\0o\0p\0O\0r\0s\0t\0u\0v\0H\x01\xa2\x02w\0\xa1\x01B\x03\x96\x01P\0w\x01\xc7\0\n\x02\xbb\x03Y\x04L\x04\r\x03\xef\x02\xdf\x04Z\x04\x83\x01\xc2\x01[\x04R\x02S\x02J\x03\xf1\x03U\x05\x8c\x04\x89\x04\x85\x04Q\0_\x05b\x03\xb9\x05\x96\x04c\x03\xa7\x04M\x04N\x04O\x04\xd5\x04\xd6\x04>\x05\x86\x05\xaf\x05\xab\x05e\x05x\0\xa3\x01R\0y\x01\xc7\x03j\x04\xc8\x03\xc6\x03\x05\x03\xb1\0S\0\"\x01\xb7\x01\x10\x03\x0e\x03T\0U\0V\0f\x04W\0X\0\xde\0Y\0Z\0\xdf\0\xe8\x000\x02\xe5\0\x85\x01\x86\x01\x8f\x02\x7f\x02[\0d\x03\xba\x05\xb6\0\\\0q\x01=\x02\x11\x03\xe0\0\xe1\0\xb7\0\xb8\0\x98\0\xdb\x01\xde\x01\xdc\x01c\x04]\0s\x01M\x01Y\x02\xf7\x03\x9b\x04\x97\x04`\x05Z\x02N\x03[\x02S\x03\x1d\x04\xf1\x02\xb8\x03\x98\x04\x99\x04\x9a\x04\x0f\x02\x03\x02\xf4\x02P\x04a\x05b\x05\x92\x03\x12\x05.\x05\x13\x05\x14\x05\x15\x05\x16\x05y\x03*\x05\x99\0\x9a\0\x9b\0\x9c\0\x9d\0\x9e\0\xbd\x01\xb1\x02\xb2\x02\xb3\x02-\x044\x045\x04\x8b\x03*\x04\xf7\x02\xbe\x01?\x01\x1d\x01\x1e\x018\x02R\x01",
  sindex: "\x14\b\xd9>\x9d\x06p,\x05,k\x0f\x90@\x96D\0\0\x84\x04l\x02WF\x84\x04\0\0\xca\x01e\0\x11\x01\0\0\0\0\x84\x04\x84\x04\x84\x04\x84\x04\x19\x03\0\0\0\0\0\0\x84\x04\x96FR\xff1?\x8b?\xdb:\xdb:\x1d\x05\0\0\xb87\xdb:\x84\x04\0\0\0\0\xe8\x04\0\0\x84\x04\x84\x04\x8e\xff\0\0\0\0WF\xd9>\0\0\0\0\x84\x04\xb9\xff\0\0\x84\x04\0\0(\x01/\0\x9b\x0b\x18\0\xd9G\0\0\0\0\xf6\x02\0\x008\0\0\0\0\0\0\0\xde\x01\0\0\0\0\"\x027\x02\0\0/\0\0\0\0\0\0\0\0\x000\x02\0\0\xd9E\x9b\0WFWF\x90@\x90@\0\0\0\0\0\0\0\0\0\0\xca\x01e\0\x18\x04B\x05\x9d\x06\xb9\xff\x11\x01\0\0\x88\x03\0\x008\0\0\0\0\x007\x02/\0\0\0\x9d\x06\0\0\0\0\0\0\0\0\0\0\x87\x02\0\0\x9e\x02\0\0\0\0\0\0l\x02\0\0<\x02`\x02/\0\0\0\xe3\x02\0\0\xe4,\0\0R\x04/\0R\x04\0\0\0\0\x0b\t\xd5\x02\xac\xff\x87\x04\n\x03\x85Ik\x0f\x8c\x03l\x02\xf3\x02\0\0\0\0\0\0L\0\0\0\0\0\0\0\xd4\x01\x13\0\0\0\x90\x03\xb6\x02\0\0+\x05\xf6\x02\x96D\x96E\x18\x03\x87C\xcdC\0\0\x90;f\x03\xb7\x03\x1c\x03\0\0\0\0J\0$\x04\0\0\0\0\x96D\x96D\0\0\0\0\0\0U\x04\x98\x04\xdb:\xdb:S\x04WF\0\0\0\0\0\0(8\0\0\0\0\0\0\xe2?\xcf\x03\0\0~\x04\0\0\0\0X\x04\0\0\0\0O\x02\x98G\xbd\x04\x96D\xc7B\xd5\x02\x90@\x95\x04o\x02\xd9>[\x05$\x04\0\0WF\0\0\xd9\x04\x0e\x01\xe5\x04\x91\xff\0\0\x93\x04\0\0\0\0\xea\x04\xa1\x04\0\0\x95H\xbe\x04\0\0\xbe\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x10\x05\x80>\x80>\x84\x04\x8e\xff\xd5\x04\0\0\0\0\0\0WF\0\0\xe1\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb3\0\0\0\0\0\0\0\0\0\0\0WF\0\0\0\0\0\0)\0v\xff\x80>\x90@\xcc\x04l\x02\xc1\x02\xf3\x02\b\x05\0\0\xe2\x04\0\0\0\0\x90@\0\0\xb9\x04\x90@\0\0\xdb:\x9b\x0b/\0\x84\x04\0\0W\x05\t\x06\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\x90@\0\0\x96D\x90@\0\0\xb9\x04\0\0\xfa\x04\0\0\xcf\x03\0\0\xcf\x03\0\0\0\0\x90@\x1f\x04WFWF6\x05;\x05WF6\x05\x18Fb\x01\0\0\0\0\x90@b\x01b\x01\0\0\0\0~\x04\x98\x01\x95\x04\x18\x04\x02\x05\x9d\x06\0\0;\x02\0\0\0\0\0\0\xad\x02\x1b\x05J\x03\0\0\xb9\x04\x80\x05\0\0\0\0\0\x003\x05\0\0\xcf\x03\0\0B\x06\0\0\0\0\0\0\0\0\0\0R\x04/\0R\x04\0\0R\x04\0\0I\f\0\0\x19\x04\0\0M\x05\xa5\x05\0\0I\f\0\0I\f\0\0\0\0\xab\x05\x97\x05]\x05k\x0f;\x03S\x04\x1d\x01{\x05\xba\x05\0\0\0\0\xb6\x05\0\0\0\0\0\0=\x03`\x05x\x05k\x0f_\x07\xf3\x02\0\0\0\0\0\0T=\0\0\0\0\0\0\0\0\xbf\x05\xbb\x05@\0z\x05\xf9\x03}\x05\0\0}\x05\0\0\x86\x05f\x03\0\0\x87\xff\xb7\x03\0\0\0\0\x81\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0,\x02\x94=\xd4=\x14>\0\0\0\0\x8b\x05\0\0\0\0\x96D\xc0\x02\x80>S\x04S\x04\0\0b\x01\xd0\x04\0\0\xf5\x02~\x04*\x04\xad\x05\0\0\x03't\x01\x03'S\x04\0\0\xec\x05\0\0k\x0f+\x03\x96E\x01<d\x02D\x05d\x05GB\0\0\x96D\x95\x05\x0e\x05\0\0\x0b\x01\x90@\x8b\x01\xa7\x03\xd6\x03\0\0\0\0b\x01|\x06\x18\x03\x90@\0\0\0\0\x18\x03\x90@;\x05\xc7\x03\x90@\xbb\xffz\xff\xdb:k\x0f\x96D\0\0\xa4\x05\xa6\x05\x94\x05\x84\x04\0\0\x96D\xc3\x05\0\0v\x01\0\0\x98\x0b\xd6\f\0\0\xaa\x05\0\0\0\0\xa8\x05\x96\x05\xc1\x02\xf1\x05\x18\x04\x19\x03\xc1\x02/\0\0\0\x96D5\x04\0\0l\x03\x9c\x05*\x04\0\0\0\0b\x03\0\0\xef\0\xfe\x05\x80>\0\0\0\0\x96F;\x05\x90@\x90@\x988\0\0\0\0\x86I\x86IQI\x1a\x07\x95HQI\x8f\f\x8f\f\x8f\f\x8f\f\xa5\x02\xe5\x05\xe5\x05\x8f\f\xa5\x02\xa5\x02QI\xe5\x05\xa5\x02\xa5\x02\xa5\x02\0\0\xe5\x05\x0f\x05/\0>A\x06\x06\0\0\xd5\x05\xc1\x02~\x04~\x04\x95H\x90@\x90@\x90@\xd9\x05b\x01b\x01\0\0\0\0\0\0\x01\x06\0\0\0\0QI\xdd\x05\x13\x05\x8f\xff\xc9\x05H\x04\xfe\x03\0\0\0\0m\x03\x14\x06\x18\x04\xe2\x04\xd8\x02/\0b\x03k\x0f\x18\x06~\x04\0\0\0\0\0\0\0\0\x11\x06\0\0\0\0R\x04\0\0\0\0\0\0\xda\0\0\0)\x06\0\0\0\0I\f\xbf\0\x19\x01\x1d\x10\0\0\xec\x01\0\0\xe2\x05\xda\x05\xc4\x05k\x0f/\x03k\x0fk\x0fu\x03\0\0\0\0\xbb\x01l\x02\xf2\x05\0\0\xd7\x05\0\0\x81\x03\x96D\0\0\0\0 \x03\x96D \0?\x03\x04\x06\"\x01\0\0\x9c\r\0\0\0\0\0\0\0\0\xaa\x02\0\x004\x06\0\0`\xff`\xff\0\0\xe9\x05\0\0\0\0\x90@\x90@\x90@\0\0\0\0\0\0\x07\x06\xbb\0\xf0\x05\0\0\xc4A\x85I\x03\x06\0\0\xb6\x02\xe8\x05\xf4\x05\xef\x05S\x04\0\0\0\0/\0\xc2\x01\x90@\0\0\x0f\x06\0\0\x96D\0\0\0\0\0\0\x17\x06\0\0\x17\x06\0\0r<\x90@GB\0\0\x1d\0Q\x06\0\0\x90@\0\0\0\0\0\0L\x06\x19\x03\0\0iG\0\0\x18\x04\0\0\0\0\0\0\0\0\xfd\0\0\0\0\0\x95H\0\0\x95HA\x06\0\0\0\0\x95H\0\0\0\0\0\0\0\0\0\0S\x04y\xff\0\0\0\0\xc1\x02\xe2\x04/\0\x90@\x94\xff\0\0\0\0\x10\x02\0\0S\x04\0\0\0\0\xd5\x02/\0\x18\x04/\0+\x01p\x05\0\0\0\x005\x02\0\0\0\0+\x02\0\0\x83\x05\0\x008\x01C\x06\x05\x06l\x02\0\0\0\0\x90@\x0b\x06S\0\xa1\x04\xbe\x04\xbe\x04\xb3\0\xa6\xff\x90@\0\0$\x0b\x90@\xe3<\x81AD\x06\0\0\0\0k\x0fC\x06/\0!\x06$\x06\xf9G\x03\x05E\0\xae\xff\x90@Y\x06\x18\x04\0\0\0\0\x19\x03\0\0\0\0\xfc\x05\xc2\x04i\x06\0\0\0\0\0\0\x18\x04$\x02l\x03v\x02c\x06\0\0\x1a\x06s\x05\x18\x048\x06\xe2\xff\0\0I\f\0\0\0\0k\x0f@\x01t\x06\0\0\0\0l\x02+\0S\x04\0\0\0\0k\x0f\0\0\x0e\x06S\x04\xf3\x02\0\0\xf2\x055\x06\0\0\x13\x06\0\0\0\0_\x07\0\0\xf9\x03&\x06\0\0\xf9\x03\0\0\0\0\0\0\0\0\x96D;\x03\0\0\0\0\xcd\xff\0\x007H\xb6\0\xd9\xffj\x06*\x04\0\0l\x02\0\0a\n\x9c\x04/\0\xc4A^\x01\x8d.\x03'/\0\0\0%\x06\x07\0(\x06\xcb\x03r\x06r\x06\x80\x06/\x06O\x06\0\0\0\0\x90@\x90@\x96DWH\x18\x04p\x05\0\0\x9c\xff\x9d\xff\0\0\xa0\xff\0\0\0\0\x90@\x90@l\x06\x18\x05\0\0\xb5H\0\x001\x06k\x0f\x96D\0\0$\x02\0\0\x19\x03k\x0f\0\0k\x0f\x8e\xff\x90@\x8e\xffu\xff/\0\0\0\0\0\0\0\x96D*\x04\0\0\xe3F\0\0<\x06\0\0\x82\x06\0\0\0\0\0\x003\x04\xeb\0>\x05U\x02\0\0\0\0\0\0Z\x06T\x01\0\0d\x06\0\0\x90@\xa3\x02\0\0\0\0\xc4A\x81\x06g\x06\0\0\0\0h\x06\0\0m\x06\x95Ha\n$\x02p\x05\x98\x06\x90\0*\x04\x96\x03\0\0\xfe\x03;\x02\0\0\0\0\x18\x04<\x06\0\0;\x02\x9f\x06\0\0\0\0.\x02\0\0\0\0A\x01\0\0k\x0fl\x02\0\0\xf2\x05\x18\x03\0\0\xac\x06\0\0k\x0f\0\0\0\0\0\0%\x04Z\0\0\0\0\0\0\0\0\0\0\0\f\x03\0\0\0\0r\x0e\xa8\x06\x85Iv\x06\x8d.z\x06\0\0\xa1\x06S\x04x\x06\0\0]\x06*\x03\xb6\x02\x07Ck\x0f\x9c\x04\b\x05\0\0P\x04S\x04\x18F\0\0\0\0\0\0/\x03\0\0\0\0\0\0%\x06/\0\0\0\0\0\x90@GBk\x0f\x90@`\x06e\x06k\x0f\0\0k\x06\0\0}\x06\0\0\x90@%\xff\0\0O\xff\0\0n\x06\0\0\0\0\x95H\0\0\x90@\x90@\x90@\0\0S\x04Q\x06p\x05;\xff\xff\x02/\0\x9c\x04/\0\0\x03/\0\x85\x06\x87\x06/\0\0\0Q\x06\0\0e\0\0\0\xdb0\"G\0\0o\x03\x8e\x06\xc0\x06\0\0\0\0\x98\x01\x01\x02\0\0%\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa9\xffZ\x06\xb3\x06k\x0fw\x06\0\0\x90@\x01\x02/\0\f\x03\x90@\x90@\x90@/\0`\x05`\x05\x95\x01\0\0\xbd\x06\xbb\x06\0\0\0\0\xde\x02y\x01\0\0a\nk\x0f\0\0\0\0\0\0\0\0\0\0\xc1\x06\x0e\x06\xf2\x05\x14>\0\0\0\0k\x0f\0\0\0\0s\x05\x99\x03W\x01\x90\x03\x8d.\x9f\x01k\x0f\x89\x04\0\0\x91\x06\xcf\x06\x9c\x04\0\0a\n\x03'\xb3\x03\x87B\0\0a\x01\xdf\xff\x90\x04\x9c\x04\0\0\x18F\0\0\0\0\xca\x06\0\0S\x04\0\0\0\0\0\0S\x04GB\x90@\x95H\0\0;\x03\0\0\0\0\0\0\0\0\x13I\0\0k\x0f\0\0\xc3\x01\0\0q\x06<\x06;\x05\0\0\0\0;\x05{\x06;\x05\0\0\x98\x01S\x04\xc0\x06\xc0\x01\x85\x06\0\0S\x04k\x0f\0\0e\0^\x02 \x02\0\0\0\0\0\0\0\0\0\0\x84\x06\0\0k\x0f\x92\x03\x81A\0\0\0\0\0\0s\x05\x95H\x95H\x95H\0\0\xf0\x03\xf0\x03\0\0k\x0f\x86\x06k\x0fv\x02e\0\x98\x01G\x02\0\0\0\0/\0\0\0k\x0f\0\0\x1f\x01\0\0\xce\x03\xd0\x03\x9c\x06/\x03W\0\0\0\0\0m\x01a\n\x8d.S\x04\0\0\0\0\0\0\x9c\x04\0\0\xf3\x02\0\0a\n\0\0\0\0\0\0S\x04\x90@\0\0\0\0\x8a\x06\0\0S\x04\xab\x06/\0;\x05;\x05\x07B\xe2\x06;\x05\f\x05S\x04\0\0\xcf\0;\x05\x94\x06\0\0\x85\x06\0\0\xdd\x03\0\0\x7f\x02t\x01S\x04\0\0\0\0\0\0\0\0\xe5\x03\x90@\0\0\0\0\0\0\0\0\0\0\0\0\x98\x01\0\0\0\0\0\0S\x04\0\0\0\0\0\0\0\0a\n\0\0k\x0f\f\x03:\x04\xba\x02/\0\0\0\0\0\0\0\xb2\x06S\x04\0\0l\0\xec\x06\0\0\0\0\0\0\xf4\x06\xf5\x06\xbdF\0\0k\x0f\xf8\x06\x90@\xef\x06\0\0\x85\x06\xc0\x06\xf9\x06\0\0\0\0k\x0ft\x01S\x04S\x04\0\0\x90@\0\0\xfa\x06\0\0/\0s\x05\xaa\x06\xb5\x06;\x05\xcf\x03\x85\x06\x0f\x07/\0\0\0a\n\0\0\0\0\0\0\x1d\x10\x1d\x10Z\x06S\x04\x06\x07\xac\x01S\x04k\x0f\0\0\x90@\xc5\x06\x1d\x10S\x04S\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15\x07;\x05;\x05k\x0f\0\0\0\0\0\0\0\0\x11\x07\x90@k\x0fS\x04\0\0\0\0S\x04\0\0\x1d\x10\x1c\x07\x1e\x07S\x04k\x0f\0\0S\x04\xcd\x06/\0k\x0fk\x0f\x04\x04S\x04\0\0S\x04S\x04\x90@\0\0\0\0",
  rindex: "\0\0/\b0\b\xd0\x06\0\0\0\0\0\0\0\0\0\0\xd5F\0\0\0\x009@\0\0s\x03\0\0\0\0\0\0\0\0\xd6DGC\x10D\xe7@\0\0\0\0\0\0\0\0\xd5F\0\0\0\0\0\0\0\0\0\0\0\0PD\xea\x10\0\0\0\0\xe7@\0\0\0\0\0\0\0\0\xf7\x03\xed\x01\xc2\x06\0\0\0\0\0\0G\0\0\0\0\0\xe7@\xd4\x03\0\0\xe7@\0\0\0\0\xe2\tG\0f\x11\x9a&\0\0\0\0@6\0\0g6\0\0\0\0\0\0\x936\0\0\0\0\xc06\xd66\0\0\xdf6\0\0\0\0\0\0\0\0\0\0\0\0\xfb\x16s\x17\x0e\x16\x84\x16\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\x03\0\0\0\0\0\0n\0\xd4\x03\0\0\0\0\0\0\0\0y\x0e\0\0\0\0?1\xb51\0\0n\0\0\0\0\0\0\0\0\0\0\0\xf02\0\0Y3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd1\x06\0\0\xd0\x06\0\0\0\0\0\0\0\0\x7f\x04\0\0\0\0\0\0\0\0<\r<\r\0\0\n'\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0%\x0f\0\0\xed'R(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0V-\0\0\0\0\xa4\x02 \x06\0\0\0\0\0\0\x95\x06\xc8-\0\0\0\0\x039\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\x03\0\0\xfc\x06\0\0\0\0\0\0\0\0\0\0\xf84\0\0\0\0\0\0\0\0\x16E\0\0\0\0\0\0\xc5\x04\xdf6\xf3\x05\0\0\0\0`\x01\x9b\x04\0\0\xc9\xff\0\0\0\0[\0\0\0\0\0\0\0\x82\x04\0\0^\0\xfe\0\0\0\\\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0C7\xd7\x06\xd7\x06\xc7\x06\"\x04VE\0\0\0\0\0\0\x97\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0u9\xcd9\0\0\0\0\0\0%:}:\0\0\x99\0\0\0\0\0\0\0\0\0\0\0\xd7\x06\0\0\0\0\0\0\0\0\0\0[\x06\0\0\0\0\0\0\0\0\0\0\0\0\xf8\x02\0\0\0\0\0\0G\0\xf7/PD\0\0@6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xca\x1f\0\0\0\0\0\0\0\0\0\x002\x03\0\0\0\0\0\0s\x03\0\0s\x03\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\x11\xa9\x14\0\0\0\0\0\0\xe9\x17_\x18\0\0\0\0\xfc\x06\x8a\n\0\0\0\0\0\0\xd6\x04\xca\x07\xb51\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf8\x02\0\0\0\0\0\0\0\0\0\0\0\0s\x03\0\0o\x07\0\0\0\0\0\0\0\0\0\0\0\0\x7f\x04\0\0\0\0\0\0\0\0\0\0\0\0G\x01\0\x000\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x1b\x07\0\0\0\0\x90\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xca\xff\0\0\x96\0\xa8\0\xfe\0\0\0\\\x05\0\0\0\0\xc9\0\0\0\0\0\xca\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd7\x06\x039\x95+\0\0\xd7\x18\0\0\0\0\0\0\xfc\x06\xe4\x06\0\0\0\0\0\0\0\0\0\0\xac\x0b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0M\x19\0\0\0\0\0\0\0\0\0\0\x0f\x01\0\0\xa9\x04\0\0\xa1\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xc7\x06\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13'\0\0\0\0\0\0\xdf6\0\0\0\0\0\0\0\0z4\0\0/\x04\0\0\0\0\0\0\0\0\0\0\0\0\xd7\x06\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x85\"\xf4\"P\t\x7f\x05\xcf\x0f^#@ \xb7 .!\xa4!\x02\x1d\xc3\x19:\x1a\x1b\"x\x1d\xef\x1d\xc8#\xb0\x1af\x1e\xdc\x1eS\x1f\0\0'\x1b\0\0F5\xaf\x04i\x05\0\0\0\0\0\0\xfc\x06\xfc\x06Z\x10\0\0\0\0\0\0W\x12!\x15\x98\x15\0\0\0\0\0\0\xce\x12\0\0\0\x002$\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb51\0\0\0\0\0\0\xfc\x06\0\0\0\0\0\0\0\0\x11\f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x036\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x1d\x07\0\0\0\0\0\0\x99\xff\0\0\xb7(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83)\0\0\x1e)\0\0\0\0\0\0\0\0\0\0\x1c\x01\xa1\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\x04\0\0\t\n\0\0\xc6\x03+\b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0.0z0\0\0\0\0\0\0\xcb5\0\0\0\0z4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x9e\x1b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0o\x01\0\0\xdb\xff\0\0\xa9\0\0\0\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\0\0\xe0\x06\xe5\x06\0\0\0\0\0\0\0\0F5\0\0\0\0\0\0\0\x005\x01\0\0\xb9\x01\0\0\0\0\x16E\x0e6\0\0z4\0\0\x904\0\0\0\0\0\0\0\0\0\0\xdb\x04\0\0\x16E\0\0\0\0\xcd1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x04\xfe\0\\\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0v2\x0e6\0\0\0\0\0\0\xf3H\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa1\x02\x80\x03\0\0\xf3\n\0\0\0\0D\r\xb51\0\0\0\0\0\0\0\0\xb51\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x1b\x02\0\0\0\0\0\0\0\0\0\0\x99\x01\0\0\0\0\xe8)\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\0,\x01\0\0\xf6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\x06\0\0\0\0\0\0\0\0\0\0\x0e6\0\0\0\0\0\0\0\0\xdf6\0\0\0\0\0\0\0\0\xc7\x01\xea\x06\xea\x06\xd7\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0}'\0\0\xf7\x06\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe03\0\0\0\0\0\0\0\0\0\0\xf5\x04\0\0,\xff\xe7\x04:\b\0\0\0\0\0\0\0\0/\x04\0\0\x18\x07\0\0\b\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0D\x13\0\0\0\0\xbc\x13\0\x003\x14\x97$\0\0\xff1!+r\x04\0\0\xe4\x06\0\0\0\0\0\0\xe9\r\0\0\0\0\0\0\b\x02\0\0\xe9\r\0\0\0\0\0\0G\x01\0\0\0\0\0\0A;\0\0\0\0\0\0O*\0\0\0\0\xac\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0E/\0\0\xd8\x05\0\0\0\0\x80/\0\0\xc0\b\0\0\0\0\x01\x07\0\0\x8b0\0\0\0\0\0\0[\x06\0\0\0\0\\5\x14.\0\0\0\0\0\0\xe70\0\0\0\0\0\0\x124z4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb5\0\0\0\0\0\0\0\0\0\0\0\xdb\x01\x14\x1c\xbd4\0\0\0\0:\b\0\0:\b\x0e\x07:\b\x12\x07\x12\x07:\b\0\0\x8b\x1c\0\0\0\0\0\0\0\0 \x07\x9d.\xb12\0\0\xec2\0\0\0\0\x831M4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0:\x07\0\0\0\0\0\0\0\0\0\0M4\x0e6\0\0\0\0\0\0\0\0\xe9\r\0\0\0\0\0\x004\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb4*\0\0\0\0\0\0\0\0\0\0\0\0M4\0\0\0\0\r\x03\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0O.\0\0\0\0\0\0\0\0\xf2\x01\0\0\0\0\0\0\t\x02\0\0\0\0\xfc$\0\0\0\0\0\0\0\0\0\0\0\0V\x01\0\0\0\0\0\x006\x02\0\0\x13\x07\x0e\x07\0\0\0\0\0\0\0\0%\x07\0\0\0\0\x831'3j3\xf3\x01\x12\x07\0\0:2\0\0\0\0\0\0\xef4\xdf6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0M4f%\xcb%0&\0\0P\f\xdd\f\0\0\0\0&A\0\0\0\0\0\0D\x07\xb51\0\0\0\0\xe9\r\0\0\0\0\0\0\xfa\x03\0\0\0\0\0\0\0\x0051\0\0\0\0\0\0\xe3\x04\0\0\0\0r5\0\0\0\0\xbb/\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd8.\0\0\0\0\0\0\0\0\0\0\t\x05\0\0:\b\0\0\0\0\0\0\0\0\0\0\0\0:2\0\0\0\0\0\0\0\0\0\0E\x02\0\0\0\0\0\0\xef4\0\0\xd73\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0D\x07\0\0\0\0\0\0\xbe\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0&\x07\0\0\xe3\t\0\0\0\0\0\0\0\0\x13/\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x12\x07\xa53\0\0\0\0\0\0\0\0\0\0\xd73\xc15\0\0\0\0\0\0,\x0e\0\0\xe3\t\xe3\t-\x072\x07\0\x008\x07\x12\x07\0\0\xe3\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x000\x03\0\0\0\0/\x05\0\0\0\0\0\0\0\0\0\0\xef*\xc15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb4\x05\0\0\0\0\x9b\x02\0\0\0\0\0\0\0\0\xb8\x05\0\0\0\0i\x04\xff\x06\xe3\t\0\0\0\0\0\0\x9f\x04\0\0\xe1\x06\xd3\b\0\0\0\0\0\0",
  gindex: "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\\\0\xf3\xff\0\0V\0\xfd\xff\xe8\x06\xff\x07>\0\0\0\xcc\xff\x87\0?\0[\xff\0\0\x94\xfe\0\x07G\xff\xd2\x07\xa3\x0e\xf3\xfc\x11\0\x16\x04\x0e\x001\x004\0B\0\0\0\0\0\0\0\0\0K\0X\0\0\0a\0\0\0\x02\0\x04\0^\xfe\0\0\0\0S\xfe\0\0\0\0\0\0\0\0c\0\0\0\0\0\0\0\0\0\0\0\xee\xfe\xa0\xfc\0\0\0\0\0\0\x06\0\0\0\0\0\xa4\xff\xcf\xfe\x88\xfe\x12\xfcr\xfcH\xffg\x04\xa8\x03\0\x000\x048\xfds\xff7\x04\0\0\0\0\0\0\0\0\0\0\0\0\x10\x03\xf7\xff\xcc\xfb\xc9\xfe$\xfe\x81\xfc9\x03\x8b\xfb\x1d\xfc\n\xfcZ\x03\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8c\x05\xcd\x04\xa8\x04\0\0\0\0g\xff\x1e\0\xe7\0\x8c\xff\x05\x02\t\xfd]\xff\xbe\b1\x0b\0\0\0\0\0\0j\xff\xfb\x06\x8e\f>\x06\x01\0V\xffI\x06\x86\xfe\0\0\"\x07p\x06\xd6\x0b\xbd\xfcX\xfd\xd4\xfe\0\0\0\0\0\0\xdc\x04L\x04\0\0\0\0\xa6\x06w\xff\xdc\x05\n\b\0\0O\x04\0\0\0\0P\bI\x02P\x05-\xfc\xb8\xfb\xf4\xfc\xd2\xfd\0\0\x0f\xfe\0\0\0\0\xea\xff\0\0\0\0\xeb\xfb\xf9\xff\xf0\xfbi\xfe\xfe\xfd\"\xfe\0\0\0\0\xf7\x02\0\0\0\0\xfc\x03\xa0\xfb\0\0\xaa\x03\x9a\x04\0\0s\xfd\x03\f~\xff\0\0\t\0C\xfe\n\x06\x88\xff\xd7\xfe\x82\xff\0\0\xfd\x03\0\0\0\0\0\0\xee\x06\0\0\0\0\0\0\x1a\x005\xff\0\0",
  tablesize: 19189,
  table: "~\0\x85\0\x8c\x01\xa0\0l\0\xc8\x01m\0E\x02\xcd\0\x93\x02\xd5\x01\xb5\x01\xfb\x02\xc3\x01\xda\x01;\x02\xbf\0\xb4\x01\x91\x03\xc0\x02\xe4\0\xd1\x01\xcc\x03\xb9\x01\xf0\x02\x1a\x02\xbb\0\xb5\x02\"\x02\xbb\0\t\x04\"\x04\xea\0>\x01\xf4\x01\x97\x02\xbb\0\xbb\0\xbb\0\xbb\0M\x03\xc1\0\xe1\x03\xbd\x03\xbb\0\x93\x03\xf5\x02\x1f\x02\xfc\x02\x19\x05@\0\xbb\0@\0@\0g\0\xbb\0\x1b\x02\xac\x04\xdd\0\x1f\x01\xbb\0\xbb\x002\x02@\x013\x02\x80\0\x86\0\x81\x02h\0\xbb\0\xae\x003\0\xbb\0T\x01\xf9\x01\t\x05\xc9\x01i\0I\x01\xf6\x02\xad\x01\xf6\x02\xaf\x01\xd7\x049\x02\x9a\x01\x03\x05\x05\x05\x8d\x01}\0j\0\x95\x020\x059\0\x1c\x02\xce\x04\xf3\x04\x9f\x01@\0k\0l\0q\0m\0\xe1\x04\xb9\0\b\x02\xe6\x02\xe7\x02U\x01\x9f\x02W\0\xf7\x01l\0\x84\x01m\0\x88\x01\x89\x01H\x02F\x02\xe2\0\xfd\x02\x9d\x04,\x03@\x02G\x01\xf5\x01\xb9\0\xab\x01\xa4\x01\xf6\x01\f\x05\xbc\x01-\x03\xf2\x04\x9f\x02?\x02\xf7\x01\xb2\x04\r\x05\xf8\x01\x96\0J\x01\xb8\x02q\x03\xb9\x02+\x02\xb3\x01\xe3\0\xe0\x03G\x01g\0\xc5\x01\xfc\x04\x1b\x02\x9a\x02\xf9\x04t\x04v\x04\x9f\x02<\x04x\x04\xa4\x02g\0\xb9\0h\0\xbc\x04\x02\x04\xca\x01@\x03\x17\x05\x1b\x02\xa4\x02E\x03i\0\x14\x04\xf4\x04h\0U\x01j\x05@\0\xb6\x01U\x01\x06\x04U\x01P\x02i\0j\0*\x03\xb9\0>\x01\x80\0\xfa\x01\xac\x01\x07\x02\x86\0k\0\x86\0q\0j\0u\x04w\x04k\x01\xa6\x01 \x05\x02\x02=\x04w\x05k\0\x1d\x02q\0\xb9\0\0\x02\x01\x02\xbd\0G\x02\xee\x02\xaa\x01\x14\x04\x04\x02j\x019\x05\xbd\0\xbd\0H\x05C\x03\xd3\x01g\x03\xb9\0\xdd\x01\xdd\x01\x8b\x02\x8a\x04&\x02\x1f\x02\xbd\0A\x05\xdb\x03I\x05,\x02r\x03\xbc\0\xfc\x01\xfd\x01\xc4\0\f\x05M\x05\xd7\x02\\\x05'\x02\x1b\x02\xd0\0\xd1\0\xd2\0\xd3\0)\x04\xa4\x02y\x04h\x05\xda\0\x92\x01\x9a\x02\xa5\x01\x03\x04@\0L\x01\0\x05\xb8\x01\x92\x01\x92\x01A\x01\x15\x04\x14\x02\xb9\0\x81\x02E\x01F\x01\xbd\x02\x9a\x02\x9a\x05\xcd\x01\x92\x01+\x03\x85\x02K\x01\x86\x02h\x05N\x01d\x04\xa7\x03\xf5\x01\xb9\0\xa7\0\xce\0\xf6\x01k\x01\xa6\x01O\x01A\x02k\x01\xa6\x01\xf7\x01>\x04V\x01\xf8\x011\x05\xbb\0#\x02}\x03\xd4\x02\xe5\x02\xd5\x02B\x02j\x01A\x04C\x02r\x01j\x01\xbe\x02I\x02J\x05\xd0\x02/\x04\xd2\x05\xcd\x02\xc1\0\x12\x04\xa6\x023\0U\x02K\x02\x88\x05\\\x02\xca\x02B\x05\xf5\x01@\0@\0e\x02\xf6\x01\xfc\x03h\x03i\x03\xa0\x05\x89\x05I\x01\xf7\x01\xc9\x04g\x01\xf8\x01\xce\x01n\x01^\x02\xb9\x003\0\xa5\x01\xc0\x03\xbb\0\xa0\x05\xa5\x01\xcd\x03n\x01|\x02]\x02 \x03\xb2\x05\x82\x02W\0\xeb\x02\xe9\x04@\0e\x04P\x01\xc8\0\x85\x03\xad\x02\x90\x02\xaf\x02\xcc\x05\xb0\x02\x18\x03\0\x03\xd0\x04\xa8\x03\xd3\x04W\x05\x1b\x02U\x01\xc9\0\x99\x02\f\x05\xf0\x020\x04W\0D\x02\xc0\x02^\x05\xe0\x04\xb9\0\x8c\x03\xb9\0\xce\x03\xdc\x03U\x03l\0D\x03m\0\xa1\x01[\x02\x18\x05T\x02\xb9\0\x8c\x02\x8d\x02\xd1\x02\xa8\x05\x91\x02\xa5\x05\x84\x01\xc3\x04\x13\x04\x9c\x023\0\xfb\x01\xca\0\x9f\x01l\x01o\x01\xb4\x04\x1e\x02\x87\x01~\x02\xd7\x03\xfd\x03\x87\x05\x9f\x01?\x02o\x01m\x01\x12\x04\x7f\x05g\x01\xb3\x01\xca\x04\x8b\x05n\x01\x1e\x02\x1d\x02n\x01\xb3\x01\x1d\x02\xb3\x01\x02\x02\xf0\x02g\0\x8f\x04\x88\x03a\x03^\x02\\\x02t\x05\xb3\x05\xb5\x03l\x01\x1d\x02P\x03\xcb\0\xca\x01h\0\xcc\0\xe5\x03\xd4\0\x90\x04\xcb\x02o\x05m\x01U\x01i\0U\x01\xc8\0U\x01_\x04`\x04\x88\x03\x8d\x03\xfa\x01k\x03Q\x05\x1b\x02\x86\0j\0\x86\0\xa1\x04\x86\0\xc9\0\xfa\x01 \0\xa6\x05\x18\x03k\0\xa1\x01q\0\xd5\0\xa0\x01[\x02O\x05T\x02\xfa\x011\x04R\x04\xd8\x03\xa3\x02\xc0\x02\xa0\x01R\x04\xf6\x02\xd0\x04\x18\x04\x99\x05\x9f\x01:\x02o\x01\x9f\x01l\x01o\x01\x1e\x02\xfa\x01\xfa\x01i\x01 \x04\xca\0\x02\x02\x02\x02@\x04\xcb\x02m\x01\xcb\x02&\x04\xb6\x03\x82\x03\xd6\0\xa2\x01\x8e\x03\x1d\x02z\x05\x02\x02\x88\x036\0\xcf\x05\x05\x02\xfa\x01&\x03\xc0\x02\xc0\x02^\x02\\\x02\xf0\x02\xa3\x02\x10\x05\xf7\x01\xc1\x02\xac\x03@\x002\x05&\x02\xc8\0\xde\x02\xe0\x02\xe2\x02\x89\x03\x9a\x03\xbc\x03\xcb\0\xda\x01\xe3\x02\xcc\0$\x02\xb9\0\x9b\x03\x9c\x03\xc9\0]\x04k\x03\xe7\x03\n\0\x88\x03\xa2\x04\xf4\x03Q\x03\xbb\0\x1e\x02.\x03\xe2\x02p\x01&\x02\xa7\0\xce\0\xa0\x01\x17\x03\x9d\x05\xa0\x01\xe4\0\x1b\x02R\x04\x0f\x03\xa3\x02\xd9\x03\xd2\x03R\x03w\x02[\x03\xb9\0X\x03Y\x03s\x04d\x01\xca\0d\x01\xc1\x02\xa8\x04\xe2\x02i\x01\xd1\x01\xb9\0x\x02\xc1\x02\x80\x01\x81\x01\xc1\x02\x1b\x020\x03O\x02\x8f\x03\x05\x02\xa2\x01\x87\x03w\x02~\x02\xc2\x02\xdd\0{\x05\x80\x05,\x05\xad\x03)\x027\x03O\x02l\x03m\x03\xc8\0\xa3\x02x\x02\x1a\x03R\x04\xbf\x05@\0\xfa\x01G\x03\xcb\0\x11\0\xc0\x04\xcc\0p\x01\xad\x04\xc9\0\xf5\x03\x1b\x03\xfe\x02q\x05\x81\x05s\x05+\x04\xc1\x04\x9a\x02\x01\x040\x02{\x03\x89\x01\xe2\x02\f\x02\xb5\x03\x9c\x02a\x03!\x001\x02\xf8\x02\xfe\x03\xff\x03\0\x040\x04\xc1\x02%\0\xbc\x01\x82\x058\x05\xf9\x02\xbb\x04$\x02\xb9\0\x19\x04\xca\0/\x03w\x02^\x04G\x05\xb3\x01w\x02\xd4\x05O\x02O\x02\x80\x01\x81\x01T\x05\x1b\x02:\x03<\x03\xe3\x03x\x02$\x02\xb9\0\xa0\x03x\x02\x9e\x03O\x02O\x02r\x01O\x028\x03]\x05\xf3\x03\x86\x04C\x05\x88\x04\x8b\x04\xc2\x03\x83\x05U\x013\0t\x01\xdd\x006\0O\x02\xcb\0\xb2\x03\xb3\x03\xcc\0\x0e\x02\xcb\x01\x1c\x03\x86\0\xe4\x020\x02\xfa\x010\x02\xfa\x01\xda\0\xfa\x01\xfa\x01'\x05q\x011\x02\xc0\x021\x02:\x04\x94\x02\xc3\x03\xcc\x01\xfc\x02:\x05\xe4\x02R\x04\x94\x02\xba\x01\xbc\x03\xb9\0\xb9\0\xe4\x020\x04\xcb\x03(\x04\x02\x026\x04\xde\0\xa3\x03\xca\x01\x94\x02\x94\x02\xa6\x032\x04\x0e\x05R\x04\xcc\x01\x94\x02\x91\x03r\x01\x9c\x04\x9f\x03\xe4\x02\xe4\x02R\x04\xf6\x02\xfa\x01\xe2\x034\x03\x1b\x02\xdb\0v\x01\x94\x02\xdd\0\x10\x05\x94\x02\xe4\x02\x83\x03\xdb\x02\xe3\0\x82\x04\xe4\x02\xbf\x04&\x02\xe4\x02\x93\x03\xe4\x02\x94\x02\x9e\0\xda\0\xc5\0\xf5\x01x\x01q\x01\xc6\0\xf6\x01\xea\x03\xe2\x02\xca\x01\xfa\x01\xc5\x03\xe8\x03\xf7\x01P\x01\xc0\x02\xf8\x01\x98\x03\x9e\0\x94\x02\xca\x01\xef\x03\xca\x01\xf0\x03,\x05\x9e\0\xfa\x03\xde\0\xb9\0\x9c\x02&\x02\xbc\x03\xf9\x03\xfa\x01\x04\x04\xeb\x03\xec\x03\x07\x04\f\x02\xe4\x02\x94\x02\xaf\x03\x1e\x04\x94\x02\xa5\x04P\x01\x9e\0\x9e\0\xb9\0!\0\xdb\0\r\x02\x93\x02\f\x02\xa7\0\xce\0{\x01%\0\xb9\0\xed\x03\x9e\0\x94\x02\x1b\x02c\x05\x94\x02\xb9\0g\x05\x9e\0\x9e\0\xe2\x02\x9e\0\xb9\0P\x01Q\0\xd8\x02R\x04R\x04\x9f\x02\xf5\x01\x96\x02\xb8\x04\x9d\x01\xf6\x01\xa0\x01P\x01R\x04\f\x02\x9c\x02\xd9\x02\xf7\x01\xb3\x01\xd4\0\xf8\x01\xca\x01\xe9\x03.\x04$\x02\xb9\0\x9a\x02\x9f\x05\xde\x04\xee\x03\xc5\x04\xa5\x01C\x04\x0e\x02\xa2\x01\xda\x01\x02\x02\x89\x01\x02\x03\x03\x03\x9e\0\x89\x01\xca\x018\x04 \0\x89\x01\xbd\0\x89\x01\x0e\x02\x9a\x02\xd5\0\x89\x01\x89\x01\xfa\x01\xc7\x04\x89\x01\xfa\x01\xa1\x02\xf7\x01\x1b\x02\x83\x02\xf8\x01D\x04\xab\x04\x89\x01\xca\x01R\x04\xa6\x01\x9d\x02\xb9\0\x98\x05\x9d\x01\xb5\x018\x04\xd1\x01o\x04p\x04\r\0\xb4\x01\x1b\x02L\x02\x0e\x02\xa2\x05b\x01c\x01\x04\x03\x9a\x03\xfa\x01\xd6\0{\x04\xd0\x05\xd1\x05\xbe\0M\x02\xb6\x016\0\x12\0!\x02\xda\x02\xc3\x01&\x02\xa3\x02:\x03\xb9\0\x89\x01\x9c\x02\x87\x04;\x04X\x04\x0b\x04\xb9\0\x89\x01\xcc\x01\x0e\0\x18\0\x19\0\x1a\0R\x04\xec\x02\x9c\x02\xb1\x01\xe2\x02o\x01h\x01\xe3\0\xe2\x02\xc7\x01\xe2\x05\x0f\0\x10\0\x89\x01\x89\x01\x1e\x02\x89\x01\x89\x01\xac\x05\xaa\x04\xa9\0\xc3\x05\xc4\x05m\x01\x17\0*\0\x0f\x03\xed\x02\xc3\x01,\x02&\x02\x7f\x01\xb7\x04#\x02\xaa\0\x89\x01\xbf\x01\xd0\x01\xfa\x04\x97\0\xca\x01\xb0\0p\x01,\x02!\0\xb9\0\x0f\x03S\x01\x97\x05\x93\0\xde\x042\0%\0\x9c\x02&\x02\xd9\x05\xad\x05\xd9\0)\0\xf5\x01\xf7\x01\x9c\x02\x0f\x03\xf6\x01\xc6\x01-\0\xc4\x04\x9c\x02\x7f\x03\xbb\x01\xf7\x01\x02\x02\xd4\0\xf8\x01+\x05\xa9\x03\xdd\x04\xe1\x05\xb9\0\xf7\x01\xcb\x04\x1b\x02\xff\x02\x80\x03 \0\xaa\x03\xf7\x01\xf7\x01\xfa\x01\xcc\x04\xd1\x04\xeb\x05,\x025\0\x81\0\x9a\x02\xc7\x01 \0\x1b\x02,\x02\x9f\x02\xd8\x01\xfe\x04\xd5\0H\x04\xb1\x01\xda\x04\xf7\x01\xf7\x01\xd8\x016\0\xe8\x04a\x03\xa0\x02\xeb\x04\xbb\x01\xc7\x01\x80\x04\xe4\x04,\x02\xcc\x01\xf7\x01\xb9\0\x83\x04\xb1\x01\x84\x04\xff\x04\xbb\x01\xf7\x01\xf7\x01\x94\x01\xf7\x01\x84\x01\xf6\x04\xf7\x04\x93\0\xbd\0\x95\x04\xc6\x02\xe0\x02Q\0\xd6\0\xfb\x01\x1b\x02\x9c\x02\xea\x01X\x046\x006\0\x07\x05\n\x05\x93\0\xa1\x02Q\0\xc7\x016\0\xa4\x03\xca\x01\x99\x03&\x02\xca\x01\xca\x01\x11\x05\xeb\x01\xec\x01\xed\x01Q\0Q\0Q\0Q\0\x93\0\x97\0a\x03\xf7\x01\xc7\x01O\x03\x97\0\x97\0\xca\x01\x1d\x03\x1d\x05Q\0\x92\x01\x98\x02\xc7\x02n\x05\xbd\x007\x05P\x01\x9a\x03\xb9\0\xee\x01\x98\x02-\x05\x9d\x03X\x04\xb0\0\xb0\0\x8a\x05\xb0\0\xb0\0Q\0\xb0\0\x1b\x02Q\0\x1e\x03\xa2\x03Q\0Q\0Q\0\x9d\x01'\x03\xb0\0\xb0\0\x9d\x01Q\0\x9c\x02\xc4\x01\x9d\x01\xf5\x01\x9d\x01\x93\0Q\0\xf6\x01\x9d\x01\xb9\0\xef\x01\xb6\x04\x9d\x01h\x04\xf7\x01\xcc\x01z\x03\xf8\x01Q\0\xda\x04Q\0\x9d\x01Q\0Q\0e\x02\xcb\x02\xb0\0\xb0\0\xf0\x01\xf1\x01\xf2\x01\xd9\0(\x03P\x05Q\0\xea\x04e\x02Q\0\xe4\x04\xee\x04D\x05Q\0\xcf\x01X\x05\x9e\x05\xd4\0Y\x05\xca\x01[\x05\xf5\x01\x9d\x01\xca\x01\xa3\x05\xf6\x01\x9d\x01\x84\x01\xf3\x016\0\x9e\x035\x05\xf7\x01f\x05X\x04\xf8\x01\x9d\x01\xe4\x04\xb9\0|\x05\x9d\x01\xcc\x04 \0\x7f\x01X\x04\x90\x02\x90\x02\x7f\x01\xd5\0\xca\x01\b\x05\x7f\x01\x90\x02\x7f\x01\x02\x02\xea\x05\xb9\0\x7f\x01\xc7\x02\x9d\x01\x9d\x01u\x05\x9d\x01\x9d\x01\xb9\0\xf5\x01\x90\x02\xd2\x01\xca\x01\xf6\x01\x7f\x01\x1b\x05\x90\x02\xda\x04\xcc\x01\x9f\x04\xf7\x01H\x03\x1f\x03\xc8\x04\xe4\x02\x9d\x01\xfb\x01\x8e\x01\xb9\0\xc7\x02\xd6\0\x93\0\x84\x05\xc6\0\x85\x05\x90\x02\x90\x026\0\xfa\x01\xb9\0t\x03v\x03\xd9\0\x8c\x05\xca\x01\x90\x05\x91\x05I\x03\xcb\x05\x95\x05\xe4\x04o\x01 \0\x88\x02\x9b\x05\x89\x02\xa0\x04\xbd\0\x8f\x01;\x05\xb9\0\x7f\x01\xe4\x04\x0e\0\xd8\x01\x8a\x02u\x03\x90\x01\xca\x01\x9f\x02\xe4\x02\xfe\x01\xb9\0\xf8\x01\xb4\x02\xa4\x05w\x03\x02\x02\x0f\0\x10\0\x7f\x01\x7f\x01W\x02\x7f\x01\x7f\x01\xca\x01X\x04\x9f\x02\xe3\x04\x02\x02\xae\x05\x17\0\xf8\x01\x91\x01\xca\x01\xf1\0X\x02S\x05\xa3\x02\xf8\x01\xf8\x01\xb0\0\x7f\x01\x92\x01{\x02<\x05\xca\x01\xc7\x01\xe0\x02{\x026\0!\0K\x05\x9f\x02S\x01\xbd\x05\xa9\x05d\x05\xb9\0%\0\xf8\x01\xf8\x01\xe4\x04\xe0\x02\xe0\x02)\0\xba\x01\xc7\x01\xc5\x05m\x05\xca\x05=\x05-\0\x94\x01\xf8\x01\xa3\x02\xe0\x02\xa4\x02L\x05\xbb\x01\xaa\x05\xf8\x01\xf8\x01\xff\x01\xf8\x01\x02\x02\x02\x02\x84\x01\x82\0z\0\t\x02\x84\x01\x0b\x02\xda\x04y\x05\xd6\x05\xe0\x02S\x04\x84\x01\xe0\x025\0\x84\x01\xdb\x05\xdc\x05\xe0\x023\0\x97\0\xb9\0\xe3\0\xca\x01\xe0\x02\x13\x02\xca\x01\x97\0\xa4\x02\x97\0\xdf\x05\xe0\x02\xca\x01\x02\x02T\x04\x97\0W\0\x1e\x02 \0\xba\0\xf8\x01\x90\0S\x01\xc6\x01U\x043\0\xe2\x02\xe0\x02\xe0\x02\xb3\0\x97\0\x97\0\xca\x01\xec\x05\x81\x04\x02\x02\xb0\0\xe2\x02V\x04\xe0\x02\xca\x01(\x02W\0\xca\x01\x84\x01\x1d\0-\x02\x90\0\xca\x01\x02\x02\x8e\x04\xca\x01\xca\x01V\x02\xe2\x02\xb3\0r\x02r\x02*\x02W\x02/\x02\x11\x04\x1c\x04.\x02\xe8\x02\x84\x04\xe9\x02\xc2\0W\x026\0\xb0\0\xb0\0\xb0\0X\x02r\x02\xd8\x01\xea\x02\xf5\x01\xb0\0\x87\x01\x9f\x02\xf6\x01X\x02\xb8\x05B\x02\xbb\x05\xc2\0C\x02\xf7\x011\x02\x8a\x01\xf8\x01\x97\0\xc2\0\x97\0\xc1\x054\x02\x96\x05\x9f\x02\x97\0\\\x03\xb0\0\xb0\0\x9f\x02\xfb\x01\xa0\0\xb0\0\x9f\x02\xb0\0\x9f\x02<\x02\x9f\x02\x9f\x02\x9f\x02\xc2\0\xc2\0\xd9\0J\x02\xb8\x05\xb8\x05\xa3\x046\0}\x04>\x02\xa0\0\xd5\x05:\x02\x9f\x02\xc2\0B\x01\xa4\x04\xa0\0Q\x02\x97\0\xb0\0\xc2\0\xc2\0w\x02\xc2\x006\0\xb9\0\xb0\0\xdd\x05\x1e\x02C\x01D\x01\x97\0\x97\0o\x01\xe0\x05\xa3\x02p\x03\xa0\0\xa0\0\xb9\0\xb8\x05\x94\x01\xd9\0\x9f\x02\xe5\x05\xa3\x02\xb0\0 \x01\x84\x02\xe8\x05\xe9\x05\xa0\0\x85\x01\x13\x03!\x01\x98\x02\x85\x01\xba\0\xa0\0\xa0\0\"\x03\xa0\0\x8e\x02\x85\x01$\x03\xc2\0\x85\x01\xe3\0\x14\x03\x15\x03\xf1\0\xf1\0\xf1\0\xf1\0\xf2\x03\x85\x01\x06\x03\x07\x03\xf1\0\xf1\0\xf1\0\x9e\x02\xb6\x01\xf1\0\xf1\0\xa4\x02\xf1\0\xf1\0\xf1\0\xf1\0\xf1\0\xf1\0x\x01\xb0\0\xf1\0\xf1\0\xf1\0\xf1\0\xf1\0\xf1\0$\x02\xb9\0P\x01\xa0\0\x98\x01\xa5\x02\xf1\0\xf1\0\x06\x03\t\x03\xf1\0\xf1\0\xf1\0\xf1\0\xb6\x02\x85\x01\xb7\x02\xf1\0\xf1\0C\x01\x99\x01$\x02\xb9\0\x9f\0\x94\x01\xb9\0P\x01\xc0\0\xba\x02\x97\0\xbb\x02\xf1\0\xf1\0\xbc\x02\xf1\0\b\x03\n\x03\xf1\0\xf1\0\xf1\0\xc3\x02\xf1\0\x9f\0\xc4\x02\xf1\0\xf1\0\xc0\0\xc5\x02\x97\0\x9f\0\x93\0\x97\0\xf1\0\xc0\0\xf1\0\xc9\x02\xce\x02\xcf\x02\x97\0\xb5\0\x97\0\x97\0\xd2\x02\xf1\0\xf1\0\xd3\x02\xf1\0\xf1\0\xf1\0\xf1\0\x9f\0\x9f\0\xb0\0\xd6\x02\xc0\0\xf1\0\xb0\0\xf1\0\xb5\0?\x02\xf1\0\xf2\x02\x97\0\xf1\0\x9f\0\xb5\0\x1d\0\xf1\0\xc0\0\x1d\0 \0\x9f\0\x9f\0e\x02\x9f\0\xc0\0\xc0\0\x12\x03\xc0\0\x1d\0\x1d\x001\x033\x032\x036\x03>\x03\xb5\0\xb0\0\x97\0=\x03?\x03A\x03\x1d\0\x1d\0\x1d\0\x1d\0L\x03T\x03c\x01e\x03\xb5\0f\x03\x05\x02n\x03\xb0\0s\x03\x1d\0\x1d\0\xb5\0o\x03\xb5\0\x8a\x01\xb0\0|\x03\xb0\0\x8a\x01\x9f\0\x84\x03\x86\x03\x8a\x01\xc0\0\x8a\x01\x8a\x03\x95\x03\xd9\0\x8a\x01\x8a\x01\x1d\0\x94\x01\x8a\x01\x1d\0z\x01\x1d\0\x1d\0\x1d\0\x1d\0\x97\x03\x96\x03\x8a\x01\xce\x01\xa1\x03\x1d\0`\x02a\x02b\x02c\x02\xf7\x01\xd5\x01\x1d\0\xab\x03\xb0\x03\xb4\x03\xb5\0\xa7\0d\x02\xb7\x03\xbe\x03\xbf\x03;\x01\xc4\x03\x1d\0\xe6\0\x1d\0\x9e\x01\x1d\0\x1d\0\x94\x01\x06\x03\xcf\x03\xd1\x03\x93\0\xda\x03\xf8\x03\xf6\x03\n\x04\xa7\x02\x1d\0\x0e\x04\x8a\x01\x1d\0\x0f\x04\xa7\x01\x17\x04\x1d\0\xfb\x03\x8a\x01\x1a\x04\x1f\x04\xae\x01\x93\0\x86\x02\xd9\0#\x04$\x04\xa8\x02\x97\0\x93\0\xb0\0\xb0\0e\x02'\x04\n\0\x97\x003\x04\x8a\x01\x8a\x017\x04\x8a\x01\x8a\x01\xc7\x02\xa7\0\xce\0B\x04\x94\x019\x04g\x04\xd9\0\x93\0\x93\0b\x04i\x04l\x04m\x04n\x04\x7f\x04\x94\x01\x8a\x01|\x04x\x01\x9c\x04\x9e\x04\x93\0x\x01\x94\x01\xa6\x04\xae\x04x\x01\x97\0x\x01\x93\0\x97\0\x93\0x\x01x\x01\xa9\x04\xaf\x04\xb0\x04\xb3\x04\xa9\x02^\0\x97\0\xb1\x04\xbe\x04\xaa\x02\xc6\x04x\x016\0`\x02a\x02b\x02c\x02\xd2\x04\x97\0\xd4\x04_\0\x10\0\xd8\x04\xd9\x04!\x03d\x02%\x02\xec\x04\xb0\0\xdb\x04\xdc\x04\x0b\x05\xed\x04`\0\xf0\x04\x90\x04\x1a\x05M\x02\xef\x04\x93\0(\x05\xf5\x04K\x04W\x04\x02\x05\xb0\0\x04\x05\x97\0\x97\0)\x05\x1c\x05x\x01\xaf\0!\0?\x053\x05@\x05N\x05x\x01r\x05\xbf\0%\0V\x05l\x05\xb0\0~\x05\x94\x01a\0\xd8\0\x8d\x05e\x02\x8e\x05Z\x05\xdc\0-\0\x94\x05\x9c\x05x\x01x\x01\xbf\0x\x01x\x01 \0\x97\0\xb0\0 \0\xbf\0\xb1\x05\xd9\0\x97\0b\0\x97\0\xb4\x05\xb5\x05\xb6\x05 \0 \0\xbc\x05\xc0\x05x\x01\xb0\0\xbe\x05c\0\x97\0\x0e\x05d\0\xc9\x05\xbf\0 \0 \0 \0 \0\x01\0\x02\0\x03\0\x04\0\x05\0\x06\0\x07\0\xc8\x05\xcd\x05\xbf\0 \0 \0\xd3\x05\xd7\x05\xda\x05\xb0\0\xbf\0\xbf\0\xde\x05\xbf\0Z\x01\xe3\x05\x9c\x01\xe4\x05K\x04\xe6\x053\0W\0\x9f\x02\b\0\xe0\x02 \x003\0\xe4\x02 \0\"\x02\x94\x01_\x02 \0 \0~\0\xea\x02\xa3\x02\xc7\x01\xa4\x02 \0\xeb\x02\xd5\x01\x97\0a\x01b\x01c\x01 \0\xd8\0.\x02\xd5\x01\x97\0\x94\x02\x94\x02L\x01\xd5\x01\xbf\0\x96\x02\x95\x02 \0\x95\x02 \0\xcd\x04 \0 \0\x97\0\xdc\x01\x97\0\xd5\x01\x97\0\xd5\x01\xd5\x01e\x01f\x01\xc7\x01 \0\x97\x02\x9a\x02 \0\xb0\0\x97\0W\x04 \0\xd5\x01\x9b\x02h\x01i\x01j\x01k\x01\x9c\x02\xaf\0\xaf\0\xd9\x01\xaf\0\xaf\0\x98\x02\xaf\0\x9b\x02\x86\x02\xb0\0\x97\0\xa8\x01m\x01\xd5\x01\x97\0\xb5\x04\xaf\0\xaf\0F\x05\xd5\x01\xd5\x01\xd5\x01\xe5\x04\x86\x02\x86\x02\xe2\x04\x96\x02\xd5\x01\xa7\x05\x93\x05}\x05\xae\x02k\x04\xc9\x03\xd5\x01\x89\0\x86\x02\x8a\0\x8b\0 \0W\x04\x8c\0V\x03\xac\x02\xb1\x01\x8e\0\xaf\0\xaf\0\x92\x02\xe4\x02\xd5\x01\xd8\0\x97\0\x97\0W\x03q\x04\x86\x025\x03\xa5\x03\x86\x02\xe0\x01\xe6\x04\xd5\x01\x9b\x01\x86\x02\xd5\x01\f\x04\xd8\x05/\x05\xb9\x04\x86\x02\x91\0k\x05\xcc\x02\x97\0\0\0\xa8\0\x86\x02\x92\x004\x05\xcd\x04\xb2\0\x94\x03\0\0\0\0\xc2\0M\x02\0\0\0\0M\x02\x93\0\x94\0\0\0\x86\x02\x86\x02\0\0K\x04\x97\0\0\0M\x02\0\0\0\0\xc2\0M\x02\0\0\x86\x02\xb0\0\0\0}\x02\x97\0\0\0\0\0M\x02M\x02M\x02M\x02\x97\0\0\0\x97\0\0\0\0\0\0\0\xc2\0W\x04\0\0K\x04\x97\0M\x02\xb0\0\0\0\0\0\0\0\0\0W\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb0\0\xd8\0M\x02\0\0\0\0M\x02\0\0}\x02M\x02M\x02M\x02\x97\0\xc2\0\0\0\xc2\0\xc2\0M\x02\0\0\xc7\x01\0\0\0\0T\x02\0\0M\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x97\0\0\0\0\0\0\0M\x02\0\0M\x02\x9c\x01M\x02M\x02\0\0\x9c\x01\x97\0\0\0\xb0\0\x9c\x01\0\0\x9c\x01\0\0F\x03M\x02\x9c\x01\xe0\x02M\x02K\x03\x9c\x01\x97\0M\x02\x97\0\xaf\0\0\0\0\0\0\0\0\0\x9c\x01\0\0\0\0\x97\0\0\0\0\0\0\0\xe0\x02\xd9\x01\0\0\x03\x01\0\0\0\0\0\0\xe0\x02K\x04\x97\0\0\0\0\0\0\0\0\0W\x04\0\0\0\0\0\0K\x04\xb2\0\xd6\x01\0\0\xb2\0\xb2\0\0\0\xb2\0]\x03\0\0\xe0\x02\xe0\x02\0\0\0\0\0\0\xb0\0\0\0\xb2\0\xb2\0\0\0\0\0\0\0\x9c\x01\xab\x02\xe0\x02\0\0\0\0\xc2\0\0\0\0\0\0\0\0\0\xe0\x02\0\0\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\x9c\x01\x9c\x01\x81\x03\x9c\x01\x9c\x01\0\0\xb2\0\xd6\x01\0\0\0\0\0\0\0\0K\x04\0\0\x97\0\xcd\x04\xc2\0\0\0\0\0\0\0\0\0\0\0\x9c\x01\0\0\0\0\0\0\xc7\x01\0\0\0\0\0\0\xaf\0\0\0\x97\0\0\0\x97\0\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x97\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa8\0\0\0\0\0\xa8\0\0\0\0\0\0\0K\x04\xaf\0\xaf\0\xaf\0\x97\0\x97\0\xa8\0\0\0\0\0\xaf\0\0\0\x97\0\xbe\0\0\0\0\0\x97\0\xd9\x01\0\0\0\0\xa8\0\xa8\0\xa8\0\xa8\0\0\0\xaf\0\0\0\0\0\xe0\x02\x97\0\xc2\0\xc1\x03\xbe\0\xaf\0\xaf\0\xa8\0\x97\0\0\0\xaf\0\xbe\0\xaf\0\0\0\x97\0\0\0\0\0\0\0\x97\0\0\0\xd8\0\0\0\xc2\0\x97\0\x97\0\xd9\x01\0\0\xa8\0\0\0\xd9\x01\0\0\0\0\xbe\0\0\0\xa8\0\xa8\0\0\0\0\0\xaf\0{\x01\0\0\xa8\0\0\0\0\0\0\0\xaf\0\xbe\0\n\0\xa8\0\xb0\x01\0\0\0\0\0\0\xbe\0\xbe\0\0\0\xbe\0\0\0\0\0\xde\x03\0\0\xd8\0\xa8\0\0\0\xa8\0\xaf\0\0\0\0\0\0\0\0\0\xe4\x03\0\0\xe6\x03\0\0\0\0\xb2\0\xa8\0\0\0\0\0\xa8\0\xdc\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xc2\0\xc2\0\0\0\0\0\xc2\0\0\0\xc2\0\0\0\x89\0\xbe\0\x8a\0\x8b\0 \0\0\0\x8c\0\0\0\0\0\xb1\x01\x8e\0\0\0\r\x04\x03\x01\0\0\xaf\0\x03\x01\0\0\0\0\0\0\0\0\x03\x01\0\0\x03\x01\0\0\0\0\x03\x01\x03\x01\0\0\x03\x01\x03\x01\x03\x01\x03\x01\x03\x01\x03\x01!\x04\x91\0\x03\x01\x03\x01\x03\x01%\x04\x03\x01\x03\x01\x92\0\0\0\0\0\0\0~\x03\0\0\0\0\x03\x01\0\0\0\0\x03\x01\x03\x01\x93\0\x94\0\0\0\0\0\0\0\x03\x01\x03\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd5\x01\0\0\0\0\x03\x01\0\0\0\0\x03\x01\0\0\xb2\0\0\0\x03\x01\x03\x01\0\0\x03\x01\0\0\0\0\x03\x01\x03\x01\0\0\0\0\0\0\0\0\0\0\xaf\0\x03\x01\\\x04\xd9\x01\xaf\0\0\0\0\0a\x04\0\0\0\0\0\0\0\0\x03\x01\x03\x01\0\0\x03\x01\x03\x01\x03\x01\x03\x01\xb2\0\xb2\0\xb2\0\0\0\0\0\x03\x01\0\0\x03\x01\xb2\0\0\0\x03\x01\0\0\0\0\x03\x01\0\0\0\0\xaf\0\x03\x01\0\0\0\0\0\0\0\0\0\0\xfa\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd6\x01\xb2\0\xaf\0\0\0\x8d\x04\xd6\x01\0\0\xb2\0\0\0\0\0\xaf\0\0\0\xaf\0\0\0\0\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0\0\0\xd8\0\0\0\0\0\0\0\0\0\0\0\xe0\x02\0\0\0\0\0\0M\x02\xb2\0\0\0\xe0\x02\0\0\0\0\0\0\0\0\xb2\0\xe0\x02\xe0\x02\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\xdd\x03\0\0\xba\x04{\x01\0\0\xe0\x02\0\0{\x01\xbd\x04\xb2\0\0\0{\x01\xe0\x02{\x01\0\0\0\0\0\0{\x01\0\0\0\0\0\0{\x01\0\0\0\0\xc2\0\xe0\x02\xe0\x02\0\0\xe0\x02\0\0{\x01\0\0\0\0\xe0\x02\xe0\x02\0\0\xe0\x02\0\0\xd8\0\xe0\x02\0\0\0\0\0\0\0\0\xaf\0\xaf\0\xe0\x02\0\0\0\0\0\0\xb3\0\0\0\0\0\0\0\xc3\0\0\0\xd6\x01\0\0\xe0\x02\0\0\0\0\0\0\xe0\x02\xd8\0\0\0\0\0\x1b\x04\0\0\0\0\xe7\x04{\x01\xc3\0\0\0\0\0\xe0\x02\0\0\0\0{\x01\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xc3\0\0\0\0\0\0\0\0\0{\x01{\x01\0\0{\x01{\x01\xc7\x01\0\0\xfb\x04\0\0\xfd\x04\0\0\x01\x05\0\0\0\0\x06\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0{\x01\xaf\0\0\0\0\0\0\0\0\0\0\0\x0f\x05\xc3\0\0\0\xc3\0\xc3\0\0\0\0\0\xd5\x01\0\0\xc7\x01\xb2\0\xaf\0\0\0\0\0\xb2\0\0\0\0\0\x1e\x05\x1f\x05\0\0\xd5\x01\0\0E\x04$\x05\x8a\0\x8b\0 \0\0\0\x8c\0\0\0\xaf\0F\x04G\x04\xd5\x01\0\0\xd5\x01\xd5\x01\0\0\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\xd6\x01H\x04\0\0\xd5\x01I\x04\xaf\x006\x05\0\0\0\0\xd8\0\xb2\x01\0\0J\x04\x91\0\0\0\0\0\0\0\xb2\0\0\0\0\0\x92\0\xaf\0\0\0\xd5\x01\0\0\xb2\0\0\0\xd6\x01\0\0\xd5\x01\xd5\x01\xd5\x01\x93\0\x94\0\0\0\xb3\0\xd7\x01\xd5\x01\xb3\0\xb3\0\0\0\xb3\0\0\0\0\0\xd5\x01\xb5\0\0\0\0\0\xaf\0\0\0\0\0\xb3\0\xb3\0\0\0\xcf\0\0\0\0\0\0\0\0\0\0\0\xd5\x01\xc3\0\0\0\xd9\x01\0\0\0\0\0\0M\x02\0\0\0\0M\x02\0\0\xd5\x01\0\0i\x05\xd5\x01\0\0\0\0\0\0\0\0M\x02\xb3\0\xd7\x01\0\0M\x02\xd9\x01\0\0\0\0p\x05~\x02\0\0\xc3\0\0\0M\x02M\x02M\x02M\x02\x8a\x02\0\0\0\0\0\0\0\0v\x05\0\0\0\0x\x05\0\0\0\0M\x02\0\0\xb2\0\xd6\x01\0\0\0\0\0\0\0\x009\x03\xaf\0\0\0\xc7\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0M\x02\0\0\0\0M\x02\0\0~\x02M\x02M\x02M\x02\xaf\0\x9c\x01\0\0\0\0\x8f\x05M\x02\0\0\0\0\0\0\0\0\0\0\0\0M\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf2\x01M\x02\0\0M\x02\0\0M\x02M\x02\xc3\0\xc7\x01\0\0\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0M\x02\x8c\0\x97\x01M\x02\x8d\0\x8e\0\0\0M\x02\xb2\0\0\0\xc3\0\xb0\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8f\0\xb5\0\xb5\0\xd6\x01\xb5\0\xb5\0\0\0\xb5\0\x90\0\x90\x03\0\0\0\0\0\0\0\0\0\0\0\0\x92\0\xb5\0\xb5\0\0\0\0\0\0\0\xb2\0\0\0\xc6\x05\xc7\x05\0\0\x05\x04\x93\0\x94\0\xb4\0\0\0\xce\x059\x03\0\0\xaf\0\0\0\0\0\0\0\0\0\0\0\xb3\0\xb2\0\0\0\0\0\0\0\0\0\xb5\0\xb5\0\x0e\0\0\0\0\0\xc7\x01\xe2\x02\0\0\xc3\0\xc3\0\xaf\0\xb2\0\xc3\0\0\0\xc3\0\xc7\x01\0\0\x0f\0\x10\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xaf\0\0\0\0\0\x17\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\xe7\x05\0\0\xd6\x01\0\0\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\xe2\x02\x8c\0\0\0!\0\x8d\0\x8e\0S\x01\0\0\xf1\x01\0\0\0\0%\0\xb2\x01\0\0\0\0\0\0\0\0)\0\0\0\xb2\x01\xe2\x02\xb2\x01\x8f\0\xe2\x02-\0\xaf\0\0\0\xe2\x02\xe2\x02\0\0\x90\0\x91\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\x92\0\0\x001\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\xb3\0\0\0\x93\0\x94\x005\0\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02\0\0\xd6\x01\0\0\0\0\0\0\0\0\0\0\xc7\x01\xc2\0\xc7\x01\xe2\x02\0\0\0\0\xe2\x02\x8a\x02\0\0\0\0\0\0\0\0\0\0\0\0\xd6\x01\0\0\xb3\0\xb3\0\xb3\0\xaf\0\0\0f\x02\x8a\x02\x8a\x02\xb3\0\xb4\0\xb4\0\0\0\xb4\0\xb4\0\0\0\xb4\0\0\0\0\0\xaf\0\x8a\x02\0\0\0\0\0\0\0\0\0\0\xb4\0\xb4\0\0\0\0\0k\0\x80\x02\xd7\x01\xb3\0\0\0\0\0\0\0\xd7\x01\0\0\xb3\0\x8a\x02\n\0\xf2\x01\x8a\x02\0\0\xf2\x01\0\0\0\0\x8a\x02\0\0\0\0\0\0\0\0\0\0\x8a\x02\xf2\x01\xb4\0\xb4\0\0\0\0\0\0\0\x8a\x02\0\0\0\0\0\0\xb3\0\0\0\0\0\xf2\x01\xf2\x01\xf2\x01\xf2\x01\xb3\0\0\0\0\0\xaf\0\0\0\x8a\x02\x8a\x02\0\0\0\0\0\0\0\0\xf2\x01\0\0\0\0\0\0\0\0\0\0\x8a\x02\0\0\x89\0\xb3\0\x8a\0\x8b\0 \0\xb2\0\x8c\0\0\0\0\0\xb1\x01\x8e\0\0\0\xf2\x01\0\0\0\0\xf2\x01\xc3\0\x97\x01\xf2\x01\xf2\x01\xf2\x01\0\0\0\0\0\0\0\0\0\0\xf2\x01\xd6\x01\0\0Z\x01\0\0\0\0\0\0\xf2\x01\xc2\0\0\0\x91\0\0\0\0\0\0\0\0\0\xb5\0\0\0\x92\0\xd6\x01\xf2\x01\0\0\xf2\x01\xd7\x01\xf2\x01\xf2\x01\0\0\0\0\0\0\0\0\x93\0\x94\0`\x01a\x01b\x01c\x01\xf2\x01\0\0\0\0\xf2\x01\0\0\x97\x01\0\0\xf2\x01\0\0\0\0\0\0\0\0\0\0\xdc\x02\xb5\0\xb5\0\xb5\0\xc8\x02\0\0\0\0\xb9\0\0\0\xb5\0\0\0;\x03e\x01f\x01\0\0\xd6\x01\0\0\0\0\xf1\x01\0\0\0\0\xf1\x01\0\0\0\0\0\0h\x01i\x01j\x01k\x01\xb2\x01\xe0\x02\xf1\x01\xb5\0\xb5\0\0\0\0\0\0\0\xb5\0\0\0\xb5\0\0\0\0\0m\x01\0\0\xf1\x01\xf1\x01\xf1\x01\xf1\x01\0\0\0\0\xb4\0f\x02\0\0\xb3\0\0\0\0\0\0\0\xb3\0\0\0\xf1\x01\0\0\0\0\0\0\0\0\0\0\xb5\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\x80\x02\x8c\0\0\0\xd6\x01\x8d\0\x8e\0\0\0\xf1\x01\0\0\0\0\xf1\x01\0\0\0\0\xf1\x01\xf1\x01\xf1\x01\xd7\x01\0\0\xa1\x05\0\0\xb5\0\xf1\x01\x8f\0\0\0\0\0\xef\x01\0\0\0\0\xf1\x01\0\0\x90\0\x91\0\0\0\xb3\0\0\0\0\0\0\0\0\0\x92\0\0\0\xf1\x01\xb3\0\xf1\x01\xd7\x01\xf1\x01\xf1\x01\0\0\xa1\x02\0\0k\0\x93\0\x94\0\0\0\0\0\0\0\0\0\xf1\x01\0\0\0\0\xf1\x01\x97\x01\0\0k\0\xf1\x01\0\0\0\0\0\0\xb5\0\0\0\0\0\0\0\0\0\0\0\0\0\xc2\x05k\0\0\0k\0k\0\xb4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\xa1\x02\0\0\xa1\x02\xa1\x02\xa1\x02\\\0\xa1\x02\0\0\0\0\xa1\x02\xa1\x02\0\0\0\0k\0\0\0\0\0\xb4\0\xb4\0\xb4\0\0\0k\0k\0\0\0\0\0\xb4\0\xb4\0\0\0k\0\0\0\xb3\0\xd7\x01\0\0\0\0\0\0k\0\0\0\xa1\x02\0\0\0\0\0\0\xae\x03\0\0\0\0\xa1\x02\0\0\0\0\x97\x01\xb4\0\xb4\0\xb5\0k\0\0\0\xb4\0\xb5\0\xb4\0\xa1\x02\xa1\x02\0\0\0\0\0\0\0\0\0\0k\0\0\0\0\0k\0\0\0\0\0\0\0\xb2\x01\0\0\0\0\0\0\0\0,\x04\0\0\0\0\xe7\0\xe7\0\0\0\xb4\0\0\0\0\0\0\0\xb5\0\0\0\0\0\xb4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\xb5\0\x8c\0\0\0\xb3\0\x8d\0\x8e\0\xb4\0\0\0\xb5\0\0\0\xb5\0\0\0\0\0\0\0\0\0\0\0\xe0\x02\0\0\0\0\xe0\x02\xd7\x01\0\0\x8f\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\x02\x90\0\x91\0\0\0\x8a\x01\x8b\x01\0\0\0\0\0\0\x92\0\xb3\0\0\0\0\0\xe0\x02\0\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0\x93\0\x94\0\0\0\xb4\0\0\0\0\0\0\0\xe0\x02\0\0\xb3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x97\x01\0\0\0\0\0\0\0\0\0\0\xb3\0\xfd\x01\xe0\x02\0\0\0\0\0\0\0\0\0\0\xef\x01\0\0\xe0\x02\xef\x01\0\0\0\0\0\0\0\0\xe0\x02\0\0\xb5\0\xb5\0\0\0\xef\x01\x97\x01\xe0\x02\0\0\0\0\0\0\xd7\x01\0\0\0\0\0\0\0\0\x97\x01\0\0\xef\x01\xef\x01\xef\x01\xef\x01\0\0\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xef\x01\0\0\xe0\x02\0\0\0\0\xe0\x02\0\0f\x02\xb4\0\xc2\x04\0\0\0\0\xb4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xef\x01\0\0\0\0\xef\x01\0\0\0\0\xef\x01\xef\x01\xef\x01\0\0\x97\x01\0\0\0\0\xb2\x01\xef\x01\n\0\\\0\xb0\x01\0\0\0\0\0\0\xef\x01\x97\x01\xb4\0\xb5\0\0\0\0\0\xd7\x01\0\0\\\0\x97\x01\0\0\0\0\xef\x01\xc3\0\xef\x01\0\0\xef\x01\xef\x01\0\0\xb4\0\xb5\0\\\0\0\0\\\0\\\0\0\0\xd7\x01\xb4\0\xef\x01\xb4\0\0\0\xef\x01\0\0\0\0\0\0\xef\x01\\\0\0\0\0\0\xb5\0\0\0\0\0\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\x97\x01\x8c\0\0\0\0\0\x8d\0\x8e\0\0\0\\\0\0\0\0\0\xb5\0\0\0\0\0Q\x04\0\0\\\0\0\0\0\0\0\0\0\0\0\0\\\0\x8f\0\0\0\0\0\0\0\xb5\0\0\0\\\0\0\0\x90\0\x91\0\x06\x01\0\0\0\0\0\0\0\0\x97\x01\x92\0\0\0\x97\x01\x97\x01\0\0\0\0\\\0\0\0\0\0\0\0\0\0\0\0\x93\0\x94\0\0\0\xb5\0\0\0\0\0\\\0\0\0\0\0\\\0\0\0\0\0\0\0\xb4\0\xb4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb3\0g\x02h\x02i\x02j\x02k\x02l\x02m\x02n\x02o\x02p\x02q\x02r\x02s\x02t\x02u\x02v\x02w\x02x\x02y\x02z\x02{\x02\xd7\x01}\x02\0\0\0\0\0\0\0\0\0\0\xc3\0\0\0\0\0\0\0Q\x04\0\0\0\0\0\0\x87\x02\0\0\xd7\x01\0\0\0\0\0\0\0\0\xfd\x01\x97\x01\xfd\x01\xfd\x01\xb5\0\x94\x02\0\0\0\0\xfd\x01\0\0\0\0\0\0\0\0\xfd\x01\0\0\0\0\0\0\xfd\x01\xfd\x01\xfd\x01\xb4\0\0\0\0\0\0\0\xb5\0\0\0\xfd\x01\xfd\x01\xfd\x01\xfd\x01\0\0\0\0\xcf\x04\0\0\0\0\0\0\xfd\x01\xb4\0\0\0\0\0\xd7\x01\xfd\x01\0\0\0\0\0\0\0\0\0\0\xfd\x01\xfd\x01\0\0\0\0\0\0\0\0\r\x01\0\0\0\0\xb4\0\0\0\0\0\0\0\0\0\xfd\x01\0\0\0\0\xfd\x01\0\0\0\0\xfd\x01\xfd\x01\xfd\x01\0\0\xfd\x01\0\0\0\0\0\0\xfd\x01\xb4\0\0\0\0\0\0\0\0\0\0\0\xfd\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb4\0\xfd\x01\xfd\x01\0\0\xfd\x01\xfd\x01\xfd\x01\xfd\x01\xd7\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xfd\x01\0\0\0\0\xfd\x01\0\0\0\0\0\0\xfd\x01\0\0\xb4\0\0\0\xb5\0\0\0\0\0\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\x97\x01\x8c\0\0\0\0\0\x8d\0\x8e\0\0\0\0\0\0\0\xcf\x04\0\0\0\0\xb5\0\0\0%\x05&\x05\0\0\0\0\0\0\0\0\0\0\0\0\x8f\0\0\0\0\0Q\x04\0\0\0\0\x19\x03\xb5\0\x90\0\x91\0\0\0\0\0\0\0\0\0\0\0#\x03\x92\0\x06\x01\0\0%\x03\x06\x01\0\0)\x03\0\0\0\0\x06\x01\0\0\x06\x01\x93\0\x94\0\x06\x01\x06\x01Q\x04\0\0\x06\x01\xb4\0\x06\x01\x06\x01\x06\x01\0\0\0\0\x06\x01\x06\x01\x06\x01O\x02\x06\x01\x06\x01\0\0\0\0\0\0\0\0\0\0\xb5\0\0\0\x06\x01\xb4\0\x97\x01\x06\x01\x06\x01\0\0\0\0\0\0\0\0\0\0\x06\x01\x06\x01\0\0\0\0\0\0\0\0\0\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\0\0\x06\x01\0\0\0\0\x06\x01\0\0\0\0\0\0\x06\x01\x06\x01\0\0\x06\x01\0\0\0\0\x06\x01\x06\x01\0\0\0\0\0\0\0\0\0\0\0\0\x06\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0j\x03\x06\x01\x06\x01\xb5\0\x06\x01\x06\x01\x06\x01\x06\x01\0\0\0\0\0\0\0\0\0\0\x06\x01\0\0\x06\x01\xcf\x04\0\0\x06\x01\0\0\0\0\x06\x01\0\0Q\x04\0\0\x06\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0Q\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x89\0\xb4\0\x8a\0\x8b\0 \0\r\x01\x8c\0\0\0\r\x01\x8d\0\x8e\0\0\0\0\0\r\x01\0\0\r\x01\0\0r\x02\r\x01\r\x01\0\0\0\0\r\x01\xb4\0\r\x01\r\x01\r\x01\x8f\0\0\0\r\x01\r\x01\r\x01\0\0\r\x01\r\x01\x90\0\x90\x03\0\0\0\0\0\0\xb4\0\0\0\r\x01\x92\0Q\x04\r\x01\r\x01\xcf\x04\0\0\0\0\0\0\0\0\r\x01\r\x01\xb1\x03\x93\0\x94\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\r\x01\0\0\0\0\r\x01\0\0\0\0\0\0\r\x01\r\x01\0\0\r\x01\0\0\0\0\r\x01\r\x01\0\0\0\0\0\0\0\0\xb4\0\0\0\r\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0Q\x04\xd0\x03\0\0\r\x01\r\x01\0\0\r\x01\r\x01\r\x01\r\x01\0\0\0\0\0\0\0\0\0\0\r\x01\0\0\r\x01\0\0\0\0\r\x01\0\0\0\0\r\x01\0\0\0\0\0\0\r\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xdf\x03\0\0\0\0\0\0\0\0\0\0\0\0\xe0\0\0\0\0\0\0\0\0\0\0\0\xb4\0\0\0\0\0\0\0O\x02O\x02O\x02O\x02\0\0\0\0O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02\0\0O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02\0\0\0\0\0\0\0\0O\x02O\x02\0\0\x16\x04O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02\0\0O\x02O\x02O\x02O\x02\0\0\0\0O\x02O\x02O\x02:\x02O\x02O\x02O\x02O\x02O\x02O\x02\0\0O\x02O\x02O\x02O\x02O\x02\0\0O\x02O\x02\0\0\0\0\0\0O\x02O\x02O\x02O\x02O\x02O\x02O\x02O\x02\0\0O\x02\0\0O\x02O\x02\0\0O\x02O\x02O\x02O\x02O\x02\0\0O\x02O\x02\0\0O\x02O\x02O\x02O\x02\x1d\x01O\x02O\x02\0\0O\x02\0\0\0\0\0\0O\x02\0\0\0\0\0\0\0\0\0\0\0\0r\x02r\x02r\x02r\x02r\x02\0\0r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02\0\0z\x04r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02\0\0\0\0\0\0\0\0r\x02r\x02\0\0\0\0r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02\0\0r\x02r\x02r\x02r\x02\0\0\0\0r\x02r\x02r\x02\0\0r\x02r\x02r\x02r\x02r\x02r\x02\0\0r\x02r\x02r\x02r\x02r\x02\0\0r\x02r\x02\0\0\0\0\0\0r\x02r\x02r\x02r\x02r\x02r\x02r\x02r\x02\0\0r\x02\0\0r\x02r\x02\0\0r\x02r\x02r\x02r\x02r\x02\0\0r\x02r\x02<\x01r\x02r\x02r\x02r\x02\0\0r\x02r\x02\0\0r\x02\0\0\0\0\0\0r\x02\0\0\0\0\0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\0\0\0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\0\xe0\0\0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\0\0\0\0\xf1\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\0\xe0\0\0\0\xe0\0\xf8\x04\0\0\xe0\0\xe0\0\xe0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\0\0\0\0\xe0\0\xe0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0$\x01\0\0\xe0\0\0\0\0\0\xe0\0\0\0\xe0\0\0\0\0\0\xe0\0\0\0\0\0\xe0\0!\x05\"\x05#\x05\xe0\0\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\0\0\0\0\0\0\x1d\x01\x1d\x01\0\0\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\0\0\x1d\x01\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\0\0\0\0\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\x1d\x01\0\0\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\"\x01\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\x1d\x01\x1d\x01\0\0\x1d\x01\0\0\0\0\0\0\x1d\x01\0\0<\x01<\x01<\x01<\x01<\x01\0\0<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01\0\0\0\0<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01\0\0\0\0\0\0\0\0<\x01<\x01\0\0\0\0<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01\0\0<\x01<\x01<\x01<\x01\0\0\0\0<\x01<\x01<\x01\0\0<\x01<\x01<\x01<\x01<\x01<\x01\0\0<\x01<\x01<\x01<\x01<\x01\0\0<\x01<\x01\0\0\0\0\0\0<\x01<\x01<\x01<\x01<\x01<\x01<\x01<\x01\0\0<\x01\0\0<\x01<\x01\0\0<\x01<\x01<\x01<\x01<\x01 \x01<\x01<\x01\0\0<\x01<\x01<\x01<\x01\0\0<\x01<\x01\0\0<\x01\0\0\0\0\0\0<\x01$\x01$\x01$\x01$\x01\0\0\0\0$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01\0\0$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01\0\0\0\0\0\0\0\0$\x01$\x01\0\0\0\0$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01\0\0$\x01$\x01$\x01$\x01\0\0\0\0$\x01$\x01$\x01\0\0$\x01$\x01$\x01$\x01$\x01$\x01\0\0$\x01$\x01$\x01$\x01$\x01\0\0$\x01$\x01\0\0\0\0\0\0$\x01$\x01$\x01$\x01$\x01$\x01$\x01$\x01\0\0$\x01\0\0$\x01$\x01\0\0$\x01$\x01$\x01$\x01$\x01E\x01$\x01$\x01\0\0$\x01$\x01$\x01$\x01\0\0$\x01$\x01\0\0$\x01\0\0\0\0\0\0$\x01\0\0\0\0\"\x01\"\x01\"\x01\"\x01\0\0\0\0\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\0\0\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\0\0\0\0\0\0\0\0\"\x01\"\x01\0\0\0\0\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\0\0\"\x01\"\x01\"\x01\"\x01\0\0\0\0\"\x01\"\x01\"\x01\0\0\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\0\0\"\x01\"\x01\"\x01\"\x01\"\x01\0\0\"\x01\"\x01\0\0\0\0\0\0\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\"\x01\0\0\"\x01\0\0\"\x01\"\x01\0\0\"\x01\"\x01\"\x01\"\x01\"\x01G\x01\"\x01\"\x01\0\0\"\x01\"\x01\"\x01\"\x01\0\0\"\x01\"\x01\0\0\"\x01\0\0\0\0\0\0\"\x01\0\0 \x01 \x01 \x01 \x01\0\0\0\0 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01\0\0 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01\0\0\0\0\0\0\0\0 \x01 \x01\0\0\0\0 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01\0\0 \x01 \x01 \x01 \x01\0\0\0\0 \x01 \x01 \x01\0\0 \x01 \x01 \x01 \x01 \x01 \x01\0\0 \x01 \x01 \x01 \x01 \x01\0\0 \x01 \x01\0\0\0\0\0\0 \x01 \x01 \x01 \x01 \x01 \x01 \x01 \x01\0\0 \x01\0\0 \x01 \x01\0\0 \x01 \x01 \x01 \x01 \x01J\x01 \x01 \x01\0\0 \x01 \x01 \x01 \x01\0\0 \x01 \x01\0\0 \x01\0\0\0\0\0\0 \x01E\x01E\x01E\x01E\x01E\x01\0\0E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01\0\0\0\0E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01\0\0\0\0\0\0\0\0E\x01E\x01\0\0\0\0E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01\0\0E\x01E\x01E\x01E\x01\0\0\0\0E\x01E\x01E\x01\0\0E\x01E\x01E\x01E\x01E\x01E\x01\0\0E\x01E\x01E\x01E\x01E\x01\0\0E\x01E\x01\0\0\0\0\0\0E\x01E\x01E\x01E\x01E\x01E\x01E\x01E\x01\0\0E\x01\0\0E\x01E\x01\0\0E\x01E\x01E\x01\0\0\0\0\x15\x01E\x01E\x01\0\0E\x01E\x01E\x01E\x01\0\0E\x01E\x01\0\0E\x01\0\0\0\0\0\0E\x01\0\0\0\0G\x01G\x01G\x01G\x01G\x01\0\0G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01\0\0\0\0G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01\0\0\0\0\0\0\0\0G\x01G\x01\0\0\0\0G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01\0\0G\x01G\x01G\x01G\x01\0\0\0\0G\x01G\x01G\x01\0\0G\x01G\x01G\x01G\x01G\x01G\x01\0\0G\x01G\x01G\x01G\x01G\x01\0\0G\x01G\x01\0\0\0\0\0\0G\x01G\x01G\x01G\x01G\x01G\x01G\x01G\x01\0\0G\x01\0\0G\x01G\x01\0\0G\x01G\x01G\x01\x16\x01\0\0\0\0G\x01G\x01\0\0G\x01G\x01G\x01G\x01\0\0G\x01G\x01\0\0G\x01\0\0\0\0\0\0G\x01\0\0J\x01J\x01J\x01J\x01J\x01\0\0J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01\0\0\0\0J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01\0\0\0\0\0\0\0\0J\x01J\x01\0\0\0\0J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01\0\0J\x01J\x01J\x01J\x01\0\0\0\0J\x01J\x01J\x01\0\0J\x01J\x01J\x01J\x01J\x01J\x01\0\0J\x01J\x01J\x01J\x01J\x01\0\0J\x01J\x01\0\0\0\0\0\0J\x01J\x01J\x01J\x01J\x01J\x01J\x01J\x01\0\0J\x01\0\0J\x01J\x01\0\0J\x01J\x01J\x01\xdf\0\0\0\0\0J\x01J\x01\0\0J\x01J\x01J\x01J\x01\0\0J\x01J\x01\0\0J\x01\0\0\0\0\0\0J\x01\x15\x01\x15\x01\x15\x01\x15\x01\0\0\0\0\0\0\0\0\x15\x01\x15\x01\x15\x01\0\0\0\0\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\0\0\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\0\0\0\0\0\0\0\0\0\0\0\0\x15\x01\x15\x01\0\0\0\0\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\0\0\0\0\0\0\x15\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x15\x01\x15\x01\0\0\x15\x01\0\0\0\0\x15\x01\x15\x01\x15\x01\0\0\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\0\0\0\0\0\0\0\0\0\0\0\0\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\0\0\0\0\x15\x01\0\0\x15\x01\x15\x01\0\0\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\xea\0\x15\x01\0\0\0\0\x15\x01\x15\x01\x15\x01\0\0\0\0\x15\x01\0\0\0\0\x15\x01\0\0\0\0\0\0\x15\x01\x16\x01\x16\x01\x16\x01\x16\x01\0\0\0\0\0\0\0\0\x16\x01\x16\x01\x16\x01\0\0\0\0\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\0\0\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\0\0\0\0\0\0\0\0\0\0\0\0\x16\x01\x16\x01\0\0\0\0\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\0\0\0\0\0\0\x16\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x01\x16\x01\0\0\x16\x01\0\0\0\0\x16\x01\x16\x01\x16\x01\0\0\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\0\0\0\0\0\0\0\0\0\0\0\0\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\0\0\0\0\x16\x01\0\0\x16\x01\x16\x01\0\0\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\xeb\0\x16\x01\0\0\0\0\x16\x01\x16\x01\x16\x01\0\0\0\0\x16\x01\0\0\0\0\x16\x01\0\0\0\0\0\0\x16\x01\0\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\0\0\0\0\xdf\0\xdf\0\xdf\0\0\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\0\0\0\0\0\0\0\0\xdf\0\xdf\0\0\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xdf\0\xdf\0\0\0\xdf\0\0\0\0\0\xdf\0\xdf\0\xdf\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\0\0\0\0\0\0\0\0\xdf\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\0\0\0\0\xdf\0\xdf\0\0\0\xdf\0\xdf\0\xdf\0\0\0\xec\0\0\0\xdf\0\0\0\0\0\xdf\0\0\0\xdf\0\0\0\0\0\xdf\0\0\0\0\0\xdf\0\0\0\0\0\0\0\xdf\0\0\0\0\0\xea\0\xea\0\xea\0\xea\0\0\0\0\0\0\0\0\0\xea\0\xea\0\xea\0\0\0\0\0\xea\0\xea\0\xea\0\xea\0\xea\0\0\0\xea\0\xea\0\xea\0\0\0\0\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\0\0\0\0\0\0\0\0\0\0\0\0\xea\0\xea\0\0\0\0\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xea\0\xea\0\0\0\xea\0\0\0\0\0\xea\0\xea\0\xea\0\0\0\xea\0\xea\0\xea\0\xea\0\xea\0\0\0\0\0\0\0\0\0\0\0\0\0\xea\0\0\0\xea\0\xea\0\xea\0\xea\0\xea\0\0\0\0\0\0\0\0\0\xea\0\xea\0\0\0\xea\0\xea\0\xea\0\xea\0\x0e\x01\0\0\xea\0\0\0\0\0\xea\0\0\0\xea\0\0\0\0\0\xea\0\0\0\0\0\xea\0\0\0\0\0\0\0\xea\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\xeb\0\xeb\0\xeb\0\0\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\0\0\0\0\xeb\0\xeb\0\0\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xeb\0\xeb\0\0\0\xeb\0\0\0\0\0\xeb\0\xeb\0\xeb\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\0\0\0\0\xeb\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\xeb\0\xeb\0\0\0\xeb\0\xeb\0\xeb\0\0\0\x0f\x01\0\0\xeb\0\0\0\0\0\xeb\0\0\0\xeb\0\0\0\0\0\xeb\0\0\0\0\0\xeb\0\0\0\0\0\0\0\xeb\0\xec\0\xec\0\xec\0\xec\0\0\0\0\0\0\0\0\0\xec\0\xec\0\xec\0\0\0\0\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\0\0\0\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\0\0\0\0\0\0\0\0\0\0\0\0\xec\0\xec\0\0\0\0\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xec\0\xec\0\0\0\xec\0\0\0\0\0\xec\0\xec\0\xec\0\0\0\xec\0\xec\0\xec\0\xec\0\xec\0\0\0\0\0\0\0\0\0\0\0\0\0\xec\0\0\0\xec\0\xec\0\xec\0\xec\0\xec\0\0\0\0\0\0\0\0\0\xec\0\xec\0\0\0\xec\0\xec\0\xec\0\0\0\xf6\0\0\0\xec\0\0\0\0\0\xec\0\0\0\xec\0\0\0\0\0\xec\0\0\0\0\0\xec\0\0\0\0\0\0\0\xec\0\0\0\0\0\x0e\x01\x0e\x01\x0e\x01\x0e\x01\0\0\0\0\0\0\0\0\x0e\x01\x0e\x01\x0e\x01\0\0\0\0\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\0\0\0\0\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\0\0\0\0\0\0\0\0\0\0\0\0\x0e\x01\x0e\x01\0\0\0\0\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0e\x01\x0e\x01\0\0\x0e\x01\0\0\0\0\x0e\x01\x0e\x01\x0e\x01\0\0\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\0\0\0\0\0\0\0\0\0\0\0\0\x0e\x01\0\0\x0e\x01\x0e\x01\x0e\x01\x0e\x01\x0e\x01\0\0\0\0\0\0\0\0\x0e\x01\x0e\x01\0\0\x0e\x01\x0e\x01\x0e\x01\xf7\0\0\0\0\0\x0e\x01\0\0\0\0\x0e\x01\0\0\x0e\x01\0\0\0\0\x0e\x01\0\0\0\0\x0e\x01\0\0\0\0\0\0\x0e\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\0\0\0\0\0\0\0\0\x0f\x01\x0f\x01\x0f\x01\0\0\0\0\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\0\0\0\0\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\0\0\0\0\0\0\0\0\0\0\0\0\x0f\x01\x0f\x01\0\0\0\0\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0f\x01\x0f\x01\0\0\x0f\x01\0\0\0\0\x0f\x01\x0f\x01\x0f\x01\0\0\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\0\0\0\0\0\0\0\0\0\0\0\0\x0f\x01\0\0\x0f\x01\x0f\x01\x0f\x01\x0f\x01\x0f\x01\0\0\0\0\0\0\0\0\x0f\x01\x0f\x01\0\0\x0f\x01\x0f\x01\x0f\x01\xfe\0\0\0\0\0\x0f\x01\0\0\0\0\x0f\x01\0\0\x0f\x01\0\0\0\0\x0f\x01\0\0\0\0\x0f\x01\0\0\0\0\0\0\x0f\x01\xf6\0\xf6\0\xf6\0\xf6\0\0\0\0\0\0\0\0\0\xf6\0\xf6\0\xf6\0\0\0\0\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\0\0\0\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\0\0\0\0\0\0\0\0\0\0\0\0\xf6\0\xf6\0\0\0\0\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\0\0\xf6\0\xf6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf6\0\xf6\0\0\0\xf6\0\0\0\0\0\xf6\0\xf6\0\xf6\0\0\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\0\0\0\0\0\0\0\0\0\0\0\0\xf6\0\0\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\0\0\0\0\0\0\0\0\xf6\0\xf6\0\0\0\xf6\0\xf6\0\xf6\0\xf6\0\xfd\0\0\0\xf6\0\0\0\0\0\xf6\0\0\0\xf6\0\0\0\0\0\xf6\0\0\0\0\0\xf6\0\0\0\0\0\0\0\xf6\0\0\0\xf7\0\xf7\0\xf7\0\xf7\0\0\0\0\0\0\0\0\0\xf7\0\xf7\0\xf7\0\0\0\0\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\0\0\0\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\0\0\0\0\0\0\0\0\0\0\0\0\xf7\0\xf7\0\0\0\0\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\0\0\xf7\0\xf7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf7\0\xf7\0\0\0\xf7\0\0\0\0\0\xf7\0\xf7\0\xf7\0\0\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\0\0\0\0\0\0\0\0\0\0\0\0\xf7\0\0\0\xf7\0\xf7\0\xf7\0\xf7\0\xf7\0\0\0\0\0\0\0\0\0\xf7\0\xf7\0\0\0\xf7\0\xf7\0\xf7\0\xf7\0\xe4\0\0\0\xf7\0\0\0\0\0\xf7\0\0\0\xf7\0\0\0\0\0\xf7\0\0\0\0\0\xf7\0\0\0\0\0\0\0\xf7\0\xfe\0\xfe\0\xfe\0\xfe\0\0\0\0\0\0\0\0\0\xfe\0\xfe\0\xfe\0\0\0\0\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\0\0\0\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\0\0\0\0\0\0\0\0\0\0\0\0\xfe\0\xfe\0\0\0\0\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\0\0\xfe\0\xfe\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xfe\0\xfe\0\0\0\xfe\0\0\0\0\0\xfe\0\xfe\0\xfe\0\0\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\0\0\0\0\0\0\0\0\0\0\0\0\xfe\0\0\0\xfe\0\xfe\0\xfe\0\xfe\0\xfe\0\0\0\0\0\0\0\0\0\xfe\0\xfe\0\0\0\xfe\0\xfe\0\xfe\0\xfe\0\xe7\0\0\0\xfe\0\0\0\0\0\xfe\0\0\0\xfe\0\0\0\0\0\xfe\0\0\0\0\0\xfe\0\0\0\0\0\0\0\xfe\0\0\0\xfd\0\xfd\0\xfd\0\xfd\0\0\0\0\0\0\0\0\0\xfd\0\xfd\0\xfd\0\0\0\0\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\0\0\0\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\0\0\0\0\0\0\0\0\0\0\0\0\xfd\0\xfd\0\0\0\0\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\0\0\xfd\0\xfd\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xfd\0\xfd\0\0\0\xfd\0\0\0\0\0\xfd\0\xfd\0\xfd\0\0\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\0\0\0\0\0\0\0\0\0\0\0\0\xfd\0\0\0\xfd\0\xfd\0\xfd\0\xfd\0\xfd\0\0\0\0\0\0\0\0\0\xfd\0\xfd\0\0\0\xfd\0\xfd\0\xfd\0\xfd\0\xe8\0\0\0\xfd\0\0\0\0\0\xfd\0\0\0\xfd\0\0\0\0\0\xfd\0\0\0\0\0\xfd\0\0\0\0\0\0\0\xfd\0\0\0\xe4\0\xe4\0\xe4\0\xe4\0\0\0\0\0\0\0\0\0\0\0\xe4\0\xe4\0\0\0\0\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\0\0\0\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\0\xe4\0\0\0\0\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\0\xe4\0\0\0\xe4\0\0\0\0\0\xe4\0\xe4\0\xe4\0\0\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\0\0\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\0\0\0\0\0\0\0\0\xe4\0\xe4\0\0\0\xe4\0\xe4\0\xe4\0\xe4\0\xf5\0\0\0\xe4\0\0\0\0\0\xe4\0\0\0\xe4\0\0\0\0\0\xe4\0\0\0\0\0\xe4\0\0\0\0\0\0\0\xe4\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\0\0\xe7\0\xe7\0\0\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\0\0\0\0\xe7\0\xe7\0\0\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe7\0\xe7\0\0\0\xe7\0\0\0\0\0\xe7\0\xe7\0\xe7\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\0\0\0\0\xe7\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\xe7\0\xe7\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xfb\0\0\0\xe7\0\0\0\0\0\xe7\0\0\0\xe7\0\0\0\0\0\xe7\0\0\0\0\0\xe7\0\0\0\0\0\0\0\xe7\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\0\0\0\0\0\0\0\0\0\0\xe8\0\xe8\0\0\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\0\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\0\0\0\0\0\0\0\0\0\0\0\0\xe8\0\xe8\0\0\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe8\0\xe8\0\0\0\xe8\0\0\0\0\0\xe8\0\xe8\0\xe8\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\0\0\0\0\0\0\0\0\0\0\0\0\xe8\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\0\0\0\0\0\0\0\0\xe8\0\xe8\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\xfc\0\0\0\xe8\0\0\0\0\0\xe8\0\0\0\xe8\0\0\0\0\0\xe8\0\0\0\0\0\xe8\0\0\0\0\0\0\0\xe8\0\0\0\xf5\0\xf5\0\xf5\0\xf5\0\0\0\0\0\0\0\0\0\xf5\0\xf5\0\xf5\0\0\0\0\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\0\0\0\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\0\0\0\0\0\0\0\0\0\0\0\0\xf5\0\xf5\0\0\0\0\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\0\0\0\0\xf5\0\xf5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf5\0\xf5\0\0\0\xf5\0\0\0\0\0\xf5\0\xf5\0\xf5\0\0\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\0\0\0\0\0\0\0\0\0\0\0\0\xf5\0\0\0\xf5\0\0\0\xf5\0\xf5\0\xf5\0\0\0\0\0\0\0\0\0\xf5\0\xf5\0\0\0\xf5\0\xf5\0\xf5\0\xf5\0\xf8\0\0\0\0\0\0\0\0\0\xf5\0\0\0\xf5\0\0\0\0\0\xf5\0\0\0\0\0\xf5\0\0\0\0\0\0\0\xf5\0\xfb\0\xfb\0\xfb\0\xfb\0\0\0\0\0\0\0\0\0\xfb\0\xfb\0\xfb\0\0\0\0\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\0\0\0\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\0\0\0\0\0\0\0\0\0\0\0\0\xfb\0\xfb\0\0\0\0\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\0\0\0\0\xfb\0\xfb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xfb\0\xfb\0\0\0\xfb\0\0\0\0\0\xfb\0\xfb\0\xfb\0\0\0\xfb\0\xfb\0\xfb\0\xfb\0\xfb\0\0\0\0\0\0\0\0\0\0\0\0\0\xfb\0\0\0\xfb\0\0\0\xfb\0\xfb\0\xfb\0\0\0\0\0\0\0\0\0\xfb\0\xfb\0\0\0\xfb\0\xfb\0\xfb\0\xfb\0\xf9\0\0\0\0\0\0\0\0\0\xfb\0\0\0\xfb\0\0\0\0\0\xfb\0\0\0\0\0\xfb\0\0\0\0\0\0\0\xfb\0\0\0\xfc\0\xfc\0\xfc\0\xfc\0\0\0\0\0\0\0\0\0\xfc\0\xfc\0\xfc\0\0\0\0\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\0\0\0\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\0\0\0\0\0\0\0\0\0\0\0\0\xfc\0\xfc\0\0\0\0\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\0\0\0\0\xfc\0\xfc\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xfc\0\xfc\0\0\0\xfc\0\0\0\0\0\xfc\0\xfc\0\xfc\0\0\0\xfc\0\xfc\0\xfc\0\xfc\0\xfc\0\0\0\0\0\0\0\0\0\0\0\0\0\xfc\0\0\0\xfc\0\0\0\xfc\0\xfc\0\xfc\0\0\0\0\0\0\0\0\0\xfc\0\xfc\0\0\0\xfc\0\xfc\0\xfc\0\xfc\0\xfa\0\0\0\0\0\0\0\0\0\xfc\0\0\0\xfc\0\0\0\0\0\xfc\0\0\0\0\0\xfc\0\0\0\0\0\0\0\xfc\0\0\0\xf8\0\xf8\0\xf8\0\xf8\0\0\0\0\0\0\0\0\0\xf8\0\xf8\0\xf8\0\0\0\0\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\0\0\0\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\0\0\0\0\0\0\0\0\0\0\0\0\xf8\0\xf8\0\0\0\0\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\0\0\0\0\xf8\0\xf8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf8\0\xf8\0\0\0\xf8\0\0\0\0\0\xf8\0\xf8\0\xf8\0\0\0\xf8\0\xf8\0\xf8\0\xf8\0\xf8\0\0\0\0\0\0\0\0\0\0\0\0\0\xf8\0\0\0\xf8\0\0\0\xf8\0\xf8\0\xf8\0\0\0\0\0\0\0\0\0\xf8\0\xf8\0\0\0\xf8\0\xf8\0\xf8\0\xf8\0\xcc\0\0\0\0\0\0\0\0\0\xf8\0\0\0\xf8\0\0\0\0\0\xf8\0\0\0\0\0\xf8\0\0\0\0\0\0\0\xf8\0\xf9\0\xf9\0\xf9\0\xf9\0\0\0\0\0\0\0\0\0\xf9\0\xf9\0\xf9\0\0\0\0\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\0\0\0\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\0\0\0\0\0\0\0\0\0\0\0\0\xf9\0\xf9\0\0\0\0\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\0\0\0\0\xf9\0\xf9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf9\0\xf9\0\0\0\xf9\0\0\0\0\0\xf9\0\xf9\0\xf9\0\0\0\xf9\0\xf9\0\xf9\0\xf9\0\xf9\0\0\0\0\0\0\0\0\0\0\0\0\0\xf9\0\0\0\xf9\0\0\0\xf9\0\xf9\0\xf9\0\0\0\0\0\0\0\0\0\xf9\0\xf9\0\0\0\xf9\0\xf9\0\xf9\0\xf9\0\xff\0\0\0\0\0\0\0\0\0\xf9\0\0\0\xf9\0\0\0\0\0\xf9\0\0\0\0\0\xf9\0\0\0\0\0\0\0\xf9\0\0\0\xfa\0\xfa\0\xfa\0\xfa\0\0\0\0\0\0\0\0\0\xfa\0\xfa\0\xfa\0\0\0\0\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\0\0\0\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\0\0\0\0\0\0\0\0\0\0\0\0\xfa\0\xfa\0\0\0\0\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\0\0\0\0\xfa\0\xfa\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xfa\0\xfa\0\0\0\xfa\0\0\0\0\0\xfa\0\xfa\0\xfa\0\0\0\xfa\0\xfa\0\xfa\0\xfa\0\xfa\0\0\0\0\0\0\0\0\0\0\0\0\0\xfa\0\0\0\xfa\0\0\0\xfa\0\xfa\0\xfa\0\0\0\0\0\0\0\0\0\xfa\0\xfa\0\0\0\xfa\0\xfa\0\xfa\0\xfa\0\x01\x01\0\0\0\0\0\0\0\0\xfa\0\0\0\xfa\0\0\0\0\0\xfa\0\0\0\0\0\xfa\0\0\0\0\0\0\0\xfa\0\0\0\xcc\0\xcc\0\xcc\0\xcc\0\0\0\0\0\0\0\0\0\xcc\0\xcc\0\xcc\0\0\0\0\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\0\0\0\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\0\0\0\0\0\0\0\0\0\0\0\0\xcc\0\xcc\0\0\0\0\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\xcc\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xcc\0\xcc\0\0\0\0\0\0\0\0\0\xcc\0\xcc\0\xcc\0\0\0\xcc\0\0\0\0\0\xcc\0\xcc\0\0\0\0\0\0\0\0\0\0\0\0\0\xcc\0\0\0\xcc\0\xcc\0\0\0\0\0\xcc\0\0\0\0\0\0\0\0\0\xcc\0\xcc\0\0\0\xcc\0\xcc\0\xcc\0\xcc\0\xf3\0\0\0\xcc\0\0\0\0\0\xcc\0\0\0\xcc\0\0\0\0\0\xcc\0\0\0\0\0\xcc\0\0\0\0\0\0\0\xcc\0\xff\0\xff\0\xff\0\xff\0\0\0\0\0\0\0\0\0\xff\0\xff\0\xff\0\0\0\0\0\xff\0\xff\0\0\0\xff\0\xff\0\xff\0\xff\0\xff\0\xff\0\0\0\0\0\xff\0\xff\0\xff\0\xff\0\xff\0\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\0\xff\0\0\0\0\0\xff\0\xff\0\xff\0\0\0\0\0\0\0\0\0\xff\0\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\0\xff\0\0\0\xff\0\0\0\0\0\0\0\xff\0\xff\0\0\0\xff\0\0\0\0\0\xff\0\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\0\0\0\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\0\xff\0\0\0\xff\0\xff\0\xff\0\xff\0\xf4\0\0\0\0\0\0\0\0\0\xff\0\0\0\xff\0\0\0\0\0\xff\0\0\0\0\0\xff\0\0\0\0\0\0\0\xff\0\0\0\x01\x01\x01\x01\x01\x01\x01\x01\0\0\0\0\0\0\0\0\x01\x01\x01\x01\x01\x01\0\0\0\0\x01\x01\x01\x01\0\0\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\0\0\0\0\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\x01\x01\x01\x01\0\0\0\0\x01\x01\x01\x01\x01\x01\0\0\0\0\0\0\0\0\x01\x01\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\x01\x01\x01\0\0\x01\x01\0\0\0\0\0\0\x01\x01\x01\x01\0\0\x01\x01\0\0\0\0\x01\x01\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\x01\x01\0\0\x01\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\x01\x01\x01\0\0\x01\x01\x01\x01\x01\x01\x01\x01\0\x01\0\0\0\0\0\0\0\0\x01\x01\0\0\x01\x01\0\0\0\0\x01\x01\0\0\0\0\x01\x01\0\0\0\0\0\0\x01\x01\0\0\xf3\0\xf3\0\xf3\0\xf3\0\0\0\0\0\0\0\0\0\xf3\0\xf3\0\xf3\0\0\0\0\0\xf3\0\xf3\0\0\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\0\0\0\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\0\0\0\0\0\0\0\0\0\0\0\0\xf3\0\xf3\0\0\0\0\0\xf3\0\xf3\0\xf3\0\0\0\0\0\0\0\0\0\xf3\0\xf3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf3\0\xf3\0\0\0\xf3\0\0\0\0\0\0\0\xf3\0\xf3\0\0\0\xf3\0\0\0\0\0\xf3\0\xf3\0\0\0\0\0\0\0\0\0\0\0\0\0\xf3\0\0\0\xf3\0\0\0\0\0\x05\x01\0\0\0\0\0\0\0\0\0\0\xf3\0\xf3\0\0\0\xf3\0\xf3\0\xf3\0\xf3\0\0\0\0\0\0\0\0\0\0\0\xf3\0\0\0\xf3\0\0\0\0\0\xf3\0\0\0\0\0\xf3\0\0\0\0\0\0\0\xf3\0\xf4\0\xf4\0\xf4\0\xf4\0\0\0\0\0\0\0\0\0\xf4\0\xf4\0\xf4\0\0\0\0\0\xf4\0\xf4\0\0\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\0\0\0\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\0\0\0\0\0\0\0\0\0\0\0\0\xf4\0\xf4\0\0\0\0\0\xf4\0\xf4\0\xf4\0\0\0\0\0\0\0\0\0\xf4\0\xf4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf4\0\xf4\0\0\0\xf4\0\0\0\0\0\0\0\xf4\0\xf4\0\0\0\xf4\0\0\0\0\0\xf4\0\xf4\0\0\0\0\0\0\0\0\0\x04\x01\0\0\xf4\0\0\0\xf4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf4\0\xf4\0\0\0\xf4\0\xf4\0\xf4\0\xf4\0\0\0\0\0\0\0\0\0\0\0\xf4\0\0\0\xf4\0\0\0\0\0\xf4\0\0\0\0\0\xf4\0\0\0\0\0\0\0\xf4\0\0\0\0\x01\0\x01\0\x01\0\x01\0\0\0\0\0\0\0\0\0\x01\0\x01\0\x01\0\0\0\0\0\x01\0\x01\0\0\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\0\0\0\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\x01\0\0\0\0\0\x01\0\x01\0\x01\0\0\0\0\0\0\0\0\0\x01\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\x01\0\0\0\x01\0\0\0\0d\x01\0\x01\0\x01\0\0\0\x01\0\0\0\0\0\x01\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\x01\0\0\0\x01\0\x01\0\x01\0\x01\0\0\0\0\0\0\0\0\0\0\0\x01\x05\x01\0\x01\0\0\x05\x01\0\x01\0\0\0\0\0\x01\x05\x01\x05\x01\x05\x01\0\x01\0\0\x05\x01\x05\x01\0\0\x05\x01\x05\x01\x05\x01\x05\x01\x05\x01\x05\x01\0\0\0\0\x05\x01\x05\x01\x05\x01\0\0\x05\x01\x05\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\x01\0\0\0\0\x05\x01\x05\x01\0\0\0\0\0\0\0\0\0\0\x05\x01\x05\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\x01\0\0\0\0\x05\x01\0\0\0\0\x02\x01\x05\x01\x05\x01\0\0\x05\x01\0\0\0\0\x05\x01\x05\x01\0\0\0\0\0\0\0\0\0\0\0\0\x05\x01\0\0\x05\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\x01\x05\x01\0\0\x05\x01\x05\x01\x05\x01\x05\x01\0\0\0\0\0\0\0\0\0\0\x05\x01\0\0\x05\x01\0\0\0\0\x05\x01\x04\x01\0\0\x05\x01\x04\x01\0\0\0\0\x05\x01\0\0\x04\x01\x04\x01\x04\x01\0\0\0\0\x04\x01\x04\x01\0\0\x04\x01\x04\x01\x04\x01\x04\x01\x04\x01\x04\x01\0\0\0\0\x04\x01\x04\x01\x04\x01\0\0\x04\x01\x04\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\x01\0\0\0\0\x04\x01\x04\x01\0\0\0\0\0\0\0\0\0\0\x04\x01\x04\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\x01c\x01\0\0\x04\x01\0\0\0\0\0\0\x04\x01\x04\x01\0\0\x04\x01\0\0\0\0\x04\x01\x04\x01\0\0\0\0\0\0\0\0\0\0\0\0\x04\x01\0\0\x04\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\x01\x04\x01\0\0\x04\x01\x04\x01\x04\x01\x04\x01\0\0\0\0\0\0\0\0\0\0\x04\x01d\x01\x04\x01\0\0d\x01\x04\x01\0\0\0\0\x04\x01d\x01\0\0d\x01\x04\x01\0\0d\x01d\x01\0\0d\x01d\x01d\x01d\x01d\x01d\x01\0\0\0\0d\x01d\x01d\x01\0\0d\x01d\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\x01\0\0\0\0d\x01d\x01\0\0\0\0\0\0\0\0\0\0d\x01d\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\t\x01\0\0\0\0\0\0d\x01\0\0\0\0d\x01\0\0\0\0\0\0d\x01d\x01\0\0d\x01\0\0\0\0d\x01d\x01\0\0\0\0\0\0\0\0\0\0\0\0d\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\x01d\x01\0\0d\x01d\x01d\x01d\x01\0\0\0\0\0\0\0\0\0\0d\x01\x02\x01d\x01\0\0\x02\x01d\x01\0\0\0\0d\x01\x02\x01\0\0\x02\x01d\x01\0\0\x02\x01\x02\x01\0\0\x02\x01\x02\x01\x02\x01\x02\x01\x02\x01\x02\x01\0\0\0\0\x02\x01\x02\x01\x02\x01\0\0\x02\x01\x02\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\x01\0\0\0\0\x02\x01\x02\x01\0\0\0\0\0\0\0\0\0\0\x02\x01\x02\x01\0\0\0\0\0\0\xed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\x01\0\0\0\0\x02\x01\0\0\0\0\0\0\x02\x01\x02\x01\0\0\x02\x01\0\0\0\0\x02\x01\x02\x01\0\0\0\0\0\0\0\0\0\0\0\0\x02\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\x01\x02\x01\0\0\x02\x01\x02\x01\x02\x01\x02\x01\0\0\0\0\0\0\0\0\0\0\x02\x01c\x01\x02\x01\0\0c\x01\x02\x01\0\0\0\0\x02\x01c\x01\0\0c\x01\x02\x01\0\0c\x01c\x01\0\0c\x01c\x01c\x01c\x01c\x01c\x01\0\0\0\0c\x01c\x01c\x01\0\0c\x01c\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0c\x01\0\0\0\0c\x01c\x01\0\0\0\0\0\0\0\0\0\0c\x01c\x01\0\0\0\0\0\0\f\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0c\x01\0\0\0\0c\x01\0\0\0\0\0\0c\x01c\x01\0\0c\x01\0\0\0\0c\x01c\x01\0\0\0\0\0\0\0\0\0\0\0\0c\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0c\x01c\x01\0\0c\x01c\x01c\x01c\x01\0\0\t\x01\0\0\0\0\t\x01c\x01\0\0c\x01\0\0\t\x01c\x01\t\x01\0\0c\x01\t\x01\t\x01\0\0c\x01\t\x01\0\0\t\x01\t\x01\t\x01\0\0\0\0\t\x01\t\x01\t\x01\0\0\t\x01\t\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\t\x01\0\0\0\0\t\x01\t\x01\0\0\0\0\0\0\0\0\0\0\t\x01\t\x01\0\0\0\0\0\0\x0b\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\t\x01\0\0\0\0\t\x01\0\0\0\0\0\0\t\x01\t\x01\0\0\t\x01\0\0\0\0\t\x01\t\x01\0\0\0\0\0\0\0\0\0\0\0\0\t\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\t\x01\t\x01\0\0\t\x01\t\x01\t\x01\t\x01\0\0\xed\0\0\0\0\0\xed\0\t\x01\0\0\t\x01\0\0\xed\0\t\x01\xed\0\0\0\t\x01\xed\0\xed\0\0\0\t\x01\xed\0\0\0\xed\0\xed\0\xed\0\0\0\0\0\xed\0\xed\0\xed\0\0\0\xed\0\xed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xed\0\0\0\0\0\xed\0\xed\0\0\0\0\0\0\0\0\0\0\0\xed\0\xed\0\0\0\0\0\0\0\n\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xed\0\0\0\0\0\xed\0\0\0\0\0\0\0\xed\0\xed\0\0\0\xed\0\0\0\0\0\xed\0\xed\0\0\0\0\0\0\0\0\0\0\0\0\0\xed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xed\0\xed\0\0\0\xed\0\xed\0\xed\0\xed\0\0\0\0\0\0\0\0\0\0\0\xed\0\f\x01\xed\0\0\0\f\x01\xed\0\0\0\0\0\xed\0\f\x01\0\0\f\x01\xed\0\0\0\f\x01\f\x01\0\0\0\0\f\x01\0\0\f\x01\f\x01\f\x01\0\0\0\0\f\x01\f\x01\f\x01\0\0\f\x01\f\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\x01\0\0\0\0\f\x01\f\x01\0\0\0\0\0\0\0\0\0\0\f\x01\f\x01\0\0\0\0\0\0\xcb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\x01\0\0\0\0\f\x01\0\0\0\0\0\0\f\x01\f\x01\0\0\f\x01\0\0\0\0\f\x01\f\x01\0\0\0\0\0\0\0\0\0\0\0\0\f\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\x01\f\x01\0\0\f\x01\f\x01\f\x01\f\x01\0\0\x0b\x01\0\0\0\0\x0b\x01\f\x01\0\0\f\x01\0\0\x0b\x01\f\x01\x0b\x01\0\0\f\x01\x0b\x01\x0b\x01\0\0\f\x01\x0b\x01\0\0\x0b\x01\x0b\x01\x0b\x01\0\0\0\0\x0b\x01\x0b\x01\x0b\x01\0\0\x0b\x01\x0b\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0b\x01\0\0\0\0\x0b\x01\x0b\x01\0\0\0\0\0\0\0\0\0\0\x0b\x01\x0b\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0b\x01\0\0y\x02\x0b\x01\0\0\0\0\0\0\x0b\x01\x0b\x01\0\0\x0b\x01t\0\0\0\x0b\x01\x0b\x01\0\0\0\0\0\0\0\0\0\0\0\0\x0b\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0b\x01\x0b\x01\0\0\x0b\x01\x0b\x01\x0b\x01\x0b\x01\0\0\n\x01\0\0\0\0\n\x01\x0b\x01\0\0\x0b\x01\0\0\n\x01\x0b\x01\n\x01\0\0\x0b\x01\n\x01\n\x01\0\0\x0b\x01\n\x01\0\0\n\x01\n\x01\n\x01\0\0\0\0\n\x01\n\x01\n\x01\0\0\n\x01\n\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\n\x01\0\0\0\0\n\x01\n\x01\0\0\0\0\0\0\0\0\0\0\n\x01\n\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\n\x01\0\0\0\0\n\x01\0\0\0\0\0\0\n\x01\n\x01\0\0\n\x01\0\0\0\0\n\x01\n\x01\0\0\xee\0\0\0\0\0\0\0\0\0\n\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\n\x01\n\x01\0\0\n\x01\n\x01\n\x01\n\x01\0\0\0\0\0\0\0\0\0\0\n\x01\xcb\0\n\x01\0\0\xcb\0\n\x01\0\0\0\0\n\x01\xcb\0\0\0\xcb\0\n\x01\0\0\xcb\0\xcb\0\0\0\0\0\xcb\0\0\0\xcb\0\xcb\0\xcb\0\0\0\0\0\xcb\0\xcb\0\xcb\0\0\0\xcb\0\xcb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xcb\0\0\0\0\0\xcb\0\xcb\0\0\0\0\0\0\0\0\0\0\0\xcb\0\xcb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xcb\0\0\0\0\0\xcb\0\0\0\0\0\0\0\xcb\0\xcb\0\0\0\xcb\0\0\0\0\0\xcb\0\xcb\0\0\0\0\0\0\0\0\0\0\0\0\0\xcb\0,\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xcb\0\xcb\0\0\0\xcb\0\0\0\xcb\0\xcb\0\0\0\0\0\0\0\0\0\0\0\xcb\0\0\0\xcb\0\0\0\0\0\xcb\0\0\0y\x02\xcb\0y\x02y\x02y\x02\xcb\0\0\0\0\0y\x02t\0\0\0\0\0\0\0y\x02\0\0\0\0\0\0y\x02y\x02y\x02\0\0\0\0t\0\0\0\0\0\0\0y\x02y\x02y\x02y\x02\0\0\0\0\0\0\0\0\0\0t\0y\x02t\0t\0\0\0\0\0y\x02\0\0\0\0\0\0\0\0\0\0y\x02y\x02\x89\0t\0\x8a\0\x8b\0 \0\0\0\x8c\0\0\0\0\0\xb1\x01\xf3\x02\0\0y\x02\0\0\0\0y\x02y\x02\0\0y\x02y\x02y\x02t\0y\x02\x04\x02t\0y\x02y\x02\0\0t\0t\0\0\0\0\0\0\0y\x02\0\0t\0\x91\0\0\0\0\0\0\0\0\0\0\0t\0\x92\0y\x02y\x02\0\0y\x02y\x02y\x02y\x02\0\0\0\0y\x02t\0\x93\0\x94\0\0\0t\0t\0\0\0y\x02y\x02\0\0y\x02\0\0\xee\0\0\0y\x02\xee\0t\0\0\0\0\0t\0\xee\0\0\0\xee\0\0\0\0\0\xee\0\xee\0\0\0\0\0\xee\0\0\0\xee\0\xee\0\xee\0\0\0\0\0\xee\0\0\0\xee\0\0\0\xee\0\xee\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xee\0\0\0\0\0\xee\0\xee\0\0\0\0\0\0\0\0\0\0\0\xee\0\xee\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\x02\0\0\0\0\xee\0\0\0\0\0\xee\0\0\0\0\0\0\0\xee\0\xee\0\0\0\xee\0\0\0\0\0\xee\0\xee\0\0\0\0\0\0\0\0\0\0\0\0\0\xee\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xee\0\xee\0\0\0\xee\0\xee\0\xee\0\xee\0\0\0\0\0\0\0\0\0\0\0\xee\0\0\0\xee\0\0\0\0\0\xee\0\0\0,\x02\xee\0,\x02,\x02,\x02\xee\0\0\0\0\0,\x02\0\0\0\0\0\0\0\0,\x02\0\0\0\0\0\0,\x02,\x02,\x02\0\0\0\0\0\0\0\0\0\0\0\0,\x02,\x02,\x02,\x02\0\0\0\0\0\0\0\0\0\0\0\0,\x02\0\0\0\0\0\0\0\0,\x02\0\0\0\0\0\0\0\0\0\0,\x02,\x02-\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0,\x02\0\0\0\0,\x02\0\0\0\0,\x02,\x02,\x02\0\0,\x02\0\0\0\0,\x02,\x02\0\0\0\0\0\0\0\0\0\0\0\0,\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0,\x02,\x02\0\0,\x02,\x02,\x02,\x02\0\0\x04\x02\0\0\x04\x02\x04\x02\x04\x02\0\0\0\0\0\0\x04\x02,\x02\0\0\0\0,\x02\x04\x02\0\0\0\0,\x02\x04\x02\x04\x02\x04\x02\0\0\0\0\0\0\0\0\0\0\0\0\x04\x02\x04\x02\x04\x02\x04\x02\0\0\0\0\0\0\0\0\0\0\0\0\x04\x02\0\0\0\0\0\0\0\0\x04\x02\0\0\0\0\0\0\0\0\0\0\x04\x02\x04\x02\x03\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\x02\0\0\0\0\x04\x02\0\0\0\0\x04\x02\x04\x02\x04\x02\0\0\x04\x02\0\0\0\0\x04\x02\x04\x02\0\0\0\0\0\0\0\0\0\0\0\0\x04\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\x02\x04\x02\0\0\x04\x02\x04\x02\x04\x02\0\0\0\0\x05\x02\x04\x02\x05\x02\x05\x02\x05\x02\0\0\0\0\0\0\x05\x02\x04\x02\0\0\0\0\x04\x02\x05\x02\0\0\0\0\x04\x02\x05\x02\x05\x02\x05\x02\0\0\0\0\0\0\0\0\0\0\0\0\x05\x02\x05\x02\x05\x02\x05\x02\0\0\0\0\0\0\0\0\0\0\0\0\x05\x02\0\0\0\0\0\0\0\0\x05\x02\0\0\0\0\0\0\0\0\0\0\x05\x02\x05\x02\x01\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\x02\0\0\0\0\x05\x02\0\0\0\0\x05\x02\x05\x02\x05\x02\0\0\x05\x02\0\0\0\0\x05\x02\x05\x02\0\0\0\0\0\0\0\0\0\0\0\0\x05\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\x02\x05\x02\0\0\x05\x02\x05\x02\x05\x02\0\0\0\0\0\0\x05\x02-\x02\0\0-\x02-\x02-\x02\0\0\0\0\x05\x02-\x02\0\0\x05\x02\0\0\0\0-\x02\x05\x02\0\0\0\0-\x02-\x02-\x02\0\0\0\0\0\0\0\0\0\0\0\0-\x02-\x02-\x02-\x02\0\0\0\0\0\0\0\0\0\0\0\0-\x02\0\0\0\0\0\0\0\0-\x02\0\0\0\0\0\0\0\0\0\0-\x02-\x02\x02\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0-\x02\0\0\0\0-\x02\0\0\0\0-\x02-\x02-\x02\0\0-\x02\0\0\0\0-\x02-\x02\0\0\0\0\0\0\0\0\0\0\0\0-\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0-\x02-\x02\0\0-\x02-\x02-\x02-\x02\0\0\x03\x02\0\0\x03\x02\x03\x02\x03\x02\0\0\0\0\0\0\x03\x02-\x02\0\0\0\0-\x02\x03\x02\0\0\0\0-\x02\x03\x02\x03\x02\x03\x02\0\0\0\0\0\0\0\0\0\0\0\0\x03\x02\x03\x02\x03\x02\x03\x02\0\0\0\0\0\0\0\0\0\0\0\0\x03\x02\0\0\0\0\0\0\0\0\x03\x02\0\0\0\0\0\0\0\0\0\0\x03\x02\x03\x02\0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03\x02\0\0\0\0\x03\x02\0\0\0\0\x03\x02\x03\x02\x03\x02\0\0\x03\x02\0\0\0\0\0\0\x03\x02\0\0\0\0\0\0\0\0\0\0\0\0\x03\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03\x02\x03\x02\0\0\x03\x02\x03\x02\x03\x02\x03\x02\0\0\x01\x02\0\0\x01\x02\x01\x02\x01\x02\0\0\0\0\xc1\0\x01\x02\x03\x02\0\0\0\0\x03\x02\x01\x02\0\0\0\0\x03\x02\x01\x02\x01\x02\x01\x02\0\0\0\0\0\0\0\0\0\0\0\0\x01\x02\x01\x02\x01\x02\x01\x02\0\0\0\0\0\0\0\0\0\0\0\0\x01\x02\0\0\0\0\0\0\0\0\x01\x02\0\0\0\0\0\0\0\0\0\0\x01\x02\x01\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0R\0\0\0\0\0\0\0\x01\x02\0\0\0\0\x01\x02\0\0\0\0\x01\x02\x01\x02\x01\x02\0\0\x01\x02\0\0\0\0\0\0\x01\x02\0\0\0\0\0\0\0\0\0\0\0\0\x01\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\x02\x01\x02\0\0\x01\x02\x01\x02\x01\x02\x01\x02\0\0\0\0\0\0\x02\x02\0\0\x02\x02\x02\x02\x02\x02\0\0\0\0\x01\x02\x02\x02\0\0\x01\x02\0\0\0\0\x02\x02\x01\x02\0\0\0\0\x02\x02\x02\x02\x02\x02\0\0\0\0\0\0\0\0\0\0\0\0\x02\x02\x02\x02\x02\x02\x02\x02\0\0\0\0\0\0\0\0\0\0\0\0\x02\x02\0\0\0\0\0\0\0\0\x02\x02\0\0\0\0\0\0\0\0\0\0\x02\x02\x02\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\x02\0\0\0\0\x02\x02\0\0\0\0\x02\x02\x02\x02\x02\x02\xe2\x02\x02\x02\0\0\0\0\0\0\x02\x02\0\0\0\0\0\0\0\0\0\0\0\0\x02\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\x02\x02\x02\0\0\x02\x02\x02\x02\x02\x02\x02\x02\0\0\0\x02\0\0\0\x02\0\x02\0\x02\0\0\0\0\0\0\0\x02\x02\x02\0\0\0\0\x02\x02\0\x02\0\0\0\0\x02\x02\0\x02\0\x02\0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\0\x02\0\x02\0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\0\0\0\0\0\0\0\0\0\x02\0\0\0\0\0\0\0\0\0\0\0\x02\0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xc1\0\0\0\0\x02\xc1\0\0\0\0\x02\0\0\0\0\0\x02\0\x02\0\x02\0\0\0\x02\xc1\0\0\0\0\0\0\x02\0\0\0\0\xc1\0\0\0\0\0\x81\0\0\x02\0\0\0\0\xc1\0\xc1\0\xc1\0\xc1\0\0\0\0\0\0\0\0\0\0\x02\0\x02\0\0\0\x02\0\x02\0\x02\0\x02\xc1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0R\0\0\x02\0\0R\0\0\x02\0\0\0\0\0\0\0\x02\0\0\0\0\xc1\0\0\0R\0\xc1\0\0\0\0\0\0\0\xc1\0\xc1\0\0\0\0\0\0\0\0\0\0\0\xc1\0R\0R\0R\0R\0\0\0\0\0\xc1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0R\0\0\0\0\0\xc1\0\0\0\xc1\0\0\0\xc1\0\xc1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xc1\0R\0\0\0\xc1\0R\0\0\0\0\0\xc1\0R\0R\0\0\0\0\0\0\0\0\0\0\0R\0\0\0\0\0\0\0y\0\0\0\0\0R\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0R\0\0\0R\0\0\0R\0R\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0R\0\0\0\0\0R\0\0\0\0\0\xe2\x02R\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xa9\x01\xe2\x02\0\0\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\0\0\xe2\x02\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\t\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\x0e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0f\0\x10\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\x17\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0!\0\0\0\0\0\"\0#\0$\0\0\0\0\0%\0&\0\0\0'\0(\0\0\0)\0\0\0*\0+\0\0\0,\0r\x02-\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\0z\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\x004\x005\x006\0\t\0\n\0\x0b\0\0\x007\0\0\0\f\0\r\0\x0e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0f\0\x10\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\x17\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0!\0\0\0\0\0\"\0#\0$\0\0\0\0\0%\0&\0\0\0'\0(\0\0\0)\0\0\0*\0+\0\0\0,\0\0\0-\0\0\0\0\0\0\0.\0/\0\x87\x010\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0z\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\x004\x005\x006\0\0\0\0\0\0\0\0\x007\0\0\0\0\0\0\0\0\0\t\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\x0e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0f\0\x10\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\x17\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0!\0\0\0\0\0\"\0#\0$\0\0\0\0\0%\0&\0\0\0'\0(\0\0\0)\0\0\0*\0+\0\0\0,\0\0\0-\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0z\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\x84\x003\x004\x005\x006\0\0\0\0\0r\x02\0\x007\0\0\0r\x02\0\0r\x02\0\0r\x02\0\0r\x02\0\0r\x02r\x02r\x02r\x02\0\0r\x02r\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0r\x02r\x02r\x02r\x02r\x02r\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0r\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0r\x02r\x02r\x02r\x02r\x02r\x02\0\0r\x02r\x02\0\0\0\0r\x02r\x02\0\0\0\0r\x02r\x02r\x02r\x02r\x02r\x02\0\0k\x02r\x02\0\0r\x02r\x02\0\0r\x02\0\0\0\0\0\0\0\0r\x02r\x02\0\0\0\0r\x02\0\0\0\0\0\0\0\0r\x02\0\0r\x02r\x02\0\0r\x02r\x02r\x02r\x02\0\0\0\0\0\0r\x02\0\0\0\0r\x02\0\0r\x02\0\0r\x02r\x02r\x02\0\0\x87\x01r\x02\0\0\0\0\x87\x01\0\0\x87\x01\0\0\x87\x01\0\0\x87\x01\0\0\x87\x01\0\0\x87\x01\x87\x01\x85\0\x87\x01\x87\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x87\x01\0\0\0\0\x87\x01\x87\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x87\x01\x87\x01\x87\x01\x87\x01\0\0\x87\x01\0\0\x87\x01\x87\x01\0\0\0\0\x87\x01\0\0\0\0\0\0\0\0\x87\x01\x87\x01\x87\x01\0\0\0\0\0\0\0\0\x87\x01\0\0\x87\x01\x80\0\x82\0\x87\x01\0\0\x82\0\x82\0\0\0\0\0\x87\x01\0\0\0\0\x87\x01\0\0\0\0\x82\0\x82\0\x87\x01\0\0\x87\x01\x87\x01\x82\0\x87\x01\x87\x01\0\0\x87\x01\0\0\0\0\x82\0\x87\x01\x82\0\x82\0\x87\x01\0\0\x87\x01\0\0\0\0\x87\x01\x87\x01\0\0\0\0\x87\x01\0\0\x82\0\0\0\0\0\0\0\0\0\0\0\x82\0\x82\0\x82\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x84\0\0\0\x82\0\x84\0\x84\0\x82\0\0\0\0\0\x82\0\x82\0\x82\0\0\0\x82\0\x84\0\x84\0\0\0\x82\0\0\0\0\0\x84\0\0\0\0\0\0\0\x82\0\0\0\0\0\x84\0\0\0\x84\0\x84\0\0\0\0\0\0\0\0\0\0\0\x82\0\0\0\x82\0\0\0\x82\0\x82\0\x84\0\0\0\0\0\0\0\0\0\0\0\x84\0\x84\0\xb2\0\0\0\x82\0\0\0\0\0\x82\0\0\0\0\0\0\0\0\0\0\0\0\0\x84\0\0\0\0\0\x84\0\0\0\0\0\x84\0\x84\0\x84\0\0\0\x84\0\0\0\0\0\0\0\x84\0\0\0\0\0k\x02\0\0\0\0k\x02\x84\0\0\0\0\0\0\0k\x02\0\0\0\0\0\0\0\0k\x02k\x02\0\0\x84\0\0\0\x84\0k\x02\x84\0\x84\0}\x02\0\0\0\0\0\0k\x02\0\0k\x02k\x02\x83\x02\0\0\x84\0\0\0\0\0\x84\0\0\0\0\0\0\0\0\0\x89\0k\x02\x8a\0\x8b\0 \0\0\0\x8c\0\0\0\0\0\xb1\x01G\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x85\0\0\0k\x02\x85\0\x85\0k\x02\0\0}\x02k\x02k\x02k\x02\0\0\0\0\x85\0\x85\0\0\0k\x02\x91\0\0\0\x85\0\0\0\0\0k\x02k\x02\x92\0\0\0\x85\0\0\0\x85\0\x85\0\0\0\xe0\x02\0\0\0\0\0\0k\x02\x93\0\x94\0\0\0k\x02k\x02\x85\0\0\0\0\0\0\0\0\0\0\0\x85\0\x85\0\0\0\0\0k\x02\0\0\0\0k\x02\0\0\0\0\0\0\0\0\x80\0\0\0\x85\0\x80\0\x80\0\x85\0\0\0\0\0\0\0\x85\0\x85\0\0\0\x85\0\x80\0\x80\0\0\0\x85\0\0\0\0\0\x80\0\0\0\0\0\0\0\x85\0\0\0\0\0\x80\0\xd8\x01\x80\0\x80\0\0\0\0\0\0\0\0\0\0\0\x85\0\0\0\x85\0\0\0\x85\0\x85\0\x80\0\0\0\0\0\0\0\0\0\0\0\x80\0\x80\0\0\0\x82\x02\x85\0\0\0\x82\x02\x85\0\0\0\0\0\0\0\0\0\0\0\0\0\x80\0\0\0\x82\x02\x80\0\0\0\0\0\0\0\x80\0\x80\0\0\0\x80\0\0\0\0\0\0\0\x80\0\x82\x02\x82\x02\x82\x02\x82\x02\0\0\0\0\x80\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x02\0\0\0\0\x80\0\0\0\x80\0\0\0\x80\0\x80\0\0\0\0\0\0\0\x06\x02\0\0\0\0\0\0\0\0\0\0\xb2\0\x80\0\x82\x02\xb2\0\x80\0\0\0y\x02\0\0\x82\x02\x82\x02\x82\x02\x06\x02\0\0\xb2\0\0\0y\x02\x82\x02\0\0\0\0\0\0\0\0\0\0\0\0\x82\x02\0\0\0\0\xb2\0\xb2\0\xb2\0\xb2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x02\0\0\x82\x02y\x02\xb2\0\0\0y\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x02y\x02\0\0\x82\x02\0\0\0\0\0\0\0\0\x83\x02\0\0\xb2\0\x83\x02\0\0\0\0\x1a\x02\0\0\xb2\0\xb2\0\xb2\0\0\0\0\0\x83\x02\0\0\x1a\x02\xb2\0\0\0\0\0\0\0\0\0\0\0\0\0\xb2\0\0\0\0\0\x83\x02\x83\x02\x83\x02\x83\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb2\0\0\0\xb2\0\x1a\x02\x83\x02\0\0\x1a\x02\x07\x02\0\0\0\0\0\0\0\0\0\0\0\0\xb2\0\x1a\x02\0\0\xb2\0\0\0\0\0\0\0\0\0\0\0\xe0\x02\x83\x02\0\0\xe0\x02\0\0z\x02\0\0\x83\x02\x83\x02\x83\x02\0\0\0\0\0\0\xe0\x02z\x02\x83\x02\0\0\0\0\0\0\xe0\x02\0\0\0\0\x83\x02\0\0\0\0\0\0\xe0\x02\0\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\x83\x02\0\0\x83\x02z\x02\xe0\x02\xe0\x02z\x02\0\0\0\0\0\0\0\0\xe0\x02\xe0\x02\0\0\x83\x02z\x02\0\0\x83\x02\0\0\xd8\x01\0\0\0\0\xd8\x01\0\0\0\0\xe0\x02\x07\x02\xd8\x01\xe0\x02\0\0\0\0\0\0\xd8\x01\xe0\x02\0\0\xe0\x02f\0\0\0\xd8\x01\xe0\x02\0\0\0\0\0\0\0\0\0\0\xd8\x01\xe0\x02\xd8\x01\xd8\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\x02\0\0\xd8\x01\0\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\x02\0\0\0\0\xe0\x02\0\0\0\0\xd8\x01\0\0\0\0\xd8\x01\0\0\0\0\xd8\x01\xd8\x01\xd8\x01\0\0\0\0\0\0\0\x004\x02\xd8\x01\x06\x02\0\0\0\0\x06\x02\0\0\0\0\xd8\x01\0\0\x06\x02\xd5\x01\0\0\0\0\0\0\x06\x02\0\0\0\0\0\0\x06\x02\xd8\x01\x06\x02\x06\x02\0\0\xd8\x01\xd8\x01\0\0\x06\x02\x06\x02\0\0\x06\x02\x06\x02\x06\x02\0\0\0\0\0\0\xd8\x01\0\0\x06\x02\xd8\x01\0\0\0\0\0\0\x06\x02\0\0\x06\x02\0\0\x06\x02\x06\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\x02\xe0\x02\0\0\x06\x02\0\0\0\0\x06\x02\0\0\0\0\x06\x02\x06\x02\x06\x02\0\0\0\0\0\0\0\0\x06\x02\x06\x02\0\0\0\0\x06\x02\0\0\0\0\x06\x02\x06\x02\xb1\x01\x06\x02\x06\x02\x06\x02\0\0\0\0\0\0\0\0\x06\x02\x06\x02\0\0\x06\x02\0\0\0\0\0\0\x06\x02\x06\x02\0\0\0\0\x04\x02\0\0\0\0\0\0\0\0\0\0\0\0\x07\x02\x06\x02\x06\x02\x07\x02\x06\x02\0\0\x06\x02\0\0\x07\x02\0\0\x06\x02\0\0\0\0\x07\x02\0\0\0\0\0\0\0\0\x06\x02\x07\x02\0\0\x06\x02\0\0\0\0P\0\0\0\x07\x02\0\0\x07\x02\x07\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\x02\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\0\0\x8c\0\0\0\0\0\x8d\0\x8e\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\x02\0\0\xc0\x01\x07\x02\0\0\0\0\x07\x02\x07\x02\x07\x02\0\0\x8f\0\0\0\0\0\x07\x02\x07\x02\0\0\0\0\x07\x02\x90\0\x91\0\x07\x02\x07\x02\xe2\x02\x0b\x02\0\0\x07\x02\x92\0f\0\0\0\0\0\x07\x02\0\0\0\0\x07\x02\0\0\0\0\x07\x02\x07\x02\x93\0\x94\0f\0\x05\x02\0\0\x07\x02\0\0\x07\x02\x07\x02\0\0\0\0\x07\x02\0\0\0\0\x07\x02f\0\0\0f\0f\0\0\0\x07\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\x02\0\0\0\0\x07\x02\xb1\x01\0\0\x07\x02\x07\x02\x07\x02\0\0f\0\0\0\0\0\x07\x02\x07\x02\0\0\0\0\xd5\x01f\0\0\0\xd5\x01\x07\x02\0\0\0\0f\0\xd5\x01\0\0\0\0\0\0\0\0\xd5\x01f\0\0\0\x07\x02\0\0\0\0\xd5\x01\x07\x02\0\0\0\0\0\0\x07\x02\0\0\xd5\x01\0\0\xd5\x01\xd5\x01f\0\0\0\x07\x02\0\0\0\0\x07\x02\0\0\0\0\0\0\0\0\0\0\xd5\x01f\0\0\0\0\0f\0\xb2\x01\0\0\0\0\0\0\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd5\x01\0\0\xe0\x02\xd5\x01\0\0\0\0\xd5\x01\xd5\x01\xd5\x01\0\0\0\0\0\0\0\0\xb1\x01\xd5\x01\xe0\x02\xb1\x01\xe0\x02\xe0\x02\0\0\0\0\xd5\x01\0\0\0\0\0\0\0\0\xb1\x01\0\0\0\0\0\0\xe0\x02\0\0\xb1\x01\xd5\x01\0\0\0\0\0\0\xd5\x01\xd5\x01\xb1\x01\0\0\xb1\x01\xb1\x01\0\0\xb4\x01\0\0\0\0\0\0a\0\xd5\x01\xe0\x02\0\0\xd5\x01\0\0\xb1\x01\0\0\0\0\0\0\xe0\x02\0\0\0\0\0\0\0\0P\0\xe0\x02\0\0P\0\0\0\0\0\0\0\0\0\xe0\x02\0\0\0\0\xb1\x01\0\0P\0\xb1\x01\0\0\0\0\0\0\xb1\x01\xb1\x01\0\0\0\0\0\0\0\0\xe0\x02\xb1\x01P\0P\0P\0P\0\0\0\0\0\xb1\x01\0\0\0\0\0\0\xe0\x02\0\0y\x02\xe0\x02\xb3\x01P\0\0\0\0\0\xb1\x01\0\0\0\0\0\0\xb1\x01\xb1\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\xb1\x01P\0\xe2\x02\xb1\x01P\0\0\0\0\0\xe2\x02P\0P\0\0\0\0\0\xe2\x02\0\0\0\0P\0\0\0\0\0\xe2\x02\0\0\0\0\0\0P\0\0\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\0\0e\0\0\0\0\0\0\0P\0\0\0P\0\0\0P\0P\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\xb5\x01\0\0\0\0P\0\0\0\0\0P\0\0\0\0\0\0\0\0\0\0\0\xb1\x01\xe2\x02\0\0\xb1\x01\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02\0\0\0\0\0\0\xb1\x01\0\0\xe2\x02\0\0\0\0\0\0\xb1\x01\0\0\0\0\xe2\x02\0\0\0\0\0\0\xb1\x01\0\0\xb1\x01\xb1\x01\0\0\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02\0\0\xb1\x01\0\0\0\0\0\0\0\0\0\0\xb8\x01\0\0\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\xb2\x01\0\0\xb1\x01\xb2\x01\0\0\xb1\x01\0\0\0\0\0\0\xb1\x01\xb1\x01\0\0\0\0\xb2\x01\0\0\0\0\xb1\x01\0\0\0\0\xb2\x01\0\0\0\0\0\0\xb1\x01\0\0\0\0\xb2\x01\0\0\xb2\x01\xb2\x01\0\0\0\0\0\0\0\0\0\0\xb1\x01\0\0\0\0\xe2\x02\xb1\x01\xb1\x01\xb2\x01\0\0\0\0\0\0\0\0\0\0u\0\0\0\0\0\0\0\xb1\x01\0\0\0\0\xb1\x01\0\0\0\0\0\0\0\0\xb4\x01\0\0\xb2\x01\xb4\x01a\0\xb2\x01\0\0\0\0\0\0\xb2\x01\xb2\x01\0\0\0\0\xb4\x01\0\0\0\0\xb2\x01a\0\0\0\xb4\x01\0\0\0\0\0\0\xb2\x01\0\0\0\0\xb4\x01\0\0\xb4\x01\xb4\x01a\0\0\0a\0a\0\0\0\xb2\x01\0\0\0\0\xa8\x01\xb2\x01\xb2\x01\xb4\x01\0\0\0\0\0\0a\0\0\0\0\0\0\0\0\0\0\0\xb2\x01\0\0\0\0\xb2\x01\0\0\0\0\0\0\0\0\xb3\x01\0\0\xb4\x01\xb3\x01\0\0\xb4\x01a\0\0\0\0\0\xb4\x01\xb4\x01\0\0\0\0\xb3\x01a\0\0\0\xb4\x01\0\0\0\0\xb3\x01a\0\0\0\0\0\xb4\x01\0\0\0\0\xb3\x01a\0\xb3\x01\xb3\x01\0\0\0\0\0\0\0\0\0\0\xb4\x01\0\0\0\0\xe0\x02\xb4\x01\xb4\x01\xb3\x01\0\0a\0\0\0\0\0\0\0\0\0\0\0\0\0e\0\xb4\x01\0\0\0\0\xb4\x01a\0\0\0\0\0a\0\0\0\0\0\xb3\x01\0\0e\0\xb3\x01\0\0\0\0\xb5\x01\xb3\x01\xb3\x01\xb5\x01\0\0\0\0\0\0\0\0\xb3\x01e\0\0\0e\0e\0\xb5\x01\0\0\xb3\x01\xe0\x02\0\0\0\0\xb5\x01\0\0\0\0\0\0\0\0e\0\0\0\xb5\x01\xb3\x01\xb5\x01\xb5\x01\0\0\xb3\x01\xb3\x01\0\0\0\0\0\0\0\0\0\0E\0\0\0\0\0\xb5\x01\0\0\xb3\x01e\0\0\0\xb3\x01\0\0\0\0\0\0\0\0\0\0e\0\0\0\0\0\0\0\0\0\0\0e\0\xb8\x01\0\0\xb5\x01\xb8\x01\0\0\xb5\x01e\0\0\0\0\0\xb5\x01\xb5\x01\0\0\0\0\xb8\x01\0\0\0\0\xb5\x01\0\0\0\0\xb8\x01\0\0\0\0e\0\xb5\x01F\0\0\0\xb8\x01\0\0\xb8\x01\xb8\x01\0\0\0\0\0\0\0\0e\0\xb5\x01\0\0e\0\0\0\xb5\x01\xb5\x01\xb8\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\xb5\x01\0\0\0\0\xb5\x01\0\0\0\0\0\0\xe2\x02u\0\0\0\xb8\x01\0\0\xe2\x02\xb8\x01\0\0\0\0\0\0\xb8\x01\xb8\x01\0\0\0\0u\0\0\0\xd5\x01\xb8\x01\xe2\x02\0\0\xe2\x02\xe2\x02\0\0\0\0\xb8\x01\xd5\x01\0\0u\0\0\0u\0u\0\0\0\0\0\xe2\x02\0\0\0\0\xb8\x01\0\0\0\0\0\0\xb8\x01\xb8\x01u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa8\x01\xb8\x01\xe2\x02\0\0\xb8\x01\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02u\0\0\0\xa8\x01u\0\0\0\xe2\x02\0\0u\0u\0\0\0\0\0\0\0\xe2\x02\0\0u\0\xa8\x01\0\0\xa8\x01\xa8\x01\0\0\0\0u\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02\xa8\x01\0\0\0\0u\0\0\0\0\0\0\0u\0u\0\0\0\xe2\x02\xe0\x02\0\0\xe2\x02\0\0\0\0\0\0\0\0\xe0\x02u\0\xa8\x01\xe0\x02u\0\xa8\x01\0\0\0\0\0\0\xa8\x01\xa8\x01\0\0\0\0\xe0\x02\0\0{\0\xa8\x01\0\0\0\0\0\0\0\0\0\0\0\0\xa8\x01\0\0\0\0\xe0\x02\0\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0\0\0\xa8\x01\0\0|\0\0\0\xa8\x01\xa8\x01\xe0\x02\0\0\0\0\0\0\xe0\x02\0\0\0\0\0\0\0\0\0\0\xa8\x01\0\0\0\0\xa8\x01\0\0\0\0\0\0\xe0\x02\0\0\0\0\xe0\x02\0\0\0\0\xe0\x02\0\0\0\0E\0\0\0\xe0\x02E\0\xe0\x02\0\0\xe0\x02\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0E\0\0\0\xe0\x02\0\0\0\0\0\0\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0E\0\xe0\x02E\0E\0\0\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0\0\0\0\0\xe0\x02E\0E\0\xe0\x02\xe0\x02\0\0F\0\xe0\x02\xe0\x02F\0\xe2\x02\0\0\0\0\0\0\xe0\x02\0\0\0\0\0\0\0\0F\0\xe2\x02\xe0\x02E\0\0\0\0\0E\0\0\0\0\0\0\0E\0E\0\0\0F\0\xe0\x02F\0F\0E\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0E\0\0\0\0\0F\0F\0\0\0\xe0\x02\0\0\0\0\xe0\x02\0\0\0\0E\0\xd5\x01\0\0\0\0E\0E\0\0\0\0\0\0\0\xd5\x01\xd5\x01\0\0F\0\0\0\xd5\x01F\0E\0\0\0\0\0F\0F\0\0\0\0\0\xd5\x01\0\0\0\0F\0\xd5\x01\0\0\xd5\x01\xd5\x01\0\0\xe0\x02F\0\0\0\0\0\xd5\x01\0\0\xd5\x01\xd5\x01\0\0\0\0\xd5\x01\0\0\0\0F\0\0\0\0\0\0\0F\0F\0\xd5\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0F\0\xd5\x01\0\0\0\0\xd5\x01\0\0\0\0\xd5\x01\xd5\x01\xd5\x01\xd5\x01\0\0\0\0\xd5\x01\0\0\xd5\x01\xd5\x01\xd5\x01\xd5\x01\0\0\0\x006\0\xd5\x01\0\0\xd5\x01\0\0\0\0\xe0\x02\0\0\0\0\xe0\x02\xd5\x01\0\0\0\0\xd5\x01\0\0\0\0\0\0\xd5\x01\xd5\x01\xe0\x02\0\0\0\0\xd5\x01\0\0\0\0\0\0\xd5\x01\xd5\x01{\0\xd5\x01\0\0{\0\xe0\x02\0\0\xe0\x02\xe0\x02\0\0\0\0\xd5\x018\0\0\0{\0\0\0\0\0\0\0\0\0\xe0\x02\xe0\x02\0\0\0\0|\0\0\0\0\0|\0{\0\0\0{\0{\0\0\0\0\0\0\0\0\0\0\0|\0\0\0\0\0\0\0\xe0\x02\0\0{\0\xe0\x02\0\0\0\0\0\0\0\0\xe0\x02|\0\0\0|\0|\0\0\0\xe0\x02\0\0<\0\0\0\0\0\0\0\0\0\xe0\x02{\0\0\0|\0{\0\0\0\0\0\0\0{\0{\0\0\0\0\0\xe0\x02\0\0\0\0{\0\xe0\x02\xe0\x02\0\0\0\0\0\0\0\0{\0|\0\0\0\0\0|\0\0\0\xe0\x02\0\0|\0|\0\0\0\0\0{\0\0\0\0\0|\0{\0{\0?\0\xe2\x02\0\0\0\0|\0\0\0\0\0\0\0\0\0\xe2\x02{\0\xe2\x02\0\0\0\0\xe2\x02\0\0|\0\0\0\0\0\0\0|\0|\0@\0\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\xe0\x02|\0\0\0\0\0\0\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\0\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02\0\0\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\0\0\xe0\x02\xe2\x02\xe2\x02\xe0\x02\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\0\0\0\0\0\0\xe0\x02\0\0\xe2\x02\0\0\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02\0\0\0\0\0\0\xe0\x02\xe2\x02\xe0\x02\xe0\x02\0\0\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\x02\0\0\xe2\x02\0\0'\x02\0\0'\x02'\x02'\x026\0'\x02\0\0\0\0'\x02'\x02\0\0\0\0\0\0\0\0\0\0\xe0\x02\0\x006\0\xe0\x02\0\0\0\0\0\0\0\0\xe0\x02\0\0\0\0'\x02\0\0\0\0\xe0\x026\0\0\x006\x006\0'\x02'\x02\xe0\x02\0\0\0\0\0\0\0\0\0\0'\x028\0\0\x006\0\0\0\0\0\xe0\x02\0\0\0\0\0\0\xe0\x02\xe0\x02'\x02'\x028\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\x026\0\0\0\0\x006\x008\0\0\x008\x008\x006\0\0\0\0\0\0\0\0\0\0\x006\0\0\0\0\0\0\0\0\x008\0\0\x006\0<\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x006\0\0\0<\0\0\x006\x006\x008\0\0\0\0\x008\0\0\0\0\0\0\0\0\x008\0<\x006\0<\0<\0\0\x008\0\0\0\0\0\0\0\0\0\0\0\0\x008\0\0\0\0\0<\0\0\0\0\0\0\0?\0\0\0\0\0\0\0\0\x008\0\0\0\0\0\0\x008\x008\0\0\0\0\0?\0\0\0\0\0<\0\0\0\0\0<\0\0\x008\0@\0\0\0<\0\0\0?\0\0\0?\0?\0<\0\xe0\x02\0\0\0\0\0\0@\0\0\0<\0\0\0\0\0\0\0?\0\0\0\0\0\xe0\x02\0\0\0\0\0\0@\0<\0@\0@\0\0\0<\0<\0\0\0\0\0\xe0\x02\0\0\xe0\x02\xe0\x02?\0\0\0@\0?\0<\0\0\0\0\0\0\0?\0\0\0\0\0\xe0\x02\0\0\0\0?\0\0\0\0\0\0\0\0\0\0\0\0\0?\0@\0\0\0\0\0@\0\0\0\0\0\0\0\0\0@\0\xe0\x02\0\0?\0\xe0\x02\0\0@\0?\0?\0\xe0\x02\0\0\0\0\0\0@\0\0\0\xe0\x02\0\0\0\0\0\0?\0\0\0\0\0\xe0\x02\0\0\0\0@\0\0\0\0\0\0\0@\0@\0\0\0\0\0\0\0\xe0\x02\0\0\0\0\0\0\xe0\x02\xe0\x02\xdb\x02@\0\0\0\0\0\0\0\xdb\x02\xdb\x02\xdb\x02\xdb\x02\0\0\xe0\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\0\0\0\0\0\0\0\0\xdb\x02\0\0\0\0\0\0\0\0\0\0\0\0\xdb\x02\0\0\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\0\0\0\0\0\0\0\0\xdb\x02\0\0\xdb\x02\0\0\0\0\0\0\0\0\0\0\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\0\0\0\0\xdb\x02\xdb\x02\0\0\0\0\xdb\x02\xdb\x02\xdb\x02\xdb\x02\0\0\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\0\0\xdb\x02\0\0\xdb\x02\xdb\x02\0\0\xdb\x02\0\0\xdb\x02\xdb\x02\0\0\0\0\xdb\x02\xdb\x02\0\0\xdb\x02\0\0\xdb\x02\0\0\0\0\xdb\x02\xdb\x02\0\0\0\0\xdb\x02\xdb\x02\0\0\0\0\0\0\xdb\x02\0\0\0\0\xdb\x02\0\0\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\xdb\x02\0\0\0\0\xdb\x02#\x01$\x01%\x01\0\0\0\0\t\0\n\0&\x01\0\0'\x01\0\0\f\0\r\0\0\0\0\0(\x01)\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\x01\0\0\0\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0+\x01\0\0\0\0\x16\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\x001\x01\0\0\"\0#\0$\0\0\0\0\0\0\0&\0\0\x002\x013\x01\0\x004\x01\0\0*\0+\0\0\0,\0\0\0\0\0\0\x005\x016\x017\x018\x019\x01:\x01\0\0\0\0\0\0\0\0\0\0\0\0;\x01\0\0\0\0\0\0<\x01\0\0=\x012\0\0\0\0\0\0\0\0\x003\x004\0\0\x006\0#\x01$\x01%\x01\0\x007\0\t\0\n\0&\x01\0\0'\x01\0\0\f\0\r\0\0\0\0\0\0\0)\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\x01\0\0\0\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0+\x01\0\0\0\0\x16\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\x001\x01\0\0\"\0#\0$\0\0\0\0\0\0\0&\0\0\x002\x013\x01\0\x004\x01\0\0*\0+\0\0\0,\0\0\0\0\0\0\x005\x016\x017\x018\x019\x01:\x01\0\0\0\0\0\0\0\0\0\0\0\0;\x01\0\0\0\0\0\0<\x01\0\0=\x012\0\0\0\0\0\0\0\0\x003\x004\0\0\x006\0#\x01$\x01%\x01\0\x007\0\t\0\n\0&\x01\0\0'\x01\0\0\f\0\r\0\0\0\0\0\0\0)\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\x01\0\0\0\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0+\x01\0\0\0\0\x16\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\x001\x01\0\0\"\0#\0$\0\0\0\0\0\0\0&\0\0\x002\x013\x01\0\0Z\x03\0\0*\0+\0\0\0,\0\0\0\0\0\0\x005\x016\x017\x018\x019\x01:\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0<\x01\0\0=\x012\0\0\0\0\0\0\0\xe2\x023\x004\0\0\x006\0\xe2\x02\xe2\x02\xe2\x02\xe2\x027\0\0\0\xe2\x02\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\xe2\x02\xe2\x02\xe2\x02\0\0\0\0\0\0\xe2\x02\xe2\x02\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\0\0\xe2\x02\xe2\x02\0\0\xe2\x02\0\0\xe2\x02\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\xe2\x02\0\0\0\0\0\0\xe2\x02\0\0\0\0\xe2\x02\0\0\xe2\x02\xe2\x02\0\0\xe2\x02\xe2\x02\xe2\x02^\x02\0\0\xe2\x02\0\0\0\0\xa5\x02\xa5\x02\xa5\x02\0\0\0\0\0\0\xa5\x02\xa5\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa5\x02\xa5\x02\xa5\x02\xa5\x02\xa5\x02\0\0\0\0\0\0\0\0\xa5\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa5\x02\xa5\x02\xa5\x02\0\0\xa5\x02\xa5\x02\xa5\x02\xa5\x02\xa5\x02\0\0\0\0\xa5\x02\0\0\0\0\0\0\xa5\x02\xa5\x02\xa5\x02\0\0\0\0\0\0\xa5\x02\0\0\xa5\x02\xa5\x02\0\0\0\0\0\0\xa5\x02\xa5\x02\0\0\xa5\x02\0\0\0\0\0\0\0\0\0\0\xa5\x02\xa5\x02_\x02\xa5\x02\0\0\0\0\0\0\xa6\x02\xa6\x02\xa6\x02^\x02\0\0\0\0\xa6\x02\xa6\x02\0\0\0\0\xa5\x02\0\0\0\0\0\0\0\0\xa5\x02\xa5\x02\0\0\xa5\x02\0\0\0\0\0\0\0\0\xa5\x02\0\0\xa6\x02\xa6\x02\xa6\x02\xa6\x02\xa6\x02\0\0\0\0\0\0\0\0\xa6\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa6\x02\xa6\x02\xa6\x02\0\0\xa6\x02\xa6\x02\xa6\x02\xa6\x02\xa6\x02\0\0\0\0\xa6\x02\0\0\0\0\0\0\xa6\x02\xa6\x02\xa6\x02\0\0\0\0\0\0\xa6\x02\0\0\xa6\x02\xa6\x02\0\0\0\0\0\0\xa6\x02\xa6\x02\0\0\xa6\x02\0\0\0\0\0\0\0\0\0\0\xa6\x02\xa6\x02\\\x02\xa6\x02\0\0\0\0\0\0\xa7\x02\xa7\x02\xa7\x02_\x02\0\0\0\0\xa7\x02\xa7\x02\0\0\0\0\xa6\x02\0\0\0\0\0\0\0\0\xa6\x02\xa6\x02\0\0\xa6\x02\0\0\0\0\0\0\0\0\xa6\x02\0\0\xa7\x02\xa7\x02\xa7\x02\xa7\x02\xa7\x02\0\0\0\0\0\0\0\0\xa7\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa7\x02\xa7\x02\xa7\x02\0\0\xa7\x02\xa7\x02\xa7\x02\xa7\x02\xa7\x02\0\0\0\0\xa7\x02\0\0\0\0\0\0\xa7\x02\xa7\x02\xa7\x02\0\0\0\0\0\0\xa7\x02\0\0\xa7\x02\xa7\x02\0\0\0\0\0\0\xa7\x02\xa7\x02\0\0\xa7\x02\0\0\0\0\0\0\0\0\0\0\xa7\x02\xa7\x02]\x02\xa7\x02\0\0\0\0\0\0\xa8\x02\xa8\x02\xa8\x02\\\x02\0\0\0\0\xa8\x02\xa8\x02\0\0\0\0\xa7\x02\0\0\0\0\0\0\0\0\xa7\x02\xa7\x02\0\0\xa7\x02\0\0\0\0\0\0\0\0\xa7\x02\0\0\xa8\x02\xa8\x02\xa8\x02\xa8\x02\xa8\x02\0\0\0\0\0\0\0\0\xa8\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa8\x02\xa8\x02\xa8\x02\0\0\xa8\x02\xa8\x02\xa8\x02\xa8\x02\xa8\x02\0\0\0\0\xa8\x02\0\0\0\0\0\0\xa8\x02\xa8\x02\xa8\x02\0\0\0\0\0\0\xa8\x02\0\0\xa8\x02\xa8\x02\0\0\0\0\0\0\xa8\x02\xa8\x02\0\0\xa8\x02\0\0\0\0\0\0\0\0\0\0\xa8\x02\xa8\x02\0\0\xa8\x02\0\0\0\0\0\0\0\0\0\0\0\0]\x02\xeb\0\xec\0\xed\0\0\0\0\0\0\0\xa8\x02\0\0\xee\0\0\0\xef\0\xa8\x02\xa8\x02\0\0\xa8\x02\0\0\xf0\0\xf1\0\xf2\0\xa8\x02\0\0\xf3\0\xf4\0\xf5\0\0\0\xf6\0\xf7\0\xf8\0\0\0\xf9\0\xfa\0\xfb\0\xfc\0\0\0\0\0\0\0\xfd\0\xfe\0\xff\0\0\0\0\0\0\0\0\0\0\0\0\x01\x01\x01\0\0\0\0\0\0\0\0\x02\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03\x01\x04\x01\0\0\0\0\0\0\0\0\x05\x01\x06\x01\0\0\0\0\0\0\x07\x01\b\x01\0\0\t\x01\0\0\n\x01\x0b\x01\f\x01\0\0\r\x01\0\0\0\0\0\0\0\0\0\0\x0e\x01\0\0\0\0\0\0\0\0\x0f\x01\0\0\0\0\0\0\0\0\0\0\x10\x01\b\x02\0\0\x11\x01\x12\x01\b\x02\x13\x01\x14\x01\x15\x01\x16\x01\x17\x01\0\0\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\0\0\b\x02\0\0\b\x02\0\0\0\0\xf5\x01\0\0\0\0\0\0\b\x02\b\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\b\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\b\x02\b\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\b\x02\0\0\0\0\0\0\b\x02\0\0\b\x02\b\x02\b\x02\0\0\b\x02\0\0\0\0\b\x02\0\0\0\0\0\0\0\0#\x01$\x01%\x01\0\0\0\0\0\0\n\0\xe1\x01\0\0'\x01\0\0\0\0\r\0\xf5\x01\b\x02\xe2\x01)\x01\0\0\b\x02\0\0\b\x02\0\0\0\0\b\x02\0\0\0\0\0\0*\x01\xa2\0\0\0\x11\0\x12\0\b\x02\0\0\b\x02\0\0+\x01\0\0\0\0\0\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\x001\x01\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\0\0\0\0\xe3\x01\xe4\x01\0\0\xe5\x01\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\x005\x016\x01\xe6\x01\xe7\x019\x01\xe8\x01\0\0\0\0\0\0\0\0\0\0\0\0;\x01\0\0\0\0\xab\0<\x01\0\0=\x012\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0#\x01$\x01%\x01\0\0\0\0\0\0\n\0\xe1\x01\0\0'\x01\0\0\0\0\r\0\0\0\0\0\0\0)\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\x01\xa2\0\0\0\x11\0\x12\0\0\0\0\0\0\0\0\0+\x01\0\0\0\0\0\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\x001\x01\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\0\0\0\0\xe3\x01\xe4\x01\0\0\xe5\x01\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\x005\x016\x01\xe6\x01\xe7\x019\x01\xe8\x01\0\0\0\0\0\0\0\0\0\0\0\0;\x01\0\0\0\0\xab\0<\x01\0\0=\x012\0\0\0\0\0\0\0\0\x003\0\0\0\x01\x036\0\xac\0#\x01$\x01%\x01\0\0\0\0\0\0\n\0\xe1\x01\0\0'\x01\0\0\0\0\r\0\0\0\0\0\0\0)\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\x01\xa2\0\0\0\x11\0\x12\0\0\0\0\0\0\0\0\0+\x01\0\0\0\0\0\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\x001\x01\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\0\0\0\0\xe3\x01\xe4\x01\0\0\xe5\x01\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\x005\x016\x01\xe6\x01\xe7\x019\x01\xe8\x01\0\0\0\0\0\0\0\0\0\0\0\0;\x01\0\0\0\0\xab\0<\x01\0\0=\x012\0\0\0\0\0\0\0\0\x003\0\0\0\xca\x036\0\xac\0#\x01$\x01%\x01\0\0\0\0\0\0\n\0\xe1\x01\0\0'\x01\0\0\0\0\r\0\0\0\0\0\0\0)\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\x01\xa2\0\0\0\x11\0\x12\0\0\0\0\0\0\0\0\0+\x01\0\0\0\0\0\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\x001\x01\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\0\0\0\0\xe3\x01\xe4\x01\0\0\xe5\x01\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\x005\x016\x01\xe6\x01\xe7\x019\x01\xe8\x01\0\0\0\0\0\0\0\0\0\0\0\0;\x01\0\0\0\0\xab\0<\x01\0\0=\x012\0\0\0\0\0\0\0\0\x003\0\0\0\b\x046\0\xac\0#\x01$\x01%\x01\0\0\0\0\0\0\n\0\xe1\x01\0\0'\x01\0\0\0\0\r\0\0\0\0\0\0\0)\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\x01\xa2\0\0\0\x11\0\x12\0\0\0\0\0\0\0\0\0+\x01\0\0\0\0\0\0\0\0\0\0,\x01-\x01.\x01/\x010\x01\0\0\0\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\x001\x01\0\0\xdd\x02\xa7\0\xa8\0\0\0\0\0\0\0\n\0\0\0\xe3\x01\xe4\x01\0\0\xe5\x01\r\0*\0\0\0\0\0\0\0\0\0\0\0\0\x005\x016\x01\xe6\x01\xe7\x019\x01\xe8\x01\0\0\0\0\xa2\0\0\0\x11\0\x12\0;\x01\0\0\0\0\xab\0<\x01\0\0=\x012\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\xdf\x02\xa7\0\xa8\0\0\0\0\0\0\0\n\0\0\0\xa9\0\0\0\0\0\0\0\r\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\0\0\xa2\0\0\0\x11\0\x12\0\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\xe1\x02\xa7\0\xa8\0\0\0\0\0\0\0\n\0\0\0\xa9\0\0\0\0\0\0\0\r\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\0\0\xa2\0\0\0\x11\0\x12\0\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\0\0\0\0\xa9\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\t\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\x0e\x005\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0f\0\x10\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\x17\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0!\0\0\0\0\0\"\0#\0$\0\0\0\0\0%\0&\0\0\0'\0(\0\0\0)\0\0\0*\0+\0\0\0,\0\0\0-\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\x006\x02\0\0\0\0\t\0\n\0\x0b\0\0\x001\0\0\0\f\0\r\0\x0e\x002\0\0\0\0\0\0\0\0\x003\x004\x005\x006\0\0\0\0\0\0\0\0\x007\0\x0f\0\x10\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\x17\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0!\0\0\0\0\0\"\0#\0$\0\0\0\0\0%\0&\0\0\0'\0(\0\0\0)\0\0\0*\0+\0\0\0,\0\0\0-\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\0\0\0\0\0\t\0\n\0\x0b\0\0\0\0\x001\0\f\0\r\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\x004\x005\x006\0\0\0\0\0\0\0\0\x007\0\0\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\"\0#\0$\0\0\0\0\0\0\0&\0\0\0'\0(\0\0\0\0\0\0\0*\0+\0\0\0,\0\0\0\0\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\0\0\0\0\0\0\0\xe6\0\t\0\n\0\x0b\0\0\0\0\0\xe9\0\f\0\r\x002\0\0\0\0\0\0\0\0\x003\x004\0\0\x006\0\0\0\0\0\0\0\0\x007\0\0\0\0\0\0\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\"\0#\0$\0\0\0\0\0\0\0&\0\0\0'\0(\0\0\0\0\0\0\0*\0+\0\0\0,\0\0\0\0\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\0\0\0\t\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\x004\0\0\x006\0\0\0\x06\x02\0\0\0\x007\0\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\"\0#\0$\0\0\0\0\0\0\0&\0\0\0'\0(\0\0\0\0\0\0\0*\0+\0\0\0,\0\0\0\0\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\x004\0\0\x006\0\0\0\xe4\x02\0\0\0\x007\0\xe4\x02\xe4\x02\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\0\0\0\0\t\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\x11\0\x12\0\x13\0\x14\0\x15\0\0\0\0\0\0\0\0\0\x16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\x1b\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\"\0#\0$\0\0\0\0\0\0\0&\0\0\0'\0(\0\0\0\0\0\0\0*\0+\0\0\0,\0\0\0\0\0\0\0\0\0\0\0.\0/\0\0\x000\0\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\x004\0\0\x006\0\0\0\0\0\0\0\0\x007\0\xe4\x02\xe4\x02\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\0\0\0\0\0\0\n\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0^\x03\0\0\xe4\x02C\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\0\0\0\0_\x03\0\0\xe4\x02\x11\0\x12\0\xf3\x01\0\0\xf3\x01\xf3\x01\xf3\x01\0\0\xf3\x01\0\0\0\0\xf3\x01\xf3\x01\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\xf3\x01 \0\0\0\0\0\0\0\0\0\xa7\0`\x03\xf3\x01\xf3\x01\0\0\0\0\0\0\xa9\0\n\0\0\0\xf3\x01\0\0*\0\0\0\r\0\0\0B\x02\0\0\x17\x02C\x02\0\0\xaa\0\xf3\x01\xf3\x01\0\0\0\0\x18\x02\0\0\0\0_\x03\0\0\0\0\x11\0\x12\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0`\x03\0\0\0\0\0\0\0\0\0\0\xa9\0\n\0\0\0\0\0\0\0*\0\0\0\r\0\0\0\xb9\x03\0\0\x17\x02\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\x18\x02\0\0\0\0\xba\x03\0\0\0\0\x11\0\x12\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xd4\x01\0\0\0\0\0\0\0\0\0\0\xa9\0\n\0\0\0\0\0\0\0*\0\0\0\r\0\0\0\x92\x05\0\0\x17\x02\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\x18\x02\0\0\0\0_\x03\0\0\0\0\x11\0\x12\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0`\x03\0\0\0\0\0\0\n\0\0\0\xa9\0\0\0\0\0\0\0\r\0*\0\0\0\0\0\0\0\0\0\0\0\x17\x02\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\x18\x02\0\0\0\0\x11\0\x12\0\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\x0b\x03\0\0\0\0\0\0\n\0\0\0\xa9\0\0\0\f\x03\0\0\r\0*\0\0\0\0\0\0\0\0\0\0\0\x17\x02\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\x18\x02\0\0\0\0\x11\0\x12\0\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xd4\x01\0\0\0\0\0\0\n\0\0\0\xa9\0\0\0E\x05\0\0\r\0*\0\0\0\0\0\0\0\0\0\0\0\x17\x02\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\x18\x02\0\0\0\0\x11\0\x12\0\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\x16\x02\0\0\0\0\0\0\n\0\0\0\xa9\0\0\0\0\0\0\0\r\0*\0\0\0\0\0\0\0\0\0\0\0\x17\x02\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\x18\x02\0\0\0\0\x11\0\x12\0\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\x18\0\x19\0\x1a\0\x15\x02\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xd4\x01\0\0\0\0\0\0\xe4\x02\0\0\xa9\0\0\0\0\0\0\0\xe4\x02*\0\0\0\0\0\0\0\0\0\0\0\x17\x02\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\x18\x02\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\x19\x02\0\x003\0\0\0\0\x006\0\xac\0\xe4\x02\xe4\x02\xe4\x02\xe4\x02\0\0\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\n\0\0\0\xe4\x02\0\0\0\0\0\0\r\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\xa2\0\0\0\x11\0\x12\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\xe4\x02\0\0\0\0\xe4\x02\0\0\xe4\x02\0\0\0\0\xe4\x02\xe4\x02\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\0\0\0\0\xa9\0\0\0\0\0\0\0\n\0*\0\0\0\0\0\xdf\x01\0\0\r\0\0\0\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe6\0\0\0\0\0\0\0\xa2\0\xab\0\x11\0\x12\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\0\0\0\0\xa9\0\xe4\x02\0\0\xe4\x02\0\0*\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\xe4\x02\xe4\x02\xab\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\0\0\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\0\0\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\n\0\xe4\x02\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\xa2\0\xe4\x02\x11\0\x12\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0\0\0\xa3\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xa8\0\0\0\0\0\0\0\xe4\x02\0\0\xa9\0\0\0\0\0\0\0\xe4\x02*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xaa\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\xe4\x02\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\xe4\x02\xe4\x02\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xa1\x02\0\0\xe4\x02\0\0\0\0\0\0\xa1\x02\xe4\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\0\0\xa1\x02\0\0\xa1\x02\xa1\x02\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\0\0\0\0\xe4\x02\xe4\x02\xa1\x02\xa1\x02\xa1\x02\0\0\xa1\x02\xa1\x02\0\0\xa1\x02\xa1\x02\0\0\0\0\xa1\x02\0\0\0\0\0\0\0\0\xa1\x02\xa1\x02\0\0\0\0\0\0\x8e\x02\0\0\xa1\x02\0\0\0\0\0\0\x8e\x02\xa1\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa1\x02\0\0\0\0\0\0\0\0\0\0\x8e\x02\0\0\x8e\x02\x8e\x02\0\0\0\0\0\0\xa1\x02\0\0\0\0\0\0\xa1\x02\0\0\0\0\0\0\0\0\xa1\x02\0\0\0\0\xa1\x02\xa1\x02\x8e\x02\x8e\x02\x8e\x02\0\0\x8e\x02\x8e\x02\0\0\x8e\x02\x8e\x02\0\0\0\0\x8e\x02\0\0\0\0\0\0\0\0\x8e\x02\x8e\x02\0\0\0\0\0\0\n\0\0\0\x8e\x02\0\0\0\0\0\0\r\0\x8e\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8e\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x11\0\x12\0\0\0\0\0\0\0\x8e\x02\0\0\0\0\0\0\x8e\x02\0\0\0\0\0\0\0\0\x8e\x02\0\0\0\0\x8e\x02\x8e\x02\x18\0\x19\0\x1a\0\0\0\0\0\xa4\0\0\0\xa5\0\xa6\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xd4\x01\0\0\0\0\0\0\0\0\0\0\xa9\0\n\0\x0b\0\0\0\0\0*\0\f\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\xaa\0\0\0\0\0|\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x11\0\x12\0\xab\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\xac\0\0\0\0\0\0\0\x18\0\x19\0\x1a\0}\x01\0\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xc0\0\0\0\0\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\0\0*\0+\0\0\0\0\0\0\0\0\0~\x01\0\0\0\0\0\0\0\0\0\x000\0\0\0\x7f\x01\0\0\x11\0\x12\0\0\0\0\0\0\0\0\0\x80\x01\x81\x01\0\0\0\x002\0\0\0\0\0\x82\x01\0\x003\0\0\0\0\x006\0\x18\0\x19\0\x1a\0}\x01\0\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xc0\0\0\0\0\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\0\0*\0+\0\0\0\0\0\0\0\0\0~\x01\0\0\0\0\0\0\0\0\0\x000\0\0\0\x7f\x01\0\0\x11\0\x12\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x002\0\0\0\0\0\x82\x01\0\x003\0\0\0\0\x006\0\x18\0\x19\0\x1a\0\0\0\0\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xa7\0\xc0\0\0\0\0\0\n\0\x0b\0\0\0\0\0\0\0\f\0\r\0\0\0*\0+\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x000\0\0\0\0\0\0\0\x11\0\x12\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x002\0\0\0\0\0\0\0\0\x003\0\0\0\0\x006\0\x18\0\x19\0\x1a\0\0\0\0\0\x1c\0\x1d\0\x1e\0\x1f\0\0\0\0\0 \0\0\0\0\0\0\0\0\0\xdb\0\xc0\0\0\0\0\0\xe4\x02\xe4\x02\0\0\0\0\0\0\xe4\x02\xe4\x02\0\0*\0+\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x04\0\0\0\0\0\x000\0\0\0\0\0\xc8\0\xe4\x02\xe4\x02\x89\0\0\0\x8a\0\x8b\0 \0\x91\x04\x8c\0\0\x002\0\x8d\0\x8e\0\0\0\xc9\x003\0\0\0\0\x006\0\xe4\x02\xe4\x02\xe4\x02\0\0\0\0\xe4\x02\xe4\x02\xe4\x02\xe4\x02\0\0\x8f\0\xe4\x02\0\0\0\0\0\0\0\0\xe4\x02\xe4\x02\x90\0\x90\x03\0\0\x89\0\0\0\x8a\0\x8b\0 \0\x92\0\x8c\0\xe4\x02\xe4\x02\x8d\0\x92\x04\0\0\0\0\0\0\0\0\x90\x04\xb7\x05\x93\0\x94\0\xe4\x02\0\0\0\0\xc8\0\0\0\0\0\0\0\0\0\x8f\0\0\0\0\0\0\0\0\0\0\0\xe4\x02\x93\x04\x90\0\x91\0\xc9\0\xe4\x02\0\0\0\0\xe4\x02\0\0\x92\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xcb\0\0\0\0\0\x94\x04\x94\0\0\0\0\0\0\0\0\0\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\0\0\x8c\0\0\0\0\0\x8d\0\x92\x04\0\0\0\0\0\0\0\0\xd3\x03W\x01X\x01\0\0\0\0\0\0\0\0\0\0\0\0Y\x01\0\0\0\0\x8f\0\0\0\xd4\x03Z\x01[\x01\xd5\x03\\\x01\0\0\x90\0\x91\0\0\0\0\0\0\0\0\0\0\0]\x01\x92\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0^\x01\xcb\0\0\0\0\0\x94\x04\x94\0_\x01`\x01a\x01b\x01c\x01#\x01$\x01%\x01\0\0\0\0\0\0\0\0\xe1\x01\0\0'\x01\0\0\0\0\0\0\0\0\0\0d\x01)\x01\0\0\0\0\0\0\xb9\0\0\0\0\0\0\0\0\0e\x01f\x01*\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0+\x01g\x01h\x01i\x01j\x01k\x01,\x01-\x01.\x01/\x010\x01\0\0\0\0\xd6\x03\0\0\0\0\0\0\0\0\0\0m\x01\0\0\0\0\0\0\0\0\0\0\0\x001\x01\0\0\0\0\0\0W\x01X\x01\0\0\0\0\0\0\0\0\x10\x02\xe4\x01Y\x01\x11\x02\0\0\0\0\0\0\0\0Z\x01[\x01\0\0\\\x015\x016\x01\x12\x02\xe7\x019\x01\xe8\x01\0\0\0\0]\x01\0\0\0\0\0\0\0\0\0\0W\x01X\x01<\x01^\x01=\x01\0\0\0\0\0\0Y\x01_\x01`\x01a\x01b\x01c\x01Z\x01[\x01\0\0\\\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0]\x01\0\0\0\0d\x01\0\0\0\0\0\0\0\0\xb9\0^\x01\0\0\0\0\0\0e\x01f\x01_\x01`\x01a\x01b\x01c\x01\0\0\0\0\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01\0\0\0\0\0\0\0\0\0\0d\x01W\x01X\x01l\x01\0\0\xb9\0\0\0\0\0m\x01Y\x01e\x01f\x01\0\0\0\0\0\0Z\x01[\x01\0\0\\\x01\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01]\x01\0\0\0\0\0\0\x10\x04\0\0W\x01X\x01\0\0^\x01\0\0\0\0\0\0m\x01Y\x01_\x01`\x01a\x01b\x01c\x01Z\x01[\x01\0\0\\\x01\0\0\0\0\0\0\0\0\0\0\0\0r\x04\0\0]\x01\0\0\0\0d\x01\0\0\0\0\0\0\0\0\xb9\0^\x01\0\0\0\0\0\0e\x01f\x01_\x01`\x01a\x01b\x01c\x01\0\0\0\0\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01\0\0\0\0\0\0\0\0?\x04d\x01W\x01X\x01\0\0\0\0\xb9\0\0\0\0\0m\x01Y\x01e\x01f\x01\0\0\0\0\0\0Z\x01[\x01\0\0\\\x01\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01]\x01\0\0\0\0\0\0\0\0\0\0W\x01X\x01\0\0^\x01\0\0\0\0\0\0m\x01Y\x01_\x01`\x01a\x01b\x01c\x01Z\x01[\x01\0\0~\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0]\x01\0\0\0\0d\x01\0\0\0\0\0\0\0\0\xb9\0^\x01\0\0\0\0\0\0e\x01f\x01_\x01`\x01a\x01b\x01c\x01\0\0\0\0\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01\0\0\0\0\0\0\0\0\0\0d\x01\xea\0\xea\0\0\0\0\0\xb9\0\0\0\0\0m\x01\xea\0e\x01f\x01\0\0\0\0\0\0\xea\0\xea\0\0\0\0\0\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01\xea\0\0\0\0\0\0\0\0\0\0\0W\x01X\x01\0\0\xea\0\0\0\0\0\0\0m\x01Y\x01\xea\0\xea\0\xea\0\xea\0\xea\0Z\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0]\x01\0\0\0\0\xea\0\0\0\0\0\0\0\0\0\xea\0^\x01\0\0\0\0\0\0\xea\0\xea\0_\x01`\x01a\x01b\x01c\x01\0\0\0\0\0\0\0\0\0\0\xea\0\xea\0\xea\0\xea\0\xea\0\0\0\0\0\0\0\0\0\xea\0d\x01W\x01X\x01\0\0\0\0\xb9\0\0\0\0\0\xea\0Y\x01e\x01f\x01\0\0\0\0\0\0Z\x01\0\0\0\0\0\0\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01]\x01\0\0\0\0\0\0\0\0\0\0\0\0R\x05\0\0^\x01\0\0\0\0\0\0m\x01\0\0_\x01`\x01a\x01b\x01c\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0W\x01X\x01\0\0\0\0\0\0\0\0\0\0\0\0d\x01\0\0\0\0\0\0\0\0\xb9\0Z\x01\0\0\0\0\0\0e\x01f\x01\0\0\0\0\0\0\0\0\0\0\0\0]\x01\0\0\0\0\0\0g\x01h\x01i\x01j\x01k\x01^\x01\0\0\0\0\0\0\0\0\0\0_\x01`\x01a\x01b\x01c\x01\0\0\0\0m\x01\0\0\0\0\0\0\0\0\0\0\x89\0\0\0\x8a\0\x8b\0 \0\0\0\x8c\0d\x01\0\0\x8d\0\x8e\0\0\0\xb9\0\0\0\0\0\0\0\0\0e\x01f\x01\xc0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8f\0\0\0\0\0h\x01i\x01j\x01k\x01\0\0\x90\0\x91\0\0\0\0\0\0\0\0\0\0\0\0\0\x92\0\0\0\0\0\0\0m\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x93\0\x94\0",
  check: "\x03\0\x04\0^\0\x06\0\x02\0\x92\0\x02\0>\x01\x0f\0\x83\x01\xa3\0\x89\0\x0e\x02\x8f\0\xa4\0!\x01\n\0\x89\0\xba\x02\xc0\x01\x1d\0\x9e\0\r\x03\x8b\0\t\x02\xd1\0\t\0\xb2\x01\xd5\0\f\0a\x03\x7f\x03\x1f\0$\0\xab\0\x8f\x01\x13\0\x14\0\x15\0\x16\0V\x02\x0b\x007\x03\xf3\x02\x1b\0\xba\x02\f\x02\xd4\0\x0e\x02\xa6\x04\x01\0\"\0\x03\0\x04\0\x02\0&\0\xd1\0\f\x04\x1c\0!\0+\0,\0\xe8\0%\0\xea\0\x03\0\x04\0o\x01\x02\x004\0\x07\0\0\x007\0;\0\0\0\x93\x04\0\0\x02\x000\0\f\x02\x84\0\x0e\x02\x86\0I\x04\x1f\x01b\0\x8a\x04\x8b\x04_\0\x03\0\x02\0\x8c\x01\xbc\x04\x01\0\xd2\0B\x04\x11\x01n\x001\0\x02\0b\0\x02\0b\0U\x04C\x01\xc5\0\x01\x02\x02\x02;\0A\x01\0\0\x0f\x01n\0S\0n\0U\0V\0@\x01\0\x01%\x01\x0f\x02\xf8\x03\0\x014\x01\x07\x01\x04\x01C\x01\x82\0z\0\b\x01\x97\x04\x8c\0\n\x01`\x01Z\x01\0\x01\x0f\x01\x17\x04\x9a\x04\x12\x01\x05\x001\0\xb7\x01\0\x01\xb9\x01\0\x01\x89\0A\x01\0\x01\x07\x01b\0\x91\0\x86\x04\0\x01u\x01`\x01\0\x01\0\x01r\x01\xac\x03\0\x01\0\x01n\0C\x01b\0$\x04\0\x01\x96\0J\x02\0\x01\x11\x01\n\x01N\x02b\0\0\x01`\x01n\0\x80\0\x12\x05\x82\0\b\x01\x84\0^\x03\x86\0E\x01n\0b\0\0\x01C\x01\xc0\0\x80\0\xae\0\x82\0\xc4\0\x84\0b\0\x86\0b\0n\0\xd4\x03\xd5\x03\0\x01\0\x01\xae\x04\xbb\0\0\x01.\x05n\0\xd3\0n\0C\x01\xb9\0\xba\0A\x01`\x01\b\x02\x82\0\0\x01\xbc\0\0\x01\xd2\x04A\x01A\x01\0\x01L\x02\xa2\0\x84\x02C\x01\xa5\0\xa6\0|\x01r\x01\xd7\0\x8e\x01A\x01\xd9\x04s\x01\x0e\x01]\x01`\x01\t\0\xb2\0\xb3\0\f\0\t\x05\xe3\x04o\x01\x07\x05\xda\0`\x01\x13\0\x14\0\x15\0\x16\0\x8b\x03^\x01`\x01\x11\x05\x1b\0o\x01u\x01\0\x01`\x01\xd6\0O\x01\x88\x04^\x01o\x01o\x01&\0`\x01\xd0\0C\x01=\x02+\0,\0\xbe\x01u\x01^\x05\x04\x01o\x01^\x01v\x014\0x\x01-\x057\0\x18\x01\0\x01\x04\x01C\x01A\x01B\x01\b\x01]\x01]\x01\0\0\0\x01a\x01a\x01\x0f\x01`\x01\x16\x01\x12\x01\xbe\x04 \x01\xd6\0\x9f\x02\xde\x01\0\x02\xe0\x01\x0e\x01]\x01`\x01\x11\x01\x03\x01a\x01\xbf\x01A\x01`\x01\0\x01\x16\x01\xb7\x05\xd0\x01&\x01\0\x01\xa2\x01\0\x01K\x01C\x01@\x05N\x01\xce\x01\xdb\x04\x04\x01\x1e\x01\x1f\x01o\x01\b\x01\0\x01\x85\x02\x86\x02f\x05E\x05:\x01\x0f\x01\0\x01\0\x01\x12\x01J\x01\0\x01Q\x01C\x01\x1a\x01]\x01\xfa\x02S\x01u\x05a\x01J\x01\n\x01l\x01P\x01$\x02\0\x01p\x01\0\x01\x05\x02g\x04@\x01k\x01D\x01\x0f\x01\xa6\x02\xaa\x01\x80\x01\xac\x01\xad\x05\xae\x01 \x02\x15\x02E\x04^\x01G\x04\xff\x04\x1a\x02Q\x01\x1e\x01\x91\x01\x9a\x05w\x03\\\x01\x1a\x01`\x017\x03\n\x05T\x04C\x01\xb7\x02C\x01s\x013\x03]\x02\x91\x01M\x02\x91\x01\0\x01\0\x01\xa5\x04\0\x01C\x01}\x01~\x01]\x01\x81\x05\x81\x01s\x05\x83\x01/\x04^\x01\x93\x01^\x01\x16\x01B\x01\0\x01\0\x01\0\x01\x1b\x01\0\x01\x12\x01o\x01\x1b\x03]\x01?\x05\n\x01\0\x01\n\x01\0\x01\0\x01`\x01]\x01\xb0\x01`\x01I\x05^\x01\x11\x01\0\x01a\x01\xb7\x01\x03\x01\xb9\x01\xb2\x01\xb5\x03\x91\x01\xf4\x03\b\x01\x80\x02\0\x01\0\x01+\x05`\x01\x12\x01%\x01\x11\x01Y\x02l\x01\xc1\x01\x91\x01o\x01A\x03#\x01\b\x01\xcf\x01\x1c\x05%\x01\xaa\x01\x91\x01\xac\x01\x0f\x01\xae\x01\xbe\x03\xbf\x03\b\x01$\x01\xd3\x01\x88\x02\xf3\x04\x80\x02\xaa\x01\x91\x01\xac\x01\0\x01\xae\x01\x1e\x01\xdd\x01<\x01~\x05\x96\x02\x91\x01]\x01\x91\x01B\x01\0\x01`\x01\xef\x04`\x01\xe9\x01\x92\x03\xb9\x03\0\x01\0\x01\xac\x03\n\x01\xbe\x03\xbf\x03\xcb\x04p\x036\x01^\x01 \x01^\x01a\x01a\x01a\x01`\x01\xfc\x01\xfd\x01\0\x01|\x03B\x01\x01\x02\x02\x02^\x01\f\x02a\x01\x0e\x02\x84\x03^\x01\xa3\x02h\x01\0\x01^\x01`\x01\0\x01\x0f\x02\b\x01o\x01\xb1\x05\x16\x01\x14\x02/\x02\xd4\x03\xd5\x03`\x01`\x01\x1c\x04\0\x01\b\x01\x0f\x01\x12\x01\x0e\x01\0\x02\xbf\x04\"\x02\x0f\x01\xf6\x01\xf7\x01\xf8\x01^\x01\xc2\x02\xf2\x02l\x01\xd2\x02\xfe\x01o\x01B\x01C\x01\xc3\x02\xc4\x02\x1e\x01\xbc\x03\xe8\x02\x1b\x01\x06\x01\b\x01^\x01\x12\x01\\\x01;\x02B\x014\x02\b\x01\x1b\x01@\x02A\x01B\x01^\x01J\x01b\x05a\x01a\x02\xf2\x02\x17\x04\x1c\x02^\x01`\x01\x17\x03p\x01\0\x01d\x02C\x01b\x02c\x02\xd1\x03\x10\x01B\x01\x12\x01\x12\x01\x16\x01$\x01]\x01\xf6\x02C\x01\0\x01\x12\x01c\x01d\x01\x12\x01\r\x036\x02\x16\x01^\x01\x16\x01]\x01\xae\x02\x1b\x01=\x02`\x01`\x02`\x01\x13\x01\b\x01`\x01u\x01\x0e\x01\x16\x01\x89\x02\x8a\x02\x0f\x01]\x01\x1b\x01\0\x01I\x04\x99\x05]\x02~\x02Q\x02l\x01\x1e\x01*\x04o\x01`\x01\x0e\x04\x1e\x01`\x01\x0e\x01\x13\x02(\x05/\x01*\x05^\x01^\x01u\x01Z\x03\x12\x01\x9d\x02\0\0^\x01\x0e\x01\x12\x01\x97\x02a\x03=\x01\x12\x018\x01W\x03X\x03Y\x03\\\x01\x12\x01E\x01\xbc\x02G\x01^\x01B\x01#\x04B\x01C\x01s\x03B\x015\x02]\x01`\x01^\x01\xb7\x02a\x01\x16\x01c\x01d\x01c\x01d\x01\x04\x01a\x03B\x02C\x02?\x03]\x01B\x01C\x01\xc9\x02a\x01\x16\x01c\x01d\x01\x1b\x01u\x01`\x01\x17\x01L\x03\xeb\x03\xdc\x04\xed\x03\xee\x03\x1b\x01q\x01\xae\x02l\x01\x03\x01\x1b\x01o\x01u\x01l\x01\xe9\x02\xea\x02o\x01Q\x01\x16\x01`\x01\xae\x02\0\x01^\x01\xde\x02`\x01\xe0\x02\x1b\x01\xe2\x02\xe3\x02`\x01\x1b\x01^\x01\xa5\x04`\x01\xa4\x03\b\x01\xff\x02B\x01\xdc\x04`\x01\x13\x01\xbe\x04\x0f\x01\x17\x01\xbc\x03C\x01C\x01\x1a\x01\\\x01\f\x03\x88\x03\xfa\x02\x99\x03\x1b\x01\xcf\x02\xfe\x02\b\x01\x1e\x01\xd3\x02\x95\x03\x13\x01\xd2\x04B\x01\x0f\x01\xc0\x05`\x01Z\x01`\x01/\x010\x01\xdb\x04\xdc\x04\x0f\x03\x11\x01;\x02\xbc\x03\x1b\x01\x03\x01\x1e\x01`\x01\b\x016\x01=\x01\xa4\x02\0\x01A\x01\xe7\x03B\x01\x02\x01 \x03E\x01\xc0\x05G\x01B\x01\0\x01`\x01n\x01\x04\x01\x03\x01`\x01r\x01\b\x01\x13\x01$\x01/\x030\x03\x03\x03\x0e\x01\x0f\x01D\x01\xf3\x04\x12\x01\xc1\x02\x13\x01B\x01:\x03J\x03<\x03J\x03\b\x01\x1a\x01T\x03`\x01C\x01C\x03D\x03\x0e\x04Q\x03G\x03\\\x03/\x010\x01_\x03\x0e\x01q\x01l\x01\xd9\x02w\x03o\x01\x0e\x01D\x01/\x010\x01C\x01=\x01`\x01\x1b\x01\xe5\x04\x0e\x01A\x01B\x01?\x01E\x01C\x01G\x01=\x01l\x01\x0e\x04\r\x05o\x01C\x01\x1b\x01D\x01E\x01a\x01G\x01C\x01D\x01\0\0\0\x01?\x05@\x05\x0e\x01\x04\x01A\x01\x1d\x04\0\0\b\x01\x03\x01D\x01I\x05\x0e\x01}\x03\x0e\x01\x0f\x01\x88\x03#\x01\x12\x01\x83\x03`\x01\x90\x03B\x01C\x01u\x01\x1b\x01S\x04q\x013\x04b\x01\xb5\x03Q\x01\x03\x01]\x01\x92\x03\0\x01A\x01B\x01q\x01\x04\x01\x98\x03\xa1\x03<\x01\b\x01A\x01\n\x01Q\x01u\x01B\x01\x0e\x01\x0f\x01\xa3\x037\x04\x12\x01\xa6\x03B\x01\x0f\x01S\x04r\x01\x12\x01\xb7\x03\x1b\x01\x1b\x01\xaf\x03~\x05b\x01\x16\x01C\x01\\\x05\0\0E\x04\xbf\x03R\x04\xcd\x03\xce\x03\f\x01E\x04g\x04\x0e\x01Q\x01h\x05-\x01.\x01p\x01^\x04\xc5\x03h\x01\xdb\x03\xb5\x05\xb6\x05o\x01\x1b\x01\b\x01o\x01\x1f\x01q\x01`\x01A\x01\xd2\x03\x9b\x01^\x03C\x01C\x01\xd7\x03\xec\x03\xab\x03\xba\x03e\x03C\x01J\x01B\x01\r\x011\x012\x013\x01\xb1\x05\0\x01\xe5\x03A\x01]\x01\x03\x01U\x01A\x01a\x01\\\x01\xda\x05\x1c\x01\x1d\x01]\x01^\x01B\x01`\x01a\x01L\x01\n\x04H\x01\xa0\x05\xa1\x05f\x01)\x01M\x01\xcf\x03\x1a\x01o\x01\x04\x01\x01\x04\0\0\x1d\x04\b\x01V\x01s\x01\x0e\x01c\x01\x1b\x01\x05\0\x0b\x04\x07\0(\x01\x12\x01=\x01C\x01\xe3\x03@\x01[\x05o\x01\xde\x04g\x01E\x01\x18\x04\x19\x04\xc2\x05r\x01\x17\0K\x01\x04\x01\0\x01 \x04\xf3\x03\b\x01A\x01R\x010\x04&\x04`\x01A\x01\x0f\x01*\x04#\x01\x12\x01`\x01\0\x01\x16\x01\xd8\x05C\x01\x13\x018\x01\xde\x04\x1b\x01o\x01<\x01\n\x01\x1a\x01\x1b\x01;\x04A\x01E\x04\xe6\x05C\x01n\x01\0\0u\x01\\\x01<\x01\xef\x04J\x01\x0e\x01A\x01Z\x01B\x01P\x01A\x01M\x04/\x010\x01A\x01o\x01f\x04\x1c\x05\x1b\x01i\x04o\x01p\x01\xe2\x03Y\x04^\x01B\x01=\x01C\x01\xe8\x03A\x01\xea\x03r\x01A\x01D\x01E\x01`\0G\x01Z\x04|\x04}\x04o\x01A\x01\xf6\x03A\x01\0\0\0\x01h\x01\x16\x01\x1c\x05s\x04\x1f\x01U\x04o\x01o\x01\x90\x04\x1b\x01o\x01B\x01\r\x01\\\x01o\x01p\x01\x80\x04c\x01\x82\x04\x83\x04\x84\x04\x9d\x041\x012\x013\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01o\x01\x89\0X\x05q\x01p\x01A\x01\x8e\0\x8f\0\x95\x04\0\x01\xab\x04)\x01o\x018\x01o\x01\x1b\x01A\x01\x16\x01D\x01:\x05C\x01M\x01A\x01\xbc\x04A\x01\x86\x04\xa2\0\xa3\0G\x05\xa5\0\xa6\0=\x01\xa8\0X\x05@\x01\x1a\x01A\x01C\x01D\x01E\x01\0\x01\0\x01\xb2\0\xb3\0\x04\x01K\x01\xbb\x04A\x01\b\x01\x04\x01\n\x01o\x01R\x01\b\x01\x0e\x01C\x01\x1f\x01A\x01\x12\x01\x0e\x01\x0f\x01B\x01o\x01\x12\x01^\x01\xce\x04`\x01\x1b\x01b\x01c\x01o\x01\xdc\x04\xd0\0\xd1\x001\x012\x013\x01\xd5\0%\x01\xf0\x04n\x01h\x04o\x01q\x01\xe1\x04l\x04A\x01u\x01f\x01\0\x05\x1b\x01#\x01\x03\x05\xea\x04\x05\x05\x04\x01\x04\x01\xee\x04\x1b\x01\b\x01\b\x01\xe5\x04M\x01o\x01\x16\x01\xc8\x04\x0f\x01\x10\x05\xd9\x04\x12\x01\x12\x01\xfc\x04C\x01A\x01J\x01A\x01<\x01\0\x01\xe3\x04A\x01B\x01\x04\x01B\x01\b\x05\x93\x04\b\x01H\x01\n\x01\r\x05\x1b\x01C\x01\x0e\x01o\x01]\x01^\x01,\x05`\x01a\x01C\x01\x04\x01V\x01\0\0\x1b\x05\b\x01\x1b\x01\xa8\x04\\\x01 \x05B\x01\0\x01\x0f\x01\0\x01`\x01\x12\x01A\x01s\x01\x16\x01#\x01C\x01o\x01h\x01o\x01>\x05r\x01>\x05o\x01p\x01o\x015\x05C\x01\0\x01K\x014\x01N\x05;\x05V\x05W\x05\x1a\x01\xac\x05Z\x05A\x05\x03\x01<\x016\x01_\x058\x01%\x01A\x01B\x01\xd4\x04C\x01J\x01M\x05\r\x01A\x01B\x01\x1a\x01K\x01S\x05C\x01o\x01\x12\x01C\x01\0\x01Q\x01n\x05n\x01\\\x05\x1c\x01\x1d\x01]\x01^\x01H\x01`\x01a\x01d\x05E\x05U\x01(\x01h\x05\x83\x05)\x01\x13\x01e\x01m\x05\0\0V\x01\xfa\x04\0\x01\x1a\x01\x1b\x01o\x01s\x01o\x01\x16\x01\0\x01y\x05\\\x01\r\x01\x1b\x01o\x01=\x01\0\x01o\x01@\x01\x96\x05Z\x01\x0e\x05C\x01E\x01/\x010\x01\x89\x05\x1c\x01\x1d\x01K\x01\x17\x01p\x01\xa3\x05\x1a\x05\xab\x05\x1a\x01R\x01\x8f\x01=\x01%\x01)\x01\0\x01\x1a\x01$\x01r\x01D\x01E\x01\x17\x01G\x01\xa0\x05\xa1\x05\x04\x01b\x01c\x018\x01\b\x01`\x01\xa8\x053\x05\xbe\x05=\x01!\x01\x0f\x01@\x01n\x01\x12\x01\xcb\x05\xcc\x05E\x01\0\x01\xb0\x01C\x01A\x01\xb8\x05K\x01\x0e\x01\xbb\x05\xb7\x01%\x01\xb9\x01\xd3\x05R\x01\xc1\x05\xc2\x058\x01\xbf\x01\0\x01B\x01<\x01U\x01q\x01\0\x01@\x01A\x01B\x01\x1a\x01A\x01b\x01c\x01\0\x01\xce\x01\xcf\x01\xd5\x05\xea\x05\xe3\x03\xd8\x05\xd4\x01L\x01P\x01n\x01\xdd\x05\x16\x01\x1a\x01\xe0\x05C\x01\0\0a\x01\x1a\x01\xe5\x05\xe6\x05\xf3\x03\xe8\x05\xe9\x05B\x01]\x01\x1a\x01c\x01d\x01\x1b\x01H\x01a\x01\0\x01B\x01\x1b\x016\x01\x80\x058\x01\0\x01H\x01o\x01\xf6\x01\xf7\x01\xf8\x01V\x01u\x01A\x01B\x01\x04\x01\xfe\x01\x12\x01!\x01\b\x01V\x01\x92\x05\x0e\x01\x94\x05\x13\x01\x11\x01\x0f\x01a\x01\0\0\x12\x01\f\x02\x1a\x01\x0e\x02\x9e\x05\x16\x01\x1b\x01A\x01\x13\x02\x1b\x01\x15\x02\x16\x028\x01\x16\x01\0\x01\x1a\x02<\x01\x1c\x02L\x01_\x01@\x01A\x01B\x01/\x010\x01$\x02o\x01\xb5\x05\xb6\x05\0\x01o\x01(\x01`\x01\x13\x01\xbc\x05\x10\x01P\x01=\x01_\x01\n\x01\x1a\x01B\x015\x026\x02D\x01E\x01\x1b\x01G\x01o\x01C\x01=\x02\xcd\x05B\x01n\x01o\x01B\x02C\x02\x03\x01\xd4\x05\0\x01J\x01/\x010\x01C\x01\xda\x05L\x02M\x02o\x01\xde\x05\n\x01Q\x02K\x01o\x01\xe3\x05\xe4\x05=\x01\x04\x01`\x01R\x01n\x01\b\x01U\x01D\x01E\x01)\x02G\x01A\x01\x0f\x01-\x02q\x01\x12\x01A\x01o\x01p\x01\0\x01\x01\x01\x02\x01\x03\x01\0\x01\x1b\x01A\x01B\x01\b\x01\t\x01\n\x01o\x01\b\x01\r\x01\x0e\x01\x0e\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\0\0\x80\x02\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01B\x01C\x01D\x01q\x01_\x01o\x01$\x01%\x01A\x01B\x01(\x01)\x01*\x01+\x01^\x01C\x01\b\x01/\x010\x01n\x01o\x01B\x01C\x01\0\x01\x9f\x02C\x01D\x01\0\x01\x0e\x01\xa4\x02$\x01=\x01>\x01a\x01@\x01\x18\x02\x19\x02C\x01D\x01E\x01J\x01G\x01\x13\x01\x0e\x01J\x01K\x01\x13\x01\x16\x01\xb7\x02\x1a\x01o\x01\xba\x02R\x01\x1a\x01T\x01\\\x01\x16\x01\x1b\x01\xc1\x02\0\x01\xc3\x02\xc4\x02a\x01]\x01^\x01a\x01`\x01a\x01b\x01c\x01/\x010\x01\xcf\x02`\x01/\x01i\x01\xd3\x02k\x01\x13\x01\0\x01n\x01A\x01\xd9\x02q\x01=\x01\x1a\x01\0\x01u\x01=\x01\x03\x01\0\0D\x01E\x01o\x01G\x01D\x01E\x01i\x01G\x01\r\x01\x0e\x01^\x01o\x01^\x01B\x01^\x01/\x01\xf2\x02\xf3\x02`\x01u\x01\x1b\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01u\x01\x14\x01.\x01\x0e\x01=\x01A\x01\x16\x01?\x01\x03\x03Q\x01(\x01)\x01E\x01A\x01G\x01\0\x01\x0b\x03\x0e\x01\r\x03\x04\x01q\x01\x0e\x01\x16\x01\b\x01q\x01\n\x01\x02\x01J\x01\x17\x03\x0e\x01\x0f\x01=\x01\x1b\x03\x12\x01@\x01L\0B\x01C\x01D\x01E\x01u\x01`\x01\x1b\x01J\x01f\x01K\x016\x017\x018\x019\x01\x0f\x01\0\0R\x01B\x01^\x01A\x01q\x01A\x01B\x01\\\x01J\x01f\x01`\x01A\x01^\x01^\x01`\x01l\0b\x01c\x01A\x03A\x01\b\x01\x0e\x01\0\x01\x1b\x01X\x01\x1b\x01\x1b\x01\x1e\x01n\x01A\x01C\x01q\x01A\x01~\0\x0e\x01u\x01^\x01J\x01o\x01\x03\x01\x85\0\x13\x01\0\0Z\x03\x0e\x01X\x011\x01^\x03\x1a\x01`\x03a\x03o\x01A\x01\x06\x01e\x03n\x01]\x01^\x01J\x01`\x01a\x01o\x01A\x01B\x01\x1b\x01p\x03a\x01`\x01s\x03/\x010\x01g\x01\x1b\x01\x0e\x01`\x01A\x01`\x01|\x03s\x01(\x01\0\x01Z\x01\x15\x01=\x01\x04\x01\x84\x03A\x01\x1b\x01\b\x01\x88\x03\n\x01E\x01\x8b\x03G\x01\x0e\x01\x0f\x01A\x01?\x01?\x01\x10\x01g\x01\r\x01\x95\x03?\x01\x0e\x01l\x01\x03\x01\x1b\x01o\x016\x017\x018\x019\x01\x0e\x01\xa1\x03B\x01\x1c\x01\x1d\x01A\x01\x1b\x01A\x01B\x01\xd7\0`\x01\xab\x03J\x01f\x016\x01`\x01)\x01J\x01\b\x01\x16\x01\0\0`\x01q\x01\x10\x01`\x01\xb9\x03\xba\x03L\x01\xbc\x03L\x01\xbe\x03\xbf\x03\x1b\x01`\x01C\x01\x07\0=\x01J\x01\x1b\x01\x0e\x01\x14\x01J\x01Z\x01\0\x01E\x01r\x01`\x01\xcf\x03J\x01\xd1\x03K\x01\x17\0`\x01o\x01A\x01r\x01\x1c\0R\x01\x0e\x01]\x01]\x01^\x01\x13\x01`\x01a\x01\0\x01\xe2\x03\xe3\x03\x03\x01\x1a\x01J\x01\xe7\x03\xe8\x03b\x01\xea\x03\x15\x01\x0e\x01\x0e\x01\r\x01\x0e\x01\x0e\x01\x0e\x01s\x01\xf3\x03\x1b\x01n\x01\xf6\x03\x13\x01q\x01Z\x01/\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x01\0\x02\0\x03\0\x04\0\x05\0\x06\0\x07\0r\x01\x0e\x01=\x01(\x01)\x01\x1b\x01]\x01\x0e\x01\x0e\x04D\x01E\x01\x16\x01G\x01\x0f\x01\x0e\x01\0\0\x0e\x01\x17\x04a\x01\0\0\0\0o\x01b\x01b\x01=\x01^\x01o\x01@\x01\b\x01#\x04R\x01D\x01E\x01A\x01^\x01$\x01\\\x01$\x01K\x01^\x01\0\x01/\x04,\x01-\x01.\x01R\x01`\x01J\x01\b\x017\x046\x01A\x01\x16\x01\r\x01q\x01A\x01A\x01^\x016\x01`\x01B\x04b\x01c\x01E\x04]\x01G\x04\x1a\x01I\x04\x1c\x01\x1d\x01H\x01I\x01\x92\0n\x01A\x01A\x01q\x01S\x04T\x04U\x04u\x01)\x01A\x01U\x01V\x01W\x01X\x01A\x01\xa2\0\xa3\0\xa4\0\xa5\0\xa6\0A\x01\xa8\0\x93\x01\r\x01g\x04h\x04\x80\0f\x01=\x01l\x04\x1c\x04\xb2\0\xb3\0\xde\x04C\x01D\x01E\x01Z\x04\x1c\x01\x1d\x01V\x04\x8e\x01K\x01\x80\x05X\x058\x05\xab\x01\xc7\x03\t\x03R\x018\x01)\x01:\x01;\x01<\x01\x86\x04>\x01`\x02\xa4\x01A\x01B\x01\xd0\0\xd1\0\x82\x01\xff\x01b\x01\xd5\0\x92\x04\x93\x04a\x02\xcf\x03=\x01=\x02\xd2\x02@\x01\xa6\0b\x04n\x01c\0E\x01q\x01f\x03\xc0\x05\xbc\x04\x1f\x04K\x01\\\x01\x12\x05\xcf\x01\xa8\x04\xff\xff\0\0R\x01c\x01\xc6\x04\xae\x04\x07\0\xbc\x02\xff\xff\xff\xff\x0b\0\0\x01\xff\xff\xff\xff\x03\x01o\x01p\x01\xff\xffb\x01c\x01\xff\xff\xbe\x04\xbf\x04\xff\xff\r\x01\xff\xff\xff\xff\x1c\0\x11\x01\xff\xffn\x01\xc8\x04\xff\xff\x16\x01\xcb\x04\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xd2\x04\xff\xff\xd4\x04\xff\xff\xff\xff\xff\xff0\0\xd9\x04\xff\xff\xdb\x04\xdc\x04)\x01\xde\x04\xff\xff\xff\xff\xff\xff\xff\xff\xe3\x04\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xef\x044\x01=\x01\xff\xff\xff\xff@\x01\xff\xffB\x01C\x01D\x01E\x01\xfa\x04S\0\xff\xffU\0V\0K\x01\xff\xffE\x01\xff\xff\xff\xffH\x01\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x0e\x05\xff\xff\xff\xff\xff\xff^\x01\xff\xff`\x01\0\x01b\x01c\x01\xff\xff\x04\x01\x1a\x05\xff\xff\x1c\x05\b\x01\xff\xff\n\x01\xff\xffO\x02n\x01\x0e\x01\0\x01q\x01T\x02\x12\x01(\x05u\x01*\x05o\x01\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff3\x05\xff\xff\xff\xff\xff\xff\x13\x01|\x01\xff\xff\0\0\xff\xff\xff\xff\xff\xff\x1a\x01?\x05@\x05\xff\xff\xff\xff\xff\xff\xff\xffE\x05\xff\xff\xff\xff\xff\xffI\x05\xa2\0\xa3\0\xff\xff\xa5\0\xa6\0\xff\xff\xa8\0\x7f\x02\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xffX\x05\xff\xff\xb2\0\xb3\0\xff\xff\xff\xff\xff\xffJ\x01\xa4\x01=\x01\xff\xff\xff\xff\xbc\0\xff\xff\xff\xff\xff\xff\xff\xffE\x01\xff\xffG\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xa2\x02`\x01a\x01\xff\xff\xd0\0\xd1\0\xff\xff\xff\xff\xff\xff\xff\xff~\x05\xff\xff\x80\x05\x81\x05\xda\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffs\x01\xff\xff\xff\xff\xff\xff\xd0\x01\xff\xff\xff\xff\xff\xff\xd4\x01\xff\xff\x92\x05\xff\xff\x94\x05q\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x9e\x05\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\x03\x01\xff\xff\xff\xff\xff\xff\xb1\x05\xf6\x01\xf7\x01\xf8\x01\xb5\x05\xb6\x05\r\x01\xff\xff\xff\xff\xfe\x01\xff\xff\xbc\x05\0\x01\xff\xff\xff\xff\xc0\x05\x05\x02\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\r\x02\xff\xff\xff\xff\0\0\xcd\x05&\x01\xfd\x02\x13\x01\x15\x02\x16\x02)\x01\xd4\x05\xff\xff\x1a\x02\x1a\x01\x1c\x02\xff\xff\xda\x05\xff\xff\xff\xff\xff\xff\xde\x05\xff\xff$\x02\xff\xff:\x01\xe3\x05\xe4\x05)\x02\xff\xff=\x01\xff\xff-\x02\xff\xff\xff\xff/\x01\xff\xffD\x01E\x01\xff\xff\xff\xff6\x02\0\0\xff\xffK\x01\xff\xff\xff\xff\xff\xff=\x02=\x01\x06\x01R\x01\b\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xff5\x03\xff\xffM\x02`\x01\xff\xffb\x01Q\x02\xff\xff\xff\xff\xff\xff\xff\xff@\x03\xff\xffB\x03\xff\xff\xff\xffo\x01n\x01\xff\xff\xff\xffq\x01`\x02\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff}\x01~\x01\xff\xff\xff\xff\x81\x01\xff\xff\x83\x01\xff\xff8\x01q\x01:\x01;\x01<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xffg\x03\0\x01\xff\xff\x80\x02\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\xff\xff\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01~\x03\\\x01\x18\x01\x19\x01\x1a\x01\x83\x03\x1c\x01\x1d\x01c\x01\xff\xff\xff\xff\xff\xff\xa0\x02\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01o\x01p\x01\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xd4\x01\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xcf\x02R\x01\xbb\x03\xd2\x02\xd3\x02\xff\xff\xff\xff\xc0\x03\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xf6\x01\xf7\x01\xf8\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xfe\x01\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xf2\x02u\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\r\x02\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x15\x02\x16\x02\x03\x03\xff\xff\xef\x03\x1a\x02\xff\xff\x1c\x02\xff\xff\xff\xff\x0b\x03\xff\xff\r\x03\xff\xff\xff\xff\0\x01\0\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x17\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\0\x006\x02\xff\xff\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff=\x02\x1a\x01\x1a\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff4\x03\xff\xff \x04\0\x01\xff\xff)\x01\xff\xff\x04\x01&\x04Q\x02\xff\xff\b\x01/\x01\n\x01\xff\xff\xff\xff\xff\xff\x0e\x01\xff\xff\xff\xff\xff\xff\x12\x01\xff\xff\xff\xff`\x02=\x01=\x01\xff\xff@\x01\xff\xff\x1b\x01\xff\xff\xff\xffE\x01E\x01\xff\xffG\x01\xff\xffZ\x03K\x01\xff\xff\xff\xff\xff\xff\xff\xff`\x03a\x03R\x01\xff\xff\xff\xff\xff\xff\x07\0\xff\xff\xff\xff\xff\xff\x0b\0\xff\xff\x80\x02\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01s\x03\xff\xff\xff\xffv\x03\xff\xff\xff\xffc\x04C\x01\x1c\0\xff\xff\xff\xffn\x01\xff\xff\xff\xffJ\x01q\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff0\0\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01\x99\x03\xff\xff\x85\x04\xff\xff\x87\x04\xff\xff\x89\x04\xff\xff\xff\xff\x8c\x04\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffs\x01\xab\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x9b\x04S\0\xff\xffU\0V\0\xff\xff\xff\xff\0\x01\xff\xff\xba\x03\xcf\x02\xbc\x03\xff\xff\xff\xff\xd3\x02\xff\xff\xff\xff\xac\x04\xad\x04\xff\xff\r\x01\xff\xff8\x01\xb2\x04:\x01;\x01<\x01\xff\xff>\x01\xff\xff\xcf\x03A\x01B\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xf2\x02P\x01\xff\xff)\x01S\x01\xe3\x03\xce\x04\xff\xff\xff\xff\xe7\x03\x89\0\xff\xff[\x01\\\x01\xff\xff\xff\xff\xff\xff\x03\x03\xff\xff\xff\xffc\x01\xf3\x03\xff\xff=\x01\xff\xff\x0b\x03\xff\xff\r\x03\xff\xffC\x01D\x01E\x01o\x01p\x01\xff\xff\xa2\0\xa3\0K\x01\xa5\0\xa6\0\xff\xff\xa8\0\xff\xff\xff\xffR\x01\x07\0\xff\xff\xff\xff\x0e\x04\xff\xff\xff\xff\xb2\0\xb3\0\xff\xff\x10\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffb\x01\xbc\0\xff\xff\x1d\x04\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\x03\x01\xff\xffn\x01\xff\xff\x12\x05q\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xd0\0\xd1\0\xff\xff\x11\x013\x04\xff\xff\xff\xff \x05\x16\x01\xff\xff\xda\0\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff.\x05\xff\xff\xff\xff1\x05\xff\xff\xff\xff)\x01\xff\xff`\x03a\x03\xff\xff\xff\xff\xff\xff\xff\xff\0\x01S\x04\xff\xffU\x04\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xffB\x01C\x01D\x01E\x01g\x04d\0\xff\xff\xff\xffU\x05K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0^\x01\xff\xff`\x01\xff\xffb\x01c\x01&\x01\x86\x04\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01n\x01>\x01`\0q\x01A\x01B\x01\xff\xffu\x01\xab\x03\xff\xff:\x01\x84\x05\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xa2\0\xa3\0\xbc\x03\xa5\0\xa6\0\xff\xff\xa8\0[\x01\\\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffc\x01\xb2\0\xb3\0\xff\xff\xff\xff\xff\xff\xcf\x03\xff\xff\xa7\x05\xa8\x05\xff\xffn\x01o\x01p\x01\x07\0\xff\xff\xaf\x05\0\x01\xff\xff\xc8\x04\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffo\x01\xe3\x03\xff\xff\xff\xff\xff\xff\xff\xff\xd0\0\xd1\0\r\x01\xff\xff\xff\xff\xd9\x04\0\x01\xff\xff}\x01~\x01\xde\x04\xf3\x03\x81\x01\xff\xff\x83\x01\xe3\x04\xff\xff\x1c\x01\x1d\x01\r\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xef\x04\xff\xff\xff\xff)\x01\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xe2\x05\xff\xff\x0e\x04\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01)\x01>\x01\xff\xff=\x01A\x01B\x01@\x01\xff\xff\0\0\xff\xff\xff\xffE\x01\xb0\x01\xff\xff\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xb7\x01=\x01\xb9\x01S\x01@\x01R\x01\x1c\x05\xff\xffD\x01E\x01\xff\xff[\x01\\\x01\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xffb\x01R\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xd4\x01\xff\xffo\x01p\x01n\x01^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xffS\x04\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffE\x05Z\x04G\x05n\x01\xff\xff\xff\xffq\x01\r\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffg\x04\xff\xff\xf6\x01\xf7\x01\xf8\x01X\x05\xff\xffV\x01\x1c\x01\x1d\x01\xfe\x01\xa2\0\xa3\0\xff\xff\xa5\0\xa6\0\xff\xff\xa8\0\xff\xff\xff\xffg\x05)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xb2\0\xb3\0\xff\xff\xff\xff\0\0o\x01\x15\x02\x16\x02\xff\xff\xff\xff\xff\xff\x1a\x02\xff\xff\x1c\x02=\x01\x06\x01\0\x01@\x01\xff\xff\x03\x01\xff\xff\xff\xffE\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffK\x01\r\x01\xd0\0\xd1\0\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff6\x02\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01=\x02\xff\xff\xff\xff\x9f\x05\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff8\x01Q\x02:\x01;\x01<\x01\xc8\x04>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff=\x01\xff\xff\xff\xff@\x01`\x02\x8f\x01C\x01D\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffK\x01\xde\x04\xff\xff\x0f\x01\xff\xff\xff\xff\xff\xffR\x01\xe5\x04\xff\xff\\\x01\xff\xff\xff\xff\xff\xff\xff\xff\xd4\x01\xff\xffc\x01\xef\x04^\x01\xff\xff`\x01\x80\x02b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xffo\x01p\x01+\x01,\x01-\x01.\x01n\x01\xff\xff\xff\xffq\x01\xff\xff\xc0\x01\xff\xffu\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf5\x01\xf6\x01\xf7\x01\xf8\x01\xcc\x01\xff\xff\xff\xffC\x01\xff\xff\xfe\x01\xff\xff\0\x01H\x01I\x01\xff\xff\x1c\x05\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\x03\x01\xff\xff\xff\xff\xff\xffU\x01V\x01W\x01X\x01\xb7\x02\0\0\r\x01\x15\x02\x16\x02\xff\xff\xff\xff\xff\xff\x1a\x02\xff\xff\x1c\x02\xff\xff\xff\xfff\x01\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xffo\x01(\x02\xff\xff\xcf\x02\xff\xff\xff\xff\xff\xff\xd3\x02\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff6\x02\xff\xff8\x01\xff\xff:\x01;\x01<\x01=\x02>\x01\xff\xffX\x05A\x01B\x01\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xf2\x02\xff\xffg\x05\xff\xffQ\x02K\x01S\x01\xff\xff\xff\xff\0\0\xff\xff\xff\xffR\x01\xff\xff[\x01\\\x01\xff\xff\x03\x03\xff\xff\xff\xff\xff\xff\xff\xffc\x01\xff\xff^\x01\x0b\x03`\x01\r\x03b\x01c\x01\xff\xff\x06\x01\xff\xff\0\x01o\x01p\x01\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01L\x02\xff\xff\r\x01u\x01\xff\xff\xff\xff\xff\xff\x80\x02\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x9f\x05\x1a\x01\xff\xff\x1c\x01\x1d\x01\xd4\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01\0\0>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff=\x01\xff\xff\xff\xff\xf6\x01\xf7\x01\xf8\x01\xff\xffD\x01E\x01\xff\xff\xff\xff\xfe\x01\xff\x01\xff\xffK\x01\xff\xff`\x03a\x03\xff\xff\xff\xff\xff\xffR\x01\xff\xff\\\x01\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\xff\xffc\x01\xff\xff\xff\xff\x9f\x02\x15\x02\x16\x02\xcf\x02b\x01\xff\xff\x1a\x02\xd3\x02\x1c\x02o\x01p\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\x88\x03\xff\xff\xff\xff\xff\xff\xff\xff\x8d\x03\xff\xff\xff\xff\x1e\0\x1f\0\xff\xff6\x02\xff\xff\xff\xff\xff\xff\xf2\x02\xff\xff\xff\xff=\x02\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01\x03\x03>\x01\xff\xff\xab\x03A\x01B\x01Q\x02\xff\xff\x0b\x03\xff\xff\r\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\x03\x01\xbc\x03\xff\xffS\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\r\x01[\x01\\\x01\xff\xffW\0X\0\xff\xff\xff\xff\xff\xffc\x01\xcf\x03\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xffo\x01p\x01\xff\xff\x80\x02\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xe3\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf3\x03\0\0=\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xffE\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xffK\x01\xff\xff`\x03a\x03\xff\xff\r\x017\x03R\x01\xff\xff\xff\xff\xff\xff\x0e\x04\xff\xff\xff\xff\xff\xff\xff\xffA\x03\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xffb\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\x86\x03\xcf\x02-\x04\xff\xff\xff\xff\xd3\x02\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffp\x03\xff\xff\xff\xffE\x04K\x01\x06\x01\0\x01\b\x01\xff\xff\xff\xff\xff\xffR\x01|\x03\xf2\x02\xab\x03\xff\xff\xff\xffS\x04\xff\xff\r\x01\x84\x03\xff\xff\xff\xff^\x01Z\x04`\x01\xff\xffb\x01c\x01\xff\xff\x03\x03\xbc\x03\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xffg\x04\x0b\x03n\x01\r\x03\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01)\x01\xff\xff\xff\xff\xcf\x03\xff\xff\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01\xac\x03>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff=\x01\xff\xff\xff\xff\xe3\x03\xff\xff\xff\xff\xb9\x03\xff\xffE\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffK\x01S\x01\xff\xff\xff\xff\xff\xff\xf3\x03\xff\xffR\x01\xff\xff[\x01\\\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xd1\x03c\x01\xff\xff\xd4\x03\xd5\x03\xff\xff\xff\xffb\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffo\x01p\x01\xff\xff\x0e\x04\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff`\x03a\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xc8\x04W\x01X\x01Y\x01Z\x01[\x01\\\x01]\x01^\x01_\x01`\x01a\x01b\x01c\x01d\x01e\x01f\x01g\x01h\x01i\x01j\x01k\x01\xde\x04m\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe5\x04\xff\xff\xff\xff\xff\xff\x17\x04\xff\xff\xff\xff\xff\xff{\x01\xff\xff\xef\x04\xff\xff\xff\xff\xff\xff\xff\xff\0\x01#\x04\x02\x01\x03\x01S\x04\x87\x01\xff\xff\xff\xff\b\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\x11\x01\x12\x01\x13\x01\xab\x03\xff\xff\xff\xff\xff\xffg\x04\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xffB\x04\xff\xff\xff\xff\xff\xff$\x01\xbc\x03\xff\xff\xff\xff\x1c\x05)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xcf\x03\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xff\xff\xffK\x01\xe3\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf3\x03]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01X\x05\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\x0e\x04\xff\xff\xc8\x04\xff\xff\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01\xa5\x04>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xae\x04\xff\xff\xff\xff\xde\x04\xff\xff\xb3\x04\xb4\x04\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xff\xbe\x04\xff\xff\xff\xff!\x02\xef\x04[\x01\\\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff*\x02c\x01\0\x01\xff\xff.\x02\x03\x01\xff\xff1\x02\xff\xff\xff\xff\b\x01\xff\xff\n\x01o\x01p\x01\r\x01\x0e\x01\xdb\x04\xff\xff\x11\x01S\x04\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\0\0\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x05\xff\xff%\x01g\x04\xf3\x04(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffb\x02c\x02\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x88\x02]\x01^\x01X\x05`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x018\x05\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff?\x05\xff\xffu\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffI\x05\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff8\x01\xc8\x04:\x01;\x01<\x01\0\x01>\x01\xff\xff\x03\x01A\x01B\x01\xff\xff\xff\xff\b\x01\xff\xff\n\x01\xff\xff\0\0\r\x01\x0e\x01\xff\xff\xff\xff\x11\x01\xde\x04\x13\x01\x14\x01\x15\x01S\x01\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01[\x01\\\x01\xff\xff\xff\xff\xff\xff\xef\x04\xff\xff%\x01c\x01~\x05(\x01)\x01\x81\x05\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xe8\x02o\x01p\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x05\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xb1\x05\x12\x03\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff6\x03\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffX\x05\xff\xff\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\x16\x01\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xffn\x03(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01?\x01@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\xff\xfff\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\0\0n\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\x04\x01\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xda\x03\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\xff\xfff\x01g\x01\0\0i\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xffr\x04\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01~\x04\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xaf\x04\xb0\x04\xb1\x04u\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\x16\x01\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\0\0f\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\x04\x01\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\0\0f\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\x16\x01\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\0\0f\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\x16\x01\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\0\0f\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\x16\x01\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\0\0f\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\x04\x01\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\xff\xff\xff\xff\0\0f\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\x04\x01\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\0\0\xff\xff\xff\xfff\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\x04\x01\xff\xff\x06\x01\x07\x01\b\x01\t\x01\n\x01\x0b\x01\f\x01\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01>\x01\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\0\0\xff\xff\xff\xfff\x01g\x01\xff\xffi\x01j\x01k\x01l\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\x16\x01\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff4\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\0\0f\x01\xff\xff\xff\xffi\x01j\x01k\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\x16\x01\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff4\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01S\x01T\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01d\x01\0\0f\x01\xff\xff\xff\xffi\x01j\x01k\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\xff\xff\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\xff\xff\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\xff\xff\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\0\0\xff\xff\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\0\0\xff\xff\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xffV\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xffV\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xffV\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xffV\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xffV\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01H\x01I\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xffV\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01+\x01,\x01-\x01.\x01/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff\xff\xff\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01U\x01\xff\xff\xff\xffX\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xfff\x01\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xffR\x01\xff\xffT\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01%\x01\xff\xff\xff\xff(\x01)\x01*\x01\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01>\x01\xff\xff@\x01\xff\xff\xff\xff\0\0D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\0\x01k\x01\xff\xff\x03\x01n\x01\xff\xff\xff\xffq\x01\b\x01\t\x01\n\x01u\x01\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\0\0D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\0\x01\xff\xffq\x01\x03\x01\xff\xff\xff\xffu\x01\xff\xff\b\x01\t\x01\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\0\0\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xffT\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\0\x01k\x01\xff\xff\x03\x01n\x01\xff\xff\xff\xffq\x01\b\x01\xff\xff\n\x01u\x01\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\0\x01k\x01\xff\xff\x03\x01n\x01\xff\xff\xff\xffq\x01\b\x01\xff\xff\n\x01u\x01\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\0\x01k\x01\xff\xff\x03\x01n\x01\xff\xff\xff\xffq\x01\b\x01\xff\xff\n\x01u\x01\xff\xff\r\x01\x0e\x01\xff\xff\x10\x01\x11\x01\x12\x01\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\xff\xff\x03\x01i\x01\xff\xffk\x01\xff\xff\b\x01n\x01\n\x01\xff\xffq\x01\r\x01\x0e\x01\xff\xffu\x01\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\xff\xff\x03\x01i\x01\xff\xffk\x01\xff\xff\b\x01n\x01\n\x01\xff\xffq\x01\r\x01\x0e\x01\xff\xffu\x01\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\0\x01k\x01\xff\xff\x03\x01n\x01\xff\xff\xff\xffq\x01\b\x01\xff\xff\n\x01u\x01\xff\xff\r\x01\x0e\x01\xff\xff\xff\xff\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\xff\xff\x03\x01i\x01\xff\xffk\x01\xff\xff\b\x01n\x01\n\x01\xff\xffq\x01\r\x01\x0e\x01\xff\xffu\x01\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\0\0@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\0\0\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\xff\xff\x03\x01i\x01\xff\xffk\x01\xff\xff\b\x01n\x01\n\x01\xff\xffq\x01\r\x01\x0e\x01\xff\xffu\x01\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\0\x01k\x01\xff\xff\x03\x01n\x01\xff\xff\xff\xffq\x01\b\x01\xff\xff\n\x01u\x01\xff\xff\r\x01\x0e\x01\xff\xff\xff\xff\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\0\x01q\x01\x02\x01\x03\x01\x04\x01u\x01\xff\xff\xff\xff\b\x01\0\x01\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01$\x01\x1c\x01\x1d\x01\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x018\x01)\x01:\x01;\x01<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff=\x01\xff\xff\xff\xff@\x01A\x01\xff\xffC\x01D\x01E\x01=\x01G\x01\0\0@\x01J\x01K\x01\xff\xffD\x01E\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xffK\x01\\\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01c\x01]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xfff\x01^\x01o\x01p\x01\xff\xffb\x01c\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\0\x01\xff\xffu\x01\x03\x01n\x01\xff\xff\xff\xffq\x01\b\x01\xff\xff\n\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff\xff\xff\x11\x01\xff\xff\x13\x01\x14\x01\x15\x01\xff\xff\xff\xff\x18\x01\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\x01\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\x01\xff\xffk\x01\xff\xff\xff\xffn\x01\xff\xff\0\x01q\x01\x02\x01\x03\x01\x04\x01u\x01\xff\xff\xff\xff\b\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\x02\x01\x03\x01\x04\x01\xff\xff\xff\xff\xff\xff\b\x01n\x01\xff\xff\xff\xffq\x01\r\x01\xff\xff\xff\xffu\x01\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\xff\xff\xff\xff\0\x01f\x01\x02\x01\x03\x01\x04\x01\xff\xff\xff\xff\xff\xff\b\x01n\x01\xff\xff\xff\xffq\x01\r\x01\xff\xff\xff\xffu\x01\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01\xff\xff\xff\xff\xff\xfff\x01\0\x01\xff\xff\x02\x01\x03\x01\x04\x01\xff\xff\xff\xffn\x01\b\x01\xff\xffq\x01\xff\xff\xff\xff\r\x01u\x01\xff\xff\xff\xff\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\x02\x01\x03\x01\x04\x01\xff\xff\xff\xff\xff\xff\b\x01n\x01\xff\xff\xff\xffq\x01\r\x01\xff\xff\xff\xffu\x01\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\x02\x01\x03\x01\x04\x01\xff\xff\xff\xff\0\0\b\x01n\x01\xff\xff\xff\xffq\x01\r\x01\xff\xff\xff\xffu\x01\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\x02\x01\x03\x01\x04\x01\xff\xff\xff\xffn\x01\b\x01\xff\xffq\x01\xff\xff\xff\xff\r\x01u\x01\xff\xff\xff\xff\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\0\0G\x01\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\0\x01\xff\xff\x02\x01\x03\x01\x04\x01\xff\xff\xff\xff\xff\xff\b\x01n\x01\xff\xff\xff\xffq\x01\r\x01\xff\xff\xff\xffu\x01\x11\x01\x12\x01\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\r\x01\xff\xff\xff\xffK\x01\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\0\0R\x01\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01\xff\xff\x03\x01q\x01\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff=\x01\xff\xff\r\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffK\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff^\x01\xff\xff`\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01=\x01\xff\xffq\x01@\x01\xff\xff\xff\xffu\x01D\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff`\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\0\x01u\x01\xff\xff\x03\x01\xff\xff\x05\x01\x06\x01\x07\x01\b\x01\xff\xff\xff\xff\x0b\x01\f\x01\r\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff$\x01\xff\xff\xff\xff'\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x011\x012\x013\x014\x015\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01\xff\xffD\x01E\x01F\x01G\x01H\x01I\x01\xff\xffK\x01L\x01M\x01N\x01\0\0P\x01\xff\xffR\x01S\x01\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff[\x01\xff\xff]\x01^\x01_\x01\xff\xffa\x01b\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01m\x01n\x01o\x01p\x01q\x01\xff\xff\xff\xfft\x01\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\r\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\x1d\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xffE\x01F\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\0\0R\x01\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01n\x01o\x01\x05\x01\x06\x01\x07\x01\xff\xfft\x01\xff\xff\x0b\x01\f\x01\r\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\x1d\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xffE\x01F\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xffR\x01\xff\xff\xff\xff\xff\xffV\x01W\x01\0\0Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01n\x01o\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\xff\xff\xff\xff\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\r\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\x1d\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x001\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xffE\x01F\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xffR\x01\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\0\0l\x01m\x01n\x01o\x01\xff\xff\xff\xff\0\x01\xff\xfft\x01\xff\xff\x04\x01\xff\xff\x06\x01\xff\xff\b\x01\xff\xff\n\x01\xff\xff\f\x01\r\x01\x0e\x01\x0f\x01\xff\xff\x11\x01\x12\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x014\x015\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01C\x01D\x01E\x01\xff\xff\0\0H\x01\xff\xffJ\x01K\x01\xff\xffM\x01\xff\xff\xff\xff\xff\xff\xff\xffR\x01S\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff]\x01^\x01\xff\xff`\x01a\x01b\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xffn\x01o\x01p\x01\xff\xff\0\x01s\x01\xff\xff\xff\xff\x04\x01\xff\xff\x06\x01\xff\xff\b\x01\xff\xff\n\x01\xff\xff\f\x01\xff\xff\x0e\x01\x0f\x01\0\0\x11\x01\x12\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01C\x01\xff\xff\xff\xff\xff\xff\xff\xffH\x01\xff\xffJ\x01\0\0\0\x01M\x01\xff\xff\x03\x01\x04\x01\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\r\x01\x0e\x01[\x01\xff\xff]\x01^\x01\x13\x01`\x01a\x01\xff\xffc\x01\xff\xff\xff\xff\x1a\x01g\x01\x1c\x01\x1d\x01j\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xffs\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\x04\x01@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\r\x01\x0e\x01\xff\xffK\x01\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff`\x01\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\0\0\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\x03\x01R\x01\xff\xff\xff\xff\xff\xff\b\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\x0e\x01\xff\xff^\x01\xff\xff`\x01\x13\x01b\x01c\x01\x16\x01\xff\xff\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\0\0\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff8\x01)\x01:\x01;\x01<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\x04\x01@\x01\xff\xffB\x01C\x01D\x01E\x01\xff\xff\xff\xff\r\x01\x0e\x01\xff\xffK\x01\\\x01\xff\xff\x13\x01\xff\xff\xff\xffQ\x01R\x01c\x01\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\0\0\xff\xff\xff\xff\xff\xff^\x01o\x01p\x01\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\x04\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\r\x01\x0e\x01\xff\xffK\x01\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\0\0\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff`\x01\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\0\x01n\x01\xff\xff\x03\x01q\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\r\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xffG\x01\xff\xff\xff\xff\xff\xffK\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff^\x01\xff\xff`\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01=\x01\x03\x01q\x01\xff\xffA\x01\xff\xffC\x01D\x01E\x01\0\0\xff\xff\r\x01\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xffb\x01c\x01)\x01\xff\xfff\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\xff\xff\xff\xffA\x01\xff\xffC\x01D\x01E\x01\xff\xff\xff\xff\r\x01\xff\xffJ\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xffb\x01c\x01)\x01\xff\xfff\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01=\x01\xff\xff\x03\x01\xff\xffA\x01\xff\xffC\x01D\x01E\x01\xff\xff\xff\xff\xff\xff\r\x01J\x01K\x01\xff\xff\xff\xff\xff\xff\x13\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xffb\x01c\x01(\x01)\x01f\x01\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xffn\x01o\x01\xff\xffq\x01\xff\xff\0\x01\xff\xff\xff\xff\x03\x01\xff\xff\xff\xff=\x01\0\0\b\x01@\x01\xff\xff\xff\xff\xff\xff\r\x01E\x01\xff\xffG\x01\0\0\xff\xff\x13\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01R\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff)\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xffJ\x01K\x01\0\x01\xff\xff\xff\xff\x03\x01\xff\xff\xff\xffR\x01\xff\xff\b\x01\0\0\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\0\x01^\x01\x13\x01\x03\x01\xff\xffb\x01c\x01\xff\xff\b\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\r\x01\xff\xff\xff\xff\xff\xffn\x01\xff\xff\x13\x01q\x01\xff\xff\xff\xff\xff\xff)\x01\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\0\0\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01R\x01\0\0C\x01D\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xffJ\x01K\x01\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01R\x01\xff\xff\xff\xfff\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01^\x01\x03\x01q\x01\xff\xffb\x01\xff\xff\b\x01\xff\xfff\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\xff\xffn\x01\x13\x01\xff\xffq\x01\xff\xff\xff\xff\0\0\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xffK\x01@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xffS\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\0\x01[\x01\\\x01\x03\x01R\x01\0\0`\x01\xff\xff\b\x01c\x01\0\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\x13\x01b\x01o\x01p\x01\r\x01f\x01\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\0\0\xff\xffC\x01D\x01E\x01\xff\xff=\x01\xff\xff\xff\xffJ\x01K\x01\xff\xff\xff\xff\0\x01E\x01\xff\xff\x03\x01R\x01\xff\xff\xff\xffK\x01\b\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01R\x01\xff\xff^\x01\xff\xff\xff\xff\x13\x01b\x01\xff\xff\xff\xff\xff\xfff\x01\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01b\x01\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01n\x01\xff\xff\xff\xffq\x01\0\0\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\r\x01@\x01\xff\xff\xff\xffC\x01D\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01K\x01\x1a\x01\x03\x01\x1c\x01\x1d\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff)\x01\xff\xff\x13\x01^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\0\0\xff\xff\xff\xff\xff\xff\0\0n\x01=\x01\xff\xffq\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xffE\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01K\x01\xff\xff\x03\x01\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff=\x01\xff\xff\r\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xffb\x01K\x01\x1a\x01\x1b\x01\x1c\x01\x1d\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xffn\x01\xff\xffX\x01q\x01\0\0)\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01=\x01\x03\x01q\x01@\x01\xff\xff\xff\xff\b\x01D\x01E\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xffK\x01\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\0\0\xff\xff\xff\xff\xff\xff^\x01\xff\xff`\x01\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01=\x01\xff\xff\x03\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\xff\xff\r\x01\xff\xffK\x01\xff\xff\xff\xff\xff\xff\x13\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xffK\x01\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff\xff\xff\0\0b\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\0\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xffK\x01\r\x01\xff\xff\x13\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff^\x01\xff\xff\xff\xff\0\0b\x01c\x01)\x01\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\xff\xff=\x01\x03\x01\xff\xff@\x01=\x01\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\r\x01E\x01\xff\xffK\x01\xff\xff\xff\xff\x13\x01K\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01R\x01\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff\xff\xff\0\0b\x01c\x01)\x01\xff\xffb\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01\xff\xff\xff\xffq\x01n\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff=\x01\xff\xff\r\x01@\x01\xff\xff\xff\xff\0\x01D\x01E\x01\x03\x01\xff\xff\xff\xff\xff\xff\xff\xffK\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\r\x01\xff\xffR\x01\0\0\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\x1a\x01^\x01\x1c\x01\x1d\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff)\x01\xff\xffn\x01=\x01\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffE\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffK\x01\0\x01\xff\xff=\x01\x03\x01\xff\xff@\x01R\x01\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xffK\x01\xff\xff\xff\xff\x13\x01\xff\xff\xff\xffb\x01R\x01\0\0\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xffn\x01^\x01\xff\xffq\x01\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\b\x01\0\x01\xff\xff=\x01\xff\xff\r\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\r\x01\xff\xff\0\0K\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xffR\x01\0\0\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff)\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01=\x01\xff\xffq\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01=\x01\xff\xff\r\x01@\x01\xff\xffK\x01\xff\xffD\x01E\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xffK\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xffn\x01\0\0\xff\xffq\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01n\x01=\x01\x03\x01q\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\r\x01\xff\xff\0\0K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff\0\0\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\0\x01\xff\xffE\x01\x03\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xff\xffR\x01\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01^\x01\x1c\x01\x1d\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01(\x01)\x01@\x01n\x01\xff\xff\0\x01q\x01E\x01\x03\x01\0\0\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\0\0R\x01=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\x1a\x01^\x01\x1c\x01\x1d\x01K\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff(\x01)\x01\xff\xffn\x01\xff\xff\xff\xffq\x01\xff\xff\xff\xff^\x01\0\x01\xff\xff\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\b\x01\0\x01\xff\xff=\x01\xff\xff\r\x01@\x01n\x01\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xffK\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\0\0R\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff)\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xffC\x01D\x01E\x01=\x01\xff\xff\xff\xff@\x01\xff\xffK\x01C\x01D\x01E\x01\xff\xff\xff\xff\0\0R\x01\xff\xffK\x01\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\x03\x01R\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\r\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\0\x01n\x01\xff\xff\x03\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xffn\x01\0\0\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\xff\xff(\x01)\x01\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\x03\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff=\x01\xff\xff)\x01@\x01\xff\xff\xff\xff\xff\xff\xff\xffE\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xffK\x01\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xffR\x01=\x01\xff\xff)\x01@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xffK\x01b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xffR\x01=\x01\xff\xff\xff\xff@\x01\xff\xffn\x01\xff\xffD\x01E\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xffK\x01b\x01c\x01\0\0\0\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01n\x01\0\x01\xff\xff\xff\xff\r\x01\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\0\0\xff\xff\r\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\0\0n\x01\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xffD\x01E\x01\xff\xff=\x01\xff\xff\xff\xff@\x01K\x01\xff\xff\0\x01D\x01E\x01\x03\x01\xff\xffR\x01\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff\r\x01\xff\xffR\x01\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff\x1a\x01^\x01\x1c\x01\x1d\x01\xff\xffb\x01c\x01n\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xffn\x01\xff\xff8\x01\xff\xff:\x01;\x01<\x01\0\x01>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\r\x01@\x01\xff\xff\xff\xff\xff\xff\xff\xffE\x01\xff\xff\xff\xffS\x01\xff\xff\xff\xffK\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01[\x01\\\x01R\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffc\x01\0\x01\xff\xff)\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01o\x01p\x01\r\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffn\x01=\x01\xff\xff\xff\xff@\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01E\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff)\x01\xff\xffR\x01\0\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff\r\x01\xff\xffb\x01c\x01=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xff\xff\xffE\x01\x1a\x01n\x01\x1c\x01\x1d\x01\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01\xff\xff\xff\xff)\x01\xff\xff\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xff=\x01\xff\xff\xff\xff@\x01\xff\xffn\x01\0\x01\xff\xffE\x01\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01K\x01\0\x01\xff\xff\xff\xff\xff\xff\r\x01\xff\xffR\x01\xff\xff\xff\xff\xff\xff)\x01\xff\xff\xff\xff\r\x01\xff\xff\xff\xff\xff\xff\x1a\x01^\x01\x1c\x01\x1d\x01\xff\xffb\x01c\x01\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01=\x01\xff\xff)\x01@\x01n\x01\xff\xff\xff\xff\xff\xffE\x01\xff\xff\xff\xff)\x01\xff\xff\xff\xffK\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\x01=\x01\xff\xff\xff\xff@\x01\xff\xff\xff\xff\xff\xff\xff\xffE\x01=\x01\xff\xff^\x01@\x01\xff\xffK\x01b\x01c\x01E\x01\xff\xff\xff\xff\xff\xffR\x01\xff\xffK\x01\xff\xff\xff\xff\xff\xffn\x01\xff\xff\xff\xffR\x01\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xffb\x01c\x01\0\x01n\x01\xff\xff\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\b\x01\xff\xffn\x01\x0b\x01\f\x01\r\x01\x0e\x01\xff\xff\xff\xff\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\x1d\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x011\x012\x013\x014\x015\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01C\x01\xff\xffE\x01F\x01G\x01H\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xffR\x01S\x01\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff[\x01\xff\xff\xff\xff^\x01_\x01\xff\xff\xff\xffb\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01m\x01n\x01o\x01p\x01q\x01\xff\xff\xff\xfft\x01\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\x0f\x01\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff$\x01\xff\xff\xff\xff'\x01\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xff\xff\xff\xff\xffd\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\0\x01\x01\x01\x02\x01\xff\xfft\x01\x05\x01\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xff\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff$\x01\xff\xff\xff\xff'\x01\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xff\xff\xff\xff\xffd\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\0\x01\x01\x01\x02\x01\xff\xfft\x01\x05\x01\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xff\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff$\x01\xff\xff\xff\xff'\x01\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffd\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\0\x01l\x01m\x01\xff\xffo\x01\x05\x01\x06\x01\x07\x01\b\x01t\x01\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x13\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\x01\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x011\x012\x013\x014\x015\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xffE\x01F\x01G\x01H\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff[\x01\xff\xff\xff\xff\xff\xff_\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01m\x01\xff\xffo\x01p\x01q\x01\0\x01\xff\xfft\x01\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\0\x01Y\x01\xff\xff\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01`\x01\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\0\x01Y\x01\xff\xff\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01`\x01\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\0\x01Y\x01\xff\xff\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01`\x01\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\x03\x01\x04\x01\x05\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\x0b\x01\xff\xff\r\x01l\x01m\x01\xff\xffo\x01\xff\xff\x13\x01\x14\x01\x15\x01t\x01\xff\xff\x18\x01\x19\x01\x1a\x01\xff\xff\x1c\x01\x1d\x01\x1e\x01\xff\xff \x01!\x01\"\x01#\x01\xff\xff\xff\xff\xff\xff'\x01(\x01)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff5\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff@\x01A\x01\xff\xff\xff\xff\xff\xff\xff\xffF\x01G\x01\xff\xff\xff\xff\xff\xffK\x01L\x01\xff\xffN\x01\xff\xffP\x01Q\x01R\x01\xff\xffT\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffZ\x01\xff\xff\xff\xff\xff\xff\xff\xff_\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffe\x01\0\x01\xff\xffh\x01i\x01\x04\x01k\x01l\x01m\x01n\x01o\x01\xff\xffq\x01r\x01s\x01t\x01u\x01\xff\xff\x11\x01\xff\xff\x13\x01\xff\xff\xff\xff\x16\x01\xff\xff\xff\xff\xff\xff\x1a\x01\x1b\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\x010\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\x01\xff\xff\xff\xff\xff\xffA\x01\xff\xffC\x01D\x01E\x01\xff\xffG\x01\xff\xff\xff\xffJ\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\xff\xff\f\x01\\\x01]\x01\x0f\x01\x10\x01\xff\xffa\x01\xff\xffc\x01\xff\xff\xff\xfff\x01\xff\xff\xff\xff\xff\xff\x1b\x01\x1c\x01\xff\xff\x1e\x01\x1f\x01o\x01\xff\xffq\x01\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xff\xff\xffc\x01d\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\xff\xff\f\x01\xff\xff\xff\xff\xff\xff\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xff\xff\xffc\x01d\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xffn\x01o\x01p\x01\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\xff\xff\f\x01\xff\xff\xff\xff\xff\xff\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xff\xff\xffc\x01d\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xffn\x01o\x01p\x01\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\xff\xff\f\x01\xff\xff\xff\xff\xff\xff\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xff\xff\xffc\x01d\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xffn\x01o\x01p\x01\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\t\x01\xff\xff\xff\xff\f\x01\xff\xff\xff\xff\xff\xff\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff$\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff>\x01\xff\xff\0\x01A\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01I\x01\xff\xffK\x01\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01`\x01\xff\xff\xff\xffc\x01d\x01\xff\xfff\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\0\x01A\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\0\x01A\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01\xff\xff\xff\xff\xff\xff\xff\xffM\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\r\x01\x0e\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\x1d\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xffE\x01F\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xffR\x01\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff[\x01\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xffb\x01\xff\xff\x0b\x01\f\x01\r\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01n\x01o\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\x1c\x01\x1d\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff)\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01=\x01\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xffE\x01F\x01\xff\xffH\x01I\x01\xff\xffK\x01\xff\xffM\x01N\x01\xff\xffP\x01\xff\xffR\x01\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\xff\xffb\x01\x0b\x01\f\x01\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01n\x01o\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\xff\xff\xff\xff^\x01\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\n\x01\x0b\x01\f\x01g\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\xff\xff\xff\xff\xff\xff\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\x1a\x01\xff\xff\xff\xfft\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\x1a\x01\xff\xff\xff\xfft\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\x05\x01\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\xff\xff\xff\xff\xff\xfft\x01\x1e\x01\x1f\x01 \x01!\x01\"\x01\xff\xff\xff\xff\xff\xff\xff\xff'\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff@\x01A\x01B\x01\xff\xff\xff\xff\xff\xffF\x01\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xffM\x01N\x01\xff\xffP\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01W\x01\xff\xffY\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\f\x01\xff\xff\x0e\x01\xff\xffg\x01\x11\x01\xff\xff\xff\xff\xff\xffl\x01m\x01\xff\xffo\x01\xff\xff\xff\xff\x1b\x01\xff\xfft\x01\x1e\x01\x1f\x018\x01\xff\xff:\x01;\x01<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xffS\x01<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01[\x01\\\x01\xff\xff\xff\xff\xff\xffH\x01\x06\x01\xff\xffc\x01\xff\xffM\x01\xff\xff\f\x01\xff\xff\x0e\x01\xff\xffS\x01\x11\x01\xff\xffV\x01o\x01p\x01\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\x1e\x01\x1f\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff1\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01\x06\x01\xff\xff\xff\xff\xff\xffM\x01\xff\xff\f\x01\xff\xff\x0e\x01\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\x1e\x01\x1f\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff1\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01\x06\x01\xff\xff\xff\xff\xff\xffM\x01\xff\xff\f\x01\xff\xff\x0e\x01\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\x1e\x01\x1f\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff1\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xffJ\x01\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xffJ\x01\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x014\x01\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff[\x01\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01\xff\xff\xff\xff\xff\xff\x06\x01M\x01\xff\xff\xff\xff\n\x01\xff\xff\f\x01\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\x01\xff\xff\xff\xff\xff\xff\x1c\x01c\x01\x1e\x01\x1f\x01\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01\x06\x01\xff\xff\b\x01\xff\xffM\x01\xff\xff\f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01\xff\xff\xff\xff\xff\xff\x06\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\f\x01\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff_\x01\xff\xff\xff\xff\x1c\x01c\x01\x1e\x01\x1f\x01\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1c\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff5\x016\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\x06\x01\xff\xffH\x01\xff\xff\xff\xff\xff\xff\f\x01M\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x011\x012\x013\x01\xff\xff\xff\xff6\x01\xff\xff8\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\x01\x06\x01\x07\x01\xff\xff\xff\xffM\x01\x0b\x01\f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xff\xff\xff\x16\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1e\x01\x1f\x01c\x01\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff1\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffY\x01\xff\xff[\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xffc\x01d\x01\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x011\x012\x013\x014\x01\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffY\x01\xff\xff[\x01\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xffj\x01\xff\xffl\x01\xff\xff\xff\xffo\x011\x012\x013\x01\xff\xff\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffY\x01\xff\xff\xff\xff\xff\xff\x1e\x01\x1f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffg\x01\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x011\x012\x013\x01\xff\xff\xff\xff6\x017\x018\x019\x01\xff\xff\xff\xff<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\x06\x01\x07\x01\xff\xff\xff\xff\xff\xff\x0b\x01\f\x01\xff\xffM\x01N\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\b\x01\xff\xff\xff\xff\xff\xffY\x01\xff\xff\xff\xff\x0f\x01\x1e\x01\x1f\x018\x01\xff\xff:\x01;\x01<\x01\x17\x01>\x01\xff\xffg\x01A\x01B\x01\xff\xff\x1e\x01l\x01\xff\xff\xff\xffo\x011\x012\x013\x01\xff\xff\xff\xff6\x017\x018\x019\x01\xff\xffS\x01<\x01\xff\xff\xff\xff\xff\xff\xff\xffA\x01B\x01[\x01\\\x01\xff\xff8\x01\xff\xff:\x01;\x01<\x01c\x01>\x01M\x01N\x01A\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\b\x01n\x01o\x01p\x01Y\x01\xff\xff\xff\xff\x0f\x01\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffg\x01Z\x01[\x01\\\x01\x1e\x01l\x01\xff\xff\xff\xffo\x01\xff\xffc\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffl\x01\xff\xff\xff\xffo\x01p\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01\xff\xff>\x01\xff\xff\xff\xffA\x01B\x01\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\t\x01\xff\xff\xff\xffS\x01\xff\xff\x0e\x01\x0f\x01\x10\x01\x11\x01\x12\x01\xff\xff[\x01\\\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01l\x01\xff\xff\xff\xffo\x01p\x01*\x01+\x01,\x01-\x01.\x01\0\x01\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\xff\xff\x07\x01\xff\xff\t\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\x01\x10\x01\xff\xff\xff\xff\xff\xffC\x01\xff\xff\xff\xff\xff\xff\xff\xffH\x01I\x01\x1b\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\x01T\x01U\x01V\x01W\x01X\x01*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff`\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xfff\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\x01\xff\xff\xff\xff\xff\xff\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\xff\xffH\x01I\x01\t\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\x0f\x01\x10\x01\xff\xff\x12\x01T\x01U\x01V\x01W\x01X\x01Y\x01\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x01\x02\x01d\x01$\x01f\x01\xff\xff\xff\xff\xff\xff\t\x01*\x01+\x01,\x01-\x01.\x01\x0f\x01\x10\x01\xff\xff\x12\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff>\x01\xff\xff\xff\xff\xff\xff\xff\xffC\x01$\x01\xff\xff\xff\xff\xff\xffH\x01I\x01*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\x01\x01\x01\x02\x01a\x01\xff\xffC\x01\xff\xff\xff\xfff\x01\t\x01H\x01I\x01\xff\xff\xff\xff\xff\xff\x0f\x01\x10\x01\xff\xff\x12\x01\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\x1b\x01\xff\xff\xff\xff\xff\xff]\x01\xff\xff\x01\x01\x02\x01\xff\xff$\x01\xff\xff\xff\xff\xff\xfff\x01\t\x01*\x01+\x01,\x01-\x01.\x01\x0f\x01\x10\x01\xff\xff\x12\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x19\x01\xff\xff\x1b\x01\xff\xff\xff\xff>\x01\xff\xff\xff\xff\xff\xff\xff\xffC\x01$\x01\xff\xff\xff\xff\xff\xffH\x01I\x01*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01>\x01\x01\x01\x02\x01\xff\xff\xff\xffC\x01\xff\xff\xff\xfff\x01\t\x01H\x01I\x01\xff\xff\xff\xff\xff\xff\x0f\x01\x10\x01\xff\xff\x12\x01\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\x1b\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x01\x02\x01\xff\xff$\x01\xff\xff\xff\xff\xff\xfff\x01\t\x01*\x01+\x01,\x01-\x01.\x01\x0f\x01\x10\x01\xff\xff\x12\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff>\x01\xff\xff\xff\xff\xff\xff\xff\xffC\x01$\x01\xff\xff\xff\xff\xff\xffH\x01I\x01*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\x01\x01\x01\x02\x01\xff\xff\xff\xffC\x01\xff\xff\xff\xfff\x01\t\x01H\x01I\x01\xff\xff\xff\xff\xff\xff\x0f\x01\x10\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\x1b\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x01\x02\x01\xff\xff$\x01\xff\xff\xff\xff\xff\xfff\x01\t\x01*\x01+\x01,\x01-\x01.\x01\x0f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff>\x01\xff\xff\xff\xff\xff\xff\xff\xffC\x01$\x01\xff\xff\xff\xff\xff\xffH\x01I\x01*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\xff\xff\xff\xff\xff\xff\xff\xff]\x01>\x01\x01\x01\x02\x01\xff\xff\xff\xffC\x01\xff\xff\xff\xfff\x01\t\x01H\x01I\x01\xff\xff\xff\xff\xff\xff\x0f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01\x1b\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\x01\xff\xff$\x01\xff\xff\xff\xff\xff\xfff\x01\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x01\x02\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\x01\xff\xff\xff\xff\xff\xff\xff\xffC\x01\x0f\x01\xff\xff\xff\xff\xff\xffH\x01I\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\x01\xff\xff\xff\xff\xff\xffT\x01U\x01V\x01W\x01X\x01$\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff*\x01+\x01,\x01-\x01.\x01\xff\xff\xff\xfff\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff8\x01\xff\xff:\x01;\x01<\x01\xff\xff>\x01>\x01\xff\xffA\x01B\x01\xff\xffC\x01\xff\xff\xff\xff\xff\xff\xff\xffH\x01I\x01K\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\x01\xff\xff\xff\xffU\x01V\x01W\x01X\x01\xff\xff[\x01\\\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffc\x01\xff\xff\xff\xff\xff\xfff\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffo\x01p\x01",
  error_function: Parsing.parse_error,
  names_const: "AMPERAMPER\0AMPERSAND\0AND\0AS\0ASSERT\0BACKQUOTE\0BANG\0BAR\0BARBAR\0BARRBRACKET\0BEGIN\0CLASS\0COLON\0COLONCOLON\0COLONEQUAL\0COLONGREATER\0COMMA\0CONSTRAINT\0DO\0DONE\0DOT\0DOTDOT\0DOWNTO\0ELSE\0END\0EOF\0EQUAL\0EXCEPTION\0EXTERNAL\0FALSE\0FOR\0FUN\0FUNCTION\0FUNCTOR\0GREATER\0GREATERRBRACE\0GREATERRBRACKET\0IF\0IN\0INCLUDE\0INHERIT\0INITIALIZER\0LAZY\0LBRACE\0LBRACELESS\0LBRACKET\0LBRACKETBAR\0LBRACKETLESS\0LBRACKETGREATER\0LBRACKETPERCENT\0LBRACKETPERCENTPERCENT\0LESS\0LESSMINUS\0LET\0LPAREN\0LBRACKETAT\0LBRACKETATAT\0LBRACKETATATAT\0MATCH\0METHOD\0MINUS\0MINUSDOT\0MINUSGREATER\0MODULE\0MUTABLE\0NEW\0NONREC\0OBJECT\0OF\0OPEN\0OR\0PERCENT\0PLUS\0PLUSDOT\0PLUSEQ\0PRIVATE\0QUESTION\0QUOTE\0RBRACE\0RBRACKET\0REC\0RPAREN\0SEMI\0SEMISEMI\0SHARP\0SIG\0STAR\0STRUCT\0THEN\0TILDE\0TO\0TRUE\0TRY\0TYPE\0UNDERSCORE\0VAL\0VIRTUAL\0WHEN\0WHILE\0WITH\0EOL\0",
  names_block: "CHAR\0FLOAT\0INFIXOP0\0INFIXOP1\0INFIXOP2\0INFIXOP3\0INFIXOP4\0INT\0INT32\0INT64\0LABEL\0LIDENT\0NATIVEINT\0OPTLABEL\0PREFIXOP\0SHARPOP\0STRING\0UIDENT\0COMMENT\0DOCSTRING\0"
};

function implementation(lexfun, lexbuf) {
  return Parsing.yyparse(yytables, 1, lexfun, lexbuf);
}

function type_of_directive(x) {
  if (typeof x === "number") {
    return /* Dir_type_null */4;
  }
  switch (x.tag | 0) {
    case /* Dir_bool */0 :
        return /* Dir_type_bool */0;
    case /* Dir_float */1 :
        return /* Dir_type_float */1;
    case /* Dir_int */2 :
        return /* Dir_type_int */2;
    case /* Dir_string */3 :
        return /* Dir_type_string */3;
    
  }
}

function string_of_type_directive(x) {
  switch (x) {
    case /* Dir_type_bool */0 :
        return "bool";
    case /* Dir_type_float */1 :
        return "float";
    case /* Dir_type_int */2 :
        return "int";
    case /* Dir_type_string */3 :
        return "string";
    case /* Dir_type_null */4 :
        return "null";
    
  }
}

var $$Error$4 = Caml_exceptions.create("Ocaml_typedtree_test.Lexer.Error");

function assert_same_type(lexbuf, x, y) {
  var lhs = type_of_directive(x);
  var rhs = type_of_directive(y);
  if (lhs !== rhs) {
    throw [
          $$Error$4,
          /* Conditional_expr_expected_type */Block.__(7, [
              lhs,
              rhs
            ]),
          curr(lexbuf)
        ];
  }
  return y;
}

var directive_built_in_values = Hashtbl.create(void 0, 51);

Hashtbl.replace(directive_built_in_values, "OCAML_VERSION", /* Dir_string */Block.__(3, [Sys.ocaml_version]));

var tmp;

var exit = 0;

var i;

try {
  i = $$String.rindex(Sys.ocaml_version, /* "+" */43);
  exit = 1;
}
catch (exn$1){
  if (exn$1 !== Caml_builtin_exceptions.not_found) {
    throw exn$1;
  }
  tmp = "";
}

if (exit === 1) {
  tmp = $$String.sub(Sys.ocaml_version, i + 1 | 0, (Sys.ocaml_version.length - i | 0) - 1 | 0);
}

Hashtbl.replace(directive_built_in_values, "OCAML_PATCH", /* Dir_string */Block.__(3, [tmp]));

Hashtbl.replace(directive_built_in_values, "OS_TYPE", /* Dir_string */Block.__(3, [Sys.os_type]));

Hashtbl.replace(directive_built_in_values, "BIG_ENDIAN", /* Dir_bool */Block.__(0, [Sys.big_endian]));

Hashtbl.replace(directive_built_in_values, "WORD_SIZE", /* Dir_int */Block.__(2, [Sys.word_size]));

function semantic_version_parse(str, start, last_index) {
  var aux = function (_start, _acc, last_index) {
    while(true) {
      var acc = _acc;
      var start = _start;
      if (start > last_index) {
        return /* tuple */[
                acc,
                start
              ];
      }
      var c = str.charCodeAt(start);
      if (c === /* "." */46) {
        return /* tuple */[
                acc,
                start + 1 | 0
              ];
      }
      var v = c - /* "0" */48 | 0;
      if (!(v >= 0 && v <= 9)) {
        return /* tuple */[
                acc,
                start
              ];
      }
      _acc = Caml_int32.imul(acc, 10) + v | 0;
      _start = start + 1 | 0;
      continue ;
    };
  };
  var match = aux(start, 0, last_index);
  var match$1 = aux(match[1], 0, last_index);
  var match$2 = aux(match$1[1], 0, last_index);
  var patch_end = match$2[1];
  var additional = $$String.sub(str, patch_end, (last_index - patch_end | 0) + 1 | 0);
  return /* tuple */[
          /* tuple */[
            match[0],
            match$1[0],
            match$2[0]
          ],
          additional
        ];
}

function defined(str) {
  var val;
  try {
    val = Hashtbl.find(directive_built_in_values, str);
  }
  catch (exn){
    try {
      Caml_sys.caml_sys_getenv(str);
      return true;
    }
    catch (exn$1){
      return false;
    }
  }
  if (typeof val === "number") {
    return false;
  } else {
    return true;
  }
}

function query(loc, str) {
  var v;
  try {
    v = Hashtbl.find(directive_built_in_values, str);
  }
  catch (exn){
    if (exn !== Caml_builtin_exceptions.not_found) {
      throw exn;
    }
    var exit = 0;
    var v$1;
    try {
      v$1 = Caml_sys.caml_sys_getenv(str);
      exit = 2;
    }
    catch (exn$1){
      if (exn$1 === Caml_builtin_exceptions.not_found) {
        return /* Dir_bool */Block.__(0, [false]);
      }
      throw exn$1;
    }
    if (exit === 2) {
      try {
        return /* Dir_bool */Block.__(0, [Pervasives.bool_of_string(v$1)]);
      }
      catch (exn$2){
        try {
          return /* Dir_int */Block.__(2, [Caml_format.caml_int_of_string(v$1)]);
        }
        catch (exn$3){
          try {
            return /* Dir_float */Block.__(1, [Caml_format.caml_float_of_string(v$1)]);
          }
          catch (exn$4){
            return /* Dir_string */Block.__(3, [v$1]);
          }
        }
      }
    }
    
  }
  if (typeof v === "number") {
    return /* Dir_bool */Block.__(0, [false]);
  } else {
    return v;
  }
}

function value_of_token(loc, t) {
  if (typeof t === "number") {
    switch (t) {
      case /* FALSE */29 :
          return /* Dir_bool */Block.__(0, [false]);
      case /* TRUE */91 :
          return /* Dir_bool */Block.__(0, [true]);
      default:
        throw [
              $$Error$4,
              /* Unexpected_token_in_conditional */4,
              loc
            ];
    }
  } else {
    switch (t.tag | 0) {
      case /* FLOAT */1 :
          return /* Dir_float */Block.__(1, [Caml_format.caml_float_of_string(t[0])]);
      case /* INT */7 :
          return /* Dir_int */Block.__(2, [t[0]]);
      case /* STRING */16 :
          return /* Dir_string */Block.__(3, [t[0][0]]);
      case /* UIDENT */17 :
          return query(loc, t[0]);
      default:
        throw [
              $$Error$4,
              /* Unexpected_token_in_conditional */4,
              loc
            ];
    }
  }
}

function directive_parse(token_with_comments, lexbuf) {
  var look_ahead = {
    contents: void 0
  };
  var token = function (param) {
    var v = look_ahead.contents;
    if (v !== void 0) {
      look_ahead.contents = void 0;
      return v;
    } else {
      var _param;
      while(true) {
        var t = Curry._1(token_with_comments, lexbuf);
        if (typeof t === "number") {
          switch (t) {
            case /* EOF */25 :
                throw [
                      $$Error$4,
                      /* Unterminated_if */2,
                      curr(lexbuf)
                    ];
            case /* EOL */100 :
                _param = void 0;
                continue ;
            default:
              return t;
          }
        } else {
          switch (t.tag | 0) {
            case /* COMMENT */18 :
            case /* DOCSTRING */19 :
                _param = void 0;
                continue ;
            default:
              return t;
          }
        }
      };
    }
  };
  var push = function (e) {
    if (look_ahead.contents !== void 0) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "lexer.mll",
              312,
              4
            ]
          ];
    }
    look_ahead.contents = e;
    
  };
  var token_op = function (calc, no, lhs) {
    var op = token(void 0);
    var exit = 0;
    if (typeof op === "number") {
      switch (op) {
        case /* EQUAL */26 :
        case /* GREATER */34 :
        case /* LESS */51 :
            exit = 1;
            break;
        default:
          return Curry._1(no, op);
      }
    } else {
      if (op.tag !== /* INFIXOP0 */2) {
        return Curry._1(no, op);
      }
      switch (op[0]) {
        case "=~" :
            if (!calc) {
              return true;
            }
            if (typeof lhs !== "number" && lhs.tag === /* Dir_string */3) {
              var curr_loc = curr(lexbuf);
              var rhs = value_of_token(curr_loc, token(void 0));
              var exit$1 = 0;
              if (typeof rhs === "number") {
                exit$1 = 3;
              } else {
                if (rhs.tag === /* Dir_string */3) {
                  var lhs$1 = lhs[0];
                  var str = rhs[0];
                  var last_index = str.length - 1 | 0;
                  if (last_index < 0) {
                    throw [
                          $$Error$4,
                          /* Illegal_semver */Block.__(6, [str]),
                          curr_loc
                        ];
                  }
                  var v = str.charCodeAt(0);
                  var match;
                  var exit$2 = 0;
                  if (v !== 94) {
                    if (v >= 63) {
                      if (v !== 126) {
                        exit$2 = 1;
                      } else {
                        match = /* tuple */[
                          /* Approximate */-617782220,
                          semantic_version_parse(str, 1, last_index)
                        ];
                      }
                    } else if (v >= 60) {
                      switch (v - 60 | 0) {
                        case 0 :
                            if (last_index === 0) {
                              throw [
                                    $$Error$4,
                                    /* Illegal_semver */Block.__(6, [str]),
                                    curr_loc
                                  ];
                            }
                            match = str[1] === "=" ? /* tuple */[
                                /* Le */17049,
                                semantic_version_parse(str, 2, last_index)
                              ] : /* tuple */[
                                /* Lt */17064,
                                semantic_version_parse(str, 1, last_index)
                              ];
                            break;
                        case 1 :
                            exit$2 = 1;
                            break;
                        case 2 :
                            if (last_index === 0) {
                              throw [
                                    $$Error$4,
                                    /* Illegal_semver */Block.__(6, [str]),
                                    curr_loc
                                  ];
                            }
                            match = str[1] === "=" ? /* tuple */[
                                /* Ge */15934,
                                semantic_version_parse(str, 2, last_index)
                              ] : /* tuple */[
                                /* Gt */15949,
                                semantic_version_parse(str, 1, last_index)
                              ];
                            break;
                        
                      }
                    } else {
                      exit$2 = 1;
                    }
                  } else {
                    match = /* tuple */[
                      /* Compatible */785637236,
                      semantic_version_parse(str, 1, last_index)
                    ];
                  }
                  if (exit$2 === 1) {
                    match = /* tuple */[
                      /* Exact */172069535,
                      semantic_version_parse(str, 0, last_index)
                    ];
                  }
                  var version = match[1][0];
                  var major = version[0];
                  var pred = match[0];
                  var match$1 = semantic_version_parse(lhs$1, 0, lhs$1.length - 1 | 0);
                  var lversion = match$1[0];
                  var l_major = lversion[0];
                  if (pred >= 17049) {
                    if (pred >= 172069535) {
                      if (pred >= 785637236) {
                        return major === l_major;
                      } else {
                        return Caml_obj.caml_equal(lversion, version);
                      }
                    } else if (pred >= 17064) {
                      return Caml_obj.caml_lessthan(lversion, version);
                    } else {
                      return Caml_obj.caml_lessequal(lversion, version);
                    }
                  } else if (pred !== 15934) {
                    if (pred >= 15949) {
                      return Caml_obj.caml_greaterthan(lversion, version);
                    } else if (major === l_major) {
                      return version[1] === lversion[1];
                    } else {
                      return false;
                    }
                  } else {
                    return Caml_obj.caml_greaterequal(lversion, version);
                  }
                }
                exit$1 = 3;
              }
              if (exit$1 === 3) {
                throw [
                      $$Error$4,
                      /* Conditional_expr_expected_type */Block.__(7, [
                          /* Dir_type_string */3,
                          type_of_directive(lhs)
                        ]),
                      curr(lexbuf)
                    ];
              }
              
            }
            throw [
                  $$Error$4,
                  /* Conditional_expr_expected_type */Block.__(7, [
                      /* Dir_type_string */3,
                      type_of_directive(lhs)
                    ]),
                  curr(lexbuf)
                ];
            break;
        case "<=" :
        case "<>" :
        case ">=" :
            exit = 1;
            break;
        default:
          return Curry._1(no, op);
      }
    }
    if (exit === 1) {
      var f;
      var exit$3 = 0;
      if (typeof op === "number") {
        switch (op) {
          case /* EQUAL */26 :
              f = Caml_obj.caml_equal;
              break;
          case /* GREATER */34 :
              f = Caml_obj.caml_greaterthan;
              break;
          case /* LESS */51 :
              f = Caml_obj.caml_lessthan;
              break;
          default:
            exit$3 = 2;
        }
      } else if (op.tag === /* INFIXOP0 */2) {
        switch (op[0]) {
          case "<=" :
              f = Caml_obj.caml_lessequal;
              break;
          case "<>" :
              f = Caml_obj.caml_notequal;
              break;
          default:
            exit$3 = 2;
        }
      } else {
        exit$3 = 2;
      }
      if (exit$3 === 2) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "lexer.mll",
                331,
                17
              ]
            ];
      }
      var curr_loc$1 = curr(lexbuf);
      var rhs$1 = value_of_token(curr_loc$1, token(void 0));
      if (calc) {
        return Curry._2(f, lhs, assert_same_type(lexbuf, lhs, rhs$1));
      } else {
        return true;
      }
    }
    
  };
  var parse_and_aux = function (calc, v) {
    var e = token(void 0);
    if (typeof e === "number" && e === 0) {
      var calc$1 = calc && v;
      var b = parse_and_aux(calc$1, parse_relation(calc$1));
      if (v) {
        return b;
      } else {
        return false;
      }
    } else {
      push(e);
      return v;
    }
  };
  var parse_relation = function (calc) {
    var curr_token = token(void 0);
    var curr_loc = curr(lexbuf);
    if (typeof curr_token === "number") {
      switch (curr_token) {
        case /* FALSE */29 :
            return false;
        case /* LPAREN */54 :
            var v = parse_or_aux(calc, parse_and_aux(calc, parse_relation(calc)));
            var match = token(void 0);
            if (typeof match !== "number") {
              throw [
                    $$Error$4,
                    /* Unterminated_paren_in_conditional */1,
                    curr(lexbuf)
                  ];
            }
            if (match !== 81) {
              throw [
                    $$Error$4,
                    /* Unterminated_paren_in_conditional */1,
                    curr(lexbuf)
                  ];
            }
            return v;
        case /* TRUE */91 :
            return true;
        default:
          throw [
                $$Error$4,
                /* Unexpected_token_in_conditional */4,
                curr_loc
              ];
      }
    } else {
      switch (curr_token.tag | 0) {
        case /* FLOAT */1 :
            return token_op(calc, (function (e) {
                          throw [
                                $$Error$4,
                                /* Conditional_expr_expected_type */Block.__(7, [
                                    /* Dir_type_bool */0,
                                    /* Dir_type_float */1
                                  ]),
                                curr_loc
                              ];
                        }), /* Dir_float */Block.__(1, [Caml_format.caml_float_of_string(curr_token[0])]));
        case /* INT */7 :
            return token_op(calc, (function (e) {
                          throw [
                                $$Error$4,
                                /* Conditional_expr_expected_type */Block.__(7, [
                                    /* Dir_type_bool */0,
                                    /* Dir_type_int */2
                                  ]),
                                curr_loc
                              ];
                        }), /* Dir_int */Block.__(2, [curr_token[0]]));
        case /* LIDENT */11 :
            var r = curr_token[0];
            switch (r) {
              case "defined" :
              case "undefined" :
                  break;
              default:
                throw [
                      $$Error$4,
                      /* Unexpected_token_in_conditional */4,
                      curr_loc
                    ];
            }
            var t = token(void 0);
            var loc = curr(lexbuf);
            if (typeof t === "number") {
              throw [
                    $$Error$4,
                    /* Unexpected_token_in_conditional */4,
                    loc
                  ];
            }
            if (t.tag !== /* UIDENT */17) {
              throw [
                    $$Error$4,
                    /* Unexpected_token_in_conditional */4,
                    loc
                  ];
            }
            var s = t[0];
            if (calc) {
              if (Caml_string.get(r, 0) === /* "u" */117) {
                return !defined(s);
              } else {
                return defined(s);
              }
            } else {
              return true;
            }
            break;
        case /* STRING */16 :
            return token_op(calc, (function (e) {
                          throw [
                                $$Error$4,
                                /* Conditional_expr_expected_type */Block.__(7, [
                                    /* Dir_type_bool */0,
                                    /* Dir_type_string */3
                                  ]),
                                curr_loc
                              ];
                        }), /* Dir_string */Block.__(3, [curr_token[0][0]]));
        case /* UIDENT */17 :
            var value_v = query(curr_loc, curr_token[0]);
            return token_op(calc, (function (e) {
                          push(e);
                          if (typeof value_v !== "number" && !value_v.tag) {
                            return value_v[0];
                          }
                          var ty = type_of_directive(value_v);
                          throw [
                                $$Error$4,
                                /* Conditional_expr_expected_type */Block.__(7, [
                                    /* Dir_type_bool */0,
                                    ty
                                  ]),
                                curr_loc
                              ];
                        }), value_v);
        default:
          throw [
                $$Error$4,
                /* Unexpected_token_in_conditional */4,
                curr_loc
              ];
      }
    }
  };
  var parse_or_aux = function (calc, v) {
    var e = token(void 0);
    if (typeof e === "number" && e === 8) {
      var calc$1 = calc && !v;
      var b = parse_or_aux(calc$1, parse_and_aux(calc$1, parse_relation(calc$1)));
      if (v) {
        return true;
      } else {
        return b;
      }
    } else {
      push(e);
      return v;
    }
  };
  var v = parse_or_aux(true, parse_and_aux(true, parse_relation(true)));
  var match = token(void 0);
  if (typeof match !== "number") {
    throw [
          $$Error$4,
          /* Expect_hash_then_in_conditional */5,
          curr(lexbuf)
        ];
  }
  if (match !== 88) {
    throw [
          $$Error$4,
          /* Expect_hash_then_in_conditional */5,
          curr(lexbuf)
        ];
  }
  return v;
}

function is_elif(i) {
  if (typeof i === "number" || !(i.tag === /* LIDENT */11 && i[0] === "elif")) {
    return false;
  } else {
    return true;
  }
}

var keyword_table = create_hashtable(149, /* :: */[
      /* tuple */[
        "and",
        /* AND */2
      ],
      /* :: */[
        /* tuple */[
          "as",
          /* AS */3
        ],
        /* :: */[
          /* tuple */[
            "assert",
            /* ASSERT */4
          ],
          /* :: */[
            /* tuple */[
              "begin",
              /* BEGIN */10
            ],
            /* :: */[
              /* tuple */[
                "class",
                /* CLASS */11
              ],
              /* :: */[
                /* tuple */[
                  "constraint",
                  /* CONSTRAINT */17
                ],
                /* :: */[
                  /* tuple */[
                    "do",
                    /* DO */18
                  ],
                  /* :: */[
                    /* tuple */[
                      "done",
                      /* DONE */19
                    ],
                    /* :: */[
                      /* tuple */[
                        "downto",
                        /* DOWNTO */22
                      ],
                      /* :: */[
                        /* tuple */[
                          "else",
                          /* ELSE */23
                        ],
                        /* :: */[
                          /* tuple */[
                            "end",
                            /* END */24
                          ],
                          /* :: */[
                            /* tuple */[
                              "exception",
                              /* EXCEPTION */27
                            ],
                            /* :: */[
                              /* tuple */[
                                "external",
                                /* EXTERNAL */28
                              ],
                              /* :: */[
                                /* tuple */[
                                  "false",
                                  /* FALSE */29
                                ],
                                /* :: */[
                                  /* tuple */[
                                    "for",
                                    /* FOR */30
                                  ],
                                  /* :: */[
                                    /* tuple */[
                                      "fun",
                                      /* FUN */31
                                    ],
                                    /* :: */[
                                      /* tuple */[
                                        "function",
                                        /* FUNCTION */32
                                      ],
                                      /* :: */[
                                        /* tuple */[
                                          "functor",
                                          /* FUNCTOR */33
                                        ],
                                        /* :: */[
                                          /* tuple */[
                                            "if",
                                            /* IF */37
                                          ],
                                          /* :: */[
                                            /* tuple */[
                                              "in",
                                              /* IN */38
                                            ],
                                            /* :: */[
                                              /* tuple */[
                                                "include",
                                                /* INCLUDE */39
                                              ],
                                              /* :: */[
                                                /* tuple */[
                                                  "inherit",
                                                  /* INHERIT */40
                                                ],
                                                /* :: */[
                                                  /* tuple */[
                                                    "initializer",
                                                    /* INITIALIZER */41
                                                  ],
                                                  /* :: */[
                                                    /* tuple */[
                                                      "lazy",
                                                      /* LAZY */42
                                                    ],
                                                    /* :: */[
                                                      /* tuple */[
                                                        "let",
                                                        /* LET */53
                                                      ],
                                                      /* :: */[
                                                        /* tuple */[
                                                          "match",
                                                          /* MATCH */58
                                                        ],
                                                        /* :: */[
                                                          /* tuple */[
                                                            "method",
                                                            /* METHOD */59
                                                          ],
                                                          /* :: */[
                                                            /* tuple */[
                                                              "module",
                                                              /* MODULE */63
                                                            ],
                                                            /* :: */[
                                                              /* tuple */[
                                                                "mutable",
                                                                /* MUTABLE */64
                                                              ],
                                                              /* :: */[
                                                                /* tuple */[
                                                                  "new",
                                                                  /* NEW */65
                                                                ],
                                                                /* :: */[
                                                                  /* tuple */[
                                                                    "nonrec",
                                                                    /* NONREC */66
                                                                  ],
                                                                  /* :: */[
                                                                    /* tuple */[
                                                                      "object",
                                                                      /* OBJECT */67
                                                                    ],
                                                                    /* :: */[
                                                                      /* tuple */[
                                                                        "of",
                                                                        /* OF */68
                                                                      ],
                                                                      /* :: */[
                                                                        /* tuple */[
                                                                          "open",
                                                                          /* OPEN */69
                                                                        ],
                                                                        /* :: */[
                                                                          /* tuple */[
                                                                            "or",
                                                                            /* OR */70
                                                                          ],
                                                                          /* :: */[
                                                                            /* tuple */[
                                                                              "private",
                                                                              /* PRIVATE */75
                                                                            ],
                                                                            /* :: */[
                                                                              /* tuple */[
                                                                                "rec",
                                                                                /* REC */80
                                                                              ],
                                                                              /* :: */[
                                                                                /* tuple */[
                                                                                  "sig",
                                                                                  /* SIG */85
                                                                                ],
                                                                                /* :: */[
                                                                                  /* tuple */[
                                                                                    "struct",
                                                                                    /* STRUCT */87
                                                                                  ],
                                                                                  /* :: */[
                                                                                    /* tuple */[
                                                                                      "then",
                                                                                      /* THEN */88
                                                                                    ],
                                                                                    /* :: */[
                                                                                      /* tuple */[
                                                                                        "to",
                                                                                        /* TO */90
                                                                                      ],
                                                                                      /* :: */[
                                                                                        /* tuple */[
                                                                                          "true",
                                                                                          /* TRUE */91
                                                                                        ],
                                                                                        /* :: */[
                                                                                          /* tuple */[
                                                                                            "try",
                                                                                            /* TRY */92
                                                                                          ],
                                                                                          /* :: */[
                                                                                            /* tuple */[
                                                                                              "type",
                                                                                              /* TYPE */93
                                                                                            ],
                                                                                            /* :: */[
                                                                                              /* tuple */[
                                                                                                "val",
                                                                                                /* VAL */95
                                                                                              ],
                                                                                              /* :: */[
                                                                                                /* tuple */[
                                                                                                  "virtual",
                                                                                                  /* VIRTUAL */96
                                                                                                ],
                                                                                                /* :: */[
                                                                                                  /* tuple */[
                                                                                                    "when",
                                                                                                    /* WHEN */97
                                                                                                  ],
                                                                                                  /* :: */[
                                                                                                    /* tuple */[
                                                                                                      "while",
                                                                                                      /* WHILE */98
                                                                                                    ],
                                                                                                    /* :: */[
                                                                                                      /* tuple */[
                                                                                                        "with",
                                                                                                        /* WITH */99
                                                                                                      ],
                                                                                                      /* :: */[
                                                                                                        /* tuple */[
                                                                                                          "mod",
                                                                                                          /* INFIXOP3 */Block.__(5, ["mod"])
                                                                                                        ],
                                                                                                        /* :: */[
                                                                                                          /* tuple */[
                                                                                                            "land",
                                                                                                            /* INFIXOP3 */Block.__(5, ["land"])
                                                                                                          ],
                                                                                                          /* :: */[
                                                                                                            /* tuple */[
                                                                                                              "lor",
                                                                                                              /* INFIXOP3 */Block.__(5, ["lor"])
                                                                                                            ],
                                                                                                            /* :: */[
                                                                                                              /* tuple */[
                                                                                                                "lxor",
                                                                                                                /* INFIXOP3 */Block.__(5, ["lxor"])
                                                                                                              ],
                                                                                                              /* :: */[
                                                                                                                /* tuple */[
                                                                                                                  "lsl",
                                                                                                                  /* INFIXOP4 */Block.__(6, ["lsl"])
                                                                                                                ],
                                                                                                                /* :: */[
                                                                                                                  /* tuple */[
                                                                                                                    "lsr",
                                                                                                                    /* INFIXOP4 */Block.__(6, ["lsr"])
                                                                                                                  ],
                                                                                                                  /* :: */[
                                                                                                                    /* tuple */[
                                                                                                                      "asr",
                                                                                                                      /* INFIXOP4 */Block.__(6, ["asr"])
                                                                                                                    ],
                                                                                                                    /* [] */0
                                                                                                                  ]
                                                                                                                ]
                                                                                                              ]
                                                                                                            ]
                                                                                                          ]
                                                                                                        ]
                                                                                                      ]
                                                                                                    ]
                                                                                                  ]
                                                                                                ]
                                                                                              ]
                                                                                            ]
                                                                                          ]
                                                                                        ]
                                                                                      ]
                                                                                    ]
                                                                                  ]
                                                                                ]
                                                                              ]
                                                                            ]
                                                                          ]
                                                                        ]
                                                                      ]
                                                                    ]
                                                                  ]
                                                                ]
                                                              ]
                                                            ]
                                                          ]
                                                        ]
                                                      ]
                                                    ]
                                                  ]
                                                ]
                                              ]
                                            ]
                                          ]
                                        ]
                                      ]
                                    ]
                                  ]
                                ]
                              ]
                            ]
                          ]
                        ]
                      ]
                    ]
                  ]
                ]
              ]
            ]
          ]
        ]
      ]
    ]);

var initial_string_buffer = Caml_bytes.caml_create_bytes(256);

var string_buff = {
  contents: initial_string_buffer
};

var string_index = {
  contents: 0
};

function reset_string_buffer(param) {
  string_buff.contents = initial_string_buffer;
  string_index.contents = 0;
  
}

function store_string_char(c) {
  if (string_index.contents >= string_buff.contents.length) {
    var new_buff = Caml_bytes.caml_create_bytes((string_buff.contents.length << 1));
    Bytes.blit(string_buff.contents, 0, new_buff, 0, string_buff.contents.length);
    string_buff.contents = new_buff;
  }
  string_buff.contents[string_index.contents] = c;
  string_index.contents = string_index.contents + 1 | 0;
  
}

function store_string(s) {
  for(var i = 0 ,i_finish = s.length - 1 | 0; i <= i_finish; ++i){
    store_string_char(Caml_string.get(s, i));
  }
  
}

function get_stored_string(param) {
  var s = Bytes.sub_string(string_buff.contents, 0, string_index.contents);
  string_buff.contents = initial_string_buffer;
  return s;
}

var string_start_loc = {
  contents: none
};

var comment_start_loc = {
  contents: /* [] */0
};

var is_in_string = {
  contents: false
};

var print_warnings = {
  contents: true
};

var if_then_else = {
  contents: /* Dir_out */2
};

var sharp_look_ahead = {
  contents: void 0
};

function with_comment_buffer(comment, lexbuf) {
  var start_loc = curr(lexbuf);
  comment_start_loc.contents = /* :: */[
    start_loc,
    /* [] */0
  ];
  reset_string_buffer(void 0);
  var end_loc = Curry._1(comment, lexbuf);
  var s = get_stored_string(void 0);
  reset_string_buffer(void 0);
  var loc_loc_start = start_loc.loc_start;
  var loc_loc_end = end_loc.loc_end;
  var loc_loc_ghost = start_loc.loc_ghost;
  var loc = {
    loc_start: loc_loc_start,
    loc_end: loc_loc_end,
    loc_ghost: loc_loc_ghost
  };
  return /* tuple */[
          s,
          loc
        ];
}

function char_for_backslash(c) {
  if (c < 110) {
    if (c !== 98) {
      return c;
    } else {
      return /* "\b" */8;
    }
  }
  if (c >= 117) {
    return c;
  }
  switch (c - 110 | 0) {
    case 0 :
        return /* "\n" */10;
    case 4 :
        return /* "\r" */13;
    case 1 :
    case 2 :
    case 3 :
    case 5 :
        return c;
    case 6 :
        return /* "\t" */9;
    
  }
}

function char_for_decimal_code(lexbuf, i) {
  var c = (Caml_int32.imul(100, Lexing.lexeme_char(lexbuf, i) - 48 | 0) + Caml_int32.imul(10, Lexing.lexeme_char(lexbuf, i + 1 | 0) - 48 | 0) | 0) + (Lexing.lexeme_char(lexbuf, i + 2 | 0) - 48 | 0) | 0;
  if (!(c < 0 || c > 255)) {
    return Char.chr(c);
  }
  if (comment_start_loc.contents !== /* [] */0) {
    return /* "x" */120;
  }
  throw [
        $$Error$4,
        /* Illegal_escape */Block.__(1, [Lexing.lexeme(lexbuf)]),
        curr(lexbuf)
      ];
}

function char_for_hexadecimal_code(lexbuf, i) {
  var d1 = Lexing.lexeme_char(lexbuf, i);
  var val1 = d1 >= 97 ? d1 - 87 | 0 : (
      d1 >= 65 ? d1 - 55 | 0 : d1 - 48 | 0
    );
  var d2 = Lexing.lexeme_char(lexbuf, i + 1 | 0);
  var val2 = d2 >= 97 ? d2 - 87 | 0 : (
      d2 >= 65 ? d2 - 55 | 0 : d2 - 48 | 0
    );
  return Char.chr((val1 << 4) + val2 | 0);
}

function cvt_int_literal(s) {
  return -Caml_format.caml_int_of_string("-" + s) | 0;
}

function cvt_int32_literal(s) {
  return -Caml_format.caml_int32_of_string("-" + $$String.sub(s, 0, s.length - 1 | 0)) | 0;
}

function cvt_int64_literal(s) {
  return Caml_int64.neg(Caml_format.caml_int64_of_string("-" + $$String.sub(s, 0, s.length - 1 | 0)));
}

function cvt_nativeint_literal(s) {
  return -Caml_format.caml_nativeint_of_string("-" + $$String.sub(s, 0, s.length - 1 | 0));
}

function remove_underscores(s) {
  var l = s.length;
  var b = Caml_bytes.caml_create_bytes(l);
  var _src = 0;
  var _dst = 0;
  while(true) {
    var dst = _dst;
    var src = _src;
    if (src >= l) {
      if (dst >= l) {
        return s;
      } else {
        return Bytes.sub_string(b, 0, dst);
      }
    }
    var c = Caml_string.get(s, src);
    if (c !== 95) {
      b[dst] = c;
      _dst = dst + 1 | 0;
      _src = src + 1 | 0;
      continue ;
    } else {
      _src = src + 1 | 0;
      continue ;
    }
  };
}

function get_label_name(lexbuf) {
  var s = Lexing.lexeme(lexbuf);
  var name = $$String.sub(s, 1, s.length - 2 | 0);
  if (Hashtbl.mem(keyword_table, name)) {
    throw [
          $$Error$4,
          /* Keyword_as_label */Block.__(4, [name]),
          curr(lexbuf)
        ];
  }
  return name;
}

function update_loc(lexbuf, file, line, absolute, chars) {
  var pos = lexbuf.lex_curr_p;
  var new_file = file !== void 0 ? file : pos.pos_fname;
  lexbuf.lex_curr_p = {
    pos_fname: new_file,
    pos_lnum: absolute ? line : pos.pos_lnum + line | 0,
    pos_bol: pos.pos_cnum - chars | 0,
    pos_cnum: pos.pos_cnum
  };
  
}

var preprocessor = {
  contents: void 0
};

var escaped_newlines = {
  contents: false
};

var comment_list = {
  contents: /* [] */0
};

function add_comment(com) {
  comment_list.contents = /* :: */[
    com,
    comment_list.contents
  ];
  
}

function add_docstring_comment(ds) {
  return add_comment(/* tuple */[
              ds.ds_body,
              ds.ds_loc
            ]);
}

function report_error$2(ppf, param) {
  if (typeof param === "number") {
    switch (param) {
      case /* Unterminated_string */0 :
          return Format.fprintf(ppf, /* Format */[
                      /* String_literal */Block.__(11, [
                          "String literal not terminated",
                          /* End_of_format */0
                        ]),
                      "String literal not terminated"
                    ]);
      case /* Unterminated_paren_in_conditional */1 :
          return Format.fprintf(ppf, /* Format */[
                      /* String_literal */Block.__(11, [
                          "Unterminated parens in conditional predicate",
                          /* End_of_format */0
                        ]),
                      "Unterminated parens in conditional predicate"
                    ]);
      case /* Unterminated_if */2 :
          return Format.fprintf(ppf, /* Format */[
                      /* String_literal */Block.__(11, [
                          "#if not terminated",
                          /* End_of_format */0
                        ]),
                      "#if not terminated"
                    ]);
      case /* Unterminated_else */3 :
          return Format.fprintf(ppf, /* Format */[
                      /* String_literal */Block.__(11, [
                          "#else not terminated",
                          /* End_of_format */0
                        ]),
                      "#else not terminated"
                    ]);
      case /* Unexpected_token_in_conditional */4 :
          return Format.fprintf(ppf, /* Format */[
                      /* String_literal */Block.__(11, [
                          "Unexpected token in conditional predicate",
                          /* End_of_format */0
                        ]),
                      "Unexpected token in conditional predicate"
                    ]);
      case /* Expect_hash_then_in_conditional */5 :
          return Format.fprintf(ppf, /* Format */[
                      /* String_literal */Block.__(11, [
                          "Expect `then` after conditional predicate",
                          /* End_of_format */0
                        ]),
                      "Expect `then` after conditional predicate"
                    ]);
      case /* Unexpected_directive */6 :
          return Format.fprintf(ppf, /* Format */[
                      /* String_literal */Block.__(11, [
                          "Unexpected directive",
                          /* End_of_format */0
                        ]),
                      "Unexpected directive"
                    ]);
      
    }
  } else {
    switch (param.tag | 0) {
      case /* Illegal_character */0 :
          return Curry._1(Format.fprintf(ppf, /* Format */[
                          /* String_literal */Block.__(11, [
                              "Illegal character (",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* Char_literal */Block.__(12, [
                                      /* ")" */41,
                                      /* End_of_format */0
                                    ])
                                ])
                            ]),
                          "Illegal character (%s)"
                        ]), Char.escaped(param[0]));
      case /* Illegal_escape */1 :
          return Curry._1(Format.fprintf(ppf, /* Format */[
                          /* String_literal */Block.__(11, [
                              "Illegal backslash escape in string or character (",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* Char_literal */Block.__(12, [
                                      /* ")" */41,
                                      /* End_of_format */0
                                    ])
                                ])
                            ]),
                          "Illegal backslash escape in string or character (%s)"
                        ]), param[0]);
      case /* Unterminated_comment */2 :
          return Format.fprintf(ppf, /* Format */[
                      /* String_literal */Block.__(11, [
                          "Comment not terminated",
                          /* End_of_format */0
                        ]),
                      "Comment not terminated"
                    ]);
      case /* Unterminated_string_in_comment */3 :
          return Curry._2(Format.fprintf(ppf, /* Format */[
                          /* String_literal */Block.__(11, [
                              "This comment contains an unterminated string literal",
                              /* Formatting_lit */Block.__(17, [
                                  /* Flush_newline */4,
                                  /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                          "String literal begins here",
                                          /* End_of_format */0
                                        ])])
                                ])
                            ]),
                          "This comment contains an unterminated string literal@.%aString literal begins here"
                        ]), print_error, param[1]);
      case /* Keyword_as_label */4 :
          return Curry._1(Format.fprintf(ppf, /* Format */[
                          /* Char_literal */Block.__(12, [
                              /* "`" */96,
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* String_literal */Block.__(11, [
                                      "' is a keyword, it cannot be used as label name",
                                      /* End_of_format */0
                                    ])
                                ])
                            ]),
                          "`%s' is a keyword, it cannot be used as label name"
                        ]), param[0]);
      case /* Literal_overflow */5 :
          return Curry._1(Format.fprintf(ppf, /* Format */[
                          /* String_literal */Block.__(11, [
                              "Integer literal exceeds the range of representable integers of type ",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* End_of_format */0
                                ])
                            ]),
                          "Integer literal exceeds the range of representable integers of type %s"
                        ]), param[0]);
      case /* Illegal_semver */6 :
          return Curry._1(Format.fprintf(ppf, /* Format */[
                          /* String_literal */Block.__(11, [
                              "Illegal semantic version string ",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* End_of_format */0
                                ])
                            ]),
                          "Illegal semantic version string %s"
                        ]), param[0]);
      case /* Conditional_expr_expected_type */7 :
          return Curry._2(Format.fprintf(ppf, /* Format */[
                          /* String_literal */Block.__(11, [
                              "Conditional expression type mismatch (",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* Char_literal */Block.__(12, [
                                      /* "," */44,
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* Char_literal */Block.__(12, [
                                              /* ")" */41,
                                              /* End_of_format */0
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "Conditional expression type mismatch (%s,%s)"
                        ]), string_of_type_directive(param[0]), string_of_type_directive(param[1]));
      
    }
  }
}

register_error_of_exn((function (param) {
        if (param[0] === $$Error$4) {
          return error_of_printer(param[2], report_error$2, param[1]);
        }
        
      }));

var __ocaml_lex_tables = {
  lex_base: "\0\0\xa4\xff\xa5\xff\xe0\0\x03\x01&\x01I\x01l\x01\x8f\x01\xbc\xff\xb2\x01\xd7\x01\xc4\xff[\0\xfc\x01\x1f\x02D\0G\0T\0B\x02\xd5\xff\xd7\xff\xda\xffe\x02\xc4\x02\xe7\x02Y\0\xff\0\x05\x03\xec\xffR\x03s\x03\xbc\x03\x8c\x04\\\x05,\x06\x0b\x07g\x077\b}\0\xfe\xff\x01\0\x05\0\xff\xff\x06\0\x07\0\x16\t4\t\x04\n\xfa\xff\xf9\xff\xd4\n\xa4\x0b\xf7\xff\xf6\xff\xed\xff\xee\xff\xef\xff]\0v\x02[\0n\0\xe7\x02\x07\x04\xd7\x04e\x02\xfe\x02v\0\xc2\xff\xeb\xffx\x05\x84\f`\0q\0\x0b\0\xea\xff\xe9\xff\xe5\xff\xe5\x04\x80\0s\0\xe8\xff\xe0\0u\0\xe7\xffw\x06\x93\0\xe6\xff\x92\0\xe1\xff\x94\0\xe0\xff\xd9\0\x84\f\xdf\xff\xab\f\xaf\b\xae\x06\xde\xff\f\0\x18\x01,\x01P\x01-\x01\xde\xff\r\0\xd9\f\0\r#\rI\r\xd2\xff\xce\xff\xcf\xff\xd0\xff\xcc\xffl\r\x9a\0\xb7\0\xc5\xff\xc6\xff\xc7\xff\xc7\0\xb6\xff\xb8\xff\xbf\xff\x8f\r\xbb\xff\xbd\xff\xb2\r\xd5\r\xf8\r\x1b\x0e\xeb\x05\xf3\xff\xf4\xff\x11\0\xf5\xff>\x02\xac\x07\xfd\xff\xdf\0\xf1\0\xff\xff\xfe\xff\xfc\xff\xc8\x07-\x0e\xfa\0\xfc\0\x12\0\xfb\xff\xfa\xff\xf9\xff\x80\t\x1e\x03\x03\x01\xf8\xff\\\x03\x04\x01\xf7\xffO\n\x05\x01\xf6\xff+\x01\xc7\x01\xf7\xff\xf8\xff\xf9\xff;\x01v\x0e\xff\xff\xfa\xff\x1f\x0b$\x04\xfd\xff&\x01E\x01^\x01\xfc\x04\xfc\xff\xef\x0b\xfb\xff_\x01\xb5\x01\xfc\xff\xee\x06\xfe\xff\xff\xffo\x01p\x01\xfd\xffJ\x07\x10\x01\x13\x012\x01?\x01\x1a\x01k\x01!\x01\x13\0\xff\xff",
  lex_backtrk: "\xff\xff\xff\xff\xff\xffX\0W\0T\0S\0L\0J\0\xff\xffA\0>\0\xff\xff7\x006\x004\x002\0.\0,\0O\0\xff\xff\xff\xff\xff\xff#\0\"\0)\0'\0&\0<\0\xff\xff\x0e\0\x0e\0\r\0\f\0\x0b\0\n\0\x07\0\x04\0\x03\0\x02\0\xff\xff[\0[\0\xff\xff\xff\xff\xff\xffR\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x0f\0\xff\xff\xff\xff\xff\xff\x0e\0\x0e\0\x0e\0\x0f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1a\0\x1a\0\x1a\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1b\0\xff\xff\x1c\0\xff\xff\x1d\0V\0\xff\xffY\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\0U\0P\0+\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff5\0F\0E\0\xff\xff\xff\xff\xff\xffH\0\xff\xff\xff\xff\xff\xff?\0\xff\xff\xff\xffQ\0K\0N\0M\0\xff\xff\xff\xff\xff\xff\f\0\xff\xff\f\0\f\0\xff\xff\f\0\f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\b\0\b\0\xff\xff\xff\xff\x05\0\x05\0\xff\xff\x01\0\x05\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x03\0\xff\xff\xff\xff\x03\0\xff\xff\xff\xff\xff\xff\x02\0\xff\xff\xff\xff\x01\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff",
  lex_default: "\x01\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xffH\0\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\xff\xff\xff\xff\0\0\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\xff\xffM\0\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\xff\xff\0\0\xff\xff\0\0\xff\xff\xff\xff\0\0\xff\xffd\0\xff\xff\0\0\xff\xffd\0e\0d\0g\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\xff\xff\0\0\0\0\0\0\xff\xff\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\x85\0\0\0\0\0\xff\xff\0\0\x93\0\xff\xff\0\0\xff\xff\xff\xff\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\xff\xff\xa5\0\0\0\0\0\0\0\xff\xff\xab\0\0\0\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\0\0\xff\xff\xb8\0\0\0\xff\xff\0\0\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xc2\0\xc5\0\xff\xff\xc5\0\xff\xff\xff\xff\0\0",
  lex_trans: "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\0(\0(\0'\0)\0-\0+\0+\0(\0,\0,\0-\0I\0b\0h\0J\0c\0i\0\x86\0\x94\0\xc8\0\xa3\0\x95\0'\0\b\0\x1d\0\x18\0\x06\0\x04\0\x17\0\x1b\0\x1a\0\x15\0\x19\0\x07\0\x14\0\x13\0\x12\0\x03\0\x1f\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x11\0\x10\0\x0f\0\x0e\0\n\0$\0\x05\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\r\0*\0\f\0\x05\0&\0\x16\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\x1c\0\x0b\0\t\0%\0r\0t\0q\0n\0X\0p\0o\0'\0L\0C\0'\0C\0A\0A\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0w\0K\0v\0Q\0u\0T\0'\0@\0@\0@\0@\0@\0@\0@\0@\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0W\0Y\0Z\0[\0\\\0{\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0x\0 \0 \0 \0 \0 \0 \0 \0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0y\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\x02\0\x03\0[\0\\\0\x03\0\x03\0\x03\0z\0\x8f\0I\0\x03\0\x03\0J\0\x03\0\x03\0\x03\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\x03\0\x8e\0\x03\0\x03\0\x03\0\x03\0\x03\0\x98\0b\0\x97\0\x03\0c\0\xff\xff\x03\0\x03\0\x03\0\x9c\0\x9f\0\xa2\0\x03\0\x03\0\xaf\0\x03\0\x03\0\x03\0\xc1\0\xc2\0\x86\0b\0h\0\xa3\0c\0i\0\xc6\0\xc3\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\xc7\0\xa7\0\xaf\0\x05\0\xb6\0\xc4\0\x05\0\x05\0\x05\0\0\0g\0\xaf\0\x05\0\x05\0\xb1\0\x05\0\x05\0\x05\0\0\0\0\0\0\0f\0b\0G\0\x03\0c\0\x03\0\0\0\x05\0\x03\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\xaf\0\xa7\0\x06\0\xb1\0\xb6\0\x06\0\x06\0\x06\0f\0\0\0e\0\x06\0\x06\0\xc4\0\x06\0\x06\0\x06\0\xbb\0\xbb\0\0\0\xbd\0\xbd\0\0\0\x03\0\0\0\x03\0\0\0\x06\0\x05\0\x06\0\x06\0\x06\0\x06\0\x06\0\0\0\0\0\0\0k\0\0\0\0\0k\0k\0k\0\0\0\0\0\0\0k\0k\0\0\0k\0\x83\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\0\0\0\x05\0\0\0k\0\x06\0k\0\x82\0k\0k\0k\0\0\0\0\0\0\0\x80\0\0\0\0\0\x80\0\x80\0\x80\0\0\0\0\0\0\0\x80\0\x80\0\0\0\x80\0\x80\0\x80\0\xbb\0\0\0\0\0\xbc\0\0\0\0\0\x06\0\0\0\x06\0\0\0\x80\0k\0\x80\0\x81\0\x80\0\x80\0\x80\0\0\0\xa7\0\0\0\x06\0\xa8\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\0\0\0\0\0\0k\0\xaa\0k\0\0\0\x06\0\x80\0\x06\0\x06\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\0\0\0\0\x06\0\0\0\0\0\x06\0\x06\0\x06\0\0\0\xff\xff\0\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\0\0\x80\0\0\0\x80\0\0\0\x7f\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0\x06\0\x06\0\xff\xff\0\0\0\0\0\0\0\0\x06\0\0\0\0\0\x06\0\x06\0\x06\0\xa9\0\0\0\0\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0\xff\xff\xff\xff\x06\0~\0\x06\0\xb9\0\xff\xff\0\0|\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0\x06\0\x06\0\0\0\0\0\xff\xff\x06\0\0\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\x94\0\x06\0\x06\0\x95\0s\0\x06\0\x06\0\0\0\xff\xff\0\0\0\0}\0\0\0\x06\0\0\0\0\0\0\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\0\0\0\0\0\0k\0\0\0\x96\0k\0k\0k\0\0\0\0\0\xff\xffk\0k\0\0\0k\0l\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\0\0\x06\0\0\0k\0\x06\0k\0k\0m\0k\0k\0\0\0\0\0\0\0\x06\0\0\0\0\0\x06\0\x06\0j\0\0\0\0\0\0\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0A\0A\0\0\0\0\0\0\0\x92\0\x06\0\0\0\x06\0\0\0\x06\0k\0\x06\0\x06\0\x06\0\x06\0\x06\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0\0\x008\0\0\0\0\0\0\0\xba\0\0\0\0\0\0\0\0\0\0\0:\0\0\0\0\0k\0\0\0k\0\0\0\0\0\x06\0A\0\0\0\0\0\xa6\0\0\0\0\0\0\0\0\0\0\0a\0\0\0\0\0\0\x009\0\0\x007\0\0\0;\0\0\0\0\0\0\0\0\0\0\0:\0\0\0\0\0\0\0\0\0\0\0\x06\0\0\0\x06\0a\0_\0\0\0_\0_\0_\0_\0\0\0\0\0\0\0_\0_\0\0\0_\0_\0_\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0_\0\0\0_\0_\0_\0_\0_\0\0\0\0\0\0\0\x03\0\0\0\0\0\x03\0\x03\0\x03\0\0\0\0\0^\0]\0\x03\0\0\0\x03\0\x03\0\x03\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0\x03\0_\0\x03\0\x03\0\x03\0\x03\0\x03\0?\0?\0?\0?\0?\0?\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\0\0_\0D\0_\0\0\0\0\0\x03\0\0\0\0\0?\0?\0?\0?\0?\0?\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\0\0\0\0\0\0\0\0\0\0B\0\0\0\0\0\0\0\0\0\0\0\x03\0F\0\x03\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0;\0E\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\0\0:\0\0\0\0\0\0\0\0\0\0\0\0\x008\0\0\0\0\0;\0\0\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\0\0\0\0\0\0\0\0\x1e\0\0\0\0\0\0\0<\0\0\0:\0:\0\0\0\0\0\0\0\0\0\0\x009\x008\x007\0\0\0=\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0>\0\0\0\0\0\0\0\0\0\0\0\0\0\x1e\0\0\0\0\0<\0\0\0\0\0:\0\0\0\0\0\0\0\0\0\0\0\0\x009\0\0\x007\0=\0 \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0>\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\0\0\0\0\0\0\0\0 \0\0\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0?\0?\0?\0?\0?\0?\0\0\0\0\0\0\0\0\0\0\x008\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0?\0\0\0?\0?\0?\0?\0?\0?\0\0\0\0\0\0\0\0\0\0\x009\0\0\x007\0\0\0\0\0\0\0\0\0\0\0\0\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\0\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0!\0 \0 \0 \0 \0 \0 \0 \0 \0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\0\0\0\0\0\0\0\0!\0\0\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0@\0@\0@\0@\0@\0@\0@\0@\0\0\0\0\0\0\0\0\0\0\0\0\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0\0\0\0\0\0\0\0\x008\0\0\0\0\0U\0U\0U\0U\0U\0U\0\xb3\0\xb3\0\xb3\0\xb3\0\xb3\0\xb3\0\xb3\0\xb3\0\xb3\0\xb3\0@\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x009\0\0\x007\0U\0U\0U\0U\0U\0U\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\0\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\"\0 \0 \0 \0 \0 \0 \0 \0 \0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\0\0\0\0\0\0\0\0\"\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0F\0\0\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0\0\0E\0\x86\0\0\0\0\0\x87\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8b\0\0\0\0\0\0\0\0\0\x89\0\x8d\0\0\0\x8c\0\0\0\0\0\0\0\0\0\0\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0#\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\x8a\0\0\0\0\0\0\0\0\0\0\0\0\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\0\0\0\0\0\0\0\0#\0\0\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0\0\0\0\0\0\0\0\0\0\0\0\0a\0V\0V\0V\0V\0V\0V\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0V\0V\0V\0V\0V\0V\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0\0\0\0\0\0\0\x88\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0.\0\0\0\0\0.\0.\0.\0\0\0\0\0\0\0.\0.\0\0\0.\0.\0.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0.\0\0\0.\0.\0.\0.\0.\0\0\0\xbf\0\0\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0.\x004\0\xbe\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\0\0.\0.\0.\0\0\0.\0.\0.\0\0\0\0\0\0\0.\0.\0\0\0.\0.\0.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0.\0\0\0.\0.\0.\0.\0.\0\0\0\xbf\0\0\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0.\x000\0\xbe\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\0\0.\0\0\0.\0\0\0\0\0\0\0\0\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\0\x003\x003\x003\x003\x003\x003\x003\x003\0\x91\0\0\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x90\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\0\0\x90\0\0\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0#\0/\0/\0/\0/\0/\0/\0/\0/\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\0\0\0\0\0\0\0\0#\0\0\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\0\0\0\0\0\0\0\0\0\0\0\0f\0b\0\0\0\0\0c\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0f\0\0\0e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\0\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0.\0\0\0\0\0.\0.\0.\0\0\0\0\0\0\0.\0.\0\0\0.\0.\0.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0.\0\0\0.\0.\0.\0.\0.\0\0\0\0\0\0\0\0\0/\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\x002\0\0\0\0\0\0\0\0\0\0\0.\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\0\0\0\0\0\0.\0/\0.\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\xff\xff\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\0\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\x000\0/\0/\0/\0/\0/\0/\0/\0/\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x001\0\0\0\0\0\0\0\0\0\0\0\0\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\0\0\0\0\0\0\0\x000\0\0\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\xa1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\0\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\x003\0/\0/\0/\0/\0/\0/\0/\0/\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x006\0\0\0\0\0\0\0\0\0\0\0\0\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\0\0\0\0\0\0\0\x003\0\0\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\0\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x004\x003\x003\x003\x003\x003\x003\x003\x003\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x005\0\0\0\0\0\0\0\0\0\0\0\0\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\0\0\0\0\0\0\0\x004\0\0\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\xb5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\0\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\0\x003\x003\x003\x003\x003\x003\x003\x003\0P\0]\0P\0\0\0]\0]\0]\0P\0\0\0\0\0]\0]\0\0\0]\0]\0]\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0]\0\0\0]\0]\0]\0]\0]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\0\0\0_\0_\0_\0_\0\0\0\0\0\0\0_\0_\0\0\0_\0_\0_\0\0\0\0\0\0\0\0\0\0\0P\0\0\0]\0\0\0\0\0_\0P\0_\0_\0_\0_\0_\0\0\0\0\0\0\0\0\0\0\0\0\0P\0\0\0\0\0\0\0P\0\0\0P\0\0\0\x06\0\0\0N\0\x06\0\x06\0\x06\0]\0\0\0]\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0_\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\0\0\x06\0\x06\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0k\0\0\0\0\0k\0k\0k\0_\0\0\0_\0k\0k\0\0\0k\0k\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\0\0\0\0k\0\0\0k\0k\0k\0k\0k\0\0\0\0\0\0\0k\0\0\0\0\0k\0k\0k\0\0\0\0\0\0\0k\0k\0\0\0k\0k\0k\0\0\0\0\0\x06\0\0\0\x06\0\0\0\0\0\0\0\0\0\0\0k\0k\0k\0k\0k\0k\0k\0\0\0\0\0\0\0\0\0\0\0\0\0k\0\0\0\0\0k\0k\0k\0\0\0\0\0\0\0k\0k\0\0\0k\0k\0k\0\0\0\0\0\0\0k\0\0\0k\0\0\0\0\0k\0\0\0k\0\xff\xffk\0k\0k\0k\0k\0\0\0\0\0\0\0\x06\0\0\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\0\0k\0\0\0k\0\0\0\0\0\0\0\0\0\x06\0k\0\x06\0\x06\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\x06\0\0\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\x06\0\x06\0\0\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\0\0\0\0\0\0k\0\0\0k\0\0\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\0\0\0\0\0\0\x80\0\0\0\0\0\x80\0\x80\0\x80\0\0\0\0\0\0\0\x80\0\x80\0\0\0\x80\0\x80\0\x80\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\0\0\x06\0\0\0\x80\0\x06\0\x80\0\x80\0\x80\0\x80\0\x80\0\0\0\0\0\0\0\x80\0\0\0\0\0\x80\0\x80\0\x80\0\0\0\0\0\0\0\x80\0\x80\0\0\0\x80\0\x80\0\x80\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\0\0\x06\0\0\0\x80\0\x80\0\x80\0\x80\0\x80\0\x80\0\x80\0\0\0\0\0\0\0k\0\0\0\0\0k\0k\0k\0\0\0\0\0\0\0k\0k\0\0\0k\0k\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\x80\0\0\0\x80\0\0\0k\0\x80\0k\0k\0k\0k\0k\0\0\0\0\0\0\0k\0\0\0\0\0k\0k\0k\0\0\0\0\0\0\0k\0k\0\0\0k\0k\0k\0\0\0\0\0\x9b\0\0\0\x9b\0\0\0\x80\0\0\0\x80\0\x9b\0k\0k\0k\0k\0k\0k\0k\0\0\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0k\0\0\0k\0\0\0\0\0k\0\0\0\0\0\0\0\0\0\0\0\0\0\xaf\0\0\0\0\0\xb0\0\0\0\0\0\0\0\0\0\0\0\x9b\0\0\0\0\0\0\0\0\0\0\0\x9b\0\0\0\0\0\0\0\0\0\0\0\0\0\xae\0k\0\xae\0k\0\0\0\x9b\0\0\0\xae\0\0\0\x9b\0\0\0\x9b\0\0\0\0\0\0\0\x99\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xae\0\0\0\0\0\0\0\0\0\0\0\xae\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xae\0\0\0\0\0\0\0\xae\0\0\0\xae\0\0\0\0\0\0\0\xac\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff",
  lex_check: "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0)\0\0\0\0\0)\0*\0,\0-\0*\0,\0-\0J\0c\0i\0J\0c\0i\0\x87\0\x95\0\xc7\0\x87\0\x95\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x10\0\r\0\x11\0\x12\0\x1a\0\x11\0\x11\0'\0H\0:\0'\0:\0<\0<\0:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0\r\0I\0\r\0P\0\r\0S\0'\0=\0=\0=\0=\0=\0=\0=\0=\0C\0C\0C\0C\0C\0C\0C\0C\0C\0C\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0V\0X\0X\0Z\0Z\0t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03\0\\\0\\\0\x03\0\x03\0\x03\0y\0\x8c\0\x1b\0\x03\0\x03\0\x1b\0\x03\0\x03\0\x03\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0\x03\0\x8d\0\x03\0\x03\0\x03\0\x03\0\x03\0\x93\0d\0\x94\0\x04\0d\0\x1b\0\x04\0\x04\0\x04\0\x9b\0\x9e\0\xa1\0\x04\0\x04\0\xaf\0\x04\0\x04\0\x04\0\xc0\0\xc1\0\xa3\0e\0g\0\xa3\0e\0g\0\xc4\0\xc2\0\x04\0\x03\0\x04\0\x04\0\x04\0\x04\0\x04\0\xc6\0\xa8\0\xaf\0\x05\0\xa8\0\xc3\0\x05\0\x05\0\x05\0\xff\xffe\0\xb0\0\x05\0\x05\0\xb0\0\x05\0\x05\0\x05\0\xff\xff\xff\xff\xff\xfff\0f\0\x1b\0\x03\0f\0\x03\0\xff\xff\x05\0\x04\0\x05\0\x05\0\x05\0\x05\0\x05\0\xff\xff\xb1\0\xb6\0\x06\0\xb1\0\xb6\0\x06\0\x06\0\x06\0f\0\xff\xfff\0\x06\0\x06\0\xc5\0\x06\0\x06\0\x06\0\xbc\0\xbd\0\xff\xff\xbc\0\xbd\0\xff\xff\x04\0\xff\xff\x04\0\xff\xff\x06\0\x05\0\x06\0\x06\0\x06\0\x06\0\x06\0\xff\xff\xff\xff\xff\xff\x07\0\xff\xff\xff\xff\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\x07\0\x07\0\xff\xff\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x05\0\xff\xff\x05\0\xff\xff\x07\0\x06\0\x07\0\x07\0\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\b\0\xff\xff\xff\xff\b\0\b\0\b\0\xff\xff\xff\xff\xff\xff\b\0\b\0\xff\xff\b\0\b\0\b\0\xb7\0\xff\xff\xff\xff\xb7\0\xff\xff\xff\xff\x06\0\xff\xff\x06\0\xff\xff\b\0\x07\0\b\0\b\0\b\0\b\0\b\0\xff\xff\xa4\0\xff\xff\n\0\xa4\0\xff\xff\n\0\n\0\n\0\xff\xff\xff\xff\xff\xff\n\0\n\0\xff\xff\n\0\n\0\n\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x07\0\xa4\0\x07\0\xff\xff\n\0\b\0\n\0\n\0\n\0\n\0\n\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x0b\0\xff\xff\xff\xff\x0b\0\x0b\0\x0b\0\xff\xff\x1b\0\xff\xff\x0b\0\x0b\0\xff\xff\x0b\0\x0b\0\x0b\0\xff\xff\xff\xff\xff\xff\xff\xff\b\0\xff\xff\b\0\xff\xff\n\0\n\0\x0b\0\xff\xff\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0d\0\xff\xff\xff\xff\xff\xff\xff\xff\x0e\0\xff\xff\xff\xff\x0e\0\x0e\0\x0e\0\xa4\0\xff\xff\xff\xff\x0e\0\x0e\0\xff\xff\x0e\0\x0e\0\x0e\0e\0g\0\n\0\n\0\n\0\xb7\0\xc2\0\xff\xff\x0b\0\x0b\0\x0e\0\xff\xff\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\xff\xff\xff\xff\xc3\0\x0f\0\xff\xff\xff\xff\x0f\0\x0f\0\x0f\0\xff\xff\xff\xff\x89\0\x0f\0\x0f\0\x89\0\x0f\0\x0f\0\x0f\0\xff\xfff\0\xff\xff\xff\xff\x0b\0\xff\xff\x0b\0\xff\xff\xff\xff\xff\xff\x0f\0\x0e\0\x0f\0\x0f\0\x0f\0\x0f\0\x0f\0\xff\xff\xff\xff\xff\xff\x13\0\xff\xff\x89\0\x13\0\x13\0\x13\0\xff\xff\xff\xff\xc5\0\x13\0\x13\0\xff\xff\x13\0\x13\0\x13\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x0e\0\xff\xff\x0e\0\xff\xff\x13\0\x0f\0\x13\0\x13\0\x13\0\x13\0\x13\0\xff\xff\xff\xff\xff\xff\x17\0\xff\xff\xff\xff\x17\0\x17\0\x17\0\xff\xff\xff\xff\xff\xff\x17\0\x17\0\xff\xff\x17\0\x17\0\x17\0A\0A\0\xff\xff\xff\xff\xff\xff\x89\0\x0f\0\xff\xff\x0f\0\xff\xff\x17\0\x13\0\x17\0\x17\0\x17\0\x17\0\x17\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0\xff\xffA\0\xff\xff\xff\xff\xff\xff\xb7\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff;\0\xff\xff\xff\xff\x13\0\xff\xff\x13\0\xff\xff\xff\xff\x17\0A\0\xff\xff\xff\xff\xa4\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x18\0\xff\xff\xff\xff\xff\xffA\0\xff\xffA\0\xff\xff;\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff;\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x17\0\xff\xff\x17\0\x18\0\x18\0\xff\xff\x18\0\x18\0\x18\0\x18\0\xff\xff\xff\xff\xff\xff\x18\0\x18\0\xff\xff\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\xff\xff\x18\0\x18\0\x18\0\x18\0\x18\0\xff\xff\xff\xff\xff\xff\x19\0\xff\xff\xff\xff\x19\0\x19\0\x19\0\xff\xff\xff\xff\x19\0\x19\0\x19\0\xff\xff\x19\0\x19\0\x19\0>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0\x19\0\x18\0\x19\0\x19\0\x19\0\x19\0\x19\0>\0>\0>\0>\0>\0>\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x89\0\xff\xff\x18\0\x1c\0\x18\0\xff\xff\xff\xff\x19\0\xff\xff\xff\xff>\0>\0>\0>\0>\0>\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffB\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x19\0\x1c\0\x19\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1e\0\x1c\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x1e\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\xff\xff\x1e\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1e\0\xff\xff\xff\xff\x1f\0\xff\xff\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\x1f\0\xff\xff\xff\xff\xff\xff\xff\xff\x1e\0\xff\xff\xff\xff\xff\xff\x1f\0\xff\xff\x1e\0\x1f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1e\0\x1f\0\x1e\0\xff\xff\x1f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1f\0\xff\xff\xff\xff\x1f\0\xff\xff\xff\xff\x1f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1f\0\xff\xff\x1f\0\x1f\0 \0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1f\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\xff\xff\xff\xff\xff\xff\xff\xff \0\xff\xff \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff?\0?\0?\0?\0?\0?\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff?\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xad\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff?\0\xff\xff?\0?\0?\0?\0?\0?\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff?\0\xff\xff?\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0\xff\xff \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0!\0 \0 \0 \0 \0 \0 \0 \0 \0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\xff\xff\xff\xff\xff\xff\xff\xff!\0\xff\xff!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0@\0@\0@\0@\0@\0@\0@\0@\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffN\0N\0N\0N\0N\0N\0N\0N\0N\0N\0\xff\xff\xff\xff\xff\xff\xff\xff@\0\xff\xff\xff\xffN\0N\0N\0N\0N\0N\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0\xb2\0@\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff@\0\xff\xff@\0N\0N\0N\0N\0N\0N\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\xff\xff!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0!\0\"\0!\0!\0!\0!\0!\0!\0!\0!\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\xff\xff\xff\xff\xff\xff\xff\xff\"\0\xff\xff\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0F\0\xff\xffF\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0\xff\xffF\0\x84\0\xff\xff\xff\xff\x84\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x84\0\xff\xff\xff\xff\xff\xff\xff\xff\x84\0\x84\0\xff\xff\x84\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\xff\xff\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0#\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0\"\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\x84\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\xff\xff\xff\xff\xff\xff\xff\xff#\0\xff\xff#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffa\0U\0U\0U\0U\0U\0U\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffa\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffU\0U\0U\0U\0U\0U\0a\0a\0a\0a\0a\0a\0a\0a\0a\0a\0\xff\xff\xff\xff\xff\xff\x84\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\xff\xff#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\xff\xff#\0#\0#\0#\0#\0#\0#\0#\0$\0\xff\xff\xff\xff$\0$\0$\0\xff\xff\xff\xff\xff\xff$\0$\0\xff\xff$\0$\0$\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\0\xff\xff$\0$\0$\0$\0$\0\xff\xff\xb9\0\xff\xff\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0\xb9\0$\0$\0\xb9\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0\xff\xff$\0%\0$\0\xff\xff%\0%\0%\0\xff\xff\xff\xff\xff\xff%\0%\0\xff\xff%\0%\0%\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff%\0\xff\xff%\0%\0%\0%\0%\0\xff\xff\xbf\0\xff\xff\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0\xbf\0%\0%\0\xbf\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0\xff\xff%\0\xff\xff%\0\xff\xff\xff\xff\xff\xff\xff\xff$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0\xff\xff$\0$\0$\0$\0$\0$\0$\0$\0\x8a\0\xff\xff\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x8a\0\x91\0\x8a\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\x91\0\xff\xff\x91\0\xff\xff%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0%\0&\0%\0%\0%\0%\0%\0%\0%\0%\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0\xff\xff\xff\xff\xff\xff\xff\xff&\0\xff\xff&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\0`\0\xff\xff\xff\xff`\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\0\xff\xff`\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0\xff\xff&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0\xff\xff&\0&\0&\0&\0&\0&\0&\0&\0.\0\xff\xff\xff\xff.\0.\0.\0\xff\xff\xff\xff\xff\xff.\0.\0\xff\xff.\0.\0.\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff.\0\xff\xff.\0.\0.\0.\0.\0\xff\xff\xff\xff\xff\xff\xff\xff/\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff.\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\xff\xff\xff\xff\xff\xff.\0/\0.\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0`\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\xff\xff/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\x000\0/\0/\0/\0/\0/\0/\0/\0/\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff0\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\xff\xff\xff\xff\xff\xff\xff\xff0\0\xff\xff0\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xa0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff0\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\xff\xff0\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x003\x000\x000\x000\x000\x000\x000\x000\x000\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff3\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\xff\xff\xff\xff\xff\xff\xff\xff3\0\xff\xff3\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\xac\0\xac\0\xac\0\xac\0\xac\0\xac\0\xac\0\xac\0\xac\0\xac\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xac\0\xac\0\xac\0\xac\0\xac\0\xac\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xac\0\xac\0\xac\0\xac\0\xac\0\xac\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff3\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\xff\xff3\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x004\x003\x003\x003\x003\x003\x003\x003\x003\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff4\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\xff\xff\xff\xff\xff\xff\xff\xff4\0\xff\xff4\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xb4\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff4\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\xff\xff4\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\xff\xff4\x004\x004\x004\x004\x004\x004\x004\0G\0]\0G\0\xff\xff]\0]\0]\0G\0\xff\xff\xff\xff]\0]\0\xff\xff]\0]\0]\0G\0G\0G\0G\0G\0G\0G\0G\0G\0G\0]\0\xff\xff]\0]\0]\0]\0]\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff_\0\xff\xff_\0_\0_\0_\0\xff\xff\xff\xff\xff\xff_\0_\0\xff\xff_\0_\0_\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffG\0\xff\xff]\0\xff\xff\xff\xff_\0G\0_\0_\0_\0_\0_\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffG\0\xff\xff\xff\xff\xff\xffG\0\xff\xffG\0\xff\xffj\0\xff\xffG\0j\0j\0j\0]\0\xff\xff]\0j\0j\0\xff\xffj\0j\0j\0_\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffj\0\xff\xffj\0j\0j\0j\0j\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffk\0\xff\xff\xff\xffk\0k\0k\0_\0\xff\xff_\0k\0k\0\xff\xffk\0k\0k\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffj\0\xff\xff\xff\xffk\0\xff\xffk\0k\0k\0k\0k\0\xff\xff\xff\xff\xff\xffl\0\xff\xff\xff\xffl\0l\0l\0\xff\xff\xff\xff\xff\xffl\0l\0\xff\xffl\0l\0l\0\xff\xff\xff\xffj\0\xff\xffj\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffl\0k\0l\0l\0l\0l\0l\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffm\0\xff\xff\xff\xffm\0m\0m\0\xff\xff\xff\xff\xff\xffm\0m\0\xff\xffm\0m\0m\0\xff\xff\xff\xff\xff\xffk\0\xff\xffk\0\xff\xff\xff\xffl\0\xff\xffm\0G\0m\0m\0m\0m\0m\0\xff\xff\xff\xff\xff\xffs\0\xff\xff\xff\xffs\0s\0s\0\xff\xff\xff\xff\xff\xffs\0s\0\xff\xffs\0s\0s\0\xff\xff\xff\xff\xff\xffl\0\xff\xffl\0\xff\xff\xff\xff\xff\xff\xff\xffs\0m\0s\0s\0s\0s\0s\0\xff\xff\xff\xff\xff\xff}\0\xff\xff\xff\xff}\0}\0}\0\xff\xff\xff\xff\xff\xff}\0}\0\xff\xff}\0}\0}\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffm\0\xff\xffm\0\xff\xff}\0s\0}\0}\0}\0}\0}\0\xff\xff\xff\xff\xff\xff\x80\0\xff\xff\xff\xff\x80\0\x80\0\x80\0\xff\xff\xff\xff\xff\xff\x80\0\x80\0\xff\xff\x80\0\x80\0\x80\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffs\0\xff\xffs\0\xff\xff\x80\0}\0\x80\0\x80\0\x80\0\x80\0\x80\0\xff\xff\xff\xff\xff\xff\x81\0\xff\xff\xff\xff\x81\0\x81\0\x81\0\xff\xff\xff\xff\xff\xff\x81\0\x81\0\xff\xff\x81\0\x81\0\x81\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff}\0\xff\xff}\0\xff\xff\x81\0\x80\0\x81\0\x81\0\x81\0\x81\0\x81\0\xff\xff\xff\xff\xff\xff\x82\0\xff\xff\xff\xff\x82\0\x82\0\x82\0\xff\xff\xff\xff\xff\xff\x82\0\x82\0\xff\xff\x82\0\x82\0\x82\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x80\0\xff\xff\x80\0\xff\xff\x82\0\x81\0\x82\0\x82\0\x82\0\x82\0\x82\0\xff\xff\xff\xff\xff\xff\x83\0\xff\xff\xff\xff\x83\0\x83\0\x83\0\xff\xff\xff\xff\xff\xff\x83\0\x83\0\xff\xff\x83\0\x83\0\x83\0\xff\xff\xff\xff\x92\0\xff\xff\x92\0\xff\xff\x81\0\xff\xff\x81\0\x92\0\x83\0\x82\0\x83\0\x83\0\x83\0\x83\0\x83\0\xff\xff\x92\0\x92\0\x92\0\x92\0\x92\0\x92\0\x92\0\x92\0\x92\0\x92\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x82\0\xff\xff\x82\0\xff\xff\xff\xff\x83\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa9\0\xff\xff\xff\xff\xa9\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x92\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x92\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa9\0\x83\0\xa9\0\x83\0\xff\xff\x92\0\xff\xff\xa9\0\xff\xff\x92\0\xff\xff\x92\0\xff\xff\xff\xff\xff\xff\x92\0\xa9\0\xa9\0\xa9\0\xa9\0\xa9\0\xa9\0\xa9\0\xa9\0\xa9\0\xa9\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa9\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa9\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa9\0\xff\xff\xff\xff\xff\xff\xa9\0\xff\xff\xa9\0\xff\xff\xff\xff\xff\xff\xa9\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa9\0",
  lex_base_code: "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\n\0$\0\f\0\0\0\0\0\0\0\x02\0\0\0\x1b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
  lex_backtrk_code: "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
  lex_default_code: "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
  lex_trans_code: "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0$\0$\0\0\0$\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\x01\0\x16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\x01\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
  lex_check_code: "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x18\0e\0\xa9\0\xb0\0e\0\xb1\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x18\0\xff\xffe\0\0\0f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\0a\0\xff\xff\xff\xff\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0a\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffa\0a\0a\0a\0a\0a\0a\0a\0a\0a\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffe\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff",
  lex_code: "\xff\x04\xff\xff\x05\xff\xff\x07\xff\x06\xff\xff\x03\xff\0\x04\x01\x05\xff\x07\xff\xff\x06\xff\x07\xff\xff\0\x04\x01\x05\x03\x06\x02\x07\xff\x01\xff\xff\0\x01\xff"
};

function token(lexbuf) {
  lexbuf.lex_mem = Caml_array.caml_make_vect(8, -1);
  var ___ocaml_lex_state = 0;
  while(true) {
    var __ocaml_lex_state = ___ocaml_lex_state;
    var __ocaml_lex_state$1 = Lexing.new_engine(__ocaml_lex_tables, __ocaml_lex_state, lexbuf);
    switch (__ocaml_lex_state$1) {
      case 0 :
          if (!escaped_newlines.contents) {
            throw [
                  $$Error$4,
                  /* Illegal_character */Block.__(0, [Lexing.lexeme_char(lexbuf, 0)]),
                  curr(lexbuf)
                ];
          }
          update_loc(lexbuf, void 0, 1, false, 0);
          return token(lexbuf);
      case 1 :
          update_loc(lexbuf, void 0, 1, false, 0);
          return /* EOL */100;
      case 2 :
          return token(lexbuf);
      case 3 :
          return /* UNDERSCORE */94;
      case 4 :
          return /* TILDE */89;
      case 5 :
          return /* LABEL */Block.__(10, [get_label_name(lexbuf)]);
      case 6 :
          prerr_warning(curr(lexbuf), /* Deprecated */Block.__(0, ["ISO-Latin1 characters in identifiers"]));
          return /* LABEL */Block.__(10, [get_label_name(lexbuf)]);
      case 7 :
          return /* QUESTION */76;
      case 8 :
          return /* OPTLABEL */Block.__(13, [get_label_name(lexbuf)]);
      case 9 :
          prerr_warning(curr(lexbuf), /* Deprecated */Block.__(0, ["ISO-Latin1 characters in identifiers"]));
          return /* OPTLABEL */Block.__(13, [get_label_name(lexbuf)]);
      case 10 :
          var s = Lexing.lexeme(lexbuf);
          try {
            return Hashtbl.find(keyword_table, s);
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              return /* LIDENT */Block.__(11, [s]);
            }
            throw exn;
          }
      case 11 :
          prerr_warning(curr(lexbuf), /* Deprecated */Block.__(0, ["ISO-Latin1 characters in identifiers"]));
          return /* LIDENT */Block.__(11, [Lexing.lexeme(lexbuf)]);
      case 12 :
          return /* UIDENT */Block.__(17, [Lexing.lexeme(lexbuf)]);
      case 13 :
          prerr_warning(curr(lexbuf), /* Deprecated */Block.__(0, ["ISO-Latin1 characters in identifiers"]));
          return /* UIDENT */Block.__(17, [Lexing.lexeme(lexbuf)]);
      case 14 :
          try {
            return /* INT */Block.__(7, [cvt_int_literal(Lexing.lexeme(lexbuf))]);
          }
          catch (raw_exn){
            var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn$1[0] === Caml_builtin_exceptions.failure) {
              throw [
                    $$Error$4,
                    /* Literal_overflow */Block.__(5, ["int"]),
                    curr(lexbuf)
                  ];
            }
            throw exn$1;
          }
      case 15 :
          return /* FLOAT */Block.__(1, [remove_underscores(Lexing.lexeme(lexbuf))]);
      case 16 :
          try {
            return /* INT32 */Block.__(8, [cvt_int32_literal(Lexing.lexeme(lexbuf))]);
          }
          catch (raw_exn$1){
            var exn$2 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
            if (exn$2[0] === Caml_builtin_exceptions.failure) {
              throw [
                    $$Error$4,
                    /* Literal_overflow */Block.__(5, ["int32"]),
                    curr(lexbuf)
                  ];
            }
            throw exn$2;
          }
      case 17 :
          try {
            return /* INT64 */Block.__(9, [cvt_int64_literal(Lexing.lexeme(lexbuf))]);
          }
          catch (raw_exn$2){
            var exn$3 = Caml_js_exceptions.internalToOCamlException(raw_exn$2);
            if (exn$3[0] === Caml_builtin_exceptions.failure) {
              throw [
                    $$Error$4,
                    /* Literal_overflow */Block.__(5, ["int64"]),
                    curr(lexbuf)
                  ];
            }
            throw exn$3;
          }
      case 18 :
          try {
            return /* NATIVEINT */Block.__(12, [cvt_nativeint_literal(Lexing.lexeme(lexbuf))]);
          }
          catch (raw_exn$3){
            var exn$4 = Caml_js_exceptions.internalToOCamlException(raw_exn$3);
            if (exn$4[0] === Caml_builtin_exceptions.failure) {
              throw [
                    $$Error$4,
                    /* Literal_overflow */Block.__(5, ["nativeint"]),
                    curr(lexbuf)
                  ];
            }
            throw exn$4;
          }
      case 19 :
          reset_string_buffer(void 0);
          is_in_string.contents = true;
          var string_start = lexbuf.lex_start_p;
          string_start_loc.contents = curr(lexbuf);
          string(lexbuf);
          is_in_string.contents = false;
          lexbuf.lex_start_p = string_start;
          return /* STRING */Block.__(16, [/* tuple */[
                      get_stored_string(void 0),
                      void 0
                    ]]);
      case 20 :
          reset_string_buffer(void 0);
          var delim = Lexing.lexeme(lexbuf);
          var delim$1 = $$String.sub(delim, 1, delim.length - 2 | 0);
          is_in_string.contents = true;
          var string_start$1 = lexbuf.lex_start_p;
          string_start_loc.contents = curr(lexbuf);
          __ocaml_lex_quoted_string_rec(delim$1, lexbuf, 183);
          is_in_string.contents = false;
          lexbuf.lex_start_p = string_start$1;
          return /* STRING */Block.__(16, [/* tuple */[
                      get_stored_string(void 0),
                      delim$1
                    ]]);
      case 21 :
          update_loc(lexbuf, void 0, 1, false, 1);
          return /* CHAR */Block.__(0, [Lexing.lexeme_char(lexbuf, 1)]);
      case 22 :
          return /* CHAR */Block.__(0, [Lexing.lexeme_char(lexbuf, 1)]);
      case 23 :
          return /* CHAR */Block.__(0, [char_for_backslash(Lexing.lexeme_char(lexbuf, 2))]);
      case 24 :
          return /* CHAR */Block.__(0, [char_for_decimal_code(lexbuf, 2)]);
      case 25 :
          return /* CHAR */Block.__(0, [char_for_hexadecimal_code(lexbuf, 3)]);
      case 26 :
          var l = Lexing.lexeme(lexbuf);
          var esc = $$String.sub(l, 1, l.length - 1 | 0);
          throw [
                $$Error$4,
                /* Illegal_escape */Block.__(1, [esc]),
                curr(lexbuf)
              ];
      case 27 :
          var match = with_comment_buffer(comment, lexbuf);
          return /* COMMENT */Block.__(18, [/* tuple */[
                      match[0],
                      match[1]
                    ]]);
      case 28 :
          var match$1 = with_comment_buffer(comment, lexbuf);
          return /* DOCSTRING */Block.__(19, [docstring(match$1[0], match$1[1])]);
      case 29 :
          var stars = Lexing.sub_lexeme(lexbuf, lexbuf.lex_start_pos, lexbuf.lex_curr_pos);
          var match$2 = with_comment_buffer((function(stars){
              return function (lexbuf) {
                store_string("*" + stars);
                return __ocaml_lex_comment_rec(lexbuf, 132);
              }
              }(stars)), lexbuf);
          return /* COMMENT */Block.__(18, [/* tuple */[
                      match$2[0],
                      match$2[1]
                    ]]);
      case 30 :
          if (print_warnings.contents) {
            prerr_warning(curr(lexbuf), /* Comment_start */0);
          }
          var match$3 = with_comment_buffer(comment, lexbuf);
          return /* COMMENT */Block.__(18, [/* tuple */[
                      match$3[0],
                      match$3[1]
                    ]]);
      case 31 :
          var stars$1 = Lexing.sub_lexeme(lexbuf, lexbuf.lex_start_pos, lexbuf.lex_curr_pos - 2 | 0);
          return /* COMMENT */Block.__(18, [/* tuple */[
                      stars$1,
                      curr(lexbuf)
                    ]]);
      case 32 :
          var loc = curr(lexbuf);
          prerr_warning(loc, /* Comment_not_end */1);
          lexbuf.lex_curr_pos = lexbuf.lex_curr_pos - 1 | 0;
          var curpos = lexbuf.lex_curr_p;
          lexbuf.lex_curr_p = {
            pos_fname: curpos.pos_fname,
            pos_lnum: curpos.pos_lnum,
            pos_bol: curpos.pos_bol,
            pos_cnum: curpos.pos_cnum - 1 | 0
          };
          return /* STAR */86;
      case 33 :
          var num = Lexing.sub_lexeme(lexbuf, Caml_array.caml_array_get(lexbuf.lex_mem, 0), Caml_array.caml_array_get(lexbuf.lex_mem, 1));
          var name = Lexing.sub_lexeme_opt(lexbuf, Caml_array.caml_array_get(lexbuf.lex_mem, 3), Caml_array.caml_array_get(lexbuf.lex_mem, 2));
          update_loc(lexbuf, name, Caml_format.caml_int_of_string(num), true, 0);
          return token(lexbuf);
      case 34 :
          return /* SHARP */84;
      case 35 :
          return /* AMPERSAND */1;
      case 36 :
          return /* AMPERAMPER */0;
      case 37 :
          return /* BACKQUOTE */5;
      case 38 :
          return /* QUOTE */77;
      case 39 :
          return /* LPAREN */54;
      case 40 :
          return /* RPAREN */81;
      case 41 :
          return /* STAR */86;
      case 42 :
          return /* COMMA */16;
      case 43 :
          return /* MINUSGREATER */62;
      case 44 :
          return /* DOT */20;
      case 45 :
          return /* DOTDOT */21;
      case 46 :
          return /* COLON */12;
      case 47 :
          return /* COLONCOLON */13;
      case 48 :
          return /* COLONEQUAL */14;
      case 49 :
          return /* COLONGREATER */15;
      case 50 :
          return /* SEMI */82;
      case 51 :
          return /* SEMISEMI */83;
      case 52 :
          return /* LESS */51;
      case 53 :
          return /* LESSMINUS */52;
      case 54 :
          return /* EQUAL */26;
      case 55 :
          return /* LBRACKET */45;
      case 56 :
          return /* LBRACKETBAR */46;
      case 57 :
          return /* LBRACKETLESS */47;
      case 58 :
          return /* LBRACKETGREATER */48;
      case 59 :
          return /* RBRACKET */79;
      case 60 :
          return /* LBRACE */43;
      case 61 :
          return /* LBRACELESS */44;
      case 62 :
          return /* BAR */7;
      case 63 :
          return /* BARBAR */8;
      case 64 :
          return /* BARRBRACKET */9;
      case 65 :
          return /* GREATER */34;
      case 66 :
          return /* GREATERRBRACKET */36;
      case 67 :
          return /* RBRACE */78;
      case 68 :
          return /* GREATERRBRACE */35;
      case 69 :
          return /* LBRACKETAT */55;
      case 70 :
          return /* LBRACKETPERCENT */49;
      case 71 :
          return /* LBRACKETPERCENTPERCENT */50;
      case 72 :
          return /* LBRACKETATAT */56;
      case 73 :
          return /* LBRACKETATATAT */57;
      case 74 :
          return /* BANG */6;
      case 75 :
          return /* INFIXOP0 */Block.__(2, ["!="]);
      case 76 :
          return /* PLUS */72;
      case 77 :
          return /* PLUSDOT */73;
      case 78 :
          return /* PLUSEQ */74;
      case 79 :
          return /* MINUS */60;
      case 80 :
          return /* MINUSDOT */61;
      case 81 :
      case 82 :
          return /* PREFIXOP */Block.__(14, [Lexing.lexeme(lexbuf)]);
      case 83 :
          return /* INFIXOP0 */Block.__(2, [Lexing.lexeme(lexbuf)]);
      case 84 :
          return /* INFIXOP1 */Block.__(3, [Lexing.lexeme(lexbuf)]);
      case 85 :
          return /* INFIXOP2 */Block.__(4, [Lexing.lexeme(lexbuf)]);
      case 86 :
          return /* INFIXOP4 */Block.__(6, [Lexing.lexeme(lexbuf)]);
      case 87 :
          return /* PERCENT */71;
      case 88 :
          return /* INFIXOP3 */Block.__(5, [Lexing.lexeme(lexbuf)]);
      case 89 :
          return /* SHARPOP */Block.__(15, [Lexing.lexeme(lexbuf)]);
      case 90 :
          if (if_then_else.contents === /* Dir_out */2) {
            return /* EOF */25;
          }
          if (if_then_else.contents === /* Dir_if_true */0) {
            throw [
                  $$Error$4,
                  /* Unterminated_if */2,
                  curr(lexbuf)
                ];
          }
          throw [
                $$Error$4,
                /* Unterminated_else */3,
                curr(lexbuf)
              ];
      case 91 :
          throw [
                $$Error$4,
                /* Illegal_character */Block.__(0, [Lexing.lexeme_char(lexbuf, 0)]),
                curr(lexbuf)
              ];
      default:
        Curry._1(lexbuf.refill_buff, lexbuf);
        ___ocaml_lex_state = __ocaml_lex_state$1;
        continue ;
    }
  };
}

function __ocaml_lex_quoted_string_rec(delim, lexbuf, ___ocaml_lex_state) {
  while(true) {
    var __ocaml_lex_state = ___ocaml_lex_state;
    var __ocaml_lex_state$1 = Lexing.engine(__ocaml_lex_tables, __ocaml_lex_state, lexbuf);
    switch (__ocaml_lex_state$1) {
      case 0 :
          update_loc(lexbuf, void 0, 1, false, 0);
          store_string(Lexing.lexeme(lexbuf));
          ___ocaml_lex_state = 183;
          continue ;
      case 1 :
          is_in_string.contents = false;
          throw [
                $$Error$4,
                /* Unterminated_string */0,
                string_start_loc.contents
              ];
      case 2 :
          var edelim = Lexing.lexeme(lexbuf);
          var edelim$1 = $$String.sub(edelim, 1, edelim.length - 2 | 0);
          if (delim === edelim$1) {
            return ;
          }
          store_string(Lexing.lexeme(lexbuf));
          ___ocaml_lex_state = 183;
          continue ;
      case 3 :
          store_string_char(Lexing.lexeme_char(lexbuf, 0));
          ___ocaml_lex_state = 183;
          continue ;
      default:
        Curry._1(lexbuf.refill_buff, lexbuf);
        ___ocaml_lex_state = __ocaml_lex_state$1;
        continue ;
    }
  };
}

function __ocaml_lex_comment_rec(lexbuf, ___ocaml_lex_state) {
  while(true) {
    var __ocaml_lex_state = ___ocaml_lex_state;
    var __ocaml_lex_state$1 = Lexing.engine(__ocaml_lex_tables, __ocaml_lex_state, lexbuf);
    switch (__ocaml_lex_state$1) {
      case 0 :
          comment_start_loc.contents = /* :: */[
            curr(lexbuf),
            comment_start_loc.contents
          ];
          store_string(Lexing.lexeme(lexbuf));
          ___ocaml_lex_state = 132;
          continue ;
      case 1 :
          var match = comment_start_loc.contents;
          if (!match) {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  /* tuple */[
                    "lexer.mll",
                    989,
                    16
                  ]
                ];
          }
          var l = match[1];
          if (l) {
            comment_start_loc.contents = l;
            store_string(Lexing.lexeme(lexbuf));
            ___ocaml_lex_state = 132;
            continue ;
          } else {
            comment_start_loc.contents = /* [] */0;
            return curr(lexbuf);
          }
      case 2 :
          string_start_loc.contents = curr(lexbuf);
          store_string_char(/* "\"" */34);
          is_in_string.contents = true;
          try {
            string(lexbuf);
          }
          catch (raw_exn){
            var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn[0] !== $$Error$4) {
              throw exn;
            }
            var match$1 = exn[1];
            if (typeof match$1 !== "number") {
              throw exn;
            }
            if (match$1 !== 0) {
              throw exn;
            }
            var match$2 = comment_start_loc.contents;
            if (!match$2) {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    /* tuple */[
                      "lexer.mll",
                      1003,
                      18
                    ]
                  ];
            }
            var start = List.hd(List.rev(comment_start_loc.contents));
            comment_start_loc.contents = /* [] */0;
            throw [
                  $$Error$4,
                  /* Unterminated_string_in_comment */Block.__(3, [
                      start,
                      exn[2]
                    ]),
                  match$2[0]
                ];
          }
          is_in_string.contents = false;
          store_string_char(/* "\"" */34);
          ___ocaml_lex_state = 132;
          continue ;
      case 3 :
          var delim = Lexing.lexeme(lexbuf);
          var delim$1 = $$String.sub(delim, 1, delim.length - 2 | 0);
          string_start_loc.contents = curr(lexbuf);
          store_string(Lexing.lexeme(lexbuf));
          is_in_string.contents = true;
          try {
            __ocaml_lex_quoted_string_rec(delim$1, lexbuf, 183);
          }
          catch (raw_exn$1){
            var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
            if (exn$1[0] !== $$Error$4) {
              throw exn$1;
            }
            var match$3 = exn$1[1];
            if (typeof match$3 !== "number") {
              throw exn$1;
            }
            if (match$3 !== 0) {
              throw exn$1;
            }
            var match$4 = comment_start_loc.contents;
            if (!match$4) {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    /* tuple */[
                      "lexer.mll",
                      1023,
                      18
                    ]
                  ];
            }
            var start$1 = List.hd(List.rev(comment_start_loc.contents));
            comment_start_loc.contents = /* [] */0;
            throw [
                  $$Error$4,
                  /* Unterminated_string_in_comment */Block.__(3, [
                      start$1,
                      exn$1[2]
                    ]),
                  match$4[0]
                ];
          }
          is_in_string.contents = false;
          store_string_char(/* "|" */124);
          store_string(delim$1);
          store_string_char(/* "}" */125);
          ___ocaml_lex_state = 132;
          continue ;
      case 5 :
          update_loc(lexbuf, void 0, 1, false, 1);
          store_string(Lexing.lexeme(lexbuf));
          ___ocaml_lex_state = 132;
          continue ;
      case 10 :
          var match$5 = comment_start_loc.contents;
          if (!match$5) {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  /* tuple */[
                    "lexer.mll",
                    1053,
                    16
                  ]
                ];
          }
          var start$2 = List.hd(List.rev(comment_start_loc.contents));
          comment_start_loc.contents = /* [] */0;
          throw [
                $$Error$4,
                /* Unterminated_comment */Block.__(2, [start$2]),
                match$5[0]
              ];
      case 11 :
          update_loc(lexbuf, void 0, 1, false, 0);
          store_string(Lexing.lexeme(lexbuf));
          ___ocaml_lex_state = 132;
          continue ;
      case 4 :
      case 6 :
      case 7 :
      case 8 :
      case 9 :
      case 12 :
          store_string(Lexing.lexeme(lexbuf));
          ___ocaml_lex_state = 132;
          continue ;
      default:
        Curry._1(lexbuf.refill_buff, lexbuf);
        ___ocaml_lex_state = __ocaml_lex_state$1;
        continue ;
    }
  };
}

function comment(lexbuf) {
  return __ocaml_lex_comment_rec(lexbuf, 132);
}

function string(lexbuf) {
  lexbuf.lex_mem = Caml_array.caml_make_vect(2, -1);
  var ___ocaml_lex_state = 164;
  while(true) {
    var __ocaml_lex_state = ___ocaml_lex_state;
    var __ocaml_lex_state$1 = Lexing.new_engine(__ocaml_lex_tables, __ocaml_lex_state, lexbuf);
    switch (__ocaml_lex_state$1) {
      case 0 :
          return ;
      case 1 :
          var space = Lexing.sub_lexeme(lexbuf, Caml_array.caml_array_get(lexbuf.lex_mem, 0), lexbuf.lex_curr_pos);
          update_loc(lexbuf, void 0, 1, false, space.length);
          return string(lexbuf);
      case 2 :
          store_string_char(char_for_backslash(Lexing.lexeme_char(lexbuf, 1)));
          return string(lexbuf);
      case 3 :
          store_string_char(char_for_decimal_code(lexbuf, 1));
          return string(lexbuf);
      case 4 :
          store_string_char(char_for_hexadecimal_code(lexbuf, 2));
          return string(lexbuf);
      case 5 :
          if (comment_start_loc.contents !== /* [] */0) {
            return string(lexbuf);
          }
          var loc = curr(lexbuf);
          prerr_warning(loc, /* Illegal_backslash */7);
          store_string_char(Lexing.lexeme_char(lexbuf, 0));
          store_string_char(Lexing.lexeme_char(lexbuf, 1));
          return string(lexbuf);
      case 6 :
          if (comment_start_loc.contents === /* [] */0) {
            prerr_warning(curr(lexbuf), /* Eol_in_string */14);
          }
          update_loc(lexbuf, void 0, 1, false, 0);
          store_string(Lexing.lexeme(lexbuf));
          return string(lexbuf);
      case 7 :
          is_in_string.contents = false;
          throw [
                $$Error$4,
                /* Unterminated_string */0,
                string_start_loc.contents
              ];
      case 8 :
          store_string_char(Lexing.lexeme_char(lexbuf, 0));
          return string(lexbuf);
      default:
        Curry._1(lexbuf.refill_buff, lexbuf);
        ___ocaml_lex_state = __ocaml_lex_state$1;
        continue ;
    }
  };
}

function at_bol(lexbuf) {
  var pos = lexbuf.lex_start_p;
  return pos.pos_cnum === pos.pos_bol;
}

function token_with_comments(lexbuf) {
  var match = preprocessor.contents;
  if (match !== void 0) {
    return Curry._2(match[1], token, lexbuf);
  } else {
    return token(lexbuf);
  }
}

function token$1(lexbuf) {
  var post_pos = lexbuf.lex_curr_p;
  var attach = function (lines, docs, pre_pos) {
    if (typeof docs === "number") {
      return ;
    }
    if (docs.tag) {
      var b = docs[2];
      var f = docs[1];
      var a = docs[0];
      if (lines >= 2) {
        set_post_docstrings(post_pos, List.rev(a));
        set_post_extra_docstrings(post_pos, List.rev_append(f, List.rev(b)));
        set_floating_docstrings(pre_pos, List.rev_append(f, List.rev(b)));
        return set_pre_extra_docstrings(pre_pos, List.rev(a));
      } else {
        set_post_docstrings(post_pos, List.rev(a));
        set_post_extra_docstrings(post_pos, List.rev_append(f, List.rev(b)));
        set_floating_docstrings(pre_pos, List.rev(f));
        set_pre_extra_docstrings(pre_pos, List.rev(a));
        return set_pre_docstrings(pre_pos, b);
      }
    } else {
      var a$1 = docs[0];
      if (lines >= 2) {
        set_post_docstrings(post_pos, List.rev(a$1));
        return set_pre_extra_docstrings(pre_pos, List.rev(a$1));
      } else {
        set_post_docstrings(post_pos, List.rev(a$1));
        return set_pre_docstrings(pre_pos, a$1);
      }
    }
  };
  var loop = function (_lines, _docs, lexbuf) {
    while(true) {
      var docs = _docs;
      var lines = _lines;
      var tok = token_with_comments(lexbuf);
      if (typeof tok === "number") {
        switch (tok) {
          case /* SHARP */84 :
              if (at_bol(lexbuf)) {
                var cont = (function(lines,docs){
                return function cont(lexbuf) {
                  return loop(lines, docs, lexbuf);
                }
                }(lines,docs));
                var look_ahead = function (token) {
                  sharp_look_ahead.contents = token;
                  return /* SHARP */84;
                };
                var if_then_else$1 = if_then_else.contents;
                var match = token_with_comments(lexbuf);
                if (typeof match === "number") {
                  switch (match) {
                    case /* ELSE */23 :
                        if (if_then_else$1 !== 0) {
                          throw [
                                $$Error$4,
                                /* Unexpected_directive */6,
                                curr(lexbuf)
                              ];
                        }
                        break;
                    case /* END */24 :
                        if (if_then_else$1 >= 2) {
                          throw [
                                $$Error$4,
                                /* Unexpected_directive */6,
                                curr(lexbuf)
                              ];
                        }
                        if_then_else.contents = /* Dir_out */2;
                        return Curry._1(cont, lexbuf);
                    case /* IF */37 :
                        if (if_then_else$1 < 2) {
                          throw [
                                $$Error$4,
                                /* Unexpected_directive */6,
                                curr(lexbuf)
                              ];
                        }
                        if (directive_parse(token_with_comments, lexbuf)) {
                          if_then_else.contents = /* Dir_if_true */0;
                          return Curry._1(cont, lexbuf);
                        } else {
                          var _param;
                          while(true) {
                            var token = token_with_comments(lexbuf);
                            if (token === /* EOF */25) {
                              throw [
                                    $$Error$4,
                                    /* Unterminated_if */2,
                                    curr(lexbuf)
                                  ];
                            }
                            if (token === /* SHARP */84 && at_bol(lexbuf)) {
                              var token$1 = token_with_comments(lexbuf);
                              if (typeof token$1 === "number") {
                                var switcher = token$1 - 23 | 0;
                                if (switcher === 0 || switcher === 1) {
                                  if (switcher !== 0) {
                                    if_then_else.contents = /* Dir_out */2;
                                    return Curry._1(cont, lexbuf);
                                  } else {
                                    if_then_else.contents = /* Dir_if_false */1;
                                    return Curry._1(cont, lexbuf);
                                  }
                                }
                                if (switcher === 14) {
                                  throw [
                                        $$Error$4,
                                        /* Unexpected_directive */6,
                                        curr(lexbuf)
                                      ];
                                }
                                
                              }
                              if (is_elif(token$1) && directive_parse(token_with_comments, lexbuf)) {
                                if_then_else.contents = /* Dir_if_true */0;
                                return Curry._1(cont, lexbuf);
                              } else {
                                _param = void 0;
                                continue ;
                              }
                            } else {
                              _param = void 0;
                              continue ;
                            }
                          };
                        }
                    default:
                      return Curry._1(look_ahead, match);
                  }
                } else {
                  if (match.tag !== /* LIDENT */11) {
                    return Curry._1(look_ahead, match);
                  }
                  if (match[0] !== "elif") {
                    return Curry._1(look_ahead, match);
                  }
                  if (if_then_else$1 !== 0) {
                    throw [
                          $$Error$4,
                          /* Unexpected_directive */6,
                          curr(lexbuf)
                        ];
                  }
                  
                }
                if (if_then_else$1 !== 0) {
                  return Curry._1(look_ahead, match);
                }
                var _else_seen = match === /* ELSE */23;
                while(true) {
                  var else_seen = _else_seen;
                  var token$2 = token_with_comments(lexbuf);
                  if (token$2 === /* EOF */25) {
                    throw [
                          $$Error$4,
                          /* Unterminated_else */3,
                          curr(lexbuf)
                        ];
                  }
                  if (token$2 === /* SHARP */84 && at_bol(lexbuf)) {
                    var token$3 = token_with_comments(lexbuf);
                    if (typeof token$3 === "number") {
                      var switcher$1 = token$3 - 23 | 0;
                      if (switcher$1 === 0 || switcher$1 === 1) {
                        if (switcher$1 !== 0) {
                          if_then_else.contents = /* Dir_out */2;
                          return Curry._1(cont, lexbuf);
                        } else {
                          if (else_seen) {
                            throw [
                                  $$Error$4,
                                  /* Unexpected_directive */6,
                                  curr(lexbuf)
                                ];
                          }
                          _else_seen = true;
                          continue ;
                        }
                      } else if (switcher$1 === 14) {
                        throw [
                              $$Error$4,
                              /* Unexpected_directive */6,
                              curr(lexbuf)
                            ];
                      }
                      
                    }
                    if (else_seen && is_elif(token$3)) {
                      throw [
                            $$Error$4,
                            /* Unexpected_directive */6,
                            curr(lexbuf)
                          ];
                    }
                    continue ;
                  } else {
                    continue ;
                  }
                };
              }
              break;
          case /* EOL */100 :
              var lines$prime = lines !== 0 ? /* BlankLine */2 : /* NewLine */1;
              _lines = lines$prime;
              continue ;
          default:
            
        }
      } else {
        switch (tok.tag | 0) {
          case /* COMMENT */18 :
              var match$1 = tok[0];
              add_comment(/* tuple */[
                    match$1[0],
                    match$1[1]
                  ]);
              var lines$prime$1 = lines >= 2 ? /* BlankLine */2 : /* NoLine */0;
              _lines = lines$prime$1;
              continue ;
          case /* DOCSTRING */19 :
              var doc = tok[0];
              add_docstring_comment(doc);
              var docs$prime;
              if (typeof docs === "number") {
                docs$prime = lines >= 2 ? /* Before */Block.__(1, [
                      /* [] */0,
                      /* [] */0,
                      /* :: */[
                        doc,
                        /* [] */0
                      ]
                    ]) : /* After */Block.__(0, [/* :: */[
                        doc,
                        /* [] */0
                      ]]);
              } else if (docs.tag) {
                var b = docs[2];
                var f = docs[1];
                var a = docs[0];
                docs$prime = lines >= 2 ? /* Before */Block.__(1, [
                      a,
                      Pervasives.$at(b, f),
                      /* :: */[
                        doc,
                        /* [] */0
                      ]
                    ]) : /* Before */Block.__(1, [
                      a,
                      f,
                      /* :: */[
                        doc,
                        b
                      ]
                    ]);
              } else {
                var a$1 = docs[0];
                docs$prime = lines >= 2 ? /* Before */Block.__(1, [
                      a$1,
                      /* [] */0,
                      /* :: */[
                        doc,
                        /* [] */0
                      ]
                    ]) : /* After */Block.__(0, [/* :: */[
                        doc,
                        a$1
                      ]]);
              }
              _docs = docs$prime;
              _lines = /* NoLine */0;
              continue ;
          default:
            
        }
      }
      attach(lines, docs, lexbuf.lex_start_p);
      return tok;
    };
  };
  var match = sharp_look_ahead.contents;
  if (match !== void 0) {
    sharp_look_ahead.contents = void 0;
    return match;
  } else {
    return loop(/* NoLine */0, /* Initial */0, lexbuf);
  }
}

function init$1(param) {
  sharp_look_ahead.contents = void 0;
  if_then_else.contents = /* Dir_out */2;
  is_in_string.contents = false;
  comment_start_loc.contents = /* [] */0;
  comment_list.contents = /* [] */0;
  var match = preprocessor.contents;
  if (match !== void 0) {
    return Curry._1(match[0], void 0);
  }
  
}

function skip_phrase(lexbuf) {
  while(true) {
    try {
      var match = token$1(lexbuf);
      if (typeof match === "number" && !(match !== 25 && match !== 83)) {
        return ;
      } else {
        return skip_phrase(lexbuf);
      }
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn[0] !== $$Error$4) {
        throw exn;
      }
      var tmp = exn[1];
      if (typeof tmp === "number") {
        if (tmp !== /* Unterminated_string */0) {
          throw exn;
        }
        continue ;
      } else {
        switch (tmp.tag | 0) {
          case /* Illegal_character */0 :
          case /* Unterminated_comment */2 :
          case /* Unterminated_string_in_comment */3 :
              continue ;
          default:
            throw exn;
        }
      }
    }
  };
}

function maybe_skip_phrase(lexbuf) {
  if (Parsing.is_current_lookahead(/* SEMISEMI */83) || Parsing.is_current_lookahead(/* EOF */25)) {
    return ;
  } else {
    return skip_phrase(lexbuf);
  }
}

function wrap$1(parsing_fun, lexbuf) {
  try {
    init(void 0);
    init$1(void 0);
    var ast = Curry._2(parsing_fun, token$1, lexbuf);
    Parsing.clear_parser(void 0);
    warn_bad_docstrings(void 0);
    return ast;
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err[0] === $$Error$4) {
      var tmp = err[1];
      if (typeof tmp === "number") {
        throw err;
      }
      if (tmp.tag) {
        throw err;
      }
      if (input_name.contents !== "//toplevel//") {
        throw err;
      }
      skip_phrase(lexbuf);
      throw err;
    } else if (err[0] === $$Error$3) {
      if (input_name.contents !== "//toplevel//") {
        throw err;
      }
      maybe_skip_phrase(lexbuf);
      throw err;
    } else if (err !== Parsing.Parse_error && err !== Escape_error) {
      throw err;
    }
    var loc = curr(lexbuf);
    if (input_name.contents === "//toplevel//") {
      maybe_skip_phrase(lexbuf);
    }
    throw [
          $$Error$3,
          /* Other */Block.__(5, [loc])
        ];
  }
}

function iter_pattern_desc(f, param) {
  if (typeof param === "number") {
    return ;
  }
  switch (param.tag | 0) {
    case /* Tpat_construct */4 :
        return List.iter(f, param[2]);
    case /* Tpat_variant */5 :
        return may(f, param[1]);
    case /* Tpat_record */6 :
        return List.iter((function (param) {
                      return Curry._1(f, param[2]);
                    }), param[0]);
    case /* Tpat_tuple */3 :
    case /* Tpat_array */7 :
        return List.iter(f, param[0]);
    case /* Tpat_or */8 :
        Curry._1(f, param[0]);
        return Curry._1(f, param[1]);
    case /* Tpat_alias */1 :
    case /* Tpat_lazy */9 :
        return Curry._1(f, param[0]);
    default:
      return ;
  }
}

function map_pattern_desc(f, d) {
  if (typeof d === "number") {
    return d;
  }
  switch (d.tag | 0) {
    case /* Tpat_alias */1 :
        return /* Tpat_alias */Block.__(1, [
                  Curry._1(f, d[0]),
                  d[1],
                  d[2]
                ]);
    case /* Tpat_tuple */3 :
        return /* Tpat_tuple */Block.__(3, [List.map(f, d[0])]);
    case /* Tpat_construct */4 :
        return /* Tpat_construct */Block.__(4, [
                  d[0],
                  d[1],
                  List.map(f, d[2])
                ]);
    case /* Tpat_variant */5 :
        var match = d[1];
        if (match !== void 0) {
          return /* Tpat_variant */Block.__(5, [
                    d[0],
                    Curry._1(f, match),
                    d[2]
                  ]);
        } else {
          return d;
        }
    case /* Tpat_record */6 :
        return /* Tpat_record */Block.__(6, [
                  List.map((function (param) {
                          return /* tuple */[
                                  param[0],
                                  param[1],
                                  Curry._1(f, param[2])
                                ];
                        }), d[0]),
                  d[1]
                ]);
    case /* Tpat_array */7 :
        return /* Tpat_array */Block.__(7, [List.map(f, d[0])]);
    case /* Tpat_or */8 :
        return /* Tpat_or */Block.__(8, [
                  Curry._1(f, d[0]),
                  Curry._1(f, d[1]),
                  d[2]
                ]);
    case /* Tpat_lazy */9 :
        return /* Tpat_lazy */Block.__(9, [Curry._1(f, d[0])]);
    default:
      return d;
  }
}

var idents = {
  contents: /* [] */0
};

function bound_idents(_pat) {
  while(true) {
    var pat = _pat;
    var d = pat.pat_desc;
    if (typeof d === "number") {
      return iter_pattern_desc(bound_idents, d);
    }
    switch (d.tag | 0) {
      case /* Tpat_var */0 :
          idents.contents = /* :: */[
            /* tuple */[
              d[0],
              d[1]
            ],
            idents.contents
          ];
          return ;
      case /* Tpat_alias */1 :
          bound_idents(d[0]);
          idents.contents = /* :: */[
            /* tuple */[
              d[1],
              d[2]
            ],
            idents.contents
          ];
          return ;
      case /* Tpat_or */8 :
          _pat = d[0];
          continue ;
      default:
        return iter_pattern_desc(bound_idents, d);
    }
  };
}

function pat_bound_idents(pat) {
  idents.contents = /* [] */0;
  bound_idents(pat);
  var res = idents.contents;
  idents.contents = /* [] */0;
  return res;
}

function rev_let_bound_idents_with_loc(bindings) {
  idents.contents = /* [] */0;
  List.iter((function (vb) {
          return bound_idents(vb.vb_pat);
        }), bindings);
  var res = idents.contents;
  idents.contents = /* [] */0;
  return res;
}

function let_bound_idents(pat) {
  return List.map((function (prim) {
                return prim[0];
              }), List.rev(rev_let_bound_idents_with_loc(pat)));
}

function alpha_pat(env, p) {
  var d = p.pat_desc;
  if (typeof d !== "number") {
    switch (d.tag | 0) {
      case /* Tpat_var */0 :
          var tmp;
          try {
            tmp = /* Tpat_var */Block.__(0, [
                List.assoc(d[0], env),
                d[1]
              ]);
          }
          catch (exn){
            if (exn !== Caml_builtin_exceptions.not_found) {
              throw exn;
            }
            tmp = /* Tpat_any */0;
          }
          return {
                  pat_desc: tmp,
                  pat_loc: p.pat_loc,
                  pat_extra: p.pat_extra,
                  pat_type: p.pat_type,
                  pat_env: p.pat_env,
                  pat_attributes: p.pat_attributes
                };
      case /* Tpat_alias */1 :
          var new_p = alpha_pat(env, d[0]);
          try {
            return {
                    pat_desc: /* Tpat_alias */Block.__(1, [
                        new_p,
                        List.assoc(d[1], env),
                        d[2]
                      ]),
                    pat_loc: p.pat_loc,
                    pat_extra: p.pat_extra,
                    pat_type: p.pat_type,
                    pat_env: p.pat_env,
                    pat_attributes: p.pat_attributes
                  };
          }
          catch (exn$1){
            if (exn$1 === Caml_builtin_exceptions.not_found) {
              return new_p;
            }
            throw exn$1;
          }
      default:
        
    }
  }
  return {
          pat_desc: map_pattern_desc((function (param) {
                  return alpha_pat(env, param);
                }), d),
          pat_loc: p.pat_loc,
          pat_extra: p.pat_extra,
          pat_type: p.pat_type,
          pat_env: p.pat_env,
          pat_attributes: p.pat_attributes
        };
}

function enter_structure(t) {
  return t;
}

function enter_value_description(t) {
  return t;
}

function enter_type_declaration(t) {
  return t;
}

function enter_type_extension(t) {
  return t;
}

function enter_extension_constructor(t) {
  return t;
}

function enter_pattern(t) {
  return t;
}

function enter_expression(t) {
  return t;
}

function enter_package_type(t) {
  return t;
}

function enter_signature(t) {
  return t;
}

function enter_signature_item(t) {
  return t;
}

function enter_module_type_declaration(t) {
  return t;
}

function enter_module_type(t) {
  return t;
}

function enter_module_expr(t) {
  return t;
}

function enter_with_constraint(t) {
  return t;
}

function enter_class_expr(t) {
  return t;
}

function enter_class_signature(t) {
  return t;
}

function enter_class_declaration(t) {
  return t;
}

function enter_class_description(t) {
  return t;
}

function enter_class_type_declaration(t) {
  return t;
}

function enter_class_type(t) {
  return t;
}

function enter_class_type_field(t) {
  return t;
}

function enter_core_type(t) {
  return t;
}

function enter_class_structure(t) {
  return t;
}

function enter_class_field(t) {
  return t;
}

function enter_structure_item(t) {
  return t;
}

function leave_value_description(t) {
  return t;
}

function leave_type_declaration(t) {
  return t;
}

function leave_type_extension(t) {
  return t;
}

function leave_extension_constructor(t) {
  return t;
}

function leave_package_type(t) {
  return t;
}

function leave_module_type_declaration(t) {
  return t;
}

function leave_with_constraint(t) {
  return t;
}

function leave_class_signature(t) {
  return t;
}

function leave_class_declaration(t) {
  return t;
}

function leave_class_description(t) {
  return t;
}

function leave_class_type_declaration(t) {
  return t;
}

function leave_class_type_field(t) {
  return t;
}

function leave_class_structure(t) {
  return t;
}

function leave_class_field(t) {
  return t;
}

function TypedtreeMap_MakeMap(funarg) {
  var map_structure = function (str) {
    var str$1 = Curry._1(funarg.enter_structure, str);
    var str_items = List.map(map_structure_item, str$1.str_items);
    return Curry._1(funarg.leave_structure, {
                str_items: str_items,
                str_type: str$1.str_type,
                str_final_env: str$1.str_final_env
              });
  };
  var map_type_declaration = function (decl) {
    var decl$1 = Curry._1(funarg.enter_type_declaration, decl);
    var typ_params = List.map(map_type_parameter, decl$1.typ_params);
    var typ_cstrs = List.map((function (param) {
            return /* tuple */[
                    map_core_type(param[0]),
                    map_core_type(param[1]),
                    param[2]
                  ];
          }), decl$1.typ_cstrs);
    var match = decl$1.typ_kind;
    var typ_kind;
    if (typeof match === "number") {
      typ_kind = match === /* Ttype_abstract */0 ? /* Ttype_abstract */0 : /* Ttype_open */1;
    } else if (match.tag) {
      var list = List.map((function (ld) {
              return {
                      ld_id: ld.ld_id,
                      ld_name: ld.ld_name,
                      ld_mutable: ld.ld_mutable,
                      ld_type: map_core_type(ld.ld_type),
                      ld_loc: ld.ld_loc,
                      ld_attributes: ld.ld_attributes
                    };
            }), match[0]);
      typ_kind = /* Ttype_record */Block.__(1, [list]);
    } else {
      var list$1 = List.map(map_constructor_declaration, match[0]);
      typ_kind = /* Ttype_variant */Block.__(0, [list$1]);
    }
    var typ_manifest = may_map(map_core_type, decl$1.typ_manifest);
    return Curry._1(funarg.leave_type_declaration, {
                typ_id: decl$1.typ_id,
                typ_name: decl$1.typ_name,
                typ_params: typ_params,
                typ_type: decl$1.typ_type,
                typ_cstrs: typ_cstrs,
                typ_kind: typ_kind,
                typ_private: decl$1.typ_private,
                typ_manifest: typ_manifest,
                typ_loc: decl$1.typ_loc,
                typ_attributes: decl$1.typ_attributes
              });
  };
  var map_case = function (param) {
    return {
            c_lhs: map_pattern(param.c_lhs),
            c_guard: may_map(map_expression, param.c_guard),
            c_rhs: map_expression(param.c_rhs)
          };
  };
  var map_core_type = function (ct) {
    var ct$1 = Curry._1(funarg.enter_core_type, ct);
    var match = ct$1.ctyp_desc;
    var ctyp_desc;
    if (typeof match === "number") {
      ctyp_desc = ct$1.ctyp_desc;
    } else {
      switch (match.tag | 0) {
        case /* Ttyp_var */0 :
            ctyp_desc = ct$1.ctyp_desc;
            break;
        case /* Ttyp_arrow */1 :
            ctyp_desc = /* Ttyp_arrow */Block.__(1, [
                match[0],
                map_core_type(match[1]),
                map_core_type(match[2])
              ]);
            break;
        case /* Ttyp_tuple */2 :
            ctyp_desc = /* Ttyp_tuple */Block.__(2, [List.map(map_core_type, match[0])]);
            break;
        case /* Ttyp_constr */3 :
            ctyp_desc = /* Ttyp_constr */Block.__(3, [
                match[0],
                match[1],
                List.map(map_core_type, match[2])
              ]);
            break;
        case /* Ttyp_object */4 :
            ctyp_desc = /* Ttyp_object */Block.__(4, [
                List.map((function (param) {
                        return /* tuple */[
                                param[0],
                                param[1],
                                map_core_type(param[2])
                              ];
                      }), match[0]),
                match[1]
              ]);
            break;
        case /* Ttyp_class */5 :
            ctyp_desc = /* Ttyp_class */Block.__(5, [
                match[0],
                match[1],
                List.map(map_core_type, match[2])
              ]);
            break;
        case /* Ttyp_alias */6 :
            ctyp_desc = /* Ttyp_alias */Block.__(6, [
                map_core_type(match[0]),
                match[1]
              ]);
            break;
        case /* Ttyp_variant */7 :
            ctyp_desc = /* Ttyp_variant */Block.__(7, [
                List.map(map_row_field, match[0]),
                match[1],
                match[2]
              ]);
            break;
        case /* Ttyp_poly */8 :
            ctyp_desc = /* Ttyp_poly */Block.__(8, [
                match[0],
                map_core_type(match[1])
              ]);
            break;
        case /* Ttyp_package */9 :
            ctyp_desc = /* Ttyp_package */Block.__(9, [map_package_type(match[0])]);
            break;
        
      }
    }
    return Curry._1(funarg.leave_core_type, {
                ctyp_desc: ctyp_desc,
                ctyp_type: ct$1.ctyp_type,
                ctyp_env: ct$1.ctyp_env,
                ctyp_loc: ct$1.ctyp_loc,
                ctyp_attributes: ct$1.ctyp_attributes
              });
  };
  var map_class_type = function (ct) {
    var ct$1 = Curry._1(funarg.enter_class_type, ct);
    var match = ct$1.cltyp_desc;
    var cltyp_desc;
    switch (match.tag | 0) {
      case /* Tcty_constr */0 :
          cltyp_desc = /* Tcty_constr */Block.__(0, [
              match[0],
              match[1],
              List.map(map_core_type, match[2])
            ]);
          break;
      case /* Tcty_signature */1 :
          cltyp_desc = /* Tcty_signature */Block.__(1, [map_class_signature(match[0])]);
          break;
      case /* Tcty_arrow */2 :
          cltyp_desc = /* Tcty_arrow */Block.__(2, [
              match[0],
              map_core_type(match[1]),
              map_class_type(match[2])
            ]);
          break;
      
    }
    return Curry._1(funarg.leave_class_type, {
                cltyp_desc: cltyp_desc,
                cltyp_type: ct$1.cltyp_type,
                cltyp_env: ct$1.cltyp_env,
                cltyp_loc: ct$1.cltyp_loc,
                cltyp_attributes: ct$1.cltyp_attributes
              });
  };
  var map_class_signature = function (cs) {
    var cs$1 = Curry._1(funarg.enter_class_signature, cs);
    var csig_self = map_core_type(cs$1.csig_self);
    var csig_fields = List.map(map_class_type_field, cs$1.csig_fields);
    return Curry._1(funarg.leave_class_signature, {
                csig_self: csig_self,
                csig_fields: csig_fields,
                csig_type: cs$1.csig_type
              });
  };
  var map_module_type = function (mty) {
    var mty$1 = Curry._1(funarg.enter_module_type, mty);
    var match = mty$1.mty_desc;
    var mty_desc;
    switch (match.tag | 0) {
      case /* Tmty_signature */1 :
          mty_desc = /* Tmty_signature */Block.__(1, [map_signature(match[0])]);
          break;
      case /* Tmty_functor */2 :
          mty_desc = /* Tmty_functor */Block.__(2, [
              match[0],
              match[1],
              may_map(map_module_type, match[2]),
              map_module_type(match[3])
            ]);
          break;
      case /* Tmty_with */3 :
          mty_desc = /* Tmty_with */Block.__(3, [
              map_module_type(match[0]),
              List.map((function (param) {
                      return /* tuple */[
                              param[0],
                              param[1],
                              map_with_constraint(param[2])
                            ];
                    }), match[1])
            ]);
          break;
      case /* Tmty_typeof */4 :
          mty_desc = /* Tmty_typeof */Block.__(4, [map_module_expr(match[0])]);
          break;
      case /* Tmty_ident */0 :
      case /* Tmty_alias */5 :
          mty_desc = mty$1.mty_desc;
          break;
      
    }
    return Curry._1(funarg.leave_module_type, {
                mty_desc: mty_desc,
                mty_type: mty$1.mty_type,
                mty_env: mty$1.mty_env,
                mty_loc: mty$1.mty_loc,
                mty_attributes: mty$1.mty_attributes
              });
  };
  var map_constructor_declaration = function (cd) {
    return {
            cd_id: cd.cd_id,
            cd_name: cd.cd_name,
            cd_args: List.map(map_core_type, cd.cd_args),
            cd_res: may_map(map_core_type, cd.cd_res),
            cd_loc: cd.cd_loc,
            cd_attributes: cd.cd_attributes
          };
  };
  var map_type_parameter = function (param) {
    return /* tuple */[
            map_core_type(param[0]),
            param[1]
          ];
  };
  var map_binding = function (vb) {
    return {
            vb_pat: map_pattern(vb.vb_pat),
            vb_expr: map_expression(vb.vb_expr),
            vb_attributes: vb.vb_attributes,
            vb_loc: vb.vb_loc
          };
  };
  var map_module_expr = function (mexpr) {
    var mexpr$1 = Curry._1(funarg.enter_module_expr, mexpr);
    var match = mexpr$1.mod_desc;
    var mod_desc;
    switch (match.tag | 0) {
      case /* Tmod_ident */0 :
          mod_desc = mexpr$1.mod_desc;
          break;
      case /* Tmod_structure */1 :
          mod_desc = /* Tmod_structure */Block.__(1, [map_structure(match[0])]);
          break;
      case /* Tmod_functor */2 :
          mod_desc = /* Tmod_functor */Block.__(2, [
              match[0],
              match[1],
              may_map(map_module_type, match[2]),
              map_module_expr(match[3])
            ]);
          break;
      case /* Tmod_apply */3 :
          mod_desc = /* Tmod_apply */Block.__(3, [
              map_module_expr(match[0]),
              map_module_expr(match[1]),
              match[2]
            ]);
          break;
      case /* Tmod_constraint */4 :
          var match$1 = match[2];
          var mod_type = match[1];
          var mexpr$2 = match[0];
          mod_desc = match$1 ? /* Tmod_constraint */Block.__(4, [
                map_module_expr(mexpr$2),
                mod_type,
                /* Tmodtype_explicit */[map_module_type(match$1[0])],
                match[3]
              ]) : /* Tmod_constraint */Block.__(4, [
                map_module_expr(mexpr$2),
                mod_type,
                /* Tmodtype_implicit */0,
                match[3]
              ]);
          break;
      case /* Tmod_unpack */5 :
          mod_desc = /* Tmod_unpack */Block.__(5, [
              map_expression(match[0]),
              match[1]
            ]);
          break;
      
    }
    return Curry._1(funarg.leave_module_expr, {
                mod_desc: mod_desc,
                mod_loc: mexpr$1.mod_loc,
                mod_type: mexpr$1.mod_type,
                mod_env: mexpr$1.mod_env,
                mod_attributes: mexpr$1.mod_attributes
              });
  };
  var map_class_structure = function (cs) {
    var cs$1 = Curry._1(funarg.enter_class_structure, cs);
    var cstr_self = map_pattern(cs$1.cstr_self);
    var cstr_fields = List.map(map_class_field, cs$1.cstr_fields);
    return Curry._1(funarg.leave_class_structure, {
                cstr_self: cstr_self,
                cstr_fields: cstr_fields,
                cstr_type: cs$1.cstr_type,
                cstr_meths: cs$1.cstr_meths
              });
  };
  var map_exp_extra = function (exp_extra) {
    var attrs = exp_extra[2];
    var loc = exp_extra[1];
    var desc = exp_extra[0];
    switch (desc.tag | 0) {
      case /* Texp_constraint */0 :
          return /* tuple */[
                  /* Texp_constraint */Block.__(0, [map_core_type(desc[0])]),
                  loc,
                  attrs
                ];
      case /* Texp_coerce */1 :
          var match = desc[0];
          if (match !== void 0) {
            return /* tuple */[
                    /* Texp_coerce */Block.__(1, [
                        map_core_type(match),
                        map_core_type(desc[1])
                      ]),
                    loc,
                    attrs
                  ];
          } else {
            return /* tuple */[
                    /* Texp_coerce */Block.__(1, [
                        void 0,
                        map_core_type(desc[1])
                      ]),
                    loc,
                    attrs
                  ];
          }
      case /* Texp_poly */3 :
          var match$1 = desc[0];
          if (match$1 !== void 0) {
            return /* tuple */[
                    /* Texp_poly */Block.__(3, [map_core_type(match$1)]),
                    loc,
                    attrs
                  ];
          } else {
            return exp_extra;
          }
      case /* Texp_open */2 :
      case /* Texp_newtype */4 :
          return exp_extra;
      
    }
  };
  var map_expression = function (exp) {
    var exp$1 = Curry._1(funarg.enter_expression, exp);
    var match = exp$1.exp_desc;
    var exp_desc;
    switch (match.tag | 0) {
      case /* Texp_let */2 :
          var rec_flag = match[0];
          exp_desc = /* Texp_let */Block.__(2, [
              rec_flag,
              List.map(map_binding, match[1]),
              map_expression(match[2])
            ]);
          break;
      case /* Texp_function */3 :
          exp_desc = /* Texp_function */Block.__(3, [
              match[0],
              List.map(map_case, match[1]),
              match[2]
            ]);
          break;
      case /* Texp_apply */4 :
          exp_desc = /* Texp_apply */Block.__(4, [
              map_expression(match[0]),
              List.map((function (param) {
                      var expo = param[1];
                      var expo$1 = expo !== void 0 ? map_expression(expo) : expo;
                      return /* tuple */[
                              param[0],
                              expo$1,
                              param[2]
                            ];
                    }), match[1])
            ]);
          break;
      case /* Texp_match */5 :
          exp_desc = /* Texp_match */Block.__(5, [
              map_expression(match[0]),
              List.map(map_case, match[1]),
              List.map(map_case, match[2]),
              match[3]
            ]);
          break;
      case /* Texp_try */6 :
          exp_desc = /* Texp_try */Block.__(6, [
              map_expression(match[0]),
              List.map(map_case, match[1])
            ]);
          break;
      case /* Texp_tuple */7 :
          exp_desc = /* Texp_tuple */Block.__(7, [List.map(map_expression, match[0])]);
          break;
      case /* Texp_construct */8 :
          exp_desc = /* Texp_construct */Block.__(8, [
              match[0],
              match[1],
              List.map(map_expression, match[2])
            ]);
          break;
      case /* Texp_variant */9 :
          var expo = match[1];
          var expo$1 = expo !== void 0 ? map_expression(expo) : expo;
          exp_desc = /* Texp_variant */Block.__(9, [
              match[0],
              expo$1
            ]);
          break;
      case /* Texp_record */10 :
          var expo$2 = match[1];
          var list = List.map((function (param) {
                  return /* tuple */[
                          param[0],
                          param[1],
                          map_expression(param[2])
                        ];
                }), match[0]);
          var expo$3 = expo$2 !== void 0 ? map_expression(expo$2) : expo$2;
          exp_desc = /* Texp_record */Block.__(10, [
              list,
              expo$3
            ]);
          break;
      case /* Texp_field */11 :
          exp_desc = /* Texp_field */Block.__(11, [
              map_expression(match[0]),
              match[1],
              match[2]
            ]);
          break;
      case /* Texp_setfield */12 :
          exp_desc = /* Texp_setfield */Block.__(12, [
              map_expression(match[0]),
              match[1],
              match[2],
              map_expression(match[3])
            ]);
          break;
      case /* Texp_array */13 :
          exp_desc = /* Texp_array */Block.__(13, [List.map(map_expression, match[0])]);
          break;
      case /* Texp_ifthenelse */14 :
          var expo$4 = match[2];
          exp_desc = /* Texp_ifthenelse */Block.__(14, [
              map_expression(match[0]),
              map_expression(match[1]),
              expo$4 !== void 0 ? map_expression(expo$4) : expo$4
            ]);
          break;
      case /* Texp_sequence */15 :
          exp_desc = /* Texp_sequence */Block.__(15, [
              map_expression(match[0]),
              map_expression(match[1])
            ]);
          break;
      case /* Texp_while */16 :
          exp_desc = /* Texp_while */Block.__(16, [
              map_expression(match[0]),
              map_expression(match[1])
            ]);
          break;
      case /* Texp_for */17 :
          exp_desc = /* Texp_for */Block.__(17, [
              match[0],
              match[1],
              map_expression(match[2]),
              map_expression(match[3]),
              match[4],
              map_expression(match[5])
            ]);
          break;
      case /* Texp_send */18 :
          exp_desc = /* Texp_send */Block.__(18, [
              map_expression(match[0]),
              match[1],
              may_map(map_expression, match[2])
            ]);
          break;
      case /* Texp_ident */0 :
      case /* Texp_constant */1 :
      case /* Texp_new */19 :
      case /* Texp_instvar */20 :
          exp_desc = exp$1.exp_desc;
          break;
      case /* Texp_setinstvar */21 :
          exp_desc = /* Texp_setinstvar */Block.__(21, [
              match[0],
              match[1],
              match[2],
              map_expression(match[3])
            ]);
          break;
      case /* Texp_override */22 :
          exp_desc = /* Texp_override */Block.__(22, [
              match[0],
              List.map((function (param) {
                      return /* tuple */[
                              param[0],
                              param[1],
                              map_expression(param[2])
                            ];
                    }), match[1])
            ]);
          break;
      case /* Texp_letmodule */23 :
          exp_desc = /* Texp_letmodule */Block.__(23, [
              match[0],
              match[1],
              map_module_expr(match[2]),
              map_expression(match[3])
            ]);
          break;
      case /* Texp_assert */24 :
          exp_desc = /* Texp_assert */Block.__(24, [map_expression(match[0])]);
          break;
      case /* Texp_lazy */25 :
          exp_desc = /* Texp_lazy */Block.__(25, [map_expression(match[0])]);
          break;
      case /* Texp_object */26 :
          exp_desc = /* Texp_object */Block.__(26, [
              map_class_structure(match[0]),
              match[1]
            ]);
          break;
      case /* Texp_pack */27 :
          exp_desc = /* Texp_pack */Block.__(27, [map_module_expr(match[0])]);
          break;
      
    }
    var exp_extra = List.map(map_exp_extra, exp$1.exp_extra);
    return Curry._1(funarg.leave_expression, {
                exp_desc: exp_desc,
                exp_loc: exp$1.exp_loc,
                exp_extra: exp_extra,
                exp_type: exp$1.exp_type,
                exp_env: exp$1.exp_env,
                exp_attributes: exp$1.exp_attributes
              });
  };
  var map_structure_item = function (item) {
    var item$1 = Curry._1(funarg.enter_structure_item, item);
    var match = item$1.str_desc;
    var str_desc;
    switch (match.tag | 0) {
      case /* Tstr_eval */0 :
          str_desc = /* Tstr_eval */Block.__(0, [
              map_expression(match[0]),
              match[1]
            ]);
          break;
      case /* Tstr_value */1 :
          var rec_flag = match[0];
          str_desc = /* Tstr_value */Block.__(1, [
              rec_flag,
              List.map(map_binding, match[1])
            ]);
          break;
      case /* Tstr_primitive */2 :
          str_desc = /* Tstr_primitive */Block.__(2, [map_value_description(match[0])]);
          break;
      case /* Tstr_type */3 :
          str_desc = /* Tstr_type */Block.__(3, [List.map(map_type_declaration, match[0])]);
          break;
      case /* Tstr_typext */4 :
          str_desc = /* Tstr_typext */Block.__(4, [map_type_extension(match[0])]);
          break;
      case /* Tstr_exception */5 :
          str_desc = /* Tstr_exception */Block.__(5, [map_extension_constructor(match[0])]);
          break;
      case /* Tstr_module */6 :
          str_desc = /* Tstr_module */Block.__(6, [map_module_binding(match[0])]);
          break;
      case /* Tstr_recmodule */7 :
          var list = List.map(map_module_binding, match[0]);
          str_desc = /* Tstr_recmodule */Block.__(7, [list]);
          break;
      case /* Tstr_modtype */8 :
          str_desc = /* Tstr_modtype */Block.__(8, [map_module_type_declaration(match[0])]);
          break;
      case /* Tstr_open */9 :
          str_desc = /* Tstr_open */Block.__(9, [match[0]]);
          break;
      case /* Tstr_class */10 :
          var list$1 = List.map((function (param) {
                  return /* tuple */[
                          map_class_declaration(param[0]),
                          param[1],
                          param[2]
                        ];
                }), match[0]);
          str_desc = /* Tstr_class */Block.__(10, [list$1]);
          break;
      case /* Tstr_class_type */11 :
          var list$2 = List.map((function (param) {
                  return /* tuple */[
                          param[0],
                          param[1],
                          map_class_type_declaration(param[2])
                        ];
                }), match[0]);
          str_desc = /* Tstr_class_type */Block.__(11, [list$2]);
          break;
      case /* Tstr_include */12 :
          var incl = match[0];
          str_desc = /* Tstr_include */Block.__(12, [{
                incl_mod: map_module_expr(incl.incl_mod),
                incl_type: incl.incl_type,
                incl_loc: incl.incl_loc,
                incl_attributes: incl.incl_attributes
              }]);
          break;
      case /* Tstr_attribute */13 :
          str_desc = /* Tstr_attribute */Block.__(13, [match[0]]);
          break;
      
    }
    return Curry._1(funarg.leave_structure_item, {
                str_desc: str_desc,
                str_loc: item$1.str_loc,
                str_env: item$1.str_env
              });
  };
  var map_class_type_field = function (ctf) {
    var ctf$1 = Curry._1(funarg.enter_class_type_field, ctf);
    var x = ctf$1.ctf_desc;
    var ctf_desc;
    switch (x.tag | 0) {
      case /* Tctf_inherit */0 :
          ctf_desc = /* Tctf_inherit */Block.__(0, [map_class_type(x[0])]);
          break;
      case /* Tctf_val */1 :
          var match = x[0];
          ctf_desc = /* Tctf_val */Block.__(1, [/* tuple */[
                match[0],
                match[1],
                match[2],
                map_core_type(match[3])
              ]]);
          break;
      case /* Tctf_method */2 :
          var match$1 = x[0];
          ctf_desc = /* Tctf_method */Block.__(2, [/* tuple */[
                match$1[0],
                match$1[1],
                match$1[2],
                map_core_type(match$1[3])
              ]]);
          break;
      case /* Tctf_constraint */3 :
          var match$2 = x[0];
          ctf_desc = /* Tctf_constraint */Block.__(3, [/* tuple */[
                map_core_type(match$2[0]),
                map_core_type(match$2[1])
              ]]);
          break;
      case /* Tctf_attribute */4 :
          ctf_desc = x;
          break;
      
    }
    return Curry._1(funarg.leave_class_type_field, {
                ctf_desc: ctf_desc,
                ctf_loc: ctf$1.ctf_loc,
                ctf_attributes: ctf$1.ctf_attributes
              });
  };
  var map_signature_item = function (item) {
    var item$1 = Curry._1(funarg.enter_signature_item, item);
    var x = item$1.sig_desc;
    var sig_desc;
    switch (x.tag | 0) {
      case /* Tsig_value */0 :
          sig_desc = /* Tsig_value */Block.__(0, [map_value_description(x[0])]);
          break;
      case /* Tsig_type */1 :
          sig_desc = /* Tsig_type */Block.__(1, [List.map(map_type_declaration, x[0])]);
          break;
      case /* Tsig_typext */2 :
          sig_desc = /* Tsig_typext */Block.__(2, [map_type_extension(x[0])]);
          break;
      case /* Tsig_exception */3 :
          sig_desc = /* Tsig_exception */Block.__(3, [map_extension_constructor(x[0])]);
          break;
      case /* Tsig_module */4 :
          var md = x[0];
          sig_desc = /* Tsig_module */Block.__(4, [{
                md_id: md.md_id,
                md_name: md.md_name,
                md_type: map_module_type(md.md_type),
                md_attributes: md.md_attributes,
                md_loc: md.md_loc
              }]);
          break;
      case /* Tsig_recmodule */5 :
          sig_desc = /* Tsig_recmodule */Block.__(5, [List.map((function (md) {
                      return {
                              md_id: md.md_id,
                              md_name: md.md_name,
                              md_type: map_module_type(md.md_type),
                              md_attributes: md.md_attributes,
                              md_loc: md.md_loc
                            };
                    }), x[0])]);
          break;
      case /* Tsig_modtype */6 :
          sig_desc = /* Tsig_modtype */Block.__(6, [map_module_type_declaration(x[0])]);
          break;
      case /* Tsig_open */7 :
          sig_desc = item$1.sig_desc;
          break;
      case /* Tsig_include */8 :
          var incl = x[0];
          sig_desc = /* Tsig_include */Block.__(8, [{
                incl_mod: map_module_type(incl.incl_mod),
                incl_type: incl.incl_type,
                incl_loc: incl.incl_loc,
                incl_attributes: incl.incl_attributes
              }]);
          break;
      case /* Tsig_class */9 :
          sig_desc = /* Tsig_class */Block.__(9, [List.map(map_class_description, x[0])]);
          break;
      case /* Tsig_class_type */10 :
          sig_desc = /* Tsig_class_type */Block.__(10, [List.map(map_class_type_declaration, x[0])]);
          break;
      case /* Tsig_attribute */11 :
          sig_desc = x;
          break;
      
    }
    return Curry._1(funarg.leave_signature_item, {
                sig_desc: sig_desc,
                sig_env: item$1.sig_env,
                sig_loc: item$1.sig_loc
              });
  };
  var map_row_field = function (rf) {
    if (rf.tag) {
      return /* Tinherit */Block.__(1, [map_core_type(rf[0])]);
    } else {
      return /* Ttag */Block.__(0, [
                rf[0],
                rf[1],
                rf[2],
                List.map(map_core_type, rf[3])
              ]);
    }
  };
  var map_package_type = function (pack) {
    var pack$1 = Curry._1(funarg.enter_package_type, pack);
    var pack_fields = List.map((function (param) {
            return /* tuple */[
                    param[0],
                    map_core_type(param[1])
                  ];
          }), pack$1.pack_fields);
    return Curry._1(funarg.leave_package_type, {
                pack_path: pack$1.pack_path,
                pack_fields: pack_fields,
                pack_type: pack$1.pack_type,
                pack_txt: pack$1.pack_txt
              });
  };
  var map_extension_constructor = function (ext) {
    var ext$1 = Curry._1(funarg.enter_extension_constructor, ext);
    var match = ext$1.ext_kind;
    var ext_kind;
    if (match.tag) {
      ext_kind = /* Text_rebind */Block.__(1, [
          match[0],
          match[1]
        ]);
    } else {
      var args = List.map(map_core_type, match[0]);
      var ret = may_map(map_core_type, match[1]);
      ext_kind = /* Text_decl */Block.__(0, [
          args,
          ret
        ]);
    }
    return Curry._1(funarg.leave_extension_constructor, {
                ext_id: ext$1.ext_id,
                ext_name: ext$1.ext_name,
                ext_type: ext$1.ext_type,
                ext_kind: ext_kind,
                ext_loc: ext$1.ext_loc,
                ext_attributes: ext$1.ext_attributes
              });
  };
  var map_type_extension = function (tyext) {
    var tyext$1 = Curry._1(funarg.enter_type_extension, tyext);
    var tyext_params = List.map(map_type_parameter, tyext$1.tyext_params);
    var tyext_constructors = List.map(map_extension_constructor, tyext$1.tyext_constructors);
    return Curry._1(funarg.leave_type_extension, {
                tyext_path: tyext$1.tyext_path,
                tyext_txt: tyext$1.tyext_txt,
                tyext_params: tyext_params,
                tyext_constructors: tyext_constructors,
                tyext_private: tyext$1.tyext_private,
                tyext_attributes: tyext$1.tyext_attributes
              });
  };
  var map_value_description = function (v) {
    var v$1 = Curry._1(funarg.enter_value_description, v);
    var val_desc = map_core_type(v$1.val_desc);
    return Curry._1(funarg.leave_value_description, {
                val_id: v$1.val_id,
                val_name: v$1.val_name,
                val_desc: val_desc,
                val_val: v$1.val_val,
                val_prim: v$1.val_prim,
                val_loc: v$1.val_loc,
                val_attributes: v$1.val_attributes
              });
  };
  var map_class_declaration = function (cd) {
    var cd$1 = Curry._1(funarg.enter_class_declaration, cd);
    var ci_params = List.map(map_type_parameter, cd$1.ci_params);
    var ci_expr = map_class_expr(cd$1.ci_expr);
    return Curry._1(funarg.leave_class_declaration, {
                ci_virt: cd$1.ci_virt,
                ci_params: ci_params,
                ci_id_name: cd$1.ci_id_name,
                ci_id_class: cd$1.ci_id_class,
                ci_id_class_type: cd$1.ci_id_class_type,
                ci_id_object: cd$1.ci_id_object,
                ci_id_typesharp: cd$1.ci_id_typesharp,
                ci_expr: ci_expr,
                ci_decl: cd$1.ci_decl,
                ci_type_decl: cd$1.ci_type_decl,
                ci_loc: cd$1.ci_loc,
                ci_attributes: cd$1.ci_attributes
              });
  };
  var map_module_type_declaration = function (mtd) {
    var mtd$1 = Curry._1(funarg.enter_module_type_declaration, mtd);
    return Curry._1(funarg.leave_module_type_declaration, {
                mtd_id: mtd$1.mtd_id,
                mtd_name: mtd$1.mtd_name,
                mtd_type: may_map(map_module_type, mtd$1.mtd_type),
                mtd_attributes: mtd$1.mtd_attributes,
                mtd_loc: mtd$1.mtd_loc
              });
  };
  var map_class_type_declaration = function (cd) {
    var cd$1 = Curry._1(funarg.enter_class_type_declaration, cd);
    var ci_params = List.map(map_type_parameter, cd$1.ci_params);
    var ci_expr = map_class_type(cd$1.ci_expr);
    return Curry._1(funarg.leave_class_type_declaration, {
                ci_virt: cd$1.ci_virt,
                ci_params: ci_params,
                ci_id_name: cd$1.ci_id_name,
                ci_id_class: cd$1.ci_id_class,
                ci_id_class_type: cd$1.ci_id_class_type,
                ci_id_object: cd$1.ci_id_object,
                ci_id_typesharp: cd$1.ci_id_typesharp,
                ci_expr: ci_expr,
                ci_decl: cd$1.ci_decl,
                ci_type_decl: cd$1.ci_type_decl,
                ci_loc: cd$1.ci_loc,
                ci_attributes: cd$1.ci_attributes
              });
  };
  var map_module_binding = function (x) {
    return {
            mb_id: x.mb_id,
            mb_name: x.mb_name,
            mb_expr: map_module_expr(x.mb_expr),
            mb_attributes: x.mb_attributes,
            mb_loc: x.mb_loc
          };
  };
  var map_class_expr = function (cexpr) {
    var cexpr$1 = Curry._1(funarg.enter_class_expr, cexpr);
    var match = cexpr$1.cl_desc;
    var cl_desc;
    switch (match.tag | 0) {
      case /* Tcl_ident */0 :
          cl_desc = /* Tcl_ident */Block.__(0, [
              match[0],
              match[1],
              List.map(map_core_type, match[2])
            ]);
          break;
      case /* Tcl_structure */1 :
          cl_desc = /* Tcl_structure */Block.__(1, [map_class_structure(match[0])]);
          break;
      case /* Tcl_fun */2 :
          cl_desc = /* Tcl_fun */Block.__(2, [
              match[0],
              map_pattern(match[1]),
              List.map((function (param) {
                      return /* tuple */[
                              param[0],
                              param[1],
                              map_expression(param[2])
                            ];
                    }), match[2]),
              map_class_expr(match[3]),
              match[4]
            ]);
          break;
      case /* Tcl_apply */3 :
          cl_desc = /* Tcl_apply */Block.__(3, [
              map_class_expr(match[0]),
              List.map((function (param) {
                      return /* tuple */[
                              param[0],
                              may_map(map_expression, param[1]),
                              param[2]
                            ];
                    }), match[1])
            ]);
          break;
      case /* Tcl_let */4 :
          var rec_flat = match[0];
          cl_desc = /* Tcl_let */Block.__(4, [
              rec_flat,
              List.map(map_binding, match[1]),
              List.map((function (param) {
                      return /* tuple */[
                              param[0],
                              param[1],
                              map_expression(param[2])
                            ];
                    }), match[2]),
              map_class_expr(match[3])
            ]);
          break;
      case /* Tcl_constraint */5 :
          var match$1 = match[1];
          var cl = match[0];
          cl_desc = match$1 !== void 0 ? /* Tcl_constraint */Block.__(5, [
                map_class_expr(cl),
                map_class_type(match$1),
                match[2],
                match[3],
                match[4]
              ]) : /* Tcl_constraint */Block.__(5, [
                map_class_expr(cl),
                void 0,
                match[2],
                match[3],
                match[4]
              ]);
          break;
      
    }
    return Curry._1(funarg.leave_class_expr, {
                cl_desc: cl_desc,
                cl_loc: cexpr$1.cl_loc,
                cl_type: cexpr$1.cl_type,
                cl_env: cexpr$1.cl_env,
                cl_attributes: cexpr$1.cl_attributes
              });
  };
  var map_pattern = function (pat) {
    var pat$1 = Curry._1(funarg.enter_pattern, pat);
    var match = pat$1.pat_desc;
    var pat_desc;
    if (typeof match === "number") {
      pat_desc = pat$1.pat_desc;
    } else {
      switch (match.tag | 0) {
        case /* Tpat_alias */1 :
            var pat1 = map_pattern(match[0]);
            pat_desc = /* Tpat_alias */Block.__(1, [
                pat1,
                match[1],
                match[2]
              ]);
            break;
        case /* Tpat_tuple */3 :
            pat_desc = /* Tpat_tuple */Block.__(3, [List.map(map_pattern, match[0])]);
            break;
        case /* Tpat_construct */4 :
            pat_desc = /* Tpat_construct */Block.__(4, [
                match[0],
                match[1],
                List.map(map_pattern, match[2])
              ]);
            break;
        case /* Tpat_variant */5 :
            var pato = match[1];
            var pato$1 = pato !== void 0 ? map_pattern(pato) : pato;
            pat_desc = /* Tpat_variant */Block.__(5, [
                match[0],
                pato$1,
                match[2]
              ]);
            break;
        case /* Tpat_record */6 :
            pat_desc = /* Tpat_record */Block.__(6, [
                List.map((function (param) {
                        return /* tuple */[
                                param[0],
                                param[1],
                                map_pattern(param[2])
                              ];
                      }), match[0]),
                match[1]
              ]);
            break;
        case /* Tpat_array */7 :
            pat_desc = /* Tpat_array */Block.__(7, [List.map(map_pattern, match[0])]);
            break;
        case /* Tpat_or */8 :
            pat_desc = /* Tpat_or */Block.__(8, [
                map_pattern(match[0]),
                map_pattern(match[1]),
                match[2]
              ]);
            break;
        case /* Tpat_lazy */9 :
            pat_desc = /* Tpat_lazy */Block.__(9, [map_pattern(match[0])]);
            break;
        default:
          pat_desc = pat$1.pat_desc;
      }
    }
    var pat_extra = List.map(map_pat_extra, pat$1.pat_extra);
    return Curry._1(funarg.leave_pattern, {
                pat_desc: pat_desc,
                pat_loc: pat$1.pat_loc,
                pat_extra: pat_extra,
                pat_type: pat$1.pat_type,
                pat_env: pat$1.pat_env,
                pat_attributes: pat$1.pat_attributes
              });
  };
  var map_signature = function (sg) {
    var sg$1 = Curry._1(funarg.enter_signature, sg);
    var sig_items = List.map(map_signature_item, sg$1.sig_items);
    return Curry._1(funarg.leave_signature, {
                sig_items: sig_items,
                sig_type: sg$1.sig_type,
                sig_final_env: sg$1.sig_final_env
              });
  };
  var map_with_constraint = function (cstr) {
    var cstr$1 = Curry._1(funarg.enter_with_constraint, cstr);
    var tmp;
    switch (cstr$1.tag | 0) {
      case /* Twith_type */0 :
          tmp = /* Twith_type */Block.__(0, [map_type_declaration(cstr$1[0])]);
          break;
      case /* Twith_typesubst */2 :
          tmp = /* Twith_typesubst */Block.__(2, [map_type_declaration(cstr$1[0])]);
          break;
      case /* Twith_module */1 :
      case /* Twith_modsubst */3 :
          tmp = cstr$1;
          break;
      
    }
    return Curry._1(funarg.leave_with_constraint, tmp);
  };
  var map_class_field = function (cf) {
    var cf$1 = Curry._1(funarg.enter_class_field, cf);
    var x = cf$1.cf_desc;
    var cf_desc;
    switch (x.tag | 0) {
      case /* Tcf_inherit */0 :
          cf_desc = /* Tcf_inherit */Block.__(0, [
              x[0],
              map_class_expr(x[1]),
              x[2],
              x[3],
              x[4]
            ]);
          break;
      case /* Tcf_val */1 :
          var match = x[3];
          var ident = x[2];
          var mut = x[1];
          var lab = x[0];
          cf_desc = match.tag ? /* Tcf_val */Block.__(1, [
                lab,
                mut,
                ident,
                /* Tcfk_concrete */Block.__(1, [
                    match[0],
                    map_expression(match[1])
                  ]),
                x[4]
              ]) : /* Tcf_val */Block.__(1, [
                lab,
                mut,
                ident,
                /* Tcfk_virtual */Block.__(0, [map_core_type(match[0])]),
                x[4]
              ]);
          break;
      case /* Tcf_method */2 :
          var match$1 = x[2];
          var priv = x[1];
          var lab$1 = x[0];
          cf_desc = match$1.tag ? /* Tcf_method */Block.__(2, [
                lab$1,
                priv,
                /* Tcfk_concrete */Block.__(1, [
                    match$1[0],
                    map_expression(match$1[1])
                  ])
              ]) : /* Tcf_method */Block.__(2, [
                lab$1,
                priv,
                /* Tcfk_virtual */Block.__(0, [map_core_type(match$1[0])])
              ]);
          break;
      case /* Tcf_constraint */3 :
          cf_desc = /* Tcf_constraint */Block.__(3, [
              map_core_type(x[0]),
              map_core_type(x[1])
            ]);
          break;
      case /* Tcf_initializer */4 :
          cf_desc = /* Tcf_initializer */Block.__(4, [map_expression(x[0])]);
          break;
      case /* Tcf_attribute */5 :
          cf_desc = x;
          break;
      
    }
    return Curry._1(funarg.leave_class_field, {
                cf_desc: cf_desc,
                cf_loc: cf$1.cf_loc,
                cf_attributes: cf$1.cf_attributes
              });
  };
  var map_class_description = function (cd) {
    var cd$1 = Curry._1(funarg.enter_class_description, cd);
    var ci_params = List.map(map_type_parameter, cd$1.ci_params);
    var ci_expr = map_class_type(cd$1.ci_expr);
    return Curry._1(funarg.leave_class_description, {
                ci_virt: cd$1.ci_virt,
                ci_params: ci_params,
                ci_id_name: cd$1.ci_id_name,
                ci_id_class: cd$1.ci_id_class,
                ci_id_class_type: cd$1.ci_id_class_type,
                ci_id_object: cd$1.ci_id_object,
                ci_id_typesharp: cd$1.ci_id_typesharp,
                ci_expr: ci_expr,
                ci_decl: cd$1.ci_decl,
                ci_type_decl: cd$1.ci_type_decl,
                ci_loc: cd$1.ci_loc,
                ci_attributes: cd$1.ci_attributes
              });
  };
  var map_pat_extra = function (pat_extra) {
    var match = pat_extra[0];
    if (typeof match === "number" || match.tag) {
      return pat_extra;
    } else {
      return /* tuple */[
              /* Tpat_constraint */Block.__(0, [map_core_type(match[0])]),
              pat_extra[1],
              pat_extra[2]
            ];
    }
  };
  return {
          map_structure: map_structure,
          map_pattern: map_pattern,
          map_structure_item: map_structure_item,
          map_expression: map_expression,
          map_class_expr: map_class_expr,
          map_signature: map_signature,
          map_signature_item: map_signature_item,
          map_module_type: map_module_type
        };
}

var need_to_clear_env;

try {
  Caml_sys.caml_sys_getenv("OCAML_BINANNOT_WITHENV");
  need_to_clear_env = false;
}
catch (exn$2){
  if (exn$2 !== Caml_builtin_exceptions.not_found) {
    throw exn$2;
  }
  need_to_clear_env = true;
}

function leave_pattern(p) {
  return {
          pat_desc: p.pat_desc,
          pat_loc: p.pat_loc,
          pat_extra: p.pat_extra,
          pat_type: p.pat_type,
          pat_env: keep_only_summary(p.pat_env),
          pat_attributes: p.pat_attributes
        };
}

function leave_expression(e) {
  var exp_extra = List.map((function (exp_extra) {
          var match = exp_extra[0];
          if (match.tag === /* Texp_open */2) {
            return /* tuple */[
                    /* Texp_open */Block.__(2, [
                        match[0],
                        match[1],
                        match[2],
                        keep_only_summary(match[3])
                      ]),
                    exp_extra[1],
                    exp_extra[2]
                  ];
          } else {
            return exp_extra;
          }
        }), e.exp_extra);
  return {
          exp_desc: e.exp_desc,
          exp_loc: e.exp_loc,
          exp_extra: exp_extra,
          exp_type: e.exp_type,
          exp_env: keep_only_summary(e.exp_env),
          exp_attributes: e.exp_attributes
        };
}

function leave_class_expr(c) {
  return {
          cl_desc: c.cl_desc,
          cl_loc: c.cl_loc,
          cl_type: c.cl_type,
          cl_env: keep_only_summary(c.cl_env),
          cl_attributes: c.cl_attributes
        };
}

function leave_module_expr(m) {
  return {
          mod_desc: m.mod_desc,
          mod_loc: m.mod_loc,
          mod_type: m.mod_type,
          mod_env: keep_only_summary(m.mod_env),
          mod_attributes: m.mod_attributes
        };
}

function leave_structure(s) {
  return {
          str_items: s.str_items,
          str_type: s.str_type,
          str_final_env: keep_only_summary(s.str_final_env)
        };
}

function leave_structure_item(str) {
  return {
          str_desc: str.str_desc,
          str_loc: str.str_loc,
          str_env: keep_only_summary(str.str_env)
        };
}

function leave_module_type(m) {
  return {
          mty_desc: m.mty_desc,
          mty_type: m.mty_type,
          mty_env: keep_only_summary(m.mty_env),
          mty_loc: m.mty_loc,
          mty_attributes: m.mty_attributes
        };
}

function leave_signature(s) {
  return {
          sig_items: s.sig_items,
          sig_type: s.sig_type,
          sig_final_env: keep_only_summary(s.sig_final_env)
        };
}

function leave_signature_item(s) {
  return {
          sig_desc: s.sig_desc,
          sig_env: keep_only_summary(s.sig_env),
          sig_loc: s.sig_loc
        };
}

function leave_core_type(c) {
  return {
          ctyp_desc: c.ctyp_desc,
          ctyp_type: c.ctyp_type,
          ctyp_env: keep_only_summary(c.ctyp_env),
          ctyp_loc: c.ctyp_loc,
          ctyp_attributes: c.ctyp_attributes
        };
}

function leave_class_type(c) {
  return {
          cltyp_desc: c.cltyp_desc,
          cltyp_type: c.cltyp_type,
          cltyp_env: keep_only_summary(c.cltyp_env),
          cltyp_loc: c.cltyp_loc,
          cltyp_attributes: c.cltyp_attributes
        };
}

var ClearEnv = Curry._1(TypedtreeMap_MakeMap, {
      enter_structure: enter_structure,
      enter_value_description: enter_value_description,
      enter_type_declaration: enter_type_declaration,
      enter_type_extension: enter_type_extension,
      enter_extension_constructor: enter_extension_constructor,
      enter_pattern: enter_pattern,
      enter_expression: enter_expression,
      enter_package_type: enter_package_type,
      enter_signature: enter_signature,
      enter_signature_item: enter_signature_item,
      enter_module_type_declaration: enter_module_type_declaration,
      enter_module_type: enter_module_type,
      enter_module_expr: enter_module_expr,
      enter_with_constraint: enter_with_constraint,
      enter_class_expr: enter_class_expr,
      enter_class_signature: enter_class_signature,
      enter_class_declaration: enter_class_declaration,
      enter_class_description: enter_class_description,
      enter_class_type_declaration: enter_class_type_declaration,
      enter_class_type: enter_class_type,
      enter_class_type_field: enter_class_type_field,
      enter_core_type: enter_core_type,
      enter_class_structure: enter_class_structure,
      enter_class_field: enter_class_field,
      enter_structure_item: enter_structure_item,
      leave_structure: leave_structure,
      leave_value_description: leave_value_description,
      leave_type_declaration: leave_type_declaration,
      leave_type_extension: leave_type_extension,
      leave_extension_constructor: leave_extension_constructor,
      leave_pattern: leave_pattern,
      leave_expression: leave_expression,
      leave_package_type: leave_package_type,
      leave_signature: leave_signature,
      leave_signature_item: leave_signature_item,
      leave_module_type_declaration: leave_module_type_declaration,
      leave_module_type: leave_module_type,
      leave_module_expr: leave_module_expr,
      leave_with_constraint: leave_with_constraint,
      leave_class_expr: leave_class_expr,
      leave_class_signature: leave_class_signature,
      leave_class_declaration: leave_class_declaration,
      leave_class_description: leave_class_description,
      leave_class_type_declaration: leave_class_type_declaration,
      leave_class_type: leave_class_type,
      leave_class_type_field: leave_class_type_field,
      leave_core_type: leave_core_type,
      leave_class_structure: leave_class_structure,
      leave_class_field: leave_class_field,
      leave_structure_item: leave_structure_item
    });

function clear_part(p) {
  switch (p.tag | 0) {
    case /* Partial_structure */0 :
        return /* Partial_structure */Block.__(0, [Curry._1(ClearEnv.map_structure, p[0])]);
    case /* Partial_structure_item */1 :
        return /* Partial_structure_item */Block.__(1, [Curry._1(ClearEnv.map_structure_item, p[0])]);
    case /* Partial_expression */2 :
        return /* Partial_expression */Block.__(2, [Curry._1(ClearEnv.map_expression, p[0])]);
    case /* Partial_pattern */3 :
        return /* Partial_pattern */Block.__(3, [Curry._1(ClearEnv.map_pattern, p[0])]);
    case /* Partial_class_expr */4 :
        return /* Partial_class_expr */Block.__(4, [Curry._1(ClearEnv.map_class_expr, p[0])]);
    case /* Partial_signature */5 :
        return /* Partial_signature */Block.__(5, [Curry._1(ClearEnv.map_signature, p[0])]);
    case /* Partial_signature_item */6 :
        return /* Partial_signature_item */Block.__(6, [Curry._1(ClearEnv.map_signature_item, p[0])]);
    case /* Partial_module_type */7 :
        return /* Partial_module_type */Block.__(7, [Curry._1(ClearEnv.map_module_type, p[0])]);
    
  }
}

function clear_env(binary_annots) {
  if (!need_to_clear_env) {
    return binary_annots;
  }
  switch (binary_annots.tag | 0) {
    case /* Packed */0 :
        return binary_annots;
    case /* Implementation */1 :
        return /* Implementation */Block.__(1, [Curry._1(ClearEnv.map_structure, binary_annots[0])]);
    case /* Interface */2 :
        return /* Interface */Block.__(2, [Curry._1(ClearEnv.map_signature, binary_annots[0])]);
    case /* Partial_implementation */3 :
        return /* Partial_implementation */Block.__(3, [$$Array.map(clear_part, binary_annots[0])]);
    case /* Partial_interface */4 :
        return /* Partial_interface */Block.__(4, [$$Array.map(clear_part, binary_annots[0])]);
    
  }
}

function output_cmt(oc, cmt) {
  Pervasives.output_string(oc, "Caml2012T004");
  return Caml_external_polyfill.resolve("caml_output_value")(oc, cmt, /* [] */0);
}

var saved_types = {
  contents: /* [] */0
};

var value_deps = {
  contents: /* [] */0
};

function clear(param) {
  saved_types.contents = /* [] */0;
  value_deps.contents = /* [] */0;
  
}

function add_saved_type(b) {
  saved_types.contents = /* :: */[
    b,
    saved_types.contents
  ];
  
}

function record_value_dependency(vd1, vd2) {
  if (Caml_obj.caml_notequal(vd1.val_loc, vd2.val_loc)) {
    value_deps.contents = /* :: */[
      /* tuple */[
        vd1,
        vd2
      ],
      value_deps.contents
    ];
    return ;
  }
  
}

function save_cmt(filename, modname, binary_annots, sourcefile, initial_env, sg) {
  if (binary_annotations.contents && !print_types.contents) {
    var imports$1 = imports(void 0);
    var oc = Pervasives.open_out_bin(filename);
    var this_crc;
    if (sg !== void 0) {
      var cmi_cmi_flags = recursive_types.contents ? /* :: */[
          /* Rectypes */0,
          /* [] */0
        ] : /* [] */0;
      var cmi = {
        cmi_name: modname,
        cmi_sign: sg,
        cmi_crcs: imports$1,
        cmi_flags: cmi_cmi_flags
      };
      this_crc = output_cmi(filename, oc, cmi);
    } else {
      this_crc = void 0;
    }
    var source_digest = may_map(Digest.file, sourcefile);
    var cmt_cmt_annots = clear_env(binary_annots);
    var cmt_cmt_value_dependencies = value_deps.contents;
    var cmt_cmt_comments = List.rev(comment_list.contents);
    var cmt_cmt_builddir = Caml_sys.caml_sys_getcwd(void 0);
    var cmt_cmt_loadpath = load_path.contents;
    var cmt_cmt_initial_env = need_to_clear_env ? keep_only_summary(initial_env) : initial_env;
    var cmt_cmt_imports = List.sort(Caml_obj.caml_compare, imports$1);
    var cmt = {
      cmt_modname: modname,
      cmt_annots: cmt_cmt_annots,
      cmt_value_dependencies: cmt_cmt_value_dependencies,
      cmt_comments: cmt_cmt_comments,
      cmt_args: Sys.argv,
      cmt_sourcefile: sourcefile,
      cmt_builddir: cmt_cmt_builddir,
      cmt_loadpath: cmt_cmt_loadpath,
      cmt_source_digest: source_digest,
      cmt_initial_env: cmt_cmt_initial_env,
      cmt_imports: cmt_cmt_imports,
      cmt_interface_digest: this_crc,
      cmt_use_summaries: need_to_clear_env
    };
    output_cmt(oc, cmt);
    Caml_io.caml_ml_flush(oc);
    Caml_external_polyfill.resolve("caml_ml_close_channel")(oc);
    var exit = 0;
    var cmd;
    try {
      cmd = Caml_sys.caml_sys_getenv("BS_CMT_POST_PROCESS_CMD");
      exit = 1;
    }
    catch (exn){
      
    }
    if (exit === 1) {
      Caml_sys.caml_sys_system_command(cmd + (" -cmt-add " + (filename + (
                sourcefile !== void 0 ? ":" + sourcefile : ""
              ))));
    }
    
  }
  return clear(void 0);
}

var Unify = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Unify");

var Tags = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Tags");

register_error_of_exn((function (param) {
        if (param[0] === Tags) {
          return Curry._2(errorf(in_file(input_name.contents), void 0, void 0, /* Format */[
                          /* String_literal */Block.__(11, [
                              "In this program,",
                              /* Formatting_lit */Block.__(17, [
                                  /* Break */Block.__(0, [
                                      "@ ",
                                      1,
                                      0
                                    ]),
                                  /* String_literal */Block.__(11, [
                                      "variant constructors",
                                      /* Formatting_lit */Block.__(17, [
                                          /* Break */Block.__(0, [
                                              "@ ",
                                              1,
                                              0
                                            ]),
                                          /* Char_literal */Block.__(12, [
                                              /* "`" */96,
                                              /* String */Block.__(2, [
                                                  /* No_padding */0,
                                                  /* String_literal */Block.__(11, [
                                                      " and `",
                                                      /* String */Block.__(2, [
                                                          /* No_padding */0,
                                                          /* Formatting_lit */Block.__(17, [
                                                              /* Break */Block.__(0, [
                                                                  "@ ",
                                                                  1,
                                                                  0
                                                                ]),
                                                              /* String_literal */Block.__(11, [
                                                                  "have the same hash value.",
                                                                  /* Formatting_lit */Block.__(17, [
                                                                      /* Break */Block.__(0, [
                                                                          "@ ",
                                                                          1,
                                                                          0
                                                                        ]),
                                                                      /* String_literal */Block.__(11, [
                                                                          "Change one of them.",
                                                                          /* End_of_format */0
                                                                        ])
                                                                    ])
                                                                ])
                                                            ])
                                                        ])
                                                    ])
                                                ])
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "In this program,@ variant constructors@ `%s and `%s@ have the same hash value.@ Change one of them."
                        ]), param[1], param[2]);
        }
        
      }));

var Subtype = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Subtype");

var Cannot_expand = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Cannot_expand");

var Recursive_abbrev = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Recursive_abbrev");

var Unification_recursive_abbrev = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Unification_recursive_abbrev");

var current_level = {
  contents: 0
};

var nongen_level = {
  contents: 0
};

var global_level = {
  contents: 1
};

var saved_level = {
  contents: /* [] */0
};

function init_def(level) {
  current_level.contents = level;
  nongen_level.contents = level;
  
}

function begin_def(param) {
  saved_level.contents = /* :: */[
    /* tuple */[
      current_level.contents,
      nongen_level.contents
    ],
    saved_level.contents
  ];
  current_level.contents = current_level.contents + 1 | 0;
  nongen_level.contents = current_level.contents;
  
}

function begin_class_def(param) {
  saved_level.contents = /* :: */[
    /* tuple */[
      current_level.contents,
      nongen_level.contents
    ],
    saved_level.contents
  ];
  current_level.contents = current_level.contents + 1 | 0;
  
}

function raise_nongen_level(param) {
  saved_level.contents = /* :: */[
    /* tuple */[
      current_level.contents,
      nongen_level.contents
    ],
    saved_level.contents
  ];
  nongen_level.contents = current_level.contents;
  
}

function end_def(param) {
  var match = List.hd(saved_level.contents);
  saved_level.contents = List.tl(saved_level.contents);
  current_level.contents = match[0];
  nongen_level.contents = match[1];
  
}

function reset_global_level(param) {
  global_level.contents = current_level.contents + 1 | 0;
  
}

function increase_global_level(param) {
  var gl = global_level.contents;
  global_level.contents = current_level.contents;
  return gl;
}

function is_object_type(path) {
  var name;
  switch (path.tag | 0) {
    case /* Pident */0 :
        name = path[0].name;
        break;
    case /* Pdot */1 :
        name = path[1];
        break;
    case /* Papply */2 :
        throw [
              Caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "ctype.ml",
                149,
                23
              ]
            ];
    
  }
  return Caml_string.get(name, 0) === /* "#" */35;
}

var trace_gadt_instances = {
  contents: false
};

function check_trace_gadt_instances(env) {
  if (!trace_gadt_instances.contents && env.local_constraints) {
    trace_gadt_instances.contents = true;
    cleanup_abbrev(void 0);
    return true;
  } else {
    return false;
  }
}

function reset_trace_gadt_instances(b) {
  if (b) {
    trace_gadt_instances.contents = false;
    return ;
  }
  
}

function wrap_trace_gadt_instances(env, f, x) {
  var b = check_trace_gadt_instances(env);
  var y = Curry._1(f, x);
  reset_trace_gadt_instances(b);
  return y;
}

var simple_abbrevs = {
  contents: /* Mnil */0
};

function proper_abbrevs(path, tl, abbrev) {
  if (tl !== /* [] */0 || trace_gadt_instances.contents || principal.contents || is_object_type(path)) {
    return abbrev;
  } else {
    return simple_abbrevs;
  }
}

function newvar(name, param) {
  return newty2(current_level.contents, /* Tvar */Block.__(0, [name]));
}

function new_global_var(name, param) {
  return newty2(global_level.contents, /* Tvar */Block.__(0, [name]));
}

function newobj(fields) {
  return newty2(current_level.contents, /* Tobject */Block.__(4, [
                fields,
                {
                  contents: void 0
                }
              ]));
}

function newconstr(path, tyl) {
  return newty2(current_level.contents, /* Tconstr */Block.__(3, [
                path,
                tyl,
                {
                  contents: /* Mnil */0
                }
              ]));
}

var none$2 = newty2(current_level.contents, /* Ttuple */Block.__(2, [/* [] */0]));

function equal$3(param, param$1) {
  if (param[0] === param$1[0]) {
    return param[1] === param$1[1];
  } else {
    return false;
  }
}

function hash$1(param) {
  return param[0].id + Caml_int32.imul(93, param[1].id) | 0;
}

var TypePairs = Hashtbl.Make({
      equal: equal$3,
      hash: hash$1
    });

var umode = {
  contents: /* Expression */0
};

var generate_equations = {
  contents: false
};

var assume_injective = {
  contents: false
};

function set_mode_pattern(generate, injective, f) {
  var old_unification_mode = umode.contents;
  var old_gen = generate_equations.contents;
  var old_inj = assume_injective.contents;
  try {
    umode.contents = /* Pattern */1;
    generate_equations.contents = generate;
    assume_injective.contents = injective;
    var ret = Curry._1(f, void 0);
    umode.contents = old_unification_mode;
    generate_equations.contents = old_gen;
    assume_injective.contents = old_inj;
    return ret;
  }
  catch (e){
    umode.contents = old_unification_mode;
    generate_equations.contents = old_gen;
    assume_injective.contents = old_inj;
    throw e;
  }
}

function in_current_module(param) {
  switch (param.tag | 0) {
    case /* Pident */0 :
        return true;
    case /* Pdot */1 :
    case /* Papply */2 :
        return false;
    
  }
}

function in_pervasives(p) {
  if (!in_current_module(p)) {
    return false;
  }
  try {
    find_type_full(p, initial_safe_string)[0];
    return true;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return false;
    }
    throw exn;
  }
}

function is_datatype(decl) {
  var match = decl.type_kind;
  if (typeof match === "number") {
    return match !== 0;
  } else {
    return true;
  }
}

function object_fields(ty) {
  var match = repr(ty).desc;
  if (typeof match === "number") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "ctype.ml",
            284,
            27
          ]
        ];
  }
  if (match.tag === /* Tobject */4) {
    return match[0];
  }
  throw [
        Caml_builtin_exceptions.assert_failure,
        /* tuple */[
          "ctype.ml",
          284,
          27
        ]
      ];
}

function flatten_fields(ty) {
  var flatten = function (_l, _ty) {
    while(true) {
      var ty = _ty;
      var l = _l;
      var ty$1 = repr(ty);
      var match = ty$1.desc;
      if (typeof match === "number") {
        return /* tuple */[
                l,
                ty$1
              ];
      }
      if (match.tag !== /* Tfield */5) {
        return /* tuple */[
                l,
                ty$1
              ];
      }
      _ty = match[3];
      _l = /* :: */[
        /* tuple */[
          match[0],
          match[1],
          match[2]
        ],
        l
      ];
      continue ;
    };
  };
  var match = flatten(/* [] */0, ty);
  return /* tuple */[
          List.sort((function (param, param$1) {
                  return Caml_primitive.caml_string_compare(param[0], param$1[0]);
                }), match[0]),
          match[1]
        ];
}

function build_fields(level) {
  return (function (param, param$1) {
      return List.fold_right((function (param, ty2) {
                    return newty2(level, /* Tfield */Block.__(5, [
                                  param[0],
                                  param[1],
                                  param[2],
                                  ty2
                                ]));
                  }), param, param$1);
    });
}

function associate_fields(fields1, fields2) {
  var _p = /* [] */0;
  var _s = /* [] */0;
  var _s$prime = /* [] */0;
  var _param = /* tuple */[
    fields1,
    fields2
  ];
  while(true) {
    var param = _param;
    var s$prime = _s$prime;
    var s = _s;
    var p = _p;
    var l = param[0];
    if (!param[1]) {
      return /* tuple */[
              List.rev(p),
              Pervasives.$at(List.rev(s), l),
              List.rev(s$prime)
            ];
    }
    if (!l) {
      return /* tuple */[
              List.rev(p),
              List.rev(s),
              Pervasives.$at(List.rev(s$prime), param[1])
            ];
    }
    var l$prime = param[1];
    var r$prime = l$prime[1];
    var match = l$prime[0];
    var t$prime = match[2];
    var k$prime = match[1];
    var n$prime = match[0];
    var r = l[1];
    var match$1 = l[0];
    var t = match$1[2];
    var k = match$1[1];
    var n = match$1[0];
    if (Caml_obj.caml_equal(n, n$prime)) {
      _param = /* tuple */[
        r,
        r$prime
      ];
      _p = /* :: */[
        /* tuple */[
          n,
          k,
          t,
          k$prime,
          t$prime
        ],
        p
      ];
      continue ;
    } else if (Caml_obj.caml_lessthan(n, n$prime)) {
      _param = /* tuple */[
        r,
        l$prime
      ];
      _s = /* :: */[
        /* tuple */[
          n,
          k,
          t
        ],
        s
      ];
      continue ;
    } else {
      _param = /* tuple */[
        l,
        r$prime
      ];
      _s$prime = /* :: */[
        /* tuple */[
          n$prime,
          k$prime,
          t$prime
        ],
        s$prime
      ];
      continue ;
    }
  };
}

function object_row(_ty) {
  while(true) {
    var ty = _ty;
    var ty$1 = repr(ty);
    var match = ty$1.desc;
    if (typeof match === "number") {
      return ty$1;
    }
    switch (match.tag | 0) {
      case /* Tobject */4 :
          _ty = match[0];
          continue ;
      case /* Tfield */5 :
          _ty = match[3];
          continue ;
      default:
        return ty$1;
    }
  };
}

function opened_object(ty) {
  var match = object_row(ty).desc;
  if (typeof match === "number") {
    return false;
  }
  switch (match.tag | 0) {
    case /* Tvar */0 :
    case /* Tconstr */3 :
    case /* Tunivar */9 :
        return true;
    default:
      return false;
  }
}

function concrete_object(ty) {
  var match = object_row(ty).desc;
  if (typeof match === "number" || match.tag) {
    return true;
  } else {
    return false;
  }
}

function close_object(ty) {
  var match = repr(ty).desc;
  if (typeof match === "number") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "ctype.ml",
            351,
            25
          ]
        ];
  }
  if (match.tag === /* Tobject */4) {
    var _ty = match[0];
    while(true) {
      var ty$1 = _ty;
      var ty$2 = repr(ty$1);
      var match$1 = ty$2.desc;
      if (typeof match$1 === "number") {
        throw [
              Caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "ctype.ml",
                347,
                30
              ]
            ];
      }
      switch (match$1.tag | 0) {
        case /* Tvar */0 :
            return link_type(ty$2, newty2(ty$2.level, /* Tnil */0));
        case /* Tfield */5 :
            _ty = match$1[3];
            continue ;
        default:
          throw [
                Caml_builtin_exceptions.assert_failure,
                /* tuple */[
                  "ctype.ml",
                  347,
                  30
                ]
              ];
      }
    };
  }
  throw [
        Caml_builtin_exceptions.assert_failure,
        /* tuple */[
          "ctype.ml",
          351,
          25
        ]
      ];
}

function row_variable(ty) {
  var match = repr(ty).desc;
  if (typeof match === "number") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "ctype.ml",
            365,
            23
          ]
        ];
  }
  if (match.tag === /* Tobject */4) {
    var _ty = match[0];
    while(true) {
      var ty$1 = _ty;
      var ty$2 = repr(ty$1);
      var match$1 = ty$2.desc;
      if (typeof match$1 === "number") {
        throw [
              Caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "ctype.ml",
                361,
                30
              ]
            ];
      }
      switch (match$1.tag | 0) {
        case /* Tvar */0 :
            return ty$2;
        case /* Tfield */5 :
            _ty = match$1[3];
            continue ;
        default:
          throw [
                Caml_builtin_exceptions.assert_failure,
                /* tuple */[
                  "ctype.ml",
                  361,
                  30
                ]
              ];
      }
    };
  }
  throw [
        Caml_builtin_exceptions.assert_failure,
        /* tuple */[
          "ctype.ml",
          365,
          23
        ]
      ];
}

function set_object_name(id, rv, params, ty) {
  var match = repr(ty).desc;
  if (typeof match === "number") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "ctype.ml",
            375,
            6
          ]
        ];
  }
  if (match.tag === /* Tobject */4) {
    return set_name(match[1], /* tuple */[
                /* Pident */Block.__(0, [id]),
                /* :: */[
                  rv,
                  params
                ]
              ]);
  }
  throw [
        Caml_builtin_exceptions.assert_failure,
        /* tuple */[
          "ctype.ml",
          375,
          6
        ]
      ];
}

function hide_private_methods(ty) {
  var match = repr(ty).desc;
  if (typeof match === "number") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "ctype.ml",
            397,
            6
          ]
        ];
  }
  if (match.tag !== /* Tobject */4) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "ctype.ml",
            397,
            6
          ]
        ];
  }
  match[1].contents = void 0;
  var match$1 = flatten_fields(match[0]);
  return List.iter((function (param) {
                var match = field_kind_repr(param[1]);
                if (typeof match === "number") {
                  return ;
                } else {
                  return set_kind(match[0], /* Fabsent */1);
                }
              }), match$1[0]);
}

function signature_of_class_type(_param) {
  while(true) {
    var param = _param;
    switch (param.tag | 0) {
      case /* Cty_signature */1 :
          return param[0];
      case /* Cty_constr */0 :
      case /* Cty_arrow */2 :
          _param = param[2];
          continue ;
      
    }
  };
}

function class_type_arity(_param) {
  while(true) {
    var param = _param;
    switch (param.tag | 0) {
      case /* Cty_constr */0 :
          _param = param[2];
          continue ;
      case /* Cty_signature */1 :
          return 0;
      case /* Cty_arrow */2 :
          return 1 + class_type_arity(param[2]) | 0;
      
    }
  };
}

function sort_row_fields(param) {
  return List.sort((function (param, param$1) {
                return Caml_primitive.caml_string_compare(param[0], param$1[0]);
              }), param);
}

function merge_row_fields(fi1, fi2) {
  var exit = 0;
  if (!fi1) {
    return /* tuple */[
            fi1,
            fi2,
            /* [] */0
          ];
  }
  if (!fi2) {
    return /* tuple */[
            fi1,
            fi2,
            /* [] */0
          ];
  }
  if (fi1[1]) {
    exit = 2;
  } else {
    if (!List.mem_assoc(fi1[0][0], fi2)) {
      return /* tuple */[
              fi1,
              fi2,
              /* [] */0
            ];
    }
    exit = 2;
  }
  if (exit === 2 && !fi2[1] && !List.mem_assoc(fi2[0][0], fi1)) {
    return /* tuple */[
            fi1,
            fi2,
            /* [] */0
          ];
  }
  var _r1 = /* [] */0;
  var _r2 = /* [] */0;
  var _pairs = /* [] */0;
  var _fi1 = sort_row_fields(fi1);
  var _fi2 = sort_row_fields(fi2);
  while(true) {
    var fi2$1 = _fi2;
    var fi1$1 = _fi1;
    var pairs = _pairs;
    var r2 = _r2;
    var r1 = _r1;
    if (!fi1$1) {
      return /* tuple */[
              List.rev(r1),
              List.rev_append(r2, fi2$1),
              pairs
            ];
    }
    if (!fi2$1) {
      return /* tuple */[
              List.rev_append(r1, fi1$1),
              List.rev(r2),
              pairs
            ];
    }
    var fi2$prime = fi2$1[1];
    var p2 = fi2$1[0];
    var l2 = p2[0];
    var fi1$prime = fi1$1[1];
    var p1 = fi1$1[0];
    var l1 = p1[0];
    if (Caml_obj.caml_equal(l1, l2)) {
      _fi2 = fi2$prime;
      _fi1 = fi1$prime;
      _pairs = /* :: */[
        /* tuple */[
          l1,
          p1[1],
          p2[1]
        ],
        pairs
      ];
      continue ;
    } else if (Caml_obj.caml_lessthan(l1, l2)) {
      _fi1 = fi1$prime;
      _r1 = /* :: */[
        p1,
        r1
      ];
      continue ;
    } else {
      _fi2 = fi2$prime;
      _r2 = /* :: */[
        p2,
        r2
      ];
      continue ;
    }
  };
}

function filter_row_fields(erase, param) {
  if (!param) {
    return /* [] */0;
  }
  var p = param[0];
  var fi = filter_row_fields(erase, param[1]);
  var match = row_field_repr_aux(/* [] */0, p[1]);
  if (typeof match === "number") {
    return fi;
  } else if (match.tag && !(match[2] || !erase)) {
    set_row_field(match[3], /* Rabsent */0);
    return fi;
  } else {
    return /* :: */[
            p,
            fi
          ];
  }
}

var Non_closed0 = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Non_closed0");

function closed_schema_rec(_ty) {
  while(true) {
    var ty = _ty;
    var ty$1 = repr(ty);
    if (ty$1.level < 0) {
      return ;
    }
    var level = ty$1.level;
    ty$1.level = pivot_level - level | 0;
    var match = ty$1.desc;
    if (typeof match === "number") {
      return iter_type_expr(closed_schema_rec, ty$1);
    }
    switch (match.tag | 0) {
      case /* Tvar */0 :
          if (level !== 100000000) {
            throw Non_closed0;
          }
          return iter_type_expr(closed_schema_rec, ty$1);
      case /* Tfield */5 :
          if (field_kind_repr(match[1]) === /* Fpresent */0) {
            closed_schema_rec(match[2]);
          }
          _ty = match[3];
          continue ;
      case /* Tvariant */8 :
          var row = row_repr_aux(/* [] */0, match[0]);
          iter_row(closed_schema_rec, row);
          if (static_row(row)) {
            return ;
          }
          _ty = row.row_more;
          continue ;
      default:
        return iter_type_expr(closed_schema_rec, ty$1);
    }
  };
}

function closed_schema(ty) {
  try {
    closed_schema_rec(ty);
    unmark_type(ty);
    return true;
  }
  catch (exn){
    if (exn !== Non_closed0) {
      throw exn;
    }
    unmark_type(ty);
    return false;
  }
}

var Non_closed = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Non_closed");

var free_variables = {
  contents: /* [] */0
};

var really_closed = {
  contents: void 0
};

function free_vars_rec(_real, _ty) {
  while(true) {
    var ty = _ty;
    var real = _real;
    var ty$1 = repr(ty);
    if (ty$1.level < 0) {
      return ;
    }
    ty$1.level = pivot_level - ty$1.level | 0;
    var match = ty$1.desc;
    var match$1 = really_closed.contents;
    if (typeof match === "number") {
      return iter_type_expr((function (param) {
                    return free_vars_rec(true, param);
                  }), ty$1);
    }
    switch (match.tag | 0) {
      case /* Tvar */0 :
          free_variables.contents = /* :: */[
            /* tuple */[
              ty$1,
              real
            ],
            free_variables.contents
          ];
          return ;
      case /* Tconstr */3 :
          if (match$1 === void 0) {
            return iter_type_expr((function (param) {
                          return free_vars_rec(true, param);
                        }), ty$1);
          }
          try {
            var match$2 = find_type_expansion(match[0], Caml_option.valFromOption(match$1));
            if (repr(match$2[1]).level !== 100000000) {
              free_variables.contents = /* :: */[
                /* tuple */[
                  ty$1,
                  real
                ],
                free_variables.contents
              ];
            }
            
          }
          catch (exn){
            if (exn !== Caml_builtin_exceptions.not_found) {
              throw exn;
            }
            
          }
          return List.iter((function (param) {
                        return free_vars_rec(true, param);
                      }), match[1]);
      case /* Tobject */4 :
          _ty = match[0];
          _real = false;
          continue ;
      case /* Tfield */5 :
          free_vars_rec(true, match[2]);
          _ty = match[3];
          _real = false;
          continue ;
      case /* Tvariant */8 :
          var row = row_repr_aux(/* [] */0, match[0]);
          iter_row((function (param) {
                  return free_vars_rec(true, param);
                }), row);
          if (static_row(row)) {
            return ;
          }
          _ty = row.row_more;
          _real = false;
          continue ;
      default:
        return iter_type_expr((function (param) {
                      return free_vars_rec(true, param);
                    }), ty$1);
    }
  };
}

function free_vars$1(env, ty) {
  free_variables.contents = /* [] */0;
  really_closed.contents = env;
  free_vars_rec(true, ty);
  var res = free_variables.contents;
  free_variables.contents = /* [] */0;
  really_closed.contents = void 0;
  return res;
}

function free_variables$1(env, ty) {
  var tl = List.map((function (prim) {
          return prim[0];
        }), free_vars$1(env, ty));
  unmark_type(ty);
  return tl;
}

function closed_type(ty) {
  var match = free_vars$1(void 0, ty);
  if (!match) {
    return ;
  }
  var match$1 = match[0];
  throw [
        Non_closed,
        match$1[0],
        match$1[1]
      ];
}

function closed_parameterized_type(params, ty) {
  List.iter(mark_type, params);
  var ok;
  try {
    closed_type(ty);
    ok = true;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] !== Non_closed) {
      throw exn;
    }
    ok = false;
  }
  List.iter(unmark_type, params);
  unmark_type(ty);
  return ok;
}

function closed_type_decl(decl) {
  try {
    List.iter(mark_type, decl.type_params);
    var match = decl.type_kind;
    if (typeof match === "number") {
      match === /* Type_abstract */0;
    } else if (match.tag) {
      List.iter((function (param) {
              if (param.cd_res !== void 0) {
                return ;
              } else {
                return List.iter(closed_type, param.cd_args);
              }
            }), match[0]);
    } else {
      List.iter((function (l) {
              return closed_type(l.ld_type);
            }), match[0]);
    }
    var match$1 = decl.type_manifest;
    if (match$1 !== void 0) {
      closed_type(match$1);
    }
    it_type_declaration(unmark_iterators, decl);
    return ;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] !== Non_closed) {
      throw exn;
    }
    it_type_declaration(unmark_iterators, decl);
    return exn[1];
  }
}

function closed_extension_constructor(ext) {
  try {
    List.iter(mark_type, ext.ext_type_params);
    var match = ext.ext_ret_type;
    if (match !== void 0) {
      
    } else {
      List.iter(closed_type, ext.ext_args);
    }
    unmark_extension_constructor(ext);
    return ;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] !== Non_closed) {
      throw exn;
    }
    unmark_extension_constructor(ext);
    return exn[1];
  }
}

var CCFailure = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.CCFailure");

function closed_class(params, sign) {
  var ty = object_fields(repr(sign.csig_self));
  var match = flatten_fields(ty);
  var fields = match[0];
  List.iter(mark_type, params);
  mark_type(match[1]);
  List.iter((function (param) {
          if (param[0] === dummy_method) {
            return mark_type(param[2]);
          }
          
        }), fields);
  try {
    mark_type_node(repr(sign.csig_self));
    List.iter((function (param) {
            var ty = param[2];
            if (field_kind_repr(param[1]) !== /* Fpresent */0) {
              return ;
            }
            try {
              return closed_type(ty);
            }
            catch (raw_exn){
              var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
              if (exn[0] === Non_closed) {
                throw [
                      CCFailure,
                      /* CC_Method */Block.__(0, [
                          exn[1],
                          exn[2],
                          param[0],
                          ty
                        ])
                    ];
              }
              throw exn;
            }
          }), fields);
    iter_type_expr(mark_type, repr(sign.csig_self));
    List.iter(unmark_type, params);
    unmark_class_signature(sign);
    return ;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] !== CCFailure) {
      throw exn;
    }
    iter_type_expr(mark_type, repr(sign.csig_self));
    List.iter(unmark_type, params);
    unmark_class_signature(sign);
    return exn[1];
  }
}

function iter_generalize(tyl, ty) {
  var ty$1 = repr(ty);
  if (!(ty$1.level > current_level.contents && ty$1.level !== 100000000)) {
    tyl.contents = /* :: */[
      ty$1,
      tyl.contents
    ];
    return ;
  }
  set_level(ty$1, 100000000);
  var match = ty$1.desc;
  if (typeof match !== "number" && match.tag === /* Tconstr */3) {
    iter_abbrev((function (param) {
            return iter_generalize(tyl, param);
          }), match[2].contents);
  }
  return iter_type_expr((function (param) {
                return iter_generalize(tyl, param);
              }), ty$1);
}

function iter_generalize$1(tyl, ty) {
  simple_abbrevs.contents = /* Mnil */0;
  return iter_generalize(tyl, ty);
}

function generalize(ty) {
  return iter_generalize$1({
              contents: /* [] */0
            }, ty);
}

function generalize_structure(var_level, ty) {
  var ty$1 = repr(ty);
  if (ty$1.level === 100000000) {
    return ;
  }
  if (is_Tvar(ty$1) && ty$1.level > var_level) {
    return set_level(ty$1, var_level);
  }
  var tmp = false;
  if (ty$1.level > current_level.contents) {
    var match = ty$1.desc;
    var tmp$1;
    tmp$1 = typeof match === "number" || match.tag !== /* Tconstr */3 ? true : !is_object_type(match[0]) && (match[2].contents = /* Mnil */0, true);
    tmp = tmp$1;
  }
  if (tmp) {
    set_level(ty$1, 100000000);
    return iter_type_expr((function (param) {
                  return generalize_structure(var_level, param);
                }), ty$1);
  }
  
}

function generalize_structure$1(var_level, ty) {
  simple_abbrevs.contents = /* Mnil */0;
  return generalize_structure(var_level, ty);
}

function generalize_spine(_ty) {
  while(true) {
    var ty = _ty;
    var ty$1 = repr(ty);
    if (ty$1.level < current_level.contents || ty$1.level === 100000000) {
      return ;
    }
    var match = ty$1.desc;
    if (typeof match === "number") {
      return ;
    }
    switch (match.tag | 0) {
      case /* Tarrow */1 :
          set_level(ty$1, 100000000);
          generalize_spine(match[1]);
          _ty = match[2];
          continue ;
      case /* Ttuple */2 :
          set_level(ty$1, 100000000);
          return List.iter(generalize_spine, match[0]);
      case /* Tconstr */3 :
          if (!is_object_type(match[0])) {
            set_level(ty$1, 100000000);
            match[2].contents = /* Mnil */0;
            return List.iter(generalize_spine, match[1]);
          } else {
            return ;
          }
      case /* Tpoly */10 :
          set_level(ty$1, 100000000);
          _ty = match[0];
          continue ;
      case /* Tpackage */11 :
          set_level(ty$1, 100000000);
          return List.iter(generalize_spine, match[2]);
      default:
        return ;
    }
  };
}

var forward_try_expand_once = {
  contents: (function (env, ty) {
      throw Cannot_expand;
    })
};

function get_level(env, p) {
  try {
    var match = find_type_full(p, env)[0].type_newtype_level;
    if (match !== void 0) {
      return match[0];
    } else {
      return binding_time(p);
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return binding_time(p);
    }
    throw exn;
  }
}

function normalize_package_path(env, _p) {
  while(true) {
    var p = _p;
    var t;
    try {
      t = find_modtype(p, env).mtd_type;
    }
    catch (exn){
      if (exn !== Caml_builtin_exceptions.not_found) {
        throw exn;
      }
      t = void 0;
    }
    if (t === void 0) {
      return p;
    }
    var match = t;
    if (match.tag) {
      return p;
    }
    _p = match[0];
    continue ;
  };
}

function update_level(env, level, _ty) {
  while(true) {
    var ty = _ty;
    var ty$1 = repr(ty);
    if (ty$1.level <= level) {
      return ;
    }
    var match = gadt_instance_level(env, ty$1);
    if (match !== void 0 && level < match) {
      throw [
            Unify,
            /* :: */[
              /* tuple */[
                ty$1,
                newty2(level, /* Tvar */Block.__(0, [void 0]))
              ],
              /* [] */0
            ]
          ];
    }
    var match$1 = ty$1.desc;
    if (typeof match$1 !== "number") {
      switch (match$1.tag | 0) {
        case /* Tconstr */3 :
            var p = match$1[0];
            if (level < get_level(env, p)) {
              try {
                link_type(ty$1, Curry._2(forward_try_expand_once.contents, env, ty$1));
                return update_level(env, level, ty$1);
              }
              catch (exn){
                if (exn !== Cannot_expand) {
                  throw exn;
                }
                if (level < get_level(env, p)) {
                  throw [
                        Unify,
                        /* :: */[
                          /* tuple */[
                            ty$1,
                            newty2(level, /* Tvar */Block.__(0, [void 0]))
                          ],
                          /* [] */0
                        ]
                      ];
                }
                return iter_type_expr((function (param) {
                              return update_level(env, level, param);
                            }), ty$1);
              }
            }
            break;
        case /* Tobject */4 :
            var nm = match$1[1];
            var match$2 = nm.contents;
            if (match$2 !== void 0 && level < get_level(env, match$2[0])) {
              set_name(nm, void 0);
              _ty = ty$1;
              continue ;
            }
            break;
        case /* Tfield */5 :
            var ty1 = match$1[2];
            if (match$1[0] === dummy_method && repr(ty1).level > level) {
              throw [
                    Unify,
                    /* :: */[
                      /* tuple */[
                        ty1,
                        newty2(level, /* Tvar */Block.__(0, [void 0]))
                      ],
                      /* [] */0
                    ]
                  ];
            }
            break;
        case /* Tvariant */8 :
            var row = row_repr_aux(/* [] */0, match$1[0]);
            var match$3 = row.row_name;
            if (match$3 !== void 0 && level < get_level(env, match$3[0])) {
              log_type(ty$1);
              ty$1.desc = /* Tvariant */Block.__(8, [{
                    row_fields: row.row_fields,
                    row_more: row.row_more,
                    row_bound: row.row_bound,
                    row_closed: row.row_closed,
                    row_fixed: row.row_fixed,
                    row_name: void 0
                  }]);
            }
            set_level(ty$1, level);
            return iter_type_expr((function (param) {
                          return update_level(env, level, param);
                        }), ty$1);
        case /* Tpackage */11 :
            var p$1 = match$1[0];
            if (level < get_level(env, p$1)) {
              var p$prime = normalize_package_path(env, p$1);
              if (same(p$1, p$prime)) {
                throw [
                      Unify,
                      /* :: */[
                        /* tuple */[
                          ty$1,
                          newty2(level, /* Tvar */Block.__(0, [void 0]))
                        ],
                        /* [] */0
                      ]
                    ];
              }
              log_type(ty$1);
              ty$1.desc = /* Tpackage */Block.__(11, [
                  p$prime,
                  match$1[1],
                  match$1[2]
                ]);
              _ty = ty$1;
              continue ;
            }
            break;
        default:
          
      }
    }
    set_level(ty$1, level);
    return iter_type_expr((function (param) {
                  return update_level(env, level, param);
                }), ty$1);
  };
}

function generalize_contravariant(env) {
  if (principal.contents) {
    return generalize_structure$1;
  } else {
    return (function (param, param$1) {
        return update_level(env, param, param$1);
      });
  }
}

function generalize_expansive(env, var_level, _ty) {
  while(true) {
    var ty = _ty;
    var ty$1 = repr(ty);
    if (ty$1.level === 100000000) {
      return ;
    }
    if (ty$1.level <= var_level) {
      return ;
    }
    set_level(ty$1, 100000000);
    var match = ty$1.desc;
    if (typeof match === "number") {
      return iter_type_expr((function (param) {
                    return generalize_expansive(env, var_level, param);
                  }), ty$1);
    }
    switch (match.tag | 0) {
      case /* Tarrow */1 :
          generalize_contravariant(env)(var_level, match[1]);
          _ty = match[2];
          continue ;
      case /* Tconstr */3 :
          var tyl = match[1];
          var variance;
          try {
            variance = find_type_full(match[0], env)[0].type_variance;
          }
          catch (exn){
            if (exn !== Caml_builtin_exceptions.not_found) {
              throw exn;
            }
            variance = List.map((function (param) {
                    return Types_Variance.may_inv;
                  }), tyl);
          }
          match[2].contents = /* Mnil */0;
          return List.iter2((function (v, t) {
                        if (Curry._2(Types_Variance.mem, /* May_weak */2, v)) {
                          return generalize_contravariant(env)(var_level, t);
                        } else {
                          return generalize_expansive(env, var_level, t);
                        }
                      }), variance, tyl);
      case /* Tpackage */11 :
          var partial_arg = generalize_contravariant(env);
          return List.iter((function(partial_arg){
                    return function (param) {
                      return partial_arg(var_level, param);
                    }
                    }(partial_arg)), match[2]);
      default:
        return iter_type_expr((function (param) {
                      return generalize_expansive(env, var_level, param);
                    }), ty$1);
    }
  };
}

function generalize_expansive$1(env, ty) {
  simple_abbrevs.contents = /* Mnil */0;
  try {
    return generalize_expansive(env, nongen_level.contents, ty);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] !== Unify) {
      throw exn;
    }
    var tr = exn[1];
    if (!tr) {
      throw exn;
    }
    if (tr[1]) {
      throw exn;
    }
    throw [
          Unify,
          /* :: */[
            /* tuple */[
              ty,
              tr[0][1]
            ],
            tr
          ]
        ];
  }
}

function generalize_structure$2(ty) {
  return generalize_structure$1(current_level.contents, ty);
}

function limited_generalize(ty0, ty) {
  var ty0$1 = repr(ty0);
  var graph = Hashtbl.create(void 0, 17);
  var idx = {
    contents: 0
  };
  var roots = {
    contents: /* [] */0
  };
  var inverse = function (pty, ty) {
    var ty$1 = repr(ty);
    if (ty$1.level > current_level.contents || ty$1.level === 100000000) {
      idx.contents = idx.contents - 1 | 0;
      Hashtbl.add(graph, idx.contents, /* tuple */[
            ty$1,
            {
              contents: pty
            }
          ]);
      if (ty$1.level === 100000000 || ty$1 === ty0$1) {
        roots.contents = /* :: */[
          ty$1,
          roots.contents
        ];
      }
      set_level(ty$1, idx.contents);
      var partial_arg = /* :: */[
        ty$1,
        /* [] */0
      ];
      return iter_type_expr((function (param) {
                    return inverse(partial_arg, param);
                  }), ty$1);
    } else {
      if (ty$1.level >= 0) {
        return ;
      }
      var match = Hashtbl.find(graph, ty$1.level);
      var parents = match[1];
      parents.contents = Pervasives.$at(pty, parents.contents);
      return ;
    }
  };
  var generalize_parents = function (ty) {
    var idx = ty.level;
    if (idx === 100000000) {
      return ;
    }
    set_level(ty, 100000000);
    List.iter(generalize_parents, Hashtbl.find(graph, idx)[1].contents);
    var match = ty.desc;
    if (typeof match === "number") {
      return ;
    }
    if (match.tag !== /* Tvariant */8) {
      return ;
    }
    var more = row_more(match[0]);
    var lv = more.level;
    if ((lv < 0 || lv > current_level.contents) && lv !== 100000000) {
      return set_level(more, 100000000);
    }
    
  };
  inverse(/* [] */0, ty);
  if (ty0$1.level < 0) {
    iter_type_expr((function (param) {
            return inverse(/* [] */0, param);
          }), ty0$1);
  }
  List.iter(generalize_parents, roots.contents);
  return Hashtbl.iter((function (param, param$1) {
                var ty = param$1[0];
                if (ty.level !== 100000000) {
                  return set_level(ty, current_level.contents);
                }
                
              }), graph);
}

function inv_type(hash, pty, ty) {
  var ty$1 = repr(ty);
  try {
    var inv = Curry._2(TypeHash.find, hash, ty$1);
    inv.inv_parents = Pervasives.$at(pty, inv.inv_parents);
    return ;
  }
  catch (exn){
    if (exn !== Caml_builtin_exceptions.not_found) {
      throw exn;
    }
    var inv$1 = {
      inv_type: ty$1,
      inv_parents: pty
    };
    Curry._3(TypeHash.add, hash, ty$1, inv$1);
    var partial_arg = /* :: */[
      inv$1,
      /* [] */0
    ];
    return iter_type_expr((function (param) {
                  return inv_type(hash, partial_arg, param);
                }), ty$1);
  }
}

function compute_univars(ty) {
  var inverted = Curry._1(TypeHash.create, 17);
  inv_type(inverted, /* [] */0, ty);
  var node_univars = Curry._1(TypeHash.create, 17);
  var add_univar = function (univ, inv) {
    var match = inv.inv_type.desc;
    if (typeof match !== "number" && match.tag === /* Tpoly */10 && List.memq(univ, List.map(repr, match[1]))) {
      return ;
    }
    try {
      var univs = Curry._2(TypeHash.find, node_univars, inv.inv_type);
      if (!mem$3(univ, univs.contents)) {
        univs.contents = add$3(univ, univs.contents);
        return List.iter((function (param) {
                      return add_univar(univ, param);
                    }), inv.inv_parents);
      } else {
        return ;
      }
    }
    catch (exn){
      if (exn !== Caml_builtin_exceptions.not_found) {
        throw exn;
      }
      Curry._3(TypeHash.add, node_univars, inv.inv_type, {
            contents: singleton$1(univ)
          });
      return List.iter((function (param) {
                    return add_univar(univ, param);
                  }), inv.inv_parents);
    }
  };
  Curry._2(TypeHash.iter, (function (ty, inv) {
          if (is_Tunivar(ty)) {
            return add_univar(ty, inv);
          }
          
        }), inverted);
  return (function (ty) {
      try {
        return Curry._2(TypeHash.find, node_univars, ty).contents;
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          return /* Empty */0;
        }
        throw exn;
      }
    });
}

function find_repr(p1, _param) {
  while(true) {
    var param = _param;
    if (typeof param === "number") {
      return ;
    }
    if (param.tag) {
      var rem = param[0].contents;
      _param = rem;
      continue ;
    } else if (param[0]) {
      if (same(p1, param[1])) {
        return param[2];
      }
      _param = param[4];
      continue ;
    } else {
      _param = param[4];
      continue ;
    }
  };
}

var abbreviations = {
  contents: {
    contents: /* Mnil */0
  }
};

function copy(env, partial, keep_names, ty) {
  var copy$1 = function (param) {
    return copy(env, partial, keep_names, param);
  };
  var ty$1 = repr(ty);
  var match = ty$1.desc;
  var exit = 0;
  if (typeof match === "number") {
    exit = 1;
  } else {
    if (match.tag === /* Tsubst */7) {
      return match[0];
    }
    exit = 1;
  }
  if (exit === 1) {
    if (ty$1.level !== 100000000 && partial === void 0) {
      return ty$1;
    }
    var forget;
    if (ty$1.level === 100000000) {
      forget = 100000000;
    } else {
      if (partial === void 0) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "ctype.ml",
                984,
                16
              ]
            ];
      }
      var match$1 = partial;
      var param = Curry._1(match$1[0], ty$1);
      forget = (
        param ? false : true
      ) ? (
          match$1[1] ? ty$1.level : current_level.contents
        ) : 100000000;
    }
    if (forget !== 100000000) {
      return newty2(forget, /* Tvar */Block.__(0, [void 0]));
    }
    var desc = ty$1.desc;
    save_desc(ty$1, desc);
    var t = newvar(void 0, void 0);
    if (env !== void 0) {
      var env$1 = Caml_option.valFromOption(env);
      if (env$1.local_constraints) {
        var match$2 = gadt_instance_level(env$1, ty$1);
        if (match$2 !== void 0) {
          add_gadt_instances(env$1, match$2, /* :: */[
                t,
                /* [] */0
              ]);
        }
        
      }
      
    }
    ty$1.desc = /* Tsubst */Block.__(7, [t]);
    var tmp;
    if (typeof desc === "number") {
      tmp = copy_type_desc(keep_names, copy$1, desc);
    } else {
      switch (desc.tag | 0) {
        case /* Tconstr */3 :
            var tl = desc[1];
            var p = desc[0];
            var abbrevs = proper_abbrevs(p, tl, abbreviations.contents);
            var match$3 = find_repr(p, abbrevs.contents);
            var exit$1 = 0;
            if (match$3 !== void 0) {
              var ty$2 = match$3;
              if (repr(ty$2) !== t) {
                tmp = /* Tlink */Block.__(6, [ty$2]);
              } else {
                exit$1 = 2;
              }
            } else {
              exit$1 = 2;
            }
            if (exit$1 === 2) {
              var abbrev = abbreviations.contents.contents;
              var tmp$1;
              tmp$1 = typeof abbrev === "number" || abbrev.tag ? abbrev : /* Mlink */Block.__(1, [abbreviations.contents]);
              tmp = /* Tconstr */Block.__(3, [
                  p,
                  List.map(copy$1, tl),
                  {
                    contents: tmp$1
                  }
                ]);
            }
            break;
        case /* Tobject */4 :
            tmp = partial !== void 0 ? /* Tobject */Block.__(4, [
                  copy$1(desc[0]),
                  {
                    contents: void 0
                  }
                ]) : copy_type_desc(keep_names, copy$1, desc);
            break;
        case /* Tfield */5 :
            var match$4 = field_kind_repr(desc[1]);
            if (typeof match$4 === "number") {
              tmp = match$4 !== 0 ? /* Tlink */Block.__(6, [copy$1(desc[3])]) : copy_type_desc(void 0, copy$1, desc);
            } else {
              dup_kind(match$4[0]);
              tmp = copy_type_desc(void 0, copy$1, desc);
            }
            break;
        case /* Tvariant */8 :
            var row = row_repr_aux(/* [] */0, desc[0]);
            var more = repr(row.row_more);
            var match$5 = more.desc;
            var exit$2 = 0;
            if (typeof match$5 === "number" || match$5.tag !== /* Tsubst */7) {
              exit$2 = 2;
            } else {
              var match$6 = match$5[0].desc;
              if (typeof match$6 === "number" || match$6.tag !== /* Ttuple */2) {
                exit$2 = 2;
              } else {
                var match$7 = match$6[0];
                if (match$7) {
                  var match$8 = match$7[1];
                  if (match$8 && !match$8[1]) {
                    var ty2 = match$8[0];
                    ty$1.desc = /* Tsubst */Block.__(7, [ty2]);
                    tmp = /* Tlink */Block.__(6, [ty2]);
                  } else {
                    exit$2 = 2;
                  }
                } else {
                  exit$2 = 2;
                }
              }
            }
            if (exit$2 === 2) {
              var keep = more.level !== 100000000;
              var match$9 = more.desc;
              var more$prime;
              var exit$3 = 0;
              if (typeof match$9 === "number") {
                exit$3 = 3;
              } else {
                switch (match$9.tag | 0) {
                  case /* Tconstr */3 :
                      exit$3 = 3;
                      break;
                  case /* Tsubst */7 :
                      more$prime = match$9[0];
                      break;
                  case /* Tvar */0 :
                  case /* Tunivar */9 :
                      exit$3 = 4;
                      break;
                  default:
                    throw [
                          Caml_builtin_exceptions.assert_failure,
                          /* tuple */[
                            "ctype.ml",
                            1047,
                            24
                          ]
                        ];
                }
              }
              switch (exit$3) {
                case 3 :
                    if (keep) {
                      save_desc(more, more.desc);
                    }
                    more$prime = copy$1(more);
                    break;
                case 4 :
                    save_desc(more, more.desc);
                    more$prime = keep ? more : newty2(current_level.contents, more.desc);
                    break;
                
              }
              var match$10 = repr(more$prime);
              var match$11 = match$10.desc;
              var row$1;
              row$1 = typeof match$11 === "number" || !(match$11.tag === /* Tconstr */3 && !row.row_fixed) ? row : ({
                    row_fields: row.row_fields,
                    row_more: row.row_more,
                    row_bound: row.row_bound,
                    row_closed: row.row_closed,
                    row_fixed: true,
                    row_name: row.row_name
                  });
              var match$12;
              if (partial !== void 0) {
                var match$13 = partial;
                if (match$13[1]) {
                  match$12 = /* tuple */[
                    more$prime,
                    row$1
                  ];
                } else {
                  var more$prime$1;
                  if (more.id !== more$prime.id) {
                    more$prime$1 = more$prime;
                  } else {
                    var lv = keep ? more.level : current_level.contents;
                    more$prime$1 = newty2(lv, /* Tvar */Block.__(0, [void 0]));
                  }
                  var not_reither = function (param) {
                    var match = row_field_repr_aux(/* [] */0, param[1]);
                    if (typeof match === "number" || !match.tag) {
                      return true;
                    } else {
                      return false;
                    }
                  };
                  var tmp$2 = false;
                  if (row$1.row_closed) {
                    var tmp$3 = false;
                    if (!row$1.row_fixed) {
                      var param$1 = Curry._1(match$13[0], ty$1);
                      tmp$3 = (
                        param$1 ? false : true
                      ) && !List.for_all(not_reither, row$1.row_fields);
                    }
                    tmp$2 = tmp$3;
                  }
                  match$12 = tmp$2 ? /* tuple */[
                      more$prime$1,
                      {
                        row_fields: List.filter(not_reither)(row$1.row_fields),
                        row_more: more$prime$1,
                        row_bound: void 0,
                        row_closed: false,
                        row_fixed: false,
                        row_name: void 0
                      }
                    ] : /* tuple */[
                      more$prime$1,
                      row$1
                    ];
                }
              } else {
                match$12 = /* tuple */[
                  more$prime,
                  row$1
                ];
              }
              var more$prime$2 = match$12[0];
              more.desc = /* Tsubst */Block.__(7, [newty2(100000000, /* Ttuple */Block.__(2, [/* :: */[
                            more$prime$2,
                            /* :: */[
                              t,
                              /* [] */0
                            ]
                          ]]))]);
              tmp = /* Tvariant */Block.__(8, [copy_row(copy$1, true, match$12[1], keep, more$prime$2)]);
            }
            break;
        default:
          tmp = copy_type_desc(keep_names, copy$1, desc);
      }
    }
    t.desc = tmp;
    return t;
  }
  
}

function simple_copy(t) {
  return copy(void 0, void 0, void 0, t);
}

function gadt_env(env) {
  if (env.local_constraints) {
    return Caml_option.some(env);
  }
  
}

function instance(partial, env, sch) {
  var env$1 = gadt_env(env);
  var partial$1 = partial !== void 0 ? /* tuple */[
      compute_univars(sch),
      partial
    ] : void 0;
  var ty = copy(env$1, partial$1, void 0, sch);
  cleanup_types(void 0);
  return ty;
}

function instance_def(sch) {
  var ty = copy(void 0, void 0, void 0, sch);
  cleanup_types(void 0);
  return ty;
}

function instance_list(env, schl) {
  var env$1 = gadt_env(env);
  var tyl = List.map((function (t) {
          return copy(env$1, void 0, void 0, t);
        }), schl);
  cleanup_types(void 0);
  return tyl;
}

var reified_var_counter = {
  contents: /* Empty */0
};

function get_new_abstract_name(s) {
  var index;
  try {
    index = find(s, reified_var_counter.contents) + 1 | 0;
  }
  catch (exn){
    if (exn !== Caml_builtin_exceptions.not_found) {
      throw exn;
    }
    index = 0;
  }
  reified_var_counter.contents = add$1(s, index, reified_var_counter.contents);
  return Curry._2(Printf.sprintf(/* Format */[
                  /* String */Block.__(2, [
                      /* No_padding */0,
                      /* Char_literal */Block.__(12, [
                          /* "#" */35,
                          /* Int */Block.__(4, [
                              /* Int_d */0,
                              /* No_padding */0,
                              /* No_precision */0,
                              /* End_of_format */0
                            ])
                        ])
                    ]),
                  "%s#%d"
                ]), s, index);
}

function new_declaration(newtype, manifest) {
  return {
          type_params: /* [] */0,
          type_arity: 0,
          type_kind: /* Type_abstract */0,
          type_private: /* Public */1,
          type_manifest: manifest,
          type_variance: /* [] */0,
          type_newtype_level: newtype,
          type_loc: none,
          type_attributes: /* [] */0
        };
}

function instance_constructor(in_pattern, cstr) {
  if (in_pattern !== void 0) {
    var match = in_pattern;
    var newtype_lev = match[1];
    var env = match[0];
    var $$process = function (existential) {
      var decl = new_declaration(/* tuple */[
            newtype_lev,
            newtype_lev
          ], void 0);
      var match = repr(existential);
      var match$1 = match.desc;
      var name;
      if (typeof match$1 === "number" || match$1.tag) {
        name = "ex";
      } else {
        var match$2 = match$1[0];
        name = match$2 !== void 0 ? match$2 : "ex";
      }
      var match$3 = enter_type(get_new_abstract_name(name), decl, env.contents);
      env.contents = match$3[1];
      var to_unify = newty2(current_level.contents, /* Tconstr */Block.__(3, [
              /* Pident */Block.__(0, [match$3[0]]),
              /* [] */0,
              {
                contents: /* Mnil */0
              }
            ]));
      var tv = copy(void 0, void 0, void 0, existential);
      if (!is_Tvar(tv)) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "ctype.ml",
                1170,
                8
              ]
            ];
      }
      return link_type(tv, to_unify);
    };
    List.iter($$process, cstr.cstr_existentials);
  }
  var ty_res = copy(void 0, void 0, void 0, cstr.cstr_res);
  var ty_args = List.map(simple_copy, cstr.cstr_args);
  cleanup_types(void 0);
  return /* tuple */[
          ty_args,
          ty_res
        ];
}

function instance_parameterized_type(keep_names, sch_args, sch) {
  var ty_args = List.map((function (t) {
          return copy(void 0, void 0, keep_names, t);
        }), sch_args);
  var ty = copy(void 0, void 0, void 0, sch);
  cleanup_types(void 0);
  return /* tuple */[
          ty_args,
          ty
        ];
}

function instance_declaration(decl) {
  var match = decl.type_kind;
  var tmp;
  tmp = typeof match === "number" ? (
      match === /* Type_abstract */0 ? /* Type_abstract */0 : /* Type_open */1
    ) : (
      match.tag ? /* Type_variant */Block.__(1, [List.map((function (c) {
                    return {
                            cd_id: c.cd_id,
                            cd_args: List.map(simple_copy, c.cd_args),
                            cd_res: may_map(simple_copy, c.cd_res),
                            cd_loc: c.cd_loc,
                            cd_attributes: c.cd_attributes
                          };
                  }), match[0])]) : /* Type_record */Block.__(0, [
            List.map((function (l) {
                    return {
                            ld_id: l.ld_id,
                            ld_mutable: l.ld_mutable,
                            ld_type: copy(void 0, void 0, void 0, l.ld_type),
                            ld_loc: l.ld_loc,
                            ld_attributes: l.ld_attributes
                          };
                  }), match[0]),
            match[1]
          ])
    );
  var decl_type_params = List.map(simple_copy, decl.type_params);
  var decl_type_arity = decl.type_arity;
  var decl_type_private = decl.type_private;
  var decl_type_manifest = may_map(simple_copy, decl.type_manifest);
  var decl_type_variance = decl.type_variance;
  var decl_type_newtype_level = decl.type_newtype_level;
  var decl_type_loc = decl.type_loc;
  var decl_type_attributes = decl.type_attributes;
  var decl$1 = {
    type_params: decl_type_params,
    type_arity: decl_type_arity,
    type_kind: tmp,
    type_private: decl_type_private,
    type_manifest: decl_type_manifest,
    type_variance: decl_type_variance,
    type_newtype_level: decl_type_newtype_level,
    type_loc: decl_type_loc,
    type_attributes: decl_type_attributes
  };
  cleanup_types(void 0);
  return decl$1;
}

function instance_class(params, cty) {
  var copy_class_type = function (param) {
    switch (param.tag | 0) {
      case /* Cty_constr */0 :
          return /* Cty_constr */Block.__(0, [
                    param[0],
                    List.map(simple_copy, param[1]),
                    copy_class_type(param[2])
                  ]);
      case /* Cty_signature */1 :
          var sign = param[0];
          return /* Cty_signature */Block.__(1, [{
                      csig_self: copy(void 0, void 0, void 0, sign.csig_self),
                      csig_vars: map((function (param) {
                              return /* tuple */[
                                      param[0],
                                      param[1],
                                      copy(void 0, void 0, void 0, param[2])
                                    ];
                            }), sign.csig_vars),
                      csig_concr: sign.csig_concr,
                      csig_inher: List.map((function (param) {
                              return /* tuple */[
                                      param[0],
                                      List.map(simple_copy, param[1])
                                    ];
                            }), sign.csig_inher)
                    }]);
      case /* Cty_arrow */2 :
          return /* Cty_arrow */Block.__(2, [
                    param[0],
                    copy(void 0, void 0, void 0, param[1]),
                    copy_class_type(param[2])
                  ]);
      
    }
  };
  var params$prime = List.map(simple_copy, params);
  var cty$prime = copy_class_type(cty);
  cleanup_types(void 0);
  return /* tuple */[
          params$prime,
          cty$prime
        ];
}

function diff_list(l1, l2) {
  if (l1 === l2) {
    return /* [] */0;
  }
  if (l1) {
    return /* :: */[
            l1[0],
            diff_list(l1[1], l2)
          ];
  }
  throw [
        Caml_builtin_exceptions.invalid_argument,
        "Ctype.diff_list"
      ];
}

function conflicts(free, bound) {
  var bound$1 = List.map(repr, bound);
  return exists((function (t) {
                return List.memq(repr(t), bound$1);
              }), free);
}

var delayed_copy = {
  contents: /* [] */0
};

function copy_sep(fixed, free, bound, visited, ty) {
  var ty$1 = repr(ty);
  var univars = Curry._1(free, ty$1);
  if (univars ? false : true) {
    if (ty$1.level !== 100000000) {
      return ty$1;
    }
    var t = newvar(void 0, void 0);
    delayed_copy.contents = /* :: */[
      Caml_obj.caml_lazy_make((function (param) {
              t.desc = /* Tlink */Block.__(6, [copy(void 0, void 0, void 0, ty$1)]);
              
            })),
      delayed_copy.contents
    ];
    return t;
  } else {
    try {
      var match = List.assq(ty$1, visited);
      var dl = is_Tunivar(ty$1) ? /* [] */0 : diff_list(bound, match[1]);
      if (dl !== /* [] */0 && conflicts(univars, dl)) {
        throw Caml_builtin_exceptions.not_found;
      }
      return match[0];
    }
    catch (exn){
      if (exn !== Caml_builtin_exceptions.not_found) {
        throw exn;
      }
      var t$1 = newvar(void 0, void 0);
      var match$1 = ty$1.desc;
      var visited$1;
      var exit = 0;
      if (typeof match$1 === "number") {
        visited$1 = visited;
      } else {
        switch (match$1.tag | 0) {
          case /* Tarrow */1 :
          case /* Ttuple */2 :
          case /* Tconstr */3 :
          case /* Tobject */4 :
          case /* Tvariant */8 :
          case /* Tpackage */11 :
              exit = 1;
              break;
          default:
            visited$1 = visited;
        }
      }
      if (exit === 1) {
        visited$1 = /* :: */[
          /* tuple */[
            ty$1,
            /* tuple */[
              t$1,
              bound
            ]
          ],
          visited
        ];
      }
      var copy_rec = function (param) {
        return copy_sep(fixed, free, bound, visited$1, param);
      };
      var match$2 = ty$1.desc;
      var tmp;
      if (typeof match$2 === "number") {
        tmp = copy_type_desc(void 0, copy_rec, ty$1.desc);
      } else {
        switch (match$2.tag | 0) {
          case /* Tvariant */8 :
              var row = row_repr_aux(/* [] */0, match$2[0]);
              var more = repr(row.row_more);
              var keep = is_Tvar(more) && more.level !== 100000000;
              var more$prime = copy_rec(more);
              var fixed$prime = fixed && is_Tvar(repr(more$prime));
              var row$1 = copy_row(copy_rec, fixed$prime, row, keep, more$prime);
              tmp = /* Tvariant */Block.__(8, [row$1]);
              break;
          case /* Tpoly */10 :
              var tl = List.map(repr, match$2[1]);
              var tl$prime = List.map((function (t) {
                      return newty2(current_level.contents, t.desc);
                    }), tl);
              var bound$1 = Pervasives.$at(tl, bound);
              var visited$2 = Pervasives.$at(List.map2((function (ty, t) {
                          return /* tuple */[
                                  ty,
                                  /* tuple */[
                                    t,
                                    bound$1
                                  ]
                                ];
                        }), tl, tl$prime), visited$1);
              tmp = /* Tpoly */Block.__(10, [
                  copy_sep(fixed, free, bound$1, visited$2, match$2[0]),
                  tl$prime
                ]);
              break;
          default:
            tmp = copy_type_desc(void 0, copy_rec, ty$1.desc);
        }
      }
      t$1.desc = tmp;
      return t$1;
    }
  }
}

function instance_poly(keep_namesOpt, fixed, univars, sch) {
  var keep_names = keep_namesOpt !== void 0 ? keep_namesOpt : false;
  var univars$1 = List.map(repr, univars);
  var copy_var = function (ty) {
    var match = ty.desc;
    if (typeof match === "number") {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "ctype.ml",
              1307,
              11
            ]
          ];
    }
    if (match.tag === /* Tunivar */9) {
      if (keep_names) {
        return newty2(current_level.contents, /* Tvar */Block.__(0, [match[0]]));
      } else {
        return newvar(void 0, void 0);
      }
    }
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "ctype.ml",
            1307,
            11
          ]
        ];
  };
  var vars = List.map(copy_var, univars$1);
  var pairs = List.map2((function (u, v) {
          return /* tuple */[
                  u,
                  /* tuple */[
                    v,
                    /* [] */0
                  ]
                ];
        }), univars$1, vars);
  delayed_copy.contents = /* [] */0;
  var ty = copy_sep(fixed, compute_univars(sch), /* [] */0, pairs, sch);
  List.iter(CamlinternalLazy.force, delayed_copy.contents);
  delayed_copy.contents = /* [] */0;
  cleanup_types(void 0);
  return /* tuple */[
          vars,
          ty
        ];
}

function instance_label(fixed, lbl) {
  var ty_res = copy(void 0, void 0, void 0, lbl.lbl_res);
  var ty = repr(lbl.lbl_arg);
  var match = ty.desc;
  var match$1;
  var exit = 0;
  if (typeof match === "number" || match.tag !== /* Tpoly */10) {
    exit = 1;
  } else {
    match$1 = instance_poly(void 0, fixed, match[1], match[0]);
  }
  if (exit === 1) {
    match$1 = /* tuple */[
      /* [] */0,
      copy(void 0, void 0, void 0, lbl.lbl_arg)
    ];
  }
  cleanup_types(void 0);
  return /* tuple */[
          match$1[0],
          match$1[1],
          ty_res
        ];
}

var unify$prime = {
  contents: (function (env, ty1, ty2) {
      throw [
            Unify,
            /* [] */0
          ];
    })
};

function subst(env, level, priv, abbrev, ty, params, args, body) {
  if (List.length(params) !== List.length(args)) {
    throw [
          Unify,
          /* [] */0
        ];
  }
  var old_level = current_level.contents;
  current_level.contents = level;
  try {
    var body0 = newvar(void 0, void 0);
    if (ty !== void 0) {
      var ty$1 = ty;
      var match = ty$1.desc;
      if (typeof match === "number") {
        throw [
              Caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "ctype.ml",
                1347,
                8
              ]
            ];
      }
      if (match.tag !== /* Tconstr */3) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "ctype.ml",
                1347,
                8
              ]
            ];
      }
      var path = match[0];
      var abbrev$1 = proper_abbrevs(path, match[1], abbrev);
      memorize_abbrev(abbrev$1, priv, path, ty$1, body0);
    }
    abbreviations.contents = abbrev;
    var match$1 = instance_parameterized_type(void 0, params, body);
    var body$prime = match$1[1];
    abbreviations.contents = {
      contents: /* Mnil */0
    };
    Curry._3(unify$prime.contents, env, body0, body$prime);
    List.iter2(Curry._1(unify$prime.contents, env), match$1[0], args);
    current_level.contents = old_level;
    return body$prime;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] !== Unify) {
      throw exn;
    }
    current_level.contents = old_level;
    throw exn;
  }
}

var previous_env = {
  contents: empty
};

function check_abbrev_env(env) {
  if (env !== previous_env.contents) {
    cleanup_abbrev(void 0);
    previous_env.contents = env;
    return ;
  }
  
}

function expand_abbrev_gen(kind, find_type_expansion, env, ty) {
  check_abbrev_env(env);
  var match = ty.desc;
  if (typeof match === "number") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "ctype.ml",
            1456,
            6
          ]
        ];
  }
  if (match.tag !== /* Tconstr */3) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "ctype.ml",
            1456,
            6
          ]
        ];
  }
  var abbrev = match[2];
  var args = match[1];
  var path = match[0];
  var level = ty.level;
  var lookup_abbrev = proper_abbrevs(path, args, abbrev);
  var match$1 = find_expans(kind, path, lookup_abbrev.contents);
  if (match$1 !== void 0) {
    var ty$1 = match$1;
    if (level !== 100000000) {
      try {
        update_level(env, level, ty$1);
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn[0] !== Unify) {
          throw exn;
        }
        
      }
    }
    return ty$1;
  } else {
    var match$2;
    try {
      match$2 = Curry._2(find_type_expansion, path, env);
    }
    catch (exn$1){
      if (exn$1 === Caml_builtin_exceptions.not_found) {
        throw Cannot_expand;
      }
      throw exn$1;
    }
    var ty$prime = subst(env, level, kind, abbrev, ty, match$2[0], args, match$2[1]);
    var ty$2 = repr(ty$prime);
    var match$3 = ty$2.desc;
    if (typeof match$3 !== "number" && match$3.tag === /* Tvariant */8) {
      var row = match$3[0];
      if (static_row(row)) {
        ty$2.desc = /* Tvariant */Block.__(8, [{
              row_fields: row.row_fields,
              row_more: row.row_more,
              row_bound: row.row_bound,
              row_closed: row.row_closed,
              row_fixed: row.row_fixed,
              row_name: /* tuple */[
                path,
                args
              ]
            }]);
      }
      
    }
    if (trace_gadt_instances.contents) {
      var match$4 = Caml_obj.caml_max(match$2[2], gadt_instance_level(env, ty));
      if (match$4 !== void 0) {
        var lv = match$4;
        if (level < lv) {
          throw [
                Unify,
                /* :: */[
                  /* tuple */[
                    ty,
                    newty2(level, /* Tvar */Block.__(0, [void 0]))
                  ],
                  /* [] */0
                ]
              ];
        }
        add_gadt_instances(env, lv, /* :: */[
              ty,
              /* :: */[
                ty$prime,
                /* [] */0
              ]
            ]);
      }
      
    }
    return ty$prime;
  }
}

function expand_abbrev(ty) {
  return (function (param) {
      return expand_abbrev_gen(/* Public */1, find_type_expansion, ty, param);
    });
}

function expand_head_once(env, ty) {
  try {
    return expand_abbrev(env)(repr(ty));
  }
  catch (exn){
    if (exn === Cannot_expand) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "ctype.ml",
              1464,
              56
            ]
          ];
    }
    throw exn;
  }
}

function safe_abbrev(env, ty) {
  var snap = snapshot(void 0);
  try {
    expand_abbrev(env)(ty);
    return true;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn === Cannot_expand) {
      backtrack(snap);
      return false;
    } else {
      if (exn[0] !== Unify) {
        throw exn;
      }
      backtrack(snap);
      return false;
    }
  }
}

function try_expand_once(env, ty) {
  var ty$1 = repr(ty);
  var match = ty$1.desc;
  if (typeof match === "number") {
    throw Cannot_expand;
  }
  if (match.tag === /* Tconstr */3) {
    return repr(expand_abbrev(env)(ty$1));
  }
  throw Cannot_expand;
}

function try_expand_safe(env, ty) {
  var snap = snapshot(void 0);
  try {
    return try_expand_once(env, ty);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] !== Unify) {
      throw exn;
    }
    backtrack(snap);
    throw Cannot_expand;
  }
}

function try_expand_head(try_once, env, ty) {
  var ty$prime = Curry._2(try_once, env, ty);
  try {
    return try_expand_head(try_once, env, ty$prime);
  }
  catch (exn){
    if (exn === Cannot_expand) {
      return ty$prime;
    }
    throw exn;
  }
}

function try_expand_head$1(try_once, env, ty) {
  var ty$prime = try_expand_head(try_once, env, ty);
  var match = gadt_instance_level(env, ty$prime);
  if (match !== void 0) {
    add_gadt_instance_chain(env, match, ty);
  }
  return ty$prime;
}

function expand_head_unif(env, ty) {
  try {
    return try_expand_head$1(try_expand_once, env, ty);
  }
  catch (exn){
    if (exn === Cannot_expand) {
      return repr(ty);
    }
    throw exn;
  }
}

function expand_head(env, ty) {
  try {
    return try_expand_head$1(try_expand_safe, env, ty);
  }
  catch (exn){
    if (exn === Cannot_expand) {
      return repr(ty);
    }
    throw exn;
  }
}

forward_try_expand_once.contents = try_expand_safe;

function extract_concrete_typedecl(env, ty) {
  var ty$1 = repr(ty);
  var match = ty$1.desc;
  if (typeof match === "number") {
    throw Caml_builtin_exceptions.not_found;
  }
  if (match.tag !== /* Tconstr */3) {
    throw Caml_builtin_exceptions.not_found;
  }
  var p = match[0];
  var decl = find_type_full(p, env)[0];
  if (decl.type_kind !== /* Type_abstract */0) {
    return /* tuple */[
            p,
            p,
            decl
          ];
  }
  var ty$2;
  try {
    ty$2 = try_expand_once(env, ty$1);
  }
  catch (exn){
    if (exn === Cannot_expand) {
      throw Caml_builtin_exceptions.not_found;
    }
    throw exn;
  }
  var match$1 = extract_concrete_typedecl(env, ty$2);
  return /* tuple */[
          p,
          match$1[1],
          match$1[2]
        ];
}

function expand_abbrev_opt(param, param$1) {
  return expand_abbrev_gen(/* Private */0, find_type_expansion_opt, param, param$1);
}

function try_expand_once_opt(env, ty) {
  var ty$1 = repr(ty);
  var match = ty$1.desc;
  if (typeof match === "number") {
    throw Cannot_expand;
  }
  if (match.tag === /* Tconstr */3) {
    return repr(expand_abbrev_opt(env, ty$1));
  }
  throw Cannot_expand;
}

function try_expand_head_opt(env, ty) {
  var ty$prime = try_expand_once_opt(env, ty);
  try {
    return try_expand_head_opt(env, ty$prime);
  }
  catch (exn){
    if (exn === Cannot_expand) {
      return ty$prime;
    }
    throw exn;
  }
}

function expand_head_opt(env, ty) {
  var snap = snapshot(void 0);
  try {
    return try_expand_head_opt(env, ty);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn === Cannot_expand) {
      backtrack(snap);
      return repr(ty);
    } else {
      if (exn[0] !== Unify) {
        throw exn;
      }
      backtrack(snap);
      return repr(ty);
    }
  }
}

function enforce_constraints(env, ty) {
  var match = ty.desc;
  if (typeof match === "number") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "ctype.ml",
            1574,
            6
          ]
        ];
  }
  if (match.tag !== /* Tconstr */3) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "ctype.ml",
            1574,
            6
          ]
        ];
  }
  var level = ty.level;
  try {
    var decl = find_type_full(match[0], env)[0];
    subst(env, level, /* Public */1, {
          contents: /* Mnil */0
        }, void 0, decl.type_params, match[1], newty2(level, /* Tvar */Block.__(0, [void 0])));
    return ;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return ;
    }
    throw exn;
  }
}

function full_expand(env, ty) {
  var ty$1 = repr(expand_head(env, ty));
  var match = ty$1.desc;
  if (typeof match === "number") {
    return ty$1;
  }
  if (match.tag !== /* Tobject */4) {
    return ty$1;
  }
  var match$1 = match[1].contents;
  if (match$1 === void 0) {
    return ty$1;
  }
  var match$2 = match$1[1];
  if (match$2 && is_Tvar(repr(match$2[0]))) {
    return newty2(ty$1.level, /* Tobject */Block.__(4, [
                  match[0],
                  {
                    contents: void 0
                  }
                ]));
  } else {
    return ty$1;
  }
}

function generic_abbrev(env, path) {
  try {
    var match = find_type_expansion(path, env);
    return repr(match[1]).level === 100000000;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return false;
    }
    throw exn;
  }
}

function generic_private_abbrev(env, path) {
  try {
    var match = find_type_full(path, env)[0];
    var match$1 = match.type_kind;
    if (typeof match$1 !== "number") {
      return false;
    }
    if (match$1 !== 0) {
      return false;
    }
    if (match.type_private) {
      return false;
    }
    var match$2 = match.type_manifest;
    if (match$2 !== void 0) {
      return repr(match$2).level === 100000000;
    } else {
      return false;
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return false;
    }
    throw exn;
  }
}

function is_contractive(env, ty) {
  var match = repr(ty).desc;
  if (typeof match === "number") {
    return true;
  }
  if (match.tag !== /* Tconstr */3) {
    return true;
  }
  var p = match[0];
  if (in_pervasives(p)) {
    return true;
  }
  try {
    return is_datatype(find_type_full(p, env)[0]);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return false;
    }
    throw exn;
  }
}

var Occur = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Occur");

function occur_rec(env, visited, ty0, ty) {
  if (ty === ty0) {
    throw Occur;
  }
  var occur_ok = recursive_types.contents && is_contractive(env, ty);
  var match = ty.desc;
  if (typeof match !== "number") {
    switch (match.tag | 0) {
      case /* Tconstr */3 :
          try {
            if (occur_ok || List.memq(ty, visited)) {
              throw Occur;
            }
            var partial_arg = /* :: */[
              ty,
              visited
            ];
            return iter_type_expr((function (param) {
                          return occur_rec(env, partial_arg, ty0, param);
                        }), ty);
          }
          catch (exn){
            if (exn !== Occur) {
              throw exn;
            }
            try {
              var ty$prime = try_expand_head$1(try_expand_once, env, ty);
              if (ty$prime === ty0 || List.memq(ty$prime, visited)) {
                throw Occur;
              }
              var match$1 = ty$prime.desc;
              var exit = 0;
              if (typeof match$1 === "number") {
                exit = 2;
              } else {
                switch (match$1.tag | 0) {
                  case /* Tobject */4 :
                  case /* Tvariant */8 :
                      return ;
                  default:
                    exit = 2;
                }
              }
              if (exit === 2) {
                if (recursive_types.contents && is_contractive(env, ty$prime)) {
                  return ;
                }
                var partial_arg$1 = /* :: */[
                  ty$prime,
                  visited
                ];
                return iter_type_expr((function (param) {
                              return occur_rec(env, partial_arg$1, ty0, param);
                            }), ty$prime);
              }
              
            }
            catch (exn$1){
              if (exn$1 !== Cannot_expand) {
                throw exn$1;
              }
              if (occur_ok) {
                return ;
              }
              throw Occur;
            }
          }
          break;
      case /* Tobject */4 :
      case /* Tvariant */8 :
          return ;
      default:
        
    }
  }
  if (!occur_ok) {
    return iter_type_expr((function (param) {
                  return occur_rec(env, visited, ty0, param);
                }), ty);
  }
  
}

var type_changed = {
  contents: false
};

function merge(r, b) {
  if (b) {
    r.contents = true;
    return ;
  }
  
}

function occur(env, ty0, ty) {
  var old = type_changed.contents;
  try {
    while(type_changed.contents = false, occur_rec(env, /* [] */0, ty0, ty), type_changed.contents) {
      
    };
    return merge(type_changed, old);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    merge(type_changed, old);
    throw exn === Occur ? [
            Unify,
            /* [] */0
          ] : exn;
  }
}

function occur_in(env, ty0, t) {
  try {
    occur(env, ty0, t);
    return false;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === Unify) {
      return true;
    }
    throw exn;
  }
}

function unify_univar(t1, t2, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      throw [
            Unify,
            /* [] */0
          ];
    }
    var match = param[0];
    var find_univ = function (t, cl) {
      try {
        var match = List.find((function (param) {
                return t === repr(param[0]);
              }), cl);
        return Caml_option.some(match[1]);
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          return ;
        }
        throw exn;
      }
    };
    var match$1 = find_univ(t1, match[0]);
    var match$2 = find_univ(t2, match[1]);
    if (match$1 !== void 0) {
      var r1 = match$1;
      var match$3 = r1.contents;
      if (match$3 !== void 0) {
        if (match$2 === void 0) {
          throw [
                Unify,
                /* [] */0
              ];
        }
        if (t2 === repr(match$3)) {
          return ;
        }
        throw [
              Unify,
              /* [] */0
            ];
      } else {
        if (match$2 === void 0) {
          throw [
                Unify,
                /* [] */0
              ];
        }
        var r2 = match$2;
        var match$4 = r2.contents;
        if (match$4 !== void 0) {
          throw [
                Unify,
                /* [] */0
              ];
        }
        set_univar(r1, t2);
        return set_univar(r2, t1);
      }
    } else {
      if (match$2 !== void 0) {
        throw [
              Unify,
              /* [] */0
            ];
      }
      _param = param[1];
      continue ;
    }
  };
}

function occur_univar(env, ty) {
  var visited = {
    contents: /* Empty */0
  };
  var occur_rec = function (_bound, _ty) {
    while(true) {
      var ty = _ty;
      var bound = _bound;
      var ty$1 = repr(ty);
      var tmp = false;
      if (ty$1.level >= 0) {
        var tmp$1;
        if (bound ? false : true) {
          ty$1.level = pivot_level - ty$1.level | 0;
          tmp$1 = true;
        } else {
          try {
            var bound$prime = find$1(ty$1, visited.contents);
            if (exists((function(bound){
                  return function (x) {
                    return !mem$3(x, bound);
                  }
                  }(bound)), bound$prime)) {
              visited.contents = add$4(ty$1, inter$2(bound, bound$prime), visited.contents);
              tmp$1 = true;
            } else {
              tmp$1 = false;
            }
          }
          catch (exn){
            if (exn !== Caml_builtin_exceptions.not_found) {
              throw exn;
            }
            visited.contents = add$4(ty$1, bound, visited.contents);
            tmp$1 = true;
          }
        }
        tmp = tmp$1;
      }
      if (!tmp) {
        return ;
      }
      var match = ty$1.desc;
      if (typeof match === "number") {
        return iter_type_expr((function(bound){
                  return function (param) {
                    return occur_rec(bound, param);
                  }
                  }(bound)), ty$1);
      }
      switch (match.tag | 0) {
        case /* Tconstr */3 :
            var tl = match[1];
            if (!tl) {
              return ;
            }
            try {
              var td = find_type_full(match[0], env)[0];
              return List.iter2((function(bound){
                        return function (t, v) {
                          if (Curry._2(Types_Variance.mem, /* May_pos */0, v) || Curry._2(Types_Variance.mem, /* May_neg */1, v)) {
                            return occur_rec(bound, t);
                          }
                          
                        }
                        }(bound)), tl, td.type_variance);
            }
            catch (exn$1){
              if (exn$1 === Caml_builtin_exceptions.not_found) {
                return List.iter((function(bound){
                          return function (param) {
                            return occur_rec(bound, param);
                          }
                          }(bound)), tl);
              }
              throw exn$1;
            }
        case /* Tunivar */9 :
            if (mem$3(ty$1, bound)) {
              return ;
            }
            throw [
                  Unify,
                  /* :: */[
                    /* tuple */[
                      ty$1,
                      newty2(100000000, /* Tvar */Block.__(0, [void 0]))
                    ],
                    /* [] */0
                  ]
                ];
        case /* Tpoly */10 :
            var bound$1 = List.fold_right(add$3, List.map(repr, match[1]), bound);
            _ty = match[0];
            _bound = bound$1;
            continue ;
        default:
          return iter_type_expr((function(bound){
                    return function (param) {
                      return occur_rec(bound, param);
                    }
                    }(bound)), ty$1);
      }
    };
  };
  try {
    occur_rec(/* Empty */0, ty);
    return unmark_type(ty);
  }
  catch (exn){
    unmark_type(ty);
    throw exn;
  }
}

function add_univars(param, param$1) {
  return List.fold_left((function (s, param) {
                return add$3(repr(param[0]), s);
              }), param, param$1);
}

function get_univar_family(univar_pairs, univars) {
  if (univars === /* [] */0) {
    return /* Empty */0;
  }
  var insert = function (s, param) {
    var cl2 = param[1];
    if (cl2 && List.exists((function (param) {
              return mem$3(repr(param[0]), s);
            }), param[0])) {
      return add_univars(s, cl2);
    } else {
      return s;
    }
  };
  var s = List.fold_right(add$3, univars, /* Empty */0);
  return List.fold_left(insert, s, univar_pairs);
}

function univars_escape(env, univar_pairs, vl, ty) {
  var family = get_univar_family(univar_pairs, vl);
  var visited = {
    contents: /* Empty */0
  };
  var occur = function (_t) {
    while(true) {
      var t = _t;
      var t$1 = repr(t);
      if (mem$3(t$1, visited.contents)) {
        return ;
      }
      visited.contents = add$3(t$1, visited.contents);
      var match = t$1.desc;
      if (typeof match === "number") {
        return iter_type_expr(occur, t$1);
      }
      switch (match.tag | 0) {
        case /* Tconstr */3 :
            var tl = match[1];
            if (!tl) {
              return ;
            }
            try {
              var td = find_type_full(match[0], env)[0];
              return List.iter2((function (t, v) {
                            if (Curry._2(Types_Variance.mem, /* May_pos */0, v) || Curry._2(Types_Variance.mem, /* May_neg */1, v)) {
                              return occur(t);
                            }
                            
                          }), tl, td.type_variance);
            }
            catch (exn){
              if (exn === Caml_builtin_exceptions.not_found) {
                return List.iter(occur, tl);
              }
              throw exn;
            }
        case /* Tunivar */9 :
            if (mem$3(t$1, family)) {
              throw Occur;
            }
            return ;
        case /* Tpoly */10 :
            if (List.exists((function (t) {
                      return mem$3(repr(t), family);
                    }), match[1])) {
              return ;
            }
            _t = match[0];
            continue ;
        default:
          return iter_type_expr(occur, t$1);
      }
    };
  };
  try {
    occur(ty);
    return false;
  }
  catch (exn){
    if (exn === Occur) {
      return true;
    }
    throw exn;
  }
}

function enter_poly(env, univar_pairs, t1, tl1, t2, tl2, f) {
  var old_univars = univar_pairs.contents;
  var known_univars = List.fold_left((function (s, param) {
          return add_univars(s, param[0]);
        }), /* Empty */0, old_univars);
  var tl1$1 = List.map(repr, tl1);
  var tl2$1 = List.map(repr, tl2);
  if (List.exists((function (t) {
            return mem$3(t, known_univars);
          }), tl1$1) && univars_escape(env, old_univars, tl1$1, newty2(current_level.contents, /* Tpoly */Block.__(10, [
                t2,
                tl2$1
              ]))) || List.exists((function (t) {
            return mem$3(t, known_univars);
          }), tl2$1) && univars_escape(env, old_univars, tl2$1, newty2(current_level.contents, /* Tpoly */Block.__(10, [
                t1,
                tl1$1
              ])))) {
    throw [
          Unify,
          /* [] */0
        ];
  }
  var cl1 = List.map((function (t) {
          return /* tuple */[
                  t,
                  {
                    contents: void 0
                  }
                ];
        }), tl1$1);
  var cl2 = List.map((function (t) {
          return /* tuple */[
                  t,
                  {
                    contents: void 0
                  }
                ];
        }), tl2$1);
  univar_pairs.contents = /* :: */[
    /* tuple */[
      cl1,
      cl2
    ],
    /* :: */[
      /* tuple */[
        cl2,
        cl1
      ],
      old_univars
    ]
  ];
  try {
    var res = Curry._2(f, t1, t2);
    univar_pairs.contents = old_univars;
    return res;
  }
  catch (exn){
    univar_pairs.contents = old_univars;
    throw exn;
  }
}

var univar_pairs = {
  contents: /* [] */0
};

function has_cached_expansion(p, _abbrev) {
  while(true) {
    var abbrev = _abbrev;
    if (typeof abbrev === "number") {
      return false;
    }
    if (abbrev.tag) {
      _abbrev = abbrev[0].contents;
      continue ;
    } else {
      if (same(p, abbrev[1])) {
        return true;
      }
      _abbrev = abbrev[4];
      continue ;
    }
  };
}

function expand_trace(env, trace) {
  return List.fold_right((function (param, rem) {
                var t2 = param[1];
                var t1 = param[0];
                return /* :: */[
                        /* tuple */[
                          repr(t1),
                          full_expand(env, t1)
                        ],
                        /* :: */[
                          /* tuple */[
                            repr(t2),
                            full_expand(env, t2)
                          ],
                          rem
                        ]
                      ];
              }), trace, /* [] */0);
}

function mkvariant(fields, closed) {
  return newty2(100000000, /* Tvariant */Block.__(8, [{
                  row_fields: fields,
                  row_more: newvar(void 0, void 0),
                  row_bound: void 0,
                  row_closed: closed,
                  row_fixed: false,
                  row_name: void 0
                }]));
}

var rigid_variants = {
  contents: false
};

function deep_occur(t0, ty) {
  var occur_rec = function (ty) {
    var ty$1 = repr(ty);
    if (ty$1.level < 0) {
      return ;
    }
    if (ty$1 === t0) {
      throw Occur;
    }
    ty$1.level = pivot_level - ty$1.level | 0;
    return iter_type_expr(occur_rec, ty$1);
  };
  try {
    occur_rec(ty);
    unmark_type(ty);
    return false;
  }
  catch (exn){
    if (exn !== Occur) {
      throw exn;
    }
    unmark_type(ty);
    return true;
  }
}

var newtype_level = {
  contents: void 0
};

function get_newtype_level(param) {
  var match = newtype_level.contents;
  if (match !== void 0) {
    return match;
  }
  throw [
        Caml_builtin_exceptions.assert_failure,
        /* tuple */[
          "ctype.ml",
          1949,
          12
        ]
      ];
}

function reify(env, t) {
  var newtype_level = get_newtype_level(void 0);
  var create_fresh_constr = function (lev, name) {
    var decl = new_declaration(/* tuple */[
          newtype_level,
          newtype_level
        ], void 0);
    var name$1 = get_new_abstract_name(name);
    var match = enter_type(name$1, decl, env.contents);
    var t = newty2(lev, /* Tconstr */Block.__(3, [
            /* Pident */Block.__(0, [match[0]]),
            /* [] */0,
            {
              contents: /* Mnil */0
            }
          ]));
    env.contents = match[1];
    return t;
  };
  var visited = {
    contents: /* Empty */0
  };
  var iterator = function (ty) {
    var ty$1 = repr(ty);
    if (mem$3(ty$1, visited.contents)) {
      return ;
    }
    visited.contents = add$3(ty$1, visited.contents);
    var match = ty$1.desc;
    if (typeof match === "number") {
      return iter_type_expr(iterator, ty$1);
    }
    switch (match.tag | 0) {
      case /* Tvar */0 :
          var o = match[0];
          var name = o !== void 0 ? o : "ex";
          var t = create_fresh_constr(ty$1.level, name);
          return link_type(ty$1, t);
      case /* Tconstr */3 :
          if (is_object_type(match[0])) {
            return iter_type_expr(iterator, full_expand(env.contents, ty$1));
          } else {
            return iter_type_expr(iterator, ty$1);
          }
      case /* Tvariant */8 :
          var r = row_repr_aux(/* [] */0, match[0]);
          if (!static_row(r)) {
            if (r.row_fixed) {
              iterator(row_more(r));
            } else {
              var m = r.row_more;
              var match$1 = m.desc;
              if (typeof match$1 === "number") {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      /* tuple */[
                        "ctype.ml",
                        1987,
                        19
                      ]
                    ];
              }
              if (match$1.tag) {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      /* tuple */[
                        "ctype.ml",
                        1987,
                        19
                      ]
                    ];
              }
              var o$1 = match$1[0];
              var name$1 = o$1 !== void 0 ? o$1 : "ex";
              var t$1 = create_fresh_constr(m.level, name$1);
              var row_row_bound = r.row_bound;
              var row_row_closed = r.row_closed;
              var row_row_name = r.row_name;
              var row = {
                row_fields: /* [] */0,
                row_more: t$1,
                row_bound: row_row_bound,
                row_closed: row_row_closed,
                row_fixed: true,
                row_name: row_row_name
              };
              link_type(m, newty2(m.level, /* Tvariant */Block.__(8, [row])));
            }
          }
          return iter_row(iterator, r);
      default:
        return iter_type_expr(iterator, ty$1);
    }
  };
  return iterator(t);
}

function is_newtype(env, p) {
  try {
    var decl = find_type_full(p, env)[0];
    if (decl.type_newtype_level !== void 0 && decl.type_kind === /* Type_abstract */0) {
      return decl.type_private === /* Public */1;
    } else {
      return false;
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return false;
    }
    throw exn;
  }
}

function non_aliasable(p, decl) {
  if (in_current_module(p)) {
    return decl.type_newtype_level === void 0;
  } else {
    return false;
  }
}

function expands_to_datatype(env, ty) {
  var ty$1 = repr(ty);
  var match = ty$1.desc;
  if (typeof match === "number") {
    return false;
  }
  if (match.tag !== /* Tconstr */3) {
    return false;
  }
  try {
    if (is_datatype(find_type_full(match[0], env)[0])) {
      return true;
    } else {
      return expands_to_datatype(env, try_expand_once(env, ty$1));
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return false;
    }
    if (exn === Cannot_expand) {
      return false;
    }
    throw exn;
  }
}

function mcomp(type_pairs, env, _t1, _t2) {
  while(true) {
    var t2 = _t2;
    var t1 = _t1;
    if (t1 === t2) {
      return ;
    }
    var t1$1 = repr(t1);
    var t2$1 = repr(t2);
    if (t1$1 === t2$1) {
      return ;
    }
    var match = t1$1.desc;
    var match$1 = t2$1.desc;
    var exit = 0;
    var exit$1 = 0;
    if (typeof match === "number") {
      exit$1 = 2;
    } else {
      switch (match.tag | 0) {
        case /* Tvar */0 :
            return ;
        case /* Tconstr */3 :
            if (match[1]) {
              exit$1 = 2;
            } else if (typeof match$1 === "number") {
              exit = 1;
            } else {
              switch (match$1.tag | 0) {
                case /* Tvar */0 :
                    exit$1 = 2;
                    break;
                case /* Tconstr */3 :
                    if (match$1[1]) {
                      exit = 1;
                    } else {
                      if (same(match[0], match$1[0])) {
                        return ;
                      }
                      exit = 1;
                    }
                    break;
                default:
                  exit = 1;
              }
            }
            break;
        default:
          exit$1 = 2;
      }
    }
    if (exit$1 === 2) {
      if (typeof match$1 === "number") {
        exit = 1;
      } else {
        if (!match$1.tag) {
          return ;
        }
        exit = 1;
      }
    }
    if (exit === 1) {
      var t1$prime = expand_head_opt(env, t1$1);
      var t2$prime = expand_head_opt(env, t2$1);
      var t1$prime$1 = repr(t1$prime);
      var t2$prime$1 = repr(t2$prime);
      if (t1$prime$1 === t2$prime$1) {
        return ;
      }
      try {
        return Curry._2(TypePairs.find, type_pairs, /* tuple */[
                    t1$prime$1,
                    t2$prime$1
                  ]);
      }
      catch (exn){
        if (exn !== Caml_builtin_exceptions.not_found) {
          throw exn;
        }
        Curry._3(TypePairs.add, type_pairs, /* tuple */[
              t1$prime$1,
              t2$prime$1
            ], void 0);
        var match$2 = t1$prime$1.desc;
        var match$3 = t2$prime$1.desc;
        var p;
        var exit$2 = 0;
        if (typeof match$2 === "number") {
          if (typeof match$3 === "number") {
            return ;
          }
          if (match$3.tag !== /* Tconstr */3) {
            throw [
                  Unify,
                  /* [] */0
                ];
          }
          exit$2 = 3;
        } else {
          switch (match$2.tag | 0) {
            case /* Tvar */0 :
                if (typeof match$3 === "number") {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                switch (match$3.tag | 0) {
                  case /* Tvar */0 :
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            /* tuple */[
                              "ctype.ml",
                              2051,
                              30
                            ]
                          ];
                  case /* Tconstr */3 :
                      exit$2 = 3;
                      break;
                  default:
                    throw [
                          Unify,
                          /* [] */0
                        ];
                }
                break;
            case /* Tarrow */1 :
                var l1 = match$2[0];
                if (typeof match$3 === "number") {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                switch (match$3.tag | 0) {
                  case /* Tarrow */1 :
                      var l2 = match$3[0];
                      if (!(l1 === l2 || !(is_optional(l1) || is_optional(l2)))) {
                        throw [
                              Unify,
                              /* [] */0
                            ];
                      }
                      mcomp(type_pairs, env, match$2[1], match$3[1]);
                      _t2 = match$3[2];
                      _t1 = match$2[2];
                      continue ;
                  case /* Tconstr */3 :
                      exit$2 = 3;
                      break;
                  default:
                    throw [
                          Unify,
                          /* [] */0
                        ];
                }
                break;
            case /* Ttuple */2 :
                if (typeof match$3 === "number") {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                switch (match$3.tag | 0) {
                  case /* Ttuple */2 :
                      return mcomp_list(type_pairs, env, match$2[0], match$3[0]);
                  case /* Tconstr */3 :
                      exit$2 = 3;
                      break;
                  default:
                    throw [
                          Unify,
                          /* [] */0
                        ];
                }
                break;
            case /* Tconstr */3 :
                var p1 = match$2[0];
                if (typeof match$3 === "number") {
                  p = p1;
                } else {
                  if (match$3.tag === /* Tconstr */3) {
                    var p2 = match$3[0];
                    var tl1 = match$2[1];
                    var tl2 = match$3[1];
                    try {
                      var decl = find_type_full(p1, env)[0];
                      var decl$prime = find_type_full(p2, env)[0];
                      if (same(p1, p2)) {
                        var inj;
                        try {
                          inj = List.map(Curry._1(Types_Variance.mem, /* Inj */3), find_type_full(p1, env)[0].type_variance);
                        }
                        catch (exn$1){
                          if (exn$1 !== Caml_builtin_exceptions.not_found) {
                            throw exn$1;
                          }
                          inj = List.map((function (param) {
                                  return false;
                                }), tl1);
                        }
                        return List.iter2((function (i, param) {
                                      if (i) {
                                        return mcomp(type_pairs, env, param[0], param[1]);
                                      }
                                      
                                    }), inj, List.combine(tl1, tl2));
                      } else {
                        if (non_aliasable(p1, decl) && non_aliasable(p2, decl$prime)) {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        }
                        var match$4 = decl.type_kind;
                        var match$5 = decl$prime.type_kind;
                        var exit$3 = 0;
                        if (typeof match$4 === "number") {
                          if (match$4 === /* Type_abstract */0) {
                            var exit$4 = 0;
                            if (typeof match$5 === "number") {
                              if (match$5 === 0) {
                                return ;
                              }
                              exit$4 = 2;
                            } else {
                              exit$4 = 2;
                            }
                            if (exit$4 === 2) {
                              if (!non_aliasable(p1, decl)) {
                                return ;
                              }
                              exit$3 = 1;
                            }
                            
                          } else {
                            if (typeof match$5 !== "number") {
                              throw [
                                    Unify,
                                    /* [] */0
                                  ];
                            }
                            if (match$5 !== 0) {
                              return mcomp_list(type_pairs, env, tl1, tl2);
                            }
                            exit$3 = 1;
                          }
                        } else if (match$4.tag) {
                          if (typeof match$5 === "number") {
                            if (match$5 !== /* Type_abstract */0) {
                              throw [
                                    Unify,
                                    /* [] */0
                                  ];
                            }
                            exit$3 = 1;
                          } else {
                            if (!match$5.tag) {
                              throw [
                                    Unify,
                                    /* [] */0
                                  ];
                            }
                            mcomp_list(type_pairs, env, tl1, tl2);
                            var xs = match$4[0];
                            var ys = match$5[0];
                            var _x = xs;
                            var _y = ys;
                            while(true) {
                              var y = _y;
                              var x = _x;
                              if (x) {
                                if (!y) {
                                  throw [
                                        Unify,
                                        /* [] */0
                                      ];
                                }
                                var c2 = y[0];
                                var c1 = x[0];
                                mcomp_type_option(type_pairs, env, c1.cd_res, c2.cd_res);
                                mcomp_list(type_pairs, env, c1.cd_args, c2.cd_args);
                                if (c1.cd_id.name !== c2.cd_id.name) {
                                  throw [
                                        Unify,
                                        /* [] */0
                                      ];
                                }
                                _y = y[1];
                                _x = x[1];
                                continue ;
                              } else {
                                if (y) {
                                  throw [
                                        Unify,
                                        /* [] */0
                                      ];
                                }
                                return ;
                              }
                            };
                          }
                        } else if (typeof match$5 === "number") {
                          if (match$5 !== /* Type_abstract */0) {
                            throw [
                                  Unify,
                                  /* [] */0
                                ];
                          }
                          exit$3 = 1;
                        } else {
                          if (match$5.tag) {
                            throw [
                                  Unify,
                                  /* [] */0
                                ];
                          }
                          if (match$4[1] !== match$5[1]) {
                            throw [
                                  Unify,
                                  /* [] */0
                                ];
                          }
                          mcomp_list(type_pairs, env, tl1, tl2);
                          return mcomp_record_description(type_pairs, env)(match$4[0], match$5[0]);
                        }
                        if (exit$3 === 1) {
                          if (typeof match$5 !== "number") {
                            throw [
                                  Unify,
                                  /* [] */0
                                ];
                          }
                          if (match$5 !== 0) {
                            throw [
                                  Unify,
                                  /* [] */0
                                ];
                          }
                          if (non_aliasable(p2, decl$prime)) {
                            throw [
                                  Unify,
                                  /* [] */0
                                ];
                          }
                          return ;
                        }
                        
                      }
                    }
                    catch (exn$2){
                      if (exn$2 === Caml_builtin_exceptions.not_found) {
                        return ;
                      }
                      throw exn$2;
                    }
                  }
                  p = p1;
                }
                break;
            case /* Tobject */4 :
                if (typeof match$3 === "number") {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                switch (match$3.tag | 0) {
                  case /* Tconstr */3 :
                      exit$2 = 3;
                      break;
                  case /* Tobject */4 :
                      return mcomp_fields(type_pairs, env, match$2[0], match$3[0]);
                  default:
                    throw [
                          Unify,
                          /* [] */0
                        ];
                }
                break;
            case /* Tfield */5 :
                if (typeof match$3 === "number") {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                switch (match$3.tag | 0) {
                  case /* Tconstr */3 :
                      exit$2 = 3;
                      break;
                  case /* Tfield */5 :
                      return mcomp_fields(type_pairs, env, t1$prime$1, t2$prime$1);
                  default:
                    throw [
                          Unify,
                          /* [] */0
                        ];
                }
                break;
            case /* Tlink */6 :
            case /* Tsubst */7 :
                exit$2 = 3;
                break;
            case /* Tvariant */8 :
                if (typeof match$3 === "number") {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                switch (match$3.tag | 0) {
                  case /* Tconstr */3 :
                      exit$2 = 3;
                      break;
                  case /* Tvariant */8 :
                      var row1 = match$2[0];
                      var row2 = match$3[0];
                      var row1$1 = row_repr_aux(/* [] */0, row1);
                      var row2$1 = row_repr_aux(/* [] */0, row2);
                      var match$6 = merge_row_fields(row1$1.row_fields, row2$1.row_fields);
                      var cannot_erase = function (param) {
                        var match = row_field_repr_aux(/* [] */0, param[1]);
                        if (typeof match === "number" || match.tag) {
                          return false;
                        } else {
                          return true;
                        }
                      };
                      if (row1$1.row_closed && List.exists(cannot_erase, match$6[1]) || row2$1.row_closed && List.exists(cannot_erase, match$6[0])) {
                        throw [
                              Unify,
                              /* [] */0
                            ];
                      }
                      return List.iter((function (param) {
                                    var match = row_field_repr_aux(/* [] */0, param[1]);
                                    var match$1 = row_field_repr_aux(/* [] */0, param[2]);
                                    var exit = 0;
                                    var exit$1 = 0;
                                    if (typeof match === "number") {
                                      exit$1 = 2;
                                    } else if (match.tag) {
                                      var exit$2 = 0;
                                      if (match[0] || typeof match$1 === "number" || match$1.tag) {
                                        exit$2 = 3;
                                      } else {
                                        var match$2 = match$1[0];
                                        if (match$2 !== void 0) {
                                          var t2 = match$2;
                                          return List.iter((function (param) {
                                                        return mcomp(type_pairs, env, t2, param);
                                                      }), match[1]);
                                        } else {
                                          exit$2 = 3;
                                        }
                                      }
                                      if (exit$2 === 3) {
                                        if (match[1]) {
                                          exit$1 = 2;
                                        } else {
                                          exit = 1;
                                        }
                                      }
                                      
                                    } else {
                                      var match$3 = match[0];
                                      if (match$3 !== void 0) {
                                        var t1 = match$3;
                                        if (typeof match$1 === "number") {
                                          throw [
                                                Unify,
                                                /* [] */0
                                              ];
                                        }
                                        if (match$1.tag) {
                                          if (match$1[0]) {
                                            throw [
                                                  Unify,
                                                  /* [] */0
                                                ];
                                          }
                                          return List.iter((function (param) {
                                                        return mcomp(type_pairs, env, t1, param);
                                                      }), match$1[1]);
                                        } else {
                                          var match$4 = match$1[0];
                                          if (match$4 !== void 0) {
                                            return mcomp(type_pairs, env, t1, match$4);
                                          }
                                          throw [
                                                Unify,
                                                /* [] */0
                                              ];
                                        }
                                      } else {
                                        if (typeof match$1 === "number") {
                                          throw [
                                                Unify,
                                                /* [] */0
                                              ];
                                        }
                                        if (match$1.tag) {
                                          if (match$1[1]) {
                                            throw [
                                                  Unify,
                                                  /* [] */0
                                                ];
                                          }
                                          return ;
                                        } else {
                                          if (match$1[0] !== void 0) {
                                            throw [
                                                  Unify,
                                                  /* [] */0
                                                ];
                                          }
                                          return ;
                                        }
                                      }
                                    }
                                    if (exit$1 === 2) {
                                      if (typeof match$1 === "number") {
                                        return ;
                                      }
                                      if (match$1.tag) {
                                        return ;
                                      }
                                      if (match$1[0] === void 0) {
                                        throw [
                                              Unify,
                                              /* [] */0
                                            ];
                                      }
                                      exit = 1;
                                    }
                                    if (exit === 1) {
                                      if (typeof match !== "number" && !match[0]) {
                                        return ;
                                      }
                                      if (typeof match$1 === "number") {
                                        return ;
                                      }
                                      if (match$1.tag) {
                                        return ;
                                      }
                                      if (match$1[0] !== void 0) {
                                        throw [
                                              Unify,
                                              /* [] */0
                                            ];
                                      }
                                      return ;
                                    }
                                    
                                  }), match$6[2]);
                  default:
                    throw [
                          Unify,
                          /* [] */0
                        ];
                }
                break;
            case /* Tunivar */9 :
                if (typeof match$3 === "number") {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                switch (match$3.tag | 0) {
                  case /* Tconstr */3 :
                      exit$2 = 3;
                      break;
                  case /* Tunivar */9 :
                      return unify_univar(t1$prime$1, t2$prime$1, univar_pairs.contents);
                  default:
                    throw [
                          Unify,
                          /* [] */0
                        ];
                }
                break;
            case /* Tpoly */10 :
                var tl1$1 = match$2[1];
                var t1$2 = match$2[0];
                var exit$5 = 0;
                if (tl1$1) {
                  exit$5 = 4;
                } else {
                  if (typeof match$3 === "number") {
                    throw [
                          Unify,
                          /* [] */0
                        ];
                  }
                  switch (match$3.tag | 0) {
                    case /* Tconstr */3 :
                        exit$2 = 3;
                        break;
                    case /* Tpoly */10 :
                        if (match$3[1]) {
                          exit$5 = 4;
                        } else {
                          _t2 = match$3[0];
                          _t1 = t1$2;
                          continue ;
                        }
                        break;
                    default:
                      throw [
                            Unify,
                            /* [] */0
                          ];
                  }
                }
                if (exit$5 === 4) {
                  if (typeof match$3 === "number") {
                    throw [
                          Unify,
                          /* [] */0
                        ];
                  }
                  switch (match$3.tag | 0) {
                    case /* Tconstr */3 :
                        exit$2 = 3;
                        break;
                    case /* Tpoly */10 :
                        return enter_poly(env, univar_pairs, t1$2, tl1$1, match$3[0], match$3[1], (function (param, param$1) {
                                      return mcomp(type_pairs, env, param, param$1);
                                    }));
                    default:
                      throw [
                            Unify,
                            /* [] */0
                          ];
                  }
                }
                break;
            case /* Tpackage */11 :
                if (typeof match$3 === "number") {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                switch (match$3.tag | 0) {
                  case /* Tconstr */3 :
                      exit$2 = 3;
                      break;
                  case /* Tpackage */11 :
                      return ;
                  default:
                    throw [
                          Unify,
                          /* [] */0
                        ];
                }
                break;
            
          }
        }
        if (exit$2 === 3) {
          if (typeof match$3 === "number") {
            throw [
                  Unify,
                  /* [] */0
                ];
          }
          if (match$3.tag !== /* Tconstr */3) {
            throw [
                  Unify,
                  /* [] */0
                ];
          }
          p = match$3[0];
        }
        try {
          var decl$1 = find_type_full(p, env)[0];
          if (non_aliasable(p, decl$1) || is_datatype(decl$1)) {
            throw [
                  Unify,
                  /* [] */0
                ];
          }
          return ;
        }
        catch (exn$3){
          if (exn$3 === Caml_builtin_exceptions.not_found) {
            return ;
          }
          throw exn$3;
        }
      }
    }
    
  };
}

function mcomp_list(type_pairs, env, tl1, tl2) {
  if (List.length(tl1) !== List.length(tl2)) {
    throw [
          Unify,
          /* [] */0
        ];
  }
  return List.iter2((function (param, param$1) {
                return mcomp(type_pairs, env, param, param$1);
              }), tl1, tl2);
}

function mcomp_fields(type_pairs, env, ty1, ty2) {
  if (!(concrete_object(ty1) && concrete_object(ty2))) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "ctype.ml",
            2096,
            59
          ]
        ];
  }
  var match = flatten_fields(ty2);
  var match$1 = flatten_fields(ty1);
  var match$2 = associate_fields(match$1[0], match[0]);
  mcomp(type_pairs, env, match$1[1], match[1]);
  if (match$2[1] !== /* [] */0 && object_row(ty1).desc === /* Tnil */0 || match$2[2] !== /* [] */0 && object_row(ty2).desc === /* Tnil */0) {
    throw [
          Unify,
          /* [] */0
        ];
  }
  return List.iter((function (param) {
                mcomp_kind(param[1], param[3]);
                return mcomp(type_pairs, env, param[2], param[4]);
              }), match$2[0]);
}

function mcomp_kind(k1, k2) {
  var k1$1 = field_kind_repr(k1);
  var k2$1 = field_kind_repr(k2);
  if (typeof k1$1 === "number") {
    if (k1$1 !== 0) {
      throw [
            Unify,
            /* [] */0
          ];
    }
    if (typeof k2$1 !== "number") {
      throw [
            Unify,
            /* [] */0
          ];
    }
    if (k2$1 !== 0) {
      throw [
            Unify,
            /* [] */0
          ];
    }
    return ;
  } else {
    if (typeof k2$1 === "number") {
      throw [
            Unify,
            /* [] */0
          ];
    }
    return ;
  }
}

function mcomp_type_option(type_pairs, env, t, t$prime) {
  if (t !== void 0) {
    if (t$prime !== void 0) {
      return mcomp(type_pairs, env, t, t$prime);
    }
    throw [
          Unify,
          /* [] */0
        ];
  } else {
    if (t$prime !== void 0) {
      throw [
            Unify,
            /* [] */0
          ];
    }
    return ;
  }
}

function mcomp_record_description(type_pairs, env) {
  var iter = function (_x, _y) {
    while(true) {
      var y = _y;
      var x = _x;
      if (x) {
        if (!y) {
          throw [
                Unify,
                /* [] */0
              ];
        }
        var l2 = y[0];
        var l1 = x[0];
        mcomp(type_pairs, env, l1.ld_type, l2.ld_type);
        if (!(l1.ld_id.name === l2.ld_id.name && l1.ld_mutable === l2.ld_mutable)) {
          throw [
                Unify,
                /* [] */0
              ];
        }
        _y = y[1];
        _x = x[1];
        continue ;
      } else {
        if (y) {
          throw [
                Unify,
                /* [] */0
              ];
        }
        return ;
      }
    };
  };
  return iter;
}

function mcomp$1(env, t1, t2) {
  return mcomp(Curry._1(TypePairs.create, 4), env, t1, t2);
}

function find_lowest_level(ty) {
  var lowest = {
    contents: 100000000
  };
  var find = function (ty) {
    var ty$1 = repr(ty);
    if (ty$1.level >= 0) {
      if (ty$1.level < lowest.contents) {
        lowest.contents = ty$1.level;
      }
      ty$1.level = pivot_level - ty$1.level | 0;
      return iter_type_expr(find, ty$1);
    }
    
  };
  find(ty);
  unmark_type(ty);
  return lowest.contents;
}

function find_newtype_level(env, path) {
  try {
    var match = find_type_full(path, env)[0].type_newtype_level;
    if (match !== void 0) {
      return match;
    }
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "ctype.ml",
            2227,
            12
          ]
        ];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "ctype.ml",
              2228,
              20
            ]
          ];
    }
    throw exn;
  }
}

function add_gadt_equation(env, source, destination) {
  var destination$1 = type_expr(identity, destination);
  var source_lev = find_newtype_level(env.contents, /* Pident */Block.__(0, [source]));
  var decl = new_declaration(source_lev, destination$1);
  var newtype_level = get_newtype_level(void 0);
  env.contents = add_local_constraint(source, decl, newtype_level, env.contents);
  return cleanup_abbrev(void 0);
}

var unify_eq_set = Curry._1(TypePairs.create, 11);

function order_type_pair(t1, t2) {
  if (t1.id <= t2.id) {
    return /* tuple */[
            t1,
            t2
          ];
  } else {
    return /* tuple */[
            t2,
            t1
          ];
  }
}

function add_type_equality(t1, t2) {
  return Curry._3(TypePairs.add, unify_eq_set, order_type_pair(t1, t2), void 0);
}

function eq_package_path(env, p1, p2) {
  if (same(p1, p2)) {
    return true;
  } else {
    return same(normalize_package_path(env, p1), normalize_package_path(env, p2));
  }
}

var nondep_type$prime = {
  contents: (function (param, param$1, param$2) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "ctype.ml",
              2250,
              37
            ]
          ];
    })
};

var package_subtype = {
  contents: (function (param, param$1, param$2, param$3, param$4, param$5, param$6) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "ctype.ml",
              2251,
              48
            ]
          ];
    })
};

function concat_longident(lid1, param) {
  switch (param.tag | 0) {
    case /* Lident */0 :
        return /* Ldot */Block.__(1, [
                  lid1,
                  param[0]
                ]);
    case /* Ldot */1 :
        return /* Ldot */Block.__(1, [
                  concat_longident(lid1, param[0]),
                  param[1]
                ]);
    case /* Lapply */2 :
        return /* Lapply */Block.__(2, [
                  concat_longident(lid1, param[0]),
                  param[1]
                ]);
    
  }
}

function nondep_instance(env, level, id, ty) {
  var ty$1 = Curry._3(nondep_type$prime.contents, env, id, ty);
  if (level === 100000000) {
    return type_expr(identity, ty$1);
  }
  var old = current_level.contents;
  current_level.contents = level;
  var ty$2 = instance(void 0, env, ty$1);
  current_level.contents = old;
  return ty$2;
}

function complete_type_list(allow_absentOpt, env, nl1, lv2, mty2, nl2, tl2) {
  var allow_absent = allow_absentOpt !== void 0 ? allow_absentOpt : false;
  var id2 = create("Pkg");
  var env$prime = add_module$1(void 0, id2, mty2, env);
  var complete = function (_nl1, ntl2) {
    while(true) {
      var nl1 = _nl1;
      if (!nl1) {
        return ntl2;
      }
      var nl = nl1[1];
      var n = nl1[0];
      var exit = 0;
      if (ntl2) {
        var nt2 = ntl2[0];
        var n2 = nt2[0];
        if (Caml_obj.caml_greaterequal(n, n2)) {
          return /* :: */[
                  nt2,
                  complete(Caml_obj.caml_equal(n, n2) ? nl : nl1, ntl2[1])
                ];
        }
        exit = 1;
      } else {
        exit = 1;
      }
      if (exit === 1) {
        try {
          var match = lookup_type$1(concat_longident(/* Lident */Block.__(0, ["Pkg"]), n), env$prime);
          var decl = match[1];
          if (decl.type_arity !== 0) {
            throw Pervasives.Exit;
          }
          var match$1 = decl.type_kind;
          if (typeof match$1 !== "number") {
            throw Pervasives.Exit;
          }
          if (match$1 !== 0) {
            throw Pervasives.Exit;
          }
          if (!decl.type_private) {
            throw Pervasives.Exit;
          }
          var match$2 = decl.type_manifest;
          if (match$2 !== void 0) {
            return /* :: */[
                    /* tuple */[
                      n,
                      nondep_instance(env$prime, lv2, id2, match$2)
                    ],
                    complete(nl, ntl2)
                  ];
          }
          if (allow_absent) {
            return complete(nl, ntl2);
          }
          throw Pervasives.Exit;
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found && allow_absent) {
            _nl1 = nl;
            continue ;
          }
          if (exn === Pervasives.Exit) {
            throw Caml_builtin_exceptions.not_found;
          }
          throw exn;
        }
      }
      
    };
  };
  return complete(nl1, List.combine(nl2, tl2));
}

function unify_package(env, unify_list, lv1, p1, n1, tl1, lv2, p2, n2, tl2) {
  var ntl2 = complete_type_list(void 0, env, n1, lv2, /* Mty_ident */Block.__(0, [p2]), n2, tl2);
  var ntl1 = complete_type_list(void 0, env, n2, lv2, /* Mty_ident */Block.__(0, [p1]), n1, tl1);
  Curry._2(unify_list, List.map((function (prim) {
              return prim[1];
            }), ntl1), List.map((function (prim) {
              return prim[1];
            }), ntl2));
  if (eq_package_path(env, p1, p2) || Curry._7(package_subtype.contents, env, p1, n1, tl1, p2, n2, tl2) && Curry._7(package_subtype.contents, env, p2, n2, tl2, p1, n1, tl1)) {
    return ;
  }
  throw Caml_builtin_exceptions.not_found;
}

function unify_eq(env, t1, t2) {
  if (t1 === t2) {
    return true;
  }
  var match = umode.contents;
  if (!match) {
    return false;
  }
  try {
    Curry._2(TypePairs.find, unify_eq_set, order_type_pair(t1, t2));
    return true;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return false;
    }
    throw exn;
  }
}

function unify(env, t1, t2) {
  if (t1 === t2) {
    return ;
  }
  var t1$1 = repr(t1);
  var t2$1 = repr(t2);
  if (unify_eq(env.contents, t1$1, t2$1)) {
    return ;
  }
  var reset_tracing = check_trace_gadt_instances(env.contents);
  try {
    type_changed.contents = true;
    var match = t1$1.desc;
    var match$1 = t2$1.desc;
    var exit = 0;
    if (typeof match === "number") {
      exit = 1;
    } else {
      switch (match.tag | 0) {
        case /* Tvar */0 :
            var exit$1 = 0;
            if (typeof match$1 === "number" || !(match$1.tag === /* Tconstr */3 && deep_occur(t1$1, t2$1))) {
              exit$1 = 2;
            } else {
              unify2(env, t1$1, t2$1);
            }
            if (exit$1 === 2) {
              occur(env.contents, t1$1, t2$1);
              occur_univar(env.contents, t2$1);
              link_type(t1$1, t2$1);
              update_level(env.contents, t1$1.level, t2$1);
            }
            break;
        case /* Tconstr */3 :
            var p1 = match[0];
            if (typeof match$1 === "number") {
              unify2(env, t1$1, t2$1);
            } else {
              switch (match$1.tag | 0) {
                case /* Tvar */0 :
                    if (deep_occur(t2$1, t1$1)) {
                      unify2(env, t1$1, t2$1);
                    } else {
                      exit = 1;
                    }
                    break;
                case /* Tconstr */3 :
                    if (match[1] || match$1[1]) {
                      unify2(env, t1$1, t2$1);
                    } else {
                      var p2 = match$1[0];
                      if (same(p1, p2) && !(has_cached_expansion(p1, match[2].contents) || has_cached_expansion(p2, match$1[2].contents))) {
                        update_level(env.contents, t1$1.level, t2$1);
                        link_type(t1$1, t2$1);
                      } else if (env.contents.local_constraints && is_newtype(env.contents, p1) && is_newtype(env.contents, p2)) {
                        try {
                          if (Caml_obj.caml_lessthan(find_newtype_level(env.contents, p1), find_newtype_level(env.contents, p2))) {
                            unify(env, t1$1, try_expand_once(env.contents, t2$1));
                          } else {
                            unify(env, try_expand_once(env.contents, t1$1), t2$1);
                          }
                        }
                        catch (exn){
                          if (exn !== Cannot_expand) {
                            throw exn;
                          }
                          unify2(env, t1$1, t2$1);
                        }
                      } else {
                        unify2(env, t1$1, t2$1);
                      }
                    }
                    break;
                default:
                  unify2(env, t1$1, t2$1);
              }
            }
            break;
        case /* Tunivar */9 :
            if (typeof match$1 === "number") {
              unify2(env, t1$1, t2$1);
            } else {
              switch (match$1.tag | 0) {
                case /* Tvar */0 :
                    exit = 1;
                    break;
                case /* Tunivar */9 :
                    unify_univar(t1$1, t2$1, univar_pairs.contents);
                    update_level(env.contents, t1$1.level, t2$1);
                    link_type(t1$1, t2$1);
                    break;
                default:
                  unify2(env, t1$1, t2$1);
              }
            }
            break;
        default:
          exit = 1;
      }
    }
    if (exit === 1) {
      if (typeof match$1 === "number" || match$1.tag) {
        unify2(env, t1$1, t2$1);
      } else {
        occur(env.contents, t2$1, t1$1);
        occur_univar(env.contents, t1$1);
        link_type(t2$1, t1$1);
        update_level(env.contents, t2$1.level, t1$1);
      }
    }
    return reset_trace_gadt_instances(reset_tracing);
  }
  catch (raw_exn){
    var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn$1[0] !== Unify) {
      throw exn$1;
    }
    reset_trace_gadt_instances(reset_tracing);
    throw [
          Unify,
          /* :: */[
            /* tuple */[
              t1$1,
              t2$1
            ],
            exn$1[1]
          ]
        ];
  }
}

function unify_row(env, row1, row2) {
  var row1$1 = row_repr_aux(/* [] */0, row1);
  var row2$1 = row_repr_aux(/* [] */0, row2);
  var rm1 = row_more(row1$1);
  var rm2 = row_more(row2$1);
  if (unify_eq(env.contents, rm1, rm2)) {
    return ;
  }
  var match = merge_row_fields(row1$1.row_fields, row2$1.row_fields);
  var pairs = match[2];
  var r2 = match[1];
  var r1 = match[0];
  if (r1 !== /* [] */0 && r2 !== /* [] */0) {
    var ht = Hashtbl.create(void 0, List.length(r1));
    List.iter((function (param) {
            var l = param[0];
            return Hashtbl.add(ht, hash_variant(l), l);
          }), r1);
    List.iter((function (param) {
            var l = param[0];
            try {
              throw [
                    Tags,
                    l,
                    Hashtbl.find(ht, hash_variant(l))
                  ];
            }
            catch (exn){
              if (exn === Caml_builtin_exceptions.not_found) {
                return ;
              }
              throw exn;
            }
          }), r2);
  }
  var fixed1 = row_fixed(row1$1);
  var fixed2 = row_fixed(row2$1);
  var more = fixed1 ? rm1 : (
      fixed2 ? rm2 : newty2(rm1.level < rm2.level ? rm1.level : rm2.level, /* Tvar */Block.__(0, [void 0]))
    );
  var fixed = fixed1 || fixed2;
  var closed = row1$1.row_closed || row2$1.row_closed;
  var keep = function ($$switch) {
    return List.for_all((function (param) {
                  var match = Curry._2($$switch, param[1], param[2]);
                  if (row_field_repr_aux(/* [] */0, match[0]) === /* Rabsent */0) {
                    return true;
                  } else {
                    return row_field_repr_aux(/* [] */0, match[1]) !== /* Rabsent */0;
                  }
                }), pairs);
  };
  var empty = function (fields) {
    return List.for_all((function (param) {
                  return row_field_repr_aux(/* [] */0, param[1]) === /* Rabsent */0;
                }), fields);
  };
  if (closed && (empty(r1) || row2$1.row_closed) && (empty(r2) || row1$1.row_closed) && List.for_all((function (param) {
            if (row_field_repr_aux(/* [] */0, param[1]) === /* Rabsent */0) {
              return true;
            } else {
              return row_field_repr_aux(/* [] */0, param[2]) === /* Rabsent */0;
            }
          }), pairs)) {
    throw [
          Unify,
          /* :: */[
            /* tuple */[
              mkvariant(/* [] */0, true),
              mkvariant(/* [] */0, true)
            ],
            /* [] */0
          ]
        ];
  }
  var name = row1$1.row_name !== void 0 && (row1$1.row_closed || empty(r2)) && (!row2$1.row_closed || keep((function (f1, f2) {
            return /* tuple */[
                    f1,
                    f2
                  ];
          })) && empty(r1)) ? row1$1.row_name : (
      row2$1.row_name !== void 0 && (row2$1.row_closed || empty(r1)) && (!row1$1.row_closed || keep((function (f1, f2) {
                return /* tuple */[
                        f2,
                        f1
                      ];
              })) && empty(r2)) ? row2$1.row_name : void 0
    );
  var set_more = function (row, rest) {
    var rest$1 = closed ? filter_row_fields(row.row_closed, rest) : rest;
    if (rest$1 !== /* [] */0 && (row.row_closed || row_fixed(row)) || closed && row_fixed(row) && !row.row_closed) {
      var t1 = mkvariant(/* [] */0, true);
      var t2 = mkvariant(rest$1, false);
      throw [
            Unify,
            /* :: */[
              row === row1$1 ? /* tuple */[
                  t1,
                  t2
                ] : /* tuple */[
                  t2,
                  t1
                ],
              /* [] */0
            ]
          ];
    }
    var rm = row_more(row);
    if (trace_gadt_instances.contents && rm.desc === /* Tnil */0 || !trace_gadt_instances.contents) {
      
    } else {
      update_level(env.contents, rm.level, newty2(100000000, /* Tvariant */Block.__(8, [row])));
    }
    if (row_fixed(row)) {
      if (more === rm) {
        return ;
      } else if (is_Tvar(rm)) {
        return link_type(rm, more);
      } else {
        return unify(env, rm, more);
      }
    }
    var ty = newty2(100000000, /* Tvariant */Block.__(8, [{
              row_fields: rest$1,
              row_more: more,
              row_bound: void 0,
              row_closed: closed,
              row_fixed: fixed,
              row_name: name
            }]));
    update_level(env.contents, rm.level, ty);
    return link_type(rm, ty);
  };
  var md1 = rm1.desc;
  var md2 = rm2.desc;
  try {
    set_more(row2$1, r1);
    set_more(row1$1, r2);
    return List.iter((function (param) {
                  var f2 = param[2];
                  var f1 = param[1];
                  var l = param[0];
                  try {
                    var _f1 = f1;
                    var _f2 = f2;
                    while(true) {
                      var f2$1 = _f2;
                      var f1$1 = _f1;
                      var f1$2 = row_field_repr_aux(/* [] */0, f1$1);
                      var f2$2 = row_field_repr_aux(/* [] */0, f2$1);
                      if (f1$2 === f2$2) {
                        return ;
                      }
                      if (typeof f1$2 === "number") {
                        if (typeof f2$2 === "number") {
                          return ;
                        }
                        if (!f2$2.tag) {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        }
                        if (f2$2[2]) {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        }
                        if (fixed2) {
                          throw [
                                Unify,
                                /* [] */0
                              ];
                        }
                        return set_row_field(f2$2[3], f1$2);
                      } else if (f1$2.tag) {
                        var c1 = f1$2[0];
                        var m1 = f1$2[2];
                        var tl1 = f1$2[1];
                        var e1 = f1$2[3];
                        if (typeof f2$2 === "number") {
                          if (m1) {
                            throw [
                                  Unify,
                                  /* [] */0
                                ];
                          }
                          if (fixed1) {
                            throw [
                                  Unify,
                                  /* [] */0
                                ];
                          }
                          return set_row_field(f1$2[3], f2$2);
                        } else if (f2$2.tag) {
                          var e2 = f2$2[3];
                          if (e1 === e2) {
                            return ;
                          }
                          var m2 = f2$2[2];
                          var tl2 = f2$2[1];
                          var c2 = f2$2[0];
                          var redo = false;
                          if (m1 || m2 || fixed1 || fixed2 || rigid_variants.contents && (List.length(tl1) === 1 || List.length(tl2) === 1)) {
                            var match = Pervasives.$at(tl1, tl2);
                            var tmp;
                            if (match) {
                              var t1 = match[0];
                              if (c1 || c2) {
                                throw [
                                      Unify,
                                      /* [] */0
                                    ];
                              }
                              List.iter((function(t1){
                                  return function (param) {
                                    return unify(env, t1, param);
                                  }
                                  }(t1)), match[1]);
                              tmp = e1.contents !== void 0 || e2.contents !== void 0;
                            } else {
                              tmp = false;
                            }
                            redo = tmp;
                          }
                          if (redo) {
                            _f2 = f2$2;
                            _f1 = f1$2;
                            continue ;
                          } else {
                            var tl1$1 = List.map(repr, tl1);
                            var tl2$1 = List.map(repr, tl2);
                            var remq = function (tl, _param) {
                              while(true) {
                                var param = _param;
                                if (!param) {
                                  return /* [] */0;
                                }
                                var tl$prime = param[1];
                                var ty = param[0];
                                if (!List.memq(ty, tl)) {
                                  return /* :: */[
                                          ty,
                                          remq(tl, tl$prime)
                                        ];
                                }
                                _param = tl$prime;
                                continue ;
                              };
                            };
                            var tl2$prime = remq(tl2$1, tl1$1);
                            var tl1$prime = remq(tl1$1, tl2$1);
                            var partial_arg = repr(more).level;
                            var partial_arg$1 = env.contents;
                            List.iter((function(partial_arg,partial_arg$1){
                                return function (param) {
                                  return update_level(partial_arg$1, partial_arg, param);
                                }
                                }(partial_arg,partial_arg$1)), Pervasives.$at(tl1$prime, tl2$prime));
                            var e = {
                              contents: void 0
                            };
                            var f1$prime_000 = c1 || c2;
                            var f1$prime_002 = m1 || m2;
                            var f1$prime = /* Reither */Block.__(1, [
                                f1$prime_000,
                                tl1$prime,
                                f1$prime_002,
                                e
                              ]);
                            var f2$prime_000 = c1 || c2;
                            var f2$prime_002 = m1 || m2;
                            var f2$prime = /* Reither */Block.__(1, [
                                f2$prime_000,
                                tl2$prime,
                                f2$prime_002,
                                e
                              ]);
                            set_row_field(e1, f1$prime);
                            return set_row_field(e2, f2$prime);
                          }
                        } else if (c1) {
                          if (f1$2[1]) {
                            throw [
                                  Unify,
                                  /* [] */0
                                ];
                          }
                          if (f2$2[0] !== void 0) {
                            throw [
                                  Unify,
                                  /* [] */0
                                ];
                          }
                          if (fixed1) {
                            throw [
                                  Unify,
                                  /* [] */0
                                ];
                          }
                          return set_row_field(f1$2[3], f2$2);
                        } else {
                          var match$1 = f2$2[0];
                          if (match$1 === void 0) {
                            throw [
                                  Unify,
                                  /* [] */0
                                ];
                          }
                          if (fixed1) {
                            throw [
                                  Unify,
                                  /* [] */0
                                ];
                          }
                          var t2 = match$1;
                          var e1$1 = f1$2[3];
                          set_row_field(e1$1, f2$2);
                          update_level(env.contents, repr(more).level, t2);
                          try {
                            return List.iter((function(t2){
                                      return function (t1) {
                                        return unify(env, t1, t2);
                                      }
                                      }(t2)), f1$2[1]);
                          }
                          catch (exn){
                            e1$1.contents = void 0;
                            throw exn;
                          }
                        }
                      } else {
                        var match$2 = f1$2[0];
                        if (match$2 !== void 0) {
                          var t1$1 = match$2;
                          if (typeof f2$2 === "number") {
                            throw [
                                  Unify,
                                  /* [] */0
                                ];
                          }
                          if (f2$2.tag) {
                            if (f2$2[0]) {
                              throw [
                                    Unify,
                                    /* [] */0
                                  ];
                            }
                            if (fixed2) {
                              throw [
                                    Unify,
                                    /* [] */0
                                  ];
                            }
                            var e2$1 = f2$2[3];
                            set_row_field(e2$1, f1$2);
                            update_level(env.contents, repr(more).level, t1$1);
                            try {
                              return List.iter((function(t1$1){
                                        return function (param) {
                                          return unify(env, t1$1, param);
                                        }
                                        }(t1$1)), f2$2[1]);
                            }
                            catch (exn$1){
                              e2$1.contents = void 0;
                              throw exn$1;
                            }
                          } else {
                            var match$3 = f2$2[0];
                            if (match$3 !== void 0) {
                              return unify(env, t1$1, match$3);
                            }
                            throw [
                                  Unify,
                                  /* [] */0
                                ];
                          }
                        } else {
                          if (typeof f2$2 === "number") {
                            throw [
                                  Unify,
                                  /* [] */0
                                ];
                          }
                          if (f2$2.tag) {
                            if (!f2$2[0]) {
                              throw [
                                    Unify,
                                    /* [] */0
                                  ];
                            }
                            if (f2$2[1]) {
                              throw [
                                    Unify,
                                    /* [] */0
                                  ];
                            }
                            if (fixed2) {
                              throw [
                                    Unify,
                                    /* [] */0
                                  ];
                            }
                            return set_row_field(f2$2[3], f1$2);
                          } else {
                            if (f2$2[0] !== void 0) {
                              throw [
                                    Unify,
                                    /* [] */0
                                  ];
                            }
                            return ;
                          }
                        }
                      }
                    };
                  }
                  catch (raw_exn){
                    var exn$2 = Caml_js_exceptions.internalToOCamlException(raw_exn);
                    if (exn$2[0] === Unify) {
                      throw [
                            Unify,
                            /* :: */[
                              /* tuple */[
                                mkvariant(/* :: */[
                                      /* tuple */[
                                        l,
                                        f1
                                      ],
                                      /* [] */0
                                    ], true),
                                mkvariant(/* :: */[
                                      /* tuple */[
                                        l,
                                        f2
                                      ],
                                      /* [] */0
                                    ], true)
                              ],
                              exn$2[1]
                            ]
                          ];
                    }
                    throw exn$2;
                  }
                }), pairs);
  }
  catch (exn){
    log_type(rm1);
    rm1.desc = md1;
    log_type(rm2);
    rm2.desc = md2;
    throw exn;
  }
}

function unify_list(env, tl1, tl2) {
  if (List.length(tl1) !== List.length(tl2)) {
    throw [
          Unify,
          /* [] */0
        ];
  }
  return List.iter2((function (param, param$1) {
                return unify(env, param, param$1);
              }), tl1, tl2);
}

function unify_fields(env, ty1, ty2) {
  var match = flatten_fields(ty1);
  var rest1 = match[1];
  var match$1 = flatten_fields(ty2);
  var rest2 = match$1[1];
  var match$2 = associate_fields(match[0], match$1[0]);
  var miss2 = match$2[2];
  var miss1 = match$2[1];
  var l1 = repr(ty1).level;
  var l2 = repr(ty2).level;
  var va = make_rowvar(l1 < l2 ? l1 : l2, miss2 === /* [] */0, rest1, miss1 === /* [] */0, rest2);
  var d1 = rest1.desc;
  var d2 = rest2.desc;
  try {
    unify(env, build_fields(l1)(miss1, va), rest2);
    unify(env, rest1, build_fields(l2)(miss2, va));
    return List.iter((function (param) {
                  var t2 = param[4];
                  var k2 = param[3];
                  var t1 = param[2];
                  var k1 = param[1];
                  var n = param[0];
                  unify_kind(k1, k2);
                  try {
                    if (trace_gadt_instances.contents) {
                      update_level(env.contents, va.level, t1);
                    }
                    return unify(env, t1, t2);
                  }
                  catch (raw_exn){
                    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                    if (exn[0] === Unify) {
                      var desc_003 = newty2(current_level.contents, /* Tnil */0);
                      var desc = /* Tfield */Block.__(5, [
                          n,
                          k1,
                          t1,
                          desc_003
                        ]);
                      var desc_003$1 = newty2(current_level.contents, /* Tnil */0);
                      var desc$1 = /* Tfield */Block.__(5, [
                          n,
                          k2,
                          t2,
                          desc_003$1
                        ]);
                      throw [
                            Unify,
                            /* :: */[
                              /* tuple */[
                                newty2(current_level.contents, desc),
                                newty2(current_level.contents, desc$1)
                              ],
                              exn[1]
                            ]
                          ];
                    }
                    throw exn;
                  }
                }), match$2[0]);
  }
  catch (exn){
    log_type(rest1);
    rest1.desc = d1;
    log_type(rest2);
    rest2.desc = d2;
    throw exn;
  }
}

function unify2(env, t1, t2) {
  var expand_both = function (_t1$prime$prime, _t2$prime$prime) {
    while(true) {
      var t2$prime$prime = _t2$prime$prime;
      var t1$prime$prime = _t1$prime$prime;
      var t1$prime = expand_head_unif(env.contents, t1);
      var t2$prime = expand_head_unif(env.contents, t2);
      if (unify_eq(env.contents, t1$prime, t1$prime$prime) && unify_eq(env.contents, t2$prime, t2$prime$prime)) {
        return /* tuple */[
                t1$prime,
                t2$prime
              ];
      }
      _t2$prime$prime = t2$prime;
      _t1$prime$prime = t1$prime;
      continue ;
    };
  };
  var match = expand_both(t1, t2);
  var t2$prime = match[1];
  var t1$prime = match[0];
  var lv = t1$prime.level < t2$prime.level ? t1$prime.level : t2$prime.level;
  update_level(env.contents, lv, t2);
  update_level(env.contents, lv, t1);
  if (unify_eq(env.contents, t1$prime, t2$prime)) {
    return ;
  }
  var t1$1 = repr(t1);
  var t2$1 = repr(t2);
  if (trace_gadt_instances.contents) {
    var ilevel = function (t) {
      var match = gadt_instance_level(env.contents, t);
      if (match !== void 0) {
        return match;
      } else {
        return 0;
      }
    };
    var lv1 = ilevel(t1$1);
    var lv2 = ilevel(t2$1);
    if (lv1 > lv2) {
      add_gadt_instance_chain(env.contents, lv1, t2$1);
    } else if (lv2 > lv1) {
      add_gadt_instance_chain(env.contents, lv2, t1$1);
    }
    
  }
  var match$1;
  if (principal.contents && (find_lowest_level(t1$prime) < lv || find_lowest_level(t2$prime) < lv)) {
    var match$2 = t1$1.desc;
    var tmp;
    tmp = typeof match$2 === "number" || !(match$2.tag === /* Tconstr */3 && !match$2[1]) ? t1$1 : t1$prime;
    var match$3 = t2$1.desc;
    var tmp$1;
    tmp$1 = typeof match$3 === "number" || !(match$3.tag === /* Tconstr */3 && !match$3[1]) ? t2$1 : t2$prime;
    match$1 = /* tuple */[
      tmp,
      tmp$1
    ];
  } else {
    match$1 = /* tuple */[
      t1$1,
      t2$1
    ];
  }
  var t2$2 = match$1[1];
  var t1$2 = match$1[0];
  if (unify_eq(env.contents, t1$2, t1$prime) || !unify_eq(env.contents, t2$2, t2$prime)) {
    return unify3(env, t1$2, t1$prime, t2$2, t2$prime);
  }
  try {
    return unify3(env, t2$2, t2$prime, t1$2, t1$prime);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === Unify) {
      throw [
            Unify,
            List.map((function (param) {
                    return /* tuple */[
                            param[1],
                            param[0]
                          ];
                  }), exn[1])
          ];
    }
    throw exn;
  }
}

function unify3(env, t1, t1$prime, t2, t2$prime) {
  var d1 = t1$prime.desc;
  var d2 = t2$prime.desc;
  var create_recursion = t2 !== t2$prime && deep_occur(t1$prime, t2);
  var exit = 0;
  var exit$1 = 0;
  if (typeof d1 === "number") {
    exit$1 = 2;
  } else {
    switch (d1.tag | 0) {
      case /* Tvar */0 :
          occur(env.contents, t1$prime, t2);
          occur_univar(env.contents, t2);
          return link_type(t1$prime, t2);
      case /* Tfield */5 :
          if (typeof d2 === "number") {
            exit = 1;
          } else {
            switch (d2.tag | 0) {
              case /* Tvar */0 :
                  exit$1 = 2;
                  break;
              case /* Tfield */5 :
                  return unify_fields(env, t1$prime, t2$prime);
              default:
                exit = 1;
            }
          }
          break;
      case /* Tunivar */9 :
          if (typeof d2 === "number") {
            exit = 1;
          } else {
            switch (d2.tag | 0) {
              case /* Tvar */0 :
                  exit$1 = 2;
                  break;
              case /* Tunivar */9 :
                  unify_univar(t1$prime, t2$prime, univar_pairs.contents);
                  return link_type(t1$prime, t2$prime);
              default:
                exit = 1;
            }
          }
          break;
      default:
        exit$1 = 2;
    }
  }
  if (exit$1 === 2) {
    if (typeof d2 === "number" || d2.tag) {
      exit = 1;
    } else {
      occur(env.contents, t2$prime, t1);
      occur_univar(env.contents, t1);
      return link_type(t2$prime, t1);
    }
  }
  if (exit === 1) {
    var match = umode.contents;
    if (match) {
      add_type_equality(t1$prime, t2$prime);
    } else {
      occur(env.contents, t1$prime, t2$prime);
      link_type(t1$prime, t2);
    }
    try {
      var exit$2 = 0;
      var f;
      var kind;
      var rem;
      var exit$3 = 0;
      var exit$4 = 0;
      if (typeof d1 === "number") {
        if (typeof d2 !== "number") {
          switch (d2.tag | 0) {
            case /* Tconstr */3 :
                exit$4 = 5;
                break;
            case /* Tfield */5 :
                f = d2[0];
                kind = d2[1];
                rem = d2[3];
                exit$2 = 3;
                break;
            default:
              throw [
                    Unify,
                    /* [] */0
                  ];
          }
        }
        
      } else {
        switch (d1.tag | 0) {
          case /* Tarrow */1 :
              var l1 = d1[0];
              if (typeof d2 === "number") {
                throw [
                      Unify,
                      /* [] */0
                    ];
              }
              switch (d2.tag | 0) {
                case /* Tarrow */1 :
                    var l2 = d2[0];
                    if (!(l1 === l2 || classic.contents && !(is_optional(l1) || is_optional(l2)))) {
                      throw [
                            Unify,
                            /* [] */0
                          ];
                    }
                    unify(env, d1[1], d2[1]);
                    unify(env, d1[2], d2[2]);
                    var match$1 = commu_repr(d1[3]);
                    var match$2 = commu_repr(d2[3]);
                    if (typeof match$1 === "number") {
                      if (typeof match$2 === "number") {
                        
                      } else {
                        set_commu(match$2[0], match$1);
                      }
                    } else {
                      set_commu(match$1[0], match$2);
                    }
                    break;
                case /* Tconstr */3 :
                    exit$4 = 5;
                    break;
                default:
                  throw [
                        Unify,
                        /* [] */0
                      ];
              }
              break;
          case /* Ttuple */2 :
              if (typeof d2 === "number") {
                throw [
                      Unify,
                      /* [] */0
                    ];
              }
              switch (d2.tag | 0) {
                case /* Ttuple */2 :
                    unify_list(env, d1[0], d2[0]);
                    break;
                case /* Tconstr */3 :
                    exit$4 = 5;
                    break;
                default:
                  throw [
                        Unify,
                        /* [] */0
                      ];
              }
              break;
          case /* Tconstr */3 :
              var p1 = d1[0];
              var exit$5 = 0;
              if (typeof d2 === "number" || d2.tag !== /* Tconstr */3) {
                exit$5 = 6;
              } else {
                var tl2 = d2[1];
                var tl1 = d1[1];
                if (same(p1, d2[0])) {
                  if (umode.contents === /* Expression */0 || !generate_equations.contents) {
                    unify_list(env, tl1, tl2);
                  } else if (assume_injective.contents) {
                    set_mode_pattern(true, false, (function (param) {
                            return unify_list(env, tl1, tl2);
                          }));
                  } else {
                    var tmp = true;
                    if (!in_current_module(p1)) {
                      var partial_arg = env.contents;
                      tmp = List.exists((function (param) {
                              return expands_to_datatype(partial_arg, param);
                            }), /* :: */[
                            t1$prime,
                            /* :: */[
                              t1,
                              /* :: */[
                                t2,
                                /* [] */0
                              ]
                            ]
                          ]);
                    }
                    if (tmp) {
                      unify_list(env, tl1, tl2);
                    } else {
                      var inj;
                      try {
                        inj = List.map(Curry._1(Types_Variance.mem, /* Inj */3), find_type_full(p1, env.contents)[0].type_variance);
                      }
                      catch (exn){
                        if (exn !== Caml_builtin_exceptions.not_found) {
                          throw exn;
                        }
                        inj = List.map((function (param) {
                                return false;
                              }), tl1);
                      }
                      List.iter2((function (i, param) {
                              var t2 = param[1];
                              var t1 = param[0];
                              if (i) {
                                return unify(env, t1, t2);
                              } else {
                                return set_mode_pattern(false, false, (function (param) {
                                              var snap = snapshot(void 0);
                                              try {
                                                return unify(env, t1, t2);
                                              }
                                              catch (raw_exn){
                                                var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                                                if (exn[0] !== Unify) {
                                                  throw exn;
                                                }
                                                backtrack(snap);
                                                reify(env, t1);
                                                return reify(env, t2);
                                              }
                                            }));
                              }
                            }), inj, List.combine(tl1, tl2));
                    }
                  }
                } else {
                  exit$5 = 6;
                }
              }
              if (exit$5 === 6) {
                switch (p1.tag | 0) {
                  case /* Pident */0 :
                      if (d1[1]) {
                        exit$4 = 5;
                      } else {
                        var p = p1[0];
                        var exit$6 = 0;
                        if (typeof d2 === "number" || d2.tag !== /* Tconstr */3) {
                          exit$6 = 7;
                        } else {
                          var path$prime = d2[0];
                          switch (path$prime.tag | 0) {
                            case /* Pident */0 :
                                if (d2[1] || !(is_newtype(env.contents, p1) && is_newtype(env.contents, path$prime) && generate_equations.contents)) {
                                  exit$6 = 7;
                                } else {
                                  var match$3 = Caml_obj.caml_greaterthan(find_newtype_level(env.contents, p1), find_newtype_level(env.contents, path$prime)) ? /* tuple */[
                                      p,
                                      t2$prime
                                    ] : /* tuple */[
                                      path$prime[0],
                                      t1$prime
                                    ];
                                  add_gadt_equation(env, match$3[0], match$3[1]);
                                }
                                break;
                            case /* Pdot */1 :
                            case /* Papply */2 :
                                exit$6 = 7;
                                break;
                            
                          }
                        }
                        if (exit$6 === 7) {
                          if (is_newtype(env.contents, p1) && generate_equations.contents) {
                            reify(env, t2$prime);
                            add_gadt_equation(env, p, t2$prime);
                          } else {
                            exit$4 = 5;
                          }
                        }
                        
                      }
                      break;
                  case /* Pdot */1 :
                  case /* Papply */2 :
                      exit$4 = 5;
                      break;
                  
                }
              }
              break;
          case /* Tobject */4 :
              var nm1 = d1[1];
              if (typeof d2 === "number") {
                throw [
                      Unify,
                      /* [] */0
                    ];
              }
              switch (d2.tag | 0) {
                case /* Tconstr */3 :
                    exit$4 = 5;
                    break;
                case /* Tobject */4 :
                    unify_fields(env, d1[0], d2[0]);
                    var match$4 = repr(t2$prime).desc;
                    if (typeof match$4 !== "number" && match$4.tag === /* Tobject */4) {
                      var nm2 = match$4[1];
                      var match$5 = nm2.contents;
                      if (match$5 !== void 0) {
                        var match$6 = match$5[1];
                        if (match$6) {
                          var match$7 = repr(match$6[0]).desc;
                          var tmp$1;
                          if (typeof match$7 === "number") {
                            tmp$1 = true;
                          } else {
                            switch (match$7.tag | 0) {
                              case /* Tvar */0 :
                              case /* Tunivar */9 :
                                  tmp$1 = true;
                                  break;
                              default:
                                tmp$1 = false;
                            }
                          }
                          if (tmp$1) {
                            
                          } else {
                            set_name(nm2, nm1.contents);
                          }
                        } else {
                          set_name(nm2, nm1.contents);
                        }
                      } else {
                        set_name(nm2, nm1.contents);
                      }
                    }
                    break;
                default:
                  throw [
                        Unify,
                        /* [] */0
                      ];
              }
              break;
          case /* Tfield */5 :
              if (typeof d2 === "number") {
                f = d1[0];
                kind = d1[1];
                rem = d1[3];
                exit$2 = 3;
              } else {
                if (d2.tag !== /* Tconstr */3) {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                exit$4 = 5;
              }
              break;
          case /* Tvariant */8 :
              var row1 = d1[0];
              if (typeof d2 === "number") {
                throw [
                      Unify,
                      /* [] */0
                    ];
              }
              switch (d2.tag | 0) {
                case /* Tconstr */3 :
                    exit$4 = 5;
                    break;
                case /* Tvariant */8 :
                    var row2 = d2[0];
                    if (umode.contents === /* Expression */0) {
                      unify_row(env, row1, row2);
                    } else {
                      var snap = snapshot(void 0);
                      try {
                        unify_row(env, row1, row2);
                      }
                      catch (raw_exn){
                        var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn);
                        if (exn$1[0] !== Unify) {
                          throw exn$1;
                        }
                        backtrack(snap);
                        reify(env, t1$prime);
                        reify(env, t2$prime);
                        if (generate_equations.contents) {
                          mcomp$1(env.contents, t1$prime, t2$prime);
                        }
                        
                      }
                    }
                    break;
                default:
                  throw [
                        Unify,
                        /* [] */0
                      ];
              }
              break;
          case /* Tpoly */10 :
              var tl1$1 = d1[1];
              var t1$1 = d1[0];
              var exit$7 = 0;
              if (tl1$1) {
                exit$7 = 6;
              } else {
                if (typeof d2 === "number") {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                switch (d2.tag | 0) {
                  case /* Tconstr */3 :
                      exit$4 = 5;
                      break;
                  case /* Tpoly */10 :
                      if (d2[1]) {
                        exit$7 = 6;
                      } else {
                        unify(env, t1$1, d2[0]);
                      }
                      break;
                  default:
                    throw [
                          Unify,
                          /* [] */0
                        ];
                }
              }
              if (exit$7 === 6) {
                if (typeof d2 === "number") {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                switch (d2.tag | 0) {
                  case /* Tconstr */3 :
                      exit$4 = 5;
                      break;
                  case /* Tpoly */10 :
                      enter_poly(env.contents, univar_pairs, t1$1, tl1$1, d2[0], d2[1], (function (param, param$1) {
                              return unify(env, param, param$1);
                            }));
                      break;
                  default:
                    throw [
                          Unify,
                          /* [] */0
                        ];
                }
              }
              break;
          case /* Tpackage */11 :
              var tl1$2 = d1[2];
              if (typeof d2 === "number") {
                throw [
                      Unify,
                      /* [] */0
                    ];
              }
              switch (d2.tag | 0) {
                case /* Tconstr */3 :
                    exit$4 = 5;
                    break;
                case /* Tpackage */11 :
                    var tl2$1 = d2[2];
                    try {
                      unify_package(env.contents, (function (param, param$1) {
                              return unify_list(env, param, param$1);
                            }), t1.level, d1[0], d1[1], tl1$2, t2.level, d2[0], d2[1], tl2$1);
                    }
                    catch (exn$2){
                      if (exn$2 !== Caml_builtin_exceptions.not_found) {
                        throw exn$2;
                      }
                      if (umode.contents === /* Expression */0) {
                        throw [
                              Unify,
                              /* [] */0
                            ];
                      }
                      List.iter((function (param) {
                              return reify(env, param);
                            }), Pervasives.$at(tl1$2, tl2$1));
                    }
                    break;
                default:
                  throw [
                        Unify,
                        /* [] */0
                      ];
              }
              break;
          default:
            exit$4 = 5;
        }
      }
      if (exit$4 === 5) {
        if (typeof d2 === "number" || d2.tag !== /* Tconstr */3) {
          exit$3 = 4;
        } else {
          var path = d2[0];
          switch (path.tag | 0) {
            case /* Pident */0 :
                if (d2[1] || !(is_newtype(env.contents, path) && generate_equations.contents)) {
                  exit$2 = 2;
                } else {
                  reify(env, t1$prime);
                  add_gadt_equation(env, path[0], t1$prime);
                }
                break;
            case /* Pdot */1 :
            case /* Papply */2 :
                exit$2 = 2;
                break;
            
          }
        }
      }
      if (exit$3 === 4) {
        if (typeof d1 === "number") {
          throw [
                Unify,
                /* [] */0
              ];
        }
        if (d1.tag !== /* Tconstr */3) {
          throw [
                Unify,
                /* [] */0
              ];
        }
        exit$2 = 2;
      }
      switch (exit$2) {
        case 2 :
            if (umode.contents !== /* Pattern */1) {
              throw [
                    Unify,
                    /* [] */0
                  ];
            }
            reify(env, t1$prime);
            reify(env, t2$prime);
            if (generate_equations.contents) {
              mcomp$1(env.contents, t1$prime, t2$prime);
            }
            break;
        case 3 :
            var match$8 = field_kind_repr(kind);
            if (typeof match$8 === "number") {
              throw [
                    Unify,
                    /* [] */0
                  ];
            }
            if (f === dummy_method) {
              throw [
                    Unify,
                    /* [] */0
                  ];
            }
            set_kind(match$8[0], /* Fabsent */1);
            if (d2 === /* Tnil */0) {
              unify(env, rem, t2$prime);
            } else {
              unify(env, newty2(rem.level, /* Tnil */0), rem);
            }
            break;
        
      }
      if (!create_recursion) {
        return ;
      }
      var match$9 = t2.desc;
      if (typeof match$9 === "number") {
        return ;
      }
      if (match$9.tag !== /* Tconstr */3) {
        return ;
      }
      forget_abbrev(match$9[2], match$9[0]);
      var t2$prime$prime = expand_head_unif(env.contents, t2);
      if (!closed_parameterized_type(match$9[1], t2$prime$prime)) {
        return link_type(repr(t2), repr(t2$prime));
      } else {
        return ;
      }
    }
    catch (raw_exn$1){
      var exn$3 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
      if (exn$3[0] !== Unify) {
        throw exn$3;
      }
      t1$prime.desc = d1;
      throw [
            Unify,
            exn$3[1]
          ];
    }
  }
  
}

function unify_kind(k1, k2) {
  var k1$1 = field_kind_repr(k1);
  var k2$1 = field_kind_repr(k2);
  if (k1$1 === k2$1) {
    return ;
  }
  if (typeof k1$1 === "number") {
    if (k1$1 === 0) {
      if (typeof k2$1 !== "number") {
        return set_kind(k2$1[0], k1$1);
      }
      if (k2$1 === 0) {
        return ;
      }
      
    }
    
  } else {
    var r = k1$1[0];
    if (typeof k2$1 !== "number") {
      return set_kind(r, k2$1);
    }
    if (k2$1 === 0) {
      return set_kind(r, k2$1);
    }
    
  }
  throw [
        Caml_builtin_exceptions.assert_failure,
        /* tuple */[
          "ctype.ml",
          2624,
          37
        ]
      ];
}

function make_rowvar(level, use1, rest1, use2, rest2) {
  var set_name = function (ty, name) {
    var match = ty.desc;
    if (typeof match === "number" || match.tag || match[0] !== void 0) {
      return ;
    } else {
      log_type(ty);
      ty.desc = /* Tvar */Block.__(0, [name]);
      return ;
    }
  };
  var match = rest1.desc;
  var match$1 = rest2.desc;
  var name;
  var exit = 0;
  if (typeof match === "number" || match.tag) {
    exit = 1;
  } else {
    var name1 = match[0];
    if (name1 !== void 0) {
      var exit$1 = 0;
      if (typeof match$1 === "number" || match$1.tag) {
        exit$1 = 2;
      } else {
        var name2 = match$1[0];
        if (name2 !== void 0) {
          name = rest1.level <= rest2.level ? name1 : name2;
        } else {
          exit$1 = 2;
        }
      }
      if (exit$1 === 2) {
        if (use2) {
          set_name(rest2, name1);
        }
        name = name1;
      }
      
    } else {
      exit = 1;
    }
  }
  if (exit === 1) {
    if (typeof match$1 === "number" || match$1.tag) {
      name = void 0;
    } else {
      var name$1 = match$1[0];
      if (name$1 !== void 0) {
        if (use1) {
          set_name(rest2, name$1);
        }
        name = name$1;
      } else {
        name = void 0;
      }
    }
  }
  if (use1) {
    return rest1;
  } else if (use2) {
    return rest2;
  } else {
    return newty2(level, /* Tvar */Block.__(0, [name]));
  }
}

function unify$1(env, ty1, ty2) {
  try {
    return unify(env, ty1, ty2);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === Unify) {
      throw [
            Unify,
            expand_trace(env.contents, exn[1])
          ];
    }
    if (exn === Recursive_abbrev) {
      throw [
            Unification_recursive_abbrev,
            expand_trace(env.contents, /* :: */[
                  /* tuple */[
                    ty1,
                    ty2
                  ],
                  /* [] */0
                ])
          ];
    }
    throw exn;
  }
}

function unify_var(env, t1, t2) {
  var t1$1 = repr(t1);
  var t2$1 = repr(t2);
  if (t1$1 === t2$1) {
    return ;
  }
  var match = t1$1.desc;
  if (typeof match === "number") {
    return unify$1({
                contents: env
              }, t1$1, t2$1);
  }
  if (match.tag) {
    return unify$1({
                contents: env
              }, t1$1, t2$1);
  }
  var reset_tracing = check_trace_gadt_instances(env);
  try {
    occur(env, t1$1, t2$1);
    update_level(env, t1$1.level, t2$1);
    link_type(t1$1, t2$1);
    return reset_trace_gadt_instances(reset_tracing);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] !== Unify) {
      throw exn;
    }
    reset_trace_gadt_instances(reset_tracing);
    var expanded_trace = expand_trace(env, /* :: */[
          /* tuple */[
            t1$1,
            t2$1
          ],
          exn[1]
        ]);
    throw [
          Unify,
          expanded_trace
        ];
  }
}

unify$prime.contents = unify_var;

function unify_pairs(env, ty1, ty2, pairs) {
  univar_pairs.contents = pairs;
  return unify$1(env, ty1, ty2);
}

function unify$2(env, ty1, ty2) {
  return unify_pairs({
              contents: env
            }, ty1, ty2, /* [] */0);
}

function expand_head_trace(env, t) {
  var reset_tracing = check_trace_gadt_instances(env);
  var t$1 = expand_head_unif(env, t);
  reset_trace_gadt_instances(reset_tracing);
  return t$1;
}

function filter_arrow(env, t, l) {
  var t$1 = expand_head_trace(env, t);
  var match = t$1.desc;
  if (typeof match === "number") {
    throw [
          Unify,
          /* [] */0
        ];
  }
  switch (match.tag | 0) {
    case /* Tvar */0 :
        var lv = t$1.level;
        var t1 = newty2(lv, /* Tvar */Block.__(0, [void 0]));
        var t2 = newty2(lv, /* Tvar */Block.__(0, [void 0]));
        var t$prime = newty2(lv, /* Tarrow */Block.__(1, [
                l,
                t1,
                t2,
                /* Cok */0
              ]));
        link_type(t$1, t$prime);
        return /* tuple */[
                t1,
                t2
              ];
    case /* Tarrow */1 :
        var l$prime = match[0];
        if (l === l$prime || classic.contents && l === "" && !is_optional(l$prime)) {
          return /* tuple */[
                  match[1],
                  match[2]
                ];
        }
        throw [
              Unify,
              /* [] */0
            ];
    default:
      throw [
            Unify,
            /* [] */0
          ];
  }
}

function filter_method_field(env, name, priv, _ty) {
  while(true) {
    var ty = _ty;
    var ty$1 = expand_head_trace(env, ty);
    var match = ty$1.desc;
    if (typeof match === "number") {
      throw [
            Unify,
            /* [] */0
          ];
    }
    switch (match.tag | 0) {
      case /* Tvar */0 :
          var level = ty$1.level;
          var ty1 = newty2(level, /* Tvar */Block.__(0, [void 0]));
          var ty2 = newty2(level, /* Tvar */Block.__(0, [void 0]));
          var ty$prime = newty2(level, /* Tfield */Block.__(5, [
                  name,
                  priv ? /* Fpresent */0 : /* Fvar */[{
                        contents: void 0
                      }],
                  ty1,
                  ty2
                ]));
          link_type(ty$1, ty$prime);
          return ty1;
      case /* Tfield */5 :
          var kind = field_kind_repr(match[1]);
          if (match[0] === name && kind !== /* Fabsent */1) {
            if (priv === /* Public */1) {
              unify_kind(kind, /* Fpresent */0);
            }
            return match[2];
          } else {
            _ty = match[3];
            continue ;
          }
      default:
        throw [
              Unify,
              /* [] */0
            ];
    }
  };
}

function filter_method(env, name, priv, ty) {
  var ty$1 = expand_head_trace(env, ty);
  var match = ty$1.desc;
  if (typeof match === "number") {
    throw [
          Unify,
          /* [] */0
        ];
  }
  switch (match.tag | 0) {
    case /* Tvar */0 :
        var ty1 = newvar(void 0, void 0);
        var ty$prime = newobj(ty1);
        update_level(env, ty$1.level, ty$prime);
        link_type(ty$1, ty$prime);
        return filter_method_field(env, name, priv, ty1);
    case /* Tobject */4 :
        return filter_method_field(env, name, priv, match[0]);
    default:
      throw [
            Unify,
            /* [] */0
          ];
  }
}

function filter_self_method(env, lab, priv, meths, ty) {
  var ty$prime = filter_method(env, lab, priv, ty);
  try {
    return find(lab, meths.contents);
  }
  catch (exn){
    if (exn !== Caml_builtin_exceptions.not_found) {
      throw exn;
    }
    var pair_000 = create(lab);
    var pair = /* tuple */[
      pair_000,
      ty$prime
    ];
    meths.contents = add$1(lab, pair, meths.contents);
    return pair;
  }
}

function moregen_occur(env, level, ty) {
  var occur = function (ty) {
    var ty$1 = repr(ty);
    if (ty$1.level <= level) {
      return ;
    }
    if (is_Tvar(ty$1) && ty$1.level >= 99999999) {
      throw Occur;
    }
    ty$1.level = pivot_level - ty$1.level | 0;
    var match = ty$1.desc;
    if (typeof match === "number") {
      return iter_type_expr(occur, ty$1);
    }
    if (match.tag !== /* Tvariant */8) {
      return iter_type_expr(occur, ty$1);
    }
    var row = match[0];
    if (static_row(row)) {
      return iter_row(occur, row);
    } else {
      return iter_type_expr(occur, ty$1);
    }
  };
  try {
    occur(ty);
    unmark_type(ty);
  }
  catch (exn){
    if (exn !== Occur) {
      throw exn;
    }
    unmark_type(ty);
    throw [
          Unify,
          /* [] */0
        ];
  }
  occur_univar(env, ty);
  return update_level(env, level, ty);
}

function may_instantiate(inst_nongen, t1) {
  if (inst_nongen) {
    return t1.level !== 99999999;
  } else {
    return t1.level === 100000000;
  }
}

function moregen(inst_nongen, type_pairs, env, t1, t2) {
  if (t1 === t2) {
    return ;
  }
  var t1$1 = repr(t1);
  var t2$1 = repr(t2);
  if (t1$1 === t2$1) {
    return ;
  }
  try {
    var match = t1$1.desc;
    var match$1 = t2$1.desc;
    var exit = 0;
    if (typeof match === "number") {
      exit = 1;
    } else {
      switch (match.tag | 0) {
        case /* Tvar */0 :
            if (may_instantiate(inst_nongen, t1$1)) {
              moregen_occur(env, t1$1.level, t2$1);
              occur(env, t1$1, t2$1);
              return link_type(t1$1, t2$1);
            } else {
              exit = 1;
            }
            break;
        case /* Tconstr */3 :
            if (match[1] || typeof match$1 === "number" || !(match$1.tag === /* Tconstr */3 && !match$1[1])) {
              exit = 1;
            } else {
              if (same(match[0], match$1[0])) {
                return ;
              }
              exit = 1;
            }
            break;
        default:
          exit = 1;
      }
    }
    if (exit === 1) {
      var t1$prime = expand_head(env, t1$1);
      var t2$prime = expand_head(env, t2$1);
      var t1$prime$1 = repr(t1$prime);
      var t2$prime$1 = repr(t2$prime);
      if (t1$prime$1 === t2$prime$1) {
        return ;
      }
      try {
        return Curry._2(TypePairs.find, type_pairs, /* tuple */[
                    t1$prime$1,
                    t2$prime$1
                  ]);
      }
      catch (exn){
        if (exn !== Caml_builtin_exceptions.not_found) {
          throw exn;
        }
        Curry._3(TypePairs.add, type_pairs, /* tuple */[
              t1$prime$1,
              t2$prime$1
            ], void 0);
        var match$2 = t1$prime$1.desc;
        var match$3 = t2$prime$1.desc;
        if (typeof match$2 === "number") {
          if (typeof match$3 === "number") {
            return ;
          }
          throw [
                Unify,
                /* [] */0
              ];
        } else {
          switch (match$2.tag | 0) {
            case /* Tvar */0 :
                if (!may_instantiate(inst_nongen, t1$prime$1)) {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                moregen_occur(env, t1$prime$1.level, t2$1);
                return link_type(t1$prime$1, t2$1);
            case /* Tarrow */1 :
                if (typeof match$3 === "number") {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                if (match$3.tag !== /* Tarrow */1) {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                var l2 = match$3[0];
                var l1 = match$2[0];
                if (!(l1 === l2 || classic.contents && !(is_optional(l1) || is_optional(l2)))) {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                moregen(inst_nongen, type_pairs, env, match$2[1], match$3[1]);
                return moregen(inst_nongen, type_pairs, env, match$2[2], match$3[2]);
            case /* Ttuple */2 :
                if (typeof match$3 === "number") {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                if (match$3.tag === /* Ttuple */2) {
                  return moregen_list(inst_nongen, type_pairs, env, match$2[0], match$3[0]);
                }
                throw [
                      Unify,
                      /* [] */0
                    ];
            case /* Tconstr */3 :
                if (typeof match$3 === "number") {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                if (match$3.tag !== /* Tconstr */3) {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                if (same(match$2[0], match$3[0])) {
                  return moregen_list(inst_nongen, type_pairs, env, match$2[1], match$3[1]);
                }
                throw [
                      Unify,
                      /* [] */0
                    ];
            case /* Tobject */4 :
                if (typeof match$3 === "number") {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                if (match$3.tag === /* Tobject */4) {
                  return moregen_fields(inst_nongen, type_pairs, env, match$2[0], match$3[0]);
                }
                throw [
                      Unify,
                      /* [] */0
                    ];
            case /* Tfield */5 :
                if (typeof match$3 === "number") {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                if (match$3.tag === /* Tfield */5) {
                  return moregen_fields(inst_nongen, type_pairs, env, t1$prime$1, t2$prime$1);
                }
                throw [
                      Unify,
                      /* [] */0
                    ];
            case /* Tlink */6 :
            case /* Tsubst */7 :
                throw [
                      Unify,
                      /* [] */0
                    ];
            case /* Tvariant */8 :
                if (typeof match$3 === "number") {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                if (match$3.tag === /* Tvariant */8) {
                  var row1 = match$2[0];
                  var row2 = match$3[0];
                  var row1$1 = row_repr_aux(/* [] */0, row1);
                  var row2$1 = row_repr_aux(/* [] */0, row2);
                  var rm1 = repr(row1$1.row_more);
                  var rm2 = repr(row2$1.row_more);
                  if (rm1 === rm2) {
                    return ;
                  }
                  var may_inst = is_Tvar(rm1) && may_instantiate(inst_nongen, rm1) || rm1.desc === /* Tnil */0;
                  var match$4 = merge_row_fields(row1$1.row_fields, row2$1.row_fields);
                  var r2 = match$4[1];
                  var r1 = match$4[0];
                  var match$5 = row2$1.row_closed ? /* tuple */[
                      filter_row_fields(may_inst, r1),
                      filter_row_fields(false, r2)
                    ] : /* tuple */[
                      r1,
                      r2
                    ];
                  var r2$1 = match$5[1];
                  if (match$5[0] !== /* [] */0 || row1$1.row_closed && (!row2$1.row_closed || r2$1 !== /* [] */0)) {
                    throw [
                          Unify,
                          /* [] */0
                        ];
                  }
                  var match$6 = rm1.desc;
                  var match$7 = rm2.desc;
                  var exit$1 = 0;
                  var exit$2 = 0;
                  if (typeof match$6 === "number" || match$6.tag !== /* Tunivar */9) {
                    exit$2 = 2;
                  } else {
                    if (typeof match$7 === "number") {
                      throw [
                            Unify,
                            /* [] */0
                          ];
                    }
                    if (match$7.tag !== /* Tunivar */9) {
                      throw [
                            Unify,
                            /* [] */0
                          ];
                    }
                    unify_univar(rm1, rm2, univar_pairs.contents);
                  }
                  if (exit$2 === 2) {
                    if (typeof match$7 === "number") {
                      exit$1 = 1;
                    } else {
                      if (match$7.tag === /* Tunivar */9) {
                        throw [
                              Unify,
                              /* [] */0
                            ];
                      }
                      exit$1 = 1;
                    }
                  }
                  if (exit$1 === 1 && !static_row(row1$1)) {
                    if (may_inst) {
                      var ext = newty2(100000000, /* Tvariant */Block.__(8, [{
                                row_fields: r2$1,
                                row_more: row2$1.row_more,
                                row_bound: row2$1.row_bound,
                                row_closed: row2$1.row_closed,
                                row_fixed: row2$1.row_fixed,
                                row_name: row2$1.row_name
                              }]));
                      moregen_occur(env, rm1.level, ext);
                      link_type(rm1, ext);
                    } else {
                      if (typeof match$6 === "number") {
                        throw [
                              Unify,
                              /* [] */0
                            ];
                      }
                      if (match$6.tag !== /* Tconstr */3) {
                        throw [
                              Unify,
                              /* [] */0
                            ];
                      }
                      if (typeof match$7 === "number") {
                        throw [
                              Unify,
                              /* [] */0
                            ];
                      }
                      if (match$7.tag !== /* Tconstr */3) {
                        throw [
                              Unify,
                              /* [] */0
                            ];
                      }
                      moregen(inst_nongen, type_pairs, env, rm1, rm2);
                    }
                  }
                  return List.iter((function (param) {
                                var f1 = row_field_repr_aux(/* [] */0, param[1]);
                                var f2 = row_field_repr_aux(/* [] */0, param[2]);
                                if (f1 === f2) {
                                  return ;
                                }
                                if (typeof f1 === "number") {
                                  if (typeof f2 === "number") {
                                    return ;
                                  }
                                  throw [
                                        Unify,
                                        /* [] */0
                                      ];
                                } else if (f1.tag) {
                                  var c1 = f1[0];
                                  if (c1) {
                                    if (!f1[1] && typeof f2 !== "number" && !f2.tag) {
                                      if (f2[0] !== void 0) {
                                        throw [
                                              Unify,
                                              /* [] */0
                                            ];
                                      }
                                      if (may_inst) {
                                        return set_row_field(f1[3], f2);
                                      }
                                      throw [
                                            Unify,
                                            /* [] */0
                                          ];
                                    }
                                    
                                  } else if (typeof f2 !== "number" && !f2.tag) {
                                    var match = f2[0];
                                    if (match === void 0) {
                                      throw [
                                            Unify,
                                            /* [] */0
                                          ];
                                    }
                                    if (!may_inst) {
                                      throw [
                                            Unify,
                                            /* [] */0
                                          ];
                                    }
                                    var t2 = match;
                                    set_row_field(f1[3], f2);
                                    return List.iter((function (t1) {
                                                  return moregen(inst_nongen, type_pairs, env, t1, t2);
                                                }), f1[1]);
                                  }
                                  var e1 = f1[3];
                                  var tl1 = f1[1];
                                  if (typeof f2 === "number") {
                                    if (may_inst) {
                                      return set_row_field(e1, f2);
                                    }
                                    throw [
                                          Unify,
                                          /* [] */0
                                        ];
                                  } else {
                                    if (!f2.tag) {
                                      throw [
                                            Unify,
                                            /* [] */0
                                          ];
                                    }
                                    var e2 = f2[3];
                                    if (e1 === e2) {
                                      return ;
                                    }
                                    var tl2 = f2[1];
                                    var c2 = f2[0];
                                    if (c1 && !c2) {
                                      throw [
                                            Unify,
                                            /* [] */0
                                          ];
                                    }
                                    set_row_field(e1, /* Reither */Block.__(1, [
                                            c2,
                                            /* [] */0,
                                            f2[2],
                                            e2
                                          ]));
                                    if (List.length(tl1) === List.length(tl2)) {
                                      return List.iter2((function (param, param$1) {
                                                    return moregen(inst_nongen, type_pairs, env, param, param$1);
                                                  }), tl1, tl2);
                                    }
                                    if (tl2) {
                                      var t2$1 = tl2[0];
                                      return List.iter((function (t1) {
                                                    return moregen(inst_nongen, type_pairs, env, t1, t2$1);
                                                  }), tl1);
                                    } else {
                                      if (tl1 !== /* [] */0) {
                                        throw [
                                              Unify,
                                              /* [] */0
                                            ];
                                      }
                                      return ;
                                    }
                                  }
                                } else {
                                  var match$1 = f1[0];
                                  if (match$1 !== void 0) {
                                    if (typeof f2 === "number") {
                                      throw [
                                            Unify,
                                            /* [] */0
                                          ];
                                    }
                                    if (f2.tag) {
                                      throw [
                                            Unify,
                                            /* [] */0
                                          ];
                                    }
                                    var match$2 = f2[0];
                                    if (match$2 !== void 0) {
                                      return moregen(inst_nongen, type_pairs, env, match$1, match$2);
                                    }
                                    throw [
                                          Unify,
                                          /* [] */0
                                        ];
                                  } else {
                                    if (typeof f2 === "number") {
                                      throw [
                                            Unify,
                                            /* [] */0
                                          ];
                                    }
                                    if (f2.tag) {
                                      throw [
                                            Unify,
                                            /* [] */0
                                          ];
                                    }
                                    if (f2[0] !== void 0) {
                                      throw [
                                            Unify,
                                            /* [] */0
                                          ];
                                    }
                                    return ;
                                  }
                                }
                              }), match$4[2]);
                }
                throw [
                      Unify,
                      /* [] */0
                    ];
            case /* Tunivar */9 :
                if (typeof match$3 === "number") {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                if (match$3.tag === /* Tunivar */9) {
                  return unify_univar(t1$prime$1, t2$prime$1, univar_pairs.contents);
                }
                throw [
                      Unify,
                      /* [] */0
                    ];
            case /* Tpoly */10 :
                var tl1 = match$2[1];
                var t1$2 = match$2[0];
                var exit$3 = 0;
                if (tl1) {
                  exit$3 = 2;
                } else {
                  if (typeof match$3 === "number") {
                    throw [
                          Unify,
                          /* [] */0
                        ];
                  }
                  if (match$3.tag !== /* Tpoly */10) {
                    throw [
                          Unify,
                          /* [] */0
                        ];
                  }
                  if (!match$3[1]) {
                    return moregen(inst_nongen, type_pairs, env, t1$2, match$3[0]);
                  }
                  exit$3 = 2;
                }
                if (exit$3 === 2) {
                  if (typeof match$3 === "number") {
                    throw [
                          Unify,
                          /* [] */0
                        ];
                  }
                  if (match$3.tag === /* Tpoly */10) {
                    return enter_poly(env, univar_pairs, t1$2, tl1, match$3[0], match$3[1], (function (param, param$1) {
                                  return moregen(inst_nongen, type_pairs, env, param, param$1);
                                }));
                  }
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                break;
            case /* Tpackage */11 :
                if (typeof match$3 === "number") {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                if (match$3.tag !== /* Tpackage */11) {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                try {
                  return unify_package(env, (function (param, param$1) {
                                return moregen_list(inst_nongen, type_pairs, env, param, param$1);
                              }), t1$prime$1.level, match$2[0], match$2[1], match$2[2], t2$prime$1.level, match$3[0], match$3[1], match$3[2]);
                }
                catch (exn$1){
                  if (exn$1 === Caml_builtin_exceptions.not_found) {
                    throw [
                          Unify,
                          /* [] */0
                        ];
                  }
                  throw exn$1;
                }
            
          }
        }
      }
    }
    
  }
  catch (raw_exn){
    var exn$2 = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn$2[0] === Unify) {
      throw [
            Unify,
            /* :: */[
              /* tuple */[
                t1$1,
                t2$1
              ],
              exn$2[1]
            ]
          ];
    }
    throw exn$2;
  }
}

function moregen_list(inst_nongen, type_pairs, env, tl1, tl2) {
  if (List.length(tl1) !== List.length(tl2)) {
    throw [
          Unify,
          /* [] */0
        ];
  }
  return List.iter2((function (param, param$1) {
                return moregen(inst_nongen, type_pairs, env, param, param$1);
              }), tl1, tl2);
}

function moregen_fields(inst_nongen, type_pairs, env, ty1, ty2) {
  var match = flatten_fields(ty1);
  var match$1 = flatten_fields(ty2);
  var rest2 = match$1[1];
  var match$2 = associate_fields(match[0], match$1[0]);
  if (match$2[1] !== /* [] */0) {
    throw [
          Unify,
          /* [] */0
        ];
  }
  moregen(inst_nongen, type_pairs, env, match[1], build_fields(repr(ty2).level)(match$2[2], rest2));
  return List.iter((function (param) {
                var t2 = param[4];
                var k2 = param[3];
                var t1 = param[2];
                var k1 = param[1];
                var n = param[0];
                moregen_kind(k1, k2);
                try {
                  return moregen(inst_nongen, type_pairs, env, t1, t2);
                }
                catch (raw_exn){
                  var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                  if (exn[0] === Unify) {
                    throw [
                          Unify,
                          /* :: */[
                            /* tuple */[
                              newty2(current_level.contents, /* Tfield */Block.__(5, [
                                      n,
                                      k1,
                                      t1,
                                      rest2
                                    ])),
                              newty2(current_level.contents, /* Tfield */Block.__(5, [
                                      n,
                                      k2,
                                      t2,
                                      rest2
                                    ]))
                            ],
                            exn[1]
                          ]
                        ];
                  }
                  throw exn;
                }
              }), match$2[0]);
}

function moregen_kind(k1, k2) {
  var k1$1 = field_kind_repr(k1);
  var k2$1 = field_kind_repr(k2);
  if (k1$1 === k2$1) {
    return ;
  }
  if (typeof k1$1 === "number") {
    if (k1$1 !== 0) {
      throw [
            Unify,
            /* [] */0
          ];
    }
    if (typeof k2$1 !== "number") {
      throw [
            Unify,
            /* [] */0
          ];
    }
    if (k2$1 !== 0) {
      throw [
            Unify,
            /* [] */0
          ];
    }
    return ;
  } else {
    var r = k1$1[0];
    if (typeof k2$1 !== "number") {
      return set_kind(r, k2$1);
    }
    if (k2$1 !== 0) {
      throw [
            Unify,
            /* [] */0
          ];
    }
    return set_kind(r, k2$1);
  }
}

function moregen$1(inst_nongen, type_pairs, env, patt, subj) {
  univar_pairs.contents = /* [] */0;
  return moregen(inst_nongen, type_pairs, env, patt, subj);
}

function moregeneral(env, inst_nongen, pat_sch, subj_sch) {
  var old_level = current_level.contents;
  current_level.contents = 99999999;
  var ty = instance(void 0, env, subj_sch);
  var subj = type_expr(identity, ty);
  current_level.contents = 100000000;
  var patt = instance(void 0, env, pat_sch);
  var res;
  try {
    moregen$1(inst_nongen, Curry._1(TypePairs.create, 13), env, patt, subj);
    res = true;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] !== Unify) {
      throw exn;
    }
    res = false;
  }
  current_level.contents = old_level;
  return res;
}

function rigidify_rec(vars, _ty) {
  while(true) {
    var ty = _ty;
    var ty$1 = repr(ty);
    if (ty$1.level < 0) {
      return ;
    }
    ty$1.level = pivot_level - ty$1.level | 0;
    var match = ty$1.desc;
    if (typeof match === "number") {
      return iter_type_expr((function (param) {
                    return rigidify_rec(vars, param);
                  }), ty$1);
    }
    switch (match.tag | 0) {
      case /* Tvar */0 :
          if (!List.memq(ty$1, vars.contents)) {
            vars.contents = /* :: */[
              ty$1,
              vars.contents
            ];
            return ;
          } else {
            return ;
          }
      case /* Tvariant */8 :
          var row = row_repr_aux(/* [] */0, match[0]);
          var more = repr(row.row_more);
          if (is_Tvar(more) && !row_fixed(row)) {
            var more$prime = newty2(more.level, more.desc);
            var row$prime_row_bound = row.row_bound;
            var row$prime_row_closed = row.row_closed;
            var row$prime_row_name = row.row_name;
            var row$prime = {
              row_fields: /* [] */0,
              row_more: more$prime,
              row_bound: row$prime_row_bound,
              row_closed: row$prime_row_closed,
              row_fixed: true,
              row_name: row$prime_row_name
            };
            link_type(more, newty2(ty$1.level, /* Tvariant */Block.__(8, [row$prime])));
          }
          iter_row((function (param) {
                  return rigidify_rec(vars, param);
                }), row);
          if (static_row(row)) {
            return ;
          }
          _ty = row_more(row);
          continue ;
      default:
        return iter_type_expr((function (param) {
                      return rigidify_rec(vars, param);
                    }), ty$1);
    }
  };
}

function rigidify(ty) {
  var vars = {
    contents: /* [] */0
  };
  rigidify_rec(vars, ty);
  unmark_type(ty);
  return vars.contents;
}

function all_distinct_vars(env, vars) {
  var tyl = {
    contents: /* [] */0
  };
  return List.for_all((function (ty) {
                var ty$1 = expand_head(env, ty);
                if (List.memq(ty$1, tyl.contents)) {
                  return false;
                } else {
                  tyl.contents = /* :: */[
                    ty$1,
                    tyl.contents
                  ];
                  return is_Tvar(ty$1);
                }
              }), vars);
}

function matches(env, ty, ty$prime) {
  var snap = snapshot(void 0);
  var vars = rigidify(ty);
  cleanup_abbrev(void 0);
  var ok;
  try {
    unify$2(env, ty, ty$prime);
    ok = all_distinct_vars(env, vars);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] !== Unify) {
      throw exn;
    }
    ok = false;
  }
  backtrack(snap);
  return ok;
}

function expand_head_rigid(env, ty) {
  var old = rigid_variants.contents;
  rigid_variants.contents = true;
  var ty$prime = expand_head(env, ty);
  rigid_variants.contents = old;
  return ty$prime;
}

function normalize_subst(subst) {
  if (List.exists((function (param) {
            var match = param[0].desc;
            if (typeof match !== "number" && match.tag === /* Tlink */6) {
              return true;
            }
            var match$1 = param[1].desc;
            return typeof match$1 === "number" || match$1.tag !== /* Tlink */6 ? false : true;
          }), subst.contents)) {
    subst.contents = List.map((function (param) {
            return /* tuple */[
                    repr(param[0]),
                    repr(param[1])
                  ];
          }), subst.contents);
    return ;
  }
  
}

function eqtype(rename, type_pairs, subst, env, t1, t2) {
  if (t1 === t2) {
    return ;
  }
  var t1$1 = repr(t1);
  var t2$1 = repr(t2);
  if (t1$1 === t2$1) {
    return ;
  }
  try {
    var match = t1$1.desc;
    var match$1 = t2$1.desc;
    var exit = 0;
    if (typeof match === "number") {
      exit = 1;
    } else {
      switch (match.tag | 0) {
        case /* Tvar */0 :
            if (typeof match$1 === "number" || match$1.tag || !rename) {
              exit = 1;
            } else {
              try {
                normalize_subst(subst);
                if (List.assq(t1$1, subst.contents) !== t2$1) {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                return ;
              }
              catch (exn){
                if (exn !== Caml_builtin_exceptions.not_found) {
                  throw exn;
                }
                if (List.exists((function (param) {
                          return param[1] === t2$1;
                        }), subst.contents)) {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                subst.contents = /* :: */[
                  /* tuple */[
                    t1$1,
                    t2$1
                  ],
                  subst.contents
                ];
                return ;
              }
            }
            break;
        case /* Tconstr */3 :
            if (match[1] || typeof match$1 === "number" || !(match$1.tag === /* Tconstr */3 && !match$1[1])) {
              exit = 1;
            } else {
              if (same(match[0], match$1[0])) {
                return ;
              }
              exit = 1;
            }
            break;
        default:
          exit = 1;
      }
    }
    if (exit === 1) {
      var t1$prime = expand_head_rigid(env, t1$1);
      var t2$prime = expand_head_rigid(env, t2$1);
      var t1$prime$1 = repr(t1$prime);
      var t2$prime$1 = repr(t2$prime);
      if (t1$prime$1 === t2$prime$1) {
        return ;
      }
      try {
        return Curry._2(TypePairs.find, type_pairs, /* tuple */[
                    t1$prime$1,
                    t2$prime$1
                  ]);
      }
      catch (exn$1){
        if (exn$1 !== Caml_builtin_exceptions.not_found) {
          throw exn$1;
        }
        Curry._3(TypePairs.add, type_pairs, /* tuple */[
              t1$prime$1,
              t2$prime$1
            ], void 0);
        var match$2 = t1$prime$1.desc;
        var match$3 = t2$prime$1.desc;
        if (typeof match$2 === "number") {
          if (typeof match$3 === "number") {
            return ;
          }
          throw [
                Unify,
                /* [] */0
              ];
        } else {
          switch (match$2.tag | 0) {
            case /* Tvar */0 :
                if (typeof match$3 === "number") {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                if (match$3.tag) {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                if (!rename) {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                try {
                  normalize_subst(subst);
                  if (List.assq(t1$prime$1, subst.contents) !== t2$prime$1) {
                    throw [
                          Unify,
                          /* [] */0
                        ];
                  }
                  return ;
                }
                catch (exn$2){
                  if (exn$2 !== Caml_builtin_exceptions.not_found) {
                    throw exn$2;
                  }
                  if (List.exists((function (param) {
                            return param[1] === t2$prime$1;
                          }), subst.contents)) {
                    throw [
                          Unify,
                          /* [] */0
                        ];
                  }
                  subst.contents = /* :: */[
                    /* tuple */[
                      t1$prime$1,
                      t2$prime$1
                    ],
                    subst.contents
                  ];
                  return ;
                }
            case /* Tarrow */1 :
                if (typeof match$3 === "number") {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                if (match$3.tag !== /* Tarrow */1) {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                var l2 = match$3[0];
                var l1 = match$2[0];
                if (!(l1 === l2 || classic.contents && !(is_optional(l1) || is_optional(l2)))) {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                eqtype(rename, type_pairs, subst, env, match$2[1], match$3[1]);
                return eqtype(rename, type_pairs, subst, env, match$2[2], match$3[2]);
            case /* Ttuple */2 :
                if (typeof match$3 === "number") {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                if (match$3.tag === /* Ttuple */2) {
                  return eqtype_list(rename, type_pairs, subst, env, match$2[0], match$3[0]);
                }
                throw [
                      Unify,
                      /* [] */0
                    ];
            case /* Tconstr */3 :
                if (typeof match$3 === "number") {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                if (match$3.tag !== /* Tconstr */3) {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                if (same(match$2[0], match$3[0])) {
                  return eqtype_list(rename, type_pairs, subst, env, match$2[1], match$3[1]);
                }
                throw [
                      Unify,
                      /* [] */0
                    ];
            case /* Tobject */4 :
                if (typeof match$3 === "number") {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                if (match$3.tag === /* Tobject */4) {
                  return eqtype_fields(rename, type_pairs, subst, env, match$2[0], match$3[0]);
                }
                throw [
                      Unify,
                      /* [] */0
                    ];
            case /* Tfield */5 :
                if (typeof match$3 === "number") {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                if (match$3.tag === /* Tfield */5) {
                  return eqtype_fields(rename, type_pairs, subst, env, t1$prime$1, t2$prime$1);
                }
                throw [
                      Unify,
                      /* [] */0
                    ];
            case /* Tlink */6 :
            case /* Tsubst */7 :
                throw [
                      Unify,
                      /* [] */0
                    ];
            case /* Tvariant */8 :
                if (typeof match$3 === "number") {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                if (match$3.tag === /* Tvariant */8) {
                  var row1 = match$2[0];
                  var _row2 = match$3[0];
                  while(true) {
                    var row2 = _row2;
                    var match$4 = expand_head_rigid(env, row_more(row2));
                    var match$5 = match$4.desc;
                    if (typeof match$5 !== "number" && match$5.tag === /* Tvariant */8) {
                      _row2 = match$5[0];
                      continue ;
                    }
                    var row1$1 = row_repr_aux(/* [] */0, row1);
                    var row2$1 = row_repr_aux(/* [] */0, row2);
                    var match$6 = merge_row_fields(row1$1.row_fields, row2$1.row_fields);
                    var r2 = match$6[1];
                    var r1 = match$6[0];
                    if (row1$1.row_closed !== row2$1.row_closed || !row1$1.row_closed && (r1 !== /* [] */0 || r2 !== /* [] */0) || filter_row_fields(false, Pervasives.$at(r1, r2)) !== /* [] */0) {
                      throw [
                            Unify,
                            /* [] */0
                          ];
                    }
                    if (!static_row(row1$1)) {
                      eqtype(rename, type_pairs, subst, env, row1$1.row_more, row2$1.row_more);
                    }
                    return List.iter((function (param) {
                                  var match = row_field_repr_aux(/* [] */0, param[1]);
                                  var match$1 = row_field_repr_aux(/* [] */0, param[2]);
                                  if (typeof match === "number") {
                                    if (typeof match$1 === "number") {
                                      return ;
                                    }
                                    throw [
                                          Unify,
                                          /* [] */0
                                        ];
                                  } else if (match.tag) {
                                    if (match[0]) {
                                      if (match[1]) {
                                        throw [
                                              Unify,
                                              /* [] */0
                                            ];
                                      }
                                      if (typeof match$1 === "number") {
                                        throw [
                                              Unify,
                                              /* [] */0
                                            ];
                                      }
                                      if (!match$1.tag) {
                                        throw [
                                              Unify,
                                              /* [] */0
                                            ];
                                      }
                                      if (!match$1[0]) {
                                        throw [
                                              Unify,
                                              /* [] */0
                                            ];
                                      }
                                      if (match$1[1]) {
                                        throw [
                                              Unify,
                                              /* [] */0
                                            ];
                                      }
                                      return ;
                                    } else {
                                      var match$2 = match[1];
                                      if (!match$2) {
                                        throw [
                                              Unify,
                                              /* [] */0
                                            ];
                                      }
                                      var tl1 = match$2[1];
                                      var t1 = match$2[0];
                                      if (typeof match$1 === "number") {
                                        throw [
                                              Unify,
                                              /* [] */0
                                            ];
                                      }
                                      if (!match$1.tag) {
                                        throw [
                                              Unify,
                                              /* [] */0
                                            ];
                                      }
                                      if (match$1[0]) {
                                        throw [
                                              Unify,
                                              /* [] */0
                                            ];
                                      }
                                      var match$3 = match$1[1];
                                      if (!match$3) {
                                        throw [
                                              Unify,
                                              /* [] */0
                                            ];
                                      }
                                      var tl2 = match$3[1];
                                      var t2 = match$3[0];
                                      eqtype(rename, type_pairs, subst, env, t1, t2);
                                      if (List.length(tl1) === List.length(tl2)) {
                                        return List.iter2((function (param, param$1) {
                                                      return eqtype(rename, type_pairs, subst, env, param, param$1);
                                                    }), tl1, tl2);
                                      } else {
                                        List.iter((function (param) {
                                                return eqtype(rename, type_pairs, subst, env, t1, param);
                                              }), tl2);
                                        return List.iter((function (t1) {
                                                      return eqtype(rename, type_pairs, subst, env, t1, t2);
                                                    }), tl1);
                                      }
                                    }
                                  } else {
                                    var match$4 = match[0];
                                    if (match$4 !== void 0) {
                                      if (typeof match$1 === "number") {
                                        throw [
                                              Unify,
                                              /* [] */0
                                            ];
                                      }
                                      if (match$1.tag) {
                                        throw [
                                              Unify,
                                              /* [] */0
                                            ];
                                      }
                                      var match$5 = match$1[0];
                                      if (match$5 !== void 0) {
                                        return eqtype(rename, type_pairs, subst, env, match$4, match$5);
                                      }
                                      throw [
                                            Unify,
                                            /* [] */0
                                          ];
                                    } else {
                                      if (typeof match$1 === "number") {
                                        throw [
                                              Unify,
                                              /* [] */0
                                            ];
                                      }
                                      if (match$1.tag) {
                                        throw [
                                              Unify,
                                              /* [] */0
                                            ];
                                      }
                                      if (match$1[0] !== void 0) {
                                        throw [
                                              Unify,
                                              /* [] */0
                                            ];
                                      }
                                      return ;
                                    }
                                  }
                                }), match$6[2]);
                  };
                }
                throw [
                      Unify,
                      /* [] */0
                    ];
            case /* Tunivar */9 :
                if (typeof match$3 === "number") {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                if (match$3.tag === /* Tunivar */9) {
                  return unify_univar(t1$prime$1, t2$prime$1, univar_pairs.contents);
                }
                throw [
                      Unify,
                      /* [] */0
                    ];
            case /* Tpoly */10 :
                var tl1 = match$2[1];
                var t1$2 = match$2[0];
                var exit$1 = 0;
                if (tl1) {
                  exit$1 = 2;
                } else {
                  if (typeof match$3 === "number") {
                    throw [
                          Unify,
                          /* [] */0
                        ];
                  }
                  if (match$3.tag !== /* Tpoly */10) {
                    throw [
                          Unify,
                          /* [] */0
                        ];
                  }
                  if (!match$3[1]) {
                    return eqtype(rename, type_pairs, subst, env, t1$2, match$3[0]);
                  }
                  exit$1 = 2;
                }
                if (exit$1 === 2) {
                  if (typeof match$3 === "number") {
                    throw [
                          Unify,
                          /* [] */0
                        ];
                  }
                  if (match$3.tag === /* Tpoly */10) {
                    return enter_poly(env, univar_pairs, t1$2, tl1, match$3[0], match$3[1], (function (param, param$1) {
                                  return eqtype(rename, type_pairs, subst, env, param, param$1);
                                }));
                  }
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                break;
            case /* Tpackage */11 :
                if (typeof match$3 === "number") {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                if (match$3.tag !== /* Tpackage */11) {
                  throw [
                        Unify,
                        /* [] */0
                      ];
                }
                try {
                  return unify_package(env, (function (param, param$1) {
                                return eqtype_list(rename, type_pairs, subst, env, param, param$1);
                              }), t1$prime$1.level, match$2[0], match$2[1], match$2[2], t2$prime$1.level, match$3[0], match$3[1], match$3[2]);
                }
                catch (exn$3){
                  if (exn$3 === Caml_builtin_exceptions.not_found) {
                    throw [
                          Unify,
                          /* [] */0
                        ];
                  }
                  throw exn$3;
                }
            
          }
        }
      }
    }
    
  }
  catch (raw_exn){
    var exn$4 = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn$4[0] === Unify) {
      throw [
            Unify,
            /* :: */[
              /* tuple */[
                t1$1,
                t2$1
              ],
              exn$4[1]
            ]
          ];
    }
    throw exn$4;
  }
}

function eqtype_list(rename, type_pairs, subst, env, tl1, tl2) {
  if (List.length(tl1) !== List.length(tl2)) {
    throw [
          Unify,
          /* [] */0
        ];
  }
  return List.iter2((function (param, param$1) {
                return eqtype(rename, type_pairs, subst, env, param, param$1);
              }), tl1, tl2);
}

function eqtype_fields(rename, type_pairs, subst, env, ty1, _ty2) {
  while(true) {
    var ty2 = _ty2;
    var match = flatten_fields(ty1);
    var rest1 = match[1];
    var match$1 = flatten_fields(ty2);
    var rest2 = match$1[1];
    var same_row = rest1 === rest2 || Curry._2(TypePairs.mem, type_pairs, /* tuple */[
          rest1,
          rest2
        ]) || rename && List.mem(/* tuple */[
          rest1,
          rest2
        ], subst.contents);
    if (same_row) {
      return ;
    }
    var match$2 = expand_head_rigid(env, rest2);
    var match$3 = match$2.desc;
    if (typeof match$3 !== "number" && match$3.tag === /* Tobject */4) {
      _ty2 = match$3[0];
      continue ;
    }
    var match$4 = associate_fields(match[0], match$1[0]);
    eqtype(rename, type_pairs, subst, env, rest1, rest2);
    if (match$4[1] !== /* [] */0 || match$4[2] !== /* [] */0) {
      throw [
            Unify,
            /* [] */0
          ];
    }
    return List.iter((function(rest2){
              return function (param) {
                var t2 = param[4];
                var k2 = param[3];
                var t1 = param[2];
                var k1 = param[1];
                var n = param[0];
                eqtype_kind(k1, k2);
                try {
                  return eqtype(rename, type_pairs, subst, env, t1, t2);
                }
                catch (raw_exn){
                  var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                  if (exn[0] === Unify) {
                    throw [
                          Unify,
                          /* :: */[
                            /* tuple */[
                              newty2(current_level.contents, /* Tfield */Block.__(5, [
                                      n,
                                      k1,
                                      t1,
                                      rest2
                                    ])),
                              newty2(current_level.contents, /* Tfield */Block.__(5, [
                                      n,
                                      k2,
                                      t2,
                                      rest2
                                    ]))
                            ],
                            exn[1]
                          ]
                        ];
                  }
                  throw exn;
                }
              }
              }(rest2)), match$4[0]);
  };
}

function eqtype_kind(k1, k2) {
  var k1$1 = field_kind_repr(k1);
  var k2$1 = field_kind_repr(k2);
  if (typeof k1$1 === "number") {
    if (k1$1 !== 0) {
      throw [
            Unify,
            /* [] */0
          ];
    }
    if (typeof k2$1 !== "number") {
      throw [
            Unify,
            /* [] */0
          ];
    }
    if (k2$1 !== 0) {
      throw [
            Unify,
            /* [] */0
          ];
    }
    return ;
  } else {
    if (typeof k2$1 === "number") {
      throw [
            Unify,
            /* [] */0
          ];
    }
    return ;
  }
}

function equal$4(env, rename, tyl1, tyl2) {
  try {
    univar_pairs.contents = /* [] */0;
    eqtype_list(rename, Curry._1(TypePairs.create, 11), {
          contents: /* [] */0
        }, env, tyl1, tyl2);
    return true;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === Unify) {
      return false;
    }
    throw exn;
  }
}

function eqtype$1(rename, type_pairs, subst, env, t1, t2) {
  univar_pairs.contents = /* [] */0;
  return eqtype(rename, type_pairs, subst, env, t1, t2);
}

var Failure = Caml_exceptions.create("Ocaml_typedtree_test.Ctype.Failure");

function moregen_clty(trace, type_pairs, env, cty1, cty2) {
  try {
    var exit = 0;
    switch (cty1.tag | 0) {
      case /* Cty_constr */0 :
          return moregen_clty(true, type_pairs, env, cty1[2], cty2);
      case /* Cty_signature */1 :
          var sign1 = cty1[0];
          switch (cty2.tag | 0) {
            case /* Cty_constr */0 :
                exit = 1;
                break;
            case /* Cty_signature */1 :
                var sign2 = cty2[0];
                var ty1 = object_fields(repr(sign1.csig_self));
                var ty2 = object_fields(repr(sign2.csig_self));
                var match = flatten_fields(ty1);
                var match$1 = flatten_fields(ty2);
                var match$2 = associate_fields(match[0], match$1[0]);
                List.iter((function (param) {
                        try {
                          return moregen$1(true, type_pairs, env, param[2], param[4]);
                        }
                        catch (raw_exn){
                          var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                          if (exn[0] === Unify) {
                            throw [
                                  Failure,
                                  /* :: */[
                                    /* CM_Meth_type_mismatch */Block.__(5, [
                                        param[0],
                                        env,
                                        expand_trace(env, exn[1])
                                      ]),
                                    /* [] */0
                                  ]
                                ];
                          }
                          throw exn;
                        }
                      }), match$2[0]);
                return iter$1((function (lab, param) {
                              var match = find(lab, sign1.csig_vars);
                              try {
                                return moregen$1(true, type_pairs, env, match[2], param[2]);
                              }
                              catch (raw_exn){
                                var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                                if (exn[0] === Unify) {
                                  throw [
                                        Failure,
                                        /* :: */[
                                          /* CM_Val_type_mismatch */Block.__(4, [
                                              lab,
                                              env,
                                              expand_trace(env, exn[1])
                                            ]),
                                          /* [] */0
                                        ]
                                      ];
                                }
                                throw exn;
                              }
                            }), sign2.csig_vars);
            case /* Cty_arrow */2 :
                throw [
                      Failure,
                      /* [] */0
                    ];
            
          }
          break;
      case /* Cty_arrow */2 :
          switch (cty2.tag | 0) {
            case /* Cty_constr */0 :
                exit = 1;
                break;
            case /* Cty_signature */1 :
                throw [
                      Failure,
                      /* [] */0
                    ];
            case /* Cty_arrow */2 :
                if (cty1[0] !== cty2[0]) {
                  throw [
                        Failure,
                        /* [] */0
                      ];
                }
                try {
                  moregen$1(true, type_pairs, env, cty1[1], cty2[1]);
                }
                catch (raw_exn){
                  var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                  if (exn[0] === Unify) {
                    throw [
                          Failure,
                          /* :: */[
                            /* CM_Parameter_mismatch */Block.__(3, [
                                env,
                                expand_trace(env, exn[1])
                              ]),
                            /* [] */0
                          ]
                        ];
                  }
                  throw exn;
                }
                return moregen_clty(false, type_pairs, env, cty1[2], cty2[2]);
            
          }
          break;
      
    }
    if (exit === 1) {
      return moregen_clty(true, type_pairs, env, cty1, cty2[2]);
    }
    
  }
  catch (raw_exn$1){
    var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
    if (exn$1[0] !== Failure) {
      throw exn$1;
    }
    var error = exn$1[1];
    if (trace || error === /* [] */0) {
      throw [
            Failure,
            /* :: */[
              /* CM_Class_type_mismatch */Block.__(2, [
                  env,
                  cty1,
                  cty2
                ]),
              error
            ]
          ];
    }
    throw exn$1;
  }
}

function match_class_types(traceOpt, env, pat_sch, subj_sch) {
  var trace = traceOpt !== void 0 ? traceOpt : true;
  var type_pairs = Curry._1(TypePairs.create, 53);
  var old_level = current_level.contents;
  current_level.contents = 99999999;
  var match = instance_class(/* [] */0, subj_sch);
  var subj = class_type$1(identity, match[1]);
  current_level.contents = 100000000;
  var match$1 = instance_class(/* [] */0, pat_sch);
  var patt = match$1[1];
  var sign1 = signature_of_class_type(patt);
  var sign2 = signature_of_class_type(subj);
  var t1 = repr(sign1.csig_self);
  var t2 = repr(sign2.csig_self);
  Curry._3(TypePairs.add, type_pairs, /* tuple */[
        t1,
        t2
      ], void 0);
  var match$2 = flatten_fields(object_fields(t1));
  var match$3 = flatten_fields(object_fields(t2));
  var match$4 = associate_fields(match$2[0], match$3[0]);
  var error = List.fold_right((function (param, err) {
          var lab = param[0];
          var k = field_kind_repr(param[1]);
          var err$1 = typeof k === "number" ? /* :: */[
              /* CM_Hide_public */Block.__(10, [lab]),
              err
            ] : (set_kind(k[0], /* Fabsent */1), err);
          if (mem$2(lab, sign1.csig_concr)) {
            return err$1;
          } else {
            return /* :: */[
                    /* CM_Hide_virtual */Block.__(11, [
                        "method",
                        lab
                      ]),
                    err$1
                  ];
          }
        }), match$4[1], /* [] */0);
  var missing_method = List.map((function (param) {
          return param[0];
        }), match$4[2]);
  var error$1 = Pervasives.$at(List.map((function (m) {
              return /* CM_Missing_method */Block.__(9, [m]);
            }), missing_method), error);
  moregen$1(true, type_pairs, env, match$2[1], match$3[1]);
  var error$2 = List.fold_right((function (param, err) {
          try {
            moregen_kind(param[1], param[3]);
            return err;
          }
          catch (raw_exn){
            var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn[0] === Unify) {
              return /* :: */[
                      /* CM_Public_method */Block.__(12, [param[0]]),
                      err
                    ];
            }
            throw exn;
          }
        }), match$4[0], error$1);
  var error$3 = fold((function (lab, param, err) {
          try {
            var match = find(lab, sign1.csig_vars);
            if (param[0] === /* Mutable */1 && match[0] !== /* Mutable */1) {
              return /* :: */[
                      /* CM_Non_mutable_value */Block.__(6, [lab]),
                      err
                    ];
            } else if (param[1] === /* Concrete */1 && match[1] !== /* Concrete */1) {
              return /* :: */[
                      /* CM_Non_concrete_value */Block.__(7, [lab]),
                      err
                    ];
            } else {
              return err;
            }
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              return /* :: */[
                      /* CM_Missing_value */Block.__(8, [lab]),
                      err
                    ];
            }
            throw exn;
          }
        }), sign2.csig_vars, error$2);
  var error$4 = fold((function (lab, param, err) {
          if (param[1] === /* Virtual */0 && !mem(lab, sign2.csig_vars)) {
            return /* :: */[
                    /* CM_Hide_virtual */Block.__(11, [
                        "instance variable",
                        lab
                      ]),
                    err
                  ];
          } else {
            return err;
          }
        }), sign1.csig_vars, error$3);
  var error$5 = List.fold_right((function (e, l) {
          if (List.mem(e, missing_method)) {
            return l;
          } else {
            return /* :: */[
                    /* CM_Virtual_method */Block.__(14, [e]),
                    l
                  ];
          }
        }), elements_aux(/* [] */0, diff(sign2.csig_concr, sign1.csig_concr)), error$4);
  var res;
  if (error$5) {
    res = /* :: */[
      /* CM_Class_type_mismatch */Block.__(2, [
          env,
          patt,
          subj
        ]),
      error$5
    ];
  } else {
    try {
      moregen_clty(trace, type_pairs, env, patt, subj);
      res = /* [] */0;
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn[0] !== Failure) {
        throw exn;
      }
      res = exn[1];
    }
  }
  current_level.contents = old_level;
  return res;
}

function equal_clty(trace, type_pairs, subst, env, cty1, cty2) {
  try {
    var exit = 0;
    switch (cty1.tag | 0) {
      case /* Cty_constr */0 :
          var cty1$1 = cty1[2];
          var exit$1 = 0;
          switch (cty2.tag | 0) {
            case /* Cty_constr */0 :
                return equal_clty(true, type_pairs, subst, env, cty1$1, cty2[2]);
            case /* Cty_signature */1 :
            case /* Cty_arrow */2 :
                exit$1 = 3;
                break;
            
          }
          if (exit$1 === 3) {
            return equal_clty(true, type_pairs, subst, env, cty1$1, cty2);
          }
          break;
      case /* Cty_signature */1 :
          var sign1 = cty1[0];
          switch (cty2.tag | 0) {
            case /* Cty_constr */0 :
                exit = 1;
                break;
            case /* Cty_signature */1 :
                var sign2 = cty2[0];
                var ty1 = object_fields(repr(sign1.csig_self));
                var ty2 = object_fields(repr(sign2.csig_self));
                var match = flatten_fields(ty1);
                var match$1 = flatten_fields(ty2);
                var match$2 = associate_fields(match[0], match$1[0]);
                List.iter((function (param) {
                        try {
                          return eqtype$1(true, type_pairs, subst, env, param[2], param[4]);
                        }
                        catch (raw_exn){
                          var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                          if (exn[0] === Unify) {
                            throw [
                                  Failure,
                                  /* :: */[
                                    /* CM_Meth_type_mismatch */Block.__(5, [
                                        param[0],
                                        env,
                                        expand_trace(env, exn[1])
                                      ]),
                                    /* [] */0
                                  ]
                                ];
                          }
                          throw exn;
                        }
                      }), match$2[0]);
                return iter$1((function (lab, param) {
                              var match = find(lab, sign1.csig_vars);
                              try {
                                return eqtype$1(true, type_pairs, subst, env, match[2], param[2]);
                              }
                              catch (raw_exn){
                                var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                                if (exn[0] === Unify) {
                                  throw [
                                        Failure,
                                        /* :: */[
                                          /* CM_Val_type_mismatch */Block.__(4, [
                                              lab,
                                              env,
                                              expand_trace(env, exn[1])
                                            ]),
                                          /* [] */0
                                        ]
                                      ];
                                }
                                throw exn;
                              }
                            }), sign2.csig_vars);
            case /* Cty_arrow */2 :
                exit = 2;
                break;
            
          }
          break;
      case /* Cty_arrow */2 :
          switch (cty2.tag | 0) {
            case /* Cty_constr */0 :
                exit = 1;
                break;
            case /* Cty_signature */1 :
                exit = 2;
                break;
            case /* Cty_arrow */2 :
                if (cty1[0] === cty2[0]) {
                  try {
                    eqtype$1(true, type_pairs, subst, env, cty1[1], cty2[1]);
                  }
                  catch (raw_exn){
                    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                    if (exn[0] === Unify) {
                      throw [
                            Failure,
                            /* :: */[
                              /* CM_Parameter_mismatch */Block.__(3, [
                                  env,
                                  expand_trace(env, exn[1])
                                ]),
                              /* [] */0
                            ]
                          ];
                    }
                    throw exn;
                  }
                  return equal_clty(false, type_pairs, subst, env, cty1[2], cty2[2]);
                } else {
                  exit = 2;
                }
                break;
            
          }
          break;
      
    }
    switch (exit) {
      case 1 :
          return equal_clty(true, type_pairs, subst, env, cty1, cty2[2]);
      case 2 :
          throw [
                Failure,
                trace ? /* [] */0 : /* :: */[
                    /* CM_Class_type_mismatch */Block.__(2, [
                        env,
                        cty1,
                        cty2
                      ]),
                    /* [] */0
                  ]
              ];
      
    }
  }
  catch (raw_exn$1){
    var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
    if (exn$1[0] !== Failure) {
      throw exn$1;
    }
    if (trace) {
      throw [
            Failure,
            /* :: */[
              /* CM_Class_type_mismatch */Block.__(2, [
                  env,
                  cty1,
                  cty2
                ]),
              exn$1[1]
            ]
          ];
    }
    throw exn$1;
  }
}

function match_class_declarations(env, patt_params, patt_type, subj_params, subj_type) {
  var type_pairs = Curry._1(TypePairs.create, 53);
  var subst = {
    contents: /* [] */0
  };
  var sign1 = signature_of_class_type(patt_type);
  var sign2 = signature_of_class_type(subj_type);
  var t1 = repr(sign1.csig_self);
  var t2 = repr(sign2.csig_self);
  Curry._3(TypePairs.add, type_pairs, /* tuple */[
        t1,
        t2
      ], void 0);
  var match = flatten_fields(object_fields(t1));
  var match$1 = flatten_fields(object_fields(t2));
  var match$2 = associate_fields(match[0], match$1[0]);
  var error = List.fold_right((function (param, err) {
          var lab = param[0];
          var k = field_kind_repr(param[1]);
          var err$1 = typeof k === "number" ? /* :: */[
              /* CM_Hide_public */Block.__(10, [lab]),
              err
            ] : err;
          if (mem$2(lab, sign1.csig_concr)) {
            return err$1;
          } else {
            return /* :: */[
                    /* CM_Hide_virtual */Block.__(11, [
                        "method",
                        lab
                      ]),
                    err$1
                  ];
          }
        }), match$2[1], /* [] */0);
  var missing_method = List.map((function (param) {
          return param[0];
        }), match$2[2]);
  var error$1 = Pervasives.$at(List.map((function (m) {
              return /* CM_Missing_method */Block.__(9, [m]);
            }), missing_method), error);
  eqtype$1(true, type_pairs, subst, env, match[1], match$1[1]);
  var error$2 = List.fold_right((function (param, err) {
          var lab = param[0];
          var k1 = field_kind_repr(param[1]);
          var k2 = field_kind_repr(param[3]);
          if (typeof k1 === "number") {
            if (k1 === 0) {
              if (typeof k2 !== "number") {
                return /* :: */[
                        /* CM_Public_method */Block.__(12, [lab]),
                        err
                      ];
              }
              if (k2 === 0) {
                return err;
              }
              
            }
            
          } else {
            if (typeof k2 !== "number") {
              return err;
            }
            if (k2 === 0) {
              return /* :: */[
                      /* CM_Private_method */Block.__(13, [lab]),
                      err
                    ];
            }
            
          }
          throw [
                Caml_builtin_exceptions.assert_failure,
                /* tuple */[
                  "ctype.ml",
                  3600,
                  34
                ]
              ];
        }), match$2[0], error$1);
  var error$3 = fold((function (lab, param, err) {
          try {
            var match = find(lab, sign1.csig_vars);
            if (param[0] === /* Mutable */1 && match[0] !== /* Mutable */1) {
              return /* :: */[
                      /* CM_Non_mutable_value */Block.__(6, [lab]),
                      err
                    ];
            } else if (param[1] === /* Concrete */1 && match[1] !== /* Concrete */1) {
              return /* :: */[
                      /* CM_Non_concrete_value */Block.__(7, [lab]),
                      err
                    ];
            } else {
              return err;
            }
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              return /* :: */[
                      /* CM_Missing_value */Block.__(8, [lab]),
                      err
                    ];
            }
            throw exn;
          }
        }), sign2.csig_vars, error$2);
  var error$4 = fold((function (lab, param, err) {
          if (param[1] === /* Virtual */0 && !mem(lab, sign2.csig_vars)) {
            return /* :: */[
                    /* CM_Hide_virtual */Block.__(11, [
                        "instance variable",
                        lab
                      ]),
                    err
                  ];
          } else {
            return err;
          }
        }), sign1.csig_vars, error$3);
  var error$5 = List.fold_right((function (e, l) {
          if (List.mem(e, missing_method)) {
            return l;
          } else {
            return /* :: */[
                    /* CM_Virtual_method */Block.__(14, [e]),
                    l
                  ];
          }
        }), elements_aux(/* [] */0, diff(sign2.csig_concr, sign1.csig_concr)), error$4);
  if (error$5) {
    return error$5;
  }
  try {
    var lp = List.length(patt_params);
    var ls = List.length(subj_params);
    if (lp !== ls) {
      throw [
            Failure,
            /* :: */[
              /* CM_Parameter_arity_mismatch */Block.__(0, [
                  lp,
                  ls
                ]),
              /* [] */0
            ]
          ];
    }
    List.iter2((function (p, s) {
            try {
              return eqtype$1(true, type_pairs, subst, env, p, s);
            }
            catch (raw_exn){
              var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
              if (exn[0] === Unify) {
                throw [
                      Failure,
                      /* :: */[
                        /* CM_Type_parameter_mismatch */Block.__(1, [
                            env,
                            expand_trace(env, exn[1])
                          ]),
                        /* [] */0
                      ]
                    ];
              }
              throw exn;
            }
          }), patt_params, subj_params);
    equal_clty(false, type_pairs, subst, env, /* Cty_signature */Block.__(1, [sign1]), /* Cty_signature */Block.__(1, [sign2]));
    var clty_params = function (param, param$1) {
      return List.fold_right((function (ty, cty) {
                    return /* Cty_arrow */Block.__(2, [
                              "*",
                              ty,
                              cty
                            ]);
                  }), param, param$1);
    };
    return match_class_types(false, env, clty_params(patt_params, patt_type), clty_params(subj_params, subj_type));
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === Failure) {
      return exn[1];
    }
    throw exn;
  }
}

var warn = {
  contents: false
};

function pred_expand(n) {
  if (n % 2 === 0 && n > 0) {
    return n - 1 | 0;
  } else {
    return n;
  }
}

function pred_enlarge(n) {
  if (n % 2 === 1) {
    return n - 1 | 0;
  } else {
    return n;
  }
}

function collect(l) {
  return List.fold_left((function (c1, param) {
                return Caml_primitive.caml_int_max(c1, param[1]);
              }), /* Unchanged */0, l);
}

function filter_visited(_l) {
  while(true) {
    var l = _l;
    if (!l) {
      return /* [] */0;
    }
    var match = l[0].desc;
    if (typeof match === "number") {
      _l = l[1];
      continue ;
    } else {
      switch (match.tag | 0) {
        case /* Tobject */4 :
        case /* Tvariant */8 :
            return l;
        default:
          _l = l[1];
          continue ;
      }
    }
  };
}

function memq_warn(t, visited) {
  if (List.memq(t, visited)) {
    warn.contents = true;
    return true;
  } else {
    return false;
  }
}

function lid_of_path($staropt$star, param) {
  var sharp = $staropt$star !== void 0 ? $staropt$star : "";
  switch (param.tag | 0) {
    case /* Pident */0 :
        return /* Lident */Block.__(0, [sharp + param[0].name]);
    case /* Pdot */1 :
        return /* Ldot */Block.__(1, [
                  lid_of_path(void 0, param[0]),
                  sharp + param[1]
                ]);
    case /* Papply */2 :
        return /* Lapply */Block.__(2, [
                  lid_of_path(sharp, param[0]),
                  lid_of_path(void 0, param[1])
                ]);
    
  }
}

function find_cltype_for_path(env, p) {
  var match = lookup_type$1(lid_of_path("#", p), env);
  var cl_abbr = match[1];
  var match$1 = cl_abbr.type_manifest;
  if (match$1 === void 0) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "ctype.ml",
            3707,
            12
          ]
        ];
  }
  var ty = match$1;
  var match$2 = repr(ty).desc;
  if (typeof match$2 === "number") {
    throw Caml_builtin_exceptions.not_found;
  }
  if (match$2.tag !== /* Tobject */4) {
    throw Caml_builtin_exceptions.not_found;
  }
  var match$3 = match$2[1].contents;
  if (match$3 === void 0) {
    throw Caml_builtin_exceptions.not_found;
  }
  if (same(p, match$3[0])) {
    return /* tuple */[
            cl_abbr,
            ty
          ];
  }
  throw Caml_builtin_exceptions.not_found;
}

function build_subtype(env, visited, loops, posi, level, t) {
  var t$1 = repr(t);
  var match = t$1.desc;
  if (typeof match === "number") {
    if (posi) {
      var v = newvar(void 0, void 0);
      return /* tuple */[
              v,
              /* Changed */2
            ];
    } else {
      warn.contents = true;
      return /* tuple */[
              t$1,
              /* Unchanged */0
            ];
    }
  } else {
    switch (match.tag | 0) {
      case /* Tvar */0 :
          if (!posi) {
            return /* tuple */[
                    t$1,
                    /* Unchanged */0
                  ];
          }
          try {
            var t$prime = List.assq(t$1, loops);
            warn.contents = true;
            return /* tuple */[
                    t$prime,
                    /* Equiv */1
                  ];
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              return /* tuple */[
                      t$1,
                      /* Unchanged */0
                    ];
            }
            throw exn;
          }
      case /* Tarrow */1 :
          if (memq_warn(t$1, visited)) {
            return /* tuple */[
                    t$1,
                    /* Unchanged */0
                  ];
          }
          var visited$1 = /* :: */[
            t$1,
            visited
          ];
          var match$1 = build_subtype(env, visited$1, loops, !posi, level, match[1]);
          var match$2 = build_subtype(env, visited$1, loops, posi, level, match[2]);
          var c = Caml_primitive.caml_int_max(match$1[1], match$2[1]);
          if (c > /* Unchanged */0) {
            return /* tuple */[
                    newty2(current_level.contents, /* Tarrow */Block.__(1, [
                            match[0],
                            match$1[0],
                            match$2[0],
                            /* Cok */0
                          ])),
                    c
                  ];
          } else {
            return /* tuple */[
                    t$1,
                    /* Unchanged */0
                  ];
          }
      case /* Ttuple */2 :
          if (memq_warn(t$1, visited)) {
            return /* tuple */[
                    t$1,
                    /* Unchanged */0
                  ];
          }
          var visited$2 = /* :: */[
            t$1,
            visited
          ];
          var tlist$prime = List.map((function (param) {
                  return build_subtype(env, visited$2, loops, posi, level, param);
                }), match[0]);
          var c$1 = collect(tlist$prime);
          if (c$1 <= /* Unchanged */0) {
            return /* tuple */[
                    t$1,
                    /* Unchanged */0
                  ];
          }
          var desc = /* Ttuple */Block.__(2, [List.map((function (prim) {
                      return prim[0];
                    }), tlist$prime)]);
          return /* tuple */[
                  newty2(current_level.contents, desc),
                  c$1
                ];
      case /* Tconstr */3 :
          var tl = match[1];
          var p = match[0];
          if (level > 0 && generic_abbrev(env, p) && safe_abbrev(env, t$1) && !has_constr_row(expand_abbrev(env)(t$1))) {
            var t$prime$1 = repr(expand_abbrev(env)(t$1));
            var level$prime = pred_expand(level);
            try {
              var match$3 = t$prime$1.desc;
              if (typeof match$3 === "number") {
                throw Caml_builtin_exceptions.not_found;
              }
              if (match$3.tag !== /* Tobject */4) {
                throw Caml_builtin_exceptions.not_found;
              }
              if (!(posi && !opened_object(t$prime$1))) {
                throw Caml_builtin_exceptions.not_found;
              }
              var match$4 = find_cltype_for_path(env, p);
              var ty = subst(env, current_level.contents, /* Public */1, match[2], void 0, match$4[0].type_params, tl, match$4[1]);
              var ty$1 = repr(ty);
              var match$5 = ty$1.desc;
              var match$6;
              if (typeof match$5 === "number") {
                throw Caml_builtin_exceptions.not_found;
              }
              if (match$5.tag !== /* Tobject */4) {
                throw Caml_builtin_exceptions.not_found;
              }
              var match$7 = match$5[1].contents;
              if (match$7 === void 0) {
                throw Caml_builtin_exceptions.not_found;
              }
              var match$8 = match$7;
              if (!same(p, match$8[0])) {
                throw Caml_builtin_exceptions.not_found;
              }
              match$6 = /* tuple */[
                match$5[0],
                match$8[1]
              ];
              var tl1 = match$6[1];
              if (List.exists((function (param) {
                        return deep_occur(ty$1, param);
                      }), tl1)) {
                throw Caml_builtin_exceptions.not_found;
              }
              ty$1.desc = /* Tvar */Block.__(0, [void 0]);
              var t$prime$prime = newvar(void 0, void 0);
              var loops_000 = /* tuple */[
                ty$1,
                t$prime$prime
              ];
              var loops$1 = /* :: */[
                loops_000,
                loops
              ];
              var match$9 = build_subtype(env, /* :: */[
                    t$prime$1,
                    /* [] */0
                  ], loops$1, posi, pred_enlarge(level$prime), match$6[0]);
              var ty1$prime = match$9[0];
              if (!is_Tvar(t$prime$prime)) {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      /* tuple */[
                        "ctype.ml",
                        3770,
                        10
                      ]
                    ];
              }
              var nm = match$9[1] > /* Equiv */1 || deep_occur(ty$1, ty1$prime) ? void 0 : /* tuple */[
                  p,
                  tl1
                ];
              t$prime$prime.desc = /* Tobject */Block.__(4, [
                  ty1$prime,
                  {
                    contents: nm
                  }
                ]);
              try {
                unify_var(env, ty$1, t$1);
              }
              catch (raw_exn){
                var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn);
                if (exn$1[0] === Unify) {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        /* tuple */[
                          "ctype.ml",
                          3774,
                          50
                        ]
                      ];
                }
                throw exn$1;
              }
              return /* tuple */[
                      t$prime$prime,
                      /* Changed */2
                    ];
            }
            catch (exn$2){
              if (exn$2 !== Caml_builtin_exceptions.not_found) {
                throw exn$2;
              }
              var match$10 = build_subtype(env, visited, loops, posi, level$prime, t$prime$1);
              var c$2 = match$10[1];
              if (c$2 > /* Unchanged */0) {
                return /* tuple */[
                        match$10[0],
                        c$2
                      ];
              } else {
                return /* tuple */[
                        t$1,
                        /* Unchanged */0
                      ];
              }
            }
          } else {
            if (memq_warn(t$1, visited)) {
              return /* tuple */[
                      t$1,
                      /* Unchanged */0
                    ];
            }
            var visited$3 = /* :: */[
              t$1,
              visited
            ];
            try {
              var decl = find_type_full(p, env)[0];
              if (level === 0 && generic_abbrev(env, p) && safe_abbrev(env, t$1) && !has_constr_row(expand_abbrev(env)(t$1))) {
                warn.contents = true;
              }
              var tl$prime = List.map2((function (v, t) {
                      var match = Curry._1(Types_Variance.get_upper, v);
                      var co = match[0];
                      if (match[1]) {
                        if (co) {
                          return /* tuple */[
                                  t,
                                  /* Unchanged */0
                                ];
                        } else {
                          return build_subtype(env, visited$3, loops, !posi, level, t);
                        }
                      } else if (co) {
                        return build_subtype(env, visited$3, loops, posi, level, t);
                      } else {
                        return /* tuple */[
                                newvar(void 0, void 0),
                                /* Changed */2
                              ];
                      }
                    }), decl.type_variance, tl);
              var c$3 = collect(tl$prime);
              if (c$3 > /* Unchanged */0) {
                return /* tuple */[
                        newconstr(p, List.map((function (prim) {
                                    return prim[0];
                                  }), tl$prime)),
                        c$3
                      ];
              } else {
                return /* tuple */[
                        t$1,
                        /* Unchanged */0
                      ];
              }
            }
            catch (exn$3){
              if (exn$3 === Caml_builtin_exceptions.not_found) {
                return /* tuple */[
                        t$1,
                        /* Unchanged */0
                      ];
              }
              throw exn$3;
            }
          }
      case /* Tobject */4 :
          var t1 = match[0];
          if (memq_warn(t$1, visited) || opened_object(t1)) {
            return /* tuple */[
                    t$1,
                    /* Unchanged */0
                  ];
          }
          var level$prime$1 = pred_enlarge(level);
          var visited_001 = level$prime$1 < level ? /* [] */0 : filter_visited(visited);
          var visited$4 = /* :: */[
            t$1,
            visited_001
          ];
          var match$11 = build_subtype(env, visited$4, loops, posi, level$prime$1, t1);
          var c$4 = match$11[1];
          if (c$4 > /* Unchanged */0) {
            return /* tuple */[
                    newty2(current_level.contents, /* Tobject */Block.__(4, [
                            match$11[0],
                            {
                              contents: void 0
                            }
                          ])),
                    c$4
                  ];
          } else {
            return /* tuple */[
                    t$1,
                    /* Unchanged */0
                  ];
          }
      case /* Tfield */5 :
          var match$12 = build_subtype(env, visited, loops, posi, level, match[2]);
          var match$13 = build_subtype(env, visited, loops, posi, level, match[3]);
          var c$5 = Caml_primitive.caml_int_max(match$12[1], match$13[1]);
          if (c$5 > /* Unchanged */0) {
            return /* tuple */[
                    newty2(current_level.contents, /* Tfield */Block.__(5, [
                            match[0],
                            /* Fpresent */0,
                            match$12[0],
                            match$13[0]
                          ])),
                    c$5
                  ];
          } else {
            return /* tuple */[
                    t$1,
                    /* Unchanged */0
                  ];
          }
      case /* Tlink */6 :
      case /* Tsubst */7 :
          throw [
                Caml_builtin_exceptions.assert_failure,
                /* tuple */[
                  "ctype.ml",
                  3865,
                  6
                ]
              ];
      case /* Tvariant */8 :
          var row = row_repr_aux(/* [] */0, match[0]);
          if (memq_warn(t$1, visited) || !static_row(row)) {
            return /* tuple */[
                    t$1,
                    /* Unchanged */0
                  ];
          }
          var level$prime$2 = pred_enlarge(level);
          var visited_001$1 = level$prime$2 < level ? /* [] */0 : filter_visited(visited);
          var visited$5 = /* :: */[
            t$1,
            visited_001$1
          ];
          var fields = filter_row_fields(false, row.row_fields);
          var fields$1 = List.map((function (orig) {
                  var l = orig[0];
                  var match = row_field_repr_aux(/* [] */0, orig[1]);
                  if (typeof match === "number") {
                    throw [
                          Caml_builtin_exceptions.assert_failure,
                          /* tuple */[
                            "ctype.ml",
                            3832,
                            17
                          ]
                        ];
                  }
                  if (match.tag) {
                    throw [
                          Caml_builtin_exceptions.assert_failure,
                          /* tuple */[
                            "ctype.ml",
                            3832,
                            17
                          ]
                        ];
                  }
                  var match$1 = match[0];
                  if (match$1 === void 0) {
                    if (posi) {
                      return /* tuple */[
                              /* tuple */[
                                l,
                                /* Reither */Block.__(1, [
                                    true,
                                    /* [] */0,
                                    false,
                                    {
                                      contents: void 0
                                    }
                                  ])
                              ],
                              /* Unchanged */0
                            ];
                    } else {
                      return /* tuple */[
                              orig,
                              /* Unchanged */0
                            ];
                    }
                  }
                  var match$2 = build_subtype(env, visited$5, loops, posi, level$prime$2, match$1);
                  var t$prime = match$2[0];
                  var f = posi && level > 0 ? /* Reither */Block.__(1, [
                        false,
                        /* :: */[
                          t$prime,
                          /* [] */0
                        ],
                        false,
                        {
                          contents: void 0
                        }
                      ]) : /* Rpresent */Block.__(0, [t$prime]);
                  return /* tuple */[
                          /* tuple */[
                            l,
                            f
                          ],
                          match$2[1]
                        ];
                }), fields);
          var c$6 = collect(fields$1);
          var row_row_fields = List.map((function (prim) {
                  return prim[0];
                }), fields$1);
          var row_row_more = newvar(void 0, void 0);
          var row_row_name = c$6 > /* Unchanged */0 ? void 0 : row.row_name;
          var row$1 = {
            row_fields: row_row_fields,
            row_more: row_row_more,
            row_bound: void 0,
            row_closed: posi,
            row_fixed: false,
            row_name: row_row_name
          };
          return /* tuple */[
                  newty2(current_level.contents, /* Tvariant */Block.__(8, [row$1])),
                  /* Changed */2
                ];
      case /* Tpoly */10 :
          var match$14 = build_subtype(env, visited, loops, posi, level, match[0]);
          var c$7 = match$14[1];
          if (c$7 > /* Unchanged */0) {
            return /* tuple */[
                    newty2(current_level.contents, /* Tpoly */Block.__(10, [
                            match$14[0],
                            match[1]
                          ])),
                    c$7
                  ];
          } else {
            return /* tuple */[
                    t$1,
                    /* Unchanged */0
                  ];
          }
      case /* Tunivar */9 :
      case /* Tpackage */11 :
          return /* tuple */[
                  t$1,
                  /* Unchanged */0
                ];
      
    }
  }
}

function enlarge_type(env, ty) {
  warn.contents = false;
  var match = build_subtype(env, /* [] */0, /* [] */0, true, 4, ty);
  return /* tuple */[
          match[0],
          warn.contents
        ];
}

var subtypes = Curry._1(TypePairs.create, 17);

function subtype_error(env, trace) {
  throw [
        Subtype,
        expand_trace(env, List.rev(trace)),
        /* [] */0
      ];
}

function subtype_rec(env, _trace, _t1, _t2, _cstrs) {
  while(true) {
    var cstrs = _cstrs;
    var t2 = _t2;
    var t1 = _t1;
    var trace = _trace;
    var t1$1 = repr(t1);
    var t2$1 = repr(t2);
    if (t1$1 === t2$1) {
      return cstrs;
    }
    try {
      Curry._2(TypePairs.find, subtypes, /* tuple */[
            t1$1,
            t2$1
          ]);
      return cstrs;
    }
    catch (exn){
      if (exn !== Caml_builtin_exceptions.not_found) {
        throw exn;
      }
      Curry._3(TypePairs.add, subtypes, /* tuple */[
            t1$1,
            t2$1
          ], void 0);
      var match = t1$1.desc;
      var match$1 = t2$1.desc;
      var exit = 0;
      var exit$1 = 0;
      var exit$2 = 0;
      var exit$3 = 0;
      var exit$4 = 0;
      if (typeof match === "number") {
        exit$4 = 6;
      } else {
        switch (match.tag | 0) {
          case /* Tvar */0 :
              exit = 2;
              break;
          case /* Tarrow */1 :
              var u1 = match[2];
              var t1$2 = match[1];
              var l1 = match[0];
              if (typeof match$1 === "number") {
                exit = 1;
              } else {
                switch (match$1.tag | 0) {
                  case /* Tvar */0 :
                      exit$4 = 6;
                      break;
                  case /* Tarrow */1 :
                      var u2 = match$1[2];
                      var t2$2 = match$1[1];
                      var l2 = match$1[0];
                      if (l1 === l2 || classic.contents && !(is_optional(l1) || is_optional(l2))) {
                        var cstrs$1 = subtype_rec(env, /* :: */[
                              /* tuple */[
                                t2$2,
                                t1$2
                              ],
                              trace
                            ], t2$2, t1$2, cstrs);
                        _cstrs = cstrs$1;
                        _t2 = u2;
                        _t1 = u1;
                        _trace = /* :: */[
                          /* tuple */[
                            u1,
                            u2
                          ],
                          trace
                        ];
                        continue ;
                      } else {
                        exit = 1;
                      }
                      break;
                  case /* Tconstr */3 :
                      exit$2 = 4;
                      break;
                  default:
                    exit = 1;
                }
              }
              break;
          case /* Ttuple */2 :
              if (typeof match$1 === "number") {
                exit = 1;
              } else {
                switch (match$1.tag | 0) {
                  case /* Tvar */0 :
                      exit$4 = 6;
                      break;
                  case /* Ttuple */2 :
                      var tl1 = match[0];
                      var tl2 = match$1[0];
                      if (List.length(tl1) !== List.length(tl2)) {
                        subtype_error(env, trace);
                      }
                      return List.fold_left2((function(trace){
                                return function (cstrs, t1, t2) {
                                  return subtype_rec(env, /* :: */[
                                              /* tuple */[
                                                t1,
                                                t2
                                              ],
                                              trace
                                            ], t1, t2, cstrs);
                                }
                                }(trace)), cstrs, tl1, tl2);
                  case /* Tconstr */3 :
                      exit$2 = 4;
                      break;
                  default:
                    exit = 1;
                }
              }
              break;
          case /* Tconstr */3 :
              if (match[1]) {
                exit$4 = 6;
              } else if (typeof match$1 === "number") {
                exit$3 = 5;
              } else {
                switch (match$1.tag | 0) {
                  case /* Tvar */0 :
                      exit$4 = 6;
                      break;
                  case /* Tconstr */3 :
                      if (match$1[1]) {
                        exit$3 = 5;
                      } else {
                        if (same(match[0], match$1[0])) {
                          return cstrs;
                        }
                        exit$3 = 5;
                      }
                      break;
                  default:
                    exit$3 = 5;
                }
              }
              break;
          case /* Tobject */4 :
              var f1 = match[0];
              if (typeof match$1 === "number") {
                exit = 1;
              } else {
                switch (match$1.tag | 0) {
                  case /* Tvar */0 :
                      exit$4 = 6;
                      break;
                  case /* Tconstr */3 :
                      exit$2 = 4;
                      break;
                  case /* Tobject */4 :
                      var f2 = match$1[0];
                      if (is_Tvar(object_row(f1)) && is_Tvar(object_row(f2))) {
                        return /* :: */[
                                /* tuple */[
                                  trace,
                                  t1$1,
                                  t2$1,
                                  univar_pairs.contents
                                ],
                                cstrs
                              ];
                      } else {
                        var match$2 = flatten_fields(f1);
                        var rest1 = match$2[1];
                        var match$3 = flatten_fields(f2);
                        var rest2 = match$3[1];
                        var match$4 = associate_fields(match$2[0], match$3[0]);
                        var miss2 = match$4[2];
                        var miss1 = match$4[1];
                        var cstrs$2 = rest2.desc === /* Tnil */0 ? cstrs : (
                            miss1 === /* [] */0 ? subtype_rec(env, /* :: */[
                                    /* tuple */[
                                      rest1,
                                      rest2
                                    ],
                                    trace
                                  ], rest1, rest2, cstrs) : /* :: */[
                                /* tuple */[
                                  trace,
                                  build_fields(repr(f1).level)(miss1, rest1),
                                  rest2,
                                  univar_pairs.contents
                                ],
                                cstrs
                              ]
                          );
                        var cstrs$3 = miss2 === /* [] */0 ? cstrs$2 : /* :: */[
                            /* tuple */[
                              trace,
                              rest1,
                              build_fields(repr(f2).level)(miss2, newvar(void 0, void 0)),
                              univar_pairs.contents
                            ],
                            cstrs$2
                          ];
                        return List.fold_left((function(trace){
                                  return function (cstrs, param) {
                                    var t2 = param[4];
                                    var t1 = param[2];
                                    return subtype_rec(env, /* :: */[
                                                /* tuple */[
                                                  t1,
                                                  t2
                                                ],
                                                trace
                                              ], t1, t2, cstrs);
                                  }
                                  }(trace)), cstrs$3, match$4[0]);
                      }
                  default:
                    exit = 1;
                }
              }
              break;
          case /* Tvariant */8 :
              if (typeof match$1 === "number") {
                exit = 1;
              } else {
                switch (match$1.tag | 0) {
                  case /* Tvar */0 :
                      exit$4 = 6;
                      break;
                  case /* Tconstr */3 :
                      exit$2 = 4;
                      break;
                  case /* Tvariant */8 :
                      try {
                        var row1 = match[0];
                        var row2 = match$1[0];
                        var row1$1 = row_repr_aux(/* [] */0, row1);
                        var row2$1 = row_repr_aux(/* [] */0, row2);
                        var match$5 = merge_row_fields(row1$1.row_fields, row2$1.row_fields);
                        var pairs = match$5[2];
                        var r1 = match$5[0];
                        var more1 = repr(row1$1.row_more);
                        var more2 = repr(row2$1.row_more);
                        var match$6 = more1.desc;
                        var match$7 = more2.desc;
                        var exit$5 = 0;
                        if (typeof match$6 === "number") {
                          exit$5 = 1;
                        } else {
                          switch (match$6.tag | 0) {
                            case /* Tvar */0 :
                                exit$5 = 1;
                                break;
                            case /* Tconstr */3 :
                                if (typeof match$7 === "number" || match$7.tag !== /* Tconstr */3) {
                                  exit$5 = 1;
                                } else {
                                  if (same(match$6[0], match$7[0])) {
                                    return subtype_rec(env, /* :: */[
                                                /* tuple */[
                                                  more1,
                                                  more2
                                                ],
                                                trace
                                              ], more1, more2, cstrs);
                                  }
                                  exit$5 = 1;
                                }
                                break;
                            case /* Tunivar */9 :
                                if (typeof match$7 === "number") {
                                  throw Pervasives.Exit;
                                }
                                if (match$7.tag !== /* Tunivar */9) {
                                  throw Pervasives.Exit;
                                }
                                if (!(row1$1.row_closed === row2$1.row_closed && r1 === /* [] */0 && match$5[1] === /* [] */0)) {
                                  throw Pervasives.Exit;
                                }
                                var cstrs$4 = subtype_rec(env, /* :: */[
                                      /* tuple */[
                                        more1,
                                        more2
                                      ],
                                      trace
                                    ], more1, more2, cstrs);
                                return List.fold_left((function(trace){
                                          return function (cstrs, param) {
                                            var match = row_field_repr_aux(/* [] */0, param[1]);
                                            var match$1 = row_field_repr_aux(/* [] */0, param[2]);
                                            var t1;
                                            var t2;
                                            if (typeof match === "number") {
                                              if (typeof match$1 === "number") {
                                                return cstrs;
                                              }
                                              throw Pervasives.Exit;
                                            } else if (match.tag) {
                                              if (match[0]) {
                                                if (match[1]) {
                                                  throw Pervasives.Exit;
                                                }
                                                if (typeof match$1 === "number") {
                                                  throw Pervasives.Exit;
                                                }
                                                if (!match$1.tag) {
                                                  throw Pervasives.Exit;
                                                }
                                                if (!match$1[0]) {
                                                  throw Pervasives.Exit;
                                                }
                                                if (match$1[1]) {
                                                  throw Pervasives.Exit;
                                                }
                                                return cstrs;
                                              } else {
                                                var match$2 = match[1];
                                                if (!match$2) {
                                                  throw Pervasives.Exit;
                                                }
                                                if (match$2[1]) {
                                                  throw Pervasives.Exit;
                                                }
                                                if (typeof match$1 === "number") {
                                                  throw Pervasives.Exit;
                                                }
                                                if (!match$1.tag) {
                                                  throw Pervasives.Exit;
                                                }
                                                if (match$1[0]) {
                                                  throw Pervasives.Exit;
                                                }
                                                var match$3 = match$1[1];
                                                if (!match$3) {
                                                  throw Pervasives.Exit;
                                                }
                                                if (match$3[1]) {
                                                  throw Pervasives.Exit;
                                                }
                                                t1 = match$2[0];
                                                t2 = match$3[0];
                                              }
                                            } else {
                                              var match$4 = match[0];
                                              if (match$4 !== void 0) {
                                                if (typeof match$1 === "number") {
                                                  throw Pervasives.Exit;
                                                }
                                                if (match$1.tag) {
                                                  throw Pervasives.Exit;
                                                }
                                                var match$5 = match$1[0];
                                                if (match$5 === void 0) {
                                                  throw Pervasives.Exit;
                                                }
                                                t1 = match$4;
                                                t2 = match$5;
                                              } else {
                                                if (typeof match$1 === "number") {
                                                  throw Pervasives.Exit;
                                                }
                                                if (match$1.tag) {
                                                  throw Pervasives.Exit;
                                                }
                                                if (match$1[0] !== void 0) {
                                                  throw Pervasives.Exit;
                                                }
                                                return cstrs;
                                              }
                                            }
                                            return subtype_rec(env, /* :: */[
                                                        /* tuple */[
                                                          t1,
                                                          t2
                                                        ],
                                                        trace
                                                      ], t1, t2, cstrs);
                                          }
                                          }(trace)), cstrs$4, pairs);
                            default:
                              throw Pervasives.Exit;
                          }
                        }
                        if (exit$5 === 1) {
                          if (typeof match$7 !== "number") {
                            switch (match$7.tag | 0) {
                              case /* Tvar */0 :
                              case /* Tconstr */3 :
                                  break;
                              default:
                                throw Pervasives.Exit;
                            }
                          }
                          if (row1$1.row_closed && r1 === /* [] */0) {
                            return List.fold_left((function(trace){
                                      return function (cstrs, param) {
                                        var match = row_field_repr_aux(/* [] */0, param[1]);
                                        var match$1 = row_field_repr_aux(/* [] */0, param[2]);
                                        if (typeof match === "number") {
                                          return cstrs;
                                        }
                                        if (match.tag) {
                                          if (!match[0]) {
                                            var match$2 = match[1];
                                            if (!match$2) {
                                              throw Pervasives.Exit;
                                            }
                                            var t1 = match$2[0];
                                            if (typeof match$1 === "number") {
                                              throw Pervasives.Exit;
                                            }
                                            if (match$1.tag) {
                                              throw Pervasives.Exit;
                                            }
                                            var match$3 = match$1[0];
                                            if (match$3 === void 0) {
                                              throw Pervasives.Exit;
                                            }
                                            var t2 = match$3;
                                            return subtype_rec(env, /* :: */[
                                                        /* tuple */[
                                                          t1,
                                                          t2
                                                        ],
                                                        trace
                                                      ], t1, t2, cstrs);
                                          }
                                          
                                        } else {
                                          var match$4 = match[0];
                                          if (match$4 !== void 0) {
                                            var t1$1 = match$4;
                                            if (typeof match$1 === "number") {
                                              throw Pervasives.Exit;
                                            }
                                            if (match$1.tag) {
                                              throw Pervasives.Exit;
                                            }
                                            var match$5 = match$1[0];
                                            if (match$5 === void 0) {
                                              throw Pervasives.Exit;
                                            }
                                            var t2$1 = match$5;
                                            return subtype_rec(env, /* :: */[
                                                        /* tuple */[
                                                          t1$1,
                                                          t2$1
                                                        ],
                                                        trace
                                                      ], t1$1, t2$1, cstrs);
                                          }
                                          
                                        }
                                        if (typeof match$1 === "number") {
                                          throw Pervasives.Exit;
                                        }
                                        if (match$1.tag) {
                                          throw Pervasives.Exit;
                                        }
                                        if (match$1[0] !== void 0) {
                                          throw Pervasives.Exit;
                                        }
                                        return cstrs;
                                      }
                                      }(trace)), cstrs, pairs);
                          }
                          throw Pervasives.Exit;
                        }
                        
                      }
                      catch (exn$1){
                        if (exn$1 === Pervasives.Exit) {
                          return /* :: */[
                                  /* tuple */[
                                    trace,
                                    t1$1,
                                    t2$1,
                                    univar_pairs.contents
                                  ],
                                  cstrs
                                ];
                        }
                        throw exn$1;
                      }
                  default:
                    exit = 1;
                }
              }
              break;
          case /* Tpoly */10 :
              var tl1$1 = match[1];
              var u1$1 = match[0];
              var exit$6 = 0;
              if (tl1$1) {
                exit$6 = 7;
              } else if (typeof match$1 === "number") {
                exit = 1;
              } else {
                switch (match$1.tag | 0) {
                  case /* Tvar */0 :
                      exit$4 = 6;
                      break;
                  case /* Tconstr */3 :
                      exit$2 = 4;
                      break;
                  case /* Tpoly */10 :
                      if (match$1[1]) {
                        exit$6 = 7;
                      } else {
                        _t2 = match$1[0];
                        _t1 = u1$1;
                        continue ;
                      }
                      break;
                  default:
                    exit = 1;
                }
              }
              if (exit$6 === 7) {
                if (typeof match$1 === "number") {
                  exit = 1;
                } else {
                  switch (match$1.tag | 0) {
                    case /* Tvar */0 :
                        exit$4 = 6;
                        break;
                    case /* Tconstr */3 :
                        exit$2 = 4;
                        break;
                    case /* Tpoly */10 :
                        var tl2$1 = match$1[1];
                        var u2$1 = match$1[0];
                        if (tl2$1) {
                          try {
                            return enter_poly(env, univar_pairs, u1$1, tl1$1, u2$1, tl2$1, (function(trace,cstrs){
                                      return function (t1, t2) {
                                        return subtype_rec(env, trace, t1, t2, cstrs);
                                      }
                                      }(trace,cstrs)));
                          }
                          catch (raw_exn){
                            var exn$2 = Caml_js_exceptions.internalToOCamlException(raw_exn);
                            if (exn$2[0] === Unify) {
                              return /* :: */[
                                      /* tuple */[
                                        trace,
                                        t1$1,
                                        t2$1,
                                        univar_pairs.contents
                                      ],
                                      cstrs
                                    ];
                            }
                            throw exn$2;
                          }
                        } else {
                          var match$8 = instance_poly(void 0, false, tl1$1, u1$1);
                          _t2 = u2$1;
                          _t1 = match$8[1];
                          continue ;
                        }
                    default:
                      exit = 1;
                  }
                }
              }
              break;
          case /* Tpackage */11 :
              var tl1$2 = match[2];
              var nl1 = match[1];
              var p1 = match[0];
              if (typeof match$1 === "number") {
                exit = 1;
              } else {
                switch (match$1.tag | 0) {
                  case /* Tvar */0 :
                      exit$4 = 6;
                      break;
                  case /* Tconstr */3 :
                      exit$2 = 4;
                      break;
                  case /* Tpackage */11 :
                      var tl2$2 = match$1[2];
                      var nl2 = match$1[1];
                      var p2 = match$1[0];
                      try {
                        var ntl1 = complete_type_list(void 0, env, nl2, t1$1.level, /* Mty_ident */Block.__(0, [p1]), nl1, tl1$2);
                        var ntl2 = complete_type_list(true, env, nl1, t2$1.level, /* Mty_ident */Block.__(0, [p2]), nl2, tl2$2);
                        var cstrs$prime = List.map((function(trace,ntl1){
                            return function (param) {
                              return /* tuple */[
                                      trace,
                                      List.assoc(param[0], ntl1),
                                      param[1],
                                      univar_pairs.contents
                                    ];
                            }
                            }(trace,ntl1)), ntl2);
                        if (eq_package_path(env, p1, p2)) {
                          return Pervasives.$at(cstrs$prime, cstrs);
                        }
                        var snap = snapshot(void 0);
                        try {
                          List.iter((function (param) {
                                  return unify$2(env, param[1], param[2]);
                                }), cstrs$prime);
                          if (!Curry._7(package_subtype.contents, env, p1, nl1, tl1$2, p2, nl2, tl2$2)) {
                            throw [
                                  Unify,
                                  /* [] */0
                                ];
                          }
                          backtrack(snap);
                          return Pervasives.$at(cstrs$prime, cstrs);
                        }
                        catch (raw_exn$1){
                          var exn$3 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
                          if (exn$3[0] !== Unify) {
                            throw exn$3;
                          }
                          backtrack(snap);
                          throw Caml_builtin_exceptions.not_found;
                        }
                      }
                      catch (exn$4){
                        if (exn$4 === Caml_builtin_exceptions.not_found) {
                          return /* :: */[
                                  /* tuple */[
                                    trace,
                                    t1$1,
                                    t2$1,
                                    univar_pairs.contents
                                  ],
                                  cstrs
                                ];
                        }
                        throw exn$4;
                      }
                  default:
                    exit = 1;
                }
              }
              break;
          default:
            exit$4 = 6;
        }
      }
      if (exit$4 === 6) {
        if (typeof match$1 === "number" || match$1.tag) {
          exit$3 = 5;
        } else {
          exit = 2;
        }
      }
      if (exit$3 === 5) {
        if (typeof match === "number" || !(match.tag === /* Tconstr */3 && generic_abbrev(env, match[0]) && safe_abbrev(env, t1$1))) {
          exit$2 = 4;
        } else {
          _t2 = t2$1;
          _t1 = expand_abbrev(env)(t1$1);
          continue ;
        }
      }
      if (exit$2 === 4) {
        if (typeof match$1 === "number" || !(match$1.tag === /* Tconstr */3 && generic_abbrev(env, match$1[0]) && safe_abbrev(env, t2$1))) {
          exit$1 = 3;
        } else {
          _t2 = expand_abbrev(env)(t2$1);
          _t1 = t1$1;
          continue ;
        }
      }
      if (exit$1 === 3) {
        if (typeof match === "number" || match.tag !== /* Tconstr */3) {
          exit = 1;
        } else {
          var p1$1 = match[0];
          var exit$7 = 0;
          if (typeof match$1 === "number" || !(match$1.tag === /* Tconstr */3 && same(p1$1, match$1[0]))) {
            exit$7 = 4;
          } else {
            try {
              var decl = find_type_full(p1$1, env)[0];
              return List.fold_left2((function(trace){
                        return function (cstrs, v, param) {
                          var t2 = param[1];
                          var t1 = param[0];
                          var match = Curry._1(Types_Variance.get_upper, v);
                          var cn = match[1];
                          if (match[0]) {
                            if (cn) {
                              return /* :: */[
                                      /* tuple */[
                                        trace,
                                        newty2(t1.level, /* Ttuple */Block.__(2, [/* :: */[
                                                  t1,
                                                  /* [] */0
                                                ]])),
                                        newty2(t2.level, /* Ttuple */Block.__(2, [/* :: */[
                                                  t2,
                                                  /* [] */0
                                                ]])),
                                        univar_pairs.contents
                                      ],
                                      cstrs
                                    ];
                            } else {
                              return subtype_rec(env, /* :: */[
                                          /* tuple */[
                                            t1,
                                            t2
                                          ],
                                          trace
                                        ], t1, t2, cstrs);
                            }
                          } else if (cn) {
                            return subtype_rec(env, /* :: */[
                                        /* tuple */[
                                          t2,
                                          t1
                                        ],
                                        trace
                                      ], t2, t1, cstrs);
                          } else {
                            return cstrs;
                          }
                        }
                        }(trace)), cstrs, decl.type_variance, List.combine(match[1], match$1[1]));
            }
            catch (exn$5){
              if (exn$5 === Caml_builtin_exceptions.not_found) {
                return /* :: */[
                        /* tuple */[
                          trace,
                          t1$1,
                          t2$1,
                          univar_pairs.contents
                        ],
                        cstrs
                      ];
              }
              throw exn$5;
            }
          }
          if (exit$7 === 4) {
            if (generic_private_abbrev(env, p1$1)) {
              _t2 = t2$1;
              _t1 = expand_abbrev_opt(env, t1$1);
              continue ;
            } else {
              exit = 1;
            }
          }
          
        }
      }
      switch (exit) {
        case 1 :
        case 2 :
            return /* :: */[
                    /* tuple */[
                      trace,
                      t1$1,
                      t2$1,
                      univar_pairs.contents
                    ],
                    cstrs
                  ];
        
      }
    }
  };
}

function subtype(env, ty1, ty2) {
  Curry._1(TypePairs.clear, subtypes);
  univar_pairs.contents = /* [] */0;
  var cstrs = subtype_rec(env, /* :: */[
        /* tuple */[
          ty1,
          ty2
        ],
        /* [] */0
      ], ty1, ty2, /* [] */0);
  Curry._1(TypePairs.clear, subtypes);
  return (function (param) {
      return List.iter((function (param) {
                    try {
                      return unify_pairs({
                                  contents: env
                                }, param[1], param[2], param[3]);
                    }
                    catch (raw_exn){
                      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                      if (exn[0] === Unify) {
                        throw [
                              Subtype,
                              expand_trace(env, List.rev(param[0])),
                              List.tl(List.tl(exn[1]))
                            ];
                      }
                      throw exn;
                    }
                  }), List.rev(cstrs));
    });
}

function unalias_object(ty) {
  var ty$1 = repr(ty);
  var match = ty$1.desc;
  if (typeof match === "number") {
    return newty2(ty$1.level, ty$1.desc);
  }
  switch (match.tag | 0) {
    case /* Tvar */0 :
        return newty2(ty$1.level, ty$1.desc);
    case /* Tconstr */3 :
        return newty2(ty$1.level, /* Tvar */Block.__(0, [void 0]));
    case /* Tfield */5 :
        return newty2(ty$1.level, /* Tfield */Block.__(5, [
                      match[0],
                      match[1],
                      match[2],
                      unalias_object(match[3])
                    ]));
    case /* Tunivar */9 :
        return ty$1;
    default:
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "ctype.ml",
              4129,
              6
            ]
          ];
  }
}

function unalias(ty) {
  var ty$1 = repr(ty);
  var match = ty$1.desc;
  if (typeof match === "number") {
    return newty2(ty$1.level, ty$1.desc);
  }
  switch (match.tag | 0) {
    case /* Tobject */4 :
        var ty$2 = match[0];
        return newty2(ty$2.level, /* Tobject */Block.__(4, [
                      unalias_object(ty$2),
                      match[1]
                    ]));
    case /* Tvariant */8 :
        var row = row_repr_aux(/* [] */0, match[0]);
        var more = row.row_more;
        return newty2(ty$1.level, /* Tvariant */Block.__(8, [{
                        row_fields: row.row_fields,
                        row_more: newty2(more.level, more.desc),
                        row_bound: row.row_bound,
                        row_closed: row.row_closed,
                        row_fixed: row.row_fixed,
                        row_name: row.row_name
                      }]));
    case /* Tvar */0 :
    case /* Tunivar */9 :
        return ty$1;
    default:
      return newty2(ty$1.level, ty$1.desc);
  }
}

function arity(ty) {
  var match = repr(ty).desc;
  if (typeof match === "number" || match.tag !== /* Tarrow */1) {
    return 0;
  } else {
    return 1 + arity(match[2]) | 0;
  }
}

function cyclic_abbrev(env, id, ty) {
  var check_cycle = function (seen, ty) {
    var ty$1 = repr(ty);
    var match = ty$1.desc;
    if (typeof match === "number") {
      return false;
    }
    if (match.tag !== /* Tconstr */3) {
      return false;
    }
    if (Caml_obj.caml_equal(match[0], /* Pident */Block.__(0, [id]))) {
      return true;
    }
    if (List.memq(ty$1, seen)) {
      return true;
    }
    try {
      return check_cycle(/* :: */[
                  ty$1,
                  seen
                ], expand_abbrev_opt(env, ty$1));
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn === Cannot_expand) {
        return false;
      }
      if (exn[0] === Unify) {
        return true;
      }
      throw exn;
    }
  };
  return check_cycle(/* [] */0, ty);
}

function normalize_type_rec(env, visited, ty) {
  var ty$1 = repr(ty);
  if (mem$3(ty$1, visited.contents)) {
    return ;
  }
  visited.contents = add$3(ty$1, visited.contents);
  var match = ty$1.desc;
  if (typeof match !== "number") {
    switch (match.tag | 0) {
      case /* Tobject */4 :
          var nm = match[1];
          var match$1 = nm.contents;
          if (match$1 !== void 0) {
            var match$2 = match$1;
            var match$3 = match$2[1];
            if (match$3) {
              var l = match$3[1];
              var v = match$3[0];
              var n = match$2[0];
              if (deep_occur(ty$1, newty2(100000000, /* Ttuple */Block.__(2, [l])))) {
                set_name(nm, void 0);
              } else {
                var v$prime = repr(v);
                var match$4 = v$prime.desc;
                var exit = 0;
                if (typeof match$4 === "number") {
                  log_type(ty$1);
                  ty$1.desc = /* Tconstr */Block.__(3, [
                      n,
                      l,
                      {
                        contents: /* Mnil */0
                      }
                    ]);
                } else {
                  switch (match$4.tag | 0) {
                    case /* Tvar */0 :
                    case /* Tunivar */9 :
                        exit = 1;
                        break;
                    default:
                      set_name(nm, void 0);
                  }
                }
                if (exit === 1) {
                  if (v$prime !== v) {
                    set_name(nm, /* tuple */[
                          n,
                          /* :: */[
                            v$prime,
                            l
                          ]
                        ]);
                  }
                  
                }
                
              }
            } else {
              fatal_error("Ctype.normalize_type_rec");
            }
          }
          var fi = repr(match[0]);
          if (fi.level >= 0) {
            var match$5 = flatten_fields(fi);
            var fi$prime = build_fields(fi.level)(match$5[0], match$5[1]);
            log_type(ty$1);
            fi.desc = fi$prime.desc;
          }
          break;
      case /* Tvariant */8 :
          var row = row_repr_aux(/* [] */0, match[0]);
          var fields = List.map((function (param) {
                  var f0 = param[1];
                  var f = row_field_repr_aux(/* [] */0, f0);
                  var tmp;
                  if (typeof f === "number" || !f.tag) {
                    tmp = f;
                  } else {
                    var match = f[1];
                    if (match) {
                      var tyl = match[1];
                      if (tyl) {
                        var tyl$prime = List.fold_left((function (tyl, ty) {
                                if (List.exists((function (ty$prime) {
                                          return equal$4(env, false, /* :: */[
                                                      ty,
                                                      /* [] */0
                                                    ], /* :: */[
                                                      ty$prime,
                                                      /* [] */0
                                                    ]);
                                        }), tyl)) {
                                  return tyl;
                                } else {
                                  return /* :: */[
                                          ty,
                                          tyl
                                        ];
                                }
                              }), /* :: */[
                              match[0],
                              /* [] */0
                            ], tyl);
                        tmp = f !== f0 || List.length(tyl$prime) < List.length(tyl) ? /* Reither */Block.__(1, [
                              f[0],
                              List.rev(tyl$prime),
                              f[2],
                              f[3]
                            ]) : f;
                      } else {
                        tmp = f;
                      }
                    } else {
                      tmp = f;
                    }
                  }
                  return /* tuple */[
                          param[0],
                          tmp
                        ];
                }), row.row_fields);
          var fields$1 = List.sort((function (param, param$1) {
                  return Caml_primitive.caml_string_compare(param[0], param$1[0]);
                }), List.filter((function (param) {
                        return param[1] !== /* Rabsent */0;
                      }))(fields));
          log_type(ty$1);
          ty$1.desc = /* Tvariant */Block.__(8, [{
                row_fields: fields$1,
                row_more: row.row_more,
                row_bound: row.row_bound,
                row_closed: row.row_closed,
                row_fixed: row.row_fixed,
                row_name: row.row_name
              }]);
          break;
      default:
        
    }
  }
  return iter_type_expr((function (param) {
                return normalize_type_rec(env, visited, param);
              }), ty$1);
}

function normalize_type(env, ty) {
  return normalize_type_rec(env, {
              contents: /* Empty */0
            }, ty);
}

var nondep_hash = Curry._1(TypeHash.create, 47);

var nondep_variants = Curry._1(TypeHash.create, 17);

function nondep_type_rec(env, id, _ty) {
  while(true) {
    var ty = _ty;
    var match = ty.desc;
    var exit = 0;
    if (typeof match === "number") {
      exit = 1;
    } else {
      switch (match.tag | 0) {
        case /* Tlink */6 :
            _ty = match[0];
            continue ;
        case /* Tvar */0 :
        case /* Tunivar */9 :
            return ty;
        default:
          exit = 1;
      }
    }
    if (exit === 1) {
      try {
        return Curry._2(TypeHash.find, nondep_hash, ty);
      }
      catch (exn){
        if (exn !== Caml_builtin_exceptions.not_found) {
          throw exn;
        }
        var ty$prime = newty2(100000000, /* Tvar */Block.__(0, [void 0]));
        Curry._3(TypeHash.add, nondep_hash, ty, ty$prime);
        var match$1 = ty.desc;
        var tmp;
        var exit$1 = 0;
        if (typeof match$1 === "number") {
          exit$1 = 2;
        } else {
          switch (match$1.tag | 0) {
            case /* Tconstr */3 :
                var p = match$1[0];
                if (isfree(id, p)) {
                  try {
                    tmp = /* Tlink */Block.__(6, [nondep_type_rec(env, id, expand_abbrev(env)(newty2(ty.level, ty.desc)))]);
                  }
                  catch (raw_exn){
                    var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn);
                    if (exn$1 === Cannot_expand) {
                      throw Caml_builtin_exceptions.not_found;
                    }
                    if (exn$1[0] === Unify) {
                      throw Caml_builtin_exceptions.not_found;
                    }
                    throw exn$1;
                  }
                } else {
                  tmp = /* Tconstr */Block.__(3, [
                      p,
                      List.map((function (param) {
                              return nondep_type_rec(env, id, param);
                            }), match$1[1]),
                      {
                        contents: /* Mnil */0
                      }
                    ]);
                }
                break;
            case /* Tobject */4 :
                var match$2 = match$1[1].contents;
                var tmp$1;
                if (match$2 !== void 0) {
                  var match$3 = match$2;
                  var p$1 = match$3[0];
                  tmp$1 = isfree(id, p$1) ? void 0 : /* tuple */[
                      p$1,
                      List.map((function (param) {
                              return nondep_type_rec(env, id, param);
                            }), match$3[1])
                    ];
                } else {
                  tmp$1 = void 0;
                }
                tmp = /* Tobject */Block.__(4, [
                    nondep_type_rec(env, id, match$1[0]),
                    {
                      contents: tmp$1
                    }
                  ]);
                break;
            case /* Tvariant */8 :
                var row = row_repr_aux(/* [] */0, match$1[0]);
                var more = repr(row.row_more);
                try {
                  var ty2 = Curry._2(TypeHash.find, nondep_variants, more);
                  Curry._3(TypeHash.add, nondep_hash, ty, ty2);
                  tmp = /* Tlink */Block.__(6, [ty2]);
                }
                catch (exn$2){
                  if (exn$2 !== Caml_builtin_exceptions.not_found) {
                    throw exn$2;
                  }
                  Curry._3(TypeHash.add, nondep_variants, more, ty$prime);
                  var $$static = static_row(row);
                  var more$prime = $$static ? newty2(100000000, /* Tnil */0) : more;
                  var row$1 = copy_row((function (param) {
                          return nondep_type_rec(env, id, param);
                        }), true, row, true, more$prime);
                  var match$4 = row$1.row_name;
                  tmp = match$4 !== void 0 && isfree(id, match$4[0]) ? /* Tvariant */Block.__(8, [{
                          row_fields: row$1.row_fields,
                          row_more: row$1.row_more,
                          row_bound: row$1.row_bound,
                          row_closed: row$1.row_closed,
                          row_fixed: row$1.row_fixed,
                          row_name: void 0
                        }]) : /* Tvariant */Block.__(8, [row$1]);
                }
                break;
            case /* Tpackage */11 :
                var p$2 = match$1[0];
                if (isfree(id, p$2)) {
                  var p$prime = normalize_package_path(env, p$2);
                  if (isfree(id, p$prime)) {
                    throw Caml_builtin_exceptions.not_found;
                  }
                  tmp = /* Tpackage */Block.__(11, [
                      p$prime,
                      match$1[1],
                      List.map((function (param) {
                              return nondep_type_rec(env, id, param);
                            }), match$1[2])
                    ]);
                } else {
                  exit$1 = 2;
                }
                break;
            default:
              exit$1 = 2;
          }
        }
        if (exit$1 === 2) {
          tmp = copy_type_desc(void 0, (function (param) {
                  return nondep_type_rec(env, id, param);
                }), ty.desc);
        }
        ty$prime.desc = tmp;
        return ty$prime;
      }
    }
    
  };
}

function nondep_type(env, id, ty) {
  try {
    var ty$prime = nondep_type_rec(env, id, ty);
    Curry._1(TypeHash.clear, nondep_hash);
    Curry._1(TypeHash.clear, nondep_variants);
    return ty$prime;
  }
  catch (exn){
    if (exn !== Caml_builtin_exceptions.not_found) {
      throw exn;
    }
    Curry._1(TypeHash.clear, nondep_hash);
    Curry._1(TypeHash.clear, nondep_variants);
    throw Caml_builtin_exceptions.not_found;
  }
}

nondep_type$prime.contents = nondep_type;

function unroll_abbrev(id, tl, ty) {
  var ty$1 = repr(ty);
  var path = /* Pident */Block.__(0, [id]);
  if (is_Tvar(ty$1) || List.exists((function (param) {
            return deep_occur(ty$1, param);
          }), tl) || is_object_type(path)) {
    return ty$1;
  }
  var ty$prime = newty2(ty$1.level, ty$1.desc);
  link_type(ty$1, newty2(ty$1.level, /* Tconstr */Block.__(3, [
              path,
              tl,
              {
                contents: /* Mnil */0
              }
            ])));
  return ty$prime;
}

function nondep_type_decl(env, mid, id, is_covariant, decl) {
  try {
    var params = List.map((function (param) {
            return nondep_type_rec(env, mid, param);
          }), decl.type_params);
    var tk;
    try {
      var match = decl.type_kind;
      tk = typeof match === "number" ? (
          match === /* Type_abstract */0 ? /* Type_abstract */0 : /* Type_open */1
        ) : (
          match.tag ? /* Type_variant */Block.__(1, [List.map((function (c) {
                        return {
                                cd_id: c.cd_id,
                                cd_args: List.map((function (param) {
                                        return nondep_type_rec(env, mid, param);
                                      }), c.cd_args),
                                cd_res: may_map((function (param) {
                                        return nondep_type_rec(env, mid, param);
                                      }), c.cd_res),
                                cd_loc: c.cd_loc,
                                cd_attributes: c.cd_attributes
                              };
                      }), match[0])]) : /* Type_record */Block.__(0, [
                List.map((function (l) {
                        return {
                                ld_id: l.ld_id,
                                ld_mutable: l.ld_mutable,
                                ld_type: nondep_type_rec(env, mid, l.ld_type),
                                ld_loc: l.ld_loc,
                                ld_attributes: l.ld_attributes
                              };
                      }), match[0]),
                match[1]
              ])
        );
    }
    catch (exn){
      if (exn !== Caml_builtin_exceptions.not_found) {
        throw exn;
      }
      if (!is_covariant) {
        throw exn;
      }
      tk = /* Type_abstract */0;
    }
    var tm;
    try {
      var match$1 = decl.type_manifest;
      tm = match$1 !== void 0 ? unroll_abbrev(id, params, nondep_type_rec(env, mid, match$1)) : void 0;
    }
    catch (exn$1){
      if (exn$1 !== Caml_builtin_exceptions.not_found) {
        throw exn$1;
      }
      if (!is_covariant) {
        throw exn$1;
      }
      tm = void 0;
    }
    Curry._1(TypeHash.clear, nondep_hash);
    Curry._1(TypeHash.clear, nondep_variants);
    var priv = tm !== void 0 && has_constr_row(tm) ? /* Private */0 : decl.type_private;
    return {
            type_params: params,
            type_arity: decl.type_arity,
            type_kind: tk,
            type_private: priv,
            type_manifest: tm,
            type_variance: decl.type_variance,
            type_newtype_level: void 0,
            type_loc: decl.type_loc,
            type_attributes: decl.type_attributes
          };
  }
  catch (exn$2){
    if (exn$2 !== Caml_builtin_exceptions.not_found) {
      throw exn$2;
    }
    Curry._1(TypeHash.clear, nondep_hash);
    Curry._1(TypeHash.clear, nondep_variants);
    throw Caml_builtin_exceptions.not_found;
  }
}

function nondep_extension_constructor(env, mid, ext) {
  try {
    var match;
    if (isfree(mid, ext.ext_type_path)) {
      var ty = newty2(100000000, /* Tconstr */Block.__(3, [
              ext.ext_type_path,
              ext.ext_type_params,
              {
                contents: /* Mnil */0
              }
            ]));
      var ty$prime = nondep_type_rec(env, mid, ty);
      var match$1 = repr(ty$prime).desc;
      if (typeof match$1 === "number") {
        throw Caml_builtin_exceptions.not_found;
      }
      if (match$1.tag !== /* Tconstr */3) {
        throw Caml_builtin_exceptions.not_found;
      }
      match = /* tuple */[
        match$1[0],
        match$1[1]
      ];
    } else {
      var type_params = List.map((function (param) {
              return nondep_type_rec(env, mid, param);
            }), ext.ext_type_params);
      match = /* tuple */[
        ext.ext_type_path,
        type_params
      ];
    }
    var args = List.map((function (param) {
            return nondep_type_rec(env, mid, param);
          }), ext.ext_args);
    var ret_type = may_map((function (param) {
            return nondep_type_rec(env, mid, param);
          }), ext.ext_ret_type);
    Curry._1(TypeHash.clear, nondep_hash);
    Curry._1(TypeHash.clear, nondep_variants);
    return {
            ext_type_path: match[0],
            ext_type_params: match[1],
            ext_args: args,
            ext_ret_type: ret_type,
            ext_private: ext.ext_private,
            ext_loc: ext.ext_loc,
            ext_attributes: ext.ext_attributes
          };
  }
  catch (exn){
    if (exn !== Caml_builtin_exceptions.not_found) {
      throw exn;
    }
    Curry._1(TypeHash.clear, nondep_hash);
    Curry._1(TypeHash.clear, nondep_variants);
    throw Caml_builtin_exceptions.not_found;
  }
}

function nondep_class_signature(env, id, sign) {
  return {
          csig_self: nondep_type_rec(env, id, sign.csig_self),
          csig_vars: map((function (param) {
                  return /* tuple */[
                          param[0],
                          param[1],
                          nondep_type_rec(env, id, param[2])
                        ];
                }), sign.csig_vars),
          csig_concr: sign.csig_concr,
          csig_inher: List.map((function (param) {
                  return /* tuple */[
                          param[0],
                          List.map((function (param) {
                                  return nondep_type_rec(env, id, param);
                                }), param[1])
                        ];
                }), sign.csig_inher)
        };
}

function nondep_class_type(env, id, _param) {
  while(true) {
    var param = _param;
    switch (param.tag | 0) {
      case /* Cty_constr */0 :
          var cty = param[2];
          var p = param[0];
          if (!isfree(id, p)) {
            return /* Cty_constr */Block.__(0, [
                      p,
                      List.map((function (param) {
                              return nondep_type_rec(env, id, param);
                            }), param[1]),
                      nondep_class_type(env, id, cty)
                    ]);
          }
          _param = cty;
          continue ;
      case /* Cty_signature */1 :
          return /* Cty_signature */Block.__(1, [nondep_class_signature(env, id, param[0])]);
      case /* Cty_arrow */2 :
          return /* Cty_arrow */Block.__(2, [
                    param[0],
                    nondep_type_rec(env, id, param[1]),
                    nondep_class_type(env, id, param[2])
                  ]);
      
    }
  };
}

function nondep_class_declaration(env, id, decl) {
  if (isfree(id, decl.cty_path)) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "ctype.ml",
            4449,
            2
          ]
        ];
  }
  var match = decl.cty_new;
  var decl$1 = {
    cty_params: List.map((function (param) {
            return nondep_type_rec(env, id, param);
          }), decl.cty_params),
    cty_type: nondep_class_type(env, id, decl.cty_type),
    cty_path: decl.cty_path,
    cty_new: match !== void 0 ? nondep_type_rec(env, id, match) : void 0,
    cty_variance: decl.cty_variance,
    cty_loc: decl.cty_loc,
    cty_attributes: decl.cty_attributes
  };
  Curry._1(TypeHash.clear, nondep_hash);
  Curry._1(TypeHash.clear, nondep_variants);
  return decl$1;
}

function nondep_cltype_declaration(env, id, decl) {
  if (isfree(id, decl.clty_path)) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "ctype.ml",
            4468,
            2
          ]
        ];
  }
  var decl_clty_params = List.map((function (param) {
          return nondep_type_rec(env, id, param);
        }), decl.clty_params);
  var decl_clty_type = nondep_class_type(env, id, decl.clty_type);
  var decl_clty_path = decl.clty_path;
  var decl_clty_variance = decl.clty_variance;
  var decl_clty_loc = decl.clty_loc;
  var decl_clty_attributes = decl.clty_attributes;
  var decl$1 = {
    clty_params: decl_clty_params,
    clty_type: decl_clty_type,
    clty_path: decl_clty_path,
    clty_variance: decl_clty_variance,
    clty_loc: decl_clty_loc,
    clty_attributes: decl_clty_attributes
  };
  Curry._1(TypeHash.clear, nondep_hash);
  Curry._1(TypeHash.clear, nondep_variants);
  return decl$1;
}

function collapse_conj(env, visited, ty) {
  var ty$1 = repr(ty);
  if (List.memq(ty$1, visited)) {
    return ;
  }
  var visited$1 = /* :: */[
    ty$1,
    visited
  ];
  var match = ty$1.desc;
  if (typeof match === "number") {
    return iter_type_expr((function (param) {
                  return collapse_conj(env, visited$1, param);
                }), ty$1);
  }
  if (match.tag !== /* Tvariant */8) {
    return iter_type_expr((function (param) {
                  return collapse_conj(env, visited$1, param);
                }), ty$1);
  }
  var row = row_repr_aux(/* [] */0, match[0]);
  List.iter((function (param) {
          var match = row_field_repr_aux(/* [] */0, param[1]);
          if (typeof match === "number") {
            return ;
          }
          if (!match.tag) {
            return ;
          }
          var match$1 = match[1];
          if (!match$1) {
            return ;
          }
          var tl = match$1[1];
          if (!tl) {
            return ;
          }
          var t1 = match$1[0];
          List.iter((function (param) {
                  return unify$2(env, t1, param);
                }), tl);
          return set_row_field(match[3], /* Reither */Block.__(1, [
                        match[0],
                        /* :: */[
                          t1,
                          /* [] */0
                        ],
                        match[2],
                        {
                          contents: void 0
                        }
                      ]));
        }), row.row_fields);
  return iter_row((function (param) {
                return collapse_conj(env, visited$1, param);
              }), row);
}

function collapse_conj_params(env, params) {
  return List.iter((function (param) {
                return collapse_conj(env, /* [] */0, param);
              }), params);
}

var out_ident = {
  contents: Format.pp_print_string
};

function print_ident(ppf, param) {
  switch (param.tag | 0) {
    case /* Oide_apply */0 :
        return Curry._4(Format.fprintf(ppf, /* Format */[
                        /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                /* "(" */40,
                                /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                        /* ")" */41,
                                        /* End_of_format */0
                                      ])])
                              ])]),
                        "%a(%a)"
                      ]), print_ident, param[0], print_ident, param[1]);
    case /* Oide_dot */1 :
        print_ident(ppf, param[0]);
        Format.pp_print_char(ppf, /* "." */46);
        return Curry._2(out_ident.contents, ppf, param[1]);
    case /* Oide_ident */2 :
        return Curry._2(out_ident.contents, ppf, param[0]);
    
  }
}

function parenthesized_ident(name) {
  if (List.mem(name, /* :: */[
          "or",
          /* :: */[
            "mod",
            /* :: */[
              "land",
              /* :: */[
                "lor",
                /* :: */[
                  "lxor",
                  /* :: */[
                    "lsl",
                    /* :: */[
                      "lsr",
                      /* :: */[
                        "asr",
                        /* [] */0
                      ]
                    ]
                  ]
                ]
              ]
            ]
          ]
        ])) {
    return true;
  }
  var match = Caml_string.get(name, 0);
  if (match >= 97) {
    if (match >= 223) {
      return match === 247;
    } else {
      return match >= 123;
    }
  } else if (match >= 91) {
    return match !== 95;
  } else {
    return match < 65;
  }
}

function value_ident(ppf, name) {
  if (parenthesized_ident(name)) {
    return Curry._1(Format.fprintf(ppf, /* Format */[
                    /* String_literal */Block.__(11, [
                        "( ",
                        /* String */Block.__(2, [
                            /* No_padding */0,
                            /* String_literal */Block.__(11, [
                                " )",
                                /* End_of_format */0
                              ])
                          ])
                      ]),
                    "( %s )"
                  ]), name);
  } else {
    return Format.pp_print_string(ppf, name);
  }
}

function print_list(pr, sep, ppf, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return ;
    }
    var l = param[1];
    var a = param[0];
    if (!l) {
      return Curry._2(pr, ppf, a);
    }
    Curry._2(pr, ppf, a);
    Curry._1(sep, ppf);
    _param = l;
    continue ;
  };
}

function pr_present(param, param$1) {
  return print_list((function (ppf, s) {
                return Curry._1(Format.fprintf(ppf, /* Format */[
                                /* Char_literal */Block.__(12, [
                                    /* "`" */96,
                                    /* String */Block.__(2, [
                                        /* No_padding */0,
                                        /* End_of_format */0
                                      ])
                                  ]),
                                "`%s"
                              ]), s);
              }), (function (ppf) {
                return Format.fprintf(ppf, /* Format */[
                            /* Formatting_lit */Block.__(17, [
                                /* Break */Block.__(0, [
                                    "@ ",
                                    1,
                                    0
                                  ]),
                                /* End_of_format */0
                              ]),
                            "@ "
                          ]);
              }), param, param$1);
}

function pr_vars(param, param$1) {
  return print_list((function (ppf, s) {
                return Curry._1(Format.fprintf(ppf, /* Format */[
                                /* Char_literal */Block.__(12, [
                                    /* "'" */39,
                                    /* String */Block.__(2, [
                                        /* No_padding */0,
                                        /* End_of_format */0
                                      ])
                                  ]),
                                "'%s"
                              ]), s);
              }), (function (ppf) {
                return Format.fprintf(ppf, /* Format */[
                            /* Formatting_lit */Block.__(17, [
                                /* Break */Block.__(0, [
                                    "@ ",
                                    1,
                                    0
                                  ]),
                                /* End_of_format */0
                              ]),
                            "@ "
                          ]);
              }), param, param$1);
}

function print_out_type(ppf, ty) {
  if (typeof ty === "number") {
    return print_out_type_1(ppf, ty);
  }
  switch (ty.tag | 0) {
    case /* Otyp_alias */0 :
        return Curry._3(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* End_of_format */0,
                                  ""
                                ]]),
                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                    /* Break */Block.__(0, [
                                        "@ ",
                                        1,
                                        0
                                      ]),
                                    /* String_literal */Block.__(11, [
                                        "as '",
                                        /* String */Block.__(2, [
                                            /* No_padding */0,
                                            /* Formatting_lit */Block.__(17, [
                                                /* Close_box */0,
                                                /* End_of_format */0
                                              ])
                                          ])
                                      ])
                                  ])])
                          ]),
                        "@[%a@ as '%s@]"
                      ]), print_out_type, ty[0], ty[1]);
    case /* Otyp_poly */12 :
        return Curry._4(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<hov 2>",
                                      /* End_of_format */0
                                    ]),
                                  "<hov 2>"
                                ]]),
                            /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                    /* "." */46,
                                    /* Formatting_lit */Block.__(17, [
                                        /* Break */Block.__(0, [
                                            "@ ",
                                            1,
                                            0
                                          ]),
                                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                /* Close_box */0,
                                                /* End_of_format */0
                                              ])])
                                      ])
                                  ])])
                          ]),
                        "@[<hov 2>%a.@ %a@]"
                      ]), pr_vars, ty[0], print_out_type, ty[1]);
    default:
      return print_out_type_1(ppf, ty);
  }
}

function print_out_type_1(ppf, ty) {
  if (typeof ty === "number") {
    return print_out_type_2(ppf, ty);
  }
  if (ty.tag !== /* Otyp_arrow */1) {
    return print_out_type_2(ppf, ty);
  }
  var lab = ty[0];
  Format.pp_open_box(ppf, 0);
  if (lab !== "") {
    Format.pp_print_string(ppf, lab);
    Format.pp_print_char(ppf, /* ":" */58);
  }
  print_out_type_2(ppf, ty[1]);
  Format.pp_print_string(ppf, " ->");
  Format.pp_print_space(ppf, void 0);
  print_out_type_1(ppf, ty[2]);
  return Format.pp_close_box(ppf, void 0);
}

function print_out_type_2(ppf, ty) {
  if (typeof ty === "number" || ty.tag !== /* Otyp_tuple */9) {
    return print_simple_out_type(ppf, ty);
  } else {
    return Curry._2(Format.fprintf(ppf, /* Format */[
                    /* Formatting_gen */Block.__(18, [
                        /* Open_box */Block.__(1, [/* Format */[
                              /* String_literal */Block.__(11, [
                                  "<0>",
                                  /* End_of_format */0
                                ]),
                              "<0>"
                            ]]),
                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                /* Close_box */0,
                                /* End_of_format */0
                              ])])
                      ]),
                    "@[<0>%a@]"
                  ]), (function (param, param$1) {
                  return print_typlist(print_simple_out_type, " *", param, param$1);
                }), ty[0]);
  }
}

function print_simple_out_type(ppf, ty) {
  if (typeof ty === "number") {
    return ;
  }
  switch (ty.tag | 0) {
    case /* Otyp_class */2 :
        return Curry._5(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* End_of_format */0,
                                  ""
                                ]]),
                            /* Alpha */Block.__(15, [/* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* Char_literal */Block.__(12, [
                                        /* "#" */35,
                                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                /* Close_box */0,
                                                /* End_of_format */0
                                              ])])
                                      ])
                                  ])])
                          ]),
                        "@[%a%s#%a@]"
                      ]), print_typargs, ty[2], ty[0] ? "_" : "", print_ident, ty[1]);
    case /* Otyp_constr */3 :
        var id = ty[0];
        var exit = 0;
        switch (id.tag | 0) {
          case /* Oide_dot */1 :
              var match = id[0];
              var exit$1 = 0;
              switch (match.tag | 0) {
                case /* Oide_apply */0 :
                    exit = 2;
                    break;
                case /* Oide_dot */1 :
                    var match$1 = match[0];
                    switch (match$1.tag | 0) {
                      case /* Oide_apply */0 :
                      case /* Oide_dot */1 :
                          exit = 2;
                          break;
                      case /* Oide_ident */2 :
                          if (match$1[0] === "Js" && match[1] === "Internal") {
                            exit$1 = 3;
                          } else {
                            exit = 2;
                          }
                          break;
                      
                    }
                    break;
                case /* Oide_ident */2 :
                    if (match[0] === "Js_internal") {
                      exit$1 = 3;
                    } else {
                      exit = 2;
                    }
                    break;
                
              }
              if (exit$1 === 3) {
                var name = id[1];
                var exit$2 = 0;
                switch (name) {
                  case "fn" :
                  case "meth" :
                      exit$2 = 4;
                      break;
                  case "meth_callback" :
                      var tyl = ty[1];
                      if (tyl) {
                        var match$2 = tyl[0];
                        if (typeof match$2 === "number" || match$2.tag !== /* Otyp_variant */11) {
                          exit = 2;
                        } else {
                          var match$3 = match$2[1];
                          if (match$3.tag) {
                            exit = 2;
                          } else {
                            var match$4 = match$3[0];
                            if (match$4 && !match$4[1]) {
                              var match$5 = tyl[1];
                              if (match$5 && !match$5[1]) {
                                var match$6 = match$4[0];
                                var variant = match$6[0];
                                var make = function (tys, result) {
                                  if (!tys) {
                                    throw Caml_builtin_exceptions.not_found;
                                  }
                                  var single = tys[0];
                                  if (typeof single !== "number" && single.tag === /* Otyp_tuple */9) {
                                    if (tys[1]) {
                                      throw Caml_builtin_exceptions.not_found;
                                    }
                                    if (variant === "Arity_1") {
                                      return /* Otyp_arrow */Block.__(1, [
                                                "",
                                                single,
                                                result
                                              ]);
                                    } else {
                                      return List.fold_right((function (x, acc) {
                                                    return /* Otyp_arrow */Block.__(1, [
                                                              "",
                                                              x,
                                                              acc
                                                            ]);
                                                  }), single[0], result);
                                    }
                                  }
                                  if (tys[1]) {
                                    throw Caml_builtin_exceptions.not_found;
                                  }
                                  return /* Otyp_arrow */Block.__(1, [
                                            "",
                                            single,
                                            result
                                          ]);
                                };
                                var exit$3 = 0;
                                var res;
                                try {
                                  res = make(match$6[2], match$5[0]);
                                  exit$3 = 5;
                                }
                                catch (exn){
                                  Format.pp_open_box(ppf, 0);
                                  print_typargs(ppf, tyl);
                                  print_ident(ppf, id);
                                  return Format.pp_close_box(ppf, void 0);
                                }
                                if (exit$3 === 5) {
                                  return Curry._2(Format.fprintf(ppf, /* Format */[
                                                  /* Formatting_gen */Block.__(18, [
                                                      /* Open_box */Block.__(1, [/* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "<0>",
                                                                /* End_of_format */0
                                                              ]),
                                                            "<0>"
                                                          ]]),
                                                      /* Char_literal */Block.__(12, [
                                                          /* "(" */40,
                                                          /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                  /* Break */Block.__(0, [
                                                                      "@ ",
                                                                      1,
                                                                      0
                                                                    ]),
                                                                  /* Char_literal */Block.__(12, [
                                                                      /* "[" */91,
                                                                      /* Formatting_lit */Block.__(17, [
                                                                          /* Scan_indic */Block.__(2, [/* "b" */98]),
                                                                          /* String_literal */Block.__(11, [
                                                                              "s.this])",
                                                                              /* Formatting_lit */Block.__(17, [
                                                                                  /* Close_box */0,
                                                                                  /* End_of_format */0
                                                                                ])
                                                                            ])
                                                                        ])
                                                                    ])
                                                                ])])
                                                        ])
                                                    ]),
                                                  "@[<0>(%a@ [@bs.this])@]"
                                                ]), print_out_type_1, res);
                                }
                                
                              } else {
                                exit = 2;
                              }
                            } else {
                              exit = 2;
                            }
                          }
                        }
                      } else {
                        exit = 2;
                      }
                      break;
                  default:
                    exit = 2;
                }
                if (exit$2 === 4) {
                  var tyl$1 = ty[1];
                  if (tyl$1) {
                    var match$7 = tyl$1[0];
                    if (typeof match$7 === "number" || match$7.tag !== /* Otyp_variant */11) {
                      exit = 2;
                    } else {
                      var match$8 = match$7[1];
                      if (match$8.tag) {
                        exit = 2;
                      } else {
                        var match$9 = match$8[0];
                        if (match$9 && !match$9[1]) {
                          var match$10 = tyl$1[1];
                          if (match$10 && !match$10[1]) {
                            var match$11 = match$9[0];
                            var variant$1 = match$11[0];
                            var make$1 = function (tys, result) {
                              if (tys === /* [] */0) {
                                return /* Otyp_arrow */Block.__(1, [
                                          "",
                                          /* Otyp_constr */Block.__(3, [
                                              /* Oide_ident */Block.__(2, ["unit"]),
                                              /* [] */0
                                            ]),
                                          result
                                        ]);
                              }
                              if (!tys) {
                                throw Caml_builtin_exceptions.not_found;
                              }
                              var single = tys[0];
                              if (typeof single !== "number" && single.tag === /* Otyp_tuple */9) {
                                if (tys[1]) {
                                  throw Caml_builtin_exceptions.not_found;
                                }
                                if (variant$1 === "Arity_1") {
                                  return /* Otyp_arrow */Block.__(1, [
                                            "",
                                            single,
                                            result
                                          ]);
                                } else {
                                  return List.fold_right((function (x, acc) {
                                                return /* Otyp_arrow */Block.__(1, [
                                                          "",
                                                          x,
                                                          acc
                                                        ]);
                                              }), single[0], result);
                                }
                              }
                              if (tys[1]) {
                                throw Caml_builtin_exceptions.not_found;
                              }
                              return /* Otyp_arrow */Block.__(1, [
                                        "",
                                        single,
                                        result
                                      ]);
                            };
                            var exit$4 = 0;
                            var res$1;
                            try {
                              res$1 = make$1(match$11[2], match$10[0]);
                              exit$4 = 5;
                            }
                            catch (exn$1){
                              Format.pp_open_box(ppf, 0);
                              print_typargs(ppf, tyl$1);
                              print_ident(ppf, id);
                              return Format.pp_close_box(ppf, void 0);
                            }
                            if (exit$4 === 5) {
                              switch (name) {
                                case "fn" :
                                    return Curry._2(Format.fprintf(ppf, /* Format */[
                                                    /* Formatting_gen */Block.__(18, [
                                                        /* Open_box */Block.__(1, [/* Format */[
                                                              /* String_literal */Block.__(11, [
                                                                  "<0>",
                                                                  /* End_of_format */0
                                                                ]),
                                                              "<0>"
                                                            ]]),
                                                        /* Char_literal */Block.__(12, [
                                                            /* "(" */40,
                                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                    /* Break */Block.__(0, [
                                                                        "@ ",
                                                                        1,
                                                                        0
                                                                      ]),
                                                                    /* Char_literal */Block.__(12, [
                                                                        /* "[" */91,
                                                                        /* Formatting_lit */Block.__(17, [
                                                                            /* Scan_indic */Block.__(2, [/* "b" */98]),
                                                                            /* String_literal */Block.__(11, [
                                                                                "s])",
                                                                                /* Formatting_lit */Block.__(17, [
                                                                                    /* Close_box */0,
                                                                                    /* End_of_format */0
                                                                                  ])
                                                                              ])
                                                                          ])
                                                                      ])
                                                                  ])])
                                                          ])
                                                      ]),
                                                    "@[<0>(%a@ [@bs])@]"
                                                  ]), print_out_type_1, res$1);
                                case "meth" :
                                    return Curry._2(Format.fprintf(ppf, /* Format */[
                                                    /* Formatting_gen */Block.__(18, [
                                                        /* Open_box */Block.__(1, [/* Format */[
                                                              /* String_literal */Block.__(11, [
                                                                  "<0>",
                                                                  /* End_of_format */0
                                                                ]),
                                                              "<0>"
                                                            ]]),
                                                        /* Char_literal */Block.__(12, [
                                                            /* "(" */40,
                                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                    /* Break */Block.__(0, [
                                                                        "@ ",
                                                                        1,
                                                                        0
                                                                      ]),
                                                                    /* Char_literal */Block.__(12, [
                                                                        /* "[" */91,
                                                                        /* Formatting_lit */Block.__(17, [
                                                                            /* Scan_indic */Block.__(2, [/* "b" */98]),
                                                                            /* String_literal */Block.__(11, [
                                                                                "s.meth])",
                                                                                /* Formatting_lit */Block.__(17, [
                                                                                    /* Close_box */0,
                                                                                    /* End_of_format */0
                                                                                  ])
                                                                              ])
                                                                          ])
                                                                      ])
                                                                  ])])
                                                          ])
                                                      ]),
                                                    "@[<0>(%a@ [@bs.meth])@]"
                                                  ]), print_out_type_1, res$1);
                                default:
                                  throw [
                                        Caml_builtin_exceptions.assert_failure,
                                        /* tuple */[
                                          "oprint.ml",
                                          229,
                                          17
                                        ]
                                      ];
                              }
                            }
                            
                          } else {
                            exit = 2;
                          }
                        } else {
                          exit = 2;
                        }
                      }
                    }
                  } else {
                    exit = 2;
                  }
                }
                
              }
              break;
          case /* Oide_apply */0 :
          case /* Oide_ident */2 :
              exit = 2;
              break;
          
        }
        if (exit === 2) {
          Format.pp_open_box(ppf, 0);
          print_typargs(ppf, ty[1]);
          print_ident(ppf, id);
          return Format.pp_close_box(ppf, void 0);
        }
        break;
    case /* Otyp_object */5 :
        var rest = ty[1];
        return Curry._2(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<2>",
                                      /* End_of_format */0
                                    ]),
                                  "<2>"
                                ]]),
                            /* String_literal */Block.__(11, [
                                "< ",
                                /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                        " >",
                                        /* Formatting_lit */Block.__(17, [
                                            /* Close_box */0,
                                            /* End_of_format */0
                                          ])
                                      ])])
                              ])
                          ]),
                        "@[<2>< %a >@]"
                      ]), (function (param, param$1) {
                      return print_fields(rest, param, param$1);
                    }), ty[0]);
    case /* Otyp_stuff */7 :
        return Format.pp_print_string(ppf, ty[0]);
    case /* Otyp_var */10 :
        return Curry._2(Format.fprintf(ppf, /* Format */[
                        /* Char_literal */Block.__(12, [
                            /* "'" */39,
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* End_of_format */0
                                  ])
                              ])
                          ]),
                        "'%s%s"
                      ]), ty[0] ? "_" : "", ty[1]);
    case /* Otyp_variant */11 :
        var tags = ty[3];
        var print_present = function (ppf, param) {
          if (param === void 0) {
            return ;
          }
          var l = param;
          if (l) {
            return Curry._2(Format.fprintf(ppf, /* Format */[
                            /* Formatting_lit */Block.__(17, [
                                /* Break */Block.__(0, [
                                    "@;<1 -2>",
                                    1,
                                    -2
                                  ]),
                                /* String_literal */Block.__(11, [
                                    "> ",
                                    /* Formatting_gen */Block.__(18, [
                                        /* Open_box */Block.__(1, [/* Format */[
                                              /* String_literal */Block.__(11, [
                                                  "<hov>",
                                                  /* End_of_format */0
                                                ]),
                                              "<hov>"
                                            ]]),
                                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                /* Close_box */0,
                                                /* End_of_format */0
                                              ])])
                                      ])
                                  ])
                              ]),
                            "@;<1 -2>> @[<hov>%a@]"
                          ]), pr_present, l);
          }
          
        };
        var print_fields$1 = function (ppf, param) {
          if (param.tag) {
            return Curry._4(Format.fprintf(ppf, /* Format */[
                            /* Formatting_gen */Block.__(18, [
                                /* Open_box */Block.__(1, [/* Format */[
                                      /* End_of_format */0,
                                      ""
                                    ]]),
                                /* Alpha */Block.__(15, [/* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                            /* Close_box */0,
                                            /* End_of_format */0
                                          ])])])
                              ]),
                            "@[%a%a@]"
                          ]), print_typargs, param[1], print_ident, param[0]);
          } else {
            return print_list(print_row_field, (function (ppf) {
                          return Format.fprintf(ppf, /* Format */[
                                      /* Formatting_lit */Block.__(17, [
                                          /* Break */Block.__(0, [
                                              "@;<1 -2>",
                                              1,
                                              -2
                                            ]),
                                          /* String_literal */Block.__(11, [
                                              "| ",
                                              /* End_of_format */0
                                            ])
                                        ]),
                                      "@;<1 -2>| "
                                    ]);
                        }), ppf, param[0]);
          }
        };
        return Curry._6(Format.fprintf(ppf, /* Format */[
                        /* String */Block.__(2, [
                            /* No_padding */0,
                            /* Char_literal */Block.__(12, [
                                /* "[" */91,
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* Formatting_gen */Block.__(18, [
                                        /* Open_box */Block.__(1, [/* Format */[
                                              /* String_literal */Block.__(11, [
                                                  "<hv>",
                                                  /* End_of_format */0
                                                ]),
                                              "<hv>"
                                            ]]),
                                        /* Formatting_gen */Block.__(18, [
                                            /* Open_box */Block.__(1, [/* Format */[
                                                  /* String_literal */Block.__(11, [
                                                      "<hv>",
                                                      /* End_of_format */0
                                                    ]),
                                                  "<hv>"
                                                ]]),
                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                    /* Close_box */0,
                                                    /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                                            " ]",
                                                            /* Formatting_lit */Block.__(17, [
                                                                /* Close_box */0,
                                                                /* End_of_format */0
                                                              ])
                                                          ])])
                                                  ])])
                                          ])
                                      ])
                                  ])
                              ])
                          ]),
                        "%s[%s@[<hv>@[<hv>%a@]%a ]@]"
                      ]), ty[0] ? "_" : "", ty[2] ? (
                      tags === void 0 ? " " : "< "
                    ) : (
                      tags === void 0 ? "> " : "? "
                    ), print_fields$1, ty[1], print_present, tags);
    case /* Otyp_alias */0 :
    case /* Otyp_arrow */1 :
    case /* Otyp_tuple */9 :
    case /* Otyp_poly */12 :
        break;
    case /* Otyp_module */13 :
        Curry._1(Format.fprintf(ppf, /* Format */[
                  /* Formatting_gen */Block.__(18, [
                      /* Open_box */Block.__(1, [/* Format */[
                            /* String_literal */Block.__(11, [
                                "<1>",
                                /* End_of_format */0
                              ]),
                            "<1>"
                          ]]),
                      /* String_literal */Block.__(11, [
                          "(module ",
                          /* String */Block.__(2, [
                              /* No_padding */0,
                              /* End_of_format */0
                            ])
                        ])
                    ]),
                  "@[<1>(module %s"
                ]), ty[0]);
        var first = {
          contents: true
        };
        List.iter2((function (s, t) {
                var sep = first.contents ? (first.contents = false, "with") : "and";
                return Curry._4(Format.fprintf(ppf, /* Format */[
                                /* Char_literal */Block.__(12, [
                                    /* " " */32,
                                    /* String */Block.__(2, [
                                        /* No_padding */0,
                                        /* String_literal */Block.__(11, [
                                            " type ",
                                            /* String */Block.__(2, [
                                                /* No_padding */0,
                                                /* String_literal */Block.__(11, [
                                                    " = ",
                                                    /* Alpha */Block.__(15, [/* End_of_format */0])
                                                  ])
                                              ])
                                          ])
                                      ])
                                  ]),
                                " %s type %s = %a"
                              ]), sep, s, print_out_type, t);
              }), ty[1], ty[2]);
        return Format.fprintf(ppf, /* Format */[
                    /* Char_literal */Block.__(12, [
                        /* ")" */41,
                        /* Formatting_lit */Block.__(17, [
                            /* Close_box */0,
                            /* End_of_format */0
                          ])
                      ]),
                    ")@]"
                  ]);
    default:
      return ;
  }
  Format.pp_open_box(ppf, 1);
  Format.pp_print_char(ppf, /* "(" */40);
  print_out_type(ppf, ty);
  Format.pp_print_char(ppf, /* ")" */41);
  return Format.pp_close_box(ppf, void 0);
}

function print_fields(rest, ppf, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      if (rest !== void 0) {
        return Curry._1(Format.fprintf(ppf, /* Format */[
                        /* String */Block.__(2, [
                            /* No_padding */0,
                            /* String_literal */Block.__(11, [
                                "..",
                                /* End_of_format */0
                              ])
                          ]),
                        "%s.."
                      ]), rest ? "_" : "");
      } else {
        return ;
      }
    }
    var l = param[1];
    var match = param[0];
    var t = match[1];
    var s = match[0];
    if (l) {
      return Curry._5(Format.fprintf(ppf, /* Format */[
                      /* String */Block.__(2, [
                          /* No_padding */0,
                          /* String_literal */Block.__(11, [
                              " : ",
                              /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                      /* ";" */59,
                                      /* Formatting_lit */Block.__(17, [
                                          /* Break */Block.__(0, [
                                              "@ ",
                                              1,
                                              0
                                            ]),
                                          /* Alpha */Block.__(15, [/* End_of_format */0])
                                        ])
                                    ])])
                            ])
                        ]),
                      "%s : %a;@ %a"
                    ]), s, print_out_type, t, (function (param, param$1) {
                    return print_fields(rest, param, param$1);
                  }), l);
    }
    Curry._3(Format.fprintf(ppf, /* Format */[
              /* String */Block.__(2, [
                  /* No_padding */0,
                  /* String_literal */Block.__(11, [
                      " : ",
                      /* Alpha */Block.__(15, [/* End_of_format */0])
                    ])
                ]),
              "%s : %a"
            ]), s, print_out_type, t);
    if (rest !== void 0) {
      Format.fprintf(ppf, /* Format */[
            /* Char_literal */Block.__(12, [
                /* ";" */59,
                /* Formatting_lit */Block.__(17, [
                    /* Break */Block.__(0, [
                        "@ ",
                        1,
                        0
                      ]),
                    /* End_of_format */0
                  ])
              ]),
            ";@ "
          ]);
    }
    _param = /* [] */0;
    continue ;
  };
}

function print_row_field(ppf, param) {
  var tyl = param[2];
  var opt_amp = param[1];
  var pr_of = function (ppf) {
    if (opt_amp) {
      return Format.fprintf(ppf, /* Format */[
                  /* String_literal */Block.__(11, [
                      " of",
                      /* Formatting_lit */Block.__(17, [
                          /* Break */Block.__(0, [
                              "@ ",
                              1,
                              0
                            ]),
                          /* Char_literal */Block.__(12, [
                              /* "&" */38,
                              /* Formatting_lit */Block.__(17, [
                                  /* Break */Block.__(0, [
                                      "@ ",
                                      1,
                                      0
                                    ]),
                                  /* End_of_format */0
                                ])
                            ])
                        ])
                    ]),
                  " of@ &@ "
                ]);
    } else if (tyl !== /* [] */0) {
      return Format.fprintf(ppf, /* Format */[
                  /* String_literal */Block.__(11, [
                      " of",
                      /* Formatting_lit */Block.__(17, [
                          /* Break */Block.__(0, [
                              "@ ",
                              1,
                              0
                            ]),
                          /* End_of_format */0
                        ])
                    ]),
                  " of@ "
                ]);
    } else {
      return Format.fprintf(ppf, /* Format */[
                  /* End_of_format */0,
                  ""
                ]);
    }
  };
  return Curry._4(Format.fprintf(ppf, /* Format */[
                  /* Formatting_gen */Block.__(18, [
                      /* Open_box */Block.__(1, [/* Format */[
                            /* String_literal */Block.__(11, [
                                "<hv 2>",
                                /* End_of_format */0
                              ]),
                            "<hv 2>"
                          ]]),
                      /* Char_literal */Block.__(12, [
                          /* "`" */96,
                          /* String */Block.__(2, [
                              /* No_padding */0,
                              /* Theta */Block.__(16, [/* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                          /* Close_box */0,
                                          /* End_of_format */0
                                        ])])])
                            ])
                        ])
                    ]),
                  "@[<hv 2>`%s%t%a@]"
                ]), param[0], pr_of, (function (param, param$1) {
                return print_typlist(print_out_type, " &", param, param$1);
              }), tyl);
}

function print_typlist(print_elem, sep, ppf, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return ;
    }
    var tyl = param[1];
    var ty = param[0];
    if (!tyl) {
      return Curry._2(print_elem, ppf, ty);
    }
    Curry._2(print_elem, ppf, ty);
    Format.pp_print_string(ppf, sep);
    Format.pp_print_space(ppf, void 0);
    _param = tyl;
    continue ;
  };
}

function print_typargs(ppf, tyl) {
  if (tyl) {
    if (tyl[1]) {
      Format.pp_open_box(ppf, 1);
      Format.pp_print_char(ppf, /* "(" */40);
      print_typlist(print_out_type, ",", ppf, tyl);
      Format.pp_print_char(ppf, /* ")" */41);
      Format.pp_close_box(ppf, void 0);
      return Format.pp_print_space(ppf, void 0);
    } else {
      print_simple_out_type(ppf, tyl[0]);
      return Format.pp_print_space(ppf, void 0);
    }
  }
  
}

var out_type = {
  contents: print_out_type
};

function type_parameter(ppf, param) {
  var match = param[1];
  var ty = param[0];
  return Curry._2(Format.fprintf(ppf, /* Format */[
                  /* String */Block.__(2, [
                      /* No_padding */0,
                      /* String */Block.__(2, [
                          /* No_padding */0,
                          /* End_of_format */0
                        ])
                    ]),
                  "%s%s"
                ]), match[1] ? (
                match[0] ? "" : "-"
              ) : "+", ty === "_" ? ty : "'" + ty);
}

function print_out_class_params(ppf, tyl) {
  if (tyl) {
    return Curry._2(Format.fprintf(ppf, /* Format */[
                    /* Formatting_gen */Block.__(18, [
                        /* Open_box */Block.__(1, [/* Format */[
                              /* String_literal */Block.__(11, [
                                  "<1>",
                                  /* End_of_format */0
                                ]),
                              "<1>"
                            ]]),
                        /* Char_literal */Block.__(12, [
                            /* "[" */91,
                            /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                    /* "]" */93,
                                    /* Formatting_lit */Block.__(17, [
                                        /* Close_box */0,
                                        /* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@ ",
                                                1,
                                                0
                                              ]),
                                            /* End_of_format */0
                                          ])
                                      ])
                                  ])])
                          ])
                      ]),
                    "@[<1>[%a]@]@ "
                  ]), (function (param, param$1) {
                  return print_list(type_parameter, (function (ppf) {
                                return Format.fprintf(ppf, /* Format */[
                                            /* String_literal */Block.__(11, [
                                                ", ",
                                                /* End_of_format */0
                                              ]),
                                            ", "
                                          ]);
                              }), param, param$1);
                }), tyl);
  }
  
}

function print_out_class_type(ppf, param) {
  switch (param.tag | 0) {
    case /* Octy_constr */0 :
        var pr_tyl = function (ppf, tyl) {
          if (!tyl) {
            return ;
          }
          var partial_arg = out_type.contents;
          return Curry._2(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<1>",
                                        /* End_of_format */0
                                      ]),
                                    "<1>"
                                  ]]),
                              /* Char_literal */Block.__(12, [
                                  /* "[" */91,
                                  /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                          /* "]" */93,
                                          /* Formatting_lit */Block.__(17, [
                                              /* Close_box */0,
                                              /* Formatting_lit */Block.__(17, [
                                                  /* Break */Block.__(0, [
                                                      "@ ",
                                                      1,
                                                      0
                                                    ]),
                                                  /* End_of_format */0
                                                ])
                                            ])
                                        ])])
                                ])
                            ]),
                          "@[<1>[%a]@]@ "
                        ]), (function (param, param$1) {
                        return print_typlist(partial_arg, ",", param, param$1);
                      }), tyl);
        };
        return Curry._4(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* End_of_format */0,
                                  ""
                                ]]),
                            /* Alpha */Block.__(15, [/* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                        /* Close_box */0,
                                        /* End_of_format */0
                                      ])])])
                          ]),
                        "@[%a%a@]"
                      ]), pr_tyl, param[1], print_ident, param[0]);
    case /* Octy_arrow */1 :
        var lab = param[0];
        return Curry._5(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* End_of_format */0,
                                  ""
                                ]]),
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                        " ->",
                                        /* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@ ",
                                                1,
                                                0
                                              ]),
                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                    /* Close_box */0,
                                                    /* End_of_format */0
                                                  ])])
                                          ])
                                      ])])
                              ])
                          ]),
                        "@[%s%a ->@ %a@]"
                      ]), lab !== "" ? lab + ":" : "", print_out_type_2, param[1], print_out_class_type, param[2]);
    case /* Octy_signature */2 :
        var pr_param = function (ppf, param) {
          if (param !== void 0) {
            return Curry._2(Format.fprintf(ppf, /* Format */[
                            /* Formatting_lit */Block.__(17, [
                                /* Break */Block.__(0, [
                                    "@ ",
                                    1,
                                    0
                                  ]),
                                /* Formatting_gen */Block.__(18, [
                                    /* Open_box */Block.__(1, [/* Format */[
                                          /* End_of_format */0,
                                          ""
                                        ]]),
                                    /* Char_literal */Block.__(12, [
                                        /* "(" */40,
                                        /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                /* ")" */41,
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Close_box */0,
                                                    /* End_of_format */0
                                                  ])
                                              ])])
                                      ])
                                  ])
                              ]),
                            "@ @[(%a)@]"
                          ]), out_type.contents, param);
          }
          
        };
        return Curry._4(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<hv 2>",
                                      /* End_of_format */0
                                    ]),
                                  "<hv 2>"
                                ]]),
                            /* Formatting_gen */Block.__(18, [
                                /* Open_box */Block.__(1, [/* Format */[
                                      /* String_literal */Block.__(11, [
                                          "<2>",
                                          /* End_of_format */0
                                        ]),
                                      "<2>"
                                    ]]),
                                /* String_literal */Block.__(11, [
                                    "object",
                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                            /* Close_box */0,
                                            /* Formatting_lit */Block.__(17, [
                                                /* Break */Block.__(0, [
                                                    "@ ",
                                                    1,
                                                    0
                                                  ]),
                                                /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                        /* Break */Block.__(0, [
                                                            "@;<1 -2>",
                                                            1,
                                                            -2
                                                          ]),
                                                        /* String_literal */Block.__(11, [
                                                            "end",
                                                            /* Formatting_lit */Block.__(17, [
                                                                /* Close_box */0,
                                                                /* End_of_format */0
                                                              ])
                                                          ])
                                                      ])])
                                              ])
                                          ])])
                                  ])
                              ])
                          ]),
                        "@[<hv 2>@[<2>object%a@]@ %a@;<1 -2>end@]"
                      ]), pr_param, param[0], (function (param, param$1) {
                      return print_list(print_out_class_sig_item, (function (ppf) {
                                    return Format.fprintf(ppf, /* Format */[
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@ ",
                                                        1,
                                                        0
                                                      ]),
                                                    /* End_of_format */0
                                                  ]),
                                                "@ "
                                              ]);
                                  }), param, param$1);
                    }), param[1]);
    
  }
}

function print_out_class_sig_item(ppf, param) {
  switch (param.tag | 0) {
    case /* Ocsg_constraint */0 :
        return Curry._4(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<2>",
                                      /* End_of_format */0
                                    ]),
                                  "<2>"
                                ]]),
                            /* String_literal */Block.__(11, [
                                "constraint ",
                                /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                        " =",
                                        /* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@ ",
                                                1,
                                                0
                                              ]),
                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                    /* Close_box */0,
                                                    /* End_of_format */0
                                                  ])])
                                          ])
                                      ])])
                              ])
                          ]),
                        "@[<2>constraint %a =@ %a@]"
                      ]), out_type.contents, param[0], out_type.contents, param[1]);
    case /* Ocsg_method */1 :
        return Curry._5(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<2>",
                                      /* End_of_format */0
                                    ]),
                                  "<2>"
                                ]]),
                            /* String_literal */Block.__(11, [
                                "method ",
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* String */Block.__(2, [
                                        /* No_padding */0,
                                        /* String */Block.__(2, [
                                            /* No_padding */0,
                                            /* String_literal */Block.__(11, [
                                                " :",
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@ ",
                                                        1,
                                                        0
                                                      ]),
                                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                            /* Close_box */0,
                                                            /* End_of_format */0
                                                          ])])
                                                  ])
                                              ])
                                          ])
                                      ])
                                  ])
                              ])
                          ]),
                        "@[<2>method %s%s%s :@ %a@]"
                      ]), param[1] ? "private " : "", param[2] ? "virtual " : "", param[0], out_type.contents, param[3]);
    case /* Ocsg_value */2 :
        return Curry._5(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<2>",
                                      /* End_of_format */0
                                    ]),
                                  "<2>"
                                ]]),
                            /* String_literal */Block.__(11, [
                                "val ",
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* String */Block.__(2, [
                                        /* No_padding */0,
                                        /* String */Block.__(2, [
                                            /* No_padding */0,
                                            /* String_literal */Block.__(11, [
                                                " :",
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@ ",
                                                        1,
                                                        0
                                                      ]),
                                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                            /* Close_box */0,
                                                            /* End_of_format */0
                                                          ])])
                                                  ])
                                              ])
                                          ])
                                      ])
                                  ])
                              ])
                          ]),
                        "@[<2>val %s%s%s :@ %a@]"
                      ]), param[1] ? "mutable " : "", param[2] ? "virtual " : "", param[0], out_type.contents, param[3]);
    
  }
}

var out_class_type = {
  contents: print_out_class_type
};

var out_module_type = {
  contents: (function (param) {
      throw [
            Caml_builtin_exceptions.failure,
            "Oprint.out_module_type"
          ];
    })
};

var out_sig_item = {
  contents: (function (param) {
      throw [
            Caml_builtin_exceptions.failure,
            "Oprint.out_sig_item"
          ];
    })
};

var out_signature = {
  contents: (function (param) {
      throw [
            Caml_builtin_exceptions.failure,
            "Oprint.out_signature"
          ];
    })
};

var out_type_extension = {
  contents: (function (param) {
      throw [
            Caml_builtin_exceptions.failure,
            "Oprint.out_type_extension"
          ];
    })
};

function print_out_functor(ppf, m) {
  if (typeof m !== "number" && !m.tag) {
    var match = m[1];
    if (match !== void 0) {
      return Curry._5(Format.fprintf(ppf, /* Format */[
                      /* Char_literal */Block.__(12, [
                          /* "(" */40,
                          /* String */Block.__(2, [
                              /* No_padding */0,
                              /* String_literal */Block.__(11, [
                                  " : ",
                                  /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                          ") ",
                                          /* Alpha */Block.__(15, [/* End_of_format */0])
                                        ])])
                                ])
                            ])
                        ]),
                      "(%s : %a) %a"
                    ]), m[0], print_out_module_type, match, print_out_functor, m[2]);
    } else {
      return Curry._2(Format.fprintf(ppf, /* Format */[
                      /* String_literal */Block.__(11, [
                          "() ",
                          /* Alpha */Block.__(15, [/* End_of_format */0])
                        ]),
                      "() %a"
                    ]), print_out_functor, m[2]);
    }
  }
  return Curry._2(Format.fprintf(ppf, /* Format */[
                  /* String_literal */Block.__(11, [
                      "->",
                      /* Formatting_lit */Block.__(17, [
                          /* Break */Block.__(0, [
                              "@ ",
                              1,
                              0
                            ]),
                          /* Alpha */Block.__(15, [/* End_of_format */0])
                        ])
                    ]),
                  "->@ %a"
                ]), print_out_module_type, m);
}

function print_out_module_type(ppf, t) {
  if (typeof t === "number") {
    return ;
  }
  switch (t.tag | 0) {
    case /* Omty_functor */0 :
        return Curry._2(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<2>",
                                      /* End_of_format */0
                                    ]),
                                  "<2>"
                                ]]),
                            /* String_literal */Block.__(11, [
                                "functor",
                                /* Formatting_lit */Block.__(17, [
                                    /* Break */Block.__(0, [
                                        "@ ",
                                        1,
                                        0
                                      ]),
                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                            /* Close_box */0,
                                            /* End_of_format */0
                                          ])])
                                  ])
                              ])
                          ]),
                        "@[<2>functor@ %a@]"
                      ]), print_out_functor, t);
    case /* Omty_ident */1 :
        return Curry._2(Format.fprintf(ppf, /* Format */[
                        /* Alpha */Block.__(15, [/* End_of_format */0]),
                        "%a"
                      ]), print_ident, t[0]);
    case /* Omty_signature */2 :
        return Curry._2(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<hv 2>",
                                      /* End_of_format */0
                                    ]),
                                  "<hv 2>"
                                ]]),
                            /* String_literal */Block.__(11, [
                                "sig",
                                /* Formatting_lit */Block.__(17, [
                                    /* Break */Block.__(0, [
                                        "@ ",
                                        1,
                                        0
                                      ]),
                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@;<1 -2>",
                                                1,
                                                -2
                                              ]),
                                            /* String_literal */Block.__(11, [
                                                "end",
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Close_box */0,
                                                    /* End_of_format */0
                                                  ])
                                              ])
                                          ])])
                                  ])
                              ])
                          ]),
                        "@[<hv 2>sig@ %a@;<1 -2>end@]"
                      ]), out_signature.contents, t[0]);
    case /* Omty_alias */3 :
        return Curry._2(Format.fprintf(ppf, /* Format */[
                        /* String_literal */Block.__(11, [
                            "(module ",
                            /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                    /* ")" */41,
                                    /* End_of_format */0
                                  ])])
                          ]),
                        "(module %a)"
                      ]), print_ident, t[0]);
    
  }
}

function print_out_constr(ppf, param) {
  var ret_type_opt = param[2];
  var tyl = param[1];
  var name = param[0];
  if (ret_type_opt === void 0) {
    if (tyl) {
      return Curry._3(Format.fprintf(ppf, /* Format */[
                      /* Formatting_gen */Block.__(18, [
                          /* Open_box */Block.__(1, [/* Format */[
                                /* String_literal */Block.__(11, [
                                    "<2>",
                                    /* End_of_format */0
                                  ]),
                                "<2>"
                              ]]),
                          /* String */Block.__(2, [
                              /* No_padding */0,
                              /* String_literal */Block.__(11, [
                                  " of",
                                  /* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@ ",
                                          1,
                                          0
                                        ]),
                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                              /* Close_box */0,
                                              /* End_of_format */0
                                            ])])
                                    ])
                                ])
                            ])
                        ]),
                      "@[<2>%s of@ %a@]"
                    ]), name, (function (param, param$1) {
                    return print_typlist(print_simple_out_type, " *", param, param$1);
                  }), tyl);
    } else {
      return Format.pp_print_string(ppf, name);
    }
  }
  var ret_type = ret_type_opt;
  if (tyl) {
    return Curry._5(Format.fprintf(ppf, /* Format */[
                    /* Formatting_gen */Block.__(18, [
                        /* Open_box */Block.__(1, [/* Format */[
                              /* String_literal */Block.__(11, [
                                  "<2>",
                                  /* End_of_format */0
                                ]),
                              "<2>"
                            ]]),
                        /* String */Block.__(2, [
                            /* No_padding */0,
                            /* String_literal */Block.__(11, [
                                " :",
                                /* Formatting_lit */Block.__(17, [
                                    /* Break */Block.__(0, [
                                        "@ ",
                                        1,
                                        0
                                      ]),
                                    /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                            " -> ",
                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                    /* Close_box */0,
                                                    /* End_of_format */0
                                                  ])])
                                          ])])
                                  ])
                              ])
                          ])
                      ]),
                    "@[<2>%s :@ %a -> %a@]"
                  ]), name, (function (param, param$1) {
                  return print_typlist(print_simple_out_type, " *", param, param$1);
                }), tyl, print_simple_out_type, ret_type);
  } else {
    return Curry._3(Format.fprintf(ppf, /* Format */[
                    /* Formatting_gen */Block.__(18, [
                        /* Open_box */Block.__(1, [/* Format */[
                              /* String_literal */Block.__(11, [
                                  "<2>",
                                  /* End_of_format */0
                                ]),
                              "<2>"
                            ]]),
                        /* String */Block.__(2, [
                            /* No_padding */0,
                            /* String_literal */Block.__(11, [
                                " :",
                                /* Formatting_lit */Block.__(17, [
                                    /* Break */Block.__(0, [
                                        "@ ",
                                        1,
                                        0
                                      ]),
                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                            /* Close_box */0,
                                            /* End_of_format */0
                                          ])])
                                  ])
                              ])
                          ])
                      ]),
                    "@[<2>%s :@ %a@]"
                  ]), name, print_simple_out_type, ret_type);
  }
}

function print_out_label(ppf, param) {
  return Curry._4(Format.fprintf(ppf, /* Format */[
                  /* Formatting_gen */Block.__(18, [
                      /* Open_box */Block.__(1, [/* Format */[
                            /* String_literal */Block.__(11, [
                                "<2>",
                                /* End_of_format */0
                              ]),
                            "<2>"
                          ]]),
                      /* String */Block.__(2, [
                          /* No_padding */0,
                          /* String */Block.__(2, [
                              /* No_padding */0,
                              /* String_literal */Block.__(11, [
                                  " :",
                                  /* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@ ",
                                          1,
                                          0
                                        ]),
                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                              /* Close_box */0,
                                              /* Char_literal */Block.__(12, [
                                                  /* ";" */59,
                                                  /* End_of_format */0
                                                ])
                                            ])])
                                    ])
                                ])
                            ])
                        ])
                    ]),
                  "@[<2>%s%s :@ %a@];"
                ]), param[1] ? "mutable " : "", param[0], out_type.contents, param[2]);
}

function print_out_signature(ppf, param) {
  if (!param) {
    return ;
  }
  var item = param[0];
  if (!param[1]) {
    return Curry._2(out_sig_item.contents, ppf, item);
  }
  if (item.tag === /* Osig_typext */2 && item[1] === 0) {
    var ext = item[0];
    var gather_extensions = function (_acc, _items) {
      while(true) {
        var items = _items;
        var acc = _acc;
        if (!items) {
          return /* tuple */[
                  List.rev(acc),
                  items
                ];
        }
        var match = items[0];
        if (match.tag !== /* Osig_typext */2) {
          return /* tuple */[
                  List.rev(acc),
                  items
                ];
        }
        if (match[1] !== 1) {
          return /* tuple */[
                  List.rev(acc),
                  items
                ];
        }
        var ext = match[0];
        _items = items[1];
        _acc = /* :: */[
          /* tuple */[
            ext.oext_name,
            ext.oext_args,
            ext.oext_ret_type
          ],
          acc
        ];
        continue ;
      };
    };
    var match = gather_extensions(/* :: */[
          /* tuple */[
            ext.oext_name,
            ext.oext_args,
            ext.oext_ret_type
          ],
          /* [] */0
        ], param[1]);
    var te_otyext_name = ext.oext_type_name;
    var te_otyext_params = ext.oext_type_params;
    var te_otyext_constructors = match[0];
    var te_otyext_private = ext.oext_private;
    var te = {
      otyext_name: te_otyext_name,
      otyext_params: te_otyext_params,
      otyext_constructors: te_otyext_constructors,
      otyext_private: te_otyext_private
    };
    return Curry._4(Format.fprintf(ppf, /* Format */[
                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                            /* Break */Block.__(0, [
                                "@ ",
                                1,
                                0
                              ]),
                            /* Alpha */Block.__(15, [/* End_of_format */0])
                          ])]),
                    "%a@ %a"
                  ]), out_type_extension.contents, te, print_out_signature, match[1]);
  }
  return Curry._4(Format.fprintf(ppf, /* Format */[
                  /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                          /* Break */Block.__(0, [
                              "@ ",
                              1,
                              0
                            ]),
                          /* Alpha */Block.__(15, [/* End_of_format */0])
                        ])]),
                  "%a@ %a"
                ]), out_sig_item.contents, item, print_out_signature, param[1]);
}

function print_out_sig_item(ppf, param) {
  switch (param.tag | 0) {
    case /* Osig_class */0 :
        return Curry._7(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<2>",
                                      /* End_of_format */0
                                    ]),
                                  "<2>"
                                ]]),
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* Formatting_lit */Block.__(17, [
                                        /* Break */Block.__(0, [
                                            "@ ",
                                            1,
                                            0
                                          ]),
                                        /* Alpha */Block.__(15, [/* String */Block.__(2, [
                                                /* No_padding */0,
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@ ",
                                                        1,
                                                        0
                                                      ]),
                                                    /* Char_literal */Block.__(12, [
                                                        /* ":" */58,
                                                        /* Formatting_lit */Block.__(17, [
                                                            /* Break */Block.__(0, [
                                                                "@ ",
                                                                1,
                                                                0
                                                              ]),
                                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                    /* Close_box */0,
                                                                    /* End_of_format */0
                                                                  ])])
                                                          ])
                                                      ])
                                                  ])
                                              ])])
                                      ])
                                  ])
                              ])
                          ]),
                        "@[<2>%s%s@ %a%s@ :@ %a@]"
                      ]), param[4] === /* Orec_next */2 ? "and" : "class", param[0] ? " virtual" : "", print_out_class_params, param[2], param[1], out_class_type.contents, param[3]);
    case /* Osig_class_type */1 :
        return Curry._7(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<2>",
                                      /* End_of_format */0
                                    ]),
                                  "<2>"
                                ]]),
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* Formatting_lit */Block.__(17, [
                                        /* Break */Block.__(0, [
                                            "@ ",
                                            1,
                                            0
                                          ]),
                                        /* Alpha */Block.__(15, [/* String */Block.__(2, [
                                                /* No_padding */0,
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@ ",
                                                        1,
                                                        0
                                                      ]),
                                                    /* Char_literal */Block.__(12, [
                                                        /* "=" */61,
                                                        /* Formatting_lit */Block.__(17, [
                                                            /* Break */Block.__(0, [
                                                                "@ ",
                                                                1,
                                                                0
                                                              ]),
                                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                    /* Close_box */0,
                                                                    /* End_of_format */0
                                                                  ])])
                                                          ])
                                                      ])
                                                  ])
                                              ])])
                                      ])
                                  ])
                              ])
                          ]),
                        "@[<2>%s%s@ %a%s@ =@ %a@]"
                      ]), param[4] === /* Orec_next */2 ? "and" : "class type", param[0] ? " virtual" : "", print_out_class_params, param[2], param[1], out_class_type.contents, param[3]);
    case /* Osig_typext */2 :
        var ext = param[0];
        if (param[1] >= 2) {
          return Curry._2(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<2>",
                                        /* End_of_format */0
                                      ]),
                                    "<2>"
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "exception ",
                                  /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                          /* Close_box */0,
                                          /* End_of_format */0
                                        ])])
                                ])
                            ]),
                          "@[<2>exception %a@]"
                        ]), print_out_constr, /* tuple */[
                      ext.oext_name,
                      ext.oext_args,
                      ext.oext_ret_type
                    ]);
        } else {
          var print_extended_type = function (ppf) {
            var print_type_parameter = function (ppf, ty) {
              return Curry._1(Format.fprintf(ppf, /* Format */[
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* End_of_format */0
                                ]),
                              "%s"
                            ]), ty === "_" ? ty : "'" + ty);
            };
            var match = ext.oext_type_params;
            if (match) {
              if (match[1]) {
                return Curry._3(Format.fprintf(ppf, /* Format */[
                                /* Formatting_gen */Block.__(18, [
                                    /* Open_box */Block.__(1, [/* Format */[
                                          /* End_of_format */0,
                                          ""
                                        ]]),
                                    /* Char_literal */Block.__(12, [
                                        /* "(" */40,
                                        /* Formatting_gen */Block.__(18, [
                                            /* Open_box */Block.__(1, [/* Format */[
                                                  /* End_of_format */0,
                                                  ""
                                                ]]),
                                            /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                    /* ")" */41,
                                                    /* Formatting_lit */Block.__(17, [
                                                        /* Close_box */0,
                                                        /* Formatting_lit */Block.__(17, [
                                                            /* Break */Block.__(0, [
                                                                "@ ",
                                                                1,
                                                                0
                                                              ]),
                                                            /* String */Block.__(2, [
                                                                /* No_padding */0,
                                                                /* Formatting_lit */Block.__(17, [
                                                                    /* Close_box */0,
                                                                    /* End_of_format */0
                                                                  ])
                                                              ])
                                                          ])
                                                      ])
                                                  ])])
                                          ])
                                      ])
                                  ]),
                                "@[(@[%a)@]@ %s@]"
                              ]), (function (param, param$1) {
                              return print_list(print_type_parameter, (function (ppf) {
                                            return Format.fprintf(ppf, /* Format */[
                                                        /* Char_literal */Block.__(12, [
                                                            /* "," */44,
                                                            /* Formatting_lit */Block.__(17, [
                                                                /* Break */Block.__(0, [
                                                                    "@ ",
                                                                    1,
                                                                    0
                                                                  ]),
                                                                /* End_of_format */0
                                                              ])
                                                          ]),
                                                        ",@ "
                                                      ]);
                                          }), param, param$1);
                            }), ext.oext_type_params, ext.oext_type_name);
              } else {
                return Curry._3(Format.fprintf(ppf, /* Format */[
                                /* Formatting_gen */Block.__(18, [
                                    /* Open_box */Block.__(1, [/* Format */[
                                          /* End_of_format */0,
                                          ""
                                        ]]),
                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@ ",
                                                1,
                                                0
                                              ]),
                                            /* String */Block.__(2, [
                                                /* No_padding */0,
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Close_box */0,
                                                    /* End_of_format */0
                                                  ])
                                              ])
                                          ])])
                                  ]),
                                "@[%a@ %s@]"
                              ]), print_type_parameter, match[0], ext.oext_type_name);
              }
            } else {
              return Curry._1(Format.fprintf(ppf, /* Format */[
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* End_of_format */0
                                ]),
                              "%s"
                            ]), ext.oext_type_name);
            }
          };
          return Curry._4(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<hv 2>",
                                        /* End_of_format */0
                                      ]),
                                    "<hv 2>"
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "type ",
                                  /* Theta */Block.__(16, [/* String_literal */Block.__(11, [
                                          " +=",
                                          /* String */Block.__(2, [
                                              /* No_padding */0,
                                              /* Formatting_lit */Block.__(17, [
                                                  /* Break */Block.__(0, [
                                                      "@;<1 2>",
                                                      1,
                                                      2
                                                    ]),
                                                  /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                          /* Close_box */0,
                                                          /* End_of_format */0
                                                        ])])
                                                ])
                                            ])
                                        ])])
                                ])
                            ]),
                          "@[<hv 2>type %t +=%s@;<1 2>%a@]"
                        ]), print_extended_type, ext.oext_private === /* Private */0 ? " private" : "", print_out_constr, /* tuple */[
                      ext.oext_name,
                      ext.oext_args,
                      ext.oext_ret_type
                    ]);
        }
    case /* Osig_modtype */3 :
        var mty = param[1];
        var name = param[0];
        if (typeof mty === "number") {
          return Curry._1(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<2>",
                                        /* End_of_format */0
                                      ]),
                                    "<2>"
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "module type ",
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* Formatting_lit */Block.__(17, [
                                          /* Close_box */0,
                                          /* End_of_format */0
                                        ])
                                    ])
                                ])
                            ]),
                          "@[<2>module type %s@]"
                        ]), name);
        } else {
          return Curry._3(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<2>",
                                        /* End_of_format */0
                                      ]),
                                    "<2>"
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "module type ",
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* String_literal */Block.__(11, [
                                          " =",
                                          /* Formatting_lit */Block.__(17, [
                                              /* Break */Block.__(0, [
                                                  "@ ",
                                                  1,
                                                  0
                                                ]),
                                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                      /* Close_box */0,
                                                      /* End_of_format */0
                                                    ])])
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "@[<2>module type %s =@ %a@]"
                        ]), name, out_module_type.contents, mty);
        }
    case /* Osig_module */4 :
        var mty$1 = param[1];
        var name$1 = param[0];
        if (typeof mty$1 !== "number" && mty$1.tag === /* Omty_alias */3) {
          return Curry._3(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<2>",
                                        /* End_of_format */0
                                      ]),
                                    "<2>"
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "module ",
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* String_literal */Block.__(11, [
                                          " =",
                                          /* Formatting_lit */Block.__(17, [
                                              /* Break */Block.__(0, [
                                                  "@ ",
                                                  1,
                                                  0
                                                ]),
                                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                      /* Close_box */0,
                                                      /* End_of_format */0
                                                    ])])
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "@[<2>module %s =@ %a@]"
                        ]), name$1, print_ident, mty$1[0]);
        }
        var tmp;
        switch (param[2]) {
          case /* Orec_not */0 :
              tmp = "module";
              break;
          case /* Orec_first */1 :
              tmp = "module rec";
              break;
          case /* Orec_next */2 :
              tmp = "and";
              break;
          
        }
        return Curry._4(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<2>",
                                      /* End_of_format */0
                                    ]),
                                  "<2>"
                                ]]),
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* Char_literal */Block.__(12, [
                                    /* " " */32,
                                    /* String */Block.__(2, [
                                        /* No_padding */0,
                                        /* String_literal */Block.__(11, [
                                            " :",
                                            /* Formatting_lit */Block.__(17, [
                                                /* Break */Block.__(0, [
                                                    "@ ",
                                                    1,
                                                    0
                                                  ]),
                                                /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                        /* Close_box */0,
                                                        /* End_of_format */0
                                                      ])])
                                              ])
                                          ])
                                      ])
                                  ])
                              ])
                          ]),
                        "@[<2>%s %s :@ %a@]"
                      ]), tmp, name$1, out_module_type.contents, mty$1);
    case /* Osig_type */5 :
        var tmp$1;
        switch (param[1]) {
          case /* Orec_not */0 :
              tmp$1 = "type nonrec";
              break;
          case /* Orec_first */1 :
              tmp$1 = "type";
              break;
          case /* Orec_next */2 :
              tmp$1 = "and";
              break;
          
        }
        var td = param[0];
        var print_constraints = function (ppf) {
          return List.iter((function (param) {
                        return Curry._4(Format.fprintf(ppf, /* Format */[
                                        /* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@ ",
                                                1,
                                                0
                                              ]),
                                            /* Formatting_gen */Block.__(18, [
                                                /* Open_box */Block.__(1, [/* Format */[
                                                      /* String_literal */Block.__(11, [
                                                          "<2>",
                                                          /* End_of_format */0
                                                        ]),
                                                      "<2>"
                                                    ]]),
                                                /* String_literal */Block.__(11, [
                                                    "constraint ",
                                                    /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                                            " =",
                                                            /* Formatting_lit */Block.__(17, [
                                                                /* Break */Block.__(0, [
                                                                    "@ ",
                                                                    1,
                                                                    0
                                                                  ]),
                                                                /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                        /* Close_box */0,
                                                                        /* End_of_format */0
                                                                      ])])
                                                              ])
                                                          ])])
                                                  ])
                                              ])
                                          ]),
                                        "@ @[<2>constraint %a =@ %a@]"
                                      ]), out_type.contents, param[0], out_type.contents, param[1]);
                      }), td.otype_cstrs);
        };
        var type_defined = function (ppf) {
          var match = td.otype_params;
          if (match) {
            if (match[1]) {
              return Curry._3(Format.fprintf(ppf, /* Format */[
                              /* Formatting_gen */Block.__(18, [
                                  /* Open_box */Block.__(1, [/* Format */[
                                        /* End_of_format */0,
                                        ""
                                      ]]),
                                  /* Char_literal */Block.__(12, [
                                      /* "(" */40,
                                      /* Formatting_gen */Block.__(18, [
                                          /* Open_box */Block.__(1, [/* Format */[
                                                /* End_of_format */0,
                                                ""
                                              ]]),
                                          /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                  /* ")" */41,
                                                  /* Formatting_lit */Block.__(17, [
                                                      /* Close_box */0,
                                                      /* Formatting_lit */Block.__(17, [
                                                          /* Break */Block.__(0, [
                                                              "@ ",
                                                              1,
                                                              0
                                                            ]),
                                                          /* String */Block.__(2, [
                                                              /* No_padding */0,
                                                              /* Formatting_lit */Block.__(17, [
                                                                  /* Close_box */0,
                                                                  /* End_of_format */0
                                                                ])
                                                            ])
                                                        ])
                                                    ])
                                                ])])
                                        ])
                                    ])
                                ]),
                              "@[(@[%a)@]@ %s@]"
                            ]), (function (param, param$1) {
                            return print_list(type_parameter, (function (ppf) {
                                          return Format.fprintf(ppf, /* Format */[
                                                      /* Char_literal */Block.__(12, [
                                                          /* "," */44,
                                                          /* Formatting_lit */Block.__(17, [
                                                              /* Break */Block.__(0, [
                                                                  "@ ",
                                                                  1,
                                                                  0
                                                                ]),
                                                              /* End_of_format */0
                                                            ])
                                                        ]),
                                                      ",@ "
                                                    ]);
                                        }), param, param$1);
                          }), td.otype_params, td.otype_name);
            } else {
              return Curry._3(Format.fprintf(ppf, /* Format */[
                              /* Formatting_gen */Block.__(18, [
                                  /* Open_box */Block.__(1, [/* Format */[
                                        /* End_of_format */0,
                                        ""
                                      ]]),
                                  /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                          /* Break */Block.__(0, [
                                              "@ ",
                                              1,
                                              0
                                            ]),
                                          /* String */Block.__(2, [
                                              /* No_padding */0,
                                              /* Formatting_lit */Block.__(17, [
                                                  /* Close_box */0,
                                                  /* End_of_format */0
                                                ])
                                            ])
                                        ])])
                                ]),
                              "@[%a@ %s@]"
                            ]), type_parameter, match[0], td.otype_name);
            }
          } else {
            return Format.pp_print_string(ppf, td.otype_name);
          }
        };
        var print_manifest = function (ppf, param) {
          if (typeof param === "number" || param.tag !== /* Otyp_manifest */4) {
            return ;
          } else {
            return Curry._2(Format.fprintf(ppf, /* Format */[
                            /* String_literal */Block.__(11, [
                                " =",
                                /* Formatting_lit */Block.__(17, [
                                    /* Break */Block.__(0, [
                                        "@ ",
                                        1,
                                        0
                                      ]),
                                    /* Alpha */Block.__(15, [/* End_of_format */0])
                                  ])
                              ]),
                            " =@ %a"
                          ]), out_type.contents, param[0]);
          }
        };
        var print_name_params = function (ppf) {
          return Curry._4(Format.fprintf(ppf, /* Format */[
                          /* String */Block.__(2, [
                              /* No_padding */0,
                              /* Char_literal */Block.__(12, [
                                  /* " " */32,
                                  /* Theta */Block.__(16, [/* Alpha */Block.__(15, [/* End_of_format */0])])
                                ])
                            ]),
                          "%s %t%a"
                        ]), tmp$1, type_defined, print_manifest, td.otype_type);
        };
        var match = td.otype_type;
        var ty;
        ty = typeof match === "number" || match.tag !== /* Otyp_manifest */4 ? td.otype_type : match[1];
        var print_private = function (ppf, param) {
          if (param) {
            return ;
          } else {
            return Format.fprintf(ppf, /* Format */[
                        /* String_literal */Block.__(11, [
                            " private",
                            /* End_of_format */0
                          ]),
                        " private"
                      ]);
          }
        };
        var print_out_tkind = function (ppf, ty) {
          if (typeof ty === "number") {
            if (ty === /* Otyp_abstract */0) {
              return ;
            } else {
              return Format.fprintf(ppf, /* Format */[
                          /* String_literal */Block.__(11, [
                              " = ..",
                              /* End_of_format */0
                            ]),
                          " = .."
                        ]);
            }
          }
          switch (ty.tag | 0) {
            case /* Otyp_record */6 :
                return Curry._4(Format.fprintf(ppf, /* Format */[
                                /* String_literal */Block.__(11, [
                                    " =",
                                    /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                            " {",
                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@;<1 -2>",
                                                        1,
                                                        -2
                                                      ]),
                                                    /* Char_literal */Block.__(12, [
                                                        /* "}" */125,
                                                        /* End_of_format */0
                                                      ])
                                                  ])])
                                          ])])
                                  ]),
                                " =%a {%a@;<1 -2>}"
                              ]), print_private, td.otype_private, (function (param, param$1) {
                              var sep = function (ppf) {
                                return Format.fprintf(ppf, /* Format */[
                                            /* Formatting_lit */Block.__(17, [
                                                /* Break */Block.__(0, [
                                                    "@ ",
                                                    1,
                                                    0
                                                  ]),
                                                /* End_of_format */0
                                              ]),
                                            "@ "
                                          ]);
                              };
                              var _param = param$1;
                              while(true) {
                                var param$2 = _param;
                                if (!param$2) {
                                  return ;
                                }
                                Curry._1(sep, param);
                                Curry._2(print_out_label, param, param$2[0]);
                                _param = param$2[1];
                                continue ;
                              };
                            }), ty[0]);
            case /* Otyp_sum */8 :
                return Curry._4(Format.fprintf(ppf, /* Format */[
                                /* String_literal */Block.__(11, [
                                    " =",
                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@;<1 2>",
                                                1,
                                                2
                                              ]),
                                            /* Alpha */Block.__(15, [/* End_of_format */0])
                                          ])])
                                  ]),
                                " =%a@;<1 2>%a"
                              ]), print_private, td.otype_private, (function (param, param$1) {
                              return print_list(print_out_constr, (function (ppf) {
                                            return Format.fprintf(ppf, /* Format */[
                                                        /* Formatting_lit */Block.__(17, [
                                                            /* Break */Block.__(0, [
                                                                "@ ",
                                                                1,
                                                                0
                                                              ]),
                                                            /* String_literal */Block.__(11, [
                                                                "| ",
                                                                /* End_of_format */0
                                                              ])
                                                          ]),
                                                        "@ | "
                                                      ]);
                                          }), param, param$1);
                            }), ty[0]);
            default:
              return Curry._4(Format.fprintf(ppf, /* Format */[
                              /* String_literal */Block.__(11, [
                                  " =",
                                  /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                          /* Break */Block.__(0, [
                                              "@;<1 2>",
                                              1,
                                              2
                                            ]),
                                          /* Alpha */Block.__(15, [/* End_of_format */0])
                                        ])])
                                ]),
                              " =%a@;<1 2>%a"
                            ]), print_private, td.otype_private, out_type.contents, ty);
          }
        };
        return Curry._4(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<2>",
                                      /* End_of_format */0
                                    ]),
                                  "<2>"
                                ]]),
                            /* Formatting_gen */Block.__(18, [
                                /* Open_box */Block.__(1, [/* Format */[
                                      /* String_literal */Block.__(11, [
                                          "<hv 2>",
                                          /* End_of_format */0
                                        ]),
                                      "<hv 2>"
                                    ]]),
                                /* Theta */Block.__(16, [/* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                            /* Close_box */0,
                                            /* Theta */Block.__(16, [/* Formatting_lit */Block.__(17, [
                                                    /* Close_box */0,
                                                    /* End_of_format */0
                                                  ])])
                                          ])])])
                              ])
                          ]),
                        "@[<2>@[<hv 2>%t%a@]%t@]"
                      ]), print_name_params, print_out_tkind, ty, print_constraints);
    case /* Osig_value */6 :
        var prims = param[2];
        var kwd = prims === /* [] */0 ? "val" : "external";
        var pr_prims = function (ppf, param) {
          if (param) {
            Curry._1(Format.fprintf(ppf, /* Format */[
                      /* Formatting_lit */Block.__(17, [
                          /* Break */Block.__(0, [
                              "@ ",
                              1,
                              0
                            ]),
                          /* String_literal */Block.__(11, [
                              "= \"",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* Char_literal */Block.__(12, [
                                      /* "\"" */34,
                                      /* End_of_format */0
                                    ])
                                ])
                            ])
                        ]),
                      "@ = \"%s\""
                    ]), param[0]);
            return List.iter((function (s) {
                          var len = s.length;
                          if (len >= 3 && Caml_string.get(s, 0) === /* "B" */66 && Caml_string.get(s, 1) === /* "S" */83 && Caml_string.get(s, 2) === /* ":" */58) {
                            return Format.fprintf(ppf, /* Format */[
                                        /* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@ ",
                                                1,
                                                0
                                              ]),
                                            /* String_literal */Block.__(11, [
                                                "\"BS-EXTERNAL\"",
                                                /* End_of_format */0
                                              ])
                                          ]),
                                        "@ \"BS-EXTERNAL\""
                                      ]);
                          } else {
                            return Curry._1(Format.fprintf(ppf, /* Format */[
                                            /* Formatting_lit */Block.__(17, [
                                                /* Break */Block.__(0, [
                                                    "@ ",
                                                    1,
                                                    0
                                                  ]),
                                                /* Char_literal */Block.__(12, [
                                                    /* "\"" */34,
                                                    /* String */Block.__(2, [
                                                        /* No_padding */0,
                                                        /* Char_literal */Block.__(12, [
                                                            /* "\"" */34,
                                                            /* End_of_format */0
                                                          ])
                                                      ])
                                                  ])
                                              ]),
                                            "@ \"%s\""
                                          ]), s);
                          }
                        }), param[1]);
          }
          
        };
        return Curry._7(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<2>",
                                      /* End_of_format */0
                                    ]),
                                  "<2>"
                                ]]),
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* Char_literal */Block.__(12, [
                                    /* " " */32,
                                    /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                            " :",
                                            /* Formatting_lit */Block.__(17, [
                                                /* Break */Block.__(0, [
                                                    "@ ",
                                                    1,
                                                    0
                                                  ]),
                                                /* Alpha */Block.__(15, [/* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                            /* Close_box */0,
                                                            /* End_of_format */0
                                                          ])])])
                                              ])
                                          ])])
                                  ])
                              ])
                          ]),
                        "@[<2>%s %a :@ %a%a@]"
                      ]), kwd, value_ident, param[0], out_type.contents, param[1], pr_prims, prims);
    
  }
}

function print_out_type_extension(ppf, te) {
  var print_extended_type = function (ppf) {
    var print_type_parameter = function (ppf, ty) {
      return Curry._1(Format.fprintf(ppf, /* Format */[
                      /* String */Block.__(2, [
                          /* No_padding */0,
                          /* End_of_format */0
                        ]),
                      "%s"
                    ]), ty === "_" ? ty : "'" + ty);
    };
    var match = te.otyext_params;
    if (match) {
      if (match[1]) {
        return Curry._3(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* End_of_format */0,
                                  ""
                                ]]),
                            /* Char_literal */Block.__(12, [
                                /* "(" */40,
                                /* Formatting_gen */Block.__(18, [
                                    /* Open_box */Block.__(1, [/* Format */[
                                          /* End_of_format */0,
                                          ""
                                        ]]),
                                    /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                            /* ")" */41,
                                            /* Formatting_lit */Block.__(17, [
                                                /* Close_box */0,
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@ ",
                                                        1,
                                                        0
                                                      ]),
                                                    /* String */Block.__(2, [
                                                        /* No_padding */0,
                                                        /* Formatting_lit */Block.__(17, [
                                                            /* Close_box */0,
                                                            /* End_of_format */0
                                                          ])
                                                      ])
                                                  ])
                                              ])
                                          ])])
                                  ])
                              ])
                          ]),
                        "@[(@[%a)@]@ %s@]"
                      ]), (function (param, param$1) {
                      return print_list(print_type_parameter, (function (ppf) {
                                    return Format.fprintf(ppf, /* Format */[
                                                /* Char_literal */Block.__(12, [
                                                    /* "," */44,
                                                    /* Formatting_lit */Block.__(17, [
                                                        /* Break */Block.__(0, [
                                                            "@ ",
                                                            1,
                                                            0
                                                          ]),
                                                        /* End_of_format */0
                                                      ])
                                                  ]),
                                                ",@ "
                                              ]);
                                  }), param, param$1);
                    }), te.otyext_params, te.otyext_name);
      } else {
        return Curry._3(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* End_of_format */0,
                                  ""
                                ]]),
                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                    /* Break */Block.__(0, [
                                        "@ ",
                                        1,
                                        0
                                      ]),
                                    /* String */Block.__(2, [
                                        /* No_padding */0,
                                        /* Formatting_lit */Block.__(17, [
                                            /* Close_box */0,
                                            /* End_of_format */0
                                          ])
                                      ])
                                  ])])
                          ]),
                        "@[%a@ %s@]"
                      ]), print_type_parameter, match[0], te.otyext_name);
      }
    } else {
      return Curry._1(Format.fprintf(ppf, /* Format */[
                      /* String */Block.__(2, [
                          /* No_padding */0,
                          /* End_of_format */0
                        ]),
                      "%s"
                    ]), te.otyext_name);
    }
  };
  return Curry._4(Format.fprintf(ppf, /* Format */[
                  /* Formatting_gen */Block.__(18, [
                      /* Open_box */Block.__(1, [/* Format */[
                            /* String_literal */Block.__(11, [
                                "<hv 2>",
                                /* End_of_format */0
                              ]),
                            "<hv 2>"
                          ]]),
                      /* String_literal */Block.__(11, [
                          "type ",
                          /* Theta */Block.__(16, [/* String_literal */Block.__(11, [
                                  " +=",
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* Formatting_lit */Block.__(17, [
                                          /* Break */Block.__(0, [
                                              "@;<1 2>",
                                              1,
                                              2
                                            ]),
                                          /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                  /* Close_box */0,
                                                  /* End_of_format */0
                                                ])])
                                        ])
                                    ])
                                ])])
                        ])
                    ]),
                  "@[<hv 2>type %t +=%s@;<1 2>%a@]"
                ]), print_extended_type, te.otyext_private === /* Private */0 ? " private" : "", (function (param, param$1) {
                return print_list(print_out_constr, (function (ppf) {
                              return Format.fprintf(ppf, /* Format */[
                                          /* Formatting_lit */Block.__(17, [
                                              /* Break */Block.__(0, [
                                                  "@ ",
                                                  1,
                                                  0
                                                ]),
                                              /* String_literal */Block.__(11, [
                                                  "| ",
                                                  /* End_of_format */0
                                                ])
                                            ]),
                                          "@ | "
                                        ]);
                            }), param, param$1);
              }), te.otyext_constructors);
}

out_module_type.contents = print_out_module_type;

out_signature.contents = print_out_signature;

out_sig_item.contents = print_out_sig_item;

out_type_extension.contents = print_out_type_extension;

function longident(ppf, param) {
  switch (param.tag | 0) {
    case /* Lident */0 :
        return Format.pp_print_string(ppf, param[0]);
    case /* Ldot */1 :
        return Curry._3(Format.fprintf(ppf, /* Format */[
                        /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                /* "." */46,
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* End_of_format */0
                                  ])
                              ])]),
                        "%a.%s"
                      ]), longident, param[0], param[1]);
    case /* Lapply */2 :
        return Curry._4(Format.fprintf(ppf, /* Format */[
                        /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                /* "(" */40,
                                /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                        /* ")" */41,
                                        /* End_of_format */0
                                      ])])
                              ])]),
                        "%a(%a)"
                      ]), longident, param[0], longident, param[1]);
    
  }
}

var unique_names = {
  contents: /* Empty */0
};

function ident_name(id) {
  try {
    return find_same(id, unique_names.contents);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return id.name;
    }
    throw exn;
  }
}

function add_unique(id) {
  try {
    find_same(id, unique_names.contents);
    return ;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      unique_names.contents = add(id, unique_toplevel_name(id), unique_names.contents);
      return ;
    }
    throw exn;
  }
}

function ident$3(ppf, id) {
  return Format.pp_print_string(ppf, ident_name(id));
}

var ident_pervasive = {
  stamp: 0,
  name: "Pervasives",
  flags: 1
};

function tree_of_path(param) {
  switch (param.tag | 0) {
    case /* Pident */0 :
        return /* Oide_ident */Block.__(2, [ident_name(param[0])]);
    case /* Pdot */1 :
        var p = param[0];
        switch (p.tag | 0) {
          case /* Pident */0 :
              if (Caml_obj.caml_equal(p[0], ident_pervasive)) {
                return /* Oide_ident */Block.__(2, [param[1]]);
              }
              break;
          case /* Pdot */1 :
          case /* Papply */2 :
              break;
          
        }
        return /* Oide_dot */Block.__(1, [
                  tree_of_path(p),
                  param[1]
                ]);
    case /* Papply */2 :
        return /* Oide_apply */Block.__(0, [
                  tree_of_path(param[0]),
                  tree_of_path(param[1])
                ]);
    
  }
}

function path(ppf, param) {
  switch (param.tag | 0) {
    case /* Pident */0 :
        return Format.pp_print_string(ppf, ident_name(param[0]));
    case /* Pdot */1 :
        var p = param[0];
        switch (p.tag | 0) {
          case /* Pident */0 :
              if (Caml_obj.caml_equal(p[0], ident_pervasive)) {
                return Format.pp_print_string(ppf, param[1]);
              }
              break;
          case /* Pdot */1 :
          case /* Papply */2 :
              break;
          
        }
        path(ppf, p);
        Format.pp_print_char(ppf, /* "." */46);
        return Format.pp_print_string(ppf, param[1]);
    case /* Papply */2 :
        return Curry._4(Format.fprintf(ppf, /* Format */[
                        /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                /* "(" */40,
                                /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                        /* ")" */41,
                                        /* End_of_format */0
                                      ])])
                              ])]),
                        "%a(%a)"
                      ]), path, param[0], path, param[1]);
    
  }
}

function string_of_out_ident(param) {
  switch (param.tag | 0) {
    case /* Oide_apply */0 :
        return $$String.concat("", /* :: */[
                    string_of_out_ident(param[0]),
                    /* :: */[
                      "(",
                      /* :: */[
                        string_of_out_ident(param[1]),
                        /* :: */[
                          ")",
                          /* [] */0
                        ]
                      ]
                    ]
                  ]);
    case /* Oide_dot */1 :
        return $$String.concat(".", /* :: */[
                    string_of_out_ident(param[0]),
                    /* :: */[
                      param[1],
                      /* [] */0
                    ]
                  ]);
    case /* Oide_ident */2 :
        return param[0];
    
  }
}

function string_of_path(p) {
  return string_of_out_ident(tree_of_path(p));
}

function raw_list(pr, ppf, param) {
  if (!param) {
    return Format.fprintf(ppf, /* Format */[
                /* String_literal */Block.__(11, [
                    "[]",
                    /* End_of_format */0
                  ]),
                "[]"
              ]);
  }
  var l = param[1];
  return Curry._3(Format.fprintf(ppf, /* Format */[
                  /* Formatting_gen */Block.__(18, [
                      /* Open_box */Block.__(1, [/* Format */[
                            /* String_literal */Block.__(11, [
                                "<1>",
                                /* End_of_format */0
                              ]),
                            "<1>"
                          ]]),
                      /* Char_literal */Block.__(12, [
                          /* "[" */91,
                          /* Alpha */Block.__(15, [/* Theta */Block.__(16, [/* Char_literal */Block.__(12, [
                                      /* "]" */93,
                                      /* Formatting_lit */Block.__(17, [
                                          /* Close_box */0,
                                          /* End_of_format */0
                                        ])
                                    ])])])
                        ])
                    ]),
                  "@[<1>[%a%t]@]"
                ]), pr, param[0], (function (ppf) {
                return List.iter((function (x) {
                              return Curry._2(Format.fprintf(ppf, /* Format */[
                                              /* Char_literal */Block.__(12, [
                                                  /* ";" */59,
                                                  /* Formatting_lit */Block.__(17, [
                                                      /* Break */Block.__(0, [
                                                          "@,",
                                                          0,
                                                          0
                                                        ]),
                                                      /* Alpha */Block.__(15, [/* End_of_format */0])
                                                    ])
                                                ]),
                                              ";@,%a"
                                            ]), pr, x);
                            }), l);
              }));
}

function safe_kind_repr(_v, _param) {
  while(true) {
    var param = _param;
    var v = _v;
    if (typeof param === "number") {
      if (param !== 0) {
        return "Fabsent";
      } else {
        return "Fpresent";
      }
    }
    var match = param[0].contents;
    if (match === void 0) {
      return "Fvar None";
    }
    var k = match;
    if (List.memq(k, v)) {
      return "Fvar loop";
    }
    _param = k;
    _v = /* :: */[
      k,
      v
    ];
    continue ;
  };
}

function safe_commu_repr(_v, _param) {
  while(true) {
    var param = _param;
    var v = _v;
    if (typeof param === "number") {
      if (param !== 0) {
        return "Cunknown";
      } else {
        return "Cok";
      }
    }
    var r = param[0];
    if (List.memq(r, v)) {
      return "Clink loop";
    }
    _param = r.contents;
    _v = /* :: */[
      r,
      v
    ];
    continue ;
  };
}

function safe_repr(_v, _t) {
  while(true) {
    var t = _t;
    var v = _v;
    var match = t.desc;
    if (typeof match === "number") {
      return t;
    }
    if (match.tag !== /* Tlink */6) {
      return t;
    }
    var t$1 = match[0];
    if (List.memq(t$1, v)) {
      return t;
    }
    _t = t$1;
    _v = /* :: */[
      t$1,
      v
    ];
    continue ;
  };
}

function list_of_memo(_param) {
  while(true) {
    var param = _param;
    if (typeof param === "number") {
      return /* [] */0;
    }
    if (!param.tag) {
      return /* :: */[
              param[1],
              list_of_memo(param[4])
            ];
    }
    _param = param[0].contents;
    continue ;
  };
}

function print_name(ppf, param) {
  if (param !== void 0) {
    return Curry._1(Format.fprintf(ppf, /* Format */[
                    /* Char_literal */Block.__(12, [
                        /* "\"" */34,
                        /* String */Block.__(2, [
                            /* No_padding */0,
                            /* Char_literal */Block.__(12, [
                                /* "\"" */34,
                                /* End_of_format */0
                              ])
                          ])
                      ]),
                    "\"%s\""
                  ]), param);
  } else {
    return Format.fprintf(ppf, /* Format */[
                /* String_literal */Block.__(11, [
                    "None",
                    /* End_of_format */0
                  ]),
                "None"
              ]);
  }
}

var visited = {
  contents: /* [] */0
};

function raw_type(ppf, ty) {
  var ty$1 = safe_repr(/* [] */0, ty);
  if (List.memq(ty$1, visited.contents)) {
    return Curry._1(Format.fprintf(ppf, /* Format */[
                    /* String_literal */Block.__(11, [
                        "{id=",
                        /* Int */Block.__(4, [
                            /* Int_d */0,
                            /* No_padding */0,
                            /* No_precision */0,
                            /* Char_literal */Block.__(12, [
                                /* "}" */125,
                                /* End_of_format */0
                              ])
                          ])
                      ]),
                    "{id=%d}"
                  ]), ty$1.id);
  } else {
    visited.contents = /* :: */[
      ty$1,
      visited.contents
    ];
    return Curry._4(Format.fprintf(ppf, /* Format */[
                    /* Formatting_gen */Block.__(18, [
                        /* Open_box */Block.__(1, [/* Format */[
                              /* String_literal */Block.__(11, [
                                  "<1>",
                                  /* End_of_format */0
                                ]),
                              "<1>"
                            ]]),
                        /* String_literal */Block.__(11, [
                            "{id=",
                            /* Int */Block.__(4, [
                                /* Int_d */0,
                                /* No_padding */0,
                                /* No_precision */0,
                                /* String_literal */Block.__(11, [
                                    ";level=",
                                    /* Int */Block.__(4, [
                                        /* Int_d */0,
                                        /* No_padding */0,
                                        /* No_precision */0,
                                        /* String_literal */Block.__(11, [
                                            ";desc=",
                                            /* Formatting_lit */Block.__(17, [
                                                /* Break */Block.__(0, [
                                                    "@,",
                                                    0,
                                                    0
                                                  ]),
                                                /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                        /* "}" */125,
                                                        /* Formatting_lit */Block.__(17, [
                                                            /* Close_box */0,
                                                            /* End_of_format */0
                                                          ])
                                                      ])])
                                              ])
                                          ])
                                      ])
                                  ])
                              ])
                          ])
                      ]),
                    "@[<1>{id=%d;level=%d;desc=@,%a}@]"
                  ]), ty$1.id, ty$1.level, raw_type_desc, ty$1.desc);
  }
}

function raw_type_list(tl) {
  return (function (param) {
      return raw_list(raw_type, tl, param);
    });
}

function raw_type_desc(ppf, param) {
  if (typeof param === "number") {
    return Format.fprintf(ppf, /* Format */[
                /* String_literal */Block.__(11, [
                    "Tnil",
                    /* End_of_format */0
                  ]),
                "Tnil"
              ]);
  }
  switch (param.tag | 0) {
    case /* Tvar */0 :
        return Curry._2(Format.fprintf(ppf, /* Format */[
                        /* String_literal */Block.__(11, [
                            "Tvar ",
                            /* Alpha */Block.__(15, [/* End_of_format */0])
                          ]),
                        "Tvar %a"
                      ]), print_name, param[0]);
    case /* Tarrow */1 :
        return Curry._6(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<hov1>",
                                      /* End_of_format */0
                                    ]),
                                  "<hov1>"
                                ]]),
                            /* String_literal */Block.__(11, [
                                "Tarrow(",
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* Char_literal */Block.__(12, [
                                        /* "," */44,
                                        /* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@,",
                                                0,
                                                0
                                              ]),
                                            /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                    /* "," */44,
                                                    /* Formatting_lit */Block.__(17, [
                                                        /* Break */Block.__(0, [
                                                            "@,",
                                                            0,
                                                            0
                                                          ]),
                                                        /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                                /* "," */44,
                                                                /* Formatting_lit */Block.__(17, [
                                                                    /* Break */Block.__(0, [
                                                                        "@,",
                                                                        0,
                                                                        0
                                                                      ]),
                                                                    /* String */Block.__(2, [
                                                                        /* No_padding */0,
                                                                        /* Char_literal */Block.__(12, [
                                                                            /* ")" */41,
                                                                            /* Formatting_lit */Block.__(17, [
                                                                                /* Close_box */0,
                                                                                /* End_of_format */0
                                                                              ])
                                                                          ])
                                                                      ])
                                                                  ])
                                                              ])])
                                                      ])
                                                  ])])
                                          ])
                                      ])
                                  ])
                              ])
                          ]),
                        "@[<hov1>Tarrow(%s,@,%a,@,%a,@,%s)@]"
                      ]), param[0], raw_type, param[1], raw_type, param[2], safe_commu_repr(/* [] */0, param[3]));
    case /* Ttuple */2 :
        return Curry._2(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<1>",
                                      /* End_of_format */0
                                    ]),
                                  "<1>"
                                ]]),
                            /* String_literal */Block.__(11, [
                                "Ttuple",
                                /* Formatting_lit */Block.__(17, [
                                    /* Break */Block.__(0, [
                                        "@,",
                                        0,
                                        0
                                      ]),
                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                            /* Close_box */0,
                                            /* End_of_format */0
                                          ])])
                                  ])
                              ])
                          ]),
                        "@[<1>Ttuple@,%a@]"
                      ]), raw_type_list, param[0]);
    case /* Tconstr */3 :
        return Curry._6(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<hov1>",
                                      /* End_of_format */0
                                    ]),
                                  "<hov1>"
                                ]]),
                            /* String_literal */Block.__(11, [
                                "Tconstr(",
                                /* Formatting_lit */Block.__(17, [
                                    /* Break */Block.__(0, [
                                        "@,",
                                        0,
                                        0
                                      ]),
                                    /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                            /* "," */44,
                                            /* Formatting_lit */Block.__(17, [
                                                /* Break */Block.__(0, [
                                                    "@,",
                                                    0,
                                                    0
                                                  ]),
                                                /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                        /* "," */44,
                                                        /* Formatting_lit */Block.__(17, [
                                                            /* Break */Block.__(0, [
                                                                "@,",
                                                                0,
                                                                0
                                                              ]),
                                                            /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                                    /* ")" */41,
                                                                    /* Formatting_lit */Block.__(17, [
                                                                        /* Close_box */0,
                                                                        /* End_of_format */0
                                                                      ])
                                                                  ])])
                                                          ])
                                                      ])])
                                              ])
                                          ])])
                                  ])
                              ])
                          ]),
                        "@[<hov1>Tconstr(@,%a,@,%a,@,%a)@]"
                      ]), path, param[0], raw_type_list, param[1], (function (param, param$1) {
                      return raw_list(path, param, param$1);
                    }), list_of_memo(param[2].contents));
    case /* Tobject */4 :
        var nm = param[1];
        return Curry._3(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<hov1>",
                                      /* End_of_format */0
                                    ]),
                                  "<hov1>"
                                ]]),
                            /* String_literal */Block.__(11, [
                                "Tobject(",
                                /* Formatting_lit */Block.__(17, [
                                    /* Break */Block.__(0, [
                                        "@,",
                                        0,
                                        0
                                      ]),
                                    /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                            /* "," */44,
                                            /* Formatting_lit */Block.__(17, [
                                                /* Break */Block.__(0, [
                                                    "@,",
                                                    0,
                                                    0
                                                  ]),
                                                /* Formatting_gen */Block.__(18, [
                                                    /* Open_box */Block.__(1, [/* Format */[
                                                          /* String_literal */Block.__(11, [
                                                              "<1>",
                                                              /* End_of_format */0
                                                            ]),
                                                          "<1>"
                                                        ]]),
                                                    /* String_literal */Block.__(11, [
                                                        "ref",
                                                        /* Theta */Block.__(16, [/* Formatting_lit */Block.__(17, [
                                                                /* Close_box */0,
                                                                /* Char_literal */Block.__(12, [
                                                                    /* ")" */41,
                                                                    /* Formatting_lit */Block.__(17, [
                                                                        /* Close_box */0,
                                                                        /* End_of_format */0
                                                                      ])
                                                                  ])
                                                              ])])
                                                      ])
                                                  ])
                                              ])
                                          ])])
                                  ])
                              ])
                          ]),
                        "@[<hov1>Tobject(@,%a,@,@[<1>ref%t@])@]"
                      ]), raw_type, param[0], (function (ppf) {
                      var match = nm.contents;
                      if (match === void 0) {
                        return Format.fprintf(ppf, /* Format */[
                                    /* String_literal */Block.__(11, [
                                        " None",
                                        /* End_of_format */0
                                      ]),
                                    " None"
                                  ]);
                      }
                      var match$1 = match;
                      return Curry._4(Format.fprintf(ppf, /* Format */[
                                      /* String_literal */Block.__(11, [
                                          "(Some(",
                                          /* Formatting_lit */Block.__(17, [
                                              /* Break */Block.__(0, [
                                                  "@,",
                                                  0,
                                                  0
                                                ]),
                                              /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                      /* "," */44,
                                                      /* Formatting_lit */Block.__(17, [
                                                          /* Break */Block.__(0, [
                                                              "@,",
                                                              0,
                                                              0
                                                            ]),
                                                          /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                                                  "))",
                                                                  /* End_of_format */0
                                                                ])])
                                                        ])
                                                    ])])
                                            ])
                                        ]),
                                      "(Some(@,%a,@,%a))"
                                    ]), path, match$1[0], raw_type_list, match$1[1]);
                    }));
    case /* Tfield */5 :
        return Curry._6(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<hov1>",
                                      /* End_of_format */0
                                    ]),
                                  "<hov1>"
                                ]]),
                            /* String_literal */Block.__(11, [
                                "Tfield(",
                                /* Formatting_lit */Block.__(17, [
                                    /* Break */Block.__(0, [
                                        "@,",
                                        0,
                                        0
                                      ]),
                                    /* String */Block.__(2, [
                                        /* No_padding */0,
                                        /* Char_literal */Block.__(12, [
                                            /* "," */44,
                                            /* Formatting_lit */Block.__(17, [
                                                /* Break */Block.__(0, [
                                                    "@,",
                                                    0,
                                                    0
                                                  ]),
                                                /* String */Block.__(2, [
                                                    /* No_padding */0,
                                                    /* Char_literal */Block.__(12, [
                                                        /* "," */44,
                                                        /* Formatting_lit */Block.__(17, [
                                                            /* Break */Block.__(0, [
                                                                "@,",
                                                                0,
                                                                0
                                                              ]),
                                                            /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                                    /* "," */44,
                                                                    /* Formatting_lit */Block.__(17, [
                                                                        /* Break */Block.__(0, [
                                                                            "@;<0 -1>",
                                                                            0,
                                                                            -1
                                                                          ]),
                                                                        /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                                                /* ")" */41,
                                                                                /* Formatting_lit */Block.__(17, [
                                                                                    /* Close_box */0,
                                                                                    /* End_of_format */0
                                                                                  ])
                                                                              ])])
                                                                      ])
                                                                  ])])
                                                          ])
                                                      ])
                                                  ])
                                              ])
                                          ])
                                      ])
                                  ])
                              ])
                          ]),
                        "@[<hov1>Tfield(@,%s,@,%s,@,%a,@;<0 -1>%a)@]"
                      ]), param[0], safe_kind_repr(/* [] */0, param[1]), raw_type, param[2], raw_type, param[3]);
    case /* Tlink */6 :
        return Curry._2(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<1>",
                                      /* End_of_format */0
                                    ]),
                                  "<1>"
                                ]]),
                            /* String_literal */Block.__(11, [
                                "Tlink",
                                /* Formatting_lit */Block.__(17, [
                                    /* Break */Block.__(0, [
                                        "@,",
                                        0,
                                        0
                                      ]),
                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                            /* Close_box */0,
                                            /* End_of_format */0
                                          ])])
                                  ])
                              ])
                          ]),
                        "@[<1>Tlink@,%a@]"
                      ]), raw_type, param[0]);
    case /* Tsubst */7 :
        return Curry._2(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<1>",
                                      /* End_of_format */0
                                    ]),
                                  "<1>"
                                ]]),
                            /* String_literal */Block.__(11, [
                                "Tsubst",
                                /* Formatting_lit */Block.__(17, [
                                    /* Break */Block.__(0, [
                                        "@,",
                                        0,
                                        0
                                      ]),
                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                            /* Close_box */0,
                                            /* End_of_format */0
                                          ])])
                                  ])
                              ])
                          ]),
                        "@[<1>Tsubst@,%a@]"
                      ]), raw_type, param[0]);
    case /* Tvariant */8 :
        var row = param[0];
        return Curry.app(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<hov1>",
                                      /* End_of_format */0
                                    ]),
                                  "<hov1>"
                                ]]),
                            /* Char_literal */Block.__(12, [
                                /* "{" */123,
                                /* Formatting_gen */Block.__(18, [
                                    /* Open_box */Block.__(1, [/* Format */[
                                          /* End_of_format */0,
                                          ""
                                        ]]),
                                    /* String */Block.__(2, [
                                        /* No_padding */0,
                                        /* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@,",
                                                0,
                                                0
                                              ]),
                                            /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                    /* ";" */59,
                                                    /* Formatting_lit */Block.__(17, [
                                                        /* Close_box */0,
                                                        /* Formatting_lit */Block.__(17, [
                                                            /* Break */Block.__(0, [
                                                                "@ ",
                                                                1,
                                                                0
                                                              ]),
                                                            /* Formatting_gen */Block.__(18, [
                                                                /* Open_box */Block.__(1, [/* Format */[
                                                                      /* End_of_format */0,
                                                                      ""
                                                                    ]]),
                                                                /* String */Block.__(2, [
                                                                    /* No_padding */0,
                                                                    /* Formatting_lit */Block.__(17, [
                                                                        /* Break */Block.__(0, [
                                                                            "@,",
                                                                            0,
                                                                            0
                                                                          ]),
                                                                        /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                                                /* ";" */59,
                                                                                /* Formatting_lit */Block.__(17, [
                                                                                    /* Close_box */0,
                                                                                    /* Formatting_lit */Block.__(17, [
                                                                                        /* Break */Block.__(0, [
                                                                                            "@ ",
                                                                                            1,
                                                                                            0
                                                                                          ]),
                                                                                        /* String */Block.__(2, [
                                                                                            /* No_padding */0,
                                                                                            /* Bool */Block.__(9, [
                                                                                                /* No_padding */0,
                                                                                                /* Char_literal */Block.__(12, [
                                                                                                    /* ";" */59,
                                                                                                    /* Formatting_lit */Block.__(17, [
                                                                                                        /* Break */Block.__(0, [
                                                                                                            "@ ",
                                                                                                            1,
                                                                                                            0
                                                                                                          ]),
                                                                                                        /* String */Block.__(2, [
                                                                                                            /* No_padding */0,
                                                                                                            /* Bool */Block.__(9, [
                                                                                                                /* No_padding */0,
                                                                                                                /* Char_literal */Block.__(12, [
                                                                                                                    /* ";" */59,
                                                                                                                    /* Formatting_lit */Block.__(17, [
                                                                                                                        /* Break */Block.__(0, [
                                                                                                                            "@ ",
                                                                                                                            1,
                                                                                                                            0
                                                                                                                          ]),
                                                                                                                        /* Formatting_gen */Block.__(18, [
                                                                                                                            /* Open_box */Block.__(1, [/* Format */[
                                                                                                                                  /* String_literal */Block.__(11, [
                                                                                                                                      "<1>",
                                                                                                                                      /* End_of_format */0
                                                                                                                                    ]),
                                                                                                                                  "<1>"
                                                                                                                                ]]),
                                                                                                                            /* String */Block.__(2, [
                                                                                                                                /* No_padding */0,
                                                                                                                                /* Theta */Block.__(16, [/* Formatting_lit */Block.__(17, [
                                                                                                                                        /* Close_box */0,
                                                                                                                                        /* Char_literal */Block.__(12, [
                                                                                                                                            /* "}" */125,
                                                                                                                                            /* Formatting_lit */Block.__(17, [
                                                                                                                                                /* Close_box */0,
                                                                                                                                                /* End_of_format */0
                                                                                                                                              ])
                                                                                                                                          ])
                                                                                                                                      ])])
                                                                                                                              ])
                                                                                                                          ])
                                                                                                                      ])
                                                                                                                  ])
                                                                                                              ])
                                                                                                          ])
                                                                                                      ])
                                                                                                  ])
                                                                                              ])
                                                                                          ])
                                                                                      ])
                                                                                  ])
                                                                              ])])
                                                                      ])
                                                                  ])
                                                              ])
                                                          ])
                                                      ])
                                                  ])])
                                          ])
                                      ])
                                  ])
                              ])
                          ]),
                        "@[<hov1>{@[%s@,%a;@]@ @[%s@,%a;@]@ %s%b;@ %s%b;@ @[<1>%s%t@]}@]"
                      ]), [
                    "row_fields=",
                    (function (param, param$1) {
                        return raw_list((function (ppf, param) {
                                      return Curry._3(Format.fprintf(ppf, /* Format */[
                                                      /* Formatting_gen */Block.__(18, [
                                                          /* Open_box */Block.__(1, [/* Format */[
                                                                /* End_of_format */0,
                                                                ""
                                                              ]]),
                                                          /* String */Block.__(2, [
                                                              /* No_padding */0,
                                                              /* Char_literal */Block.__(12, [
                                                                  /* "," */44,
                                                                  /* Formatting_lit */Block.__(17, [
                                                                      /* Break */Block.__(0, [
                                                                          "@ ",
                                                                          1,
                                                                          0
                                                                        ]),
                                                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                              /* Close_box */0,
                                                                              /* End_of_format */0
                                                                            ])])
                                                                    ])
                                                                ])
                                                            ])
                                                        ]),
                                                      "@[%s,@ %a@]"
                                                    ]), param[0], raw_field, param[1]);
                                    }), param, param$1);
                      }),
                    row.row_fields,
                    "row_more=",
                    raw_type,
                    row.row_more,
                    "row_closed=",
                    row.row_closed,
                    "row_fixed=",
                    row.row_fixed,
                    "row_name=",
                    (function (ppf) {
                        var match = row.row_name;
                        if (match === void 0) {
                          return Format.fprintf(ppf, /* Format */[
                                      /* String_literal */Block.__(11, [
                                          "None",
                                          /* End_of_format */0
                                        ]),
                                      "None"
                                    ]);
                        }
                        var match$1 = match;
                        return Curry._4(Format.fprintf(ppf, /* Format */[
                                        /* String_literal */Block.__(11, [
                                            "Some(",
                                            /* Formatting_lit */Block.__(17, [
                                                /* Break */Block.__(0, [
                                                    "@,",
                                                    0,
                                                    0
                                                  ]),
                                                /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                        /* "," */44,
                                                        /* Formatting_lit */Block.__(17, [
                                                            /* Break */Block.__(0, [
                                                                "@,",
                                                                0,
                                                                0
                                                              ]),
                                                            /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                                    /* ")" */41,
                                                                    /* End_of_format */0
                                                                  ])])
                                                          ])
                                                      ])])
                                              ])
                                          ]),
                                        "Some(@,%a,@,%a)"
                                      ]), path, match$1[0], raw_type_list, match$1[1]);
                      })
                  ]);
    case /* Tunivar */9 :
        return Curry._2(Format.fprintf(ppf, /* Format */[
                        /* String_literal */Block.__(11, [
                            "Tunivar ",
                            /* Alpha */Block.__(15, [/* End_of_format */0])
                          ]),
                        "Tunivar %a"
                      ]), print_name, param[0]);
    case /* Tpoly */10 :
        return Curry._4(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<hov1>",
                                      /* End_of_format */0
                                    ]),
                                  "<hov1>"
                                ]]),
                            /* String_literal */Block.__(11, [
                                "Tpoly(",
                                /* Formatting_lit */Block.__(17, [
                                    /* Break */Block.__(0, [
                                        "@,",
                                        0,
                                        0
                                      ]),
                                    /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                            /* "," */44,
                                            /* Formatting_lit */Block.__(17, [
                                                /* Break */Block.__(0, [
                                                    "@,",
                                                    0,
                                                    0
                                                  ]),
                                                /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                        /* ")" */41,
                                                        /* Formatting_lit */Block.__(17, [
                                                            /* Close_box */0,
                                                            /* End_of_format */0
                                                          ])
                                                      ])])
                                              ])
                                          ])])
                                  ])
                              ])
                          ]),
                        "@[<hov1>Tpoly(@,%a,@,%a)@]"
                      ]), raw_type, param[0], raw_type_list, param[1]);
    case /* Tpackage */11 :
        return Curry._4(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<hov1>",
                                      /* End_of_format */0
                                    ]),
                                  "<hov1>"
                                ]]),
                            /* String_literal */Block.__(11, [
                                "Tpackage(",
                                /* Formatting_lit */Block.__(17, [
                                    /* Break */Block.__(0, [
                                        "@,",
                                        0,
                                        0
                                      ]),
                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@,",
                                                0,
                                                0
                                              ]),
                                            /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                    /* ")" */41,
                                                    /* Formatting_lit */Block.__(17, [
                                                        /* Close_box */0,
                                                        /* End_of_format */0
                                                      ])
                                                  ])])
                                          ])])
                                  ])
                              ])
                          ]),
                        "@[<hov1>Tpackage(@,%a@,%a)@]"
                      ]), path, param[0], raw_type_list, param[2]);
    
  }
}

function raw_field(ppf, param) {
  if (typeof param === "number") {
    return Format.fprintf(ppf, /* Format */[
                /* String_literal */Block.__(11, [
                    "Rabsent",
                    /* End_of_format */0
                  ]),
                "Rabsent"
              ]);
  }
  if (param.tag) {
    var e = param[3];
    return Curry._5(Format.fprintf(ppf, /* Format */[
                    /* Formatting_gen */Block.__(18, [
                        /* Open_box */Block.__(1, [/* Format */[
                              /* String_literal */Block.__(11, [
                                  "<hov1>",
                                  /* End_of_format */0
                                ]),
                              "<hov1>"
                            ]]),
                        /* String_literal */Block.__(11, [
                            "Reither(",
                            /* Bool */Block.__(9, [
                                /* No_padding */0,
                                /* Char_literal */Block.__(12, [
                                    /* "," */44,
                                    /* Formatting_lit */Block.__(17, [
                                        /* Break */Block.__(0, [
                                            "@,",
                                            0,
                                            0
                                          ]),
                                        /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                /* "," */44,
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@,",
                                                        0,
                                                        0
                                                      ]),
                                                    /* Bool */Block.__(9, [
                                                        /* No_padding */0,
                                                        /* Char_literal */Block.__(12, [
                                                            /* "," */44,
                                                            /* Formatting_lit */Block.__(17, [
                                                                /* Break */Block.__(0, [
                                                                    "@,",
                                                                    0,
                                                                    0
                                                                  ]),
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* String_literal */Block.__(11, [
                                                                              "<1>",
                                                                              /* End_of_format */0
                                                                            ]),
                                                                          "<1>"
                                                                        ]]),
                                                                    /* String_literal */Block.__(11, [
                                                                        "ref",
                                                                        /* Theta */Block.__(16, [/* Formatting_lit */Block.__(17, [
                                                                                /* Close_box */0,
                                                                                /* Char_literal */Block.__(12, [
                                                                                    /* ")" */41,
                                                                                    /* Formatting_lit */Block.__(17, [
                                                                                        /* Close_box */0,
                                                                                        /* End_of_format */0
                                                                                      ])
                                                                                  ])
                                                                              ])])
                                                                      ])
                                                                  ])
                                                              ])
                                                          ])
                                                      ])
                                                  ])
                                              ])])
                                      ])
                                  ])
                              ])
                          ])
                      ]),
                    "@[<hov1>Reither(%b,@,%a,@,%b,@,@[<1>ref%t@])@]"
                  ]), param[0], raw_type_list, param[1], param[2], (function (ppf) {
                  var match = e.contents;
                  if (match !== void 0) {
                    return Curry._2(Format.fprintf(ppf, /* Format */[
                                    /* Formatting_lit */Block.__(17, [
                                        /* Break */Block.__(0, [
                                            "@,",
                                            0,
                                            0
                                          ]),
                                        /* Formatting_gen */Block.__(18, [
                                            /* Open_box */Block.__(1, [/* Format */[
                                                  /* String_literal */Block.__(11, [
                                                      "<1>",
                                                      /* End_of_format */0
                                                    ]),
                                                  "<1>"
                                                ]]),
                                            /* Char_literal */Block.__(12, [
                                                /* "(" */40,
                                                /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                        /* ")" */41,
                                                        /* Formatting_lit */Block.__(17, [
                                                            /* Close_box */0,
                                                            /* End_of_format */0
                                                          ])
                                                      ])])
                                              ])
                                          ])
                                      ]),
                                    "@,@[<1>(%a)@]"
                                  ]), raw_field, match);
                  } else {
                    return Format.fprintf(ppf, /* Format */[
                                /* String_literal */Block.__(11, [
                                    " None",
                                    /* End_of_format */0
                                  ]),
                                " None"
                              ]);
                  }
                }));
  } else {
    var match = param[0];
    if (match !== void 0) {
      return Curry._2(Format.fprintf(ppf, /* Format */[
                      /* Formatting_gen */Block.__(18, [
                          /* Open_box */Block.__(1, [/* Format */[
                                /* String_literal */Block.__(11, [
                                    "<1>",
                                    /* End_of_format */0
                                  ]),
                                "<1>"
                              ]]),
                          /* String_literal */Block.__(11, [
                              "Rpresent(Some",
                              /* Formatting_lit */Block.__(17, [
                                  /* Break */Block.__(0, [
                                      "@,",
                                      0,
                                      0
                                    ]),
                                  /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                          /* ")" */41,
                                          /* Formatting_lit */Block.__(17, [
                                              /* Close_box */0,
                                              /* End_of_format */0
                                            ])
                                        ])])
                                ])
                            ])
                        ]),
                      "@[<1>Rpresent(Some@,%a)@]"
                    ]), raw_type, match);
    } else {
      return Format.fprintf(ppf, /* Format */[
                  /* String_literal */Block.__(11, [
                      "Rpresent None",
                      /* End_of_format */0
                    ]),
                  "Rpresent None"
                ]);
    }
  }
}

function raw_type_expr(ppf, t) {
  visited.contents = /* [] */0;
  raw_type(ppf, t);
  visited.contents = /* [] */0;
  
}

print_raw = raw_type_expr;

function is_nth(param) {
  if (typeof param === "number" || param.tag) {
    return false;
  } else {
    return true;
  }
}

function compose(l1, param) {
  if (typeof param === "number") {
    return /* Map */Block.__(1, [l1]);
  } else if (param.tag) {
    return /* Map */Block.__(1, [List.map((function (param) {
                      return List.nth(l1, param);
                    }), param[0])]);
  } else {
    return /* Nth */Block.__(0, [List.nth(l1, param[0])]);
  }
}

function apply_subst(s1, tyl) {
  if (typeof s1 === "number") {
    return tyl;
  } else if (s1.tag) {
    return List.map((function (param) {
                  return List.nth(tyl, param);
                }), s1[0]);
  } else {
    return /* :: */[
            List.nth(tyl, s1[0]),
            /* [] */0
          ];
  }
}

var printing_env = {
  contents: empty
};

var printing_depth = {
  contents: 0
};

var printing_cont = {
  contents: /* [] */0
};

var printing_old = {
  contents: empty
};

var printing_pers = {
  contents: /* Empty */0
};

function compare$2(_p1, _p2) {
  while(true) {
    var p2 = _p2;
    var p1 = _p1;
    switch (p1.tag | 0) {
      case /* Pident */0 :
          return Caml_obj.caml_compare(p1, p2);
      case /* Pdot */1 :
          switch (p2.tag | 0) {
            case /* Pdot */1 :
                var c = compare$2(p1[0], p2[0]);
                if (c !== 0) {
                  return c;
                } else {
                  return Caml_primitive.caml_string_compare(p1[1], p2[1]);
                }
            case /* Pident */0 :
            case /* Papply */2 :
                return Caml_obj.caml_compare(p1, p2);
            
          }
      case /* Papply */2 :
          switch (p2.tag | 0) {
            case /* Pident */0 :
            case /* Pdot */1 :
                return Caml_obj.caml_compare(p1, p2);
            case /* Papply */2 :
                var c$1 = compare$2(p1[0], p2[0]);
                if (c$1 !== 0) {
                  return c$1;
                }
                _p2 = p2[1];
                _p1 = p1[1];
                continue ;
            
          }
      
    }
  };
}

function height$6(param) {
  if (param) {
    return param[/* h */4];
  } else {
    return 0;
  }
}

function create$7(l, x, d, r) {
  var hl = height$6(l);
  var hr = height$6(r);
  return /* Node */[
          /* l */l,
          /* v */x,
          /* d */d,
          /* r */r,
          /* h */hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        ];
}

function bal$6(l, x, d, r) {
  var hl = l ? l[/* h */4] : 0;
  var hr = r ? r[/* h */4] : 0;
  if (hl > (hr + 2 | 0)) {
    if (!l) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Map.bal"
          ];
    }
    var lr = l[/* r */3];
    var ld = l[/* d */2];
    var lv = l[/* v */1];
    var ll = l[/* l */0];
    if (height$6(ll) >= height$6(lr)) {
      return create$7(ll, lv, ld, create$7(lr, x, d, r));
    }
    if (lr) {
      return create$7(create$7(ll, lv, ld, lr[/* l */0]), lr[/* v */1], lr[/* d */2], create$7(lr[/* r */3], x, d, r));
    }
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Map.bal"
        ];
  } else {
    if (hr <= (hl + 2 | 0)) {
      return /* Node */[
              /* l */l,
              /* v */x,
              /* d */d,
              /* r */r,
              /* h */hl >= hr ? hl + 1 | 0 : hr + 1 | 0
            ];
    }
    if (!r) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Map.bal"
          ];
    }
    var rr = r[/* r */3];
    var rd = r[/* d */2];
    var rv = r[/* v */1];
    var rl = r[/* l */0];
    if (height$6(rr) >= height$6(rl)) {
      return create$7(create$7(l, x, d, rl), rv, rd, rr);
    }
    if (rl) {
      return create$7(create$7(l, x, d, rl[/* l */0]), rl[/* v */1], rl[/* d */2], create$7(rl[/* r */3], rv, rd, rr));
    }
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Map.bal"
        ];
  }
}

function add$8(x, data, m) {
  if (!m) {
    return /* Node */[
            /* l : Empty */0,
            /* v */x,
            /* d */data,
            /* r : Empty */0,
            /* h */1
          ];
  }
  var r = m[/* r */3];
  var d = m[/* d */2];
  var v = m[/* v */1];
  var l = m[/* l */0];
  var c = compare$2(x, v);
  if (c === 0) {
    if (d === data) {
      return m;
    } else {
      return /* Node */[
              /* l */l,
              /* v */x,
              /* d */data,
              /* r */r,
              /* h */m[/* h */4]
            ];
    }
  }
  if (c < 0) {
    var ll = add$8(x, data, l);
    if (l === ll) {
      return m;
    } else {
      return bal$6(ll, v, d, r);
    }
  } else {
    var rr = add$8(x, data, r);
    if (r === rr) {
      return m;
    } else {
      return bal$6(l, v, d, rr);
    }
  }
}

function find$4(x, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      throw Caml_builtin_exceptions.not_found;
    }
    var c = compare$2(x, param[/* v */1]);
    if (c === 0) {
      return param[/* d */2];
    }
    _param = c < 0 ? param[/* l */0] : param[/* r */3];
    continue ;
  };
}

var printing_map = {
  contents: /* Empty */0
};

function same_type(t, t$prime) {
  return repr(t) === repr(t$prime);
}

function index(l, x) {
  if (l) {
    if (x === l[0]) {
      return 0;
    } else {
      return 1 + index(l[1], x) | 0;
    }
  }
  throw Caml_builtin_exceptions.not_found;
}

function uniq(_param) {
  while(true) {
    var param = _param;
    if (!param) {
      return true;
    }
    var l = param[1];
    if (List.memq(param[0], l)) {
      return false;
    }
    _param = l;
    continue ;
  };
}

function normalize_type_path(cacheOpt, env, p) {
  var cache = cacheOpt !== void 0 ? cacheOpt : false;
  try {
    var match = find_type_expansion(p, env);
    var params = List.map(repr, match[0]);
    var ty = repr(match[1]);
    var match$1 = ty.desc;
    if (typeof match$1 === "number") {
      return /* tuple */[
              p,
              /* Nth */Block.__(0, [index(params, ty)])
            ];
    }
    if (match$1.tag !== /* Tconstr */3) {
      return /* tuple */[
              p,
              /* Nth */Block.__(0, [index(params, ty)])
            ];
    }
    var p1 = match$1[0];
    var tyl = List.map(repr, match$1[1]);
    if (List.length(params) === List.length(tyl) && List.for_all2((function (prim, prim$1) {
              return prim === prim$1;
            }), params, tyl)) {
      return normalize_type_path(cache, env, p1);
    }
    if (cache || List.length(params) <= List.length(tyl) || !uniq(tyl)) {
      return /* tuple */[
              p,
              /* Id */0
            ];
    }
    var l1 = List.map((function (param) {
            return index(params, param);
          }), tyl);
    var match$2 = normalize_type_path(cache, env, p1);
    return /* tuple */[
            match$2[0],
            compose(l1, match$2[1])
          ];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* tuple */[
              p,
              /* Id */0
            ];
    }
    throw exn;
  }
}

function path_size(param) {
  switch (param.tag | 0) {
    case /* Pident */0 :
        var id = param[0];
        var s = id.name;
        return /* tuple */[
                s !== "" && Caml_string.get(s, 0) === /* "_" */95 ? 10 : 1,
                -id.stamp | 0
              ];
    case /* Pdot */1 :
        var match = path_size(param[0]);
        return /* tuple */[
                1 + match[0] | 0,
                match[1]
              ];
    case /* Papply */2 :
        var match$1 = path_size(param[0]);
        return /* tuple */[
                match$1[0] + path_size(param[1])[0] | 0,
                match$1[1]
              ];
    
  }
}

function same_printing_env(env) {
  var used_pers = used_persistent(void 0);
  if (same_types(printing_old.contents, env)) {
    return equal$2(printing_pers.contents, used_pers);
  } else {
    return false;
  }
}

function set_printing_env(env) {
  printing_env.contents = real_paths.contents ? empty : env;
  if (printing_env.contents === empty || same_printing_env(env)) {
    return ;
  }
  printing_old.contents = env;
  printing_pers.contents = used_persistent(void 0);
  printing_map.contents = /* Empty */0;
  printing_depth.contents = 0;
  var partial_arg = iter_types((function (p, param) {
          var match = normalize_type_path(true, env, param[0]);
          if (match[1] !== /* Id */0) {
            return ;
          }
          var p1 = match[0];
          try {
            var r = find$4(p1, printing_map.contents);
            var match$1 = r.contents;
            if (match$1.tag) {
              r.contents = /* Paths */Block.__(0, [/* :: */[
                    p,
                    /* :: */[
                      match$1[0],
                      /* [] */0
                    ]
                  ]]);
              return ;
            } else {
              r.contents = /* Paths */Block.__(0, [/* :: */[
                    p,
                    match$1[0]
                  ]]);
              return ;
            }
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              printing_map.contents = add$8(p1, {
                    contents: /* Paths */Block.__(0, [/* :: */[
                          p,
                          /* [] */0
                        ]])
                  }, printing_map.contents);
              return ;
            }
            throw exn;
          }
        }));
  var cont = function (param) {
    return partial_arg(env, param);
  };
  printing_cont.contents = /* :: */[
    cont,
    /* [] */0
  ];
  
}

function wrap_printing_env(env, f) {
  set_printing_env(env);
  return try_finally(f, (function (param) {
                return set_printing_env(empty);
              }));
}

function is_unambiguous(path, env) {
  var l = find_shadowed_types(path, env);
  if (List.exists((function (param) {
            return same(path, param);
          }), l)) {
    return true;
  }
  if (!l) {
    return true;
  }
  var rem = l[1];
  var p = l[0];
  var normalize = function (p) {
    return normalize_type_path(true, env, p)[0];
  };
  var p$prime = normalize(p);
  if (List.for_all((function (p) {
            return same(normalize(p), p$prime);
          }), rem)) {
    return true;
  }
  var id = lid_of_path(void 0, p);
  if (List.for_all((function (p) {
            return Caml_obj.caml_equal(lid_of_path(void 0, p), id);
          }), rem)) {
    return same(p, lookup_type$1(id, env)[0]);
  } else {
    return false;
  }
}

function best_type_path(p) {
  if (real_paths.contents || printing_env.contents === empty) {
    return /* tuple */[
            p,
            /* Id */0
          ];
  }
  var match = normalize_type_path(void 0, printing_env.contents, p);
  var p$prime = match[0];
  var get_path = function (param) {
    var r = find$4(p$prime, printing_map.contents);
    while(true) {
      var match = r.contents;
      if (match.tag) {
        return match[0];
      }
      var l = match[0];
      if (!l) {
        throw Caml_builtin_exceptions.not_found;
      }
      r.contents = /* Paths */Block.__(0, [/* [] */0]);
      List.iter((function (p) {
              var match = r.contents;
              if (match.tag && Caml_obj.caml_greaterequal(path_size(p), path_size(match[0]))) {
                return ;
              }
              if (is_unambiguous(p, printing_env.contents)) {
                r.contents = /* Best */Block.__(1, [p]);
                return ;
              }
              
            }), l);
      continue ;
    };
  };
  while((function () {
          var tmp = false;
          if (printing_cont.contents !== /* [] */0) {
            var tmp$1;
            try {
              get_path(void 0);
              tmp$1 = false;
            }
            catch (exn){
              if (exn !== Caml_builtin_exceptions.not_found) {
                throw exn;
              }
              tmp$1 = true;
            }
            tmp = tmp$1;
          }
          return tmp;
        })()) {
    printing_cont.contents = List.map((function (prim) {
            return prim[1];
          }), run_iter_cont(printing_cont.contents));
    printing_depth.contents = printing_depth.contents + 1 | 0;
  };
  var p$prime$prime;
  try {
    p$prime$prime = get_path(void 0);
  }
  catch (exn){
    if (exn !== Caml_builtin_exceptions.not_found) {
      throw exn;
    }
    p$prime$prime = p$prime;
  }
  return /* tuple */[
          p$prime$prime,
          match[1]
        ];
}

var names = {
  contents: /* [] */0
};

var name_counter = {
  contents: 0
};

var named_vars = {
  contents: /* [] */0
};

function reset_names(param) {
  names.contents = /* [] */0;
  name_counter.contents = 0;
  named_vars.contents = /* [] */0;
  
}

function add_named_var(ty) {
  var match = ty.desc;
  if (typeof match === "number") {
    return ;
  }
  switch (match.tag | 0) {
    case /* Tvar */0 :
    case /* Tunivar */9 :
        break;
    default:
      return ;
  }
  var match$1 = match[0];
  if (match$1 === void 0) {
    return ;
  }
  var name = match$1;
  if (List.mem(name, named_vars.contents)) {
    return ;
  } else {
    named_vars.contents = /* :: */[
      name,
      named_vars.contents
    ];
    return ;
  }
}

function new_name(_param) {
  while(true) {
    var name;
    if (name_counter.contents < 26) {
      var c = Char.chr(97 + name_counter.contents | 0);
      name = Caml_bytes.bytes_to_string(Bytes.make(1, c));
    } else {
      var c$1 = Char.chr(97 + name_counter.contents % 26 | 0);
      name = Caml_bytes.bytes_to_string(Bytes.make(1, c$1)) + String(name_counter.contents / 26 | 0);
    }
    name_counter.contents = name_counter.contents + 1 | 0;
    if (!(List.mem(name, named_vars.contents) || List.exists((function(name){
            return function (param) {
              return name === param[1];
            }
            }(name)), names.contents))) {
      return name;
    }
    _param = void 0;
    continue ;
  };
}

function name_of_type(t) {
  try {
    return List.assq(t, names.contents);
  }
  catch (exn){
    if (exn !== Caml_builtin_exceptions.not_found) {
      throw exn;
    }
    var match = t.desc;
    var name;
    var exit = 0;
    if (typeof match === "number") {
      name = new_name(void 0);
    } else {
      switch (match.tag | 0) {
        case /* Tvar */0 :
        case /* Tunivar */9 :
            exit = 1;
            break;
        default:
          name = new_name(void 0);
      }
    }
    if (exit === 1) {
      var match$1 = match[0];
      if (match$1 !== void 0) {
        var name$1 = match$1;
        var current_name = {
          contents: name$1
        };
        var i = 0;
        while(List.exists((function (param) {
                  return current_name.contents === param[1];
                }), names.contents)) {
          current_name.contents = name$1 + String(i);
          i = i + 1 | 0;
        };
        name = current_name.contents;
      } else {
        name = new_name(void 0);
      }
    }
    if (name !== "_") {
      names.contents = /* :: */[
        /* tuple */[
          t,
          name
        ],
        names.contents
      ];
    }
    return name;
  }
}

function check_name_of_type(t) {
  name_of_type(t);
  
}

function remove_names(tyl) {
  var tyl$1 = List.map(repr, tyl);
  names.contents = List.filter((function (param) {
            return !List.memq(param[0], tyl$1);
          }))(names.contents);
  
}

var visited_objects = {
  contents: /* [] */0
};

var aliased = {
  contents: /* [] */0
};

var delayed = {
  contents: /* [] */0
};

function add_delayed(t) {
  if (!List.memq(t, delayed.contents)) {
    delayed.contents = /* :: */[
      t,
      delayed.contents
    ];
    return ;
  }
  
}

function is_aliased(ty) {
  return List.memq(proxy(ty), aliased.contents);
}

function add_alias(ty) {
  var px = proxy(ty);
  if (!is_aliased(px)) {
    aliased.contents = /* :: */[
      px,
      aliased.contents
    ];
    return add_named_var(px);
  }
  
}

function aliasable(ty) {
  var match = ty.desc;
  if (typeof match === "number") {
    return true;
  }
  switch (match.tag | 0) {
    case /* Tconstr */3 :
        return !is_nth(best_type_path(match[0])[1]);
    case /* Tvar */0 :
    case /* Tunivar */9 :
    case /* Tpoly */10 :
        return false;
    default:
      return true;
  }
}

function namable_row(row) {
  if (row.row_name !== void 0) {
    return List.for_all((function (param) {
                  var match = row_field_repr_aux(/* [] */0, param[1]);
                  if (typeof match === "number") {
                    return true;
                  }
                  if (!match.tag) {
                    return true;
                  }
                  var l = match[1];
                  if (row.row_closed) {
                    if (match[0]) {
                      return l === /* [] */0;
                    } else {
                      return List.length(l) === 1;
                    }
                  } else {
                    return false;
                  }
                }), row.row_fields);
  } else {
    return false;
  }
}

function mark_loops_rec(_visited, _ty) {
  while(true) {
    var ty = _ty;
    var visited = _visited;
    var ty$1 = repr(ty);
    var px = proxy(ty$1);
    if (List.memq(px, visited) && aliasable(ty$1)) {
      return add_alias(px);
    }
    var visited$1 = /* :: */[
      px,
      visited
    ];
    var match = ty$1.desc;
    if (typeof match === "number") {
      return ;
    }
    switch (match.tag | 0) {
      case /* Tarrow */1 :
          mark_loops_rec(visited$1, match[1]);
          _ty = match[2];
          _visited = visited$1;
          continue ;
      case /* Ttuple */2 :
          return List.iter((function(visited$1){
                    return function (param) {
                      return mark_loops_rec(visited$1, param);
                    }
                    }(visited$1)), match[0]);
      case /* Tconstr */3 :
          var match$1 = best_type_path(match[0]);
          return List.iter((function(visited$1){
                    return function (param) {
                      return mark_loops_rec(visited$1, param);
                    }
                    }(visited$1)), apply_subst(match$1[1], match[1]));
      case /* Tobject */4 :
          if (List.memq(px, visited_objects.contents)) {
            return add_alias(px);
          }
          if (opened_object(ty$1)) {
            visited_objects.contents = /* :: */[
              px,
              visited_objects.contents
            ];
          }
          var match$2 = match[1].contents;
          if (match$2 !== void 0) {
            return List.iter((function(visited$1){
                      return function (param) {
                        return mark_loops_rec(visited$1, param);
                      }
                      }(visited$1)), List.tl(match$2[1]));
          }
          var match$3 = flatten_fields(match[0]);
          return List.iter((function(visited$1){
                    return function (param) {
                      if (field_kind_repr(param[1]) === /* Fpresent */0) {
                        return mark_loops_rec(visited$1, param[2]);
                      }
                      
                    }
                    }(visited$1)), match$3[0]);
      case /* Tfield */5 :
          var ty2 = match[3];
          if (field_kind_repr(match[1]) === /* Fpresent */0) {
            mark_loops_rec(visited$1, match[2]);
            _ty = ty2;
            _visited = visited$1;
            continue ;
          } else {
            _ty = ty2;
            _visited = visited$1;
            continue ;
          }
      case /* Tlink */6 :
          return fatal_error("Printtyp.mark_loops_rec (2)");
      case /* Tsubst */7 :
          _ty = match[0];
          _visited = visited$1;
          continue ;
      case /* Tvariant */8 :
          if (List.memq(px, visited_objects.contents)) {
            return add_alias(px);
          }
          var row = row_repr_aux(/* [] */0, match[0]);
          if (!static_row(row)) {
            visited_objects.contents = /* :: */[
              px,
              visited_objects.contents
            ];
          }
          var match$4 = row.row_name;
          if (match$4 !== void 0) {
            if (namable_row(row)) {
              return List.iter((function(visited$1){
                        return function (param) {
                          return mark_loops_rec(visited$1, param);
                        }
                        }(visited$1)), match$4[1]);
            } else {
              return iter_row((function(visited$1){
                        return function (param) {
                          return mark_loops_rec(visited$1, param);
                        }
                        }(visited$1)), row);
            }
          } else {
            return iter_row((function(visited$1){
                      return function (param) {
                        return mark_loops_rec(visited$1, param);
                      }
                      }(visited$1)), row);
          }
      case /* Tvar */0 :
      case /* Tunivar */9 :
          return add_named_var(ty$1);
      case /* Tpoly */10 :
          List.iter(add_alias, match[1]);
          _ty = match[0];
          _visited = visited$1;
          continue ;
      case /* Tpackage */11 :
          return List.iter((function(visited$1){
                    return function (param) {
                      return mark_loops_rec(visited$1, param);
                    }
                    }(visited$1)), match[2]);
      
    }
  };
}

function mark_loops(ty) {
  normalize_type(empty, ty);
  return mark_loops_rec(/* [] */0, ty);
}

function reset(param) {
  unique_names.contents = /* Empty */0;
  reset_names(void 0);
  var param$1;
  visited_objects.contents = /* [] */0;
  aliased.contents = /* [] */0;
  delayed.contents = /* [] */0;
  
}

function reset_and_mark_loops_list(tyl) {
  reset(void 0);
  return List.iter(mark_loops, tyl);
}

var print_labels = {
  contents: true
};

function tree_of_typexp(sch, ty) {
  var ty$1 = repr(ty);
  var px = proxy(ty$1);
  if (List.mem_assq(px, names.contents) && !List.memq(px, delayed.contents)) {
    var mark = is_non_gen(sch, ty$1);
    return /* Otyp_var */Block.__(10, [
              mark,
              name_of_type(px)
            ]);
  } else {
    var pr_typ = function (param) {
      var match = ty$1.desc;
      if (typeof match === "number") {
        return tree_of_typobject(sch, ty$1, void 0);
      }
      switch (match.tag | 0) {
        case /* Tvar */0 :
            return /* Otyp_var */Block.__(10, [
                      is_non_gen(sch, ty$1),
                      name_of_type(ty$1)
                    ]);
        case /* Tarrow */1 :
            var l = match[0];
            var ty1 = match[1];
            var ty2 = match[2];
            var lab = print_labels.contents && l !== "" || is_optional(l) ? l : "";
            var t1;
            if (is_optional(l)) {
              var match$1 = repr(ty1).desc;
              if (typeof match$1 === "number" || match$1.tag !== /* Tconstr */3) {
                t1 = /* Otyp_stuff */Block.__(7, ["<hidden>"]);
              } else {
                var match$2 = match$1[1];
                t1 = match$2 && !(match$2[1] || !same(match$1[0], path_option)) ? tree_of_typexp(sch, match$2[0]) : /* Otyp_stuff */Block.__(7, ["<hidden>"]);
              }
            } else {
              t1 = tree_of_typexp(sch, ty1);
            }
            return /* Otyp_arrow */Block.__(1, [
                      lab,
                      t1,
                      tree_of_typexp(sch, ty2)
                    ]);
        case /* Ttuple */2 :
            return /* Otyp_tuple */Block.__(9, [List.map((function (param) {
                              return tree_of_typexp(sch, param);
                            }), match[0])]);
        case /* Tconstr */3 :
            var match$3 = best_type_path(match[0]);
            var s = match$3[1];
            var tyl$prime = apply_subst(s, match[1]);
            if (is_nth(s)) {
              return tree_of_typexp(sch, List.hd(tyl$prime));
            } else {
              return /* Otyp_constr */Block.__(3, [
                        tree_of_path(match$3[0]),
                        List.map((function (param) {
                                return tree_of_typexp(sch, param);
                              }), tyl$prime)
                      ]);
            }
        case /* Tobject */4 :
            return tree_of_typobject(sch, match[0], match[1].contents);
        case /* Tfield */5 :
            return tree_of_typobject(sch, ty$1, void 0);
        case /* Tlink */6 :
            return fatal_error("Printtyp.tree_of_typexp");
        case /* Tsubst */7 :
            return tree_of_typexp(sch, match[0]);
        case /* Tvariant */8 :
            var row = row_repr_aux(/* [] */0, match[0]);
            var fields = row.row_closed ? List.filter((function (param) {
                        return row_field_repr_aux(/* [] */0, param[1]) !== /* Rabsent */0;
                      }))(row.row_fields) : row.row_fields;
            var present = List.filter((function (param) {
                      var match = row_field_repr_aux(/* [] */0, param[1]);
                      if (typeof match === "number" || match.tag) {
                        return false;
                      } else {
                        return true;
                      }
                    }))(fields);
            var all_present = List.length(present) === List.length(fields);
            var match$4 = row.row_name;
            if (match$4 !== void 0) {
              var match$5 = match$4;
              var tyl = match$5[1];
              var p = match$5[0];
              if (namable_row(row)) {
                var match$6 = best_type_path(p);
                var s$1 = match$6[1];
                var id = tree_of_path(match$6[0]);
                var tyl$1 = apply_subst(s$1, tyl);
                var args = List.map((function (param) {
                        return tree_of_typexp(sch, param);
                      }), tyl$1);
                if (row.row_closed && all_present) {
                  if (is_nth(s$1)) {
                    return List.hd(args);
                  } else {
                    return /* Otyp_constr */Block.__(3, [
                              id,
                              args
                            ]);
                  }
                }
                var non_gen = is_non_gen(sch, px);
                var tags = all_present ? void 0 : List.map((function (prim) {
                          return prim[0];
                        }), present);
                var inh;
                var exit = 0;
                if (args) {
                  var match$7 = args[0];
                  if (typeof match$7 === "number" || !(match$7.tag === /* Otyp_constr */3 && !(args[1] || !is_nth(s$1)))) {
                    exit = 2;
                  } else {
                    inh = /* Ovar_name */Block.__(1, [
                        match$7[0],
                        match$7[1]
                      ]);
                  }
                } else {
                  exit = 2;
                }
                if (exit === 2) {
                  inh = /* Ovar_name */Block.__(1, [
                      tree_of_path(p),
                      List.map((function (param) {
                              return tree_of_typexp(sch, param);
                            }), tyl)
                    ]);
                }
                return /* Otyp_variant */Block.__(11, [
                          non_gen,
                          inh,
                          row.row_closed,
                          tags
                        ]);
              }
              
            }
            var non_gen$1 = !(row.row_closed && all_present) && is_non_gen(sch, px);
            var fields$1 = List.map((function (param) {
                    var l = param[0];
                    var match = row_field_repr_aux(/* [] */0, param[1]);
                    if (typeof match === "number") {
                      return /* tuple */[
                              l,
                              false,
                              /* [] */0
                            ];
                    }
                    if (match.tag) {
                      var c = match[0];
                      if (c && !match[1]) {
                        return /* tuple */[
                                l,
                                false,
                                /* [] */0
                              ];
                      }
                      var tyl = match[1];
                      if (c) {
                        return /* tuple */[
                                l,
                                true,
                                List.map((function (param) {
                                        return tree_of_typexp(sch, param);
                                      }), tyl)
                              ];
                      } else {
                        return /* tuple */[
                                l,
                                false,
                                List.map((function (param) {
                                        return tree_of_typexp(sch, param);
                                      }), tyl)
                              ];
                      }
                    } else {
                      var match$1 = match[0];
                      if (match$1 !== void 0) {
                        return /* tuple */[
                                l,
                                false,
                                /* :: */[
                                  tree_of_typexp(sch, match$1),
                                  /* [] */0
                                ]
                              ];
                      } else {
                        return /* tuple */[
                                l,
                                false,
                                /* [] */0
                              ];
                      }
                    }
                  }), fields);
            var tags$1 = all_present ? void 0 : List.map((function (prim) {
                      return prim[0];
                    }), present);
            return /* Otyp_variant */Block.__(11, [
                      non_gen$1,
                      /* Ovar_fields */Block.__(0, [fields$1]),
                      row.row_closed,
                      tags$1
                    ]);
        case /* Tunivar */9 :
            return /* Otyp_var */Block.__(10, [
                      false,
                      name_of_type(ty$1)
                    ]);
        case /* Tpoly */10 :
            var tyl$2 = match[1];
            var ty$2 = match[0];
            if (!tyl$2) {
              return tree_of_typexp(sch, ty$2);
            }
            var tyl$3 = List.map(repr, tyl$2);
            if (tyl$3 === /* [] */0) {
              return tree_of_typexp(sch, ty$2);
            }
            var old_delayed = delayed.contents;
            List.iter(add_delayed, tyl$3);
            var tl = List.map(name_of_type, tyl$3);
            var tr_001 = tree_of_typexp(sch, ty$2);
            var tr = /* Otyp_poly */Block.__(12, [
                tl,
                tr_001
              ]);
            remove_names(tyl$3);
            delayed.contents = old_delayed;
            return tr;
        case /* Tpackage */11 :
            var n = List.map((function (li) {
                    return $$String.concat(".", flat(/* [] */0, li));
                  }), match[1]);
            return /* Otyp_module */Block.__(13, [
                      name(void 0, match[0]),
                      n,
                      List.map((function (param) {
                              return tree_of_typexp(sch, param);
                            }), match[2])
                    ]);
        
      }
    };
    if (List.memq(px, delayed.contents)) {
      delayed.contents = List.filter((function (param) {
                return px !== param;
              }))(delayed.contents);
    }
    if (is_aliased(px) && aliasable(ty$1)) {
      name_of_type(px);
      return /* Otyp_alias */Block.__(0, [
                pr_typ(void 0),
                name_of_type(px)
              ]);
    } else {
      return pr_typ(void 0);
    }
  }
}

function tree_of_typobject(sch, fi, nm) {
  if (nm !== void 0) {
    var match = nm;
    var match$1 = match[1];
    if (!match$1) {
      return fatal_error("Printtyp.tree_of_typobject");
    }
    var non_gen = is_non_gen(sch, repr(match$1[0]));
    var args = List.map((function (param) {
            return tree_of_typexp(sch, param);
          }), match$1[1]);
    var match$2 = best_type_path(match[0]);
    if (match$2[1] !== /* Id */0) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "printtyp.ml",
              688,
              6
            ]
          ];
    }
    return /* Otyp_class */Block.__(2, [
              non_gen,
              tree_of_path(match$2[0]),
              args
            ]);
  } else {
    var pr_fields = function (fi) {
      var match = flatten_fields(fi);
      var present_fields = List.fold_right((function (param, l) {
              var match = field_kind_repr(param[1]);
              if (typeof match === "number" && match === 0) {
                return /* :: */[
                        /* tuple */[
                          param[0],
                          param[2]
                        ],
                        l
                      ];
              } else {
                return l;
              }
            }), match[0], /* [] */0);
      var sorted_fields = List.sort((function (param, param$1) {
              return Caml_primitive.caml_string_compare(param[0], param$1[0]);
            }), present_fields);
      return tree_of_typfields(sch, match[1], sorted_fields);
    };
    var match$3 = pr_fields(fi);
    return /* Otyp_object */Block.__(5, [
              match$3[0],
              match$3[1]
            ]);
  }
}

function is_non_gen(sch, ty) {
  if (sch && is_Tvar(ty)) {
    return ty.level !== 100000000;
  } else {
    return false;
  }
}

function tree_of_typfields(sch, rest, param) {
  if (param) {
    var match = param[0];
    var field_000 = match[0];
    var field_001 = tree_of_typexp(sch, match[1]);
    var field = /* tuple */[
      field_000,
      field_001
    ];
    var match$1 = tree_of_typfields(sch, rest, param[1]);
    return /* tuple */[
            /* :: */[
              field,
              match$1[0]
            ],
            match$1[1]
          ];
  } else {
    var match$2 = rest.desc;
    var rest$1;
    if (typeof match$2 === "number") {
      rest$1 = void 0;
    } else {
      switch (match$2.tag | 0) {
        case /* Tconstr */3 :
            rest$1 = false;
            break;
        case /* Tvar */0 :
        case /* Tunivar */9 :
            rest$1 = is_non_gen(sch, rest);
            break;
        default:
          rest$1 = fatal_error("typfields (1)");
      }
    }
    return /* tuple */[
            /* [] */0,
            rest$1
          ];
  }
}

function typexp$1(sch, prio, ppf, ty) {
  return Curry._2(out_type.contents, ppf, tree_of_typexp(sch, ty));
}

function type_expr$1(ppf, ty) {
  return typexp$1(false, 0, ppf, ty);
}

function type_scheme(ppf, ty) {
  reset(void 0);
  mark_loops(ty);
  return typexp$1(true, 0, ppf, ty);
}

function tree_of_type_scheme(ty) {
  reset(void 0);
  mark_loops(ty);
  return tree_of_typexp(true, ty);
}

function tree_of_constraints(params) {
  return List.fold_right((function (ty, list) {
                var ty$prime = unalias(ty);
                if (proxy(ty) === proxy(ty$prime)) {
                  return list;
                }
                var tr = tree_of_typexp(true, ty);
                return /* :: */[
                        /* tuple */[
                          tr,
                          tree_of_typexp(true, ty$prime)
                        ],
                        list
                      ];
              }), params, /* [] */0);
}

function filter_params(tyl) {
  return List.rev(List.fold_left((function (tyl, ty) {
                    var ty$1 = repr(ty);
                    if (List.memq(ty$1, tyl)) {
                      return /* :: */[
                              newty2(100000000, /* Tsubst */Block.__(7, [ty$1])),
                              tyl
                            ];
                    } else {
                      return /* :: */[
                              ty$1,
                              tyl
                            ];
                    }
                  }), /* [] */0, tyl));
}

function tree_of_label(l) {
  return /* tuple */[
          l.ld_id.name,
          l.ld_mutable === /* Mutable */1,
          tree_of_typexp(false, l.ld_type)
        ];
}

function tree_of_constructor(cd) {
  var name = cd.cd_id.name;
  var match = cd.cd_res;
  if (match === void 0) {
    return /* tuple */[
            name,
            List.map((function (param) {
                    return tree_of_typexp(false, param);
                  }), cd.cd_args),
            void 0
          ];
  }
  var nm = names.contents;
  names.contents = /* [] */0;
  var ret = tree_of_typexp(false, match);
  var args = List.map((function (param) {
          return tree_of_typexp(false, param);
        }), cd.cd_args);
  names.contents = nm;
  return /* tuple */[
          name,
          args,
          ret
        ];
}

function tree_of_type_decl(id, decl) {
  reset(void 0);
  var params = filter_params(decl.type_params);
  var match = decl.type_manifest;
  if (match !== void 0) {
    var vars = free_variables$1(void 0, match);
    List.iter((function (ty) {
            var match = ty.desc;
            if (typeof match === "number") {
              return ;
            }
            if (match.tag) {
              return ;
            }
            var match$1 = match[0];
            if (match$1 !== void 0 && match$1 === "_" && List.memq(ty, vars)) {
              ty.desc = /* Tvar */Block.__(0, [void 0]);
              return ;
            }
            
          }), params);
  }
  List.iter(add_alias, params);
  List.iter(mark_loops, params);
  List.iter(check_name_of_type, List.map(proxy, params));
  var match$1 = decl.type_manifest;
  var ty_manifest;
  if (match$1 !== void 0) {
    var ty = match$1;
    var match$2 = repr(ty);
    var match$3 = match$2.desc;
    var ty$1;
    if (typeof match$3 === "number" || match$3.tag !== /* Tvariant */8) {
      ty$1 = ty;
    } else {
      var row = row_repr_aux(/* [] */0, match$3[0]);
      var match$4 = row.row_name;
      if (match$4 !== void 0) {
        var match$5 = match$4[0];
        switch (match$5.tag | 0) {
          case /* Pident */0 :
              ty$1 = Caml_obj.caml_equal(id, match$5[0]) ? newty2(100000000, /* Tvariant */Block.__(8, [{
                          row_fields: row.row_fields,
                          row_more: row.row_more,
                          row_bound: row.row_bound,
                          row_closed: row.row_closed,
                          row_fixed: row.row_fixed,
                          row_name: void 0
                        }])) : ty;
              break;
          case /* Pdot */1 :
          case /* Papply */2 :
              ty$1 = ty;
              break;
          
        }
      } else {
        ty$1 = ty;
      }
    }
    mark_loops(ty$1);
    ty_manifest = ty$1;
  } else {
    ty_manifest = void 0;
  }
  var match$6 = decl.type_kind;
  if (typeof match$6 === "number") {
    match$6 === /* Type_abstract */0;
  } else if (match$6.tag) {
    List.iter((function (c) {
            List.iter(mark_loops, c.cd_args);
            return may(mark_loops, c.cd_res);
          }), match$6[0]);
  } else {
    List.iter((function (l) {
            return mark_loops(l.ld_type);
          }), match$6[0]);
  }
  var type_param = function (param) {
    if (typeof param === "number" || param.tag !== /* Otyp_var */10) {
      return "?";
    } else {
      return param[1];
    }
  };
  var type_defined = function (decl) {
    var match = decl.type_kind;
    var abstr;
    abstr = typeof match === "number" ? (
        match === /* Type_abstract */0 ? decl.type_manifest === void 0 || decl.type_private === /* Private */0 : decl.type_manifest === void 0
      ) : (
        match.tag ? decl.type_private === /* Private */0 || List.exists((function (cd) {
                  return cd.cd_res !== void 0;
                }), match[0]) : decl.type_private === /* Private */0
      );
    var vari = List.map2((function (ty, v) {
            if (abstr || !is_Tvar(repr(ty))) {
              return Curry._1(Types_Variance.get_upper, v);
            } else {
              return /* tuple */[
                      true,
                      true
                    ];
            }
          }), decl.type_params, decl.type_variance);
    return /* tuple */[
            id.name,
            List.map2((function (ty, cocn) {
                    return /* tuple */[
                            type_param(tree_of_typexp(false, ty)),
                            cocn
                          ];
                  }), params, vari)
          ];
  };
  var tree_of_manifest = function (ty1) {
    if (ty_manifest !== void 0) {
      return /* Otyp_manifest */Block.__(4, [
                tree_of_typexp(false, ty_manifest),
                ty1
              ]);
    } else {
      return ty1;
    }
  };
  var match$7 = type_defined(decl);
  var constraints = tree_of_constraints(params);
  var match$8 = decl.type_kind;
  var match$9;
  match$9 = typeof match$8 === "number" ? (
      match$8 === /* Type_abstract */0 ? (
          ty_manifest !== void 0 ? /* tuple */[
              tree_of_typexp(false, ty_manifest),
              decl.type_private
            ] : /* tuple */[
              /* Otyp_abstract */0,
              /* Public */1
            ]
        ) : /* tuple */[
          tree_of_manifest(/* Otyp_open */1),
          /* Public */1
        ]
    ) : (
      match$8.tag ? /* tuple */[
          tree_of_manifest(/* Otyp_sum */Block.__(8, [List.map(tree_of_constructor, match$8[0])])),
          decl.type_private
        ] : /* tuple */[
          tree_of_manifest(/* Otyp_record */Block.__(6, [List.map(tree_of_label, match$8[0])])),
          decl.type_private
        ]
    );
  return {
          otype_name: match$7[0],
          otype_params: match$7[1],
          otype_type: match$9[0],
          otype_private: match$9[1],
          otype_cstrs: constraints
        };
}

function tree_of_type_declaration(id, decl, rs) {
  return /* Osig_type */Block.__(5, [
            tree_of_type_decl(id, decl),
            rs
          ]);
}

function type_declaration$1(id, ppf, decl) {
  return Curry._2(out_sig_item.contents, ppf, tree_of_type_declaration(id, decl, /* Trec_first */1));
}

function tree_of_extension_constructor(id, ext, es) {
  reset(void 0);
  var ty_name = name(void 0, ext.ext_type_path);
  var ty_params = filter_params(ext.ext_type_params);
  List.iter(add_alias, ty_params);
  List.iter(mark_loops, ty_params);
  List.iter(check_name_of_type, List.map(proxy, ty_params));
  List.iter(mark_loops, ext.ext_args);
  may(mark_loops, ext.ext_ret_type);
  var ty_params$1 = List.map((function (ty) {
          var param = tree_of_typexp(false, ty);
          if (typeof param === "number" || param.tag !== /* Otyp_var */10) {
            return "?";
          } else {
            return param[1];
          }
        }), ty_params);
  var name$1 = id.name;
  var match = ext.ext_ret_type;
  var match$1;
  if (match !== void 0) {
    var nm = names.contents;
    names.contents = /* [] */0;
    var ret = tree_of_typexp(false, match);
    var args = List.map((function (param) {
            return tree_of_typexp(false, param);
          }), ext.ext_args);
    names.contents = nm;
    match$1 = /* tuple */[
      args,
      ret
    ];
  } else {
    match$1 = /* tuple */[
      List.map((function (param) {
              return tree_of_typexp(false, param);
            }), ext.ext_args),
      void 0
    ];
  }
  var ext_oext_args = match$1[0];
  var ext_oext_ret_type = match$1[1];
  var ext_oext_private = ext.ext_private;
  var ext$1 = {
    oext_name: name$1,
    oext_type_name: ty_name,
    oext_type_params: ty_params$1,
    oext_args: ext_oext_args,
    oext_ret_type: ext_oext_ret_type,
    oext_private: ext_oext_private
  };
  return /* Osig_typext */Block.__(2, [
            ext$1,
            es
          ]);
}

function extension_constructor$1(id, ppf, ext) {
  return Curry._2(out_sig_item.contents, ppf, tree_of_extension_constructor(id, ext, /* Text_first */0));
}

function tree_of_value_description(id, decl) {
  var id$1 = id.name;
  var ty = tree_of_type_scheme(decl.val_type);
  var match = decl.val_kind;
  var prims;
  prims = typeof match === "number" || match.tag ? /* [] */0 : description_list(match[0]);
  return /* Osig_value */Block.__(6, [
            id$1,
            ty,
            prims
          ]);
}

function value_description$1(id, ppf, decl) {
  return Curry._2(out_sig_item.contents, ppf, tree_of_value_description(id, decl));
}

function method_type(param) {
  var match = field_kind_repr(param[1]);
  var match$1 = repr(param[2]);
  if (typeof match !== "number") {
    return /* tuple */[
            match$1,
            /* [] */0
          ];
  }
  if (match !== 0) {
    return /* tuple */[
            match$1,
            /* [] */0
          ];
  }
  var match$2 = match$1.desc;
  if (typeof match$2 === "number" || match$2.tag !== /* Tpoly */10) {
    return /* tuple */[
            match$1,
            /* [] */0
          ];
  } else {
    return /* tuple */[
            match$2[0],
            match$2[1]
          ];
  }
}

function prepare_class_type(params, _param) {
  while(true) {
    var param = _param;
    switch (param.tag | 0) {
      case /* Cty_constr */0 :
          var cty = param[2];
          var tyl = param[1];
          var sty = repr(signature_of_class_type(cty).csig_self);
          if (!(List.memq(proxy(sty), visited_objects.contents) || !List.for_all(is_Tvar, params) || List.exists((function(sty){
                  return function (param) {
                    return deep_occur(sty, param);
                  }
                  }(sty)), tyl))) {
            return List.iter(mark_loops, tyl);
          }
          _param = cty;
          continue ;
      case /* Cty_signature */1 :
          var sign = param[0];
          var sty$1 = repr(sign.csig_self);
          var px = proxy(sty$1);
          if (List.memq(px, visited_objects.contents)) {
            add_alias(sty$1);
          } else {
            visited_objects.contents = /* :: */[
              px,
              visited_objects.contents
            ];
          }
          var match = flatten_fields(object_fields(sign.csig_self));
          List.iter((function (met) {
                  return mark_loops(method_type(met)[0]);
                }), match[0]);
          return iter$1((function (param, param$1) {
                        return mark_loops(param$1[2]);
                      }), sign.csig_vars);
      case /* Cty_arrow */2 :
          mark_loops(param[1]);
          _param = param[2];
          continue ;
      
    }
  };
}

function tree_of_class_type(sch, params, _param) {
  while(true) {
    var param = _param;
    switch (param.tag | 0) {
      case /* Cty_constr */0 :
          var cty = param[2];
          var sty = repr(signature_of_class_type(cty).csig_self);
          if (!(List.memq(proxy(sty), visited_objects.contents) || !List.for_all(is_Tvar, params))) {
            return /* Octy_constr */Block.__(0, [
                      tree_of_path(param[0]),
                      List.map((function (param) {
                              return tree_of_typexp(true, param);
                            }), param[1])
                    ]);
          }
          _param = cty;
          continue ;
      case /* Cty_signature */1 :
          var sign = param[0];
          var sty$1 = repr(sign.csig_self);
          var self_ty = is_aliased(sty$1) ? /* Otyp_var */Block.__(10, [
                false,
                name_of_type(proxy(sty$1))
              ]) : void 0;
          var match = flatten_fields(object_fields(sign.csig_self));
          var csil = List.fold_left((function (csil, param) {
                  return /* :: */[
                          /* Ocsg_constraint */Block.__(0, [
                              param[0],
                              param[1]
                            ]),
                          csil
                        ];
                }), /* [] */0, tree_of_constraints(params));
          var all_vars = fold((function (l, param, all) {
                  return /* :: */[
                          /* tuple */[
                            l,
                            param[0],
                            param[1],
                            param[2]
                          ],
                          all
                        ];
                }), sign.csig_vars, /* [] */0);
          var all_vars$1 = List.rev(all_vars);
          var csil$1 = List.fold_left((function (csil, param) {
                  return /* :: */[
                          /* Ocsg_value */Block.__(2, [
                              param[0],
                              param[1] === /* Mutable */1,
                              param[2] === /* Virtual */0,
                              tree_of_typexp(sch, param[3])
                            ]),
                          csil
                        ];
                }), csil, all_vars$1);
          var partial_arg = sign.csig_concr;
          var csil$2 = List.fold_left((function(partial_arg){
              return function (param, param$1) {
                var lab = param$1[0];
                if (lab === dummy_method) {
                  return param;
                }
                var kind = field_kind_repr(param$1[1]);
                var priv = kind !== /* Fpresent */0;
                var virt = !mem$2(lab, partial_arg);
                var match = method_type(/* tuple */[
                      lab,
                      kind,
                      param$1[2]
                    ]);
                var tty = tree_of_typexp(sch, match[0]);
                remove_names(match[1]);
                return /* :: */[
                        /* Ocsg_method */Block.__(1, [
                            lab,
                            priv,
                            virt,
                            tty
                          ]),
                        param
                      ];
              }
              }(partial_arg)), csil$1, match[0]);
          return /* Octy_signature */Block.__(2, [
                    self_ty,
                    List.rev(csil$2)
                  ]);
      case /* Cty_arrow */2 :
          var ty = param[1];
          var l = param[0];
          var lab = print_labels.contents && l !== "" || is_optional(l) ? l : "";
          var ty$1;
          if (is_optional(l)) {
            var match$1 = repr(ty).desc;
            var exit = 0;
            if (typeof match$1 === "number" || match$1.tag !== /* Tconstr */3) {
              exit = 1;
            } else {
              var match$2 = match$1[1];
              if (match$2 && !(match$2[1] || !same(match$1[0], path_option))) {
                ty$1 = match$2[0];
              } else {
                exit = 1;
              }
            }
            if (exit === 1) {
              ty$1 = newconstr(/* Pident */Block.__(0, [create("<hidden>")]), /* [] */0);
            }
            
          } else {
            ty$1 = ty;
          }
          var tr = tree_of_typexp(sch, ty$1);
          return /* Octy_arrow */Block.__(1, [
                    lab,
                    tr,
                    tree_of_class_type(sch, params, param[2])
                  ]);
      
    }
  };
}

function class_type$2(ppf, cty) {
  reset(void 0);
  prepare_class_type(/* [] */0, cty);
  return Curry._2(out_class_type.contents, ppf, tree_of_class_type(false, /* [] */0, cty));
}

function tree_of_class_param(param, variance) {
  var match = tree_of_typexp(true, param);
  var tmp;
  tmp = typeof match === "number" || match.tag !== /* Otyp_var */10 ? "?" : match[1];
  return /* tuple */[
          tmp,
          is_Tvar(repr(param)) ? /* tuple */[
              true,
              true
            ] : variance
        ];
}

function class_variance(param) {
  return List.map((function (v) {
                return /* tuple */[
                        Curry._2(Types_Variance.mem, /* May_pos */0, v),
                        Curry._2(Types_Variance.mem, /* May_neg */1, v)
                      ];
              }), param);
}

function tree_of_class_declaration(id, cl, rs) {
  var params = filter_params(cl.cty_params);
  reset(void 0);
  List.iter(add_alias, params);
  prepare_class_type(params, cl.cty_type);
  var sty = repr(signature_of_class_type(cl.cty_type).csig_self);
  List.iter(mark_loops, params);
  List.iter(check_name_of_type, List.map(proxy, params));
  if (is_aliased(sty)) {
    var t = proxy(sty);
    name_of_type(t);
  }
  var vir_flag = cl.cty_new === void 0;
  return /* Osig_class */Block.__(0, [
            vir_flag,
            id.name,
            List.map2(tree_of_class_param, params, class_variance(cl.cty_variance)),
            tree_of_class_type(true, params, cl.cty_type),
            rs
          ]);
}

function class_declaration$1(id, ppf, cl) {
  return Curry._2(out_sig_item.contents, ppf, tree_of_class_declaration(id, cl, /* Trec_first */1));
}

function tree_of_cltype_declaration(id, cl, rs) {
  var params = List.map(repr, cl.clty_params);
  reset(void 0);
  List.iter(add_alias, params);
  prepare_class_type(params, cl.clty_type);
  var sty = repr(signature_of_class_type(cl.clty_type).csig_self);
  List.iter(mark_loops, params);
  List.iter(check_name_of_type, List.map(proxy, params));
  if (is_aliased(sty)) {
    var t = proxy(sty);
    name_of_type(t);
  }
  var sign = signature_of_class_type(cl.clty_type);
  var match = flatten_fields(object_fields(sign.csig_self));
  var virt = List.exists((function (param) {
          var lab = param[0];
          return !(lab === dummy_method || mem$2(lab, sign.csig_concr));
        }), match[0]) || fold((function (param, param$1, b) {
          if (param$1[1] === /* Virtual */0) {
            return true;
          } else {
            return b;
          }
        }), sign.csig_vars, false);
  return /* Osig_class_type */Block.__(1, [
            virt,
            id.name,
            List.map2(tree_of_class_param, params, class_variance(cl.clty_variance)),
            tree_of_class_type(true, params, cl.clty_type),
            rs
          ]);
}

function cltype_declaration$1(id, ppf, cl) {
  return Curry._2(out_sig_item.contents, ppf, tree_of_cltype_declaration(id, cl, /* Trec_first */1));
}

function wrap_env(fenv, ftree, arg) {
  var env = printing_env.contents;
  set_printing_env(Curry._1(fenv, env));
  var tree = Curry._1(ftree, arg);
  set_printing_env(env);
  return tree;
}

function filter_rem_sig(item, rem) {
  switch (item.tag | 0) {
    case /* Sig_class */5 :
        if (!rem) {
          return /* tuple */[
                  /* [] */0,
                  rem
                ];
        }
        var match = rem[1];
        if (!match) {
          return /* tuple */[
                  /* [] */0,
                  rem
                ];
        }
        var match$1 = match[1];
        if (match$1) {
          return /* tuple */[
                  /* :: */[
                    rem[0],
                    /* :: */[
                      match[0],
                      /* :: */[
                        match$1[0],
                        /* [] */0
                      ]
                    ]
                  ],
                  match$1[1]
                ];
        } else {
          return /* tuple */[
                  /* [] */0,
                  rem
                ];
        }
    case /* Sig_class_type */6 :
        if (!rem) {
          return /* tuple */[
                  /* [] */0,
                  rem
                ];
        }
        var match$2 = rem[1];
        if (match$2) {
          return /* tuple */[
                  /* :: */[
                    rem[0],
                    /* :: */[
                      match$2[0],
                      /* [] */0
                    ]
                  ],
                  match$2[1]
                ];
        } else {
          return /* tuple */[
                  /* [] */0,
                  rem
                ];
        }
    default:
      return /* tuple */[
              /* [] */0,
              rem
            ];
  }
}

var dummy = {
  type_params: /* [] */0,
  type_arity: 0,
  type_kind: /* Type_abstract */0,
  type_private: /* Public */1,
  type_manifest: void 0,
  type_variance: /* [] */0,
  type_newtype_level: void 0,
  type_loc: none,
  type_attributes: /* [] */0
};

function hide_rec_items(param) {
  if (!param) {
    return ;
  }
  var match = param[0];
  if (match.tag !== /* Sig_type */1) {
    return ;
  }
  if (!(match[2] === /* Trec_first */1 && !real_paths.contents)) {
    return ;
  }
  var get_ids = function (param) {
    if (!param) {
      return /* [] */0;
    }
    var match = param[0];
    if (match.tag === /* Sig_type */1 && match[2] >= 2) {
      return /* :: */[
              match[0],
              get_ids(param[1])
            ];
    } else {
      return /* [] */0;
    }
  };
  var ids_000 = match[0];
  var ids_001 = get_ids(param[1]);
  var ids = /* :: */[
    ids_000,
    ids_001
  ];
  return set_printing_env(List.fold_right((function (id) {
                    var partial_arg = rename(id);
                    return (function (param) {
                        return add_type$1(false, partial_arg, dummy, param);
                      });
                  }), ids, printing_env.contents));
}

function tree_of_modtype(param) {
  switch (param.tag | 0) {
    case /* Mty_ident */0 :
        return /* Omty_ident */Block.__(1, [tree_of_path(param[0])]);
    case /* Mty_signature */1 :
        return /* Omty_signature */Block.__(2, [tree_of_signature(param[0])]);
    case /* Mty_functor */2 :
        var ty_res = param[2];
        var ty_arg = param[1];
        var param$1 = param[0];
        var res;
        if (ty_arg !== void 0) {
          var mty = ty_arg;
          var partial_arg = true;
          res = wrap_env((function (param$2) {
                  return add_module$1(partial_arg, param$1, mty, param$2);
                }), tree_of_modtype, ty_res);
        } else {
          res = tree_of_modtype(ty_res);
        }
        return /* Omty_functor */Block.__(0, [
                  param$1.name,
                  may_map(tree_of_modtype, ty_arg),
                  res
                ]);
    case /* Mty_alias */3 :
        return /* Omty_alias */Block.__(3, [tree_of_path(param[0])]);
    
  }
}

function tree_of_signature(sg) {
  var partial_arg = printing_env.contents;
  return wrap_env((function (env) {
                return env;
              }), (function (param) {
                return tree_of_signature_rec(partial_arg, false, param);
              }), sg);
}

function tree_of_signature_rec(env$prime, in_type_group, param) {
  if (!param) {
    return /* [] */0;
  }
  var item = param[0];
  var in_type_group$1;
  var exit = 0;
  if (in_type_group) {
    if (item.tag === /* Sig_type */1) {
      if (item[2] >= 2) {
        in_type_group$1 = true;
      } else {
        exit = 1;
      }
    } else {
      set_printing_env(env$prime);
      in_type_group$1 = false;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    set_printing_env(env$prime);
    in_type_group$1 = item.tag === /* Sig_type */1 && item[2] < 2 ? true : false;
  }
  var match = filter_rem_sig(item, param[1]);
  var rem = match[1];
  var trees;
  switch (item.tag | 0) {
    case /* Sig_value */0 :
        trees = /* :: */[
          tree_of_value_description(item[0], item[1]),
          /* [] */0
        ];
        break;
    case /* Sig_type */1 :
        var id = item[0];
        if (is_row_name(id.name)) {
          trees = /* [] */0;
        } else {
          hide_rec_items(/* :: */[
                item,
                rem
              ]);
          trees = /* :: */[
            /* Osig_type */Block.__(5, [
                tree_of_type_decl(id, item[1]),
                item[2]
              ]),
            /* [] */0
          ];
        }
        break;
    case /* Sig_typext */2 :
        trees = /* :: */[
          tree_of_extension_constructor(item[0], item[1], item[2]),
          /* [] */0
        ];
        break;
    case /* Sig_module */3 :
        trees = /* :: */[
          /* Osig_module */Block.__(4, [
              item[0].name,
              tree_of_modtype(item[1].md_type),
              item[2]
            ]),
          /* [] */0
        ];
        break;
    case /* Sig_modtype */4 :
        trees = /* :: */[
          tree_of_modtype_declaration(item[0], item[1]),
          /* [] */0
        ];
        break;
    case /* Sig_class */5 :
        trees = /* :: */[
          tree_of_class_declaration(item[0], item[1], item[2]),
          /* [] */0
        ];
        break;
    case /* Sig_class_type */6 :
        trees = /* :: */[
          tree_of_cltype_declaration(item[0], item[1], item[2]),
          /* [] */0
        ];
        break;
    
  }
  var env$prime$1 = add_signature(/* :: */[
        item,
        match[0]
      ], env$prime);
  return Pervasives.$at(trees, tree_of_signature_rec(env$prime$1, in_type_group$1, rem));
}

function tree_of_modtype_declaration(id, decl) {
  var match = decl.mtd_type;
  var mty = match !== void 0 ? tree_of_modtype(match) : /* Omty_abstract */0;
  return /* Osig_modtype */Block.__(3, [
            id.name,
            mty
          ]);
}

function modtype$1(ppf, mty) {
  return Curry._2(out_module_type.contents, ppf, tree_of_modtype(mty));
}

function modtype_declaration$1(id, ppf, decl) {
  return Curry._2(out_sig_item.contents, ppf, tree_of_modtype_declaration(id, decl));
}

function print_signature(ppf, tree) {
  return Curry._2(Format.fprintf(ppf, /* Format */[
                  /* Formatting_gen */Block.__(18, [
                      /* Open_box */Block.__(1, [/* Format */[
                            /* String_literal */Block.__(11, [
                                "<v>",
                                /* End_of_format */0
                              ]),
                            "<v>"
                          ]]),
                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                              /* Close_box */0,
                              /* End_of_format */0
                            ])])
                    ]),
                  "@[<v>%a@]"
                ]), out_signature.contents, tree);
}

function signature$3(ppf, sg) {
  return Curry._2(Format.fprintf(ppf, /* Format */[
                  /* Alpha */Block.__(15, [/* End_of_format */0]),
                  "%a"
                ]), print_signature, tree_of_signature(sg));
}

function same_path(t, t$prime) {
  var t$1 = repr(t);
  var t$prime$1 = repr(t$prime);
  if (t$1 === t$prime$1) {
    return true;
  }
  var match = t$1.desc;
  var match$1 = t$prime$1.desc;
  if (typeof match === "number") {
    return false;
  }
  if (match.tag !== /* Tconstr */3) {
    return false;
  }
  if (typeof match$1 === "number") {
    return false;
  }
  if (match$1.tag !== /* Tconstr */3) {
    return false;
  }
  var match$2 = best_type_path(match[0]);
  var s1 = match$2[1];
  var match$3 = best_type_path(match$1[0]);
  var s2 = match$3[1];
  var exit = 0;
  if (typeof s1 === "number") {
    exit = 1;
  } else {
    if (!s1.tag) {
      if (typeof s2 === "number" || s2.tag) {
        return false;
      } else {
        return s1[0] === s2[0];
      }
    }
    exit = 1;
  }
  if (exit === 1) {
    if (typeof s2 !== "number" && !s2.tag) {
      return false;
    }
    if (!same(match$2[0], match$3[0])) {
      return false;
    }
    var tl = apply_subst(s1, match[1]);
    var tl$prime = apply_subst(s2, match$1[1]);
    if (List.length(tl) === List.length(tl$prime)) {
      return List.for_all2(same_type, tl, tl$prime);
    } else {
      return false;
    }
  }
  
}

function type_expansion(t, ppf, t$prime) {
  if (same_path(t, t$prime)) {
    return type_expr$1(ppf, t);
  }
  var t$prime$1 = proxy(t) === proxy(t$prime) ? unalias(t$prime) : t$prime;
  return Curry._4(Format.fprintf(ppf, /* Format */[
                  /* Formatting_gen */Block.__(18, [
                      /* Open_box */Block.__(1, [/* Format */[
                            /* String_literal */Block.__(11, [
                                "<2>",
                                /* End_of_format */0
                              ]),
                            "<2>"
                          ]]),
                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                              /* Break */Block.__(0, [
                                  "@ ",
                                  1,
                                  0
                                ]),
                              /* Char_literal */Block.__(12, [
                                  /* "=" */61,
                                  /* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@ ",
                                          1,
                                          0
                                        ]),
                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                              /* Close_box */0,
                                              /* End_of_format */0
                                            ])])
                                    ])
                                ])
                            ])])
                    ]),
                  "@[<2>%a@ =@ %a@]"
                ]), type_expr$1, t, type_expr$1, t$prime$1);
}

function type_path_expansion(tp, ppf, tp$prime) {
  if (same(tp, tp$prime)) {
    return path(ppf, tp);
  } else {
    return Curry._4(Format.fprintf(ppf, /* Format */[
                    /* Formatting_gen */Block.__(18, [
                        /* Open_box */Block.__(1, [/* Format */[
                              /* String_literal */Block.__(11, [
                                  "<2>",
                                  /* End_of_format */0
                                ]),
                              "<2>"
                            ]]),
                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                /* Break */Block.__(0, [
                                    "@ ",
                                    1,
                                    0
                                  ]),
                                /* Char_literal */Block.__(12, [
                                    /* "=" */61,
                                    /* Formatting_lit */Block.__(17, [
                                        /* Break */Block.__(0, [
                                            "@ ",
                                            1,
                                            0
                                          ]),
                                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                /* Close_box */0,
                                                /* End_of_format */0
                                              ])])
                                      ])
                                  ])
                              ])])
                      ]),
                    "@[<2>%a@ =@ %a@]"
                  ]), path, tp, path, tp$prime);
  }
}

function trace(fst, txt, ppf, param) {
  if (!param) {
    return ;
  }
  var match = param[1];
  if (!match) {
    return ;
  }
  var match$1 = match[0];
  var t2 = match$1[0];
  var match$2 = param[0];
  var t1 = match$2[0];
  if (!fst) {
    Format.fprintf(ppf, /* Format */[
          /* Formatting_lit */Block.__(17, [
              /* Break */Block.__(0, [
                  "@,",
                  0,
                  0
                ]),
              /* End_of_format */0
            ]),
          "@,"
        ]);
  }
  return Curry._7(Format.fprintf(ppf, /* Format */[
                  /* Formatting_gen */Block.__(18, [
                      /* Open_box */Block.__(1, [/* Format */[
                            /* End_of_format */0,
                            ""
                          ]]),
                      /* String_literal */Block.__(11, [
                          "Type",
                          /* Formatting_lit */Block.__(17, [
                              /* Break */Block.__(0, [
                                  "@;<1 2>",
                                  1,
                                  2
                                ]),
                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@ ",
                                          1,
                                          0
                                        ]),
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* Formatting_lit */Block.__(17, [
                                              /* Break */Block.__(0, [
                                                  "@;<1 2>",
                                                  1,
                                                  2
                                                ]),
                                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                      /* Close_box */0,
                                                      /* Char_literal */Block.__(12, [
                                                          /* " " */32,
                                                          /* Alpha */Block.__(15, [/* End_of_format */0])
                                                        ])
                                                    ])])
                                            ])
                                        ])
                                    ])])
                            ])
                        ])
                    ]),
                  "@[Type@;<1 2>%a@ %s@;<1 2>%a@] %a"
                ]), (function (param, param$1) {
                return type_expansion(t1, param, param$1);
              }), match$2[1], txt, (function (param, param$1) {
                return type_expansion(t2, param, param$1);
              }), match$1[1], (function (param, param$1) {
                return trace(false, txt, param, param$1);
              }), match[1]);
}

function filter_trace(keep_last, param) {
  if (!param) {
    return /* [] */0;
  }
  var match = param[1];
  if (!match) {
    return /* [] */0;
  }
  var rem = match[1];
  var match$1 = match[0];
  var t2$prime = match$1[1];
  var t2 = match$1[0];
  var match$2 = param[0];
  var t1$prime = match$2[1];
  var t1 = match$2[0];
  if (!rem && (is_Tvar(t1$prime) || is_Tvar(t2$prime))) {
    return /* [] */0;
  }
  var rem$prime = filter_trace(keep_last, rem);
  if (is_constr_row(t1$prime) || is_constr_row(t2$prime) || same_path(t1, t1$prime) && same_path(t2, t2$prime) && !(keep_last && rem$prime === /* [] */0)) {
    return rem$prime;
  } else {
    return /* :: */[
            /* tuple */[
              t1,
              t1$prime
            ],
            /* :: */[
              /* tuple */[
                t2,
                t2$prime
              ],
              rem$prime
            ]
          ];
  }
}

function type_path_list(ppf, param) {
  if (!param) {
    return ;
  }
  var rem = param[1];
  var match = param[0];
  var tp$prime = match[1];
  var tp = match[0];
  if (rem) {
    return Curry._4(Format.fprintf(ppf, /* Format */[
                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                            /* Break */Block.__(0, [
                                "@;<2 0>",
                                2,
                                0
                              ]),
                            /* Alpha */Block.__(15, [/* End_of_format */0])
                          ])]),
                    "%a@;<2 0>%a"
                  ]), (function (param, param$1) {
                  return type_path_expansion(tp, param, param$1);
                }), tp$prime, type_path_list, rem);
  } else {
    return type_path_expansion(tp, ppf, tp$prime);
  }
}

function hide_variant_name(t) {
  var t$1 = repr(t);
  var match = t$1.desc;
  if (typeof match === "number") {
    return t;
  }
  if (match.tag !== /* Tvariant */8) {
    return t;
  }
  var row = match[0];
  if (row_repr_aux(/* [] */0, row).row_name === void 0) {
    return t;
  }
  var init = row_repr_aux(/* [] */0, row);
  var level = row_more(row).level;
  return newty2(t$1.level, /* Tvariant */Block.__(8, [{
                  row_fields: init.row_fields,
                  row_more: newty2(level, /* Tvar */Block.__(0, [void 0])),
                  row_bound: init.row_bound,
                  row_closed: init.row_closed,
                  row_fixed: init.row_fixed,
                  row_name: void 0
                }]));
}

function prepare_expansion(param) {
  var t = param[0];
  var t$prime = hide_variant_name(param[1]);
  mark_loops(t);
  if (!same_path(t, t$prime)) {
    mark_loops(t$prime);
  }
  return /* tuple */[
          t,
          t$prime
        ];
}

function may_prepare_expansion(compact, param) {
  var t$prime = param[1];
  var t = param[0];
  var match = repr(t$prime).desc;
  if (typeof match === "number") {
    return prepare_expansion(/* tuple */[
                t,
                t$prime
              ]);
  }
  switch (match.tag | 0) {
    case /* Tobject */4 :
    case /* Tvariant */8 :
        break;
    default:
      return prepare_expansion(/* tuple */[
                  t,
                  t$prime
                ]);
  }
  if (compact) {
    mark_loops(t);
    return /* tuple */[
            t,
            t
          ];
  } else {
    return prepare_expansion(/* tuple */[
                t,
                t$prime
              ]);
  }
}

function print_tags(ppf, fields) {
  if (fields) {
    Curry._1(Format.fprintf(ppf, /* Format */[
              /* Char_literal */Block.__(12, [
                  /* "`" */96,
                  /* String */Block.__(2, [
                      /* No_padding */0,
                      /* End_of_format */0
                    ])
                ]),
              "`%s"
            ]), fields[0][0]);
    return List.iter((function (param) {
                  return Curry._1(Format.fprintf(ppf, /* Format */[
                                  /* Char_literal */Block.__(12, [
                                      /* "," */44,
                                      /* Formatting_lit */Block.__(17, [
                                          /* Break */Block.__(0, [
                                              "@ ",
                                              1,
                                              0
                                            ]),
                                          /* Char_literal */Block.__(12, [
                                              /* "`" */96,
                                              /* String */Block.__(2, [
                                                  /* No_padding */0,
                                                  /* End_of_format */0
                                                ])
                                            ])
                                        ])
                                    ]),
                                  ",@ `%s"
                                ]), param[0]);
                }), fields[1]);
  }
  
}

function has_explanation(unif, t3, t4) {
  var match = t3.desc;
  var match$1 = t4.desc;
  var exit = 0;
  var exit$1 = 0;
  if (typeof match === "number") {
    if (typeof match$1 === "number") {
      exit = 2;
    } else {
      switch (match$1.tag | 0) {
        case /* Tvar */0 :
            exit$1 = 3;
            break;
        case /* Tconstr */3 :
            return true;
        default:
          exit = 2;
      }
    }
  } else {
    switch (match.tag | 0) {
      case /* Tvar */0 :
          return true;
      case /* Tconstr */3 :
          if (typeof match$1 === "number") {
            return true;
          }
          if (match$1.tag) {
            exit = 2;
          } else {
            exit$1 = 3;
          }
          break;
      case /* Tfield */5 :
          var match$2 = match[3].desc;
          var exit$2 = 0;
          if (typeof match$2 === "number" && typeof match$1 !== "number") {
            switch (match$1.tag | 0) {
              case /* Tvar */0 :
                  exit$1 = 3;
                  break;
              case /* Tconstr */3 :
                  exit$2 = 4;
                  break;
              case /* Tfield */5 :
                  var match$3 = match$1[3].desc;
                  if (typeof match$3 === "number") {
                    return match[0] === match$1[0];
                  } else {
                    return false;
                  }
              default:
                return false;
            }
          } else {
            exit$2 = 4;
          }
          if (exit$2 === 4) {
            if (typeof match$1 === "number") {
              return true;
            }
            switch (match$1.tag | 0) {
              case /* Tvar */0 :
                  exit$1 = 3;
                  break;
              case /* Tconstr */3 :
                  return true;
              default:
                return false;
            }
          }
          break;
      case /* Tvariant */8 :
          if (typeof match$1 === "number") {
            return false;
          }
          switch (match$1.tag | 0) {
            case /* Tvar */0 :
                exit$1 = 3;
                break;
            case /* Tvariant */8 :
                return true;
            default:
              return false;
          }
          break;
      default:
        exit$1 = 3;
    }
  }
  if (exit$1 === 3) {
    if (typeof match$1 === "number") {
      exit = 2;
    } else {
      if (!match$1.tag) {
        return true;
      }
      exit = 2;
    }
  }
  if (exit === 2 && typeof match !== "number" && match.tag !== /* Tconstr */3) {
    return false;
  }
  if (typeof match$1 === "number" || match$1.tag !== /* Tfield */5) {
    return false;
  } else {
    return true;
  }
}

function mismatch(unif, param) {
  if (!param) {
    return ;
  }
  var match = param[1];
  if (!match) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "printtyp.ml",
            1339,
            9
          ]
        ];
  }
  var t$prime = match[0][1];
  var t = param[0][1];
  var m = mismatch(unif, match[1]);
  if (m !== void 0) {
    return m;
  } else if (has_explanation(unif, t, t$prime)) {
    return /* tuple */[
            t,
            t$prime
          ];
  } else {
    return ;
  }
}

function explanation(unif, mis, ppf) {
  if (mis === void 0) {
    return ;
  }
  var match = mis;
  var t3 = match[0];
  var t4 = match[1];
  var match$1 = t3.desc;
  var match$2 = t4.desc;
  var exit = 0;
  var exit$1 = 0;
  var lab;
  var exit$2 = 0;
  var exit$3 = 0;
  var exit$4 = 0;
  if (typeof match$1 === "number") {
    if (typeof match$2 === "number") {
      exit = 2;
    } else {
      switch (match$2.tag | 0) {
        case /* Tvar */0 :
            exit$4 = 9;
            break;
        case /* Tconstr */3 :
            exit = 1;
            break;
        case /* Tfield */5 :
            exit$2 = 7;
            break;
        default:
          exit = 2;
      }
    }
  } else {
    switch (match$1.tag | 0) {
      case /* Tvar */0 :
          if (typeof match$2 === "number") {
            exit$1 = 5;
          } else {
            switch (match$2.tag | 0) {
              case /* Ttuple */2 :
                  exit$1 = match$2[0] ? 5 : 3;
                  break;
              case /* Tconstr */3 :
                  var p = match$2[0];
                  if (unif && t3.level < binding_time(p)) {
                    return Curry._2(Format.fprintf(ppf, /* Format */[
                                    /* Formatting_lit */Block.__(17, [
                                        /* Break */Block.__(0, [
                                            "@,",
                                            0,
                                            0
                                          ]),
                                        /* Formatting_gen */Block.__(18, [
                                            /* Open_box */Block.__(1, [/* Format */[
                                                  /* End_of_format */0,
                                                  ""
                                                ]]),
                                            /* String_literal */Block.__(11, [
                                                "The type constructor",
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@;<1 2>",
                                                        1,
                                                        2
                                                      ]),
                                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                            /* Break */Block.__(0, [
                                                                "@ ",
                                                                1,
                                                                0
                                                              ]),
                                                            /* String_literal */Block.__(11, [
                                                                "would escape its scope",
                                                                /* Formatting_lit */Block.__(17, [
                                                                    /* Close_box */0,
                                                                    /* End_of_format */0
                                                                  ])
                                                              ])
                                                          ])])
                                                  ])
                                              ])
                                          ])
                                      ]),
                                    "@,@[The type constructor@;<1 2>%a@ would escape its scope@]"
                                  ]), path, p);
                  }
                  exit$1 = 5;
                  break;
              case /* Tunivar */9 :
                  exit$1 = 4;
                  break;
              default:
                exit$1 = 5;
            }
          }
          break;
      case /* Ttuple */2 :
          if (match$1[0]) {
            exit$4 = 9;
          } else if (typeof match$2 === "number") {
            exit = 2;
          } else {
            switch (match$2.tag | 0) {
              case /* Tvar */0 :
                  exit$1 = 3;
                  break;
              case /* Tfield */5 :
                  exit$2 = 7;
                  break;
              default:
                exit = 2;
            }
          }
          break;
      case /* Tconstr */3 :
          var p$1 = match$1[0];
          if (typeof match$2 === "number") {
            exit = 1;
          } else {
            switch (match$2.tag | 0) {
              case /* Tvar */0 :
                  if (unif && t4.level < binding_time(p$1)) {
                    return Curry._2(Format.fprintf(ppf, /* Format */[
                                    /* Formatting_lit */Block.__(17, [
                                        /* Break */Block.__(0, [
                                            "@,",
                                            0,
                                            0
                                          ]),
                                        /* Formatting_gen */Block.__(18, [
                                            /* Open_box */Block.__(1, [/* Format */[
                                                  /* End_of_format */0,
                                                  ""
                                                ]]),
                                            /* String_literal */Block.__(11, [
                                                "The type constructor",
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@;<1 2>",
                                                        1,
                                                        2
                                                      ]),
                                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                            /* Break */Block.__(0, [
                                                                "@ ",
                                                                1,
                                                                0
                                                              ]),
                                                            /* String_literal */Block.__(11, [
                                                                "would escape its scope",
                                                                /* Formatting_lit */Block.__(17, [
                                                                    /* Close_box */0,
                                                                    /* End_of_format */0
                                                                  ])
                                                              ])
                                                          ])])
                                                  ])
                                              ])
                                          ])
                                      ]),
                                    "@,@[The type constructor@;<1 2>%a@ would escape its scope@]"
                                  ]), path, p$1);
                  }
                  exit$4 = 9;
                  break;
              case /* Tfield */5 :
                  exit$2 = 7;
                  break;
              default:
                exit = 2;
            }
          }
          break;
      case /* Tvariant */8 :
          if (typeof match$2 === "number") {
            exit = 2;
          } else {
            switch (match$2.tag | 0) {
              case /* Tvar */0 :
                  exit$4 = 9;
                  break;
              case /* Tfield */5 :
                  exit$2 = 7;
                  break;
              case /* Tvariant */8 :
                  var row1 = row_repr_aux(/* [] */0, match$1[0]);
                  var row2 = row_repr_aux(/* [] */0, match$2[0]);
                  var match$3 = row1.row_fields;
                  var match$4 = row1.row_closed;
                  var match$5 = row2.row_fields;
                  var match$6 = row2.row_closed;
                  if (match$3) {
                    if (!match$3[1] && match$4 && match$5) {
                      if (match$5[1]) {
                        return ;
                      }
                      if (!match$6) {
                        return ;
                      }
                      var l1 = match$3[0][0];
                      if (l1 === match$5[0][0]) {
                        return Curry._1(Format.fprintf(ppf, /* Format */[
                                        /* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@,",
                                                0,
                                                0
                                              ]),
                                            /* String_literal */Block.__(11, [
                                                "Types for tag `",
                                                /* String */Block.__(2, [
                                                    /* No_padding */0,
                                                    /* String_literal */Block.__(11, [
                                                        " are incompatible",
                                                        /* End_of_format */0
                                                      ])
                                                  ])
                                              ])
                                          ]),
                                        "@,Types for tag `%s are incompatible"
                                      ]), l1);
                      } else {
                        return ;
                      }
                    }
                    
                  } else if (match$4) {
                    var exit$5 = 0;
                    if (match$5) {
                      exit$5 = 11;
                    } else {
                      if (match$6) {
                        return Format.fprintf(ppf, /* Format */[
                                    /* Formatting_lit */Block.__(17, [
                                        /* Break */Block.__(0, [
                                            "@,",
                                            0,
                                            0
                                          ]),
                                        /* String_literal */Block.__(11, [
                                            "These two variant types have no intersection",
                                            /* End_of_format */0
                                          ])
                                      ]),
                                    "@,These two variant types have no intersection"
                                  ]);
                      }
                      exit$5 = 11;
                    }
                    if (exit$5 === 11) {
                      return Curry._2(Format.fprintf(ppf, /* Format */[
                                      /* Formatting_lit */Block.__(17, [
                                          /* Break */Block.__(0, [
                                              "@,",
                                              0,
                                              0
                                            ]),
                                          /* Formatting_gen */Block.__(18, [
                                              /* Open_box */Block.__(1, [/* Format */[
                                                    /* End_of_format */0,
                                                    ""
                                                  ]]),
                                              /* String_literal */Block.__(11, [
                                                  "The first variant type does not allow tag(s)",
                                                  /* Formatting_lit */Block.__(17, [
                                                      /* Break */Block.__(0, [
                                                          "@ ",
                                                          1,
                                                          0
                                                        ]),
                                                      /* Formatting_gen */Block.__(18, [
                                                          /* Open_box */Block.__(1, [/* Format */[
                                                                /* String_literal */Block.__(11, [
                                                                    "<hov>",
                                                                    /* End_of_format */0
                                                                  ]),
                                                                "<hov>"
                                                              ]]),
                                                          /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                  /* Close_box */0,
                                                                  /* Formatting_lit */Block.__(17, [
                                                                      /* Close_box */0,
                                                                      /* End_of_format */0
                                                                    ])
                                                                ])])
                                                        ])
                                                    ])
                                                ])
                                            ])
                                        ]),
                                      "@,@[The first variant type does not allow tag(s)@ @[<hov>%a@]@]"
                                    ]), print_tags, match$5);
                    }
                    
                  }
                  if (match$5 || !match$6) {
                    return ;
                  } else {
                    return Curry._2(Format.fprintf(ppf, /* Format */[
                                    /* Formatting_lit */Block.__(17, [
                                        /* Break */Block.__(0, [
                                            "@,",
                                            0,
                                            0
                                          ]),
                                        /* Formatting_gen */Block.__(18, [
                                            /* Open_box */Block.__(1, [/* Format */[
                                                  /* End_of_format */0,
                                                  ""
                                                ]]),
                                            /* String_literal */Block.__(11, [
                                                "The second variant type does not allow tag(s)",
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@ ",
                                                        1,
                                                        0
                                                      ]),
                                                    /* Formatting_gen */Block.__(18, [
                                                        /* Open_box */Block.__(1, [/* Format */[
                                                              /* String_literal */Block.__(11, [
                                                                  "<hov>",
                                                                  /* End_of_format */0
                                                                ]),
                                                              "<hov>"
                                                            ]]),
                                                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                /* Close_box */0,
                                                                /* Formatting_lit */Block.__(17, [
                                                                    /* Close_box */0,
                                                                    /* End_of_format */0
                                                                  ])
                                                              ])])
                                                      ])
                                                  ])
                                              ])
                                          ])
                                      ]),
                                    "@,@[The second variant type does not allow tag(s)@ @[<hov>%a@]@]"
                                  ]), print_tags, match$3);
                  }
              default:
                exit = 2;
            }
          }
          break;
      case /* Tunivar */9 :
          if (typeof match$2 === "number") {
            exit = 2;
          } else {
            switch (match$2.tag | 0) {
              case /* Tvar */0 :
                  exit$1 = 4;
                  break;
              case /* Tfield */5 :
                  exit$2 = 7;
                  break;
              default:
                exit = 2;
            }
          }
          break;
      default:
        exit$4 = 9;
    }
  }
  if (exit$4 === 9) {
    if (typeof match$2 === "number" || match$2.tag) {
      exit$3 = 8;
    } else {
      exit$1 = 5;
    }
  }
  if (exit$3 === 8) {
    if (typeof match$1 === "number" || match$1.tag !== /* Tfield */5) {
      exit$2 = 7;
    } else {
      lab = match$1[0];
      exit$1 = 6;
    }
  }
  if (exit$2 === 7) {
    if (typeof match$2 === "number" || match$2.tag !== /* Tfield */5) {
      exit = 2;
    } else {
      lab = match$2[0];
      exit$1 = 6;
    }
  }
  switch (exit$1) {
    case 3 :
        return Format.fprintf(ppf, /* Format */[
                    /* Formatting_lit */Block.__(17, [
                        /* Break */Block.__(0, [
                            "@,",
                            0,
                            0
                          ]),
                        /* String_literal */Block.__(11, [
                            "Self type cannot escape its class",
                            /* End_of_format */0
                          ])
                      ]),
                    "@,Self type cannot escape its class"
                  ]);
    case 4 :
        return Curry._2(Format.fprintf(ppf, /* Format */[
                        /* Formatting_lit */Block.__(17, [
                            /* Break */Block.__(0, [
                                "@,",
                                0,
                                0
                              ]),
                            /* String_literal */Block.__(11, [
                                "The universal variable ",
                                /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                        " would escape its scope",
                                        /* End_of_format */0
                                      ])])
                              ])
                          ]),
                        "@,The universal variable %a would escape its scope"
                      ]), type_expr$1, is_Tunivar(t3) ? t3 : t4);
    case 5 :
        var match$7 = is_Tvar(t3) ? /* tuple */[
            t3,
            t4
          ] : /* tuple */[
            t4,
            t3
          ];
        var t$prime = match$7[1];
        var t = match$7[0];
        if (occur_in(empty, t, t$prime)) {
          return Curry._4(Format.fprintf(ppf, /* Format */[
                          /* Formatting_lit */Block.__(17, [
                              /* Break */Block.__(0, [
                                  "@,",
                                  0,
                                  0
                                ]),
                              /* Formatting_gen */Block.__(18, [
                                  /* Open_box */Block.__(1, [/* Format */[
                                        /* String_literal */Block.__(11, [
                                            "<hov>",
                                            /* End_of_format */0
                                          ]),
                                        "<hov>"
                                      ]]),
                                  /* String_literal */Block.__(11, [
                                      "The type variable ",
                                      /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                              " occurs inside",
                                              /* Formatting_lit */Block.__(17, [
                                                  /* Break */Block.__(0, [
                                                      "@ ",
                                                      1,
                                                      0
                                                    ]),
                                                  /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                          /* Close_box */0,
                                                          /* End_of_format */0
                                                        ])])
                                                ])
                                            ])])
                                    ])
                                ])
                            ]),
                          "@,@[<hov>The type variable %a occurs inside@ %a@]"
                        ]), type_expr$1, t, type_expr$1, t$prime);
        } else {
          return Curry._3(Format.fprintf(ppf, /* Format */[
                          /* Formatting_lit */Block.__(17, [
                              /* Break */Block.__(0, [
                                  "@,",
                                  0,
                                  0
                                ]),
                              /* Formatting_gen */Block.__(18, [
                                  /* Open_box */Block.__(1, [/* Format */[
                                        /* String_literal */Block.__(11, [
                                            "<hov>",
                                            /* End_of_format */0
                                          ]),
                                        "<hov>"
                                      ]]),
                                  /* String_literal */Block.__(11, [
                                      "This instance of ",
                                      /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                              " is ambiguous:",
                                              /* Formatting_lit */Block.__(17, [
                                                  /* Break */Block.__(0, [
                                                      "@ ",
                                                      1,
                                                      0
                                                    ]),
                                                  /* String */Block.__(2, [
                                                      /* No_padding */0,
                                                      /* Formatting_lit */Block.__(17, [
                                                          /* Close_box */0,
                                                          /* End_of_format */0
                                                        ])
                                                    ])
                                                ])
                                            ])])
                                    ])
                                ])
                            ]),
                          "@,@[<hov>This instance of %a is ambiguous:@ %s@]"
                        ]), type_expr$1, t$prime, "it would escape the scope of its equation");
        }
    case 6 :
        if (lab === dummy_method) {
          return Format.fprintf(ppf, /* Format */[
                      /* Formatting_lit */Block.__(17, [
                          /* Break */Block.__(0, [
                              "@,",
                              0,
                              0
                            ]),
                          /* String_literal */Block.__(11, [
                              "Self type cannot be unified with a closed object type",
                              /* End_of_format */0
                            ])
                        ]),
                      "@,Self type cannot be unified with a closed object type"
                    ]);
        }
        exit = 2;
        break;
    
  }
  switch (exit) {
    case 1 :
        return Curry._1(Format.fprintf(ppf, /* Format */[
                        /* Formatting_lit */Block.__(17, [
                            /* Break */Block.__(0, [
                                "@,",
                                0,
                                0
                              ]),
                            /* Formatting_gen */Block.__(18, [
                                /* Open_box */Block.__(1, [/* Format */[
                                      /* End_of_format */0,
                                      ""
                                    ]]),
                                /* String_literal */Block.__(11, [
                                    "The ",
                                    /* String */Block.__(2, [
                                        /* No_padding */0,
                                        /* String_literal */Block.__(11, [
                                            " object type has an abstract row, it cannot be closed",
                                            /* Formatting_lit */Block.__(17, [
                                                /* Close_box */0,
                                                /* End_of_format */0
                                              ])
                                          ])
                                      ])
                                  ])
                              ])
                          ]),
                        "@,@[The %s object type has an abstract row, it cannot be closed@]"
                      ]), t4.desc === /* Tnil */0 ? "first" : "second");
    case 2 :
        if (typeof match$1 !== "number") {
          switch (match$1.tag | 0) {
            case /* Tconstr */3 :
                break;
            case /* Tfield */5 :
                var l = match$1[0];
                var match$8 = match$1[3].desc;
                var exit$6 = 0;
                if (typeof match$8 === "number" && typeof match$2 !== "number") {
                  switch (match$2.tag | 0) {
                    case /* Tconstr */3 :
                        exit$6 = 4;
                        break;
                    case /* Tfield */5 :
                        var match$9 = match$2[3].desc;
                        if (typeof match$9 === "number" && l === match$2[0]) {
                          return Curry._1(Format.fprintf(ppf, /* Format */[
                                          /* Formatting_lit */Block.__(17, [
                                              /* Break */Block.__(0, [
                                                  "@,",
                                                  0,
                                                  0
                                                ]),
                                              /* String_literal */Block.__(11, [
                                                  "Types for method ",
                                                  /* String */Block.__(2, [
                                                      /* No_padding */0,
                                                      /* String_literal */Block.__(11, [
                                                          " are incompatible",
                                                          /* End_of_format */0
                                                        ])
                                                    ])
                                                ])
                                            ]),
                                          "@,Types for method %s are incompatible"
                                        ]), l);
                        } else {
                          return ;
                        }
                    default:
                      return ;
                  }
                } else {
                  exit$6 = 4;
                }
                if (exit$6 === 4) {
                  var exit$7 = 0;
                  if (typeof match$2 === "number") {
                    exit$7 = 5;
                  } else {
                    if (match$2.tag !== /* Tconstr */3) {
                      return ;
                    }
                    exit$7 = 5;
                  }
                  if (exit$7 === 5) {
                    return Curry._1(Format.fprintf(ppf, /* Format */[
                                    /* Formatting_lit */Block.__(17, [
                                        /* Break */Block.__(0, [
                                            "@,",
                                            0,
                                            0
                                          ]),
                                        /* Formatting_gen */Block.__(18, [
                                            /* Open_box */Block.__(1, [/* Format */[
                                                  /* End_of_format */0,
                                                  ""
                                                ]]),
                                            /* String_literal */Block.__(11, [
                                                "The second object type has no method ",
                                                /* String */Block.__(2, [
                                                    /* No_padding */0,
                                                    /* Formatting_lit */Block.__(17, [
                                                        /* Close_box */0,
                                                        /* End_of_format */0
                                                      ])
                                                  ])
                                              ])
                                          ])
                                      ]),
                                    "@,@[The second object type has no method %s@]"
                                  ]), l);
                  }
                  
                }
                break;
            default:
              return ;
          }
        }
        if (typeof match$2 === "number" || match$2.tag !== /* Tfield */5) {
          return ;
        } else {
          return Curry._1(Format.fprintf(ppf, /* Format */[
                          /* Formatting_lit */Block.__(17, [
                              /* Break */Block.__(0, [
                                  "@,",
                                  0,
                                  0
                                ]),
                              /* Formatting_gen */Block.__(18, [
                                  /* Open_box */Block.__(1, [/* Format */[
                                        /* End_of_format */0,
                                        ""
                                      ]]),
                                  /* String_literal */Block.__(11, [
                                      "The first object type has no method ",
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* Formatting_lit */Block.__(17, [
                                              /* Close_box */0,
                                              /* End_of_format */0
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "@,@[The first object type has no method %s@]"
                        ]), match$2[0]);
        }
        break;
    
  }
}

function path_same_name(_p1, _p2) {
  while(true) {
    var p2 = _p2;
    var p1 = _p1;
    switch (p1.tag | 0) {
      case /* Pident */0 :
          switch (p2.tag | 0) {
            case /* Pident */0 :
                var id1 = p1[0];
                var id2 = p2[0];
                if (equal(id1, id2) && !Caml_obj.caml_equal(id1, id2)) {
                  add_unique(id1);
                  return add_unique(id2);
                } else {
                  return ;
                }
            case /* Pdot */1 :
            case /* Papply */2 :
                return ;
            
          }
      case /* Pdot */1 :
          switch (p2.tag | 0) {
            case /* Pdot */1 :
                if (p1[1] !== p2[1]) {
                  return ;
                }
                _p2 = p2[0];
                _p1 = p1[0];
                continue ;
            case /* Pident */0 :
            case /* Papply */2 :
                return ;
            
          }
      case /* Papply */2 :
          switch (p2.tag | 0) {
            case /* Pident */0 :
            case /* Pdot */1 :
                return ;
            case /* Papply */2 :
                path_same_name(p1[0], p2[0]);
                _p2 = p2[1];
                _p1 = p1[1];
                continue ;
            
          }
      
    }
  };
}

function type_same_name(t1, t2) {
  var match = repr(t1).desc;
  var match$1 = repr(t2).desc;
  if (typeof match === "number" || !(match.tag === /* Tconstr */3 && !(typeof match$1 === "number" || match$1.tag !== /* Tconstr */3))) {
    return ;
  } else {
    return path_same_name(best_type_path(match[0])[0], best_type_path(match$1[0])[0]);
  }
}

function trace_same_names(_param) {
  while(true) {
    var param = _param;
    if (!param) {
      return ;
    }
    var match = param[1];
    if (!match) {
      return ;
    }
    var match$1 = match[0];
    var match$2 = param[0];
    type_same_name(match$2[0], match$1[0]);
    type_same_name(match$2[1], match$1[1]);
    _param = match[1];
    continue ;
  };
}

function report_unification_error(ppf, env, unifOpt, tr, txt1, txt2) {
  var unif = unifOpt !== void 0 ? unifOpt : true;
  return wrap_printing_env(env, (function (param) {
                reset(void 0);
                trace_same_names(tr);
                var tr$1 = List.map((function (param) {
                        return /* tuple */[
                                param[0],
                                hide_variant_name(param[1])
                              ];
                      }), tr);
                var mis = mismatch(unif, tr$1);
                if (!tr$1) {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        /* tuple */[
                          "printtyp.ml",
                          1438,
                          20
                        ]
                      ];
                }
                var match = tr$1[1];
                if (!match) {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        /* tuple */[
                          "printtyp.ml",
                          1438,
                          20
                        ]
                      ];
                }
                try {
                  var tr$2 = filter_trace(mis === void 0, match[1]);
                  var match$1 = may_prepare_expansion(tr$2 === /* [] */0, tr$1[0]);
                  var t1 = match$1[0];
                  var match$2 = may_prepare_expansion(tr$2 === /* [] */0, match[0]);
                  var t2 = match$2[0];
                  print_labels.contents = !classic.contents;
                  var tr$3 = List.map(prepare_expansion, tr$2);
                  Curry.app(Format.fprintf(ppf, /* Format */[
                            /* Formatting_gen */Block.__(18, [
                                /* Open_box */Block.__(1, [/* Format */[
                                      /* String_literal */Block.__(11, [
                                          "<v>",
                                          /* End_of_format */0
                                        ]),
                                      "<v>"
                                    ]]),
                                /* Formatting_gen */Block.__(18, [
                                    /* Open_box */Block.__(1, [/* Format */[
                                          /* End_of_format */0,
                                          ""
                                        ]]),
                                    /* Theta */Block.__(16, [/* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@;<1 2>",
                                                1,
                                                2
                                              ]),
                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@ ",
                                                        1,
                                                        0
                                                      ]),
                                                    /* Theta */Block.__(16, [/* Formatting_lit */Block.__(17, [
                                                            /* Break */Block.__(0, [
                                                                "@;<1 2>",
                                                                1,
                                                                2
                                                              ]),
                                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                    /* Close_box */0,
                                                                    /* Alpha */Block.__(15, [/* Theta */Block.__(16, [/* Formatting_lit */Block.__(17, [
                                                                                /* Close_box */0,
                                                                                /* End_of_format */0
                                                                              ])])])
                                                                  ])])
                                                          ])])
                                                  ])])
                                          ])])
                                  ])
                              ]),
                            "@[<v>@[%t@;<1 2>%a@ %t@;<1 2>%a@]%a%t@]"
                          ]), [
                        txt1,
                        (function (param, param$1) {
                            return type_expansion(t1, param, param$1);
                          }),
                        match$1[1],
                        txt2,
                        (function (param, param$1) {
                            return type_expansion(t2, param, param$1);
                          }),
                        match$2[1],
                        (function (param, param$1) {
                            return trace(false, "is not compatible with type", param, param$1);
                          }),
                        tr$3,
                        (function (param) {
                            return explanation(unif, mis, param);
                          })
                      ]);
                  print_labels.contents = true;
                  return ;
                }
                catch (exn){
                  print_labels.contents = true;
                  throw exn;
                }
              }));
}

function trace$1(fst, keep_last, txt, ppf, tr) {
  print_labels.contents = !classic.contents;
  trace_same_names(tr);
  try {
    if (!tr) {
      return ;
    }
    var match = tr[1];
    if (match) {
      if (fst) {
        trace(fst, txt, ppf, /* :: */[
              tr[0],
              /* :: */[
                match[0],
                filter_trace(keep_last, match[1])
              ]
            ]);
      } else {
        trace(fst, txt, ppf, filter_trace(keep_last, tr));
      }
      print_labels.contents = true;
      return ;
    } else {
      return ;
    }
  }
  catch (exn){
    print_labels.contents = true;
    throw exn;
  }
}

function class_types(env, cty1, cty2) {
  return match_class_types(void 0, env, cty1, cty2);
}

function class_type_declarations(env, cty1, cty2) {
  return match_class_declarations(env, cty1.clty_params, cty1.clty_type, cty2.clty_params, cty2.clty_type);
}

function class_declarations(env, cty1, cty2) {
  var match = cty1.cty_new;
  var match$1 = cty2.cty_new;
  if (match === void 0 && match$1 !== void 0) {
    return /* :: */[
            /* CM_Virtual_class */0,
            /* [] */0
          ];
  }
  return match_class_declarations(env, cty1.cty_params, cty1.cty_type, cty2.cty_params, cty2.cty_type);
}

function include_err(ppf, param) {
  if (typeof param === "number") {
    return Format.fprintf(ppf, /* Format */[
                /* String_literal */Block.__(11, [
                    "A class cannot be changed from virtual to concrete",
                    /* End_of_format */0
                  ]),
                "A class cannot be changed from virtual to concrete"
              ]);
  }
  switch (param.tag | 0) {
    case /* CM_Parameter_arity_mismatch */0 :
        return Format.fprintf(ppf, /* Format */[
                    /* String_literal */Block.__(11, [
                        "The classes do not have the same number of type parameters",
                        /* End_of_format */0
                      ]),
                    "The classes do not have the same number of type parameters"
                  ]);
    case /* CM_Type_parameter_mismatch */1 :
        return report_unification_error(ppf, param[0], false, param[1], (function (ppf) {
                      return Format.fprintf(ppf, /* Format */[
                                  /* String_literal */Block.__(11, [
                                      "A type parameter has type",
                                      /* End_of_format */0
                                    ]),
                                  "A type parameter has type"
                                ]);
                    }), (function (ppf) {
                      return Format.fprintf(ppf, /* Format */[
                                  /* String_literal */Block.__(11, [
                                      "but is expected to have type",
                                      /* End_of_format */0
                                    ]),
                                  "but is expected to have type"
                                ]);
                    }));
    case /* CM_Class_type_mismatch */2 :
        var cty2 = param[2];
        var cty1 = param[1];
        return wrap_printing_env(param[0], (function (param) {
                      return Curry._5(Format.fprintf(ppf, /* Format */[
                                      /* Formatting_gen */Block.__(18, [
                                          /* Open_box */Block.__(1, [/* Format */[
                                                /* End_of_format */0,
                                                ""
                                              ]]),
                                          /* String_literal */Block.__(11, [
                                              "The class type",
                                              /* Formatting_lit */Block.__(17, [
                                                  /* Break */Block.__(0, [
                                                      "@;<1 2>",
                                                      1,
                                                      2
                                                    ]),
                                                  /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                          /* Break */Block.__(0, [
                                                              "@ ",
                                                              1,
                                                              0
                                                            ]),
                                                          /* String */Block.__(2, [
                                                              /* No_padding */0,
                                                              /* Formatting_lit */Block.__(17, [
                                                                  /* Break */Block.__(0, [
                                                                      "@;<1 2>",
                                                                      1,
                                                                      2
                                                                    ]),
                                                                  /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                          /* Close_box */0,
                                                                          /* End_of_format */0
                                                                        ])])
                                                                ])
                                                            ])
                                                        ])])
                                                ])
                                            ])
                                        ]),
                                      "@[The class type@;<1 2>%a@ %s@;<1 2>%a@]"
                                    ]), class_type$2, cty1, "is not matched by the class type", class_type$2, cty2);
                    }));
    case /* CM_Parameter_mismatch */3 :
        return report_unification_error(ppf, param[0], false, param[1], (function (ppf) {
                      return Format.fprintf(ppf, /* Format */[
                                  /* String_literal */Block.__(11, [
                                      "A parameter has type",
                                      /* End_of_format */0
                                    ]),
                                  "A parameter has type"
                                ]);
                    }), (function (ppf) {
                      return Format.fprintf(ppf, /* Format */[
                                  /* String_literal */Block.__(11, [
                                      "but is expected to have type",
                                      /* End_of_format */0
                                    ]),
                                  "but is expected to have type"
                                ]);
                    }));
    case /* CM_Val_type_mismatch */4 :
        var lab = param[0];
        return report_unification_error(ppf, param[1], false, param[2], (function (ppf) {
                      return Curry._1(Format.fprintf(ppf, /* Format */[
                                      /* String_literal */Block.__(11, [
                                          "The instance variable ",
                                          /* String */Block.__(2, [
                                              /* No_padding */0,
                                              /* Formatting_lit */Block.__(17, [
                                                  /* Break */Block.__(0, [
                                                      "@ ",
                                                      1,
                                                      0
                                                    ]),
                                                  /* String_literal */Block.__(11, [
                                                      "has type",
                                                      /* End_of_format */0
                                                    ])
                                                ])
                                            ])
                                        ]),
                                      "The instance variable %s@ has type"
                                    ]), lab);
                    }), (function (ppf) {
                      return Format.fprintf(ppf, /* Format */[
                                  /* String_literal */Block.__(11, [
                                      "but is expected to have type",
                                      /* End_of_format */0
                                    ]),
                                  "but is expected to have type"
                                ]);
                    }));
    case /* CM_Meth_type_mismatch */5 :
        var lab$1 = param[0];
        return report_unification_error(ppf, param[1], false, param[2], (function (ppf) {
                      return Curry._1(Format.fprintf(ppf, /* Format */[
                                      /* String_literal */Block.__(11, [
                                          "The method ",
                                          /* String */Block.__(2, [
                                              /* No_padding */0,
                                              /* Formatting_lit */Block.__(17, [
                                                  /* Break */Block.__(0, [
                                                      "@ ",
                                                      1,
                                                      0
                                                    ]),
                                                  /* String_literal */Block.__(11, [
                                                      "has type",
                                                      /* End_of_format */0
                                                    ])
                                                ])
                                            ])
                                        ]),
                                      "The method %s@ has type"
                                    ]), lab$1);
                    }), (function (ppf) {
                      return Format.fprintf(ppf, /* Format */[
                                  /* String_literal */Block.__(11, [
                                      "but is expected to have type",
                                      /* End_of_format */0
                                    ]),
                                  "but is expected to have type"
                                ]);
                    }));
    case /* CM_Non_mutable_value */6 :
        return Curry._1(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* End_of_format */0,
                                  ""
                                ]]),
                            /* String_literal */Block.__(11, [
                                "The non-mutable instance variable ",
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* String_literal */Block.__(11, [
                                        " cannot become mutable",
                                        /* Formatting_lit */Block.__(17, [
                                            /* Close_box */0,
                                            /* End_of_format */0
                                          ])
                                      ])
                                  ])
                              ])
                          ]),
                        "@[The non-mutable instance variable %s cannot become mutable@]"
                      ]), param[0]);
    case /* CM_Non_concrete_value */7 :
        return Curry._1(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* End_of_format */0,
                                  ""
                                ]]),
                            /* String_literal */Block.__(11, [
                                "The virtual instance variable ",
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* String_literal */Block.__(11, [
                                        " cannot become concrete",
                                        /* Formatting_lit */Block.__(17, [
                                            /* Close_box */0,
                                            /* End_of_format */0
                                          ])
                                      ])
                                  ])
                              ])
                          ]),
                        "@[The virtual instance variable %s cannot become concrete@]"
                      ]), param[0]);
    case /* CM_Missing_value */8 :
        return Curry._1(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* End_of_format */0,
                                  ""
                                ]]),
                            /* String_literal */Block.__(11, [
                                "The first class type has no instance variable ",
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* Formatting_lit */Block.__(17, [
                                        /* Close_box */0,
                                        /* End_of_format */0
                                      ])
                                  ])
                              ])
                          ]),
                        "@[The first class type has no instance variable %s@]"
                      ]), param[0]);
    case /* CM_Missing_method */9 :
        return Curry._1(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* End_of_format */0,
                                  ""
                                ]]),
                            /* String_literal */Block.__(11, [
                                "The first class type has no method ",
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* Formatting_lit */Block.__(17, [
                                        /* Close_box */0,
                                        /* End_of_format */0
                                      ])
                                  ])
                              ])
                          ]),
                        "@[The first class type has no method %s@]"
                      ]), param[0]);
    case /* CM_Hide_public */10 :
        return Curry._1(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* End_of_format */0,
                                  ""
                                ]]),
                            /* String_literal */Block.__(11, [
                                "The public method ",
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* String_literal */Block.__(11, [
                                        " cannot be hidden",
                                        /* Formatting_lit */Block.__(17, [
                                            /* Close_box */0,
                                            /* End_of_format */0
                                          ])
                                      ])
                                  ])
                              ])
                          ]),
                        "@[The public method %s cannot be hidden@]"
                      ]), param[0]);
    case /* CM_Hide_virtual */11 :
        return Curry._2(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* End_of_format */0,
                                  ""
                                ]]),
                            /* String_literal */Block.__(11, [
                                "The virtual ",
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* Char_literal */Block.__(12, [
                                        /* " " */32,
                                        /* String */Block.__(2, [
                                            /* No_padding */0,
                                            /* String_literal */Block.__(11, [
                                                " cannot be hidden",
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Close_box */0,
                                                    /* End_of_format */0
                                                  ])
                                              ])
                                          ])
                                      ])
                                  ])
                              ])
                          ]),
                        "@[The virtual %s %s cannot be hidden@]"
                      ]), param[0], param[1]);
    case /* CM_Public_method */12 :
        return Curry._1(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* End_of_format */0,
                                  ""
                                ]]),
                            /* String_literal */Block.__(11, [
                                "The public method ",
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* String_literal */Block.__(11, [
                                        " cannot become private",
                                        /* End_of_format */0
                                      ])
                                  ])
                              ])
                          ]),
                        "@[The public method %s cannot become private"
                      ]), param[0]);
    case /* CM_Private_method */13 :
        return Curry._1(Format.fprintf(ppf, /* Format */[
                        /* String_literal */Block.__(11, [
                            "The private method ",
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* String_literal */Block.__(11, [
                                    " cannot become public",
                                    /* End_of_format */0
                                  ])
                              ])
                          ]),
                        "The private method %s cannot become public"
                      ]), param[0]);
    case /* CM_Virtual_method */14 :
        return Curry._1(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* End_of_format */0,
                                  ""
                                ]]),
                            /* String_literal */Block.__(11, [
                                "The virtual method ",
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* String_literal */Block.__(11, [
                                        " cannot become concrete",
                                        /* End_of_format */0
                                      ])
                                  ])
                              ])
                          ]),
                        "@[The virtual method %s cannot become concrete"
                      ]), param[0]);
    
  }
}

function report_error$3(ppf, param) {
  if (!param) {
    return ;
  }
  var print_errs = function (ppf, errs) {
    return List.iter((function (err) {
                  return Curry._2(Format.fprintf(ppf, /* Format */[
                                  /* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@ ",
                                          1,
                                          0
                                        ]),
                                      /* Alpha */Block.__(15, [/* End_of_format */0])
                                    ]),
                                  "@ %a"
                                ]), include_err, err);
                }), errs);
  };
  return Curry._4(Format.fprintf(ppf, /* Format */[
                  /* Formatting_gen */Block.__(18, [
                      /* Open_box */Block.__(1, [/* Format */[
                            /* String_literal */Block.__(11, [
                                "<v>",
                                /* End_of_format */0
                              ]),
                            "<v>"
                          ]]),
                      /* Alpha */Block.__(15, [/* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                  /* Close_box */0,
                                  /* End_of_format */0
                                ])])])
                    ]),
                  "@[<v>%a%a@]"
                ]), include_err, param[0], print_errs, param[1]);
}

var Dont_match = Caml_exceptions.create("Ocaml_typedtree_test.Includecore.Dont_match");

function private_flags(decl1, decl2) {
  var match = decl1.type_private;
  var match$1 = decl2.type_private;
  if (match || !match$1) {
    return true;
  } else if (decl2.type_kind === /* Type_abstract */0) {
    if (decl2.type_manifest === void 0) {
      return true;
    } else {
      return decl1.type_kind !== /* Type_abstract */0;
    }
  } else {
    return false;
  }
}

function is_absrow(env, ty) {
  var match = ty.desc;
  if (typeof match === "number") {
    return false;
  }
  if (match.tag !== /* Tconstr */3) {
    return false;
  }
  switch (match[0].tag | 0) {
    case /* Pident */0 :
        var match$1 = expand_head(env, ty);
        var match$2 = match$1.desc;
        if (typeof match$2 === "number") {
          return false;
        }
        switch (match$2.tag | 0) {
          case /* Tobject */4 :
          case /* Tvariant */8 :
              return true;
          default:
            return false;
        }
    case /* Pdot */1 :
    case /* Papply */2 :
        return false;
    
  }
}

function type_manifest(env, ty1, params1, ty2, params2, priv2) {
  var ty1$prime = expand_head(env, ty1);
  var ty2$prime = expand_head(env, ty2);
  var match = ty1$prime.desc;
  var match$1 = ty2$prime.desc;
  if (typeof match !== "number") {
    switch (match.tag | 0) {
      case /* Tobject */4 :
          if (typeof match$1 !== "number" && match$1.tag === /* Tobject */4) {
            var fi2 = match$1[0];
            if (is_absrow(env, flatten_fields(fi2)[1])) {
              var match$2 = flatten_fields(fi2);
              if (!equal$4(env, true, /* :: */[
                      ty1,
                      params1
                    ], /* :: */[
                      match$2[1],
                      params2
                    ])) {
                return false;
              }
              var match$3 = flatten_fields(match[0]);
              var match$4 = match$3[1].desc;
              var tmp;
              if (typeof match$4 === "number") {
                tmp = true;
              } else {
                switch (match$4.tag | 0) {
                  case /* Tvar */0 :
                  case /* Tconstr */3 :
                      tmp = true;
                      break;
                  default:
                    tmp = false;
                }
              }
              if (!tmp) {
                return false;
              }
              var match$5 = associate_fields(match$3[0], match$2[0]);
              if (match$5[2] !== /* [] */0) {
                return false;
              }
              var match$6 = List.split(List.map((function (param) {
                          return /* tuple */[
                                  param[2],
                                  param[4]
                                ];
                        }), match$5[0]));
              return equal$4(env, true, Pervasives.$at(params1, match$6[0]), Pervasives.$at(params2, match$6[1]));
            }
            
          }
          break;
      case /* Tvariant */8 :
          if (typeof match$1 !== "number" && match$1.tag === /* Tvariant */8) {
            var row2 = match$1[0];
            if (is_absrow(env, row_more(row2))) {
              var row1 = row_repr_aux(/* [] */0, match[0]);
              var row2$1 = row_repr_aux(/* [] */0, row2);
              if (!equal$4(env, true, /* :: */[
                      ty1,
                      params1
                    ], /* :: */[
                      row2$1.row_more,
                      params2
                    ])) {
                return false;
              }
              var match$7 = row1.row_more;
              var match$8 = match$7.desc;
              var tmp$1;
              if (typeof match$8 === "number") {
                tmp$1 = true;
              } else {
                switch (match$8.tag | 0) {
                  case /* Tvar */0 :
                  case /* Tconstr */3 :
                      tmp$1 = true;
                      break;
                  default:
                    tmp$1 = false;
                }
              }
              if (!tmp$1) {
                return false;
              }
              var match$9 = merge_row_fields(row1.row_fields, row2$1.row_fields);
              if (!(!row2$1.row_closed || row1.row_closed && filter_row_fields(false, match$9[0]) === /* [] */0)) {
                return false;
              }
              if (!List.for_all((function (param) {
                        var match = row_field_repr_aux(/* [] */0, param[1]);
                        if (typeof match === "number" || match.tag) {
                          return true;
                        } else {
                          return false;
                        }
                      }), match$9[1])) {
                return false;
              }
              var to_equal = {
                contents: List.combine(params1, params2)
              };
              if (!List.for_all((function (param) {
                        var match = row_field_repr_aux(/* [] */0, param[1]);
                        var match$1 = row_field_repr_aux(/* [] */0, param[2]);
                        if (typeof match === "number") {
                          if (typeof match$1 === "number" || match$1.tag) {
                            return true;
                          } else {
                            return false;
                          }
                        }
                        if (match.tag) {
                          var tl1 = match[1];
                          if (typeof match$1 === "number") {
                            return false;
                          }
                          if (!match$1.tag) {
                            return false;
                          }
                          var tl2 = match$1[1];
                          if (List.length(tl1) === List.length(tl2) && match[0] === match$1[0]) {
                            to_equal.contents = Pervasives.$at(List.combine(tl1, tl2), to_equal.contents);
                            return true;
                          } else {
                            return false;
                          }
                        } else {
                          var match$2 = match[0];
                          if (match$2 === void 0) {
                            if (typeof match$1 === "number") {
                              return false;
                            } else if (match$1.tag) {
                              if (match$1[0] && !match$1[1]) {
                                return true;
                              } else {
                                return false;
                              }
                            } else {
                              return match$1[0] === void 0;
                            }
                          }
                          var t2;
                          if (typeof match$1 === "number") {
                            return false;
                          }
                          if (match$1.tag) {
                            if (match$1[0]) {
                              return false;
                            }
                            var match$3 = match$1[1];
                            if (!match$3) {
                              return false;
                            }
                            if (match$3[1]) {
                              return false;
                            }
                            t2 = match$3[0];
                          } else {
                            var match$4 = match$1[0];
                            if (match$4 === void 0) {
                              return false;
                            }
                            t2 = match$4;
                          }
                          to_equal.contents = /* :: */[
                            /* tuple */[
                              match$2,
                              t2
                            ],
                            to_equal.contents
                          ];
                          return true;
                        }
                      }), match$9[2])) {
                return false;
              }
              var match$10 = List.split(to_equal.contents);
              return equal$4(env, true, match$10[0], match$10[1]);
            }
            
          }
          break;
      default:
        
    }
  }
  var check_super = function (ty1) {
    if (equal$4(env, true, /* :: */[
            ty1,
            params1
          ], /* :: */[
            ty2,
            params2
          ])) {
      return true;
    }
    if (priv2 !== /* Private */0) {
      return false;
    }
    try {
      return check_super(try_expand_once_opt(env, expand_head(env, ty1)));
    }
    catch (exn){
      if (exn === Cannot_expand) {
        return false;
      }
      throw exn;
    }
  };
  return check_super(ty1);
}

function report_type_mismatch(first, second, decl, ppf) {
  return (function (param) {
      return List.iter((function (err) {
                    if (err === /* Manifest */4) {
                      return ;
                    } else {
                      return Curry._2(Format.fprintf(ppf, /* Format */[
                                      /* Formatting_lit */Block.__(17, [
                                          /* Break */Block.__(0, [
                                              "@ ",
                                              1,
                                              0
                                            ]),
                                          /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                  /* "." */46,
                                                  /* End_of_format */0
                                                ])])
                                        ]),
                                      "@ %a."
                                    ]), (function (param, param$1) {
                                    if (typeof param$1 === "number") {
                                      switch (param$1) {
                                        case /* Arity */0 :
                                            return Format.fprintf(param, /* Format */[
                                                        /* String_literal */Block.__(11, [
                                                            "They have different arities",
                                                            /* End_of_format */0
                                                          ]),
                                                        "They have different arities"
                                                      ]);
                                        case /* Privacy */1 :
                                            return Format.fprintf(param, /* Format */[
                                                        /* String_literal */Block.__(11, [
                                                            "A private type would be revealed",
                                                            /* End_of_format */0
                                                          ]),
                                                        "A private type would be revealed"
                                                      ]);
                                        case /* Kind */2 :
                                            return Format.fprintf(param, /* Format */[
                                                        /* String_literal */Block.__(11, [
                                                            "Their kinds differ",
                                                            /* End_of_format */0
                                                          ]),
                                                        "Their kinds differ"
                                                      ]);
                                        case /* Constraint */3 :
                                            return Format.fprintf(param, /* Format */[
                                                        /* String_literal */Block.__(11, [
                                                            "Their constraints differ",
                                                            /* End_of_format */0
                                                          ]),
                                                        "Their constraints differ"
                                                      ]);
                                        case /* Manifest */4 :
                                            return ;
                                        case /* Variance */5 :
                                            return Format.fprintf(param, /* Format */[
                                                        /* String_literal */Block.__(11, [
                                                            "Their variances do not agree",
                                                            /* End_of_format */0
                                                          ]),
                                                        "Their variances do not agree"
                                                      ]);
                                        
                                      }
                                    } else {
                                      switch (param$1.tag | 0) {
                                        case /* Field_type */0 :
                                            return Curry._1(Format.fprintf(param, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "The types for field ",
                                                                /* String */Block.__(2, [
                                                                    /* No_padding */0,
                                                                    /* String_literal */Block.__(11, [
                                                                        " are not equal",
                                                                        /* End_of_format */0
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "The types for field %s are not equal"
                                                          ]), param$1[0].name);
                                        case /* Field_mutable */1 :
                                            return Curry._1(Format.fprintf(param, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "The mutability of field ",
                                                                /* String */Block.__(2, [
                                                                    /* No_padding */0,
                                                                    /* String_literal */Block.__(11, [
                                                                        " is different",
                                                                        /* End_of_format */0
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "The mutability of field %s is different"
                                                          ]), param$1[0].name);
                                        case /* Field_arity */2 :
                                            return Curry._1(Format.fprintf(param, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "The arities for field ",
                                                                /* String */Block.__(2, [
                                                                    /* No_padding */0,
                                                                    /* String_literal */Block.__(11, [
                                                                        " differ",
                                                                        /* End_of_format */0
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "The arities for field %s differ"
                                                          ]), param$1[0].name);
                                        case /* Field_names */3 :
                                            return Curry._3(Format.fprintf(param, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "Fields number ",
                                                                /* Int */Block.__(4, [
                                                                    /* Int_i */3,
                                                                    /* No_padding */0,
                                                                    /* No_precision */0,
                                                                    /* String_literal */Block.__(11, [
                                                                        " have different names, ",
                                                                        /* String */Block.__(2, [
                                                                            /* No_padding */0,
                                                                            /* String_literal */Block.__(11, [
                                                                                " and ",
                                                                                /* String */Block.__(2, [
                                                                                    /* No_padding */0,
                                                                                    /* End_of_format */0
                                                                                  ])
                                                                              ])
                                                                          ])
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "Fields number %i have different names, %s and %s"
                                                          ]), param$1[0], param$1[1].name, param$1[2].name);
                                        case /* Field_missing */4 :
                                            return Curry._3(Format.fprintf(param, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "The field ",
                                                                /* String */Block.__(2, [
                                                                    /* No_padding */0,
                                                                    /* String_literal */Block.__(11, [
                                                                        " is only present in ",
                                                                        /* String */Block.__(2, [
                                                                            /* No_padding */0,
                                                                            /* Char_literal */Block.__(12, [
                                                                                /* " " */32,
                                                                                /* String */Block.__(2, [
                                                                                    /* No_padding */0,
                                                                                    /* End_of_format */0
                                                                                  ])
                                                                              ])
                                                                          ])
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "The field %s is only present in %s %s"
                                                          ]), param$1[1].name, param$1[0] ? second : first, decl);
                                        case /* Record_representation */5 :
                                            return Curry._3(Format.fprintf(param, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "Their internal representations differ:",
                                                                /* Formatting_lit */Block.__(17, [
                                                                    /* Break */Block.__(0, [
                                                                        "@ ",
                                                                        1,
                                                                        0
                                                                      ]),
                                                                    /* String */Block.__(2, [
                                                                        /* No_padding */0,
                                                                        /* Char_literal */Block.__(12, [
                                                                            /* " " */32,
                                                                            /* String */Block.__(2, [
                                                                                /* No_padding */0,
                                                                                /* Char_literal */Block.__(12, [
                                                                                    /* " " */32,
                                                                                    /* String */Block.__(2, [
                                                                                        /* No_padding */0,
                                                                                        /* End_of_format */0
                                                                                      ])
                                                                                  ])
                                                                              ])
                                                                          ])
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "Their internal representations differ:@ %s %s %s"
                                                          ]), param$1[0] ? second : first, decl, "uses unboxed float representation");
                                        
                                      }
                                    }
                                  }), err);
                    }
                  }), param);
    });
}

function compare_variants(env, decl1, decl2, _n, _cstrs1, _cstrs2) {
  while(true) {
    var cstrs2 = _cstrs2;
    var cstrs1 = _cstrs1;
    var n = _n;
    if (!cstrs1) {
      if (cstrs2) {
        return /* :: */[
                /* Field_missing */Block.__(4, [
                    true,
                    cstrs2[0].cd_id
                  ]),
                /* [] */0
              ];
      } else {
        return /* [] */0;
      }
    }
    var c = cstrs1[0];
    if (!cstrs2) {
      return /* :: */[
              /* Field_missing */Block.__(4, [
                  false,
                  c.cd_id
                ]),
              /* [] */0
            ];
    }
    var match = cstrs2[0];
    var ret2 = match.cd_res;
    var arg2 = match.cd_args;
    var cstr2 = match.cd_id;
    var ret1 = c.cd_res;
    var arg1 = c.cd_args;
    var cstr1 = c.cd_id;
    if (cstr1.name !== cstr2.name) {
      return /* :: */[
              /* Field_names */Block.__(3, [
                  n,
                  cstr1,
                  cstr2
                ]),
              /* [] */0
            ];
    }
    if (List.length(arg1) !== List.length(arg2)) {
      return /* :: */[
              /* Field_arity */Block.__(2, [cstr1]),
              /* [] */0
            ];
    }
    if (ret1 !== void 0) {
      if (ret2 === void 0) {
        return /* :: */[
                /* Field_type */Block.__(0, [cstr1]),
                /* [] */0
              ];
      }
      if (!equal$4(env, true, /* :: */[
              ret1,
              /* [] */0
            ], /* :: */[
              ret2,
              /* [] */0
            ])) {
        return /* :: */[
                /* Field_type */Block.__(0, [cstr1]),
                /* [] */0
              ];
      }
      
    } else if (ret2 !== void 0) {
      return /* :: */[
              /* Field_type */Block.__(0, [cstr1]),
              /* [] */0
            ];
    }
    if (!for_all2((function (ty1, ty2) {
              return equal$4(env, true, /* :: */[
                          ty1,
                          decl1.type_params
                        ], /* :: */[
                          ty2,
                          decl2.type_params
                        ]);
            }), arg1, arg2)) {
      return /* :: */[
              /* Field_type */Block.__(0, [cstr1]),
              /* [] */0
            ];
    }
    _cstrs2 = cstrs2[1];
    _cstrs1 = cstrs1[1];
    _n = n + 1 | 0;
    continue ;
  };
}

function compare_records(env, decl1, decl2, _n, _labels1, _labels2) {
  while(true) {
    var labels2 = _labels2;
    var labels1 = _labels1;
    var n = _n;
    if (!labels1) {
      if (labels2) {
        return /* :: */[
                /* Field_missing */Block.__(4, [
                    true,
                    labels2[0].ld_id
                  ]),
                /* [] */0
              ];
      } else {
        return /* [] */0;
      }
    }
    var l = labels1[0];
    if (!labels2) {
      return /* :: */[
              /* Field_missing */Block.__(4, [
                  false,
                  l.ld_id
                ]),
              /* [] */0
            ];
    }
    var match = labels2[0];
    var lab2 = match.ld_id;
    var lab1 = l.ld_id;
    if (lab1.name !== lab2.name) {
      return /* :: */[
              /* Field_names */Block.__(3, [
                  n,
                  lab1,
                  lab2
                ]),
              /* [] */0
            ];
    }
    if (l.ld_mutable !== match.ld_mutable) {
      return /* :: */[
              /* Field_mutable */Block.__(1, [lab1]),
              /* [] */0
            ];
    }
    if (!equal$4(env, true, /* :: */[
            l.ld_type,
            decl1.type_params
          ], /* :: */[
            match.ld_type,
            decl2.type_params
          ])) {
      return /* :: */[
              /* Field_type */Block.__(0, [lab1]),
              /* [] */0
            ];
    }
    _labels2 = labels2[1];
    _labels1 = labels1[1];
    _n = n + 1 | 0;
    continue ;
  };
}

function type_declarations$1(equalityOpt, env, name, decl1, id, decl2) {
  var equality = equalityOpt !== void 0 ? equalityOpt : false;
  if (decl1.type_arity !== decl2.type_arity) {
    return /* :: */[
            /* Arity */0,
            /* [] */0
          ];
  }
  if (!private_flags(decl1, decl2)) {
    return /* :: */[
            /* Privacy */1,
            /* [] */0
          ];
  }
  var match = decl1.type_kind;
  var match$1 = decl2.type_kind;
  var err;
  var exit = 0;
  if (typeof match$1 === "number" && match$1 === 0) {
    err = /* [] */0;
  } else {
    exit = 1;
  }
  if (exit === 1) {
    if (typeof match === "number") {
      err = match === /* Type_abstract */0 || typeof match$1 !== "number" ? /* :: */[
          /* Kind */2,
          /* [] */0
        ] : /* [] */0;
    } else if (match.tag) {
      var cstrs1 = match[0];
      if (typeof match$1 === "number" || !match$1.tag) {
        err = /* :: */[
          /* Kind */2,
          /* [] */0
        ];
      } else {
        var cstrs2 = match$1[0];
        var mark = function (cstrs, usage, name, decl) {
          return List.iter((function (c) {
                        return mark_constructor_used(usage, env, name, decl, c.cd_id.name);
                      }), cstrs);
        };
        var usage = decl1.type_private === /* Private */0 || decl2.type_private === /* Public */1 ? /* Positive */0 : /* Privatize */2;
        mark(cstrs1, usage, name, decl1);
        if (equality) {
          mark(cstrs2, /* Positive */0, id.name, decl2);
        }
        err = compare_variants(env, decl1, decl2, 1, cstrs1, cstrs2);
      }
    } else if (typeof match$1 === "number" || match$1.tag) {
      err = /* :: */[
        /* Kind */2,
        /* [] */0
      ];
    } else {
      var rep2 = match$1[1];
      var err$1 = compare_records(env, decl1, decl2, 1, match[0], match$1[0]);
      err = err$1 !== /* [] */0 || match[1] === rep2 ? err$1 : /* :: */[
          /* Record_representation */Block.__(5, [rep2 === /* Record_float */1]),
          /* [] */0
        ];
    }
  }
  if (err !== /* [] */0) {
    return err;
  }
  var match$2 = decl1.type_manifest;
  var match$3 = decl2.type_manifest;
  var err$2;
  if (match$3 !== void 0) {
    if (match$2 !== void 0) {
      err$2 = type_manifest(env, match$2, decl1.type_params, match$3, decl2.type_params, decl2.type_private) ? /* [] */0 : /* :: */[
          /* Manifest */4,
          /* [] */0
        ];
    } else {
      var ty1 = newty2(100000000, /* Tconstr */Block.__(3, [
              /* Pident */Block.__(0, [id]),
              decl2.type_params,
              {
                contents: /* Mnil */0
              }
            ]));
      err$2 = equal$4(env, true, decl1.type_params, decl2.type_params) ? (
          equal$4(env, false, /* :: */[
                ty1,
                /* [] */0
              ], /* :: */[
                match$3,
                /* [] */0
              ]) ? /* [] */0 : /* :: */[
              /* Manifest */4,
              /* [] */0
            ]
        ) : /* :: */[
          /* Constraint */3,
          /* [] */0
        ];
    }
  } else {
    err$2 = equal$4(env, true, decl1.type_params, decl2.type_params) ? /* [] */0 : /* :: */[
        /* Constraint */3,
        /* [] */0
      ];
  }
  if (err$2 !== /* [] */0) {
    return err$2;
  }
  var abstr = decl2.type_private === /* Private */0 || decl2.type_kind === /* Type_abstract */0 && decl2.type_manifest === void 0;
  var opn = decl2.type_kind === /* Type_open */1 && decl2.type_manifest === void 0;
  if (List.for_all2((function (ty, param) {
            var v2 = param[1];
            var v1 = param[0];
            var match = Curry._1(Types_Variance.get_upper, v1);
            var cn1 = match[1];
            var co1 = match[0];
            var match$1 = Curry._1(Types_Variance.get_upper, v2);
            var cn2 = match$1[1];
            var co2 = match$1[0];
            if (!(
                abstr ? (!co1 || co2) && (!cn1 || cn2) : (
                    opn || !is_Tvar(repr(ty)) ? co1 === co2 && cn1 === cn2 : true
                  )
              )) {
              return false;
            }
            var match$2 = Curry._1(Types_Variance.get_lower, v1);
            var match$3 = Curry._1(Types_Variance.get_lower, v2);
            var b = (!match$3[0] || match$2[0]) && (!match$3[1] || match$2[1]) && (!match$3[2] || match$2[2]) && (!match$3[3] || match$2[3]);
            return abstr ? b : true;
          }), decl2.type_params, List.combine(decl1.type_variance, decl2.type_variance))) {
    return /* [] */0;
  } else {
    return /* :: */[
            /* Variance */5,
            /* [] */0
          ];
  }
}

function extension_constructors(env, id, ext1, ext2) {
  var usage = ext1.ext_private === /* Private */0 || ext2.ext_private === /* Public */1 ? /* Positive */0 : /* Privatize */2;
  mark_extension_used(usage, env, ext1, id.name);
  var ty1 = newty2(100000000, /* Tconstr */Block.__(3, [
          ext1.ext_type_path,
          ext1.ext_type_params,
          {
            contents: /* Mnil */0
          }
        ]));
  var ty2 = newty2(100000000, /* Tconstr */Block.__(3, [
          ext2.ext_type_path,
          ext2.ext_type_params,
          {
            contents: /* Mnil */0
          }
        ]));
  if (!equal$4(env, true, /* :: */[
          ty1,
          ext1.ext_type_params
        ], /* :: */[
          ty2,
          ext2.ext_type_params
        ])) {
    return false;
  }
  if (List.length(ext1.ext_args) !== List.length(ext2.ext_args)) {
    return false;
  }
  var match = ext1.ext_ret_type;
  var match$1 = ext2.ext_ret_type;
  var tmp;
  var exit = 0;
  if (match !== void 0) {
    if (match$1 !== void 0 && equal$4(env, true, /* :: */[
            match,
            /* [] */0
          ], /* :: */[
            match$1,
            /* [] */0
          ])) {
      exit = 1;
    } else {
      tmp = false;
    }
  } else if (match$1 !== void 0) {
    tmp = false;
  } else {
    exit = 1;
  }
  if (exit === 1) {
    tmp = for_all2((function (ty1, ty2) {
            return equal$4(env, true, /* :: */[
                        ty1,
                        ext1.ext_type_params
                      ], /* :: */[
                        ty2,
                        ext2.ext_type_params
                      ]);
          }), ext1.ext_args, ext2.ext_args);
  }
  if (!tmp) {
    return false;
  }
  var match$2 = ext1.ext_private;
  var match$3 = ext2.ext_private;
  if (match$2 || !match$3) {
    return true;
  } else {
    return false;
  }
}

function scrape(env, mty) {
  if (mty.tag) {
    return mty;
  }
  try {
    return scrape(env, find_modtype_expansion(mty[0], env));
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return mty;
    }
    throw exn;
  }
}

function strengthen$1(env, mty, p) {
  var mty$1 = scrape(env, mty);
  switch (mty$1.tag | 0) {
    case /* Mty_signature */1 :
        return /* Mty_signature */Block.__(1, [strengthen_sig(env, mty$1[0], p)]);
    case /* Mty_functor */2 :
        var param = mty$1[0];
        if (applicative_functors.contents && param.name !== "*") {
          return /* Mty_functor */Block.__(2, [
                    param,
                    mty$1[1],
                    strengthen$1(env, mty$1[2], /* Papply */Block.__(2, [
                            p,
                            /* Pident */Block.__(0, [param])
                          ]))
                  ]);
        } else {
          return mty$1;
        }
    case /* Mty_ident */0 :
    case /* Mty_alias */3 :
        return mty$1;
    
  }
}

function strengthen_sig(env, sg, p) {
  if (!sg) {
    return /* [] */0;
  }
  var sigelt = sg[0];
  switch (sigelt.tag | 0) {
    case /* Sig_type */1 :
        var decl = sigelt[1];
        var id = sigelt[0];
        var match = decl.type_manifest;
        var match$1 = decl.type_private;
        var match$2 = decl.type_kind;
        var newdecl;
        var exit = 0;
        if (match !== void 0 && (match$1 || typeof match$2 !== "number")) {
          newdecl = decl;
        } else {
          exit = 1;
        }
        if (exit === 1) {
          var manif = newty2(100000000, /* Tconstr */Block.__(3, [
                  /* Pdot */Block.__(1, [
                      p,
                      id.name,
                      -1
                    ]),
                  decl.type_params,
                  {
                    contents: /* Mnil */0
                  }
                ]));
          newdecl = decl.type_kind === /* Type_abstract */0 ? ({
                type_params: decl.type_params,
                type_arity: decl.type_arity,
                type_kind: decl.type_kind,
                type_private: /* Public */1,
                type_manifest: manif,
                type_variance: decl.type_variance,
                type_newtype_level: decl.type_newtype_level,
                type_loc: decl.type_loc,
                type_attributes: decl.type_attributes
              }) : ({
                type_params: decl.type_params,
                type_arity: decl.type_arity,
                type_kind: decl.type_kind,
                type_private: decl.type_private,
                type_manifest: manif,
                type_variance: decl.type_variance,
                type_newtype_level: decl.type_newtype_level,
                type_loc: decl.type_loc,
                type_attributes: decl.type_attributes
              });
        }
        return /* :: */[
                /* Sig_type */Block.__(1, [
                    id,
                    newdecl,
                    sigelt[2]
                  ]),
                strengthen_sig(env, sg[1], p)
              ];
    case /* Sig_module */3 :
        var md = sigelt[1];
        var id$1 = sigelt[0];
        var str = strengthen_decl(env, md, /* Pdot */Block.__(1, [
                p,
                id$1.name,
                -1
              ]));
        return /* :: */[
                /* Sig_module */Block.__(3, [
                    id$1,
                    str,
                    sigelt[2]
                  ]),
                strengthen_sig(add_module_declaration(void 0, id$1, md, env), sg[1], p)
              ];
    case /* Sig_modtype */4 :
        var decl$1 = sigelt[1];
        var id$2 = sigelt[0];
        var match$3 = decl$1.mtd_type;
        var newdecl$1 = match$3 !== void 0 ? decl$1 : ({
              mtd_type: /* Mty_ident */Block.__(0, [/* Pdot */Block.__(1, [
                      p,
                      id$2.name,
                      -1
                    ])]),
              mtd_attributes: decl$1.mtd_attributes,
              mtd_loc: decl$1.mtd_loc
            });
        return /* :: */[
                /* Sig_modtype */Block.__(4, [
                    id$2,
                    newdecl$1
                  ]),
                strengthen_sig(add_modtype$1(id$2, decl$1, env), sg[1], p)
              ];
    default:
      return /* :: */[
              sigelt,
              strengthen_sig(env, sg[1], p)
            ];
  }
}

function strengthen_decl(env, md, p) {
  return {
          md_type: strengthen$1(env, md.md_type, p),
          md_attributes: md.md_attributes,
          md_loc: md.md_loc
        };
}

strengthen.contents = strengthen$1;

function nondep_supertype(env, mid, mty) {
  var nondep_mty = function (env, va, _mty) {
    while(true) {
      var mty = _mty;
      switch (mty.tag | 0) {
        case /* Mty_ident */0 :
            var p = mty[0];
            if (!isfree(mid, p)) {
              return mty;
            }
            _mty = find_modtype_expansion(p, env);
            continue ;
        case /* Mty_signature */1 :
            return /* Mty_signature */Block.__(1, [nondep_sig(env, va, mty[0])]);
        case /* Mty_functor */2 :
            var arg = mty[1];
            var param = mty[0];
            var var_inv;
            switch (va) {
              case /* Co */0 :
                  var_inv = /* Contra */1;
                  break;
              case /* Contra */1 :
                  var_inv = /* Co */0;
                  break;
              case /* Strict */2 :
                  var_inv = /* Strict */2;
                  break;
              
            }
            return /* Mty_functor */Block.__(2, [
                      param,
                      may_map((function(var_inv){
                          return function (param) {
                            return nondep_mty(env, var_inv, param);
                          }
                          }(var_inv)), arg),
                      nondep_mty(add_module$1(true, param, default_mty(arg), env), va, mty[2])
                    ]);
        case /* Mty_alias */3 :
            var p$1 = mty[0];
            if (!isfree(mid, p$1)) {
              return mty;
            }
            _mty = find_module(false, p$1, env).md_type;
            continue ;
        
      }
    };
  };
  var nondep_sig = function (env, va, param) {
    if (!param) {
      return /* [] */0;
    }
    var item = param[0];
    var rem$prime = nondep_sig(env, va, param[1]);
    switch (item.tag | 0) {
      case /* Sig_value */0 :
          var d = item[1];
          return /* :: */[
                  /* Sig_value */Block.__(0, [
                      item[0],
                      {
                        val_type: nondep_type(env, mid, d.val_type),
                        val_kind: d.val_kind,
                        val_loc: d.val_loc,
                        val_attributes: d.val_attributes
                      }
                    ]),
                  rem$prime
                ];
      case /* Sig_type */1 :
          var id = item[0];
          return /* :: */[
                  /* Sig_type */Block.__(1, [
                      id,
                      nondep_type_decl(env, mid, id, va === /* Co */0, item[1]),
                      item[2]
                    ]),
                  rem$prime
                ];
      case /* Sig_typext */2 :
          return /* :: */[
                  /* Sig_typext */Block.__(2, [
                      item[0],
                      nondep_extension_constructor(env, mid, item[1]),
                      item[2]
                    ]),
                  rem$prime
                ];
      case /* Sig_module */3 :
          var md = item[1];
          return /* :: */[
                  /* Sig_module */Block.__(3, [
                      item[0],
                      {
                        md_type: nondep_mty(env, va, md.md_type),
                        md_attributes: md.md_attributes,
                        md_loc: md.md_loc
                      },
                      item[2]
                    ]),
                  rem$prime
                ];
      case /* Sig_modtype */4 :
          var id$1 = item[0];
          try {
            return /* :: */[
                    /* Sig_modtype */Block.__(4, [
                        id$1,
                        nondep_modtype_decl(env, item[1])
                      ]),
                    rem$prime
                  ];
          }
          catch (exn){
            if (exn !== Caml_builtin_exceptions.not_found) {
              throw exn;
            }
            if (va !== 0) {
              throw Caml_builtin_exceptions.not_found;
            }
            return /* :: */[
                    /* Sig_modtype */Block.__(4, [
                        id$1,
                        {
                          mtd_type: void 0,
                          mtd_attributes: /* [] */0,
                          mtd_loc: none
                        }
                      ]),
                    rem$prime
                  ];
          }
      case /* Sig_class */5 :
          return /* :: */[
                  /* Sig_class */Block.__(5, [
                      item[0],
                      nondep_class_declaration(env, mid, item[1]),
                      item[2]
                    ]),
                  rem$prime
                ];
      case /* Sig_class_type */6 :
          return /* :: */[
                  /* Sig_class_type */Block.__(6, [
                      item[0],
                      nondep_cltype_declaration(env, mid, item[1]),
                      item[2]
                    ]),
                  rem$prime
                ];
      
    }
  };
  var nondep_modtype_decl = function (env, mtd) {
    return {
            mtd_type: may_map((function (param) {
                    return nondep_mty(env, /* Strict */2, param);
                  }), mtd.mtd_type),
            mtd_attributes: mtd.mtd_attributes,
            mtd_loc: mtd.mtd_loc
          };
  };
  return nondep_mty(env, /* Co */0, mty);
}

function enrich_typedecl(env, p, decl) {
  var match = decl.type_manifest;
  if (match !== void 0) {
    return decl;
  }
  try {
    var orig_decl = find_type_full(p, env)[0];
    if (orig_decl.type_arity !== decl.type_arity) {
      return decl;
    } else {
      return {
              type_params: decl.type_params,
              type_arity: decl.type_arity,
              type_kind: decl.type_kind,
              type_private: decl.type_private,
              type_manifest: newty2(100000000, /* Tconstr */Block.__(3, [
                      p,
                      decl.type_params,
                      {
                        contents: /* Mnil */0
                      }
                    ])),
              type_variance: decl.type_variance,
              type_newtype_level: decl.type_newtype_level,
              type_loc: decl.type_loc,
              type_attributes: decl.type_attributes
            };
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return decl;
    }
    throw exn;
  }
}

function enrich_modtype(env, p, mty) {
  if (mty.tag === /* Mty_signature */1) {
    return /* Mty_signature */Block.__(1, [List.map((function (param) {
                      switch (param.tag | 0) {
                        case /* Sig_type */1 :
                            var id = param[0];
                            return /* Sig_type */Block.__(1, [
                                      id,
                                      enrich_typedecl(env, /* Pdot */Block.__(1, [
                                              p,
                                              id.name,
                                              -1
                                            ]), param[1]),
                                      param[2]
                                    ]);
                        case /* Sig_module */3 :
                            var md = param[1];
                            var id$1 = param[0];
                            return /* Sig_module */Block.__(3, [
                                      id$1,
                                      {
                                        md_type: enrich_modtype(env, /* Pdot */Block.__(1, [
                                                p,
                                                id$1.name,
                                                -1
                                              ]), md.md_type),
                                        md_attributes: md.md_attributes,
                                        md_loc: md.md_loc
                                      },
                                      param[2]
                                    ]);
                        default:
                          return param;
                      }
                    }), mty[0])]);
  } else {
    return mty;
  }
}

function type_paths(env, p, mty) {
  var match = scrape(env, mty);
  if (match.tag === /* Mty_signature */1) {
    return type_paths_sig(env, p, 0, match[0]);
  } else {
    return /* [] */0;
  }
}

function type_paths_sig(_env, p, _pos, _sg) {
  while(true) {
    var sg = _sg;
    var pos = _pos;
    var env = _env;
    if (!sg) {
      return /* [] */0;
    }
    var match = sg[0];
    switch (match.tag | 0) {
      case /* Sig_value */0 :
          var match$1 = match[1].val_kind;
          var pos$prime;
          pos$prime = typeof match$1 === "number" || match$1.tag ? pos + 1 | 0 : pos;
          _sg = sg[1];
          _pos = pos$prime;
          continue ;
      case /* Sig_type */1 :
          return /* :: */[
                  /* Pdot */Block.__(1, [
                      p,
                      match[0].name,
                      -1
                    ]),
                  type_paths_sig(env, p, pos, sg[1])
                ];
      case /* Sig_module */3 :
          var md = match[1];
          var id = match[0];
          return Pervasives.$at(type_paths(env, /* Pdot */Block.__(1, [
                            p,
                            id.name,
                            pos
                          ]), md.md_type), type_paths_sig(add_module_declaration(void 0, id, md, env), p, pos + 1 | 0, sg[1]));
      case /* Sig_modtype */4 :
          _sg = sg[1];
          _env = add_modtype$1(match[0], match[1], env);
          continue ;
      case /* Sig_typext */2 :
      case /* Sig_class */5 :
          break;
      case /* Sig_class_type */6 :
          _sg = sg[1];
          continue ;
      
    }
    _sg = sg[1];
    _pos = pos + 1 | 0;
    continue ;
  };
}

function contains_type(env, _param) {
  while(true) {
    var param = _param;
    switch (param.tag | 0) {
      case /* Mty_ident */0 :
          try {
            var match = find_modtype(param[0], env).mtd_type;
            if (match !== void 0) {
              return contains_type(env, match);
            }
            throw Pervasives.Exit;
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              throw Pervasives.Exit;
            }
            throw exn;
          }
      case /* Mty_signature */1 :
          return contains_type_sig(env)(param[0]);
      case /* Mty_functor */2 :
          _param = param[2];
          continue ;
      case /* Mty_alias */3 :
          return ;
      
    }
  };
}

function contains_type_sig(env) {
  return (function (param) {
      return List.iter((function (param) {
                    switch (param.tag | 0) {
                      case /* Sig_type */1 :
                          var match = param[1];
                          var match$1 = match.type_kind;
                          if (match.type_manifest === void 0) {
                            throw Pervasives.Exit;
                          }
                          if (typeof match$1 !== "number") {
                            return ;
                          }
                          if (match$1 !== 0) {
                            return ;
                          }
                          if (match.type_private) {
                            return ;
                          }
                          throw Pervasives.Exit;
                      case /* Sig_module */3 :
                          return contains_type(env, param[1].md_type);
                      case /* Sig_modtype */4 :
                          throw Pervasives.Exit;
                      default:
                        return ;
                    }
                  }), param);
    });
}

function contains_type$1(env, mty) {
  try {
    contains_type(env, mty);
    return false;
  }
  catch (exn){
    if (exn === Pervasives.Exit) {
      return true;
    }
    throw exn;
  }
}

function compare$3(p1, p2) {
  if (same(p1, p2)) {
    return 0;
  } else {
    return Caml_obj.caml_compare(p1, p2);
  }
}

function height$7(param) {
  if (param) {
    return param[/* h */3];
  } else {
    return 0;
  }
}

function create$8(l, v, r) {
  var hl = l ? l[/* h */3] : 0;
  var hr = r ? r[/* h */3] : 0;
  return /* Node */[
          /* l */l,
          /* v */v,
          /* r */r,
          /* h */hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        ];
}

function bal$7(l, v, r) {
  var hl = l ? l[/* h */3] : 0;
  var hr = r ? r[/* h */3] : 0;
  if (hl > (hr + 2 | 0)) {
    if (!l) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          ];
    }
    var lr = l[/* r */2];
    var lv = l[/* v */1];
    var ll = l[/* l */0];
    if (height$7(ll) >= height$7(lr)) {
      return create$8(ll, lv, create$8(lr, v, r));
    }
    if (lr) {
      return create$8(create$8(ll, lv, lr[/* l */0]), lr[/* v */1], create$8(lr[/* r */2], v, r));
    }
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Set.bal"
        ];
  } else {
    if (hr <= (hl + 2 | 0)) {
      return /* Node */[
              /* l */l,
              /* v */v,
              /* r */r,
              /* h */hl >= hr ? hl + 1 | 0 : hr + 1 | 0
            ];
    }
    if (!r) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          ];
    }
    var rr = r[/* r */2];
    var rv = r[/* v */1];
    var rl = r[/* l */0];
    if (height$7(rr) >= height$7(rl)) {
      return create$8(create$8(l, v, rl), rv, rr);
    }
    if (rl) {
      return create$8(create$8(l, v, rl[/* l */0]), rl[/* v */1], create$8(rl[/* r */2], rv, rr));
    }
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Set.bal"
        ];
  }
}

function add$9(x, t) {
  if (!t) {
    return /* Node */[
            /* l : Empty */0,
            /* v */x,
            /* r : Empty */0,
            /* h */1
          ];
  }
  var r = t[/* r */2];
  var v = t[/* v */1];
  var l = t[/* l */0];
  var c = compare$3(x, v);
  if (c === 0) {
    return t;
  }
  if (c < 0) {
    var ll = add$9(x, l);
    if (l === ll) {
      return t;
    } else {
      return bal$7(ll, v, r);
    }
  } else {
    var rr = add$9(x, r);
    if (r === rr) {
      return t;
    } else {
      return bal$7(l, v, rr);
    }
  }
}

function singleton$2(x) {
  return /* Node */[
          /* l : Empty */0,
          /* v */x,
          /* r : Empty */0,
          /* h */1
        ];
}

function add_min_element$2(x, param) {
  if (param) {
    return bal$7(add_min_element$2(x, param[/* l */0]), param[/* v */1], param[/* r */2]);
  } else {
    return singleton$2(x);
  }
}

function add_max_element$2(x, param) {
  if (param) {
    return bal$7(param[/* l */0], param[/* v */1], add_max_element$2(x, param[/* r */2]));
  } else {
    return singleton$2(x);
  }
}

function join$2(l, v, r) {
  if (!l) {
    return add_min_element$2(v, r);
  }
  if (!r) {
    return add_max_element$2(v, l);
  }
  var rh = r[/* h */3];
  var lh = l[/* h */3];
  if (lh > (rh + 2 | 0)) {
    return bal$7(l[/* l */0], l[/* v */1], join$2(l[/* r */2], v, r));
  } else if (rh > (lh + 2 | 0)) {
    return bal$7(join$2(l, v, r[/* l */0]), r[/* v */1], r[/* r */2]);
  } else {
    return create$8(l, v, r);
  }
}

function split$2(x, param) {
  if (!param) {
    return /* tuple */[
            /* Empty */0,
            false,
            /* Empty */0
          ];
  }
  var r = param[/* r */2];
  var v = param[/* v */1];
  var l = param[/* l */0];
  var c = compare$3(x, v);
  if (c === 0) {
    return /* tuple */[
            l,
            true,
            r
          ];
  }
  if (c < 0) {
    var match = split$2(x, l);
    return /* tuple */[
            match[0],
            match[1],
            join$2(match[2], v, r)
          ];
  } else {
    var match$1 = split$2(x, r);
    return /* tuple */[
            join$2(l, v, match$1[0]),
            match$1[1],
            match$1[2]
          ];
  }
}

function union$3(s1, s2) {
  if (!s1) {
    return s2;
  }
  if (!s2) {
    return s1;
  }
  var h2 = s2[/* h */3];
  var v2 = s2[/* v */1];
  var h1 = s1[/* h */3];
  var v1 = s1[/* v */1];
  if (h1 >= h2) {
    if (h2 === 1) {
      return add$9(v2, s1);
    }
    var match = split$2(v1, s2);
    return join$2(union$3(s1[/* l */0], match[0]), v1, union$3(s1[/* r */2], match[2]));
  } else {
    if (h1 === 1) {
      return add$9(v1, s2);
    }
    var match$1 = split$2(v2, s1);
    return join$2(union$3(match$1[0], s2[/* l */0]), v2, union$3(match$1[2], s2[/* r */2]));
  }
}

function fold$6(f, _s, _accu) {
  while(true) {
    var accu = _accu;
    var s = _s;
    if (!s) {
      return accu;
    }
    _accu = Curry._2(f, s[/* v */1], fold$6(f, s[/* l */0], accu));
    _s = s[/* r */2];
    continue ;
  };
}

function height$8(param) {
  if (param) {
    return param[/* h */4];
  } else {
    return 0;
  }
}

function create$9(l, x, d, r) {
  var hl = height$8(l);
  var hr = height$8(r);
  return /* Node */[
          /* l */l,
          /* v */x,
          /* d */d,
          /* r */r,
          /* h */hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        ];
}

function bal$8(l, x, d, r) {
  var hl = l ? l[/* h */4] : 0;
  var hr = r ? r[/* h */4] : 0;
  if (hl > (hr + 2 | 0)) {
    if (!l) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Map.bal"
          ];
    }
    var lr = l[/* r */3];
    var ld = l[/* d */2];
    var lv = l[/* v */1];
    var ll = l[/* l */0];
    if (height$8(ll) >= height$8(lr)) {
      return create$9(ll, lv, ld, create$9(lr, x, d, r));
    }
    if (lr) {
      return create$9(create$9(ll, lv, ld, lr[/* l */0]), lr[/* v */1], lr[/* d */2], create$9(lr[/* r */3], x, d, r));
    }
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Map.bal"
        ];
  } else {
    if (hr <= (hl + 2 | 0)) {
      return /* Node */[
              /* l */l,
              /* v */x,
              /* d */d,
              /* r */r,
              /* h */hl >= hr ? hl + 1 | 0 : hr + 1 | 0
            ];
    }
    if (!r) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Map.bal"
          ];
    }
    var rr = r[/* r */3];
    var rd = r[/* d */2];
    var rv = r[/* v */1];
    var rl = r[/* l */0];
    if (height$8(rr) >= height$8(rl)) {
      return create$9(create$9(l, x, d, rl), rv, rd, rr);
    }
    if (rl) {
      return create$9(create$9(l, x, d, rl[/* l */0]), rl[/* v */1], rl[/* d */2], create$9(rl[/* r */3], rv, rd, rr));
    }
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Map.bal"
        ];
  }
}

function add$10(x, data, m) {
  if (!m) {
    return /* Node */[
            /* l : Empty */0,
            /* v */x,
            /* d */data,
            /* r : Empty */0,
            /* h */1
          ];
  }
  var r = m[/* r */3];
  var d = m[/* d */2];
  var v = m[/* v */1];
  var l = m[/* l */0];
  var c = compare$3(x, v);
  if (c === 0) {
    if (d === data) {
      return m;
    } else {
      return /* Node */[
              /* l */l,
              /* v */x,
              /* d */data,
              /* r */r,
              /* h */m[/* h */4]
            ];
    }
  }
  if (c < 0) {
    var ll = add$10(x, data, l);
    if (l === ll) {
      return m;
    } else {
      return bal$8(ll, v, d, r);
    }
  } else {
    var rr = add$10(x, data, r);
    if (r === rr) {
      return m;
    } else {
      return bal$8(l, v, d, rr);
    }
  }
}

function find$5(x, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      throw Caml_builtin_exceptions.not_found;
    }
    var c = compare$3(x, param[/* v */1]);
    if (c === 0) {
      return param[/* d */2];
    }
    _param = c < 0 ? param[/* l */0] : param[/* r */3];
    continue ;
  };
}

function height$9(param) {
  if (param) {
    return param[/* h */3];
  } else {
    return 0;
  }
}

function create$10(l, v, r) {
  var hl = l ? l[/* h */3] : 0;
  var hr = r ? r[/* h */3] : 0;
  return /* Node */[
          /* l */l,
          /* v */v,
          /* r */r,
          /* h */hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        ];
}

function bal$9(l, v, r) {
  var hl = l ? l[/* h */3] : 0;
  var hr = r ? r[/* h */3] : 0;
  if (hl > (hr + 2 | 0)) {
    if (!l) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          ];
    }
    var lr = l[/* r */2];
    var lv = l[/* v */1];
    var ll = l[/* l */0];
    if (height$9(ll) >= height$9(lr)) {
      return create$10(ll, lv, create$10(lr, v, r));
    }
    if (lr) {
      return create$10(create$10(ll, lv, lr[/* l */0]), lr[/* v */1], create$10(lr[/* r */2], v, r));
    }
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Set.bal"
        ];
  } else {
    if (hr <= (hl + 2 | 0)) {
      return /* Node */[
              /* l */l,
              /* v */v,
              /* r */r,
              /* h */hl >= hr ? hl + 1 | 0 : hr + 1 | 0
            ];
    }
    if (!r) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          ];
    }
    var rr = r[/* r */2];
    var rv = r[/* v */1];
    var rl = r[/* l */0];
    if (height$9(rr) >= height$9(rl)) {
      return create$10(create$10(l, v, rl), rv, rr);
    }
    if (rl) {
      return create$10(create$10(l, v, rl[/* l */0]), rl[/* v */1], create$10(rl[/* r */2], rv, rr));
    }
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Set.bal"
        ];
  }
}

function add$11(x, t) {
  if (!t) {
    return /* Node */[
            /* l : Empty */0,
            /* v */x,
            /* r : Empty */0,
            /* h */1
          ];
  }
  var r = t[/* r */2];
  var v = t[/* v */1];
  var l = t[/* l */0];
  var c = Caml_obj.caml_compare(x, v);
  if (c === 0) {
    return t;
  }
  if (c < 0) {
    var ll = add$11(x, l);
    if (l === ll) {
      return t;
    } else {
      return bal$9(ll, v, r);
    }
  } else {
    var rr = add$11(x, r);
    if (r === rr) {
      return t;
    } else {
      return bal$9(l, v, rr);
    }
  }
}

function singleton$3(x) {
  return /* Node */[
          /* l : Empty */0,
          /* v */x,
          /* r : Empty */0,
          /* h */1
        ];
}

function add_min_element$3(x, param) {
  if (param) {
    return bal$9(add_min_element$3(x, param[/* l */0]), param[/* v */1], param[/* r */2]);
  } else {
    return singleton$3(x);
  }
}

function add_max_element$3(x, param) {
  if (param) {
    return bal$9(param[/* l */0], param[/* v */1], add_max_element$3(x, param[/* r */2]));
  } else {
    return singleton$3(x);
  }
}

function join$3(l, v, r) {
  if (!l) {
    return add_min_element$3(v, r);
  }
  if (!r) {
    return add_max_element$3(v, l);
  }
  var rh = r[/* h */3];
  var lh = l[/* h */3];
  if (lh > (rh + 2 | 0)) {
    return bal$9(l[/* l */0], l[/* v */1], join$3(l[/* r */2], v, r));
  } else if (rh > (lh + 2 | 0)) {
    return bal$9(join$3(l, v, r[/* l */0]), r[/* v */1], r[/* r */2]);
  } else {
    return create$10(l, v, r);
  }
}

function split$3(x, param) {
  if (!param) {
    return /* tuple */[
            /* Empty */0,
            false,
            /* Empty */0
          ];
  }
  var r = param[/* r */2];
  var v = param[/* v */1];
  var l = param[/* l */0];
  var c = Caml_obj.caml_compare(x, v);
  if (c === 0) {
    return /* tuple */[
            l,
            true,
            r
          ];
  }
  if (c < 0) {
    var match = split$3(x, l);
    return /* tuple */[
            match[0],
            match[1],
            join$3(match[2], v, r)
          ];
  } else {
    var match$1 = split$3(x, r);
    return /* tuple */[
            join$3(l, v, match$1[0]),
            match$1[1],
            match$1[2]
          ];
  }
}

function mem$5(x, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return false;
    }
    var c = Caml_obj.caml_compare(x, param[/* v */1]);
    if (c === 0) {
      return true;
    }
    _param = c < 0 ? param[/* l */0] : param[/* r */2];
    continue ;
  };
}

function union$4(s1, s2) {
  if (!s1) {
    return s2;
  }
  if (!s2) {
    return s1;
  }
  var h2 = s2[/* h */3];
  var v2 = s2[/* v */1];
  var h1 = s1[/* h */3];
  var v1 = s1[/* v */1];
  if (h1 >= h2) {
    if (h2 === 1) {
      return add$11(v2, s1);
    }
    var match = split$3(v1, s2);
    return join$3(union$4(s1[/* l */0], match[0]), v1, union$4(s1[/* r */2], match[2]));
  } else {
    if (h1 === 1) {
      return add$11(v1, s2);
    }
    var match$1 = split$3(v2, s1);
    return join$3(union$4(match$1[0], s2[/* l */0]), v2, union$4(match$1[2], s2[/* r */2]));
  }
}

function get_prefixes(param) {
  switch (param.tag | 0) {
    case /* Pident */0 :
        return /* Empty */0;
    case /* Pdot */1 :
    case /* Papply */2 :
        break;
    
  }
  var p = param[0];
  return add$9(p, get_prefixes(p));
}

function get_arg_paths(_param) {
  while(true) {
    var param = _param;
    switch (param.tag | 0) {
      case /* Pident */0 :
          return /* Empty */0;
      case /* Pdot */1 :
          _param = param[0];
          continue ;
      case /* Papply */2 :
          var p2 = param[1];
          return add$9(p2, union$3(get_prefixes(p2), union$3(get_arg_paths(param[0]), get_arg_paths(p2))));
      
    }
  };
}

function rollback_path(subst, _p) {
  while(true) {
    var p = _p;
    try {
      return /* Pident */Block.__(0, [find$5(p, subst)]);
    }
    catch (exn){
      if (exn !== Caml_builtin_exceptions.not_found) {
        throw exn;
      }
      switch (p.tag | 0) {
        case /* Pdot */1 :
            var p1 = p[0];
            var p1$prime = rollback_path(subst, p1);
            if (same(p1, p1$prime)) {
              return p;
            }
            _p = /* Pdot */Block.__(1, [
                p1$prime,
                p[1],
                p[2]
              ]);
            continue ;
        case /* Pident */0 :
        case /* Papply */2 :
            return p;
        
      }
    }
  };
}

function collect_ids(subst, bindings, p) {
  var match = rollback_path(subst, p);
  switch (match.tag | 0) {
    case /* Pident */0 :
        var id = match[0];
        var ids;
        try {
          ids = collect_ids(subst, bindings, find_same(id, bindings));
        }
        catch (exn){
          if (exn !== Caml_builtin_exceptions.not_found) {
            throw exn;
          }
          ids = /* Empty */0;
        }
        return add$11(id, ids);
    case /* Pdot */1 :
    case /* Papply */2 :
        return /* Empty */0;
    
  }
}

function collect_arg_paths(mty) {
  var paths = {
    contents: /* Empty */0
  };
  var subst = {
    contents: /* Empty */0
  };
  var bindings = {
    contents: /* Empty */0
  };
  var it_path = function (p) {
    paths.contents = union$3(get_arg_paths(p), paths.contents);
    
  };
  var it_signature_item$1 = function (it, si) {
    it_signature_item(it, si);
    if (si.tag !== /* Sig_module */3) {
      return ;
    }
    var match = si[1].md_type;
    var id = si[0];
    switch (match.tag | 0) {
      case /* Mty_signature */1 :
          return List.iter((function (param) {
                        if (param.tag !== /* Sig_module */3) {
                          return ;
                        }
                        var id$prime = param[0];
                        subst.contents = add$10(/* Pdot */Block.__(1, [
                                /* Pident */Block.__(0, [id]),
                                id$prime.name,
                                -1
                              ]), id$prime, subst.contents);
                        
                      }), match[0]);
      case /* Mty_ident */0 :
      case /* Mty_functor */2 :
          return ;
      case /* Mty_alias */3 :
          bindings.contents = add(id, match[0], bindings.contents);
          return ;
      
    }
  };
  var it = {
    it_signature: it_signature,
    it_signature_item: it_signature_item$1,
    it_value_description: it_value_description,
    it_type_declaration: it_type_declaration,
    it_extension_constructor: it_extension_constructor,
    it_module_declaration: it_module_declaration,
    it_modtype_declaration: it_modtype_declaration,
    it_class_declaration: it_class_declaration,
    it_class_type_declaration: it_class_type_declaration,
    it_module_type: it_module_type,
    it_class_type: it_class_type,
    it_type_kind: it_type_kind,
    it_do_type_expr: it_do_type_expr,
    it_type_expr: it_type_expr,
    it_path: it_path
  };
  it_module_type(it, mty);
  it_module_type(unmark_iterators, mty);
  return fold$6((function (p) {
                var partial_arg = collect_ids(subst.contents, bindings.contents, p);
                return (function (param) {
                    return union$4(partial_arg, param);
                  });
              }), paths.contents, /* Empty */0);
}

function remove_aliases(env, excl, _mty) {
  while(true) {
    var mty = _mty;
    switch (mty.tag | 0) {
      case /* Mty_signature */1 :
          return /* Mty_signature */Block.__(1, [remove_aliases_sig(env, excl, mty[0])]);
      case /* Mty_ident */0 :
      case /* Mty_functor */2 :
          return mty;
      case /* Mty_alias */3 :
          var mty$prime = scrape_alias(env, void 0, mty);
          if (Caml_obj.caml_equal(mty$prime, mty)) {
            return mty;
          }
          _mty = mty$prime;
          continue ;
      
    }
  };
}

function remove_aliases_sig(env, excl, sg) {
  if (!sg) {
    return /* [] */0;
  }
  var it = sg[0];
  switch (it.tag | 0) {
    case /* Sig_module */3 :
        var md = it[1];
        var id = it[0];
        var mty = md.md_type;
        var mty$1;
        mty$1 = mty.tag === /* Mty_alias */3 && mem$5(id, excl) ? md.md_type : remove_aliases(env, excl, mty);
        return /* :: */[
                /* Sig_module */Block.__(3, [
                    id,
                    {
                      md_type: mty$1,
                      md_attributes: md.md_attributes,
                      md_loc: md.md_loc
                    },
                    it[2]
                  ]),
                remove_aliases_sig(add_module$1(void 0, id, mty$1, env), excl, sg[1])
              ];
    case /* Sig_modtype */4 :
        var mtd = it[1];
        var id$1 = it[0];
        return /* :: */[
                /* Sig_modtype */Block.__(4, [
                    id$1,
                    mtd
                  ]),
                remove_aliases_sig(add_modtype$1(id$1, mtd, env), excl, sg[1])
              ];
    default:
      return /* :: */[
              it,
              remove_aliases_sig(env, excl, sg[1])
            ];
  }
}

function remove_aliases$1(env, sg) {
  var excl = collect_arg_paths(sg);
  return remove_aliases(env, excl, sg);
}

var $$Error$5 = Caml_exceptions.create("Ocaml_typedtree_test.Includemod.Error");

function value_descriptions(env, cxt, subst, id, vd1, vd2) {
  record_value_dependency(vd1, vd2);
  mark_value_used(env, id.name, vd1);
  var vd2$1 = value_description(subst, vd2);
  try {
    if (!moregeneral(env, true, vd1.val_type, vd2$1.val_type)) {
      throw Dont_match;
    }
    var match = vd1.val_kind;
    var match$1 = vd2$1.val_kind;
    if (typeof match !== "number" && !match.tag) {
      var p1 = match[0];
      if (typeof match$1 === "number") {
        return /* Tcoerce_primitive */Block.__(2, [
                  id,
                  p1
                ]);
      }
      if (match$1.tag) {
        return /* Tcoerce_primitive */Block.__(2, [
                  id,
                  p1
                ]);
      }
      if (Caml_obj.caml_equal(p1, match$1[0])) {
        return /* Tcoerce_none */0;
      }
      throw Dont_match;
    }
    if (typeof match$1 === "number") {
      return /* Tcoerce_none */0;
    }
    if (match$1.tag) {
      return /* Tcoerce_none */0;
    }
    throw Dont_match;
  }
  catch (exn){
    if (exn === Dont_match) {
      throw [
            $$Error$5,
            /* :: */[
              /* tuple */[
                cxt,
                env,
                /* Value_descriptions */Block.__(1, [
                    id,
                    vd1,
                    vd2$1
                  ])
              ],
              /* [] */0
            ]
          ];
    }
    throw exn;
  }
}

function type_declarations$2(env, old_envOpt, cxt, subst, id, decl1, decl2) {
  var old_env = old_envOpt !== void 0 ? Caml_option.valFromOption(old_envOpt) : env;
  mark_type_used(env, id.name, decl1);
  var decl2$1 = type_declaration(subst, decl2);
  var err = type_declarations$1(void 0, env, id.name, decl1, id, decl2$1);
  if (err !== /* [] */0) {
    throw [
          $$Error$5,
          /* :: */[
            /* tuple */[
              cxt,
              old_env,
              /* Type_declarations */Block.__(2, [
                  id,
                  decl1,
                  decl2$1,
                  err
                ])
            ],
            /* [] */0
          ]
        ];
  }
  
}

function extension_constructors$1(env, cxt, subst, id, ext1, ext2) {
  var ext2$1 = extension_constructor(subst, ext2);
  if (extension_constructors(env, id, ext1, ext2$1)) {
    return ;
  }
  throw [
        $$Error$5,
        /* :: */[
          /* tuple */[
            cxt,
            env,
            /* Extension_constructors */Block.__(3, [
                id,
                ext1,
                ext2$1
              ])
          ],
          /* [] */0
        ]
      ];
}

function class_type_declarations$1(old_env, env, cxt, subst, id, decl1, decl2) {
  var decl2$1 = cltype_declaration(subst, decl2);
  var reason = class_type_declarations(env, decl1, decl2$1);
  if (reason) {
    throw [
          $$Error$5,
          /* :: */[
            /* tuple */[
              cxt,
              old_env,
              /* Class_type_declarations */Block.__(7, [
                  id,
                  decl1,
                  decl2$1,
                  reason
                ])
            ],
            /* [] */0
          ]
        ];
  }
  
}

function class_declarations$1(old_env, env, cxt, subst, id, decl1, decl2) {
  var decl2$1 = class_declaration(subst, decl2);
  var reason = class_declarations(env, decl1, decl2$1);
  if (reason) {
    throw [
          $$Error$5,
          /* :: */[
            /* tuple */[
              cxt,
              old_env,
              /* Class_declarations */Block.__(8, [
                  id,
                  decl1,
                  decl2$1,
                  reason
                ])
            ],
            /* [] */0
          ]
        ];
  }
  
}

var Dont_match$1 = Caml_exceptions.create("Ocaml_typedtree_test.Includemod.Dont_match");

function may_expand_module_path(env, path) {
  try {
    find_modtype_expansion(path, env);
    return true;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return false;
    }
    throw exn;
  }
}

function expand_module_path(env, cxt, path) {
  try {
    return find_modtype_expansion(path, env);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      throw [
            $$Error$5,
            /* :: */[
              /* tuple */[
                cxt,
                env,
                /* Unbound_modtype_path */Block.__(9, [path])
              ],
              /* [] */0
            ]
          ];
    }
    throw exn;
  }
}

function expand_module_alias(env, cxt, path) {
  try {
    return find_module(false, path, env).md_type;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      throw [
            $$Error$5,
            /* :: */[
              /* tuple */[
                cxt,
                env,
                /* Unbound_module_path */Block.__(10, [path])
              ],
              /* [] */0
            ]
          ];
    }
    throw exn;
  }
}

function kind_of_field_desc(param) {
  switch (param.tag | 0) {
    case /* Field_value */0 :
        return "value";
    case /* Field_type */1 :
        return "type";
    case /* Field_typext */2 :
        return "extension constructor";
    case /* Field_module */3 :
        return "module";
    case /* Field_modtype */4 :
        return "module type";
    case /* Field_class */5 :
        return "class";
    case /* Field_classtype */6 :
        return "class type";
    
  }
}

function item_ident_name(param) {
  switch (param.tag | 0) {
    case /* Sig_value */0 :
        var id = param[0];
        return /* tuple */[
                id,
                param[1].val_loc,
                /* Field_value */Block.__(0, [id.name])
              ];
    case /* Sig_type */1 :
        var id$1 = param[0];
        return /* tuple */[
                id$1,
                param[1].type_loc,
                /* Field_type */Block.__(1, [id$1.name])
              ];
    case /* Sig_typext */2 :
        var id$2 = param[0];
        return /* tuple */[
                id$2,
                param[1].ext_loc,
                /* Field_typext */Block.__(2, [id$2.name])
              ];
    case /* Sig_module */3 :
        var id$3 = param[0];
        return /* tuple */[
                id$3,
                param[1].md_loc,
                /* Field_module */Block.__(3, [id$3.name])
              ];
    case /* Sig_modtype */4 :
        var id$4 = param[0];
        return /* tuple */[
                id$4,
                param[1].mtd_loc,
                /* Field_modtype */Block.__(4, [id$4.name])
              ];
    case /* Sig_class */5 :
        var id$5 = param[0];
        return /* tuple */[
                id$5,
                param[1].cty_loc,
                /* Field_class */Block.__(5, [id$5.name])
              ];
    case /* Sig_class_type */6 :
        var id$6 = param[0];
        return /* tuple */[
                id$6,
                param[1].clty_loc,
                /* Field_classtype */Block.__(6, [id$6.name])
              ];
    
  }
}

function is_runtime_component(param) {
  switch (param.tag | 0) {
    case /* Sig_value */0 :
        var tmp = param[1].val_kind;
        if (typeof tmp === "number" || tmp.tag) {
          return true;
        } else {
          return false;
        }
    case /* Sig_type */1 :
    case /* Sig_modtype */4 :
    case /* Sig_class_type */6 :
        return false;
    default:
      return true;
  }
}

function modtypes(env, cxt, subst, mty1, mty2) {
  try {
    return try_modtypes(env, cxt, subst, mty1, mty2);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    if (err === Dont_match$1) {
      throw [
            $$Error$5,
            /* :: */[
              /* tuple */[
                cxt,
                env,
                /* Module_types */Block.__(4, [
                    mty1,
                    modtype(subst, mty2)
                  ])
              ],
              /* [] */0
            ]
          ];
    }
    if (err[0] !== $$Error$5) {
      throw err;
    }
    if (mty1.tag === /* Mty_alias */3) {
      throw err;
    }
    if (mty2.tag === /* Mty_alias */3) {
      throw err;
    }
    throw [
          $$Error$5,
          /* :: */[
            /* tuple */[
              cxt,
              env,
              /* Module_types */Block.__(4, [
                  mty1,
                  modtype(subst, mty2)
                ])
            ],
            err[1]
          ]
        ];
  }
}

function try_modtypes(env, cxt, subst, _mty1, mty2) {
  while(true) {
    var mty1 = _mty1;
    switch (mty1.tag | 0) {
      case /* Mty_ident */0 :
          var p1 = mty1[0];
          if (may_expand_module_path(env, p1)) {
            _mty1 = expand_module_path(env, cxt, p1);
            continue ;
          }
          break;
      case /* Mty_signature */1 :
          switch (mty2.tag | 0) {
            case /* Mty_ident */0 :
                break;
            case /* Mty_signature */1 :
                return signatures(env, cxt, subst, mty1[0], mty2[0]);
            case /* Mty_functor */2 :
            case /* Mty_alias */3 :
                throw Dont_match$1;
            
          }
          break;
      case /* Mty_functor */2 :
          var match = mty1[1];
          var param1 = mty1[0];
          if (match !== void 0) {
            switch (mty2.tag | 0) {
              case /* Mty_ident */0 :
                  break;
              case /* Mty_functor */2 :
                  var match$1 = mty2[1];
                  if (match$1 === void 0) {
                    throw Dont_match$1;
                  }
                  var arg2$prime = modtype(subst, match$1);
                  var cc_arg = modtypes(env, /* :: */[
                        /* Arg */Block.__(2, [param1]),
                        cxt
                      ], identity, arg2$prime, match);
                  var cc_res = modtypes(add_module$1(void 0, param1, arg2$prime, env), /* :: */[
                        /* Body */Block.__(3, [param1]),
                        cxt
                      ], add_module(mty2[0], /* Pident */Block.__(0, [param1]), subst), mty1[2], mty2[2]);
                  if (typeof cc_arg === "number" && typeof cc_res === "number") {
                    return /* Tcoerce_none */0;
                  } else {
                    return /* Tcoerce_functor */Block.__(1, [
                              cc_arg,
                              cc_res
                            ]);
                  }
              case /* Mty_signature */1 :
              case /* Mty_alias */3 :
                  throw Dont_match$1;
              
            }
          } else {
            switch (mty2.tag | 0) {
              case /* Mty_ident */0 :
                  break;
              case /* Mty_functor */2 :
                  if (mty2[1] !== void 0) {
                    throw Dont_match$1;
                  }
                  var cc = modtypes(env, /* :: */[
                        /* Body */Block.__(3, [param1]),
                        cxt
                      ], subst, mty1[2], mty2[2]);
                  if (typeof cc === "number") {
                    return /* Tcoerce_none */0;
                  } else {
                    return /* Tcoerce_functor */Block.__(1, [
                              /* Tcoerce_none */0,
                              cc
                            ]);
                  }
              case /* Mty_signature */1 :
              case /* Mty_alias */3 :
                  throw Dont_match$1;
              
            }
          }
          break;
      case /* Mty_alias */3 :
          var p1$1 = mty1[0];
          if (mty2.tag === /* Mty_alias */3) {
            var p2 = mty2[0];
            if (is_functor_arg(p2, env)) {
              throw [
                    $$Error$5,
                    /* :: */[
                      /* tuple */[
                        cxt,
                        env,
                        /* Invalid_module_alias */Block.__(11, [p2])
                      ],
                      /* [] */0
                    ]
                  ];
            }
            if (same(p1$1, p2)) {
              return /* Tcoerce_none */0;
            }
            var p1$2 = normalize_path$1(void 0, env, p1$1);
            var p2$1 = normalize_path$1(void 0, env, module_path(subst, p2));
            if (same(p1$2, p2$1)) {
              return /* Tcoerce_none */0;
            }
            throw Dont_match$1;
          } else {
            var p1$3;
            try {
              p1$3 = normalize_path$1(none, env, p1$1);
            }
            catch (raw_exn){
              var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
              if (exn[0] !== $$Error$2) {
                throw exn;
              }
              var match$2 = exn[1];
              if (match$2.tag === /* Missing_module */3) {
                throw [
                      $$Error$5,
                      /* :: */[
                        /* tuple */[
                          cxt,
                          env,
                          /* Unbound_module_path */Block.__(10, [match$2[2]])
                        ],
                        /* [] */0
                      ]
                    ];
              }
              throw exn;
            }
            var mty1$1 = strengthen$1(env, expand_module_alias(env, cxt, p1$3), p1$3);
            return /* Tcoerce_alias */Block.__(3, [
                      p1$3,
                      modtypes(env, cxt, subst, mty1$1, mty2)
                    ]);
          }
      
    }
    if (mty2.tag) {
      throw Dont_match$1;
    }
    var mty2$1 = modtype(subst, mty2);
    if (!mty1.tag) {
      if (mty2$1.tag) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "includemod.ml",
                275,
                6
              ]
            ];
      }
      if (same(mty1[0], mty2$1[0])) {
        return /* Tcoerce_none */0;
      }
      
    }
    if (mty2$1.tag) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "includemod.ml",
              275,
              6
            ]
          ];
    }
    return try_modtypes(env, cxt, identity, mty1, expand_module_path(env, cxt, mty2$1[0]));
  };
}

function signatures(env, cxt, subst, sig1, sig2) {
  var new_env = add_signature(sig1, in_signature(env));
  var match = List.fold_left((function (param, item) {
          var pos = param[1];
          var l = param[0];
          if (item.tag === /* Sig_module */3) {
            return /* tuple */[
                    /* :: */[
                      /* tuple */[
                        item[0],
                        pos,
                        /* Tcoerce_none */0
                      ],
                      l
                    ],
                    pos + 1 | 0
                  ];
          } else {
            return /* tuple */[
                    l,
                    is_runtime_component(item) ? pos + 1 | 0 : pos
                  ];
          }
        }), /* tuple */[
        /* [] */0,
        0
      ], sig1);
  var id_pos_list = match[0];
  var build_component_table = function (_pos, _tbl, _param) {
    while(true) {
      var param = _param;
      var tbl = _tbl;
      var pos = _pos;
      if (!param) {
        return /* tuple */[
                pos,
                tbl
              ];
      }
      var item = param[0];
      var match = item_ident_name(item);
      var nextpos = is_runtime_component(item) ? pos + 1 | 0 : pos;
      _param = param[1];
      _tbl = add$5(match[2], /* tuple */[
            match[0],
            item,
            pos
          ], tbl);
      _pos = nextpos;
      continue ;
    };
  };
  var match$1 = build_component_table(0, /* Empty */0, sig1);
  var comps1 = match$1[1];
  var len1 = match$1[0];
  var len2 = List.fold_left((function (n, i) {
          if (is_runtime_component(i)) {
            return n + 1 | 0;
          } else {
            return n;
          }
        }), 0, sig2);
  var pair_components = function (subst, paired, _unpaired, _param) {
    while(true) {
      var param = _param;
      var unpaired = _unpaired;
      if (param) {
        var rem = param[1];
        var item2 = param[0];
        var match = item_ident_name(item2);
        var name2 = match[2];
        var id2 = match[0];
        var match$1;
        if (item2.tag === /* Sig_type */1 && !(item2[1].type_manifest !== void 0 || name2.tag !== /* Field_type */1)) {
          var s = name2[0];
          var l = s.length;
          match$1 = l >= 4 && $$String.sub(s, l - 4 | 0, 4) === "#row" ? /* tuple */[
              /* Field_type */Block.__(1, [$$String.sub(s, 0, s.length - 4 | 0)]),
              false
            ] : /* tuple */[
              name2,
              true
            ];
        } else {
          match$1 = /* tuple */[
            name2,
            true
          ];
        }
        var name2$1 = match$1[0];
        try {
          var match$2 = find$2(name2$1, comps1);
          var id1 = match$2[0];
          var new_subst;
          switch (item2.tag | 0) {
            case /* Sig_type */1 :
                new_subst = add_type(id2, /* Pident */Block.__(0, [id1]), subst);
                break;
            case /* Sig_module */3 :
                new_subst = add_module(id2, /* Pident */Block.__(0, [id1]), subst);
                break;
            case /* Sig_modtype */4 :
                new_subst = add_modtype(id2, /* Mty_ident */Block.__(0, [/* Pident */Block.__(0, [id1])]), subst);
                break;
            default:
              new_subst = subst;
          }
          return pair_components(new_subst, /* :: */[
                      /* tuple */[
                        match$2[1],
                        item2,
                        match$2[2]
                      ],
                      paired
                    ], unpaired, rem);
        }
        catch (exn){
          if (exn !== Caml_builtin_exceptions.not_found) {
            throw exn;
          }
          var unpaired$1 = match$1[1] ? /* :: */[
              /* tuple */[
                cxt,
                env,
                /* Missing_field */Block.__(0, [
                    id2,
                    match[1],
                    kind_of_field_desc(name2$1)
                  ])
              ],
              unpaired
            ] : unpaired;
          _param = rem;
          _unpaired = unpaired$1;
          continue ;
        }
      } else {
        if (unpaired) {
          throw [
                $$Error$5,
                unpaired
              ];
        }
        var cc = signature_components(env, new_env, cxt, subst, List.rev(paired));
        if (len1 === len2) {
          var is_identity_coercion = function (_pos, _param) {
            while(true) {
              var param = _param;
              var pos = _pos;
              if (!param) {
                return true;
              }
              var match = param[0];
              if (match[0] !== pos) {
                return false;
              }
              if (match[1] !== /* Tcoerce_none */0) {
                return false;
              }
              _param = param[1];
              _pos = pos + 1 | 0;
              continue ;
            };
          };
          if (is_identity_coercion(0, cc)) {
            return /* Tcoerce_none */0;
          } else {
            return /* Tcoerce_structure */Block.__(0, [
                      cc,
                      id_pos_list
                    ]);
          }
        } else {
          return /* Tcoerce_structure */Block.__(0, [
                    cc,
                    id_pos_list
                  ]);
        }
      }
    };
  };
  return pair_components(subst, /* [] */0, /* [] */0, sig2);
}

function signature_components(old_env, env, cxt, subst, paired) {
  var comps_rec = function (rem) {
    return signature_components(old_env, env, cxt, subst, rem);
  };
  if (!paired) {
    return /* [] */0;
  }
  var match = paired[0];
  var match$1 = match[0];
  switch (match$1.tag | 0) {
    case /* Sig_value */0 :
        var match$2 = match[1];
        if (!match$2.tag) {
          var rem = paired[1];
          var pos = match[2];
          var valdecl2 = match$2[1];
          var cc = value_descriptions(env, cxt, subst, match$1[0], match$1[1], valdecl2);
          var match$3 = valdecl2.val_kind;
          if (typeof match$3 === "number" || match$3.tag) {
            return /* :: */[
                    /* tuple */[
                      pos,
                      cc
                    ],
                    comps_rec(rem)
                  ];
          } else {
            return comps_rec(rem);
          }
        }
        break;
    case /* Sig_type */1 :
        var match$4 = match[1];
        if (match$4.tag === /* Sig_type */1) {
          type_declarations$2(env, Caml_option.some(old_env), cxt, subst, match$1[0], match$1[1], match$4[1]);
          return comps_rec(paired[1]);
        }
        break;
    case /* Sig_typext */2 :
        var match$5 = match[1];
        if (match$5.tag === /* Sig_typext */2) {
          extension_constructors$1(env, cxt, subst, match$1[0], match$1[1], match$5[1]);
          return /* :: */[
                  /* tuple */[
                    match[2],
                    /* Tcoerce_none */0
                  ],
                  comps_rec(paired[1])
                ];
        }
        break;
    case /* Sig_module */3 :
        var match$6 = match[1];
        if (match$6.tag === /* Sig_module */3) {
          var id1 = match$1[0];
          var cc$1 = modtypes(env, /* :: */[
                /* Module */Block.__(0, [id1]),
                cxt
              ], subst, strengthen$1(env, match$1[1].md_type, /* Pident */Block.__(0, [id1])), match$6[1].md_type);
          return /* :: */[
                  /* tuple */[
                    match[2],
                    cc$1
                  ],
                  comps_rec(paired[1])
                ];
        }
        break;
    case /* Sig_modtype */4 :
        var match$7 = match[1];
        if (match$7.tag === /* Sig_modtype */4) {
          modtype_infos(env, cxt, subst, match$1[0], match$1[1], match$7[1]);
          return comps_rec(paired[1]);
        }
        break;
    case /* Sig_class */5 :
        var match$8 = match[1];
        if (match$8.tag === /* Sig_class */5) {
          class_declarations$1(old_env, env, cxt, subst, match$1[0], match$1[1], match$8[1]);
          return /* :: */[
                  /* tuple */[
                    match[2],
                    /* Tcoerce_none */0
                  ],
                  comps_rec(paired[1])
                ];
        }
        break;
    case /* Sig_class_type */6 :
        var match$9 = match[1];
        if (match$9.tag === /* Sig_class_type */6) {
          class_type_declarations$1(old_env, env, cxt, subst, match$1[0], match$1[1], match$9[1]);
          return comps_rec(paired[1]);
        }
        break;
    
  }
  throw [
        Caml_builtin_exceptions.assert_failure,
        /* tuple */[
          "includemod.ml",
          400,
          6
        ]
      ];
}

function modtype_infos(env, cxt, subst, id, info1, info2) {
  var info2$1 = modtype_declaration(subst, info2);
  var cxt$prime_000 = /* Modtype */Block.__(1, [id]);
  var cxt$prime = /* :: */[
    cxt$prime_000,
    cxt
  ];
  try {
    var match = info1.mtd_type;
    var match$1 = info2$1.mtd_type;
    if (match !== void 0) {
      if (match$1 !== void 0) {
        return check_modtype_equiv(env, cxt$prime, match, match$1);
      } else {
        return ;
      }
    } else if (match$1 !== void 0) {
      return check_modtype_equiv(env, cxt$prime, /* Mty_ident */Block.__(0, [/* Pident */Block.__(0, [id])]), match$1);
    } else {
      return ;
    }
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === $$Error$5) {
      throw [
            $$Error$5,
            /* :: */[
              /* tuple */[
                cxt,
                env,
                /* Modtype_infos */Block.__(5, [
                    id,
                    info1,
                    info2$1
                  ])
              ],
              exn[1]
            ]
          ];
    }
    throw exn;
  }
}

function check_modtype_equiv(env, cxt, mty1, mty2) {
  var match = modtypes(env, cxt, identity, mty1, mty2);
  var match$1 = modtypes(env, cxt, identity, mty2, mty1);
  if (typeof match === "number" && typeof match$1 === "number") {
    return ;
  }
  throw [
        $$Error$5,
        /* :: */[
          /* tuple */[
            cxt,
            env,
            /* Modtype_permutation */0
          ],
          /* [] */0
        ]
      ];
}

function check_modtype_inclusion$1(env, mty1, path1, mty2) {
  try {
    modtypes(env, /* [] */0, identity, strengthen$1(env, mty1, path1), mty2);
    return ;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === $$Error$5) {
      throw Caml_builtin_exceptions.not_found;
    }
    throw exn;
  }
}

check_modtype_inclusion.contents = check_modtype_inclusion$1;

function compunit(env, impl_name, impl_sig, intf_name, intf_sig) {
  try {
    return signatures(env, /* [] */0, identity, impl_sig, intf_sig);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === $$Error$5) {
      throw [
            $$Error$5,
            /* :: */[
              /* tuple */[
                /* [] */0,
                empty,
                /* Interface_mismatch */Block.__(6, [
                    impl_name,
                    intf_name
                  ])
              ],
              exn[1]
            ]
          ];
    }
    throw exn;
  }
}

function modtypes$1(env, mty1, mty2) {
  return modtypes(env, /* [] */0, identity, mty1, mty2);
}

function type_declarations$3(env, id, decl1, decl2) {
  return type_declarations$2(env, void 0, /* [] */0, identity, id, decl1, decl2);
}

function show_loc(msg, ppf, loc) {
  var pos = loc.loc_start;
  if (List.mem(pos.pos_fname, /* :: */[
          "",
          /* :: */[
            "_none_",
            /* :: */[
              "//toplevel//",
              /* [] */0
            ]
          ]
        ])) {
    return ;
  } else {
    return Curry._3(Format.fprintf(ppf, /* Format */[
                    /* Formatting_lit */Block.__(17, [
                        /* Force_newline */3,
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<2>",
                                      /* End_of_format */0
                                    ]),
                                  "<2>"
                                ]]),
                            /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                    /* ":" */58,
                                    /* Formatting_lit */Block.__(17, [
                                        /* Break */Block.__(0, [
                                            "@ ",
                                            1,
                                            0
                                          ]),
                                        /* String */Block.__(2, [
                                            /* No_padding */0,
                                            /* Formatting_lit */Block.__(17, [
                                                /* Close_box */0,
                                                /* End_of_format */0
                                              ])
                                          ])
                                      ])
                                  ])])
                          ])
                      ]),
                    "@\n@[<2>%a:@ %s@]"
                  ]), print_loc, loc, msg);
  }
}

function show_locs(ppf, param) {
  show_loc("Expected declaration", ppf, param[1]);
  return show_loc("Actual declaration", ppf, param[0]);
}

function include_err$1(ppf, param) {
  if (typeof param === "number") {
    return Format.fprintf(ppf, /* Format */[
                /* String_literal */Block.__(11, [
                    "Illegal permutation of structure fields",
                    /* End_of_format */0
                  ]),
                "Illegal permutation of structure fields"
              ]);
  }
  switch (param.tag | 0) {
    case /* Missing_field */0 :
        Curry._3(Format.fprintf(ppf, /* Format */[
                  /* String_literal */Block.__(11, [
                      "The ",
                      /* String */Block.__(2, [
                          /* No_padding */0,
                          /* String_literal */Block.__(11, [
                              " `",
                              /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                      "' is required but not provided",
                                      /* End_of_format */0
                                    ])])
                            ])
                        ])
                    ]),
                  "The %s `%a' is required but not provided"
                ]), param[2], ident$3, param[0]);
        return show_loc("Expected declaration", ppf, param[1]);
    case /* Value_descriptions */1 :
        var d2 = param[2];
        var d1 = param[1];
        var id = param[0];
        Curry._4(Format.fprintf(ppf, /* Format */[
                  /* Formatting_gen */Block.__(18, [
                      /* Open_box */Block.__(1, [/* Format */[
                            /* String_literal */Block.__(11, [
                                "<hv 2>",
                                /* End_of_format */0
                              ]),
                            "<hv 2>"
                          ]]),
                      /* String_literal */Block.__(11, [
                          "Values do not match:",
                          /* Formatting_lit */Block.__(17, [
                              /* Break */Block.__(0, [
                                  "@ ",
                                  1,
                                  0
                                ]),
                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@;<1 -2>",
                                          1,
                                          -2
                                        ]),
                                      /* String_literal */Block.__(11, [
                                          "is not included in",
                                          /* Formatting_lit */Block.__(17, [
                                              /* Break */Block.__(0, [
                                                  "@ ",
                                                  1,
                                                  0
                                                ]),
                                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                      /* Close_box */0,
                                                      /* End_of_format */0
                                                    ])])
                                            ])
                                        ])
                                    ])])
                            ])
                        ])
                    ]),
                  "@[<hv 2>Values do not match:@ %a@;<1 -2>is not included in@ %a@]"
                ]), (function (param, param$1) {
                return value_description$1(id, param, param$1);
              }), d1, (function (param, param$1) {
                return value_description$1(id, param, param$1);
              }), d2);
        return show_locs(ppf, /* tuple */[
                    d1.val_loc,
                    d2.val_loc
                  ]);
    case /* Type_declarations */2 :
        var d2$1 = param[2];
        var d1$1 = param[1];
        var id$1 = param[0];
        return Curry.app(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<v>",
                                      /* End_of_format */0
                                    ]),
                                  "<v>"
                                ]]),
                            /* Formatting_gen */Block.__(18, [
                                /* Open_box */Block.__(1, [/* Format */[
                                      /* String_literal */Block.__(11, [
                                          "<hv>",
                                          /* End_of_format */0
                                        ]),
                                      "<hv>"
                                    ]]),
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* Char_literal */Block.__(12, [
                                        /* ":" */58,
                                        /* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@;<1 2>",
                                                1,
                                                2
                                              ]),
                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@ ",
                                                        1,
                                                        0
                                                      ]),
                                                    /* String */Block.__(2, [
                                                        /* No_padding */0,
                                                        /* Formatting_lit */Block.__(17, [
                                                            /* Break */Block.__(0, [
                                                                "@;<1 2>",
                                                                1,
                                                                2
                                                              ]),
                                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                    /* Close_box */0,
                                                                    /* Alpha */Block.__(15, [/* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                /* Close_box */0,
                                                                                /* End_of_format */0
                                                                              ])])])
                                                                  ])])
                                                          ])
                                                      ])
                                                  ])])
                                          ])
                                      ])
                                  ])
                              ])
                          ]),
                        "@[<v>@[<hv>%s:@;<1 2>%a@ %s@;<1 2>%a@]%a%a@]"
                      ]), [
                    "Type declarations do not match",
                    (function (param, param$1) {
                        return type_declaration$1(id$1, param, param$1);
                      }),
                    d1$1,
                    "is not included in",
                    (function (param, param$1) {
                        return type_declaration$1(id$1, param, param$1);
                      }),
                    d2$1,
                    show_locs,
                    /* tuple */[
                      d1$1.type_loc,
                      d2$1.type_loc
                    ],
                    (function (param) {
                        return report_type_mismatch("the first", "the second", "declaration", param);
                      }),
                    param[3]
                  ]);
    case /* Extension_constructors */3 :
        var x2 = param[2];
        var x1 = param[1];
        var id$2 = param[0];
        Curry._4(Format.fprintf(ppf, /* Format */[
                  /* Formatting_gen */Block.__(18, [
                      /* Open_box */Block.__(1, [/* Format */[
                            /* String_literal */Block.__(11, [
                                "<hv 2>",
                                /* End_of_format */0
                              ]),
                            "<hv 2>"
                          ]]),
                      /* String_literal */Block.__(11, [
                          "Extension declarations do not match:",
                          /* Formatting_lit */Block.__(17, [
                              /* Break */Block.__(0, [
                                  "@ ",
                                  1,
                                  0
                                ]),
                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@;<1 -2>",
                                          1,
                                          -2
                                        ]),
                                      /* String_literal */Block.__(11, [
                                          "is not included in",
                                          /* Formatting_lit */Block.__(17, [
                                              /* Break */Block.__(0, [
                                                  "@ ",
                                                  1,
                                                  0
                                                ]),
                                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                      /* Close_box */0,
                                                      /* End_of_format */0
                                                    ])])
                                            ])
                                        ])
                                    ])])
                            ])
                        ])
                    ]),
                  "@[<hv 2>Extension declarations do not match:@ %a@;<1 -2>is not included in@ %a@]"
                ]), (function (param, param$1) {
                return extension_constructor$1(id$2, param, param$1);
              }), x1, (function (param, param$1) {
                return extension_constructor$1(id$2, param, param$1);
              }), x2);
        return show_locs(ppf, /* tuple */[
                    x1.ext_loc,
                    x2.ext_loc
                  ]);
    case /* Module_types */4 :
        return Curry._4(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<hv 2>",
                                      /* End_of_format */0
                                    ]),
                                  "<hv 2>"
                                ]]),
                            /* String_literal */Block.__(11, [
                                "Modules do not match:",
                                /* Formatting_lit */Block.__(17, [
                                    /* Break */Block.__(0, [
                                        "@ ",
                                        1,
                                        0
                                      ]),
                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@;<1 -2>",
                                                1,
                                                -2
                                              ]),
                                            /* String_literal */Block.__(11, [
                                                "is not included in",
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@ ",
                                                        1,
                                                        0
                                                      ]),
                                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                            /* Close_box */0,
                                                            /* End_of_format */0
                                                          ])])
                                                  ])
                                              ])
                                          ])])
                                  ])
                              ])
                          ]),
                        "@[<hv 2>Modules do not match:@ %a@;<1 -2>is not included in@ %a@]"
                      ]), modtype$1, param[0], modtype$1, param[1]);
    case /* Modtype_infos */5 :
        var id$3 = param[0];
        return Curry._4(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<hv 2>",
                                      /* End_of_format */0
                                    ]),
                                  "<hv 2>"
                                ]]),
                            /* String_literal */Block.__(11, [
                                "Module type declarations do not match:",
                                /* Formatting_lit */Block.__(17, [
                                    /* Break */Block.__(0, [
                                        "@ ",
                                        1,
                                        0
                                      ]),
                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@;<1 -2>",
                                                1,
                                                -2
                                              ]),
                                            /* String_literal */Block.__(11, [
                                                "does not match",
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@ ",
                                                        1,
                                                        0
                                                      ]),
                                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                            /* Close_box */0,
                                                            /* End_of_format */0
                                                          ])])
                                                  ])
                                              ])
                                          ])])
                                  ])
                              ])
                          ]),
                        "@[<hv 2>Module type declarations do not match:@ %a@;<1 -2>does not match@ %a@]"
                      ]), (function (param, param$1) {
                      return modtype_declaration$1(id$3, param, param$1);
                    }), param[1], (function (param, param$1) {
                      return modtype_declaration$1(id$3, param, param$1);
                    }), param[2]);
    case /* Interface_mismatch */6 :
        return Curry._2(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* End_of_format */0,
                                  ""
                                ]]),
                            /* String_literal */Block.__(11, [
                                "The implementation ",
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* Formatting_lit */Block.__(17, [
                                        /* Break */Block.__(0, [
                                            "@ ",
                                            1,
                                            0
                                          ]),
                                        /* String_literal */Block.__(11, [
                                            "does not match the interface ",
                                            /* String */Block.__(2, [
                                                /* No_padding */0,
                                                /* Char_literal */Block.__(12, [
                                                    /* ":" */58,
                                                    /* End_of_format */0
                                                  ])
                                              ])
                                          ])
                                      ])
                                  ])
                              ])
                          ]),
                        "@[The implementation %s@ does not match the interface %s:"
                      ]), param[0], param[1]);
    case /* Class_type_declarations */7 :
        var id$4 = param[0];
        return Curry._6(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<hv 2>",
                                      /* End_of_format */0
                                    ]),
                                  "<hv 2>"
                                ]]),
                            /* String_literal */Block.__(11, [
                                "Class type declarations do not match:",
                                /* Formatting_lit */Block.__(17, [
                                    /* Break */Block.__(0, [
                                        "@ ",
                                        1,
                                        0
                                      ]),
                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@;<1 -2>",
                                                1,
                                                -2
                                              ]),
                                            /* String_literal */Block.__(11, [
                                                "does not match",
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@ ",
                                                        1,
                                                        0
                                                      ]),
                                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                            /* Close_box */0,
                                                            /* Formatting_lit */Block.__(17, [
                                                                /* Break */Block.__(0, [
                                                                    "@ ",
                                                                    1,
                                                                    0
                                                                  ]),
                                                                /* Alpha */Block.__(15, [/* End_of_format */0])
                                                              ])
                                                          ])])
                                                  ])
                                              ])
                                          ])])
                                  ])
                              ])
                          ]),
                        "@[<hv 2>Class type declarations do not match:@ %a@;<1 -2>does not match@ %a@]@ %a"
                      ]), (function (param, param$1) {
                      return cltype_declaration$1(id$4, param, param$1);
                    }), param[1], (function (param, param$1) {
                      return cltype_declaration$1(id$4, param, param$1);
                    }), param[2], report_error$3, param[3]);
    case /* Class_declarations */8 :
        var id$5 = param[0];
        return Curry._6(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<hv 2>",
                                      /* End_of_format */0
                                    ]),
                                  "<hv 2>"
                                ]]),
                            /* String_literal */Block.__(11, [
                                "Class declarations do not match:",
                                /* Formatting_lit */Block.__(17, [
                                    /* Break */Block.__(0, [
                                        "@ ",
                                        1,
                                        0
                                      ]),
                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@;<1 -2>",
                                                1,
                                                -2
                                              ]),
                                            /* String_literal */Block.__(11, [
                                                "does not match",
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@ ",
                                                        1,
                                                        0
                                                      ]),
                                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                            /* Close_box */0,
                                                            /* Formatting_lit */Block.__(17, [
                                                                /* Break */Block.__(0, [
                                                                    "@ ",
                                                                    1,
                                                                    0
                                                                  ]),
                                                                /* Alpha */Block.__(15, [/* End_of_format */0])
                                                              ])
                                                          ])])
                                                  ])
                                              ])
                                          ])])
                                  ])
                              ])
                          ]),
                        "@[<hv 2>Class declarations do not match:@ %a@;<1 -2>does not match@ %a@]@ %a"
                      ]), (function (param, param$1) {
                      return class_declaration$1(id$5, param, param$1);
                    }), param[1], (function (param, param$1) {
                      return class_declaration$1(id$5, param, param$1);
                    }), param[2], report_error$3, param[3]);
    case /* Unbound_modtype_path */9 :
        return Curry._2(Format.fprintf(ppf, /* Format */[
                        /* String_literal */Block.__(11, [
                            "Unbound module type ",
                            /* Alpha */Block.__(15, [/* End_of_format */0])
                          ]),
                        "Unbound module type %a"
                      ]), path, param[0]);
    case /* Unbound_module_path */10 :
        return Curry._2(Format.fprintf(ppf, /* Format */[
                        /* String_literal */Block.__(11, [
                            "Unbound module ",
                            /* Alpha */Block.__(15, [/* End_of_format */0])
                          ]),
                        "Unbound module %a"
                      ]), path, param[0]);
    case /* Invalid_module_alias */11 :
        return Curry._2(Format.fprintf(ppf, /* Format */[
                        /* String_literal */Block.__(11, [
                            "Module ",
                            /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                    " cannot be aliased",
                                    /* End_of_format */0
                                  ])])
                          ]),
                        "Module %a cannot be aliased"
                      ]), path, param[0]);
    
  }
}

function context(ppf, param) {
  if (!param) {
    return Format.fprintf(ppf, /* Format */[
                /* String_literal */Block.__(11, [
                    "<here>",
                    /* End_of_format */0
                  ]),
                "<here>"
              ]);
  }
  var match = param[0];
  switch (match.tag | 0) {
    case /* Module */0 :
        return Curry._4(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<2>",
                                      /* End_of_format */0
                                    ]),
                                  "<2>"
                                ]]),
                            /* String_literal */Block.__(11, [
                                "module ",
                                /* Alpha */Block.__(15, [/* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                            /* Close_box */0,
                                            /* End_of_format */0
                                          ])])])
                              ])
                          ]),
                        "@[<2>module %a%a@]"
                      ]), ident$3, match[0], args, param[1]);
    case /* Modtype */1 :
        return Curry._4(Format.fprintf(ppf, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* String_literal */Block.__(11, [
                                      "<2>",
                                      /* End_of_format */0
                                    ]),
                                  "<2>"
                                ]]),
                            /* String_literal */Block.__(11, [
                                "module type ",
                                /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                        " =",
                                        /* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@ ",
                                                1,
                                                0
                                              ]),
                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                    /* Close_box */0,
                                                    /* End_of_format */0
                                                  ])])
                                          ])
                                      ])])
                              ])
                          ]),
                        "@[<2>module type %a =@ %a@]"
                      ]), ident$3, match[0], context_mty, param[1]);
    case /* Arg */2 :
        return Curry._4(Format.fprintf(ppf, /* Format */[
                        /* String_literal */Block.__(11, [
                            "functor (",
                            /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                    " : ",
                                    /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                            ") -> ...",
                                            /* End_of_format */0
                                          ])])
                                  ])])
                          ]),
                        "functor (%a : %a) -> ..."
                      ]), ident$3, match[0], context_mty, param[1]);
    case /* Body */3 :
        return Curry._3(Format.fprintf(ppf, /* Format */[
                        /* String_literal */Block.__(11, [
                            "functor (",
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* String_literal */Block.__(11, [
                                    ") ->",
                                    /* Formatting_lit */Block.__(17, [
                                        /* Break */Block.__(0, [
                                            "@ ",
                                            1,
                                            0
                                          ]),
                                        /* Alpha */Block.__(15, [/* End_of_format */0])
                                      ])
                                  ])
                              ])
                          ]),
                        "functor (%s) ->@ %a"
                      ]), argname(match[0]), context_mty, param[1]);
    
  }
}

function context_mty(ppf, rem) {
  if (!rem) {
    return context(ppf, rem);
  }
  switch (rem[0].tag | 0) {
    case /* Module */0 :
    case /* Modtype */1 :
        break;
    case /* Arg */2 :
    case /* Body */3 :
        return context(ppf, rem);
    
  }
  return Curry._2(Format.fprintf(ppf, /* Format */[
                  /* Formatting_gen */Block.__(18, [
                      /* Open_box */Block.__(1, [/* Format */[
                            /* String_literal */Block.__(11, [
                                "<2>",
                                /* End_of_format */0
                              ]),
                            "<2>"
                          ]]),
                      /* String_literal */Block.__(11, [
                          "sig",
                          /* Formatting_lit */Block.__(17, [
                              /* Break */Block.__(0, [
                                  "@ ",
                                  1,
                                  0
                                ]),
                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@;<1 -2>",
                                          1,
                                          -2
                                        ]),
                                      /* String_literal */Block.__(11, [
                                          "end",
                                          /* Formatting_lit */Block.__(17, [
                                              /* Close_box */0,
                                              /* End_of_format */0
                                            ])
                                        ])
                                    ])])
                            ])
                        ])
                    ]),
                  "@[<2>sig@ %a@;<1 -2>end@]"
                ]), context, rem);
}

function args(ppf, cxt) {
  if (cxt) {
    var match = cxt[0];
    switch (match.tag | 0) {
      case /* Module */0 :
      case /* Modtype */1 :
          break;
      case /* Arg */2 :
          return Curry._4(Format.fprintf(ppf, /* Format */[
                          /* Char_literal */Block.__(12, [
                              /* "(" */40,
                              /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                      " :",
                                      /* Formatting_lit */Block.__(17, [
                                          /* Break */Block.__(0, [
                                              "@ ",
                                              1,
                                              0
                                            ]),
                                          /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                                  ") : ...",
                                                  /* End_of_format */0
                                                ])])
                                        ])
                                    ])])
                            ]),
                          "(%a :@ %a) : ..."
                        ]), ident$3, match[0], context_mty, cxt[1]);
      case /* Body */3 :
          return Curry._3(Format.fprintf(ppf, /* Format */[
                          /* Char_literal */Block.__(12, [
                              /* "(" */40,
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* Char_literal */Block.__(12, [
                                      /* ")" */41,
                                      /* Alpha */Block.__(15, [/* End_of_format */0])
                                    ])
                                ])
                            ]),
                          "(%s)%a"
                        ]), argname(match[0]), args, cxt[1]);
      
    }
  }
  return Curry._2(Format.fprintf(ppf, /* Format */[
                  /* String_literal */Block.__(11, [
                      " :",
                      /* Formatting_lit */Block.__(17, [
                          /* Break */Block.__(0, [
                              "@ ",
                              1,
                              0
                            ]),
                          /* Alpha */Block.__(15, [/* End_of_format */0])
                        ])
                    ]),
                  " :@ %a"
                ]), context_mty, cxt);
}

function argname(x) {
  var s = x.name;
  if (s === "*") {
    return "";
  } else {
    return s;
  }
}

function path_of_context(param) {
  if (!param) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "includemod.ml",
            573,
            9
          ]
        ];
  }
  var match = param[0];
  if (match.tag) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "includemod.ml",
            573,
            9
          ]
        ];
  }
  var _path = /* Pident */Block.__(0, [match[0]]);
  var _param = param[1];
  while(true) {
    var param$1 = _param;
    var path = _path;
    if (!param$1) {
      return path;
    }
    var match$1 = param$1[0];
    if (match$1.tag) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "includemod.ml",
              571,
              15
            ]
          ];
    }
    _param = param$1[1];
    _path = /* Pdot */Block.__(1, [
        path,
        match$1[0].name,
        -1
      ]);
    continue ;
  };
}

function context$1(ppf, cxt) {
  if (cxt === /* [] */0) {
    return ;
  } else if (List.for_all((function (param) {
            return param.tag ? false : true;
          }), cxt)) {
    return Curry._2(Format.fprintf(ppf, /* Format */[
                    /* String_literal */Block.__(11, [
                        "In module ",
                        /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                /* ":" */58,
                                /* Formatting_lit */Block.__(17, [
                                    /* Break */Block.__(0, [
                                        "@ ",
                                        1,
                                        0
                                      ]),
                                    /* End_of_format */0
                                  ])
                              ])])
                      ]),
                    "In module %a:@ "
                  ]), path, path_of_context(cxt));
  } else {
    return Curry._2(Format.fprintf(ppf, /* Format */[
                    /* Formatting_gen */Block.__(18, [
                        /* Open_box */Block.__(1, [/* Format */[
                              /* String_literal */Block.__(11, [
                                  "<hv 2>",
                                  /* End_of_format */0
                                ]),
                              "<hv 2>"
                            ]]),
                        /* String_literal */Block.__(11, [
                            "At position",
                            /* Formatting_lit */Block.__(17, [
                                /* Break */Block.__(0, [
                                    "@ ",
                                    1,
                                    0
                                  ]),
                                /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                        /* Close_box */0,
                                        /* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@ ",
                                                1,
                                                0
                                              ]),
                                            /* End_of_format */0
                                          ])
                                      ])])
                              ])
                          ])
                      ]),
                    "@[<hv 2>At position@ %a@]@ "
                  ]), context, cxt);
  }
}

function include_err$2(ppf, param) {
  var err = param[2];
  var cxt = param[0];
  return wrap_printing_env(param[1], (function (param) {
                return Curry._4(Format.fprintf(ppf, /* Format */[
                                /* Formatting_gen */Block.__(18, [
                                    /* Open_box */Block.__(1, [/* Format */[
                                          /* String_literal */Block.__(11, [
                                              "<v>",
                                              /* End_of_format */0
                                            ]),
                                          "<v>"
                                        ]]),
                                    /* Alpha */Block.__(15, [/* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                /* Close_box */0,
                                                /* End_of_format */0
                                              ])])])
                                  ]),
                                "@[<v>%a%a@]"
                              ]), context$1, List.rev(cxt), include_err$1, err);
              }));
}

var buffer = {
  contents: Bytes.empty
};

function is_big(obj) {
  var size = error_size.contents;
  if (size <= 0) {
    return false;
  }
  if (buffer.contents.length < size) {
    buffer.contents = Caml_bytes.caml_create_bytes(size);
  }
  try {
    Marshal.to_buffer(buffer.contents, 0, size, obj, /* [] */0);
    return false;
  }
  catch (exn){
    return true;
  }
}

function report_error$4(ppf, errs) {
  if (errs === /* [] */0) {
    return ;
  }
  var match = split_last(errs);
  var pe = {
    contents: true
  };
  var print_errs = function (ppf) {
    return (function (param) {
        return List.iter((function (param) {
                      if (is_big(param[2])) {
                        if (pe.contents) {
                          Format.fprintf(ppf, /* Format */[
                                /* String_literal */Block.__(11, [
                                    "...",
                                    /* Formatting_lit */Block.__(17, [
                                        /* Break */Block.__(0, [
                                            "@ ",
                                            1,
                                            0
                                          ]),
                                        /* End_of_format */0
                                      ])
                                  ]),
                                "...@ "
                              ]);
                          pe.contents = false;
                          return ;
                        } else {
                          return ;
                        }
                      } else {
                        return Curry._2(Format.fprintf(ppf, /* Format */[
                                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                /* Break */Block.__(0, [
                                                    "@ ",
                                                    1,
                                                    0
                                                  ]),
                                                /* End_of_format */0
                                              ])]),
                                        "%a@ "
                                      ]), include_err$2, param);
                      }
                    }), param);
      });
  };
  return Curry._4(Format.fprintf(ppf, /* Format */[
                  /* Formatting_gen */Block.__(18, [
                      /* Open_box */Block.__(1, [/* Format */[
                            /* String_literal */Block.__(11, [
                                "<v>",
                                /* End_of_format */0
                              ]),
                            "<v>"
                          ]]),
                      /* Alpha */Block.__(15, [/* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                  /* Close_box */0,
                                  /* End_of_format */0
                                ])])])
                    ]),
                  "@[<v>%a%a@]"
                ]), print_errs, match[0], include_err$2, match[1]);
}

register_error_of_exn((function (param) {
        if (param[0] === $$Error$5) {
          return error_of_printer_file(report_error$4, param[1]);
        }
        
      }));

function get_location(ti) {
  switch (ti.tag | 0) {
    case /* Ti_pat */0 :
        return ti[0].pat_loc;
    case /* Ti_expr */1 :
        return ti[0].exp_loc;
    case /* Ti_class */2 :
        return ti[0].cl_loc;
    case /* Ti_mod */3 :
        return ti[0].mod_loc;
    case /* An_call */4 :
    case /* An_ident */5 :
        return ti[0];
    
  }
}

var annotations$1 = {
  contents: /* [] */0
};

var phrases = {
  contents: /* [] */0
};

function record$2(ti) {
  if (annotations.contents && !get_location(ti).loc_ghost) {
    annotations$1.contents = /* :: */[
      ti,
      annotations$1.contents
    ];
    return ;
  }
  
}

function make_pat(desc, ty, tenv) {
  return {
          pat_desc: desc,
          pat_loc: none,
          pat_extra: /* [] */0,
          pat_type: ty,
          pat_env: tenv,
          pat_attributes: /* [] */0
        };
}

var omega = make_pat(/* Tpat_any */0, none$2, empty);

var extra_pat = make_pat(/* Tpat_var */Block.__(0, [
        create("+"),
        {
          txt: "+",
          loc: none
        }
      ]), none$2, empty);

function omegas(i) {
  if (i <= 0) {
    return /* [] */0;
  } else {
    return /* :: */[
            omega,
            omegas(i - 1 | 0)
          ];
  }
}

var zero = make_pat(/* Tpat_constant */Block.__(2, [/* Const_int */Block.__(0, [0])]), none$2, empty);

function is_absent(tag, row) {
  return row_field(tag, row.contents) === /* Rabsent */0;
}

function is_absent_pat(p) {
  var match = p.pat_desc;
  if (typeof match === "number" || match.tag !== /* Tpat_variant */5) {
    return false;
  } else {
    return is_absent(match[0], match[2]);
  }
}

function const_compare(x, y) {
  switch (x.tag | 0) {
    case /* Const_string */2 :
        if (y.tag === /* Const_string */2) {
          return Caml_primitive.caml_string_compare(x[0], y[0]);
        } else {
          return Caml_obj.caml_compare(x, y);
        }
    case /* Const_float */3 :
        if (y.tag === /* Const_float */3) {
          return Caml_primitive.caml_float_compare(Caml_format.caml_float_of_string(x[0]), Caml_format.caml_float_of_string(y[0]));
        } else {
          return Caml_obj.caml_compare(x, y);
        }
    default:
      return Caml_obj.caml_compare(x, y);
  }
}

function records_args(l1, l2) {
  var _r1 = /* [] */0;
  var _r2 = /* [] */0;
  var _l1 = l1;
  var _l2 = l2;
  while(true) {
    var l2$1 = _l2;
    var l1$1 = _l1;
    var r2 = _r2;
    var r1 = _r1;
    if (l1$1) {
      var rem1 = l1$1[1];
      var match = l1$1[0];
      var p1 = match[2];
      var lbl1 = match[1];
      if (l2$1) {
        var rem2 = l2$1[1];
        var match$1 = l2$1[0];
        var p2 = match$1[2];
        var lbl2 = match$1[1];
        if (lbl1.lbl_pos < lbl2.lbl_pos) {
          _l1 = rem1;
          _r2 = /* :: */[
            omega,
            r2
          ];
          _r1 = /* :: */[
            p1,
            r1
          ];
          continue ;
        } else if (lbl1.lbl_pos > lbl2.lbl_pos) {
          _l2 = rem2;
          _r2 = /* :: */[
            p2,
            r2
          ];
          _r1 = /* :: */[
            omega,
            r1
          ];
          continue ;
        } else {
          _l2 = rem2;
          _l1 = rem1;
          _r2 = /* :: */[
            p2,
            r2
          ];
          _r1 = /* :: */[
            p1,
            r1
          ];
          continue ;
        }
      } else {
        _l2 = /* [] */0;
        _l1 = rem1;
        _r2 = /* :: */[
          omega,
          r2
        ];
        _r1 = /* :: */[
          p1,
          r1
        ];
        continue ;
      }
    } else {
      if (!l2$1) {
        return /* tuple */[
                List.rev(r1),
                List.rev(r2)
              ];
      }
      _l2 = l2$1[1];
      _l1 = /* [] */0;
      _r2 = /* :: */[
        l2$1[0][2],
        r2
      ];
      _r1 = /* :: */[
        omega,
        r1
      ];
      continue ;
    }
  };
}

function compat(_p, _q) {
  while(true) {
    var q = _q;
    var p = _p;
    var match = p.pat_desc;
    var match$1 = q.pat_desc;
    var exit = 0;
    if (typeof match === "number") {
      exit = 1;
    } else {
      switch (match.tag | 0) {
        case /* Tpat_alias */1 :
            _p = match[0];
            continue ;
        case /* Tpat_constant */2 :
            if (typeof match$1 === "number") {
              exit = 1;
            } else {
              switch (match$1.tag | 0) {
                case /* Tpat_var */0 :
                case /* Tpat_alias */1 :
                    exit = 1;
                    break;
                case /* Tpat_constant */2 :
                    return const_compare(match[0], match$1[0]) === 0;
                case /* Tpat_or */8 :
                    exit = 2;
                    break;
                default:
                  exit = 3;
              }
            }
            break;
        case /* Tpat_tuple */3 :
            if (typeof match$1 === "number") {
              exit = 1;
            } else {
              switch (match$1.tag | 0) {
                case /* Tpat_var */0 :
                case /* Tpat_alias */1 :
                    exit = 1;
                    break;
                case /* Tpat_tuple */3 :
                    return compats(match[0], match$1[0]);
                case /* Tpat_or */8 :
                    exit = 2;
                    break;
                default:
                  exit = 3;
              }
            }
            break;
        case /* Tpat_construct */4 :
            if (typeof match$1 === "number") {
              exit = 1;
            } else {
              switch (match$1.tag | 0) {
                case /* Tpat_var */0 :
                case /* Tpat_alias */1 :
                    exit = 1;
                    break;
                case /* Tpat_construct */4 :
                    if (equal_tag(match[1].cstr_tag, match$1[1].cstr_tag)) {
                      return compats(match[2], match$1[2]);
                    } else {
                      return false;
                    }
                case /* Tpat_or */8 :
                    exit = 2;
                    break;
                default:
                  exit = 3;
              }
            }
            break;
        case /* Tpat_variant */5 :
            var match$2 = match[1];
            var l1 = match[0];
            if (match$2 !== void 0) {
              if (typeof match$1 === "number") {
                exit = 1;
              } else {
                switch (match$1.tag | 0) {
                  case /* Tpat_var */0 :
                  case /* Tpat_alias */1 :
                      exit = 1;
                      break;
                  case /* Tpat_variant */5 :
                      var match$3 = match$1[1];
                      if (match$3 === void 0) {
                        return false;
                      }
                      if (l1 !== match$1[0]) {
                        return false;
                      }
                      _q = match$3;
                      _p = match$2;
                      continue ;
                  case /* Tpat_or */8 :
                      exit = 2;
                      break;
                  default:
                    exit = 3;
                }
              }
            } else if (typeof match$1 === "number") {
              exit = 1;
            } else {
              switch (match$1.tag | 0) {
                case /* Tpat_var */0 :
                case /* Tpat_alias */1 :
                    exit = 1;
                    break;
                case /* Tpat_variant */5 :
                    if (match$1[1] !== void 0) {
                      return false;
                    } else {
                      return l1 === match$1[0];
                    }
                case /* Tpat_or */8 :
                    exit = 2;
                    break;
                default:
                  exit = 3;
              }
            }
            break;
        case /* Tpat_record */6 :
            if (typeof match$1 === "number") {
              exit = 1;
            } else {
              switch (match$1.tag | 0) {
                case /* Tpat_var */0 :
                case /* Tpat_alias */1 :
                    exit = 1;
                    break;
                case /* Tpat_record */6 :
                    var match$4 = records_args(match[0], match$1[0]);
                    return compats(match$4[0], match$4[1]);
                case /* Tpat_or */8 :
                    exit = 2;
                    break;
                default:
                  exit = 3;
              }
            }
            break;
        case /* Tpat_array */7 :
            var ps = match[0];
            if (typeof match$1 === "number") {
              exit = 1;
            } else {
              switch (match$1.tag | 0) {
                case /* Tpat_var */0 :
                case /* Tpat_alias */1 :
                    exit = 1;
                    break;
                case /* Tpat_array */7 :
                    var qs = match$1[0];
                    if (List.length(ps) === List.length(qs)) {
                      return compats(ps, qs);
                    } else {
                      return false;
                    }
                case /* Tpat_or */8 :
                    exit = 2;
                    break;
                default:
                  exit = 3;
              }
            }
            break;
        case /* Tpat_lazy */9 :
            if (typeof match$1 === "number") {
              exit = 1;
            } else {
              switch (match$1.tag | 0) {
                case /* Tpat_var */0 :
                case /* Tpat_alias */1 :
                    exit = 1;
                    break;
                case /* Tpat_or */8 :
                    exit = 2;
                    break;
                case /* Tpat_lazy */9 :
                    _q = match$1[0];
                    _p = match[0];
                    continue ;
                default:
                  exit = 3;
              }
            }
            break;
        default:
          exit = 1;
      }
    }
    switch (exit) {
      case 1 :
          if (typeof match$1 === "number") {
            return true;
          }
          switch (match$1.tag | 0) {
            case /* Tpat_var */0 :
                return true;
            case /* Tpat_alias */1 :
                _q = match$1[0];
                continue ;
            default:
              if (typeof match === "number") {
                return true;
              }
              if (!match.tag) {
                return true;
              }
              if (compat(match[0], q)) {
                return true;
              }
              _p = match[1];
              continue ;
          }
      case 2 :
          if (compat(p, match$1[0])) {
            return true;
          }
          _q = match$1[1];
          continue ;
      case 3 :
          throw [
                Caml_builtin_exceptions.assert_failure,
                /* tuple */[
                  "parmatch.ml",
                  106,
                  6
                ]
              ];
      
    }
  };
}

function compats(_ps, _qs) {
  while(true) {
    var qs = _qs;
    var ps = _ps;
    if (ps) {
      if (!qs) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "parmatch.ml",
                111,
                12
              ]
            ];
      }
      if (!compat(ps[0], qs[0])) {
        return false;
      }
      _qs = qs[1];
      _ps = ps[1];
      continue ;
    } else {
      if (qs) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "parmatch.ml",
                111,
                12
              ]
            ];
      }
      return true;
    }
  };
}

var Empty = Caml_exceptions.create("Ocaml_typedtree_test.Parmatch.Empty");

function clean_copy(ty) {
  if (ty.level === 100000000) {
    return ty;
  } else {
    return type_expr(identity, ty);
  }
}

function get_type_path(ty, tenv) {
  var ty$1 = repr(expand_head(tenv, clean_copy(ty)));
  var match = ty$1.desc;
  if (typeof match === "number" || match.tag !== /* Tconstr */3) {
    return fatal_error("Parmatch.get_type_path");
  } else {
    return match[0];
  }
}

function is_cons(param) {
  if (param.cstr_name === "::") {
    return true;
  } else {
    return false;
  }
}

function pretty_const(c) {
  switch (c.tag | 0) {
    case /* Const_int */0 :
        return Curry._1(Printf.sprintf(/* Format */[
                        /* Int */Block.__(4, [
                            /* Int_d */0,
                            /* No_padding */0,
                            /* No_precision */0,
                            /* End_of_format */0
                          ]),
                        "%d"
                      ]), c[0]);
    case /* Const_char */1 :
        return Curry._1(Printf.sprintf(/* Format */[
                        /* Caml_char */Block.__(1, [/* End_of_format */0]),
                        "%C"
                      ]), c[0]);
    case /* Const_string */2 :
        return Curry._1(Printf.sprintf(/* Format */[
                        /* Caml_string */Block.__(3, [
                            /* No_padding */0,
                            /* End_of_format */0
                          ]),
                        "%S"
                      ]), c[0]);
    case /* Const_float */3 :
        return Curry._1(Printf.sprintf(/* Format */[
                        /* String */Block.__(2, [
                            /* No_padding */0,
                            /* End_of_format */0
                          ]),
                        "%s"
                      ]), c[0]);
    case /* Const_int32 */4 :
        return Curry._1(Printf.sprintf(/* Format */[
                        /* Int32 */Block.__(5, [
                            /* Int_d */0,
                            /* No_padding */0,
                            /* No_precision */0,
                            /* Char_literal */Block.__(12, [
                                /* "l" */108,
                                /* End_of_format */0
                              ])
                          ]),
                        "%ldl"
                      ]), c[0]);
    case /* Const_int64 */5 :
        return Curry._1(Printf.sprintf(/* Format */[
                        /* Int64 */Block.__(7, [
                            /* Int_d */0,
                            /* No_padding */0,
                            /* No_precision */0,
                            /* Char_literal */Block.__(12, [
                                /* "L" */76,
                                /* End_of_format */0
                              ])
                          ]),
                        "%LdL"
                      ]), c[0]);
    case /* Const_nativeint */6 :
        return Curry._1(Printf.sprintf(/* Format */[
                        /* Nativeint */Block.__(6, [
                            /* Int_d */0,
                            /* No_padding */0,
                            /* No_precision */0,
                            /* Char_literal */Block.__(12, [
                                /* "n" */110,
                                /* End_of_format */0
                              ])
                          ]),
                        "%ndn"
                      ]), c[0]);
    
  }
}

function pretty_val(ppf, v) {
  var match = v.pat_extra;
  if (match) {
    var rem = match[1];
    var tmp = match[0][0];
    if (typeof tmp === "number") {
      return Curry._2(Format.fprintf(ppf, /* Format */[
                      /* Formatting_gen */Block.__(18, [
                          /* Open_box */Block.__(1, [/* Format */[
                                /* End_of_format */0,
                                ""
                              ]]),
                          /* String_literal */Block.__(11, [
                              "(module ",
                              /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                      /* ")" */41,
                                      /* Formatting_lit */Block.__(17, [
                                          /* Close_box */0,
                                          /* End_of_format */0
                                        ])
                                    ])])
                            ])
                        ]),
                      "@[(module %a)@]"
                    ]), pretty_val, {
                  pat_desc: v.pat_desc,
                  pat_loc: v.pat_loc,
                  pat_extra: rem,
                  pat_type: v.pat_type,
                  pat_env: v.pat_env,
                  pat_attributes: v.pat_attributes
                });
    } else if (tmp.tag) {
      return Curry._2(Format.fprintf(ppf, /* Format */[
                      /* Formatting_gen */Block.__(18, [
                          /* Open_box */Block.__(1, [/* Format */[
                                /* End_of_format */0,
                                ""
                              ]]),
                          /* String_literal */Block.__(11, [
                              "(# ",
                              /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                      /* ")" */41,
                                      /* Formatting_lit */Block.__(17, [
                                          /* Close_box */0,
                                          /* End_of_format */0
                                        ])
                                    ])])
                            ])
                        ]),
                      "@[(# %a)@]"
                    ]), pretty_val, {
                  pat_desc: v.pat_desc,
                  pat_loc: v.pat_loc,
                  pat_extra: rem,
                  pat_type: v.pat_type,
                  pat_env: v.pat_env,
                  pat_attributes: v.pat_attributes
                });
    } else {
      return Curry._2(Format.fprintf(ppf, /* Format */[
                      /* Formatting_gen */Block.__(18, [
                          /* Open_box */Block.__(1, [/* Format */[
                                /* End_of_format */0,
                                ""
                              ]]),
                          /* Char_literal */Block.__(12, [
                              /* "(" */40,
                              /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                      " : _)",
                                      /* Formatting_lit */Block.__(17, [
                                          /* Close_box */0,
                                          /* End_of_format */0
                                        ])
                                    ])])
                            ])
                        ]),
                      "@[(%a : _)@]"
                    ]), pretty_val, {
                  pat_desc: v.pat_desc,
                  pat_loc: v.pat_loc,
                  pat_extra: rem,
                  pat_type: v.pat_type,
                  pat_env: v.pat_env,
                  pat_attributes: v.pat_attributes
                });
    }
  } else {
    var match$1 = v.pat_desc;
    if (typeof match$1 === "number") {
      return Format.fprintf(ppf, /* Format */[
                  /* Char_literal */Block.__(12, [
                      /* "_" */95,
                      /* End_of_format */0
                    ]),
                  "_"
                ]);
    }
    switch (match$1.tag | 0) {
      case /* Tpat_var */0 :
          return print$2(ppf, match$1[0]);
      case /* Tpat_alias */1 :
          return Curry._4(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* End_of_format */0,
                                    ""
                                  ]]),
                              /* Char_literal */Block.__(12, [
                                  /* "(" */40,
                                  /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                          /* Break */Block.__(0, [
                                              "@ ",
                                              1,
                                              0
                                            ]),
                                          /* String_literal */Block.__(11, [
                                              "as ",
                                              /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                      /* ")" */41,
                                                      /* Formatting_lit */Block.__(17, [
                                                          /* Close_box */0,
                                                          /* End_of_format */0
                                                        ])
                                                    ])])
                                            ])
                                        ])])
                                ])
                            ]),
                          "@[(%a@ as %a)@]"
                        ]), pretty_val, match$1[0], print$2, match$1[1]);
      case /* Tpat_constant */2 :
          return Curry._1(Format.fprintf(ppf, /* Format */[
                          /* String */Block.__(2, [
                              /* No_padding */0,
                              /* End_of_format */0
                            ]),
                          "%s"
                        ]), pretty_const(match$1[0]));
      case /* Tpat_tuple */3 :
          return Curry._2(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* End_of_format */0,
                                    ""
                                  ]]),
                              /* Char_literal */Block.__(12, [
                                  /* "(" */40,
                                  /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                          /* ")" */41,
                                          /* Formatting_lit */Block.__(17, [
                                              /* Close_box */0,
                                              /* End_of_format */0
                                            ])
                                        ])])
                                ])
                            ]),
                          "@[(%a)@]"
                        ]), (function (param, param$1) {
                        return pretty_vals(",", param, param$1);
                      }), match$1[0]);
      case /* Tpat_construct */4 :
          var vs = match$1[2];
          var cstr = match$1[1];
          if (!vs) {
            return Curry._1(Format.fprintf(ppf, /* Format */[
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* End_of_format */0
                              ]),
                            "%s"
                          ]), cstr.cstr_name);
          }
          if (!vs[1]) {
            return Curry._3(Format.fprintf(ppf, /* Format */[
                            /* Formatting_gen */Block.__(18, [
                                /* Open_box */Block.__(1, [/* Format */[
                                      /* String_literal */Block.__(11, [
                                          "<2>",
                                          /* End_of_format */0
                                        ]),
                                      "<2>"
                                    ]]),
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* Formatting_lit */Block.__(17, [
                                        /* Break */Block.__(0, [
                                            "@ ",
                                            1,
                                            0
                                          ]),
                                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                /* Close_box */0,
                                                /* End_of_format */0
                                              ])])
                                      ])
                                  ])
                              ]),
                            "@[<2>%s@ %a@]"
                          ]), cstr.cstr_name, pretty_arg, vs[0]);
          }
          var name = cstr.cstr_name;
          if (name === "::" && vs) {
            var match$2 = vs[1];
            if (match$2 && !match$2[1]) {
              return Curry._4(Format.fprintf(ppf, /* Format */[
                              /* Formatting_gen */Block.__(18, [
                                  /* Open_box */Block.__(1, [/* Format */[
                                        /* End_of_format */0,
                                        ""
                                      ]]),
                                  /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                          "::",
                                          /* Formatting_lit */Block.__(17, [
                                              /* Break */Block.__(0, [
                                                  "@,",
                                                  0,
                                                  0
                                                ]),
                                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                      /* Close_box */0,
                                                      /* End_of_format */0
                                                    ])])
                                            ])
                                        ])])
                                ]),
                              "@[%a::@,%a@]"
                            ]), pretty_car, vs[0], pretty_cdr, match$2[0]);
            }
            
          }
          return Curry._3(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<2>",
                                        /* End_of_format */0
                                      ]),
                                    "<2>"
                                  ]]),
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@ ",
                                          1,
                                          0
                                        ]),
                                      /* Formatting_gen */Block.__(18, [
                                          /* Open_box */Block.__(1, [/* Format */[
                                                /* End_of_format */0,
                                                ""
                                              ]]),
                                          /* Char_literal */Block.__(12, [
                                              /* "(" */40,
                                              /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                      /* ")" */41,
                                                      /* Formatting_lit */Block.__(17, [
                                                          /* Close_box */0,
                                                          /* Formatting_lit */Block.__(17, [
                                                              /* Close_box */0,
                                                              /* End_of_format */0
                                                            ])
                                                        ])
                                                    ])])
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "@[<2>%s@ @[(%a)@]@]"
                        ]), name, (function (param, param$1) {
                        return pretty_vals(",", param, param$1);
                      }), vs);
          break;
      case /* Tpat_variant */5 :
          var match$3 = match$1[1];
          var l = match$1[0];
          if (match$3 !== void 0) {
            return Curry._3(Format.fprintf(ppf, /* Format */[
                            /* Formatting_gen */Block.__(18, [
                                /* Open_box */Block.__(1, [/* Format */[
                                      /* String_literal */Block.__(11, [
                                          "<2>",
                                          /* End_of_format */0
                                        ]),
                                      "<2>"
                                    ]]),
                                /* Char_literal */Block.__(12, [
                                    /* "`" */96,
                                    /* String */Block.__(2, [
                                        /* No_padding */0,
                                        /* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@ ",
                                                1,
                                                0
                                              ]),
                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                    /* Close_box */0,
                                                    /* End_of_format */0
                                                  ])])
                                          ])
                                      ])
                                  ])
                              ]),
                            "@[<2>`%s@ %a@]"
                          ]), l, pretty_arg, match$3);
          } else {
            return Curry._1(Format.fprintf(ppf, /* Format */[
                            /* Char_literal */Block.__(12, [
                                /* "`" */96,
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* End_of_format */0
                                  ])
                              ]),
                            "`%s"
                          ]), l);
          }
      case /* Tpat_record */6 :
          return Curry._2(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* End_of_format */0,
                                    ""
                                  ]]),
                              /* Char_literal */Block.__(12, [
                                  /* "{" */123,
                                  /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                          /* "}" */125,
                                          /* Formatting_lit */Block.__(17, [
                                              /* Close_box */0,
                                              /* End_of_format */0
                                            ])
                                        ])])
                                ])
                            ]),
                          "@[{%a}@]"
                        ]), pretty_lvals, List.filter((function (param) {
                              if (typeof param[2].pat_desc === "number") {
                                return false;
                              } else {
                                return true;
                              }
                            }))(match$1[0]));
      case /* Tpat_array */7 :
          return Curry._2(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* End_of_format */0,
                                    ""
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "[| ",
                                  /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                          " |]",
                                          /* Formatting_lit */Block.__(17, [
                                              /* Close_box */0,
                                              /* End_of_format */0
                                            ])
                                        ])])
                                ])
                            ]),
                          "@[[| %a |]@]"
                        ]), (function (param, param$1) {
                        return pretty_vals(" ;", param, param$1);
                      }), match$1[0]);
      case /* Tpat_or */8 :
          return Curry._4(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* End_of_format */0,
                                    ""
                                  ]]),
                              /* Char_literal */Block.__(12, [
                                  /* "(" */40,
                                  /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                          /* "|" */124,
                                          /* Formatting_lit */Block.__(17, [
                                              /* Break */Block.__(0, [
                                                  "@,",
                                                  0,
                                                  0
                                                ]),
                                              /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                      /* ")" */41,
                                                      /* Formatting_lit */Block.__(17, [
                                                          /* Close_box */0,
                                                          /* End_of_format */0
                                                        ])
                                                    ])])
                                            ])
                                        ])])
                                ])
                            ]),
                          "@[(%a|@,%a)@]"
                        ]), pretty_or, match$1[0], pretty_or, match$1[1]);
      case /* Tpat_lazy */9 :
          return Curry._2(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<2>",
                                        /* End_of_format */0
                                      ]),
                                    "<2>"
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "lazy",
                                  /* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@ ",
                                          1,
                                          0
                                        ]),
                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                              /* Close_box */0,
                                              /* End_of_format */0
                                            ])])
                                    ])
                                ])
                            ]),
                          "@[<2>lazy@ %a@]"
                        ]), pretty_arg, match$1[0]);
      
    }
  }
}

function pretty_car(ppf, v) {
  var match = v.pat_desc;
  if (typeof match === "number") {
    return pretty_val(ppf, v);
  }
  if (match.tag !== /* Tpat_construct */4) {
    return pretty_val(ppf, v);
  }
  var match$1 = match[2];
  if (!match$1) {
    return pretty_val(ppf, v);
  }
  var match$2 = match$1[1];
  if (match$2 && !(match$2[1] || !is_cons(match[1]))) {
    return Curry._2(Format.fprintf(ppf, /* Format */[
                    /* Char_literal */Block.__(12, [
                        /* "(" */40,
                        /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                /* ")" */41,
                                /* End_of_format */0
                              ])])
                      ]),
                    "(%a)"
                  ]), pretty_val, v);
  } else {
    return pretty_val(ppf, v);
  }
}

function pretty_cdr(ppf, v) {
  var match = v.pat_desc;
  if (typeof match === "number") {
    return pretty_val(ppf, v);
  }
  if (match.tag !== /* Tpat_construct */4) {
    return pretty_val(ppf, v);
  }
  var match$1 = match[2];
  if (!match$1) {
    return pretty_val(ppf, v);
  }
  var match$2 = match$1[1];
  if (match$2 && !(match$2[1] || !is_cons(match[1]))) {
    return Curry._4(Format.fprintf(ppf, /* Format */[
                    /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                            "::",
                            /* Formatting_lit */Block.__(17, [
                                /* Break */Block.__(0, [
                                    "@,",
                                    0,
                                    0
                                  ]),
                                /* Alpha */Block.__(15, [/* End_of_format */0])
                              ])
                          ])]),
                    "%a::@,%a"
                  ]), pretty_car, match$1[0], pretty_cdr, match$2[0]);
  } else {
    return pretty_val(ppf, v);
  }
}

function pretty_arg(ppf, v) {
  var match = v.pat_desc;
  if (typeof match === "number") {
    return pretty_val(ppf, v);
  }
  switch (match.tag | 0) {
    case /* Tpat_construct */4 :
        if (!match[2]) {
          return pretty_val(ppf, v);
        }
        break;
    case /* Tpat_variant */5 :
        if (match[1] === void 0) {
          return pretty_val(ppf, v);
        }
        break;
    default:
      return pretty_val(ppf, v);
  }
  return Curry._2(Format.fprintf(ppf, /* Format */[
                  /* Char_literal */Block.__(12, [
                      /* "(" */40,
                      /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                              /* ")" */41,
                              /* End_of_format */0
                            ])])
                    ]),
                  "(%a)"
                ]), pretty_val, v);
}

function pretty_or(ppf, v) {
  var match = v.pat_desc;
  if (typeof match === "number" || match.tag !== /* Tpat_or */8) {
    return pretty_val(ppf, v);
  } else {
    return Curry._4(Format.fprintf(ppf, /* Format */[
                    /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                            /* "|" */124,
                            /* Formatting_lit */Block.__(17, [
                                /* Break */Block.__(0, [
                                    "@,",
                                    0,
                                    0
                                  ]),
                                /* Alpha */Block.__(15, [/* End_of_format */0])
                              ])
                          ])]),
                    "%a|@,%a"
                  ]), pretty_or, match[0], pretty_or, match[1]);
  }
}

function pretty_vals(sep, ppf, param) {
  if (!param) {
    return ;
  }
  var vs = param[1];
  var v = param[0];
  if (vs) {
    return Curry._5(Format.fprintf(ppf, /* Format */[
                    /* Alpha */Block.__(15, [/* String */Block.__(2, [
                            /* No_padding */0,
                            /* Formatting_lit */Block.__(17, [
                                /* Break */Block.__(0, [
                                    "@ ",
                                    1,
                                    0
                                  ]),
                                /* Alpha */Block.__(15, [/* End_of_format */0])
                              ])
                          ])]),
                    "%a%s@ %a"
                  ]), pretty_val, v, sep, (function (param, param$1) {
                  return pretty_vals(sep, param, param$1);
                }), vs);
  } else {
    return pretty_val(ppf, v);
  }
}

function pretty_lvals(ppf, param) {
  if (!param) {
    return ;
  }
  var rest = param[1];
  var match = param[0];
  var v = match[2];
  var lbl = match[1];
  if (rest) {
    return Curry._5(Format.fprintf(ppf, /* Format */[
                    /* String */Block.__(2, [
                        /* No_padding */0,
                        /* Char_literal */Block.__(12, [
                            /* "=" */61,
                            /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                    /* ";" */59,
                                    /* Formatting_lit */Block.__(17, [
                                        /* Break */Block.__(0, [
                                            "@ ",
                                            1,
                                            0
                                          ]),
                                        /* Alpha */Block.__(15, [/* End_of_format */0])
                                      ])
                                  ])])
                          ])
                      ]),
                    "%s=%a;@ %a"
                  ]), lbl.lbl_name, pretty_val, v, pretty_lvals, rest);
  } else {
    return Curry._3(Format.fprintf(ppf, /* Format */[
                    /* String */Block.__(2, [
                        /* No_padding */0,
                        /* Char_literal */Block.__(12, [
                            /* "=" */61,
                            /* Alpha */Block.__(15, [/* End_of_format */0])
                          ])
                      ]),
                    "%s=%a"
                  ]), lbl.lbl_name, pretty_val, v);
  }
}

function top_pretty(ppf, v) {
  return Curry._2(Format.fprintf(ppf, /* Format */[
                  /* Formatting_gen */Block.__(18, [
                      /* Open_box */Block.__(1, [/* Format */[
                            /* End_of_format */0,
                            ""
                          ]]),
                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                              /* Close_box */0,
                              /* Formatting_lit */Block.__(17, [
                                  /* FFlush */2,
                                  /* End_of_format */0
                                ])
                            ])])
                    ]),
                  "@[%a@]@?"
                ]), pretty_val, v);
}

function simple_match(p1, p2) {
  var match = p1.pat_desc;
  var match$1 = p2.pat_desc;
  if (typeof match !== "number") {
    switch (match.tag | 0) {
      case /* Tpat_constant */2 :
          if (typeof match$1 !== "number") {
            switch (match$1.tag | 0) {
              case /* Tpat_var */0 :
                  break;
              case /* Tpat_constant */2 :
                  return const_compare(match[0], match$1[0]) === 0;
              default:
                return false;
            }
          }
          break;
      case /* Tpat_tuple */3 :
          if (typeof match$1 !== "number") {
            switch (match$1.tag | 0) {
              case /* Tpat_var */0 :
                  break;
              case /* Tpat_tuple */3 :
                  return true;
              default:
                return false;
            }
          }
          break;
      case /* Tpat_construct */4 :
          if (typeof match$1 !== "number") {
            switch (match$1.tag | 0) {
              case /* Tpat_var */0 :
                  break;
              case /* Tpat_construct */4 :
                  return equal_tag(match[1].cstr_tag, match$1[1].cstr_tag);
              default:
                return false;
            }
          }
          break;
      case /* Tpat_variant */5 :
          if (typeof match$1 !== "number") {
            switch (match$1.tag | 0) {
              case /* Tpat_var */0 :
                  break;
              case /* Tpat_variant */5 :
                  return match[0] === match$1[0];
              default:
                return false;
            }
          }
          break;
      case /* Tpat_record */6 :
          if (typeof match$1 !== "number") {
            switch (match$1.tag | 0) {
              case /* Tpat_var */0 :
                  break;
              case /* Tpat_record */6 :
                  return true;
              default:
                return false;
            }
          }
          break;
      case /* Tpat_array */7 :
          if (typeof match$1 !== "number") {
            switch (match$1.tag | 0) {
              case /* Tpat_var */0 :
                  break;
              case /* Tpat_array */7 :
                  return List.length(match[0]) === List.length(match$1[0]);
              default:
                return false;
            }
          }
          break;
      case /* Tpat_lazy */9 :
          if (typeof match$1 !== "number") {
            switch (match$1.tag | 0) {
              case /* Tpat_var */0 :
                  break;
              case /* Tpat_lazy */9 :
                  return true;
              default:
                return false;
            }
          }
          break;
      default:
        
    }
  }
  if (typeof match$1 === "number" || !match$1.tag) {
    return true;
  } else {
    return false;
  }
}

function record_arg(p) {
  var match = p.pat_desc;
  if (typeof match === "number") {
    return /* [] */0;
  } else if (match.tag === /* Tpat_record */6) {
    return match[0];
  } else {
    return fatal_error("Parmatch.as_record");
  }
}

function get_field(pos, arg) {
  return List.find((function (param) {
                  return pos === param[1].lbl_pos;
                }), arg)[2];
}

function simple_match_args(p1, _p2) {
  while(true) {
    var p2 = _p2;
    var match = p2.pat_desc;
    if (typeof match !== "number") {
      switch (match.tag | 0) {
        case /* Tpat_var */0 :
            break;
        case /* Tpat_alias */1 :
            _p2 = match[0];
            continue ;
        case /* Tpat_construct */4 :
            return match[2];
        case /* Tpat_variant */5 :
            var match$1 = match[1];
            if (match$1 !== void 0) {
              return /* :: */[
                      match$1,
                      /* [] */0
                    ];
            } else {
              return /* [] */0;
            }
        case /* Tpat_record */6 :
            var omegas = record_arg(p1);
            var arg = match[0];
            return List.map((function(arg){
                      return function (param) {
                        try {
                          return get_field(param[1].lbl_pos, arg);
                        }
                        catch (exn){
                          if (exn === Caml_builtin_exceptions.not_found) {
                            return omega;
                          }
                          throw exn;
                        }
                      }
                      }(arg)), omegas);
        case /* Tpat_tuple */3 :
        case /* Tpat_array */7 :
            return match[0];
        case /* Tpat_constant */2 :
        case /* Tpat_or */8 :
            return /* [] */0;
        case /* Tpat_lazy */9 :
            return /* :: */[
                    match[0],
                    /* [] */0
                  ];
        
      }
    }
    var match$2 = p1.pat_desc;
    if (typeof match$2 === "number") {
      return /* [] */0;
    }
    switch (match$2.tag | 0) {
      case /* Tpat_tuple */3 :
          return List.map((function (param) {
                        return omega;
                      }), match$2[0]);
      case /* Tpat_construct */4 :
          return List.map((function (param) {
                        return omega;
                      }), match$2[2]);
      case /* Tpat_variant */5 :
          if (match$2[1] !== void 0) {
            return /* :: */[
                    omega,
                    /* [] */0
                  ];
          } else {
            return /* [] */0;
          }
      case /* Tpat_record */6 :
          return List.map((function (param) {
                        return omega;
                      }), match$2[0]);
      case /* Tpat_array */7 :
          return List.map((function (param) {
                        return omega;
                      }), match$2[0]);
      case /* Tpat_lazy */9 :
          return /* :: */[
                  omega,
                  /* [] */0
                ];
      default:
        return /* [] */0;
    }
  };
}

function normalize_pat(_q) {
  while(true) {
    var q = _q;
    var match = q.pat_desc;
    if (typeof match === "number") {
      return q;
    }
    switch (match.tag | 0) {
      case /* Tpat_var */0 :
          return make_pat(/* Tpat_any */0, q.pat_type, q.pat_env);
      case /* Tpat_alias */1 :
          _q = match[0];
          continue ;
      case /* Tpat_constant */2 :
          return q;
      case /* Tpat_tuple */3 :
          return make_pat(/* Tpat_tuple */Block.__(3, [List.map((function (param) {
                                return omega;
                              }), match[0])]), q.pat_type, q.pat_env);
      case /* Tpat_construct */4 :
          return make_pat(/* Tpat_construct */Block.__(4, [
                        match[0],
                        match[1],
                        List.map((function (param) {
                                return omega;
                              }), match[2])
                      ]), q.pat_type, q.pat_env);
      case /* Tpat_variant */5 :
          return make_pat(/* Tpat_variant */Block.__(5, [
                        match[0],
                        may_map((function (param) {
                                return omega;
                              }), match[1]),
                        match[2]
                      ]), q.pat_type, q.pat_env);
      case /* Tpat_record */6 :
          return make_pat(/* Tpat_record */Block.__(6, [
                        List.map((function (param) {
                                return /* tuple */[
                                        param[0],
                                        param[1],
                                        omega
                                      ];
                              }), match[0]),
                        match[1]
                      ]), q.pat_type, q.pat_env);
      case /* Tpat_array */7 :
          return make_pat(/* Tpat_array */Block.__(7, [List.map((function (param) {
                                return omega;
                              }), match[0])]), q.pat_type, q.pat_env);
      case /* Tpat_or */8 :
          return fatal_error("Parmatch.normalize_pat");
      case /* Tpat_lazy */9 :
          return make_pat(/* Tpat_lazy */Block.__(9, [omega]), q.pat_type, q.pat_env);
      
    }
  };
}

function discr_pat(q, pss) {
  var q$1 = normalize_pat(q);
  var tmp = q$1.pat_desc;
  if (typeof tmp === "number" || tmp.tag === /* Tpat_record */6) {
    var _acc = q$1;
    var _pss = pss;
    while(true) {
      var pss$1 = _pss;
      var acc = _acc;
      if (!pss$1) {
        return acc;
      }
      var match = pss$1[0];
      if (!match) {
        return acc;
      }
      var p = match[0];
      var match$1 = p.pat_desc;
      if (typeof match$1 === "number") {
        _pss = pss$1[1];
        continue ;
      } else {
        switch (match$1.tag | 0) {
          case /* Tpat_var */0 :
              _pss = pss$1[1];
              continue ;
          case /* Tpat_alias */1 :
              _pss = /* :: */[
                /* :: */[
                  match$1[0],
                  match[1]
                ],
                pss$1[1]
              ];
              continue ;
          case /* Tpat_record */6 :
              var new_omegas = List.fold_right((function (param, r) {
                      var lbl = param[1];
                      try {
                        get_field(lbl.lbl_pos, r);
                        return r;
                      }
                      catch (exn){
                        if (exn === Caml_builtin_exceptions.not_found) {
                          return /* :: */[
                                  /* tuple */[
                                    param[0],
                                    lbl,
                                    omega
                                  ],
                                  r
                                ];
                        }
                        throw exn;
                      }
                    }), match$1[0], record_arg(acc));
              _pss = pss$1[1];
              _acc = make_pat(/* Tpat_record */Block.__(6, [
                      new_omegas,
                      match$1[1]
                    ]), p.pat_type, p.pat_env);
              continue ;
          case /* Tpat_or */8 :
              var ps = match[1];
              _pss = /* :: */[
                /* :: */[
                  match$1[0],
                  ps
                ],
                /* :: */[
                  /* :: */[
                    match$1[1],
                    ps
                  ],
                  pss$1[1]
                ]
              ];
              continue ;
          case /* Tpat_tuple */3 :
          case /* Tpat_lazy */9 :
              return normalize_pat(p);
          default:
            return acc;
        }
      }
    };
  } else {
    return q$1;
  }
}

function read_args(xs, r) {
  if (!xs) {
    return /* tuple */[
            /* [] */0,
            r
          ];
  }
  if (!r) {
    return fatal_error("Parmatch.read_args");
  }
  var match = read_args(xs[1], r[1]);
  return /* tuple */[
          /* :: */[
            r[0],
            match[0]
          ],
          match[1]
        ];
}

function do_set_args(erase_mutable, q, r) {
  var match = q.pat_desc;
  if (typeof match === "number") {
    return /* :: */[
            q,
            r
          ];
  }
  switch (match.tag | 0) {
    case /* Tpat_constant */2 :
        return /* :: */[
                q,
                r
              ];
    case /* Tpat_tuple */3 :
        var match$1 = read_args(match[0], r);
        return /* :: */[
                make_pat(/* Tpat_tuple */Block.__(3, [match$1[0]]), q.pat_type, q.pat_env),
                match$1[1]
              ];
    case /* Tpat_construct */4 :
        var match$2 = read_args(match[2], r);
        return /* :: */[
                make_pat(/* Tpat_construct */Block.__(4, [
                        match[0],
                        match[1],
                        match$2[0]
                      ]), q.pat_type, q.pat_env),
                match$2[1]
              ];
    case /* Tpat_variant */5 :
        var match$3;
        if (match[1] !== void 0) {
          if (!r) {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  /* tuple */[
                    "parmatch.ml",
                    450,
                    13
                  ]
                ];
          }
          match$3 = /* tuple */[
            r[0],
            r[1]
          ];
        } else {
          match$3 = /* tuple */[
            void 0,
            r
          ];
        }
        return /* :: */[
                make_pat(/* Tpat_variant */Block.__(5, [
                        match[0],
                        match$3[0],
                        match[2]
                      ]), q.pat_type, q.pat_env),
                match$3[1]
              ];
    case /* Tpat_record */6 :
        var omegas = match[0];
        var match$4 = read_args(omegas, r);
        return /* :: */[
                make_pat(/* Tpat_record */Block.__(6, [
                        List.map2((function (param, arg) {
                                var lbl = param[1];
                                var lid = param[0];
                                var tmp = false;
                                if (erase_mutable) {
                                  var match = lbl.lbl_mut;
                                  tmp = match ? true : false;
                                }
                                if (tmp) {
                                  return /* tuple */[
                                          lid,
                                          lbl,
                                          omega
                                        ];
                                } else {
                                  return /* tuple */[
                                          lid,
                                          lbl,
                                          arg
                                        ];
                                }
                              }), omegas, match$4[0]),
                        match[1]
                      ]), q.pat_type, q.pat_env),
                match$4[1]
              ];
    case /* Tpat_array */7 :
        var match$5 = read_args(match[0], r);
        return /* :: */[
                make_pat(/* Tpat_array */Block.__(7, [match$5[0]]), q.pat_type, q.pat_env),
                match$5[1]
              ];
    case /* Tpat_lazy */9 :
        if (r) {
          return /* :: */[
                  make_pat(/* Tpat_lazy */Block.__(9, [r[0]]), q.pat_type, q.pat_env),
                  r[1]
                ];
        } else {
          return fatal_error("Parmatch.do_set_args (lazy)");
        }
    default:
      return fatal_error("Parmatch.set_args");
  }
}

function filter_one(q, pss) {
  var filter_rec = function (_param) {
    while(true) {
      var param = _param;
      if (!param) {
        return /* [] */0;
      }
      var match = param[0];
      if (!match) {
        return /* [] */0;
      }
      var p = match[0];
      var match$1 = p.pat_desc;
      if (typeof match$1 !== "number") {
        switch (match$1.tag | 0) {
          case /* Tpat_alias */1 :
              _param = /* :: */[
                /* :: */[
                  match$1[0],
                  match[1]
                ],
                param[1]
              ];
              continue ;
          case /* Tpat_or */8 :
              var ps = match[1];
              _param = /* :: */[
                /* :: */[
                  match$1[0],
                  ps
                ],
                /* :: */[
                  /* :: */[
                    match$1[1],
                    ps
                  ],
                  param[1]
                ]
              ];
              continue ;
          default:
            
        }
      }
      var pss = param[1];
      if (simple_match(q, p)) {
        return /* :: */[
                Pervasives.$at(simple_match_args(q, p), match[1]),
                filter_rec(pss)
              ];
      }
      _param = pss;
      continue ;
    };
  };
  return filter_rec(pss);
}

function filter_extra(pss) {
  var filter_rec = function (_param) {
    while(true) {
      var param = _param;
      if (!param) {
        return /* [] */0;
      }
      var match = param[0];
      if (match) {
        var match$1 = match[0].pat_desc;
        if (typeof match$1 === "number") {
          return /* :: */[
                  match[1],
                  filter_rec(param[1])
                ];
        }
        switch (match$1.tag | 0) {
          case /* Tpat_var */0 :
              return /* :: */[
                      match[1],
                      filter_rec(param[1])
                    ];
          case /* Tpat_alias */1 :
              _param = /* :: */[
                /* :: */[
                  match$1[0],
                  match[1]
                ],
                param[1]
              ];
              continue ;
          case /* Tpat_or */8 :
              var ps = match[1];
              _param = /* :: */[
                /* :: */[
                  match$1[0],
                  ps
                ],
                /* :: */[
                  /* :: */[
                    match$1[1],
                    ps
                  ],
                  param[1]
                ]
              ];
              continue ;
          default:
            _param = param[1];
            continue ;
        }
      } else {
        _param = param[1];
        continue ;
      }
    };
  };
  return filter_rec(pss);
}

function filter_all(pat0, pss) {
  var insert = function (q, qs, env) {
    if (env) {
      var env$1 = env[1];
      var c = env[0];
      var q0 = c[0];
      if (simple_match(q0, q)) {
        return /* :: */[
                /* tuple */[
                  q0,
                  /* :: */[
                    Pervasives.$at(simple_match_args(q0, q), qs),
                    c[1]
                  ]
                ],
                env$1
              ];
      } else {
        return /* :: */[
                c,
                insert(q, qs, env$1)
              ];
      }
    } else {
      var q0$1 = normalize_pat(q);
      return /* :: */[
              /* tuple */[
                q0$1,
                /* :: */[
                  Pervasives.$at(simple_match_args(q0$1, q), qs),
                  /* [] */0
                ]
              ],
              /* [] */0
            ];
    }
  };
  var filter_rec = function (_env, _param) {
    while(true) {
      var param = _param;
      var env = _env;
      if (!param) {
        return env;
      }
      var match = param[0];
      if (!match) {
        return env;
      }
      var p = match[0];
      var match$1 = p.pat_desc;
      if (typeof match$1 === "number") {
        _param = param[1];
        continue ;
      } else {
        switch (match$1.tag | 0) {
          case /* Tpat_var */0 :
              _param = param[1];
              continue ;
          case /* Tpat_alias */1 :
              _param = /* :: */[
                /* :: */[
                  match$1[0],
                  match[1]
                ],
                param[1]
              ];
              continue ;
          case /* Tpat_or */8 :
              var ps = match[1];
              _param = /* :: */[
                /* :: */[
                  match$1[0],
                  ps
                ],
                /* :: */[
                  /* :: */[
                    match$1[1],
                    ps
                  ],
                  param[1]
                ]
              ];
              continue ;
          default:
            _param = param[1];
            _env = insert(p, match[1], env);
            continue ;
        }
      }
    };
  };
  var match = pat0.pat_desc;
  var tmp;
  var exit = 0;
  if (typeof match === "number") {
    tmp = /* [] */0;
  } else {
    switch (match.tag | 0) {
      case /* Tpat_tuple */3 :
      case /* Tpat_record */6 :
      case /* Tpat_lazy */9 :
          exit = 1;
          break;
      default:
        tmp = /* [] */0;
    }
  }
  if (exit === 1) {
    tmp = /* :: */[
      /* tuple */[
        pat0,
        /* [] */0
      ],
      /* [] */0
    ];
  }
  var _env = filter_rec(tmp, pss);
  var _param = pss;
  while(true) {
    var param = _param;
    var env = _env;
    if (!param) {
      return env;
    }
    var match$1 = param[0];
    if (match$1) {
      var match$2 = match$1[0].pat_desc;
      if (typeof match$2 !== "number") {
        switch (match$2.tag | 0) {
          case /* Tpat_var */0 :
              break;
          case /* Tpat_alias */1 :
              _param = /* :: */[
                /* :: */[
                  match$2[0],
                  match$1[1]
                ],
                param[1]
              ];
              continue ;
          case /* Tpat_or */8 :
              var ps = match$1[1];
              _param = /* :: */[
                /* :: */[
                  match$2[0],
                  ps
                ],
                /* :: */[
                  /* :: */[
                    match$2[1],
                    ps
                  ],
                  param[1]
                ]
              ];
              continue ;
          default:
            _param = param[1];
            continue ;
        }
      }
      var ps$1 = match$1[1];
      _param = param[1];
      _env = List.map((function(ps$1){
          return function (param) {
            var q = param[0];
            return /* tuple */[
                    q,
                    /* :: */[
                      Pervasives.$at(simple_match_args(q, omega), ps$1),
                      param[1]
                    ]
                  ];
          }
          }(ps$1)), env);
      continue ;
    } else {
      _param = param[1];
      continue ;
    }
  };
}

function set_last(a, param) {
  if (!param) {
    return /* [] */0;
  }
  var l = param[1];
  if (l) {
    return /* :: */[
            param[0],
            set_last(a, l)
          ];
  } else {
    return /* :: */[
            a,
            /* [] */0
          ];
  }
}

function mark_partial(_param) {
  while(true) {
    var param = _param;
    if (!param) {
      return /* [] */0;
    }
    var ps = param[0];
    if (ps) {
      var match = ps[0].pat_desc;
      if (typeof match === "number") {
        return /* :: */[
                ps,
                mark_partial(param[1])
              ];
      }
      switch (match.tag | 0) {
        case /* Tpat_var */0 :
            return /* :: */[
                    ps,
                    mark_partial(param[1])
                  ];
        case /* Tpat_alias */1 :
            _param = /* :: */[
              /* :: */[
                match[0],
                ps[1]
              ],
              param[1]
            ];
            continue ;
        case /* Tpat_or */8 :
            var ps$1 = ps[1];
            _param = /* :: */[
              /* :: */[
                match[0],
                ps$1
              ],
              /* :: */[
                /* :: */[
                  match[1],
                  ps$1
                ],
                param[1]
              ]
            ];
            continue ;
        default:
          
      }
    }
    return /* :: */[
            set_last(zero, ps),
            mark_partial(param[1])
          ];
  };
}

function close_variant(env, row) {
  var row$1 = row_repr_aux(/* [] */0, row);
  var nm = List.fold_left((function (nm, param) {
          var match = row_field_repr_aux(/* [] */0, param[1]);
          if (typeof match === "number" || !(match.tag && !match[2])) {
            return nm;
          } else {
            set_row_field(match[3], /* Rabsent */0);
            return ;
          }
        }), row$1.row_name, row$1.row_fields);
  if (!row$1.row_closed || nm !== row$1.row_name) {
    return unify$2(env, row$1.row_more, newty2(100000000, /* Tvariant */Block.__(8, [{
                        row_fields: /* [] */0,
                        row_more: newty2(100000000, /* Tvar */Block.__(0, [void 0])),
                        row_bound: row$1.row_bound,
                        row_closed: true,
                        row_fixed: row$1.row_fixed,
                        row_name: nm
                      }])));
  }
  
}

function row_of_pat(pat) {
  var match = expand_head(pat.pat_env, pat.pat_type);
  var match$1 = match.desc;
  if (typeof match$1 === "number") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "parmatch.ml",
            602,
            9
          ]
        ];
  }
  if (match$1.tag === /* Tvariant */8) {
    return row_repr_aux(/* [] */0, match$1[0]);
  }
  throw [
        Caml_builtin_exceptions.assert_failure,
        /* tuple */[
          "parmatch.ml",
          602,
          9
        ]
      ];
}

function generalized_constructor(x) {
  var match = x[0].pat_desc;
  if (typeof match === "number") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "parmatch.ml",
            613,
            9
          ]
        ];
  }
  if (match.tag === /* Tpat_construct */4) {
    return match[1].cstr_generalized;
  }
  throw [
        Caml_builtin_exceptions.assert_failure,
        /* tuple */[
          "parmatch.ml",
          613,
          9
        ]
      ];
}

function clean_env(env) {
  var loop = function (_param) {
    while(true) {
      var param = _param;
      if (!param) {
        return /* [] */0;
      }
      var xs = param[1];
      var x = param[0];
      if (!generalized_constructor(x)) {
        return /* :: */[
                x,
                loop(xs)
              ];
      }
      _param = xs;
      continue ;
    };
  };
  return loop(env);
}

function full_match(ignore_generalized, closing, env) {
  if (!env) {
    return fatal_error("Parmatch.full_match");
  }
  var p = env[0][0];
  var match = p.pat_desc;
  if (typeof match === "number") {
    return fatal_error("Parmatch.full_match");
  }
  switch (match.tag | 0) {
    case /* Tpat_constant */2 :
        if (match[0].tag === /* Const_char */1) {
          return List.length(env) === 256;
        } else {
          return false;
        }
    case /* Tpat_construct */4 :
        var c = match[1];
        if (c.cstr_consts < 0) {
          return false;
        }
        if (!ignore_generalized) {
          return List.length(env) === (c.cstr_consts + c.cstr_nonconsts | 0);
        }
        var env$1 = clean_env(env);
        return List.length(env$1) === c.cstr_normal;
    case /* Tpat_variant */5 :
        var fields = List.map((function (param) {
                var match = param[0].pat_desc;
                if (typeof match === "number") {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        /* tuple */[
                          "parmatch.ml",
                          640,
                          17
                        ]
                      ];
                }
                if (match.tag === /* Tpat_variant */5) {
                  return match[0];
                }
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      /* tuple */[
                        "parmatch.ml",
                        640,
                        17
                      ]
                    ];
              }), env);
        var row = row_of_pat(p);
        if (closing && !row_fixed(row)) {
          return List.for_all((function (param) {
                        var tag = param[0];
                        var match = row_field_repr_aux(/* [] */0, param[1]);
                        if (typeof match === "number" || match.tag && !match[2]) {
                          return true;
                        } else {
                          return List.mem(tag, fields);
                        }
                      }), row.row_fields);
        } else if (row.row_closed) {
          return List.for_all((function (param) {
                        if (row_field_repr_aux(/* [] */0, param[1]) === /* Rabsent */0) {
                          return true;
                        } else {
                          return List.mem(param[0], fields);
                        }
                      }), row.row_fields);
        } else {
          return false;
        }
    case /* Tpat_array */7 :
        return false;
    case /* Tpat_tuple */3 :
    case /* Tpat_record */6 :
    case /* Tpat_lazy */9 :
        return true;
    default:
      return fatal_error("Parmatch.full_match");
  }
}

function full_match_gadt(env) {
  if (!env) {
    return true;
  }
  var match = env[0][0].pat_desc;
  if (typeof match === "number") {
    return true;
  }
  if (match.tag !== /* Tpat_construct */4) {
    return true;
  }
  var c = match[1];
  return List.length(env) === (c.cstr_consts + c.cstr_nonconsts | 0);
}

function should_extend(ext, env) {
  if (ext === void 0) {
    return false;
  }
  if (!env) {
    return false;
  }
  var p = env[0][0];
  var match = p.pat_desc;
  if (typeof match === "number") {
    return false;
  }
  if (match.tag !== /* Tpat_construct */4) {
    return false;
  }
  switch (match[1].cstr_tag.tag | 0) {
    case /* Cstr_constant */0 :
    case /* Cstr_block */1 :
        break;
    case /* Cstr_extension */2 :
        return false;
    
  }
  var path = get_type_path(p.pat_type, p.pat_env);
  return same(path, ext);
}

function complete_tags(nconsts, nconstrs, tags) {
  var seen_const = Caml_array.caml_make_vect(nconsts, false);
  var seen_constr = Caml_array.caml_make_vect(nconstrs, false);
  List.iter((function (param) {
          switch (param.tag | 0) {
            case /* Cstr_constant */0 :
                return Caml_array.caml_array_set(seen_const, param[0], true);
            case /* Cstr_block */1 :
                return Caml_array.caml_array_set(seen_constr, param[0], true);
            case /* Cstr_extension */2 :
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      /* tuple */[
                        "parmatch.ml",
                        703,
                        14
                      ]
                    ];
            
          }
        }), tags);
  var r = /* [] */0;
  for(var i = 0 ,i_finish = nconsts - 1 | 0; i <= i_finish; ++i){
    if (!Caml_array.caml_array_get(seen_const, i)) {
      r = /* :: */[
        /* Cstr_constant */Block.__(0, [i]),
        r
      ];
    }
    
  }
  for(var i$1 = 0 ,i_finish$1 = nconstrs - 1 | 0; i$1 <= i_finish$1; ++i$1){
    if (!Caml_array.caml_array_get(seen_constr, i$1)) {
      r = /* :: */[
        /* Cstr_block */Block.__(1, [i$1]),
        r
      ];
    }
    
  }
  return r;
}

function pat_of_constr(ex_pat, cstr) {
  return {
          pat_desc: /* Tpat_construct */Block.__(4, [
              {
                txt: /* Lident */Block.__(0, ["?pat_of_constr?"]),
                loc: none
              },
              cstr,
              omegas(cstr.cstr_arity)
            ]),
          pat_loc: ex_pat.pat_loc,
          pat_extra: ex_pat.pat_extra,
          pat_type: ex_pat.pat_type,
          pat_env: ex_pat.pat_env,
          pat_attributes: ex_pat.pat_attributes
        };
}

function pat_of_constrs(ex_pat, param) {
  if (!param) {
    throw Empty;
  }
  var rem = param[1];
  var cstr = param[0];
  if (rem) {
    return {
            pat_desc: /* Tpat_or */Block.__(8, [
                pat_of_constr(ex_pat, cstr),
                pat_of_constrs(ex_pat, rem),
                void 0
              ]),
            pat_loc: ex_pat.pat_loc,
            pat_extra: ex_pat.pat_extra,
            pat_type: ex_pat.pat_type,
            pat_env: ex_pat.pat_env,
            pat_attributes: ex_pat.pat_attributes
          };
  } else {
    return pat_of_constr(ex_pat, cstr);
  }
}

function get_variant_constructors(env, _ty) {
  while(true) {
    var ty = _ty;
    var match = repr(ty).desc;
    if (typeof match === "number") {
      return fatal_error("Parmatch.get_variant_constructors");
    }
    if (match.tag !== /* Tconstr */3) {
      return fatal_error("Parmatch.get_variant_constructors");
    }
    var path = match[0];
    var match$1 = find_type_full(path, env)[0];
    var tmp = match$1.type_kind;
    if (typeof tmp !== "number" && tmp.tag === /* Type_variant */1) {
      return find_type_full(path, env)[1][0];
    }
    if (match$1.type_manifest === void 0) {
      return fatal_error("Parmatch.get_variant_constructors");
    }
    _ty = expand_head_once(env, clean_copy(ty));
    continue ;
  };
}

function map_filter(f, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return /* [] */0;
    }
    var xs = param[1];
    var match = Curry._1(f, param[0]);
    if (match !== void 0) {
      return /* :: */[
              Caml_option.valFromOption(match),
              map_filter(f, xs)
            ];
    }
    _param = xs;
    continue ;
  };
}

function complete_constrs(p, all_tags) {
  var match = p.pat_desc;
  if (typeof match === "number") {
    return fatal_error("Parmatch.complete_constr");
  }
  if (match.tag !== /* Tpat_construct */4) {
    return fatal_error("Parmatch.complete_constr");
  }
  var c = match[1];
  var not_tags = complete_tags(c.cstr_consts, c.cstr_nonconsts, all_tags);
  var constrs = get_variant_constructors(p.pat_env, c.cstr_res);
  return map_filter((function (cnstr) {
                if (List.exists((function (tag) {
                          return equal_tag(tag, cnstr.cstr_tag);
                        }), not_tags)) {
                  return cnstr;
                }
                
              }), constrs);
}

function build_other_constant(proj, make, first, next, p, env) {
  var all = List.map((function (param) {
          return Curry._1(proj, param[0].pat_desc);
        }), env);
  var _i = first;
  while(true) {
    var i = _i;
    if (!List.mem(i, all)) {
      return make_pat(Curry._1(make, i), p.pat_type, p.pat_env);
    }
    _i = Curry._1(next, i);
    continue ;
  };
}

function build_other(ext, env) {
  if (!env) {
    return omega;
  }
  var p = env[0][0];
  var match = p.pat_desc;
  if (typeof match === "number") {
    return omega;
  }
  switch (match.tag | 0) {
    case /* Tpat_constant */2 :
        switch (match[0].tag | 0) {
          case /* Const_int */0 :
              return build_other_constant((function (param) {
                            if (typeof param !== "number" && param.tag === /* Tpat_constant */2) {
                              var match = param[0];
                              if (!match.tag) {
                                return match[0];
                              }
                              
                            }
                            throw [
                                  Caml_builtin_exceptions.assert_failure,
                                  /* tuple */[
                                    "parmatch.ml",
                                    857,
                                    55
                                  ]
                                ];
                          }), (function (i) {
                            return /* Tpat_constant */Block.__(2, [/* Const_int */Block.__(0, [i])]);
                          }), 0, (function (prim) {
                            return prim + 1 | 0;
                          }), p, env);
          case /* Const_char */1 :
              var all_chars = List.map((function (param) {
                      var match = param[0].pat_desc;
                      if (typeof match !== "number" && match.tag === /* Tpat_constant */2) {
                        var match$1 = match[0];
                        if (match$1.tag === /* Const_char */1) {
                          return match$1[0];
                        }
                        
                      }
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            /* tuple */[
                              "parmatch.ml",
                              832,
                              15
                            ]
                          ];
                    }), env);
              var _param = /* :: */[
                /* tuple */[
                  /* "a" */97,
                  /* "z" */122
                ],
                /* :: */[
                  /* tuple */[
                    /* "A" */65,
                    /* "Z" */90
                  ],
                  /* :: */[
                    /* tuple */[
                      /* "0" */48,
                      /* "9" */57
                    ],
                    /* :: */[
                      /* tuple */[
                        /* " " */32,
                        /* "~" */126
                      ],
                      /* :: */[
                        /* tuple */[
                          Char.chr(0),
                          Char.chr(255)
                        ],
                        /* [] */0
                      ]
                    ]
                  ]
                ]
              ];
              while(true) {
                var param = _param;
                if (!param) {
                  return omega;
                }
                var match$1 = param[0];
                try {
                  var _i = match$1[0];
                  var imax = match$1[1];
                  while(true) {
                    var i = _i;
                    if (i > imax) {
                      throw Caml_builtin_exceptions.not_found;
                    }
                    var ci = Char.chr(i);
                    if (!List.mem(ci, all_chars)) {
                      return make_pat(/* Tpat_constant */Block.__(2, [/* Const_char */Block.__(1, [ci])]), p.pat_type, p.pat_env);
                    }
                    _i = i + 1 | 0;
                    continue ;
                  };
                }
                catch (exn){
                  if (exn !== Caml_builtin_exceptions.not_found) {
                    throw exn;
                  }
                  _param = param[1];
                  continue ;
                }
              };
          case /* Const_string */2 :
              return build_other_constant((function (param) {
                            if (typeof param !== "number" && param.tag === /* Tpat_constant */2) {
                              var match = param[0];
                              if (match.tag === /* Const_string */2) {
                                return match[0].length;
                              }
                              
                            }
                            throw [
                                  Caml_builtin_exceptions.assert_failure,
                                  /* tuple */[
                                    "parmatch.ml",
                                    878,
                                    21
                                  ]
                                ];
                          }), (function (i) {
                            return /* Tpat_constant */Block.__(2, [/* Const_string */Block.__(2, [
                                          Caml_bytes.bytes_to_string(Bytes.make(i, /* "*" */42)),
                                          void 0
                                        ])]);
                          }), 0, (function (prim) {
                            return prim + 1 | 0;
                          }), p, env);
          case /* Const_float */3 :
              return build_other_constant((function (param) {
                            if (typeof param !== "number" && param.tag === /* Tpat_constant */2) {
                              var match = param[0];
                              if (match.tag === /* Const_float */3) {
                                return Caml_format.caml_float_of_string(match[0]);
                              }
                              
                            }
                            throw [
                                  Caml_builtin_exceptions.assert_failure,
                                  /* tuple */[
                                    "parmatch.ml",
                                    884,
                                    21
                                  ]
                                ];
                          }), (function (f) {
                            return /* Tpat_constant */Block.__(2, [/* Const_float */Block.__(3, [Pervasives.string_of_float(f)])]);
                          }), 0.0, (function (f) {
                            return f + 1.0;
                          }), p, env);
          case /* Const_int32 */4 :
              return build_other_constant((function (param) {
                            if (typeof param !== "number" && param.tag === /* Tpat_constant */2) {
                              var match = param[0];
                              if (match.tag === /* Const_int32 */4) {
                                return match[0];
                              }
                              
                            }
                            throw [
                                  Caml_builtin_exceptions.assert_failure,
                                  /* tuple */[
                                    "parmatch.ml",
                                    862,
                                    57
                                  ]
                                ];
                          }), (function (i) {
                            return /* Tpat_constant */Block.__(2, [/* Const_int32 */Block.__(4, [i])]);
                          }), 0, Int32.succ, p, env);
          case /* Const_int64 */5 :
              return build_other_constant((function (param) {
                            if (typeof param !== "number" && param.tag === /* Tpat_constant */2) {
                              var match = param[0];
                              if (match.tag === /* Const_int64 */5) {
                                return match[0];
                              }
                              
                            }
                            throw [
                                  Caml_builtin_exceptions.assert_failure,
                                  /* tuple */[
                                    "parmatch.ml",
                                    867,
                                    57
                                  ]
                                ];
                          }), (function (i) {
                            return /* Tpat_constant */Block.__(2, [/* Const_int64 */Block.__(5, [i])]);
                          }), Caml_int64.zero, Int64.succ, p, env);
          case /* Const_nativeint */6 :
              return build_other_constant((function (param) {
                            if (typeof param !== "number" && param.tag === /* Tpat_constant */2) {
                              var match = param[0];
                              if (match.tag === /* Const_nativeint */6) {
                                return match[0];
                              }
                              
                            }
                            throw [
                                  Caml_builtin_exceptions.assert_failure,
                                  /* tuple */[
                                    "parmatch.ml",
                                    872,
                                    61
                                  ]
                                ];
                          }), (function (i) {
                            return /* Tpat_constant */Block.__(2, [/* Const_nativeint */Block.__(6, [i])]);
                          }), 0, Nativeint.succ, p, env);
          
        }
    case /* Tpat_construct */4 :
        var c = match[1];
        var exit = 0;
        switch (c.cstr_tag.tag | 0) {
          case /* Cstr_constant */0 :
          case /* Cstr_block */1 :
              exit = 1;
              break;
          case /* Cstr_extension */2 :
              var c_cstr_res = c.cstr_res;
              var c_cstr_existentials = c.cstr_existentials;
              var c_cstr_args = c.cstr_args;
              var c_cstr_arity = c.cstr_arity;
              var c_cstr_tag = c.cstr_tag;
              var c_cstr_consts = c.cstr_consts;
              var c_cstr_nonconsts = c.cstr_nonconsts;
              var c_cstr_normal = c.cstr_normal;
              var c_cstr_generalized = c.cstr_generalized;
              var c_cstr_private = c.cstr_private;
              var c_cstr_loc = c.cstr_loc;
              var c_cstr_attributes = c.cstr_attributes;
              var c$1 = {
                cstr_name: "*extension*",
                cstr_res: c_cstr_res,
                cstr_existentials: c_cstr_existentials,
                cstr_args: c_cstr_args,
                cstr_arity: c_cstr_arity,
                cstr_tag: c_cstr_tag,
                cstr_consts: c_cstr_consts,
                cstr_nonconsts: c_cstr_nonconsts,
                cstr_normal: c_cstr_normal,
                cstr_generalized: c_cstr_generalized,
                cstr_private: c_cstr_private,
                cstr_loc: c_cstr_loc,
                cstr_attributes: c_cstr_attributes
              };
              return make_pat(/* Tpat_construct */Block.__(4, [
                            match[0],
                            c$1,
                            /* [] */0
                          ]), none$2, empty);
          
        }
        if (exit === 1) {
          if (ext !== void 0 && same(ext, get_type_path(p.pat_type, p.pat_env))) {
            return extra_pat;
          }
          var all_tags = List.map((function (param) {
                  var param$1 = param[0];
                  var match = param$1.pat_desc;
                  if (typeof match === "number" || match.tag !== /* Tpat_construct */4) {
                    return fatal_error("Parmatch.get_tag");
                  } else {
                    return match[1].cstr_tag;
                  }
                }), env);
          return pat_of_constrs(p, complete_constrs(p, all_tags));
        }
        break;
    case /* Tpat_variant */5 :
        var r = match[2];
        var tags = List.map((function (param) {
                var match = param[0].pat_desc;
                if (typeof match === "number") {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        /* tuple */[
                          "parmatch.ml",
                          801,
                          23
                        ]
                      ];
                }
                if (match.tag === /* Tpat_variant */5) {
                  return match[0];
                }
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      /* tuple */[
                        "parmatch.ml",
                        801,
                        23
                      ]
                    ];
              }), env);
        var row = row_of_pat(p);
        var make_other_pat = function (tag, $$const) {
          var arg = $$const ? void 0 : omega;
          return make_pat(/* Tpat_variant */Block.__(5, [
                        tag,
                        arg,
                        r
                      ]), p.pat_type, p.pat_env);
        };
        var match$2 = List.fold_left((function (others, param) {
                var tag = param[0];
                if (List.mem(tag, tags)) {
                  return others;
                }
                var match = row_field_repr_aux(/* [] */0, param[1]);
                if (typeof match === "number") {
                  return others;
                } else if (match.tag) {
                  return /* :: */[
                          make_other_pat(tag, match[0]),
                          others
                        ];
                } else {
                  return /* :: */[
                          make_other_pat(tag, match[0] === void 0),
                          others
                        ];
                }
              }), /* [] */0, row.row_fields);
        if (match$2) {
          return List.fold_left((function (p_res, pat) {
                        return make_pat(/* Tpat_or */Block.__(8, [
                                      pat,
                                      p_res,
                                      void 0
                                    ]), p.pat_type, p.pat_env);
                      }), match$2[0], match$2[1]);
        } else {
          return make_other_pat("AnyExtraTag", true);
        }
    case /* Tpat_array */7 :
        var all_lengths = List.map((function (param) {
                var match = param[0].pat_desc;
                if (typeof match === "number") {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        /* tuple */[
                          "parmatch.ml",
                          893,
                          15
                        ]
                      ];
                }
                if (match.tag === /* Tpat_array */7) {
                  return List.length(match[0]);
                }
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      /* tuple */[
                        "parmatch.ml",
                        893,
                        15
                      ]
                    ];
              }), env);
        var _l = 0;
        while(true) {
          var l = _l;
          if (!List.mem(l, all_lengths)) {
            return make_pat(/* Tpat_array */Block.__(7, [omegas(l)]), p.pat_type, p.pat_env);
          }
          _l = l + 1 | 0;
          continue ;
        };
    default:
      return omega;
  }
}

function build_other_gadt(ext, env) {
  if (env) {
    var p = env[0][0];
    var tmp = p.pat_desc;
    if (typeof tmp !== "number" && tmp.tag === /* Tpat_construct */4) {
      var all_tags = List.map((function (param) {
              var param$1 = param[0];
              var match = param$1.pat_desc;
              if (typeof match === "number" || match.tag !== /* Tpat_construct */4) {
                return fatal_error("Parmatch.get_tag");
              } else {
                return match[1].cstr_tag;
              }
            }), env);
      var cnstrs = complete_constrs(p, all_tags);
      return List.map((function (param) {
                    return pat_of_constr(p, param);
                  }), cnstrs);
    }
    
  }
  throw [
        Caml_builtin_exceptions.assert_failure,
        /* tuple */[
          "parmatch.ml",
          917,
          11
        ]
      ];
}

function has_instance(_p) {
  while(true) {
    var p = _p;
    var match = p.pat_desc;
    if (typeof match === "number") {
      return true;
    }
    switch (match.tag | 0) {
      case /* Tpat_construct */4 :
          return has_instances(match[2]);
      case /* Tpat_variant */5 :
          var match$1 = match[1];
          if (is_absent(match[0], match[2])) {
            return false;
          }
          if (match$1 === void 0) {
            return true;
          }
          _p = match$1;
          continue ;
      case /* Tpat_record */6 :
          return has_instances(List.map((function (param) {
                            return param[2];
                          }), match[0]));
      case /* Tpat_tuple */3 :
      case /* Tpat_array */7 :
          return has_instances(match[0]);
      case /* Tpat_or */8 :
          if (has_instance(match[0])) {
            return true;
          }
          _p = match[1];
          continue ;
      case /* Tpat_alias */1 :
      case /* Tpat_lazy */9 :
          _p = match[0];
          continue ;
      default:
        return true;
    }
  };
}

function has_instances(_param) {
  while(true) {
    var param = _param;
    if (!param) {
      return true;
    }
    if (!has_instance(param[0])) {
      return false;
    }
    _param = param[1];
    continue ;
  };
}

function satisfiable(_pss, _qs) {
  while(true) {
    var qs = _qs;
    var pss = _pss;
    if (!pss) {
      return has_instances(qs);
    }
    if (!qs) {
      return false;
    }
    var q = qs[0];
    var match = q.pat_desc;
    var exit = 0;
    if (typeof match === "number") {
      exit = 1;
    } else {
      switch (match.tag | 0) {
        case /* Tpat_var */0 :
            exit = 1;
            break;
        case /* Tpat_alias */1 :
            _qs = /* :: */[
              match[0],
              qs[1]
            ];
            continue ;
        case /* Tpat_variant */5 :
            if (is_absent(match[0], match[2])) {
              return false;
            }
            exit = 2;
            break;
        case /* Tpat_or */8 :
            var qs$1 = qs[1];
            if (satisfiable(pss, /* :: */[
                    match[0],
                    qs$1
                  ])) {
              return true;
            }
            _qs = /* :: */[
              match[1],
              qs$1
            ];
            continue ;
        default:
          exit = 2;
      }
    }
    switch (exit) {
      case 1 :
          var qs$2 = qs[1];
          var q0 = discr_pat(omega, pss);
          var constrs = filter_all(q0, pss);
          if (constrs) {
            if (full_match(false, false, constrs)) {
              return List.exists((function(qs$2){
                        return function (param) {
                          var p = param[0];
                          if (is_absent_pat(p)) {
                            return false;
                          } else {
                            return satisfiable(param[1], Pervasives.$at(simple_match_args(p, omega), qs$2));
                          }
                        }
                        }(qs$2)), constrs);
            }
            _qs = qs$2;
            _pss = filter_extra(pss);
            continue ;
          } else {
            _qs = qs$2;
            _pss = filter_extra(pss);
            continue ;
          }
      case 2 :
          var q0$1 = discr_pat(q, pss);
          _qs = Pervasives.$at(simple_match_args(q0$1, q), qs[1]);
          _pss = filter_one(q0$1, pss);
          continue ;
      
    }
  };
}

function orify_many(param) {
  if (!param) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "parmatch.ml",
            989,
            12
          ]
        ];
  }
  var xs = param[1];
  var x = param[0];
  if (xs) {
    var y = Curry._1(orify_many, xs);
    return make_pat(/* Tpat_or */Block.__(8, [
                  x,
                  y,
                  void 0
                ]), x.pat_type, x.pat_env);
  } else {
    return x;
  }
}

function try_many_gadt(f, param) {
  if (!param) {
    return /* Rnone */0;
  }
  var match = param[0];
  var r1 = Curry._1(f, /* tuple */[
        match[0],
        match[1]
      ]);
  var r2 = try_many_gadt(f, param[1]);
  if (r1) {
    if (r2) {
      return /* Rsome */[Pervasives.$at(r1[0], r2[0])];
    } else {
      return r1;
    }
  } else {
    return r2;
  }
}

function exhaust(ext, pss, n) {
  if (!pss) {
    return /* Rsome */[omegas(n)];
  }
  if (!pss[0]) {
    return /* Rnone */0;
  }
  var q0 = discr_pat(omega, pss);
  var constrs = filter_all(q0, pss);
  if (constrs) {
    var try_non_omega = function (param) {
      var p = param[0];
      if (is_absent_pat(p)) {
        return /* Rnone */0;
      }
      var r = exhaust(ext, param[1], (List.length(simple_match_args(p, omega)) + n | 0) - 1 | 0);
      if (r) {
        return /* Rsome */[do_set_args(false, p, r[0])];
      } else {
        return r;
      }
    };
    if (full_match(true, false, constrs) && !should_extend(ext, constrs)) {
      var _param = constrs;
      while(true) {
        var param = _param;
        if (!param) {
          return /* Rnone */0;
        }
        var match = param[0];
        var r = Curry._1(try_non_omega, /* tuple */[
              match[0],
              match[1]
            ]);
        if (r) {
          return r;
        }
        _param = param[1];
        continue ;
      };
    }
    var r$1 = exhaust(ext, filter_extra(pss), n - 1 | 0);
    if (!r$1) {
      return /* Rnone */0;
    }
    try {
      return /* Rsome */[/* :: */[
                build_other(ext, constrs),
                r$1[0]
              ]];
    }
    catch (exn){
      if (exn === Empty) {
        return fatal_error("Parmatch.exhaust");
      }
      throw exn;
    }
  } else {
    var r$2 = exhaust(ext, filter_extra(pss), n - 1 | 0);
    if (r$2) {
      return /* Rsome */[/* :: */[
                q0,
                r$2[0]
              ]];
    } else {
      return r$2;
    }
  }
}

function combinations(f, lst, lst$prime) {
  var iter2 = function (x, param) {
    if (param) {
      return /* :: */[
              Curry._2(f, x, param[0]),
              iter2(x, param[1])
            ];
    } else {
      return /* [] */0;
    }
  };
  var iter = function (param) {
    if (param) {
      return Pervasives.$at(iter2(param[0], lst$prime), iter(param[1]));
    } else {
      return /* [] */0;
    }
  };
  return iter(lst);
}

function exhaust_gadt(ext, pss, n) {
  if (!pss) {
    return /* Rsome */[/* :: */[
              omegas(n),
              /* [] */0
            ]];
  }
  if (!pss[0]) {
    return /* Rnone */0;
  }
  var q0 = discr_pat(omega, pss);
  var constrs = filter_all(q0, pss);
  if (constrs) {
    var try_non_omega = function (param) {
      var p = param[0];
      if (is_absent_pat(p)) {
        return /* Rnone */0;
      }
      var r = exhaust_gadt(ext, param[1], (List.length(simple_match_args(p, omega)) + n | 0) - 1 | 0);
      if (r) {
        return /* Rsome */[List.map((function (row) {
                        return do_set_args(false, p, row);
                      }), r[0])];
      } else {
        return r;
      }
    };
    var before = try_many_gadt(try_non_omega, constrs);
    if (full_match_gadt(constrs) && !should_extend(ext, constrs)) {
      return before;
    }
    var r = exhaust_gadt(ext, filter_extra(pss), n - 1 | 0);
    if (!r) {
      return before;
    }
    try {
      var missing_trailing = build_other_gadt(ext, constrs);
      var dug = combinations((function (head, tail) {
              return /* :: */[
                      head,
                      tail
                    ];
            }), missing_trailing, r[0]);
      if (before) {
        return /* Rsome */[Pervasives.$at(before[0], dug)];
      } else {
        return /* Rsome */[dug];
      }
    }
    catch (exn){
      if (exn === Empty) {
        return fatal_error("Parmatch.exhaust");
      }
      throw exn;
    }
  } else {
    var r$1 = exhaust_gadt(ext, filter_extra(pss), n - 1 | 0);
    if (r$1) {
      return /* Rsome */[List.map((function (row) {
                      return /* :: */[
                              q0,
                              row
                            ];
                    }), r$1[0])];
    } else {
      return r$1;
    }
  }
}

function exhaust_gadt$1(ext, pss, n) {
  var ret = exhaust_gadt(ext, pss, n);
  if (!ret) {
    return /* Rnone */0;
  }
  var lst = ret[0];
  if (lst === /* [] */0) {
    return /* Rsome */[omegas(n)];
  }
  var singletons = List.map((function (param) {
          if (!param) {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  /* tuple */[
                    "parmatch.ml",
                    1165,
                    19
                  ]
                ];
          }
          if (param[1]) {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  /* tuple */[
                    "parmatch.ml",
                    1165,
                    19
                  ]
                ];
          }
          return param[0];
        }), lst);
  return /* Rsome */[/* :: */[
            Curry._1(orify_many, singletons),
            /* [] */0
          ]];
}

function pressure_variants(_tdefs, _pss) {
  while(true) {
    var pss = _pss;
    var tdefs = _tdefs;
    if (!pss) {
      return false;
    }
    if (!pss[0]) {
      return true;
    }
    var q0 = discr_pat(omega, pss);
    var constrs = filter_all(q0, pss);
    if (constrs) {
      var try_non_omega = (function(tdefs){
      return function try_non_omega(param) {
        if (!param) {
          return true;
        }
        var ok = pressure_variants(tdefs, param[0][1]);
        if (try_non_omega(param[1])) {
          return ok;
        } else {
          return false;
        }
      }
      }(tdefs));
      if (full_match(true, tdefs === void 0, constrs)) {
        return try_non_omega(constrs);
      }
      if (tdefs === void 0) {
        _pss = filter_extra(pss);
        _tdefs = void 0;
        continue ;
      } else {
        var full = full_match(true, true, constrs);
        var ok = full ? try_non_omega(constrs) : try_non_omega(filter_all(q0, mark_partial(pss)));
        if (constrs) {
          var p = constrs[0][0];
          var tmp = p.pat_desc;
          if (typeof tmp !== "number" && tmp.tag === /* Tpat_variant */5 && tdefs !== void 0) {
            var row = row_of_pat(p);
            if (row_fixed(row) || pressure_variants(void 0, filter_extra(pss))) {
              
            } else {
              close_variant(Caml_option.valFromOption(tdefs), row);
            }
          }
          
        }
        return ok;
      }
    } else {
      _pss = filter_extra(pss);
      continue ;
    }
  };
}

function make_row(ps) {
  return {
          no_ors: /* [] */0,
          ors: /* [] */0,
          active: ps
        };
}

function unalias$1(_p) {
  while(true) {
    var p = _p;
    var match = p.pat_desc;
    if (typeof match === "number") {
      return p;
    }
    if (match.tag !== /* Tpat_alias */1) {
      return p;
    }
    _p = match[0];
    continue ;
  };
}

function is_var_column(rs) {
  return List.for_all((function (r) {
                var match = r.active;
                if (match) {
                  var p = match[0];
                  var match$1 = unalias$1(p).pat_desc;
                  if (typeof match$1 === "number" || !match$1.tag) {
                    return true;
                  } else {
                    return false;
                  }
                }
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      /* tuple */[
                        "parmatch.ml",
                        1274,
                        14
                      ]
                    ];
              }), rs);
}

function or_args(_p) {
  while(true) {
    var p = _p;
    var match = p.pat_desc;
    if (typeof match === "number") {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "parmatch.ml",
              1281,
              23
            ]
          ];
    }
    switch (match.tag | 0) {
      case /* Tpat_alias */1 :
          _p = match[0];
          continue ;
      case /* Tpat_or */8 :
          return /* tuple */[
                  match[0],
                  match[1]
                ];
      default:
        throw [
              Caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "parmatch.ml",
                1281,
                23
              ]
            ];
    }
  };
}

function remove(r) {
  var match = r.active;
  if (match) {
    return {
            no_ors: r.no_ors,
            ors: r.ors,
            active: match[1]
          };
  }
  throw [
        Caml_builtin_exceptions.assert_failure,
        /* tuple */[
          "parmatch.ml",
          1286,
          12
        ]
      ];
}

function push_no_or(r) {
  var match = r.active;
  if (match) {
    return {
            no_ors: /* :: */[
              match[0],
              r.no_ors
            ],
            ors: r.ors,
            active: match[1]
          };
  }
  throw [
        Caml_builtin_exceptions.assert_failure,
        /* tuple */[
          "parmatch.ml",
          1293,
          8
        ]
      ];
}

function push_or(r) {
  var match = r.active;
  if (match) {
    return {
            no_ors: r.no_ors,
            ors: /* :: */[
              match[0],
              r.ors
            ],
            active: match[1]
          };
  }
  throw [
        Caml_builtin_exceptions.assert_failure,
        /* tuple */[
          "parmatch.ml",
          1297,
          8
        ]
      ];
}

function discr_pat$1(q, rs) {
  return discr_pat(q, List.map((function (r) {
                    return r.active;
                  }), rs));
}

function filter_one$1(q, rs) {
  var filter_rec = function (_rs) {
    while(true) {
      var rs = _rs;
      if (!rs) {
        return /* [] */0;
      }
      var rem = rs[1];
      var r = rs[0];
      var match = r.active;
      if (!match) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "parmatch.ml",
                1314,
                14
              ]
            ];
      }
      var p = match[0];
      var match$1 = p.pat_desc;
      if (typeof match$1 !== "number") {
        switch (match$1.tag | 0) {
          case /* Tpat_alias */1 :
              _rs = /* :: */[
                {
                  no_ors: r.no_ors,
                  ors: r.ors,
                  active: /* :: */[
                    match$1[0],
                    match[1]
                  ]
                },
                rem
              ];
              continue ;
          case /* Tpat_or */8 :
              var ps = match[1];
              _rs = /* :: */[
                {
                  no_ors: r.no_ors,
                  ors: r.ors,
                  active: /* :: */[
                    match$1[0],
                    ps
                  ]
                },
                /* :: */[
                  {
                    no_ors: r.no_ors,
                    ors: r.ors,
                    active: /* :: */[
                      match$1[1],
                      ps
                    ]
                  },
                  rem
                ]
              ];
              continue ;
          default:
            
        }
      }
      if (simple_match(q, p)) {
        return /* :: */[
                {
                  no_ors: r.no_ors,
                  ors: r.ors,
                  active: Pervasives.$at(simple_match_args(q, p), match[1])
                },
                filter_rec(rem)
              ];
      }
      _rs = rem;
      continue ;
    };
  };
  return filter_rec(rs);
}

function make_vector(r) {
  return r.no_ors;
}

function extract_elements(qs) {
  var do_rec = function (seen, param) {
    if (!param) {
      return /* [] */0;
    }
    var rem = param[1];
    var q = param[0];
    return /* :: */[
            {
              no_ors: Pervasives.$at(List.rev_append(seen, rem), qs.no_ors),
              ors: /* [] */0,
              active: /* :: */[
                q,
                /* [] */0
              ]
            },
            do_rec(/* :: */[
                  q,
                  seen
                ], rem)
          ];
  };
  return do_rec(/* [] */0, qs.ors);
}

function extract_columns(pss, qs) {
  if (pss) {
    var rs = List.map(extract_elements, pss);
    if (!rs) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "parmatch.ml",
              1357,
              8
            ]
          ];
    }
    var i = List.map((function (x) {
            return /* :: */[
                    x,
                    /* [] */0
                  ];
          }), rs[0]);
    return List.fold_left((function (param, param$1) {
                  return List.map2((function (r, x) {
                                return /* :: */[
                                        x,
                                        r
                                      ];
                              }), param, param$1);
                }), i, rs[1]);
  } else {
    return List.map((function (param) {
                  return /* [] */0;
                }), qs.ors);
  }
}

function every_satisfiables(_pss, _qs) {
  while(true) {
    var qs = _qs;
    var pss = _pss;
    var match = qs.active;
    if (match) {
      var q = match[0];
      var uq = unalias$1(q);
      var match$1 = uq.pat_desc;
      var exit = 0;
      if (typeof match$1 === "number") {
        exit = 2;
      } else {
        switch (match$1.tag | 0) {
          case /* Tpat_var */0 :
              exit = 2;
              break;
          case /* Tpat_variant */5 :
              if (is_absent(match$1[0], match$1[2])) {
                return /* Unused */1;
              }
              exit = 1;
              break;
          case /* Tpat_or */8 :
              if (match$1[0].pat_loc.loc_ghost && match$1[1].pat_loc.loc_ghost) {
                _qs = push_no_or(qs);
                _pss = List.map(push_no_or, pss);
                continue ;
              } else {
                _qs = push_or(qs);
                _pss = List.map(push_or, pss);
                continue ;
              }
          default:
            exit = 1;
        }
      }
      switch (exit) {
        case 1 :
            var q0 = discr_pat$1(q, pss);
            _qs = {
              no_ors: qs.no_ors,
              ors: qs.ors,
              active: Pervasives.$at(simple_match_args(q0, q), match[1])
            };
            _pss = filter_one$1(q0, pss);
            continue ;
        case 2 :
            if (is_var_column(pss)) {
              _qs = remove(qs);
              _pss = List.map(remove, pss);
              continue ;
            } else {
              _qs = push_no_or(qs);
              _pss = List.map(push_no_or, pss);
              continue ;
            }
        
      }
    } else {
      var match$2 = qs.ors;
      if (match$2) {
        return List.fold_right2((function (pss, qs, r) {
                      if (typeof r === "number" && r !== 0) {
                        return /* Unused */1;
                      }
                      var match = qs.active;
                      if (!match) {
                        throw [
                              Caml_builtin_exceptions.assert_failure,
                              /* tuple */[
                                "parmatch.ml",
                                1394,
                                23
                              ]
                            ];
                      }
                      if (match[1]) {
                        throw [
                              Caml_builtin_exceptions.assert_failure,
                              /* tuple */[
                                "parmatch.ml",
                                1394,
                                23
                              ]
                            ];
                      }
                      var match$1 = or_args(match[0]);
                      var r_loc = every_both(pss, qs, match$1[0], match$1[1]);
                      if (typeof r === "number") {
                        if (r !== 0) {
                          return /* Unused */1;
                        }
                        
                      } else {
                        if (typeof r_loc !== "number") {
                          return /* Upartial */[Pervasives.$at(r[0], r_loc[0])];
                        }
                        if (r_loc === 0) {
                          return r;
                        }
                        
                      }
                      if (typeof r_loc === "number" && r_loc !== 0) {
                        return /* Unused */1;
                      } else {
                        return r_loc;
                      }
                    }), extract_columns(pss, qs), extract_elements(qs), /* Used */0);
      } else if (satisfiable(List.map(make_vector, pss), qs.no_ors)) {
        return /* Used */0;
      } else {
        return /* Unused */1;
      }
    }
  };
}

function every_both(pss, qs, q1, q2) {
  var qs1_no_ors = qs.no_ors;
  var qs1_ors = qs.ors;
  var qs1_active = /* :: */[
    q1,
    /* [] */0
  ];
  var qs1 = {
    no_ors: qs1_no_ors,
    ors: qs1_ors,
    active: qs1_active
  };
  var qs2_no_ors = qs.no_ors;
  var qs2_ors = qs.ors;
  var qs2_active = /* :: */[
    q2,
    /* [] */0
  ];
  var qs2 = {
    no_ors: qs2_no_ors,
    ors: qs2_ors,
    active: qs2_active
  };
  var r1 = every_satisfiables(pss, qs1);
  var r2 = every_satisfiables(compat(q1, q2) ? /* :: */[
          qs1,
          pss
        ] : pss, qs2);
  if (typeof r1 === "number") {
    if (r1 !== 0) {
      if (typeof r2 === "number") {
        if (r2 !== 0) {
          return /* Unused */1;
        } else {
          return /* Upartial */[/* :: */[
                    q1,
                    /* [] */0
                  ]];
        }
      } else {
        return /* Upartial */[/* :: */[
                  q1,
                  r2[0]
                ]];
      }
    } else if (typeof r2 === "number" && r2 !== 0) {
      return /* Upartial */[/* :: */[
                q2,
                /* [] */0
              ]];
    } else {
      return r2;
    }
  }
  var u1 = r1[0];
  if (typeof r2 === "number") {
    if (r2 !== 0) {
      return /* Upartial */[Pervasives.$at(u1, /* :: */[
                    q2,
                    /* [] */0
                  ])];
    } else {
      return r1;
    }
  } else {
    return /* Upartial */[Pervasives.$at(u1, r2[0])];
  }
}

function le_pat(_p, _q) {
  while(true) {
    var q = _q;
    var p = _p;
    var match = p.pat_desc;
    var match$1 = q.pat_desc;
    var exit = 0;
    if (typeof match === "number") {
      return true;
    }
    switch (match.tag | 0) {
      case /* Tpat_var */0 :
          return true;
      case /* Tpat_alias */1 :
          _p = match[0];
          continue ;
      case /* Tpat_constant */2 :
          if (typeof match$1 !== "number") {
            switch (match$1.tag | 0) {
              case /* Tpat_alias */1 :
                  exit = 2;
                  break;
              case /* Tpat_constant */2 :
                  return const_compare(match[0], match$1[0]) === 0;
              default:
                
            }
          }
          break;
      case /* Tpat_tuple */3 :
          if (typeof match$1 !== "number") {
            switch (match$1.tag | 0) {
              case /* Tpat_alias */1 :
                  exit = 2;
                  break;
              case /* Tpat_tuple */3 :
                  return le_pats(match[0], match$1[0]);
              default:
                
            }
          }
          break;
      case /* Tpat_construct */4 :
          if (typeof match$1 !== "number") {
            switch (match$1.tag | 0) {
              case /* Tpat_alias */1 :
                  exit = 2;
                  break;
              case /* Tpat_construct */4 :
                  if (equal_tag(match[1].cstr_tag, match$1[1].cstr_tag)) {
                    return le_pats(match[2], match$1[2]);
                  } else {
                    return false;
                  }
              default:
                
            }
          }
          break;
      case /* Tpat_variant */5 :
          var match$2 = match[1];
          var l1 = match[0];
          if (match$2 !== void 0) {
            if (typeof match$1 !== "number") {
              switch (match$1.tag | 0) {
                case /* Tpat_alias */1 :
                    exit = 2;
                    break;
                case /* Tpat_variant */5 :
                    var match$3 = match$1[1];
                    if (match$3 === void 0) {
                      return false;
                    }
                    if (l1 !== match$1[0]) {
                      return false;
                    }
                    _q = match$3;
                    _p = match$2;
                    continue ;
                default:
                  
              }
            }
            
          } else if (typeof match$1 !== "number") {
            switch (match$1.tag | 0) {
              case /* Tpat_alias */1 :
                  exit = 2;
                  break;
              case /* Tpat_variant */5 :
                  if (match$1[1] !== void 0) {
                    return false;
                  } else {
                    return l1 === match$1[0];
                  }
              default:
                
            }
          }
          break;
      case /* Tpat_record */6 :
          if (typeof match$1 !== "number") {
            switch (match$1.tag | 0) {
              case /* Tpat_alias */1 :
                  exit = 2;
                  break;
              case /* Tpat_record */6 :
                  var match$4 = records_args(match[0], match$1[0]);
                  return le_pats(match$4[0], match$4[1]);
              default:
                
            }
          }
          break;
      case /* Tpat_array */7 :
          var ps = match[0];
          if (typeof match$1 !== "number") {
            switch (match$1.tag | 0) {
              case /* Tpat_alias */1 :
                  exit = 2;
                  break;
              case /* Tpat_array */7 :
                  var qs = match$1[0];
                  if (List.length(ps) === List.length(qs)) {
                    return le_pats(ps, qs);
                  } else {
                    return false;
                  }
              default:
                
            }
          }
          break;
      case /* Tpat_or */8 :
          exit = 2;
          break;
      case /* Tpat_lazy */9 :
          if (typeof match$1 !== "number") {
            switch (match$1.tag | 0) {
              case /* Tpat_alias */1 :
                  exit = 2;
                  break;
              case /* Tpat_lazy */9 :
                  _q = match$1[0];
                  _p = match[0];
                  continue ;
              default:
                
            }
          }
          break;
      
    }
    if (exit === 2 && typeof match$1 !== "number" && match$1.tag === /* Tpat_alias */1) {
      _q = match$1[0];
      continue ;
    }
    return !satisfiable(/* :: */[
                /* :: */[
                  p,
                  /* [] */0
                ],
                /* [] */0
              ], /* :: */[
                q,
                /* [] */0
              ]);
  };
}

function le_pats(_ps, _qs) {
  while(true) {
    var qs = _qs;
    var ps = _ps;
    if (!ps) {
      return true;
    }
    if (!qs) {
      return true;
    }
    if (!le_pat(ps[0], qs[0])) {
      return false;
    }
    _qs = qs[1];
    _ps = ps[1];
    continue ;
  };
}

function get_mins(le, ps) {
  var select_rec = function (_r, _param) {
    while(true) {
      var param = _param;
      var r = _r;
      if (!param) {
        return r;
      }
      var ps = param[1];
      var p = param[0];
      if (List.exists((function(p){
            return function (p0) {
              return Curry._2(le, p0, p);
            }
            }(p)), ps)) {
        _param = ps;
        continue ;
      } else {
        _param = ps;
        _r = /* :: */[
          p,
          r
        ];
        continue ;
      }
    };
  };
  return select_rec(/* [] */0, select_rec(/* [] */0, ps));
}

function pressure_variants$1(tdefs, patl) {
  var pss = List.map((function (p) {
          return /* :: */[
                  p,
                  /* :: */[
                    omega,
                    /* [] */0
                  ]
                ];
        }), patl);
  pressure_variants(Caml_option.some(tdefs), pss);
  
}

function initial_matrix(_param) {
  while(true) {
    var param = _param;
    if (!param) {
      return /* [] */0;
    }
    var match = param[0];
    if (match.c_guard === void 0) {
      return /* :: */[
              /* :: */[
                match.c_lhs,
                /* [] */0
              ],
              initial_matrix(param[1])
            ];
    }
    _param = param[1];
    continue ;
  };
}

var NoGuard = Caml_exceptions.create("Ocaml_typedtree_test.Parmatch.NoGuard");

function initial_all(no_guard, param) {
  if (param) {
    var match = param[0];
    var pat = match.c_lhs;
    return /* :: */[
            /* tuple */[
              /* :: */[
                pat,
                /* [] */0
              ],
              pat.pat_loc
            ],
            initial_all(no_guard && match.c_guard === void 0, param[1])
          ];
  } else {
    if (no_guard) {
      throw NoGuard;
    }
    return /* [] */0;
  }
}

function do_filter_var(param) {
  if (!param) {
    return /* [] */0;
  }
  var match = param[0];
  var match$1 = match[0];
  if (match$1) {
    return /* :: */[
            /* tuple */[
              match$1[1],
              match[1]
            ],
            do_filter_var(param[1])
          ];
  } else {
    return /* [] */0;
  }
}

function do_filter_one(q, pss) {
  var filter_rec = function (_param) {
    while(true) {
      var param = _param;
      if (!param) {
        return /* [] */0;
      }
      var match = param[0];
      var match$1 = match[0];
      if (!match$1) {
        return /* [] */0;
      }
      var p = match$1[0];
      var match$2 = p.pat_desc;
      if (typeof match$2 !== "number") {
        switch (match$2.tag | 0) {
          case /* Tpat_alias */1 :
              _param = /* :: */[
                /* tuple */[
                  /* :: */[
                    match$2[0],
                    match$1[1]
                  ],
                  match[1]
                ],
                param[1]
              ];
              continue ;
          case /* Tpat_or */8 :
              var loc = match[1];
              var ps = match$1[1];
              _param = /* :: */[
                /* tuple */[
                  /* :: */[
                    match$2[0],
                    ps
                  ],
                  loc
                ],
                /* :: */[
                  /* tuple */[
                    /* :: */[
                      match$2[1],
                      ps
                    ],
                    loc
                  ],
                  param[1]
                ]
              ];
              continue ;
          default:
            
        }
      }
      var pss = param[1];
      if (simple_match(q, p)) {
        return /* :: */[
                /* tuple */[
                  Pervasives.$at(simple_match_args(q, p), match$1[1]),
                  match[1]
                ],
                filter_rec(pss)
              ];
      }
      _param = pss;
      continue ;
    };
  };
  return filter_rec(pss);
}

function do_match(_pss, _qs) {
  while(true) {
    var qs = _qs;
    var pss = _pss;
    if (qs) {
      var q = qs[0];
      var match = q.pat_desc;
      var qs$1 = qs[1];
      if (typeof match === "number") {
        _qs = qs$1;
        _pss = do_filter_var(pss);
        continue ;
      } else if (match.tag === /* Tpat_or */8) {
        var r = do_match(pss, /* :: */[
              match[0],
              qs$1
            ]);
        if (r !== void 0) {
          return r;
        }
        _qs = /* :: */[
          match[1],
          qs$1
        ];
        continue ;
      } else {
        var q0 = normalize_pat(q);
        _qs = Pervasives.$at(simple_match_args(q0, q), qs$1);
        _pss = do_filter_one(q0, pss);
        continue ;
      }
    } else {
      if (!pss) {
        return ;
      }
      var match$1 = pss[0];
      if (match$1[0]) {
        return ;
      } else {
        return Caml_option.some(match$1[1]);
      }
    }
  };
}

function check_partial_all(v, casel) {
  try {
    var pss = initial_all(true, casel);
    return do_match(pss, /* :: */[
                v,
                /* [] */0
              ]);
  }
  catch (exn){
    if (exn === NoGuard) {
      return ;
    }
    throw exn;
  }
}

function get_first(f, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return ;
    }
    var x = Curry._1(f, param[0]);
    if (x !== void 0) {
      return x;
    }
    _param = param[1];
    continue ;
  };
}

function select(param) {
  if (!param) {
    return /* [] */0;
  }
  var xs = param[0];
  if (!param[1]) {
    return List.map((function (y) {
                  return /* :: */[
                          y,
                          /* [] */0
                        ];
                }), xs);
  }
  if (!xs) {
    return /* [] */0;
  }
  var ys = param[1];
  var x = xs[0];
  return Pervasives.$at(List.map((function (lst) {
                    return /* :: */[
                            x,
                            lst
                          ];
                  }), select(ys)), select(/* :: */[
                  xs[1],
                  ys
                ]));
}

var name_counter$1 = {
  contents: 0
};

function fresh(name) {
  var current = name_counter$1.contents;
  name_counter$1.contents = name_counter$1.contents + 1 | 0;
  return "#$" + (name + String(current));
}

function conv(typed) {
  var constrs = Hashtbl.create(void 0, 0);
  var labels = Hashtbl.create(void 0, 0);
  var loop = function (_pat) {
    while(true) {
      var pat = _pat;
      var match = pat.pat_desc;
      if (typeof match === "number") {
        return /* :: */[
                mk$1(void 0, void 0, /* Ppat_any */0),
                /* [] */0
              ];
      }
      switch (match.tag | 0) {
        case /* Tpat_alias */1 :
            _pat = match[0];
            continue ;
        case /* Tpat_tuple */3 :
            var results = select(List.map(loop, match[0]));
            return List.map((function (lst) {
                          return mk$1(void 0, void 0, /* Ppat_tuple */Block.__(4, [lst]));
                        }), results);
        case /* Tpat_construct */4 :
            var lst = match[2];
            var cstr = match[1];
            var id = fresh(cstr.cstr_name);
            var lid_txt = /* Lident */Block.__(0, [id]);
            var lid_loc = match[0].loc;
            var lid = {
              txt: lid_txt,
              loc: lid_loc
            };
            Hashtbl.add(constrs, id, cstr);
            var results$1 = select(List.map(loop, lst));
            if (lst) {
              return List.map((function(lid){
                        return function (lst) {
                          var arg;
                          if (!lst) {
                            throw [
                                  Caml_builtin_exceptions.assert_failure,
                                  /* tuple */[
                                    "parmatch.ml",
                                    1729,
                                    28
                                  ]
                                ];
                          }
                          arg = lst[1] ? mk$1(void 0, void 0, /* Ppat_tuple */Block.__(4, [lst])) : lst[0];
                          return mk$1(void 0, void 0, /* Ppat_construct */Block.__(5, [
                                        lid,
                                        arg
                                      ]));
                        }
                        }(lid)), results$1);
            } else {
              return /* :: */[
                      mk$1(void 0, void 0, /* Ppat_construct */Block.__(5, [
                              lid,
                              void 0
                            ])),
                      /* [] */0
                    ];
            }
        case /* Tpat_variant */5 :
            var p_opt = match[1];
            var label = match[0];
            if (p_opt === void 0) {
              return /* :: */[
                      mk$1(void 0, void 0, /* Ppat_variant */Block.__(6, [
                              label,
                              void 0
                            ])),
                      /* [] */0
                    ];
            }
            var results$2 = loop(p_opt);
            return List.map((function(label){
                      return function (p) {
                        return mk$1(void 0, void 0, /* Ppat_variant */Block.__(6, [
                                      label,
                                      p
                                    ]));
                      }
                      }(label)), results$2);
        case /* Tpat_record */6 :
            var subpatterns = match[0];
            var pats = select(List.map((function (param) {
                        return loop(param[2]);
                      }), subpatterns));
            var label_idents = List.map((function (param) {
                    var lbl = param[1];
                    var id = fresh(lbl.lbl_name);
                    Hashtbl.add(labels, id, lbl);
                    return /* Lident */Block.__(0, [id]);
                  }), subpatterns);
            return List.map((function(label_idents){
                      return function (lst) {
                        var lst$1 = List.map2((function (lid, pat) {
                                return /* tuple */[
                                        {
                                          txt: lid,
                                          loc: none
                                        },
                                        pat
                                      ];
                              }), label_idents, lst);
                        return mk$1(void 0, void 0, /* Ppat_record */Block.__(7, [
                                      lst$1,
                                      /* Open */1
                                    ]));
                      }
                      }(label_idents)), pats);
        case /* Tpat_array */7 :
            var results$3 = select(List.map(loop, match[0]));
            return List.map((function (lst) {
                          return mk$1(void 0, void 0, /* Ppat_array */Block.__(8, [lst]));
                        }), results$3);
        case /* Tpat_or */8 :
            return Pervasives.$at(loop(match[0]), loop(match[1]));
        case /* Tpat_lazy */9 :
            var results$4 = loop(match[0]);
            return List.map((function (p) {
                          return mk$1(void 0, void 0, /* Ppat_lazy */Block.__(12, [p]));
                        }), results$4);
        default:
          return /* :: */[
                  mk$1(void 0, void 0, /* Ppat_any */0),
                  /* [] */0
                ];
      }
    };
  };
  var ps = loop(typed);
  return /* tuple */[
          ps,
          constrs,
          labels
        ];
}

function do_check_partial(pred, exhaust, loc, casel, pss) {
  if (pss) {
    var match = Curry._3(exhaust, void 0, pss, List.length(pss[0]));
    if (!match) {
      return /* Total */1;
    }
    var match$1 = match[0];
    if (!match$1) {
      return fatal_error("Parmatch.check_partial");
    }
    if (match$1[1]) {
      return fatal_error("Parmatch.check_partial");
    }
    var u = match$1[0];
    var v;
    if (pred !== void 0) {
      var match$2 = conv(u);
      v = get_first(Curry._2(pred, match$2[1], match$2[2]), match$2[0]);
    } else {
      v = u;
    }
    if (v === void 0) {
      return /* Total */1;
    }
    var v$1 = v;
    var match$3 = v$1.pat_desc;
    var errmsg;
    var exit = 0;
    if (typeof match$3 === "number" || !(match$3.tag === /* Tpat_construct */4 && match$3[1].cstr_name === "*extension*")) {
      exit = 1;
    } else {
      errmsg = "_\nMatching over values of extensible variant types must include\na wild card pattern in order to be exhaustive.";
    }
    if (exit === 1) {
      try {
        var buf = $$Buffer.create(16);
        var fmt = Format.formatter_of_buffer(buf);
        top_pretty(fmt, v$1);
        var match$4 = check_partial_all(v$1, casel);
        if (match$4 !== void 0) {
          $$Buffer.add_string(buf, "\n(However, some guarded clause may match this value.)");
        }
        errmsg = $$Buffer.contents(buf);
      }
      catch (exn){
        errmsg = "";
      }
    }
    prerr_warning(loc, /* Partial_match */Block.__(3, [errmsg]));
    return /* Partial */0;
  } else {
    if (casel) {
      prerr_warning(loc, /* All_clauses_guarded */12);
    }
    return /* Partial */0;
  }
}

function do_check_partial_normal(loc, casel, pss) {
  return do_check_partial(void 0, exhaust, loc, casel, pss);
}

function add_path(path, paths) {
  if (!paths) {
    return /* :: */[
            path,
            /* [] */0
          ];
  }
  var x = paths[0];
  if (same(path, x)) {
    return paths;
  } else {
    return /* :: */[
            x,
            add_path(path, paths[1])
          ];
  }
}

function extendable_path(path) {
  return !(same(path, path_bool) || same(path, path_list) || same(path, path_unit) || same(path, path_option));
}

function collect_paths_from_pat(_r, _p) {
  while(true) {
    var p = _p;
    var r = _r;
    var match = p.pat_desc;
    if (typeof match === "number") {
      return r;
    }
    switch (match.tag | 0) {
      case /* Tpat_construct */4 :
          switch (match[1].cstr_tag.tag | 0) {
            case /* Cstr_constant */0 :
            case /* Cstr_block */1 :
                break;
            case /* Cstr_extension */2 :
                return List.fold_left(collect_paths_from_pat, r, match[2]);
            
          }
          var path = get_type_path(p.pat_type, p.pat_env);
          return List.fold_left(collect_paths_from_pat, extendable_path(path) ? add_path(path, r) : r, match[2]);
      case /* Tpat_variant */5 :
          var match$1 = match[1];
          if (match$1 === void 0) {
            return r;
          }
          _p = match$1;
          continue ;
      case /* Tpat_record */6 :
          return List.fold_left((function (r, param) {
                        return collect_paths_from_pat(r, param[2]);
                      }), r, match[0]);
      case /* Tpat_tuple */3 :
      case /* Tpat_array */7 :
          return List.fold_left(collect_paths_from_pat, r, match[0]);
      case /* Tpat_or */8 :
          _p = match[1];
          _r = collect_paths_from_pat(r, match[0]);
          continue ;
      case /* Tpat_alias */1 :
      case /* Tpat_lazy */9 :
          _p = match[0];
          continue ;
      default:
        return r;
    }
  };
}

function do_check_fragile_param(exhaust, loc, casel, pss) {
  var exts = List.fold_left((function (r, c) {
          return collect_paths_from_pat(r, c.c_lhs);
        }), /* [] */0, casel);
  if (!exts) {
    return ;
  }
  if (!pss) {
    return ;
  }
  var ps = pss[0];
  return List.iter((function (ext) {
                var match = Curry._3(exhaust, ext, pss, List.length(ps));
                if (match) {
                  return ;
                } else {
                  return prerr_warning(loc, /* Fragile_match */Block.__(1, [name(void 0, ext)]));
                }
              }), exts);
}

function do_check_fragile_normal(param, param$1, param$2) {
  return do_check_fragile_param(exhaust, param, param$1, param$2);
}

function do_check_fragile_gadt(param, param$1, param$2) {
  return do_check_fragile_param(exhaust_gadt$1, param, param$1, param$2);
}

function check_partial_param(do_check_partial, do_check_fragile, loc, casel) {
  if (!is_active(/* Partial_match */Block.__(3, [""]))) {
    return /* Partial */0;
  }
  var pss = initial_matrix(casel);
  var pss$1 = get_mins(le_pats, pss);
  var total = Curry._3(do_check_partial, loc, casel, pss$1);
  if (total === /* Total */1 && is_active(/* Fragile_match */Block.__(1, [""]))) {
    Curry._3(do_check_fragile, loc, casel, pss$1);
  }
  return total;
}

function check_partial(param, param$1) {
  return check_partial_param(do_check_partial_normal, do_check_fragile_normal, param, param$1);
}

var Already_bound = Caml_exceptions.create("Ocaml_typedtree_test.Typetexp.Already_bound");

var $$Error$6 = Caml_exceptions.create("Ocaml_typedtree_test.Typetexp.Error");

var Error_forward = Caml_exceptions.create("Ocaml_typedtree_test.Typetexp.Error_forward");

function string_of_payload(param) {
  switch (param.tag | 0) {
    case /* PStr */0 :
        var match = param[0];
        if (!match) {
          return ;
        }
        var match$1 = match[0].pstr_desc;
        if (match$1.tag) {
          return ;
        }
        var match$2 = match$1[0].pexp_desc;
        if (match$2.tag === /* Pexp_constant */1 && !match[1]) {
          var param$1 = match$2[0];
          if (param$1.tag === /* Const_string */2) {
            return param$1[0];
          } else {
            return ;
          }
        } else {
          return ;
        }
    case /* PTyp */1 :
    case /* PPat */2 :
        return ;
    
  }
}

function error_of_extension(ext) {
  var match = ext[0];
  var txt = match.txt;
  var exit = 0;
  switch (txt) {
    case "error" :
    case "ocaml.error" :
        exit = 1;
        break;
    default:
      return Curry._1(errorf(match.loc, void 0, void 0, /* Format */[
                      /* String_literal */Block.__(11, [
                          "Uninterpreted extension '",
                          /* String */Block.__(2, [
                              /* No_padding */0,
                              /* String_literal */Block.__(11, [
                                  "'.",
                                  /* End_of_format */0
                                ])
                            ])
                        ]),
                      "Uninterpreted extension '%s'."
                    ]), txt);
  }
  if (exit === 1) {
    var p = ext[1];
    var loc = match.loc;
    var sub_from = function (inner) {
      if (!inner) {
        return /* [] */0;
      }
      var match = inner[0].pstr_desc;
      if (match.tag === /* Pstr_extension */14) {
        return /* :: */[
                error_of_extension(match[0]),
                sub_from(inner[1])
              ];
      } else {
        return /* :: */[
                Curry._1(errorf(loc, void 0, void 0, /* Format */[
                          /* String_literal */Block.__(11, [
                              "Invalid syntax for sub-error of extension '",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* String_literal */Block.__(11, [
                                      "'.",
                                      /* End_of_format */0
                                    ])
                                ])
                            ]),
                          "Invalid syntax for sub-error of extension '%s'."
                        ]), txt),
                sub_from(inner[1])
              ];
      }
    };
    switch (p.tag | 0) {
      case /* PStr */0 :
          var match$1 = p[0];
          if (match$1) {
            var match$2 = match$1[0].pstr_desc;
            if (!match$2.tag) {
              var match$3 = match$2[0].pexp_desc;
              if (match$3.tag === /* Pexp_constant */1) {
                var match$4 = match$3[0];
                if (match$4.tag === /* Const_string */2) {
                  var inner = match$1[1];
                  var msg = match$4[0];
                  var exit$1 = 0;
                  if (inner) {
                    var match$5 = inner[0].pstr_desc;
                    if (match$5.tag) {
                      exit$1 = 3;
                    } else {
                      var match$6 = match$5[0].pexp_desc;
                      if (match$6.tag === /* Pexp_constant */1) {
                        var match$7 = match$6[0];
                        if (match$7.tag === /* Const_string */2) {
                          return error(loc, sub_from(inner[1]), match$7[0], msg);
                        }
                        exit$1 = 3;
                      } else {
                        exit$1 = 3;
                      }
                    }
                  } else {
                    exit$1 = 3;
                  }
                  if (exit$1 === 3) {
                    return error(loc, sub_from(inner), void 0, msg);
                  }
                  
                }
                
              }
              
            }
            
          }
          break;
      case /* PTyp */1 :
      case /* PPat */2 :
          break;
      
    }
    return Curry._1(errorf(loc, void 0, void 0, /* Format */[
                    /* String_literal */Block.__(11, [
                        "Invalid syntax for extension '",
                        /* String */Block.__(2, [
                            /* No_padding */0,
                            /* String_literal */Block.__(11, [
                                "'.",
                                /* End_of_format */0
                              ])
                          ])
                      ]),
                    "Invalid syntax for extension '%s'."
                  ]), txt);
  }
  
}

function check_deprecated(loc, attrs, s) {
  return List.iter((function (param) {
                switch (param[0].txt) {
                  case "deprecated" :
                  case "ocaml.deprecated" :
                      break;
                  default:
                    return ;
                }
                var match = string_of_payload(param[1]);
                if (match === void 0) {
                  return prerr_warning(loc, /* Deprecated */Block.__(0, [s]));
                }
                var txt = match;
                if (bs_vscode) {
                  return prerr_warning(loc, /* Deprecated */Block.__(0, [s + (" " + txt)]));
                } else {
                  return prerr_warning(loc, /* Deprecated */Block.__(0, [s + ("\n" + txt)]));
                }
              }), attrs);
}

var newrecord$1 = Caml_obj.caml_obj_dup(default_mapper);

newrecord$1.attribute = (function (param, a) {
    var exit = 0;
    switch (a[0].txt) {
      case "ocaml.ppwarning" :
      case "ppwarning" :
          exit = 1;
          break;
      default:
        
    }
    if (exit === 1) {
      var match = a[1];
      switch (match.tag | 0) {
        case /* PStr */0 :
            var match$1 = match[0];
            if (match$1) {
              var match$2 = match$1[0];
              var match$3 = match$2.pstr_desc;
              if (!match$3.tag) {
                var match$4 = match$3[0].pexp_desc;
                if (match$4.tag === /* Pexp_constant */1) {
                  var match$5 = match$4[0];
                  if (match$5.tag === /* Const_string */2) {
                    if (match$1[1]) {
                      
                    } else {
                      prerr_warning(match$2.pstr_loc, /* Preprocessor */Block.__(10, [match$5[0]]));
                    }
                  }
                  
                }
                
              }
              
            }
            break;
        case /* PTyp */1 :
        case /* PPat */2 :
            break;
        
      }
    }
    return a;
  });

var warning_scope = {
  contents: /* [] */0
};

function warning_enter_scope(param) {
  warning_scope.contents = /* :: */[
    current.contents,
    warning_scope.contents
  ];
  
}

function warning_leave_scope(param) {
  var match = warning_scope.contents;
  if (!match) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "typetexp.ml",
            146,
            10
          ]
        ];
  }
  current.contents = match[0];
  warning_scope.contents = match[1];
  
}

function warning_attribute(attrs) {
  var $$process = function (loc, txt, errflag, payload) {
    var match = string_of_payload(payload);
    if (match === void 0) {
      return prerr_warning(loc, /* Attribute_payload */Block.__(30, [
                    txt,
                    "A single string literal is expected"
                  ]));
    }
    try {
      return parse_options(errflag, match);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn[0] === Arg.Bad) {
        return prerr_warning(loc, /* Attribute_payload */Block.__(30, [
                      txt,
                      "Ill-formed list of warnings"
                    ]));
      }
      throw exn;
    }
  };
  return List.iter((function (param) {
                var match = param[0];
                var txt = match.txt;
                var exit = 0;
                switch (txt) {
                  case "ocaml.warnerror" :
                  case "warnerror" :
                      exit = 2;
                      break;
                  case "ocaml.warning" :
                  case "warning" :
                      exit = 1;
                      break;
                  default:
                    return ;
                }
                switch (exit) {
                  case 1 :
                      return $$process(match.loc, txt, false, param[1]);
                  case 2 :
                      return $$process(match.loc, txt, true, param[1]);
                  
                }
              }), attrs);
}

function narrow_unbound_lid_error(env, loc, lid, make_error) {
  var check_module = function (mlid) {
    try {
      lookup_module(true, mlid, env);
      return ;
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return narrow_unbound_lid_error(env, loc, mlid, (function (lid) {
                      return /* Unbound_module */Block.__(20, [lid]);
                    }));
      }
      if (exn === Recmodule) {
        throw [
              $$Error$6,
              loc,
              env,
              /* Illegal_reference_to_recursive_module */1
            ];
      }
      throw exn;
    }
  };
  switch (lid.tag | 0) {
    case /* Lident */0 :
        break;
    case /* Ldot */1 :
        var mlid = lid[0];
        check_module(mlid);
        var md = find_module(false, lookup_module(true, mlid, env), env);
        var match = scrape_alias(env, void 0, md.md_type);
        if (match.tag === /* Mty_functor */2) {
          throw [
                $$Error$6,
                loc,
                env,
                /* Access_functor_as_structure */Block.__(25, [mlid])
              ];
        }
        break;
    case /* Lapply */2 :
        check_module(lid[0]);
        check_module(lid[1]);
        throw [
              $$Error$6,
              loc,
              env,
              /* Ill_typed_functor_application */Block.__(24, [lid])
            ];
    
  }
  throw [
        $$Error$6,
        loc,
        env,
        Curry._1(make_error, lid)
      ];
}

function find_component(lookup, make_error, env, loc, lid) {
  try {
    switch (lid.tag | 0) {
      case /* Ldot */1 :
          var match = lid[0];
          switch (match.tag | 0) {
            case /* Lident */0 :
                if (match[0] === "*predef*") {
                  return Curry._2(lookup, /* Lident */Block.__(0, [lid[1]]), initial_safe_string);
                } else {
                  return Curry._2(lookup, lid, env);
                }
            case /* Ldot */1 :
            case /* Lapply */2 :
                return Curry._2(lookup, lid, env);
            
          }
      case /* Lident */0 :
      case /* Lapply */2 :
          return Curry._2(lookup, lid, env);
      
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return narrow_unbound_lid_error(env, loc, lid, make_error);
    }
    if (exn === Recmodule) {
      throw [
            $$Error$6,
            loc,
            env,
            /* Illegal_reference_to_recursive_module */1
          ];
    }
    throw exn;
  }
}

function find_type(env, loc, lid) {
  var r = find_component(lookup_type$1, (function (lid) {
          return /* Unbound_type_constructor */Block.__(1, [lid]);
        }), env, loc, lid);
  check_deprecated(loc, r[1].type_attributes, name(void 0, r[0]));
  return r;
}

function find_constructor(param, param$1, param$2) {
  return find_component(lookup_constructor, (function (lid) {
                return /* Unbound_constructor */Block.__(18, [lid]);
              }), param, param$1, param$2);
}

function find_all_constructors(param, param$1, param$2) {
  return find_component(lookup_all_constructors$1, (function (lid) {
                return /* Unbound_constructor */Block.__(18, [lid]);
              }), param, param$1, param$2);
}

function find_all_labels(param, param$1, param$2) {
  return find_component(lookup_all_labels$1, (function (lid) {
                return /* Unbound_label */Block.__(19, [lid]);
              }), param, param$1, param$2);
}

function find_class$1(env, loc, lid) {
  var r = find_component(lookup_class$1, (function (lid) {
          return /* Unbound_class */Block.__(21, [lid]);
        }), env, loc, lid);
  check_deprecated(loc, r[1].cty_attributes, name(void 0, r[0]));
  return r;
}

function find_value$1(env, loc, lid) {
  check_value_name(last$1(lid), loc);
  var r = find_component(lookup_value$1, (function (lid) {
          return /* Unbound_value */Block.__(17, [lid]);
        }), env, loc, lid);
  check_deprecated(loc, r[1].val_attributes, name(void 0, r[0]));
  return r;
}

function lookup_module$1(loadOpt, env, loc, lid) {
  var load = loadOpt !== void 0 ? loadOpt : false;
  return find_component((function (lid, env) {
                  return /* tuple */[
                          lookup_module(load, lid, env),
                          void 0
                        ];
                }), (function (lid) {
                  return /* Unbound_module */Block.__(20, [lid]);
                }), env, loc, lid)[0];
}

function find_module$1(env, loc, lid) {
  var path = lookup_module$1(true, env, loc, lid);
  var decl = find_module(false, path, env);
  check_deprecated(loc, decl.md_attributes, name(void 0, path));
  return /* tuple */[
          path,
          decl
        ];
}

function find_modtype$1(env, loc, lid) {
  var r = find_component(lookup_modtype, (function (lid) {
          return /* Unbound_modtype */Block.__(22, [lid]);
        }), env, loc, lid);
  check_deprecated(loc, r[1].mtd_attributes, name(void 0, r[0]));
  return r;
}

function find_class_type(env, loc, lid) {
  var r = find_component(lookup_cltype$1, (function (lid) {
          return /* Unbound_cltype */Block.__(23, [lid]);
        }), env, loc, lid);
  check_deprecated(loc, r[1].clty_attributes, name(void 0, r[0]));
  return r;
}

function unbound_constructor_error(env, lid) {
  return narrow_unbound_lid_error(env, lid.loc, lid.txt, (function (lid) {
                return /* Unbound_constructor */Block.__(18, [lid]);
              }));
}

function unbound_label_error(env, lid) {
  return narrow_unbound_lid_error(env, lid.loc, lid.txt, (function (lid) {
                return /* Unbound_label */Block.__(19, [lid]);
              }));
}

var transl_modtype_longident = {
  contents: (function (param) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "typetexp.ml",
              293,
              45
            ]
          ];
    })
};

var transl_modtype = {
  contents: (function (param) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "typetexp.ml",
              294,
              35
            ]
          ];
    })
};

function create_package_mty(fake, loc, env, param) {
  var l = List.sort((function (param, param$1) {
          var s2 = param$1[0];
          var s1 = param[0];
          if (Caml_obj.caml_equal(s1.txt, s2.txt)) {
            throw [
                  $$Error$6,
                  loc,
                  env,
                  /* Multiple_constraints_on_type */Block.__(15, [s1.txt])
                ];
          }
          return Caml_obj.caml_compare(s1.txt, s2.txt);
        }), param[1]);
  return /* tuple */[
          l,
          List.fold_left((function (mty, param) {
                  var s = param[0];
                  var d_ptype_name = {
                    txt: last$1(s.txt),
                    loc: s.loc
                  };
                  var d_ptype_manifest = fake ? void 0 : param[1];
                  var d = {
                    ptype_name: d_ptype_name,
                    ptype_params: /* [] */0,
                    ptype_cstrs: /* [] */0,
                    ptype_kind: /* Ptype_abstract */0,
                    ptype_private: /* Public */1,
                    ptype_manifest: d_ptype_manifest,
                    ptype_attributes: /* [] */0,
                    ptype_loc: loc
                  };
                  return mk$3(loc, void 0, /* Pmty_with */Block.__(3, [
                                mty,
                                /* :: */[
                                  /* Pwith_type */Block.__(0, [
                                      {
                                        txt: s.txt,
                                        loc: loc
                                      },
                                      d
                                    ]),
                                  /* [] */0
                                ]
                              ]));
                }), mk$3(loc, void 0, /* Pmty_ident */Block.__(0, [param[0]])), l)
        ];
}

var type_variables = {
  contents: /* Empty */0
};

var univars = {
  contents: /* [] */0
};

var pre_univars = {
  contents: /* [] */0
};

var used_variables = {
  contents: /* Empty */0
};

function reset_type_variables(param) {
  reset_global_level(void 0);
  type_variables.contents = /* Empty */0;
  
}

function narrow(param) {
  return /* tuple */[
          increase_global_level(void 0),
          type_variables.contents
        ];
}

function widen(param) {
  global_level.contents = param[0];
  type_variables.contents = param[1];
  
}

function strict_lowercase(c) {
  if (c === /* "_" */95) {
    return true;
  } else if (c >= /* "a" */97) {
    return c <= /* "z" */122;
  } else {
    return false;
  }
}

function validate_name(s) {
  if (s === void 0) {
    return ;
  }
  var name = s;
  if (name !== "" && strict_lowercase(Caml_string.get(name, 0))) {
    return s;
  }
  
}

function transl_type_param(env, styp) {
  var loc = styp.ptyp_loc;
  var match = styp.ptyp_desc;
  if (typeof match === "number") {
    var ty = new_global_var(validate_name("_"), void 0);
    return {
            ctyp_desc: /* Ttyp_any */0,
            ctyp_type: ty,
            ctyp_env: env,
            ctyp_loc: loc,
            ctyp_attributes: styp.ptyp_attributes
          };
  } else {
    if (match.tag) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "typetexp.ml",
              379,
              9
            ]
          ];
    }
    var name = match[0];
    var ty$1;
    try {
      if (name !== "" && Caml_string.get(name, 0) === /* "_" */95) {
        throw [
              $$Error$6,
              loc,
              empty,
              /* Invalid_variable_name */Block.__(13, ["'" + name])
            ];
      }
      find$2(name, type_variables.contents);
      throw Already_bound;
    }
    catch (exn){
      if (exn !== Caml_builtin_exceptions.not_found) {
        throw exn;
      }
      var v = new_global_var(validate_name(name), void 0);
      type_variables.contents = add$5(name, v, type_variables.contents);
      ty$1 = v;
    }
    return {
            ctyp_desc: /* Ttyp_var */Block.__(0, [name]),
            ctyp_type: ty$1,
            ctyp_env: env,
            ctyp_loc: loc,
            ctyp_attributes: styp.ptyp_attributes
          };
  }
}

function new_pre_univar(name, param) {
  var v = newvar(validate_name(name), void 0);
  pre_univars.contents = /* :: */[
    v,
    pre_univars.contents
  ];
  return v;
}

function swap_list(l) {
  if (!l) {
    return l;
  }
  var match = l[1];
  if (match) {
    return /* :: */[
            match[0],
            /* :: */[
              l[0],
              swap_list(match[1])
            ]
          ];
  } else {
    return l;
  }
}

function transl_type(env, policy, styp) {
  var loc = styp.ptyp_loc;
  var ctyp = function (ctyp_desc, ctyp_type) {
    return {
            ctyp_desc: ctyp_desc,
            ctyp_type: ctyp_type,
            ctyp_env: env,
            ctyp_loc: loc,
            ctyp_attributes: styp.ptyp_attributes
          };
  };
  var match = styp.ptyp_desc;
  if (typeof match === "number") {
    var ty;
    if (policy === /* Univars */2) {
      ty = new_pre_univar(void 0, void 0);
    } else {
      if (policy === /* Fixed */0) {
        throw [
              $$Error$6,
              styp.ptyp_loc,
              env,
              /* Unbound_type_variable */Block.__(0, ["_"])
            ];
      }
      ty = newvar(validate_name(void 0), void 0);
    }
    return ctyp(/* Ttyp_any */0, ty);
  } else {
    switch (match.tag | 0) {
      case /* Ptyp_var */0 :
          var name = match[0];
          if (name !== "" && Caml_string.get(name, 0) === /* "_" */95) {
            throw [
                  $$Error$6,
                  styp.ptyp_loc,
                  env,
                  /* Invalid_variable_name */Block.__(13, ["'" + name])
                ];
          }
          var ty$1;
          try {
            ty$1 = instance(void 0, env, List.assoc(name, univars.contents));
          }
          catch (exn){
            if (exn !== Caml_builtin_exceptions.not_found) {
              throw exn;
            }
            try {
              ty$1 = instance(void 0, env, find$2(name, used_variables.contents)[0]);
            }
            catch (exn$1){
              if (exn$1 !== Caml_builtin_exceptions.not_found) {
                throw exn$1;
              }
              var v = policy === /* Univars */2 ? new_pre_univar(name, void 0) : newvar(validate_name(name), void 0);
              used_variables.contents = add$5(name, /* tuple */[
                    v,
                    styp.ptyp_loc
                  ], used_variables.contents);
              ty$1 = v;
            }
          }
          return ctyp(/* Ttyp_var */Block.__(0, [name]), ty$1);
      case /* Ptyp_arrow */1 :
          var l = match[0];
          var cty1 = transl_type(env, policy, match[1]);
          var cty2 = transl_type(env, policy, match[2]);
          var ty$2 = newty2(current_level.contents, /* Tarrow */Block.__(1, [
                  l,
                  cty1.ctyp_type,
                  cty2.ctyp_type,
                  /* Cok */0
                ]));
          return ctyp(/* Ttyp_arrow */Block.__(1, [
                        l,
                        cty1,
                        cty2
                      ]), ty$2);
      case /* Ptyp_tuple */2 :
          var stl = match[0];
          if (List.length(stl) < 2) {
            ill_formed_ast(loc, "Tuples must have at least 2 components.");
          }
          var ctys = List.map((function (param) {
                  return transl_type(env, policy, param);
                }), stl);
          var desc = /* Ttuple */Block.__(2, [List.map((function (ctyp) {
                      return ctyp.ctyp_type;
                    }), ctys)]);
          var ty$3 = newty2(current_level.contents, desc);
          return ctyp(/* Ttyp_tuple */Block.__(2, [ctys]), ty$3);
      case /* Ptyp_constr */3 :
          var stl$1 = match[1];
          var lid = match[0];
          var match$1 = find_type(env, styp.ptyp_loc, lid.txt);
          var decl = match$1[1];
          var path = match$1[0];
          var stl$2;
          if (stl$1) {
            var t = stl$1[0];
            stl$2 = typeof t.ptyp_desc === "number" && !(stl$1[1] || decl.type_arity <= 1) ? List.map((function (param) {
                      return t;
                    }), decl.type_params) : stl$1;
          } else {
            stl$2 = stl$1;
          }
          if (List.length(stl$2) !== decl.type_arity) {
            throw [
                  $$Error$6,
                  styp.ptyp_loc,
                  env,
                  /* Type_arity_mismatch */Block.__(3, [
                      lid.txt,
                      decl.type_arity,
                      List.length(stl$2)
                    ])
                ];
          }
          var args = List.map((function (param) {
                  return transl_type(env, policy, param);
                }), stl$2);
          var params = instance_list(empty, decl.type_params);
          var match$2 = decl.type_manifest;
          var unify_param = match$2 !== void 0 && repr(match$2).level !== 100000000 ? unify$2 : unify_var;
          List.iter2((function (param, ty$prime) {
                  try {
                    return Curry._3(unify_param, env, ty$prime, param[1].ctyp_type);
                  }
                  catch (raw_exn){
                    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                    if (exn[0] === Unify) {
                      throw [
                            $$Error$6,
                            param[0].ptyp_loc,
                            env,
                            /* Type_mismatch */Block.__(6, [swap_list(exn[1])])
                          ];
                    }
                    throw exn;
                  }
                }), List.combine(stl$2, args), params);
          var constr = newconstr(path, List.map((function (ctyp) {
                      return ctyp.ctyp_type;
                    }), args));
          try {
            enforce_constraints(env, constr);
          }
          catch (raw_exn){
            var exn$2 = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn$2[0] === Unify) {
              throw [
                    $$Error$6,
                    styp.ptyp_loc,
                    env,
                    /* Type_mismatch */Block.__(6, [exn$2[1]])
                  ];
            }
            throw exn$2;
          }
          return ctyp(/* Ttyp_constr */Block.__(3, [
                        path,
                        lid,
                        args
                      ]), constr);
      case /* Ptyp_object */4 :
          var o = match[1];
          var fields = List.map((function (param) {
                  return /* tuple */[
                          param[0],
                          param[1],
                          transl_poly_type(env, policy, param[2])
                        ];
                }), match[0]);
          var ty$4 = newobj(transl_fields(loc, env, policy, /* [] */0, o, fields));
          return ctyp(/* Ttyp_object */Block.__(4, [
                        fields,
                        o
                      ]), ty$4);
      case /* Ptyp_class */5 :
          var stl$3 = match[1];
          var lid$1 = match[0];
          var match$3;
          try {
            var match$4 = lookup_type$1(lid$1.txt, env);
            var decl$1 = match$4[1];
            var check = function (_decl) {
              while(true) {
                var decl = _decl;
                var match = decl.type_manifest;
                if (match === void 0) {
                  throw Caml_builtin_exceptions.not_found;
                }
                var match$1 = repr(match).desc;
                if (typeof match$1 === "number") {
                  throw Caml_builtin_exceptions.not_found;
                }
                switch (match$1.tag | 0) {
                  case /* Tconstr */3 :
                      _decl = find_type_full(match$1[0], env)[0];
                      continue ;
                  case /* Tvariant */8 :
                      if (static_row(match$1[0])) {
                        return ;
                      }
                      throw Caml_builtin_exceptions.not_found;
                  default:
                    throw Caml_builtin_exceptions.not_found;
                }
              };
            };
            check(decl$1);
            prerr_warning(styp.ptyp_loc, /* Deprecated */Block.__(0, ["old syntax for polymorphic variant type"]));
            match$3 = /* tuple */[
              match$4[0],
              decl$1,
              true
            ];
          }
          catch (exn$3){
            if (exn$3 !== Caml_builtin_exceptions.not_found) {
              throw exn$3;
            }
            try {
              var match$5 = lid$1.txt;
              var lid2;
              switch (match$5.tag | 0) {
                case /* Lident */0 :
                    lid2 = /* Lident */Block.__(0, ["#" + match$5[0]]);
                    break;
                case /* Ldot */1 :
                    lid2 = /* Ldot */Block.__(1, [
                        match$5[0],
                        "#" + match$5[1]
                      ]);
                    break;
                case /* Lapply */2 :
                    lid2 = fatal_error("Typetexp.transl_type");
                    break;
                
              }
              var match$6 = lookup_type$1(lid2, env);
              match$3 = /* tuple */[
                match$6[0],
                match$6[1],
                false
              ];
            }
            catch (exn$4){
              if (exn$4 !== Caml_builtin_exceptions.not_found) {
                throw exn$4;
              }
              find_class$1(env, styp.ptyp_loc, lid$1.txt);
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    /* tuple */[
                      "typetexp.ml",
                      505,
                      57
                    ]
                  ];
            }
          }
          var decl$2 = match$3[1];
          var path$1 = match$3[0];
          if (List.length(stl$3) !== decl$2.type_arity) {
            throw [
                  $$Error$6,
                  styp.ptyp_loc,
                  env,
                  /* Type_arity_mismatch */Block.__(3, [
                      lid$1.txt,
                      decl$2.type_arity,
                      List.length(stl$3)
                    ])
                ];
          }
          var args$1 = List.map((function (param) {
                  return transl_type(env, policy, param);
                }), stl$3);
          var params$1 = instance_list(empty, decl$2.type_params);
          List.iter2((function (param, ty$prime) {
                  try {
                    return unify_var(env, ty$prime, param[1].ctyp_type);
                  }
                  catch (raw_exn){
                    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                    if (exn[0] === Unify) {
                      throw [
                            $$Error$6,
                            param[0].ptyp_loc,
                            env,
                            /* Type_mismatch */Block.__(6, [swap_list(exn[1])])
                          ];
                    }
                    throw exn;
                  }
                }), List.combine(stl$3, args$1), params$1);
          var ty_args = List.map((function (ctyp) {
                  return ctyp.ctyp_type;
                }), args$1);
          var ty$5;
          try {
            ty$5 = expand_head(env, newconstr(path$1, ty_args));
          }
          catch (raw_exn$1){
            var exn$5 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
            if (exn$5[0] === Unify) {
              throw [
                    $$Error$6,
                    styp.ptyp_loc,
                    env,
                    /* Type_mismatch */Block.__(6, [exn$5[1]])
                  ];
            }
            throw exn$5;
          }
          var match$7 = ty$5.desc;
          var ty$6;
          if (typeof match$7 === "number") {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  /* tuple */[
                    "typetexp.ml",
                    553,
                    10
                  ]
                ];
          }
          switch (match$7.tag | 0) {
            case /* Tobject */4 :
                var match$8 = flatten_fields(match$7[0]);
                if (policy === /* Univars */2) {
                  pre_univars.contents = /* :: */[
                    match$8[1],
                    pre_univars.contents
                  ];
                }
                ty$6 = ty$5;
                break;
            case /* Tvariant */8 :
                var row = row_repr_aux(/* [] */0, match$7[0]);
                var fields$1 = List.map((function (param) {
                        var f = param[1];
                        var match = row_field_repr_aux(/* [] */0, f);
                        var tmp;
                        if (typeof match === "number" || match.tag) {
                          tmp = f;
                        } else {
                          var match$1 = match[0];
                          tmp = match$1 !== void 0 ? /* Reither */Block.__(1, [
                                false,
                                /* :: */[
                                  match$1,
                                  /* [] */0
                                ],
                                false,
                                {
                                  contents: void 0
                                }
                              ]) : /* Reither */Block.__(1, [
                                true,
                                /* [] */0,
                                false,
                                {
                                  contents: void 0
                                }
                              ]);
                        }
                        return /* tuple */[
                                param[0],
                                tmp
                              ];
                      }), row.row_fields);
                var row_row_more = newvar(validate_name(void 0), void 0);
                var row_row_name = /* tuple */[
                  path$1,
                  ty_args
                ];
                var row$1 = {
                  row_fields: fields$1,
                  row_more: row_row_more,
                  row_bound: void 0,
                  row_closed: true,
                  row_fixed: false,
                  row_name: row_row_name
                };
                var $$static = static_row(row$1);
                var row$2 = $$static ? ({
                      row_fields: fields$1,
                      row_more: newty2(current_level.contents, /* Tnil */0),
                      row_bound: void 0,
                      row_closed: true,
                      row_fixed: false,
                      row_name: row_row_name
                    }) : (
                    policy !== /* Univars */2 ? row$1 : ({
                          row_fields: fields$1,
                          row_more: new_pre_univar(void 0, void 0),
                          row_bound: void 0,
                          row_closed: true,
                          row_fixed: false,
                          row_name: row_row_name
                        })
                  );
                ty$6 = newty2(current_level.contents, /* Tvariant */Block.__(8, [row$2]));
                break;
            default:
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    /* tuple */[
                      "typetexp.ml",
                      553,
                      10
                    ]
                  ];
          }
          return ctyp(/* Ttyp_class */Block.__(5, [
                        path$1,
                        lid$1,
                        args$1
                      ]), ty$6);
      case /* Ptyp_alias */6 :
          var alias = match[1];
          var st = match[0];
          var cty;
          try {
            var t$1;
            try {
              t$1 = List.assoc(alias, univars.contents);
            }
            catch (exn$6){
              if (exn$6 !== Caml_builtin_exceptions.not_found) {
                throw exn$6;
              }
              t$1 = instance(void 0, env, find$2(alias, used_variables.contents)[0]);
            }
            var ty$7 = transl_type(env, policy, st);
            try {
              unify_var(env, t$1, ty$7.ctyp_type);
            }
            catch (raw_exn$2){
              var exn$7 = Caml_js_exceptions.internalToOCamlException(raw_exn$2);
              if (exn$7[0] !== Unify) {
                throw exn$7;
              }
              var trace = swap_list(exn$7[1]);
              throw [
                    $$Error$6,
                    styp.ptyp_loc,
                    env,
                    /* Alias_type_mismatch */Block.__(7, [trace])
                  ];
            }
            cty = ty$7;
          }
          catch (exn$8){
            if (exn$8 !== Caml_builtin_exceptions.not_found) {
              throw exn$8;
            }
            if (principal.contents) {
              begin_def(void 0);
            }
            var t$2 = newvar(validate_name(void 0), void 0);
            used_variables.contents = add$5(alias, /* tuple */[
                  t$2,
                  styp.ptyp_loc
                ], used_variables.contents);
            var ty$8 = transl_type(env, policy, st);
            try {
              unify_var(env, t$2, ty$8.ctyp_type);
            }
            catch (raw_exn$3){
              var exn$9 = Caml_js_exceptions.internalToOCamlException(raw_exn$3);
              if (exn$9[0] !== Unify) {
                throw exn$9;
              }
              var trace$1 = swap_list(exn$9[1]);
              throw [
                    $$Error$6,
                    styp.ptyp_loc,
                    env,
                    /* Alias_type_mismatch */Block.__(7, [trace$1])
                  ];
            }
            if (principal.contents) {
              end_def(void 0);
              generalize_structure$1(current_level.contents, t$2);
            }
            var t$3 = instance(void 0, env, t$2);
            var px = proxy(t$3);
            var match$9 = px.desc;
            if (typeof match$9 !== "number") {
              switch (match$9.tag | 0) {
                case /* Tvar */0 :
                    if (match$9[0] !== void 0) {
                      
                    } else {
                      log_type(px);
                      px.desc = /* Tvar */Block.__(0, [alias]);
                    }
                    break;
                case /* Tunivar */9 :
                    if (match$9[0] !== void 0) {
                      
                    } else {
                      log_type(px);
                      px.desc = /* Tunivar */Block.__(9, [alias]);
                    }
                    break;
                default:
                  
              }
            }
            cty = {
              ctyp_desc: ty$8.ctyp_desc,
              ctyp_type: t$3,
              ctyp_env: ty$8.ctyp_env,
              ctyp_loc: ty$8.ctyp_loc,
              ctyp_attributes: ty$8.ctyp_attributes
            };
          }
          return ctyp(/* Ttyp_alias */Block.__(6, [
                        cty,
                        alias
                      ]), cty.ctyp_type);
      case /* Ptyp_variant */7 :
          var present = match[2];
          var closed = match[1];
          var name$1 = {
            contents: void 0
          };
          var mkfield = function (l, f) {
            var desc = /* Tvariant */Block.__(8, [{
                  row_fields: /* :: */[
                    /* tuple */[
                      l,
                      f
                    ],
                    /* [] */0
                  ],
                  row_more: newvar(validate_name(void 0), void 0),
                  row_bound: void 0,
                  row_closed: true,
                  row_fixed: false,
                  row_name: void 0
                }]);
            return newty2(current_level.contents, desc);
          };
          var hfields = Hashtbl.create(void 0, 17);
          var add_typed_field = function (loc, l, f) {
            var h = hash_variant(l);
            try {
              var match = Hashtbl.find(hfields, h);
              var l$prime = match[0];
              if (l !== l$prime) {
                throw [
                      $$Error$6,
                      styp.ptyp_loc,
                      env,
                      /* Variant_tags */Block.__(12, [
                          l,
                          l$prime
                        ])
                    ];
              }
              var ty = mkfield(l, f);
              var ty$prime = mkfield(l, match[1]);
              if (equal$4(env, false, /* :: */[
                      ty,
                      /* [] */0
                    ], /* :: */[
                      ty$prime,
                      /* [] */0
                    ])) {
                return ;
              }
              try {
                return unify$2(env, ty, ty$prime);
              }
              catch (raw_exn){
                var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                if (exn[0] === Unify) {
                  throw [
                        $$Error$6,
                        loc,
                        env,
                        /* Constructor_mismatch */Block.__(10, [
                            ty,
                            ty$prime
                          ])
                      ];
                }
                throw exn;
              }
            }
            catch (exn$1){
              if (exn$1 === Caml_builtin_exceptions.not_found) {
                return Hashtbl.add(hfields, h, /* tuple */[
                            l,
                            f
                          ]);
              }
              throw exn$1;
            }
          };
          var add_field = function (param) {
            if (param.tag) {
              var sty = param[0];
              var cty = transl_type(env, policy, sty);
              var ty = cty.ctyp_type;
              var match = repr(cty.ctyp_type);
              var match$1 = match.desc;
              var nm;
              nm = typeof match$1 === "number" || match$1.tag !== /* Tconstr */3 ? void 0 : /* tuple */[
                  match$1[0],
                  match$1[1]
                ];
              try {
                Hashtbl.iter((function (param, param$1) {
                        throw Pervasives.Exit;
                      }), hfields);
                name$1.contents = nm;
              }
              catch (exn){
                if (exn !== Pervasives.Exit) {
                  throw exn;
                }
                name$1.contents = void 0;
              }
              var match$2 = expand_head(env, cty.ctyp_type);
              var match$3 = match$2.desc;
              var fl;
              var exit = 0;
              if (typeof match$3 === "number") {
                exit = 1;
              } else {
                switch (match$3.tag | 0) {
                  case /* Tvar */0 :
                      if (nm !== void 0) {
                        throw [
                              $$Error$6,
                              sty.ptyp_loc,
                              env,
                              /* Unbound_type_constructor_2 */Block.__(2, [nm[0]])
                            ];
                      }
                      exit = 1;
                      break;
                  case /* Tvariant */8 :
                      var row = match$3[0];
                      if (static_row(row)) {
                        fl = row_repr_aux(/* [] */0, row).row_fields;
                      } else {
                        exit = 1;
                      }
                      break;
                  default:
                    exit = 1;
                }
              }
              if (exit === 1) {
                throw [
                      $$Error$6,
                      sty.ptyp_loc,
                      env,
                      /* Not_a_variant */Block.__(11, [ty])
                    ];
              }
              List.iter((function (param) {
                      var f = param[1];
                      var l = param[0];
                      var f$1;
                      if (present !== void 0 && !List.mem(l, present)) {
                        if (typeof f === "number") {
                          throw [
                                Caml_builtin_exceptions.assert_failure,
                                /* tuple */[
                                  "typetexp.ml",
                                  666,
                                  24
                                ]
                              ];
                        }
                        if (f.tag) {
                          throw [
                                Caml_builtin_exceptions.assert_failure,
                                /* tuple */[
                                  "typetexp.ml",
                                  666,
                                  24
                                ]
                              ];
                        }
                        var match = f[0];
                        f$1 = match !== void 0 ? /* Reither */Block.__(1, [
                              false,
                              /* :: */[
                                match,
                                /* [] */0
                              ],
                              false,
                              {
                                contents: void 0
                              }
                            ]) : /* Reither */Block.__(1, [
                              true,
                              /* [] */0,
                              false,
                              {
                                contents: void 0
                              }
                            ]);
                      } else {
                        f$1 = f;
                      }
                      return add_typed_field(sty.ptyp_loc, l, f$1);
                    }), fl);
              return /* Tinherit */Block.__(1, [cty]);
            } else {
              var stl = param[3];
              var c = param[2];
              var l = param[0];
              name$1.contents = void 0;
              var tl = List.map((function (param) {
                      return transl_type(env, policy, param);
                    }), stl);
              var f;
              var exit$1 = 0;
              if (present !== void 0 && !List.mem(l, present)) {
                var ty_tl = List.map((function (cty) {
                        return cty.ctyp_type;
                      }), tl);
                f = /* Reither */Block.__(1, [
                    c,
                    ty_tl,
                    false,
                    {
                      contents: void 0
                    }
                  ]);
              } else {
                exit$1 = 1;
              }
              if (exit$1 === 1) {
                if (List.length(stl) > 1 || c && stl !== /* [] */0) {
                  throw [
                        $$Error$6,
                        styp.ptyp_loc,
                        env,
                        /* Present_has_conjunction */Block.__(8, [l])
                      ];
                }
                f = tl ? /* Rpresent */Block.__(0, [tl[0].ctyp_type]) : /* Rpresent */Block.__(0, [void 0]);
              }
              add_typed_field(styp.ptyp_loc, l, f);
              return /* Ttag */Block.__(0, [
                        l,
                        param[1],
                        c,
                        tl
                      ]);
            }
          };
          var tfields = List.map(add_field, match[0]);
          var fields$2 = Hashtbl.fold((function (param, p, l) {
                  return /* :: */[
                          p,
                          l
                        ];
                }), hfields, /* [] */0);
          if (present !== void 0) {
            List.iter((function (l) {
                    if (List.mem_assoc(l, fields$2)) {
                      return ;
                    }
                    throw [
                          $$Error$6,
                          styp.ptyp_loc,
                          env,
                          /* Present_has_no_type */Block.__(9, [l])
                        ];
                  }), present);
          }
          var row_row_fields = List.rev(fields$2);
          var row_row_more$1 = newvar(validate_name(void 0), void 0);
          var row_row_closed = closed === /* Closed */0;
          var row_row_name$1 = name$1.contents;
          var row$3 = {
            row_fields: row_row_fields,
            row_more: row_row_more$1,
            row_bound: void 0,
            row_closed: row_row_closed,
            row_fixed: false,
            row_name: row_row_name$1
          };
          var $$static$1 = static_row(row$3);
          var row$4 = $$static$1 ? ({
                row_fields: row_row_fields,
                row_more: newty2(current_level.contents, /* Tnil */0),
                row_bound: void 0,
                row_closed: row_row_closed,
                row_fixed: false,
                row_name: row_row_name$1
              }) : (
              policy !== /* Univars */2 ? row$3 : ({
                    row_fields: row_row_fields,
                    row_more: new_pre_univar(void 0, void 0),
                    row_bound: void 0,
                    row_closed: row_row_closed,
                    row_fixed: false,
                    row_name: row_row_name$1
                  })
            );
          var ty$9 = newty2(current_level.contents, /* Tvariant */Block.__(8, [row$4]));
          return ctyp(/* Ttyp_variant */Block.__(7, [
                        tfields,
                        closed,
                        present
                      ]), ty$9);
      case /* Ptyp_poly */8 :
          var vars = match[0];
          begin_def(void 0);
          var new_univars = List.map((function (name) {
                  return /* tuple */[
                          name,
                          newvar(validate_name(name), void 0)
                        ];
                }), vars);
          var old_univars = univars.contents;
          univars.contents = Pervasives.$at(new_univars, univars.contents);
          var cty$1 = transl_type(env, policy, match[1]);
          var ty$10 = cty$1.ctyp_type;
          univars.contents = old_univars;
          end_def(void 0);
          iter_generalize$1({
                contents: /* [] */0
              }, ty$10);
          var ty_list = List.fold_left((function (tyl, param) {
                  var v = proxy(param[1]);
                  if (!deep_occur(v, ty$10)) {
                    return tyl;
                  }
                  var match = v.desc;
                  if (typeof match !== "number" && !match.tag && v.level === 100000000) {
                    v.desc = /* Tunivar */Block.__(9, [match[0]]);
                    return /* :: */[
                            v,
                            tyl
                          ];
                  }
                  throw [
                        $$Error$6,
                        styp.ptyp_loc,
                        env,
                        /* Cannot_quantify */Block.__(14, [
                            param[0],
                            v
                          ])
                      ];
                }), /* [] */0, new_univars);
          var ty$prime = newty2(100000000, /* Tpoly */Block.__(10, [
                  ty$10,
                  List.rev(ty_list)
                ]));
          unify_var(env, newvar(validate_name(void 0), void 0), ty$prime);
          return ctyp(/* Ttyp_poly */Block.__(8, [
                        vars,
                        cty$1
                      ]), ty$prime);
      case /* Ptyp_package */9 :
          var match$10 = match[0];
          var p = match$10[0];
          var match$11 = create_package_mty(true, styp.ptyp_loc, env, /* tuple */[
                p,
                match$10[1]
              ]);
          var l$1 = match$11[0];
          var z = narrow(void 0);
          var mty = Curry._2(transl_modtype.contents, env, match$11[1]);
          widen(z);
          var ptys = List.map((function (param) {
                  return /* tuple */[
                          param[0],
                          transl_type(env, policy, param[1])
                        ];
                }), l$1);
          var path$2 = Curry._3(transl_modtype_longident.contents, styp.ptyp_loc, env, p.txt);
          var desc_001 = List.map((function (param) {
                  return param[0].txt;
                }), l$1);
          var desc_002 = List.map((function (param) {
                  return param[1].ctyp_type;
                }), ptys);
          var desc$1 = /* Tpackage */Block.__(11, [
              path$2,
              desc_001,
              desc_002
            ]);
          var ty$11 = newty2(current_level.contents, desc$1);
          return ctyp(/* Ttyp_package */Block.__(9, [{
                          pack_path: path$2,
                          pack_fields: ptys,
                          pack_type: mty.mty_type,
                          pack_txt: p
                        }]), ty$11);
      case /* Ptyp_extension */10 :
          throw [
                Error_forward,
                error_of_extension(match[0])
              ];
      
    }
  }
}

function transl_poly_type(env, policy, t) {
  return transl_type(env, policy, force_poly(t));
}

function transl_fields(loc, env, policy, seen, o, param) {
  if (!param) {
    if (o) {
      if (policy >= 2) {
        return new_pre_univar(void 0, void 0);
      } else {
        return newvar(validate_name(void 0), void 0);
      }
    } else {
      return newty2(current_level.contents, /* Tnil */0);
    }
  }
  var match = param[0];
  var s = match[0];
  if (List.mem(s, seen)) {
    throw [
          $$Error$6,
          loc,
          env,
          /* Repeated_method_label */Block.__(16, [s])
        ];
  }
  var ty2 = transl_fields(loc, env, policy, /* :: */[
        s,
        seen
      ], o, param[1]);
  return newty2(current_level.contents, /* Tfield */Block.__(5, [
                s,
                /* Fpresent */0,
                match[2].ctyp_type,
                ty2
              ]));
}

function make_fixed_univars(ty) {
  var ty$1 = repr(ty);
  if (ty$1.level < 0) {
    return ;
  }
  mark_type_node(ty$1);
  var match = ty$1.desc;
  if (typeof match === "number") {
    return iter_type_expr(make_fixed_univars, ty$1);
  }
  if (match.tag !== /* Tvariant */8) {
    return iter_type_expr(make_fixed_univars, ty$1);
  }
  var row = row_repr_aux(/* [] */0, match[0]);
  if (is_Tunivar(row_more(row))) {
    ty$1.desc = /* Tvariant */Block.__(8, [{
          row_fields: List.map((function (p) {
                  var match = row_field_repr_aux(/* [] */0, p[1]);
                  if (typeof match === "number" || !match.tag) {
                    return p;
                  } else {
                    return /* tuple */[
                            p[0],
                            /* Reither */Block.__(1, [
                                match[0],
                                match[1],
                                true,
                                match[3]
                              ])
                          ];
                  }
                }), row.row_fields),
          row_more: row.row_more,
          row_bound: row.row_bound,
          row_closed: row.row_closed,
          row_fixed: true,
          row_name: row.row_name
        }]);
  }
  return iter_row(make_fixed_univars, row);
}

function globalize_used_variables(env, fixed) {
  var r = {
    contents: /* [] */0
  };
  iter$2((function (name, param) {
          var loc = param[1];
          var ty = param[0];
          var v = new_global_var(validate_name(void 0), void 0);
          var snap = snapshot(void 0);
          var tmp;
          try {
            unify$2(env, v, ty);
            tmp = true;
          }
          catch (exn){
            backtrack(snap);
            tmp = false;
          }
          if (!tmp) {
            return ;
          }
          try {
            r.contents = /* :: */[
              /* tuple */[
                loc,
                v,
                find$2(name, type_variables.contents)
              ],
              r.contents
            ];
            return ;
          }
          catch (exn$1){
            if (exn$1 !== Caml_builtin_exceptions.not_found) {
              throw exn$1;
            }
            if (fixed && is_Tvar(repr(ty))) {
              throw [
                    $$Error$6,
                    loc,
                    env,
                    /* Unbound_type_variable */Block.__(0, ["'" + name])
                  ];
            }
            var v2 = new_global_var(validate_name(void 0), void 0);
            r.contents = /* :: */[
              /* tuple */[
                loc,
                v,
                v2
              ],
              r.contents
            ];
            type_variables.contents = add$5(name, v2, type_variables.contents);
            return ;
          }
        }), used_variables.contents);
  used_variables.contents = /* Empty */0;
  return (function (param) {
      return List.iter((function (param) {
                    try {
                      return unify$2(env, param[1], param[2]);
                    }
                    catch (raw_exn){
                      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                      if (exn[0] === Unify) {
                        throw [
                              $$Error$6,
                              param[0],
                              env,
                              /* Type_mismatch */Block.__(6, [exn[1]])
                            ];
                      }
                      throw exn;
                    }
                  }), r.contents);
    });
}

function transl_simple_type(env, fixed, styp) {
  univars.contents = /* [] */0;
  used_variables.contents = /* Empty */0;
  var typ = transl_type(env, fixed ? /* Fixed */0 : /* Extensible */1, styp);
  globalize_used_variables(env, fixed)(void 0);
  var ty = typ.ctyp_type;
  make_fixed_univars(ty);
  unmark_type(ty);
  return typ;
}

function transl_simple_type_univars(env, styp) {
  univars.contents = /* [] */0;
  used_variables.contents = /* Empty */0;
  pre_univars.contents = /* [] */0;
  begin_def(void 0);
  var typ = transl_type(env, /* Univars */2, styp);
  var new_variables = used_variables.contents;
  used_variables.contents = /* Empty */0;
  iter$2((function (name, p) {
          if (mem$4(name, type_variables.contents)) {
            used_variables.contents = add$5(name, p, used_variables.contents);
            return ;
          }
          
        }), new_variables);
  globalize_used_variables(env, false)(void 0);
  end_def(void 0);
  iter_generalize$1({
        contents: /* [] */0
      }, typ.ctyp_type);
  var univs = List.fold_left((function (acc, v) {
          var v$1 = repr(v);
          var match = v$1.desc;
          if (typeof match === "number" || match.tag || v$1.level !== 100000000) {
            return acc;
          } else {
            v$1.desc = /* Tunivar */Block.__(9, [match[0]]);
            return /* :: */[
                    v$1,
                    acc
                  ];
          }
        }), /* [] */0, pre_univars.contents);
  var ty = typ.ctyp_type;
  make_fixed_univars(ty);
  unmark_type(ty);
  return {
          ctyp_desc: typ.ctyp_desc,
          ctyp_type: instance(void 0, env, newty2(100000000, /* Tpoly */Block.__(10, [
                      typ.ctyp_type,
                      univs
                    ]))),
          ctyp_env: typ.ctyp_env,
          ctyp_loc: typ.ctyp_loc,
          ctyp_attributes: typ.ctyp_attributes
        };
}

function transl_simple_type_delayed(env, styp) {
  univars.contents = /* [] */0;
  used_variables.contents = /* Empty */0;
  var typ = transl_type(env, /* Extensible */1, styp);
  var ty = typ.ctyp_type;
  make_fixed_univars(ty);
  unmark_type(ty);
  return /* tuple */[
          typ,
          globalize_used_variables(env, false)
        ];
}

function transl_type_scheme(env, styp) {
  reset_type_variables(void 0);
  begin_def(void 0);
  var typ = transl_simple_type(env, false, styp);
  end_def(void 0);
  iter_generalize$1({
        contents: /* [] */0
      }, typ.ctyp_type);
  return typ;
}

function spellcheck(ppf, fold, env, lid) {
  var match = last$1(lid).length;
  var switcher = match - 1 | 0;
  var cutoff = switcher > 3 || switcher < 0 ? (
      switcher === 5 || switcher === 4 ? 2 : 3
    ) : (
      switcher >= 2 ? 1 : 0
    );
  var compare = function (target, head, acc) {
    var best_dist = acc[1];
    var best_choice = acc[0];
    var match = edit_distance(target, head, cutoff);
    if (match === void 0) {
      return /* tuple */[
              best_choice,
              best_dist
            ];
    }
    var dist = match;
    var choice = dist < best_dist ? /* :: */[
        head,
        /* [] */0
      ] : (
        dist === best_dist ? /* :: */[
            head,
            best_choice
          ] : best_choice
      );
    return /* tuple */[
            choice,
            dist < best_dist ? dist : best_dist
          ];
  };
  var init = /* tuple */[
    /* [] */0,
    Pervasives.max_int
  ];
  var handle = function (param) {
    var match = List.rev(param[0]);
    if (!match) {
      return ;
    }
    var rev_rest = match[1];
    return Curry._3(Format.fprintf(ppf, /* Format */[
                    /* Formatting_lit */Block.__(17, [
                        /* Force_newline */3,
                        /* String_literal */Block.__(11, [
                            "Hint: Did you mean ",
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* String */Block.__(2, [
                                        /* No_padding */0,
                                        /* Char_literal */Block.__(12, [
                                            /* "?" */63,
                                            /* End_of_format */0
                                          ])
                                      ])
                                  ])
                              ])
                          ])
                      ]),
                    "@\nHint: Did you mean %s%s%s?"
                  ]), $$String.concat(", ", List.rev(rev_rest)), rev_rest === /* [] */0 ? "" : " or ", match[0]);
  };
  Format.fprintf(ppf, /* Format */[
        /* Formatting_lit */Block.__(17, [
            /* FFlush */2,
            /* End_of_format */0
          ]),
        "@?"
      ]);
  switch (lid.tag | 0) {
    case /* Lident */0 :
        var s = lid[0];
        return handle(Curry._4(fold, (function (param, param$1) {
                          return compare(s, param, param$1);
                        }), void 0, env, init));
    case /* Ldot */1 :
        var s$1 = lid[1];
        return handle(Curry._4(fold, (function (param, param$1) {
                          return compare(s$1, param, param$1);
                        }), lid[0], env, init));
    case /* Lapply */2 :
        return ;
    
  }
}

function spellcheck_simple(ppf, fold, extr) {
  return (function (param, param$1) {
      return spellcheck(ppf, (function (f) {
                    return Curry._1(fold, (function (decl, x) {
                                  return Curry._2(f, Curry._1(extr, decl), x);
                                }));
                  }), param, param$1);
    });
}

function spellcheck$1(ppf, fold) {
  return (function (param, param$1) {
      return spellcheck(ppf, (function (f) {
                    return Curry._1(fold, (function (s, param, param$1, x) {
                                  return Curry._2(f, s, x);
                                }));
                  }), param, param$1);
    });
}

register_error_of_exn((function (param) {
        if (param[0] !== $$Error$6) {
          if (param[0] === Error_forward) {
            return param[1];
          } else {
            return ;
          }
        }
        var env = param[2];
        return error_of_printer(param[1], (function (param, param$1) {
                      if (typeof param$1 === "number") {
                        if (param$1 === /* Recursive_type */0) {
                          return Format.fprintf(param, /* Format */[
                                      /* String_literal */Block.__(11, [
                                          "This type is recursive",
                                          /* End_of_format */0
                                        ]),
                                      "This type is recursive"
                                    ]);
                        } else {
                          return Format.fprintf(param, /* Format */[
                                      /* String_literal */Block.__(11, [
                                          "Illegal recursive module reference",
                                          /* End_of_format */0
                                        ]),
                                      "Illegal recursive module reference"
                                    ]);
                        }
                      }
                      switch (param$1.tag | 0) {
                        case /* Unbound_type_variable */0 :
                            return Curry._1(Format.fprintf(param, /* Format */[
                                            /* String_literal */Block.__(11, [
                                                "Unbound type parameter ",
                                                /* String */Block.__(2, [
                                                    /* No_padding */0,
                                                    /* Formatting_lit */Block.__(17, [
                                                        /* Flush_newline */4,
                                                        /* End_of_format */0
                                                      ])
                                                  ])
                                              ]),
                                            "Unbound type parameter %s@."
                                          ]), param$1[0]);
                        case /* Unbound_type_constructor */1 :
                            var lid = param$1[0];
                            Curry._2(Format.fprintf(param, /* Format */[
                                      /* String_literal */Block.__(11, [
                                          "Unbound type constructor ",
                                          /* Alpha */Block.__(15, [/* End_of_format */0])
                                        ]),
                                      "Unbound type constructor %a"
                                    ]), longident, lid);
                            return spellcheck$1(param, fold_types)(env, lid);
                        case /* Unbound_type_constructor_2 */2 :
                            return Curry._2(Format.fprintf(param, /* Format */[
                                            /* String_literal */Block.__(11, [
                                                "The type constructor",
                                                /* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@ ",
                                                        1,
                                                        0
                                                      ]),
                                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                            /* Break */Block.__(0, [
                                                                "@ ",
                                                                1,
                                                                0
                                                              ]),
                                                            /* String_literal */Block.__(11, [
                                                                "is not yet completely defined",
                                                                /* End_of_format */0
                                                              ])
                                                          ])])
                                                  ])
                                              ]),
                                            "The type constructor@ %a@ is not yet completely defined"
                                          ]), path, param$1[0]);
                        case /* Type_arity_mismatch */3 :
                            return Curry._4(Format.fprintf(param, /* Format */[
                                            /* Formatting_gen */Block.__(18, [
                                                /* Open_box */Block.__(1, [/* Format */[
                                                      /* End_of_format */0,
                                                      ""
                                                    ]]),
                                                /* String_literal */Block.__(11, [
                                                    "The type constructor ",
                                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                            /* Break */Block.__(0, [
                                                                "@ ",
                                                                1,
                                                                0
                                                              ]),
                                                            /* String_literal */Block.__(11, [
                                                                "expects ",
                                                                /* Int */Block.__(4, [
                                                                    /* Int_i */3,
                                                                    /* No_padding */0,
                                                                    /* No_precision */0,
                                                                    /* String_literal */Block.__(11, [
                                                                        " argument(s),",
                                                                        /* Formatting_lit */Block.__(17, [
                                                                            /* Break */Block.__(0, [
                                                                                "@ ",
                                                                                1,
                                                                                0
                                                                              ]),
                                                                            /* String_literal */Block.__(11, [
                                                                                "but is here applied to ",
                                                                                /* Int */Block.__(4, [
                                                                                    /* Int_i */3,
                                                                                    /* No_padding */0,
                                                                                    /* No_precision */0,
                                                                                    /* String_literal */Block.__(11, [
                                                                                        " argument(s)",
                                                                                        /* Formatting_lit */Block.__(17, [
                                                                                            /* Close_box */0,
                                                                                            /* End_of_format */0
                                                                                          ])
                                                                                      ])
                                                                                  ])
                                                                              ])
                                                                          ])
                                                                      ])
                                                                  ])
                                                              ])
                                                          ])])
                                                  ])
                                              ]),
                                            "@[The type constructor %a@ expects %i argument(s),@ but is here applied to %i argument(s)@]"
                                          ]), longident, param$1[0], param$1[1], param$1[2]);
                        case /* Bound_type_variable */4 :
                            return Curry._1(Format.fprintf(param, /* Format */[
                                            /* String_literal */Block.__(11, [
                                                "Already bound type parameter '",
                                                /* String */Block.__(2, [
                                                    /* No_padding */0,
                                                    /* End_of_format */0
                                                  ])
                                              ]),
                                            "Already bound type parameter '%s"
                                          ]), param$1[0]);
                        case /* Unbound_row_variable */5 :
                            return Curry._2(Format.fprintf(param, /* Format */[
                                            /* String_literal */Block.__(11, [
                                                "Unbound row variable in #",
                                                /* Alpha */Block.__(15, [/* End_of_format */0])
                                              ]),
                                            "Unbound row variable in #%a"
                                          ]), longident, param$1[0]);
                        case /* Type_mismatch */6 :
                            return report_unification_error(param, empty, void 0, param$1[0], (function (ppf) {
                                          return Format.fprintf(ppf, /* Format */[
                                                      /* String_literal */Block.__(11, [
                                                          "This type",
                                                          /* End_of_format */0
                                                        ]),
                                                      "This type"
                                                    ]);
                                        }), (function (ppf) {
                                          return Format.fprintf(ppf, /* Format */[
                                                      /* String_literal */Block.__(11, [
                                                          "should be an instance of type",
                                                          /* End_of_format */0
                                                        ]),
                                                      "should be an instance of type"
                                                    ]);
                                        }));
                        case /* Alias_type_mismatch */7 :
                            return report_unification_error(param, empty, void 0, param$1[0], (function (ppf) {
                                          return Format.fprintf(ppf, /* Format */[
                                                      /* String_literal */Block.__(11, [
                                                          "This alias is bound to type",
                                                          /* End_of_format */0
                                                        ]),
                                                      "This alias is bound to type"
                                                    ]);
                                        }), (function (ppf) {
                                          return Format.fprintf(ppf, /* Format */[
                                                      /* String_literal */Block.__(11, [
                                                          "but is used as an instance of type",
                                                          /* End_of_format */0
                                                        ]),
                                                      "but is used as an instance of type"
                                                    ]);
                                        }));
                        case /* Present_has_conjunction */8 :
                            return Curry._1(Format.fprintf(param, /* Format */[
                                            /* String_literal */Block.__(11, [
                                                "The present constructor ",
                                                /* String */Block.__(2, [
                                                    /* No_padding */0,
                                                    /* String_literal */Block.__(11, [
                                                        " has a conjunctive type",
                                                        /* End_of_format */0
                                                      ])
                                                  ])
                                              ]),
                                            "The present constructor %s has a conjunctive type"
                                          ]), param$1[0]);
                        case /* Present_has_no_type */9 :
                            return Curry._1(Format.fprintf(param, /* Format */[
                                            /* String_literal */Block.__(11, [
                                                "The present constructor ",
                                                /* String */Block.__(2, [
                                                    /* No_padding */0,
                                                    /* String_literal */Block.__(11, [
                                                        " has no type",
                                                        /* End_of_format */0
                                                      ])
                                                  ])
                                              ]),
                                            "The present constructor %s has no type"
                                          ]), param$1[0]);
                        case /* Constructor_mismatch */10 :
                            var ty$prime = param$1[1];
                            var ty = param$1[0];
                            return wrap_printing_env(env, (function (param$2) {
                                          reset_and_mark_loops_list(/* :: */[
                                                ty,
                                                /* :: */[
                                                  ty$prime,
                                                  /* [] */0
                                                ]
                                              ]);
                                          return Curry._6(Format.fprintf(param, /* Format */[
                                                          /* Formatting_gen */Block.__(18, [
                                                              /* Open_box */Block.__(1, [/* Format */[
                                                                    /* String_literal */Block.__(11, [
                                                                        "<hov>",
                                                                        /* End_of_format */0
                                                                      ]),
                                                                    "<hov>"
                                                                  ]]),
                                                              /* String */Block.__(2, [
                                                                  /* No_padding */0,
                                                                  /* Char_literal */Block.__(12, [
                                                                      /* " " */32,
                                                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                              /* Break */Block.__(0, [
                                                                                  "@ ",
                                                                                  1,
                                                                                  0
                                                                                ]),
                                                                              /* String */Block.__(2, [
                                                                                  /* No_padding */0,
                                                                                  /* Formatting_lit */Block.__(17, [
                                                                                      /* Break */Block.__(0, [
                                                                                          "@ ",
                                                                                          1,
                                                                                          0
                                                                                        ]),
                                                                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                              /* Close_box */0,
                                                                                              /* End_of_format */0
                                                                                            ])])
                                                                                    ])
                                                                                ])
                                                                            ])])
                                                                    ])
                                                                ])
                                                            ]),
                                                          "@[<hov>%s %a@ %s@ %a@]"
                                                        ]), "This variant type contains a constructor", type_expr$1, ty, "which should be", type_expr$1, ty$prime);
                                        }));
                        case /* Not_a_variant */11 :
                            var ty$1 = param$1[0];
                            reset(void 0);
                            mark_loops(ty$1);
                            return Curry._2(Format.fprintf(param, /* Format */[
                                            /* Formatting_gen */Block.__(18, [
                                                /* Open_box */Block.__(1, [/* Format */[
                                                      /* End_of_format */0,
                                                      ""
                                                    ]]),
                                                /* String_literal */Block.__(11, [
                                                    "The type ",
                                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                            /* Break */Block.__(0, [
                                                                "@ ",
                                                                1,
                                                                0
                                                              ]),
                                                            /* String_literal */Block.__(11, [
                                                                "is not a polymorphic variant type",
                                                                /* Formatting_lit */Block.__(17, [
                                                                    /* Close_box */0,
                                                                    /* End_of_format */0
                                                                  ])
                                                              ])
                                                          ])])
                                                  ])
                                              ]),
                                            "@[The type %a@ is not a polymorphic variant type@]"
                                          ]), type_expr$1, ty$1);
                        case /* Variant_tags */12 :
                            return Curry._3(Format.fprintf(param, /* Format */[
                                            /* Formatting_gen */Block.__(18, [
                                                /* Open_box */Block.__(1, [/* Format */[
                                                      /* End_of_format */0,
                                                      ""
                                                    ]]),
                                                /* String_literal */Block.__(11, [
                                                    "Variant tags `",
                                                    /* String */Block.__(2, [
                                                        /* No_padding */0,
                                                        /* Formatting_lit */Block.__(17, [
                                                            /* Break */Block.__(0, [
                                                                "@ ",
                                                                1,
                                                                0
                                                              ]),
                                                            /* String_literal */Block.__(11, [
                                                                "and `",
                                                                /* String */Block.__(2, [
                                                                    /* No_padding */0,
                                                                    /* String_literal */Block.__(11, [
                                                                        " have the same hash value.",
                                                                        /* Formatting_lit */Block.__(17, [
                                                                            /* Break */Block.__(0, [
                                                                                "@ ",
                                                                                1,
                                                                                0
                                                                              ]),
                                                                            /* String */Block.__(2, [
                                                                                /* No_padding */0,
                                                                                /* Formatting_lit */Block.__(17, [
                                                                                    /* Close_box */0,
                                                                                    /* End_of_format */0
                                                                                  ])
                                                                              ])
                                                                          ])
                                                                      ])
                                                                  ])
                                                              ])
                                                          ])
                                                      ])
                                                  ])
                                              ]),
                                            "@[Variant tags `%s@ and `%s have the same hash value.@ %s@]"
                                          ]), param$1[0], param$1[1], "Change one of them.");
                        case /* Invalid_variable_name */13 :
                            return Curry._1(Format.fprintf(param, /* Format */[
                                            /* String_literal */Block.__(11, [
                                                "The type variable name ",
                                                /* String */Block.__(2, [
                                                    /* No_padding */0,
                                                    /* String_literal */Block.__(11, [
                                                        " is not allowed in programs",
                                                        /* End_of_format */0
                                                      ])
                                                  ])
                                              ]),
                                            "The type variable name %s is not allowed in programs"
                                          ]), param$1[0]);
                        case /* Cannot_quantify */14 :
                            var v = param$1[1];
                            return Curry._2(Format.fprintf(param, /* Format */[
                                            /* Formatting_gen */Block.__(18, [
                                                /* Open_box */Block.__(1, [/* Format */[
                                                      /* String_literal */Block.__(11, [
                                                          "<hov>",
                                                          /* End_of_format */0
                                                        ]),
                                                      "<hov>"
                                                    ]]),
                                                /* String_literal */Block.__(11, [
                                                    "The universal type variable '",
                                                    /* String */Block.__(2, [
                                                        /* No_padding */0,
                                                        /* String_literal */Block.__(11, [
                                                            " cannot be generalized:",
                                                            /* Formatting_lit */Block.__(17, [
                                                                /* Break */Block.__(0, [
                                                                    "@ ",
                                                                    1,
                                                                    0
                                                                  ]),
                                                                /* String */Block.__(2, [
                                                                    /* No_padding */0,
                                                                    /* Char_literal */Block.__(12, [
                                                                        /* "." */46,
                                                                        /* Formatting_lit */Block.__(17, [
                                                                            /* Close_box */0,
                                                                            /* End_of_format */0
                                                                          ])
                                                                      ])
                                                                  ])
                                                              ])
                                                          ])
                                                      ])
                                                  ])
                                              ]),
                                            "@[<hov>The universal type variable '%s cannot be generalized:@ %s.@]"
                                          ]), param$1[0], is_Tvar(v) ? "it escapes its scope" : (
                                          is_Tunivar(v) ? "it is already bound to another variable" : "it is not a variable"
                                        ));
                        case /* Multiple_constraints_on_type */15 :
                            return Curry._2(Format.fprintf(param, /* Format */[
                                            /* String_literal */Block.__(11, [
                                                "Multiple constraints for type ",
                                                /* Alpha */Block.__(15, [/* End_of_format */0])
                                              ]),
                                            "Multiple constraints for type %a"
                                          ]), longident, param$1[0]);
                        case /* Repeated_method_label */16 :
                            return Curry._2(Format.fprintf(param, /* Format */[
                                            /* Formatting_gen */Block.__(18, [
                                                /* Open_box */Block.__(1, [/* Format */[
                                                      /* End_of_format */0,
                                                      ""
                                                    ]]),
                                                /* String_literal */Block.__(11, [
                                                    "This is the second method `",
                                                    /* String */Block.__(2, [
                                                        /* No_padding */0,
                                                        /* String_literal */Block.__(11, [
                                                            "' of this object type.",
                                                            /* Formatting_lit */Block.__(17, [
                                                                /* Break */Block.__(0, [
                                                                    "@ ",
                                                                    1,
                                                                    0
                                                                  ]),
                                                                /* String */Block.__(2, [
                                                                    /* No_padding */0,
                                                                    /* Formatting_lit */Block.__(17, [
                                                                        /* Close_box */0,
                                                                        /* End_of_format */0
                                                                      ])
                                                                  ])
                                                              ])
                                                          ])
                                                      ])
                                                  ])
                                              ]),
                                            "@[This is the second method `%s' of this object type.@ %s@]"
                                          ]), param$1[0], "Multiple occurences are not allowed.");
                        case /* Unbound_value */17 :
                            var lid$1 = param$1[0];
                            Curry._2(Format.fprintf(param, /* Format */[
                                      /* String_literal */Block.__(11, [
                                          "Unbound value ",
                                          /* Alpha */Block.__(15, [/* End_of_format */0])
                                        ]),
                                      "Unbound value %a"
                                    ]), longident, lid$1);
                            return spellcheck$1(param, fold_values)(env, lid$1);
                        case /* Unbound_constructor */18 :
                            var lid$2 = param$1[0];
                            Curry._2(Format.fprintf(param, /* Format */[
                                      /* String_literal */Block.__(11, [
                                          "Unbound constructor ",
                                          /* Alpha */Block.__(15, [/* End_of_format */0])
                                        ]),
                                      "Unbound constructor %a"
                                    ]), longident, lid$2);
                            return spellcheck_simple(param, fold_constructors, (function (d) {
                                            return d.cstr_name;
                                          }))(env, lid$2);
                        case /* Unbound_label */19 :
                            var lid$3 = param$1[0];
                            Curry._2(Format.fprintf(param, /* Format */[
                                      /* String_literal */Block.__(11, [
                                          "Unbound record field ",
                                          /* Alpha */Block.__(15, [/* End_of_format */0])
                                        ]),
                                      "Unbound record field %a"
                                    ]), longident, lid$3);
                            return spellcheck_simple(param, fold_labels, (function (d) {
                                            return d.lbl_name;
                                          }))(env, lid$3);
                        case /* Unbound_module */20 :
                            var lid$4 = param$1[0];
                            Curry._2(Format.fprintf(param, /* Format */[
                                      /* String_literal */Block.__(11, [
                                          "Unbound module ",
                                          /* Alpha */Block.__(15, [/* End_of_format */0])
                                        ]),
                                      "Unbound module %a"
                                    ]), longident, lid$4);
                            return spellcheck$1(param, fold_modules)(env, lid$4);
                        case /* Unbound_class */21 :
                            var lid$5 = param$1[0];
                            Curry._2(Format.fprintf(param, /* Format */[
                                      /* String_literal */Block.__(11, [
                                          "Unbound class ",
                                          /* Alpha */Block.__(15, [/* End_of_format */0])
                                        ]),
                                      "Unbound class %a"
                                    ]), longident, lid$5);
                            return spellcheck$1(param, fold_classs)(env, lid$5);
                        case /* Unbound_modtype */22 :
                            var lid$6 = param$1[0];
                            Curry._2(Format.fprintf(param, /* Format */[
                                      /* String_literal */Block.__(11, [
                                          "Unbound module type ",
                                          /* Alpha */Block.__(15, [/* End_of_format */0])
                                        ]),
                                      "Unbound module type %a"
                                    ]), longident, lid$6);
                            return spellcheck$1(param, fold_modtypes)(env, lid$6);
                        case /* Unbound_cltype */23 :
                            var lid$7 = param$1[0];
                            Curry._2(Format.fprintf(param, /* Format */[
                                      /* String_literal */Block.__(11, [
                                          "Unbound class type ",
                                          /* Alpha */Block.__(15, [/* End_of_format */0])
                                        ]),
                                      "Unbound class type %a"
                                    ]), longident, lid$7);
                            return spellcheck$1(param, fold_cltypes)(env, lid$7);
                        case /* Ill_typed_functor_application */24 :
                            return Curry._2(Format.fprintf(param, /* Format */[
                                            /* String_literal */Block.__(11, [
                                                "Ill-typed functor application ",
                                                /* Alpha */Block.__(15, [/* End_of_format */0])
                                              ]),
                                            "Ill-typed functor application %a"
                                          ]), longident, param$1[0]);
                        case /* Access_functor_as_structure */25 :
                            return Curry._2(Format.fprintf(param, /* Format */[
                                            /* String_literal */Block.__(11, [
                                                "The module ",
                                                /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                                        " is a functor, not a structure",
                                                        /* End_of_format */0
                                                      ])])
                                              ]),
                                            "The module %a is a functor, not a structure"
                                          ]), longident, param$1[0]);
                        
                      }
                    }), param[3]);
      }));

var $$Error$7 = Caml_exceptions.create("Ocaml_typedtree_test.Typecore.Error");

var Error_forward$1 = Caml_exceptions.create("Ocaml_typedtree_test.Typecore.Error_forward");

var type_module = {
  contents: (function (env, md) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "typecore.ml",
              77,
              22
            ]
          ];
    })
};

var type_open = {
  contents: (function (param) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "typecore.ml",
              83,
              16
            ]
          ];
    })
};

var type_package = {
  contents: (function (param) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "typecore.ml",
              88,
              16
            ]
          ];
    })
};

var type_object = {
  contents: (function (env, s) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "typecore.ml",
              92,
              20
            ]
          ];
    })
};

function re(node) {
  add_saved_type(/* Partial_expression */Block.__(2, [node]));
  record$2(/* Ti_expr */Block.__(1, [node]));
  return node;
}

function rp(node) {
  add_saved_type(/* Partial_pattern */Block.__(3, [node]));
  record$2(/* Ti_pat */Block.__(0, [node]));
  return node;
}

function snd3(param) {
  return param[1];
}

function iter_expression(f, e) {
  var expr = function (_e) {
    while(true) {
      var e = _e;
      Curry._1(f, e);
      var match = e.pexp_desc;
      switch (match.tag | 0) {
        case /* Pexp_let */2 :
            expr(match[2]);
            return List.iter(binding, match[1]);
        case /* Pexp_function */3 :
            return List.iter($$case, match[0]);
        case /* Pexp_fun */4 :
            may(expr, match[1]);
            _e = match[3];
            continue ;
        case /* Pexp_apply */5 :
            expr(match[0]);
            return List.iter((function (param) {
                          return expr(param[1]);
                        }), match[1]);
        case /* Pexp_match */6 :
        case /* Pexp_try */7 :
            break;
        case /* Pexp_construct */9 :
        case /* Pexp_variant */10 :
            return may(expr, match[1]);
        case /* Pexp_record */11 :
            may(expr, match[1]);
            return List.iter((function (param) {
                          return expr(param[1]);
                        }), match[0]);
        case /* Pexp_setfield */13 :
            expr(match[0]);
            _e = match[2];
            continue ;
        case /* Pexp_tuple */8 :
        case /* Pexp_array */14 :
            return List.iter(expr, match[0]);
        case /* Pexp_ifthenelse */15 :
            expr(match[0]);
            expr(match[1]);
            return may(expr, match[2]);
        case /* Pexp_sequence */16 :
        case /* Pexp_while */17 :
            expr(match[0]);
            _e = match[1];
            continue ;
        case /* Pexp_for */18 :
            expr(match[1]);
            expr(match[2]);
            _e = match[4];
            continue ;
        case /* Pexp_override */24 :
            return List.iter((function (param) {
                          return expr(param[1]);
                        }), match[0]);
        case /* Pexp_letmodule */25 :
            expr(match[2]);
            return module_expr(match[1]);
        case /* Pexp_object */29 :
            return List.iter(class_field, match[0].pcstr_fields);
        case /* Pexp_setinstvar */23 :
        case /* Pexp_newtype */30 :
            _e = match[1];
            continue ;
        case /* Pexp_pack */31 :
            return module_expr(match[0]);
        case /* Pexp_open */32 :
            _e = match[2];
            continue ;
        case /* Pexp_ident */0 :
        case /* Pexp_constant */1 :
        case /* Pexp_new */22 :
        case /* Pexp_extension */33 :
            return ;
        default:
          _e = match[0];
          continue ;
      }
      expr(match[0]);
      return List.iter($$case, match[1]);
    };
  };
  var $$case = function (param) {
    may(expr, param.pc_guard);
    return expr(param.pc_rhs);
  };
  var binding = function (x) {
    return expr(x.pvb_expr);
  };
  var module_expr = function (_me) {
    while(true) {
      var me = _me;
      var match = me.pmod_desc;
      switch (match.tag | 0) {
        case /* Pmod_structure */1 :
            return List.iter(structure_item, match[0]);
        case /* Pmod_functor */2 :
            _me = match[2];
            continue ;
        case /* Pmod_apply */3 :
            module_expr(match[0]);
            _me = match[1];
            continue ;
        case /* Pmod_constraint */4 :
            _me = match[0];
            continue ;
        case /* Pmod_unpack */5 :
            return expr(match[0]);
        case /* Pmod_ident */0 :
        case /* Pmod_extension */6 :
            return ;
        
      }
    };
  };
  var structure_item = function (str) {
    var match = str.pstr_desc;
    switch (match.tag | 0) {
      case /* Pstr_eval */0 :
          return expr(match[0]);
      case /* Pstr_value */1 :
          return List.iter(binding, match[1]);
      case /* Pstr_module */6 :
          return module_expr(match[0].pmb_expr);
      case /* Pstr_recmodule */7 :
          return List.iter((function (x) {
                        return module_expr(x.pmb_expr);
                      }), match[0]);
      case /* Pstr_class */10 :
          return List.iter((function (c) {
                        return class_expr(c.pci_expr);
                      }), match[0]);
      case /* Pstr_include */12 :
          return module_expr(match[0].pincl_mod);
      default:
        return ;
    }
  };
  var class_expr = function (_ce) {
    while(true) {
      var ce = _ce;
      var match = ce.pcl_desc;
      switch (match.tag | 0) {
        case /* Pcl_structure */1 :
            return List.iter(class_field, match[0].pcstr_fields);
        case /* Pcl_fun */2 :
            may(expr, match[1]);
            _ce = match[3];
            continue ;
        case /* Pcl_apply */3 :
            class_expr(match[0]);
            return List.iter((function (param) {
                          return expr(param[1]);
                        }), match[1]);
        case /* Pcl_let */4 :
            List.iter(binding, match[1]);
            _ce = match[2];
            continue ;
        case /* Pcl_constraint */5 :
            _ce = match[0];
            continue ;
        case /* Pcl_constr */0 :
        case /* Pcl_extension */6 :
            return ;
        
      }
    };
  };
  var class_field = function (cf) {
    var match = cf.pcf_desc;
    switch (match.tag | 0) {
      case /* Pcf_inherit */0 :
          return class_expr(match[1]);
      case /* Pcf_val */1 :
          var match$1 = match[0][2];
          if (match$1.tag) {
            return expr(match$1[1]);
          } else {
            return ;
          }
      case /* Pcf_method */2 :
          var match$2 = match[0][2];
          if (match$2.tag) {
            return expr(match$2[1]);
          } else {
            return ;
          }
      case /* Pcf_initializer */4 :
          return expr(match[0]);
      case /* Pcf_constraint */3 :
      case /* Pcf_attribute */5 :
      case /* Pcf_extension */6 :
          return ;
      
    }
  };
  return expr(e);
}

function all_idents_cases(el) {
  var idents = Hashtbl.create(void 0, 8);
  var f = function (param) {
    var match = param.pexp_desc;
    if (match.tag) {
      return ;
    }
    var match$1 = match[0].txt;
    switch (match$1.tag | 0) {
      case /* Lident */0 :
          return Hashtbl.replace(idents, match$1[0], void 0);
      case /* Ldot */1 :
      case /* Lapply */2 :
          return ;
      
    }
  };
  List.iter((function (cp) {
          may((function (param) {
                  return iter_expression(f, param);
                }), cp.pc_guard);
          return iter_expression(f, cp.pc_rhs);
        }), el);
  return Hashtbl.fold((function (x, param, rest) {
                return /* :: */[
                        x,
                        rest
                      ];
              }), idents, /* [] */0);
}

function type_constant(param) {
  switch (param.tag | 0) {
    case /* Const_int */0 :
        return instance_def(type_int);
    case /* Const_char */1 :
        return instance_def(type_char);
    case /* Const_string */2 :
        return instance_def(type_string);
    case /* Const_float */3 :
        return instance_def(type_float);
    case /* Const_int32 */4 :
        return instance_def(type_int32);
    case /* Const_int64 */5 :
        return instance_def(type_int64);
    case /* Const_nativeint */6 :
        return instance_def(type_nativeint);
    
  }
}

function type_option$1(ty) {
  return newty2(current_level.contents, /* Tconstr */Block.__(3, [
                path_option,
                /* :: */[
                  ty,
                  /* [] */0
                ],
                {
                  contents: /* Mnil */0
                }
              ]));
}

function mkexp$1(exp_desc, exp_type, exp_loc, exp_env) {
  return {
          exp_desc: exp_desc,
          exp_loc: exp_loc,
          exp_extra: /* [] */0,
          exp_type: exp_type,
          exp_env: exp_env,
          exp_attributes: /* [] */0
        };
}

function option_none(ty, loc) {
  var lid = /* Lident */Block.__(0, ["None"]);
  var cnone = lookup_constructor(lid, initial_safe_string);
  return mkexp$1(/* Texp_construct */Block.__(8, [
                {
                  txt: lid,
                  loc: none
                },
                cnone,
                /* [] */0
              ]), ty, loc, initial_safe_string);
}

function option_some(texp) {
  var lid = /* Lident */Block.__(0, ["Some"]);
  var csome = lookup_constructor(lid, initial_safe_string);
  return mkexp$1(/* Texp_construct */Block.__(8, [
                {
                  txt: lid,
                  loc: none
                },
                csome,
                /* :: */[
                  texp,
                  /* [] */0
                ]
              ]), type_option$1(texp.exp_type), texp.exp_loc, texp.exp_env);
}

function extract_option_type(env, ty) {
  var match = expand_head(env, ty);
  var match$1 = match.desc;
  if (typeof match$1 !== "number" && match$1.tag === /* Tconstr */3) {
    var match$2 = match$1[1];
    if (match$2 && !match$2[1] && same(match$1[0], path_option)) {
      return match$2[0];
    }
    
  }
  throw [
        Caml_builtin_exceptions.assert_failure,
        /* tuple */[
          "typecore.ml",
          275,
          9
        ]
      ];
}

function extract_concrete_record(env, ty) {
  var match = extract_concrete_typedecl(env, ty);
  var match$1 = match[2].type_kind;
  if (typeof match$1 === "number") {
    throw Caml_builtin_exceptions.not_found;
  }
  if (match$1.tag) {
    throw Caml_builtin_exceptions.not_found;
  }
  return /* tuple */[
          match[0],
          match[1],
          match$1[0]
        ];
}

function extract_concrete_variant(env, ty) {
  var match = extract_concrete_typedecl(env, ty);
  var match$1 = match[2].type_kind;
  var p = match[1];
  var p0 = match[0];
  if (typeof match$1 === "number") {
    if (match$1 === /* Type_abstract */0) {
      throw Caml_builtin_exceptions.not_found;
    }
    return /* tuple */[
            p0,
            p,
            /* [] */0
          ];
  } else {
    if (match$1.tag) {
      return /* tuple */[
              p0,
              p,
              match$1[0]
            ];
    }
    throw Caml_builtin_exceptions.not_found;
  }
}

function extract_label_names(sexp, env, ty) {
  try {
    var match = extract_concrete_record(env, ty);
    return List.map((function (l) {
                  return l.ld_id;
                }), match[2]);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "typecore.ml",
              293,
              4
            ]
          ];
    }
    throw exn;
  }
}

function explicit_arity(param) {
  return List.exists((function (param) {
                switch (param[0].txt) {
                  case "explicit_arity" :
                  case "ocaml.explicit_arity" :
                      return true;
                  default:
                    return false;
                }
              }), param);
}

function unify_pat_types(loc, env, ty, ty$prime) {
  try {
    return unify$2(env, ty, ty$prime);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === Unify) {
      throw [
            $$Error$7,
            loc,
            env,
            /* Pattern_type_clash */Block.__(3, [exn[1]])
          ];
    }
    if (exn[0] === Tags) {
      throw [
            $$Error$6,
            loc,
            env,
            /* Variant_tags */Block.__(12, [
                exn[1],
                exn[2]
              ])
          ];
    }
    throw exn;
  }
}

function unify_exp_types(loc, env, ty, expected_ty) {
  try {
    return unify$2(env, ty, expected_ty);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === Unify) {
      throw [
            $$Error$7,
            loc,
            env,
            /* Expr_type_clash */Block.__(7, [exn[1]])
          ];
    }
    if (exn[0] === Tags) {
      throw [
            $$Error$6,
            loc,
            env,
            /* Variant_tags */Block.__(12, [
                exn[1],
                exn[2]
              ])
          ];
    }
    throw exn;
  }
}

var newtype_level$1 = {
  contents: void 0
};

function get_newtype_level$1(param) {
  var match = newtype_level$1.contents;
  if (match !== void 0) {
    return match;
  }
  throw [
        Caml_builtin_exceptions.assert_failure,
        /* tuple */[
          "typecore.ml",
          331,
          12
        ]
      ];
}

function unify_pat_types_gadt(loc, env, ty, ty$prime) {
  var match = newtype_level$1.contents;
  var newtype_level$2;
  if (match === void 0) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "typecore.ml",
            336,
            14
          ]
        ];
  }
  newtype_level$2 = match;
  try {
    try {
      univar_pairs.contents = /* [] */0;
      newtype_level.contents = newtype_level$2;
      set_mode_pattern(true, true, (function (param) {
              return unify$1(env, ty, ty$prime);
            }));
      newtype_level.contents = void 0;
      return Curry._1(TypePairs.clear, unify_eq_set);
    }
    catch (raw_e){
      var e = Caml_js_exceptions.internalToOCamlException(raw_e);
      Curry._1(TypePairs.clear, unify_eq_set);
      if (e[0] === Unify) {
        throw [
              Unify,
              e[1]
            ];
      }
      newtype_level.contents = void 0;
      throw e;
    }
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === Unify) {
      throw [
            $$Error$7,
            loc,
            env.contents,
            /* Pattern_type_clash */Block.__(3, [exn[1]])
          ];
    }
    if (exn[0] === Tags) {
      throw [
            $$Error$6,
            loc,
            env.contents,
            /* Variant_tags */Block.__(12, [
                exn[1],
                exn[2]
              ])
          ];
    }
    if (exn[0] === Unification_recursive_abbrev) {
      throw [
            $$Error$7,
            loc,
            env.contents,
            /* Recursive_local_constraint */Block.__(33, [exn[1]])
          ];
    }
    throw exn;
  }
}

function unify_pat(env, pat, expected_ty) {
  return unify_pat_types(pat.pat_loc, env, pat.pat_type, expected_ty);
}

function finalize_variant(pat) {
  var match = pat.pat_desc;
  if (typeof match === "number") {
    return ;
  }
  if (match.tag !== /* Tpat_variant */5) {
    return ;
  }
  var opat = match[1];
  var match$1 = expand_head(pat.pat_env, pat.pat_type);
  var match$2 = match$1.desc;
  var row;
  if (typeof match$2 === "number") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "typecore.ml",
            362,
            15
          ]
        ];
  }
  if (match$2.tag !== /* Tvariant */8) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "typecore.ml",
            362,
            15
          ]
        ];
  }
  var row$1 = match$2[0];
  match[2].contents = row$1;
  row = row_repr_aux(/* [] */0, row$1);
  var match$3 = row_field(match[0], row);
  if (typeof match$3 === "number") {
    return ;
  }
  if (!match$3.tag) {
    return ;
  }
  var c = match$3[0];
  if (c) {
    if (!match$3[1] && !row.row_closed) {
      return set_row_field(match$3[3], /* Rpresent */Block.__(0, [void 0]));
    }
    
  } else {
    var match$4 = match$3[1];
    if (match$4 && !row.row_closed) {
      var ty = match$4[0];
      set_row_field(match$3[3], /* Rpresent */Block.__(0, [ty]));
      if (opat === void 0) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "typecore.ml",
                370,
                40
              ]
            ];
      }
      var pat$1 = opat;
      var partial_arg = pat$1.pat_env;
      return List.iter((function (param) {
                    return unify_pat(partial_arg, pat$1, param);
                  }), /* :: */[
                  ty,
                  match$4[1]
                ]);
    }
    
  }
  if (match$3[2] && !row_fixed(row)) {
    return set_row_field(match$3[3], /* Reither */Block.__(1, [
                  c,
                  /* [] */0,
                  false,
                  {
                    contents: void 0
                  }
                ]));
  }
  
}

function iter_pattern(f, p) {
  Curry._1(f, p);
  return iter_pattern_desc((function (param) {
                return iter_pattern(f, param);
              }), p.pat_desc);
}

function has_variants(p) {
  try {
    iter_pattern((function (param) {
            var tmp = param.pat_desc;
            if (typeof tmp === "number") {
              return ;
            }
            if (tmp.tag === /* Tpat_variant */5) {
              throw Pervasives.Exit;
            }
            
          }), p);
    return false;
  }
  catch (exn){
    if (exn === Pervasives.Exit) {
      return true;
    }
    throw exn;
  }
}

var pattern_variables = {
  contents: /* [] */0
};

var pattern_force = {
  contents: /* [] */0
};

var pattern_scope = {
  contents: void 0
};

var allow_modules = {
  contents: false
};

var module_variables = {
  contents: /* [] */0
};

function reset_pattern(scope, allow) {
  pattern_variables.contents = /* [] */0;
  pattern_force.contents = /* [] */0;
  pattern_scope.contents = scope;
  allow_modules.contents = allow;
  module_variables.contents = /* [] */0;
  
}

function enter_variable(is_moduleOpt, is_as_variableOpt, loc, name, ty) {
  var is_module = is_moduleOpt !== void 0 ? is_moduleOpt : false;
  var is_as_variable = is_as_variableOpt !== void 0 ? is_as_variableOpt : false;
  if (List.exists((function (param) {
            return param[0].name === name.txt;
          }), pattern_variables.contents)) {
    throw [
          $$Error$7,
          loc,
          empty,
          /* Multiply_bound_variable */Block.__(5, [name.txt])
        ];
  }
  var id = create(name.txt);
  pattern_variables.contents = /* :: */[
    /* tuple */[
      id,
      ty,
      name,
      loc,
      is_as_variable
    ],
    pattern_variables.contents
  ];
  if (is_module) {
    if (!allow_modules.contents) {
      throw [
            $$Error$7,
            loc,
            empty,
            /* Modules_not_allowed */2
          ];
    }
    module_variables.contents = /* :: */[
      /* tuple */[
        name,
        loc
      ],
      module_variables.contents
    ];
  } else {
    may((function (s) {
            return record$2(/* An_ident */Block.__(5, [
                          name.loc,
                          name.txt,
                          s
                        ]));
          }), pattern_scope.contents);
  }
  return id;
}

function sort_pattern_variables(vs) {
  return List.sort((function (param, param$1) {
                return Caml_primitive.caml_string_compare(param[0].name, param$1[0].name);
              }), vs);
}

function enter_orpat_variables(loc, env, p1_vs, p2_vs) {
  var p1_vs$1 = sort_pattern_variables(p1_vs);
  var p2_vs$1 = sort_pattern_variables(p2_vs);
  var unify_vars = function (_p1_vs, _p2_vs) {
    while(true) {
      var p2_vs = _p2_vs;
      var p1_vs = _p1_vs;
      if (p1_vs) {
        var match = p1_vs[0];
        var x1 = match[0];
        if (!p2_vs) {
          throw [
                $$Error$7,
                loc,
                env,
                /* Orpat_vars */Block.__(6, [x1])
              ];
        }
        var rem2 = p2_vs[1];
        var match$1 = p2_vs[0];
        var x2 = match$1[0];
        var rem1 = p1_vs[1];
        if (equal(x1, x2)) {
          if (x1 === x2) {
            _p2_vs = rem2;
            _p1_vs = rem1;
            continue ;
          } else {
            try {
              unify$2(env, match[1], match$1[1]);
            }
            catch (raw_exn){
              var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
              if (exn[0] === Unify) {
                throw [
                      $$Error$7,
                      loc,
                      env,
                      /* Or_pattern_type_clash */Block.__(4, [
                          x1,
                          exn[1]
                        ])
                    ];
              }
              throw exn;
            }
            return /* :: */[
                    /* tuple */[
                      x2,
                      x1
                    ],
                    unify_vars(rem1, rem2)
                  ];
          }
        } else {
          var min_var = x1.name < x2.name ? x1 : x2;
          throw [
                $$Error$7,
                loc,
                env,
                /* Orpat_vars */Block.__(6, [min_var])
              ];
        }
      } else {
        if (p2_vs) {
          throw [
                $$Error$7,
                loc,
                env,
                /* Orpat_vars */Block.__(6, [p2_vs[0][0]])
              ];
        }
        return /* [] */0;
      }
    };
  };
  return unify_vars(p1_vs$1, p2_vs$1);
}

function build_as_type(env, _p) {
  while(true) {
    var p = _p;
    var match = p.pat_desc;
    if (typeof match === "number") {
      return p.pat_type;
    }
    switch (match.tag | 0) {
      case /* Tpat_alias */1 :
          _p = match[0];
          continue ;
      case /* Tpat_tuple */3 :
          var tyl = List.map((function (param) {
                  return build_as_type(env, param);
                }), match[0]);
          return newty2(current_level.contents, /* Ttuple */Block.__(2, [tyl]));
      case /* Tpat_construct */4 :
          var pl = match[2];
          var cstr = match[1];
          var keep = cstr.cstr_private === /* Private */0 || cstr.cstr_existentials !== /* [] */0;
          if (keep) {
            return p.pat_type;
          }
          var tyl$1 = List.map((function (param) {
                  return build_as_type(env, param);
                }), pl);
          var match$1 = instance_constructor(void 0, cstr);
          List.iter2((function (param) {
                  var p = param[0];
                  var partial_arg = {
                    pat_desc: p.pat_desc,
                    pat_loc: p.pat_loc,
                    pat_extra: p.pat_extra,
                    pat_type: param[1],
                    pat_env: p.pat_env,
                    pat_attributes: p.pat_attributes
                  };
                  return (function (param) {
                      return unify_pat(env, partial_arg, param);
                    });
                }), List.combine(pl, tyl$1), match$1[0]);
          return match$1[1];
      case /* Tpat_variant */5 :
          var ty = may_map((function (param) {
                  return build_as_type(env, param);
                }), match[1]);
          var desc = /* Tvariant */Block.__(8, [{
                row_fields: /* :: */[
                  /* tuple */[
                    match[0],
                    /* Rpresent */Block.__(0, [ty])
                  ],
                  /* [] */0
                ],
                row_more: newvar(void 0, void 0),
                row_bound: void 0,
                row_closed: false,
                row_fixed: false,
                row_name: void 0
              }]);
          return newty2(current_level.contents, desc);
      case /* Tpat_record */6 :
          var lpl = match[0];
          var lbl = snd3(List.hd(lpl));
          if (lbl.lbl_private === /* Private */0) {
            return p.pat_type;
          }
          var ty$1 = newvar(void 0, void 0);
          var ppl = List.map((function (param) {
                  return /* tuple */[
                          param[1].lbl_pos,
                          param[2]
                        ];
                }), lpl);
          var do_label = (function(p,ty$1,ppl){
          return function do_label(lbl) {
            var match = instance_label(false, lbl);
            var ty_arg = match[1];
            unify_pat(env, {
                  pat_desc: p.pat_desc,
                  pat_loc: p.pat_loc,
                  pat_extra: p.pat_extra,
                  pat_type: ty$1,
                  pat_env: p.pat_env,
                  pat_attributes: p.pat_attributes
                }, match[2]);
            var refinable = false;
            if (lbl.lbl_mut === /* Immutable */0) {
              var tmp = false;
              if (List.mem_assoc(lbl.lbl_pos, ppl)) {
                var match$1 = repr(lbl.lbl_arg).desc;
                var tmp$1;
                tmp$1 = typeof match$1 === "number" || match$1.tag !== /* Tpoly */10 ? true : false;
                tmp = tmp$1;
              }
              refinable = tmp;
            }
            if (refinable) {
              var arg = List.assoc(lbl.lbl_pos, ppl);
              return unify_pat(env, {
                          pat_desc: arg.pat_desc,
                          pat_loc: arg.pat_loc,
                          pat_extra: arg.pat_extra,
                          pat_type: build_as_type(env, arg),
                          pat_env: arg.pat_env,
                          pat_attributes: arg.pat_attributes
                        }, ty_arg);
            } else {
              var match$2 = instance_label(false, lbl);
              unify$2(env, ty_arg, match$2[1]);
              return unify_pat(env, p, match$2[2]);
            }
          }
          }(p,ty$1,ppl));
          $$Array.iter(do_label, lbl.lbl_all);
          return ty$1;
      case /* Tpat_or */8 :
          var row = match[2];
          var p2 = match[1];
          if (row !== void 0) {
            var row$1 = row_repr_aux(/* [] */0, row);
            var desc$1 = /* Tvariant */Block.__(8, [{
                  row_fields: row$1.row_fields,
                  row_more: newvar(void 0, void 0),
                  row_bound: row$1.row_bound,
                  row_closed: false,
                  row_fixed: row$1.row_fixed,
                  row_name: row$1.row_name
                }]);
            return newty2(current_level.contents, desc$1);
          } else {
            var ty1 = build_as_type(env, match[0]);
            var ty2 = build_as_type(env, p2);
            unify_pat(env, {
                  pat_desc: p2.pat_desc,
                  pat_loc: p2.pat_loc,
                  pat_extra: p2.pat_extra,
                  pat_type: ty2,
                  pat_env: p2.pat_env,
                  pat_attributes: p2.pat_attributes
                }, ty1);
            return ty1;
          }
      default:
        return p.pat_type;
    }
  };
}

function build_or_pat(env, loc, lid) {
  var match = find_type(env, loc, lid);
  var path = match[0];
  var tyl = List.map((function (param) {
          return newvar(void 0, void 0);
        }), match[1].type_params);
  var ty = expand_head(env, newty2(current_level.contents, /* Tconstr */Block.__(3, [
              path,
              tyl,
              {
                contents: /* Mnil */0
              }
            ])));
  var match$1 = ty.desc;
  var row0;
  var exit = 0;
  if (typeof match$1 === "number" || match$1.tag !== /* Tvariant */8) {
    exit = 1;
  } else {
    var row = match$1[0];
    if (static_row(row)) {
      row0 = row;
    } else {
      exit = 1;
    }
  }
  if (exit === 1) {
    throw [
          $$Error$7,
          loc,
          env,
          /* Not_a_variant_type */Block.__(30, [lid])
        ];
  }
  var match$2 = List.fold_left((function (param, param$1) {
          var l = param$1[0];
          var fields = param[1];
          var pats = param[0];
          var match = row_field_repr_aux(/* [] */0, param$1[1]);
          if (typeof match === "number") {
            return /* tuple */[
                    pats,
                    fields
                  ];
          }
          if (match.tag) {
            return /* tuple */[
                    pats,
                    fields
                  ];
          }
          var match$1 = match[0];
          if (match$1 === void 0) {
            return /* tuple */[
                    /* :: */[
                      /* tuple */[
                        l,
                        void 0
                      ],
                      pats
                    ],
                    /* :: */[
                      /* tuple */[
                        l,
                        /* Reither */Block.__(1, [
                            true,
                            /* [] */0,
                            true,
                            {
                              contents: void 0
                            }
                          ])
                      ],
                      fields
                    ]
                  ];
          }
          var ty = match$1;
          return /* tuple */[
                  /* :: */[
                    /* tuple */[
                      l,
                      {
                        pat_desc: /* Tpat_any */0,
                        pat_loc: none,
                        pat_extra: /* [] */0,
                        pat_type: ty,
                        pat_env: env,
                        pat_attributes: /* [] */0
                      }
                    ],
                    pats
                  ],
                  /* :: */[
                    /* tuple */[
                      l,
                      /* Reither */Block.__(1, [
                          false,
                          /* :: */[
                            ty,
                            /* [] */0
                          ],
                          true,
                          {
                            contents: void 0
                          }
                        ])
                    ],
                    fields
                  ]
                ];
        }), /* tuple */[
        /* [] */0,
        /* [] */0
      ], row_repr_aux(/* [] */0, row0).row_fields);
  var row_row_fields = List.rev(match$2[1]);
  var row_row_more = newvar(void 0, void 0);
  var row_row_name = /* tuple */[
    path,
    tyl
  ];
  var row$1 = {
    row_fields: row_row_fields,
    row_more: row_row_more,
    row_bound: void 0,
    row_closed: false,
    row_fixed: false,
    row_name: row_row_name
  };
  var ty$1 = newty2(current_level.contents, /* Tvariant */Block.__(8, [row$1]));
  var gloc_loc_start = loc.loc_start;
  var gloc_loc_end = loc.loc_end;
  var gloc = {
    loc_start: gloc_loc_start,
    loc_end: gloc_loc_end,
    loc_ghost: true
  };
  var row$prime = {
    contents: {
      row_fields: row_row_fields,
      row_more: newvar(void 0, void 0),
      row_bound: void 0,
      row_closed: false,
      row_fixed: false,
      row_name: row_row_name
    }
  };
  var pats = List.map((function (param) {
          return {
                  pat_desc: /* Tpat_variant */Block.__(5, [
                      param[0],
                      param[1],
                      row$prime
                    ]),
                  pat_loc: gloc,
                  pat_extra: /* [] */0,
                  pat_type: ty$1,
                  pat_env: env,
                  pat_attributes: /* [] */0
                };
        }), match$2[0]);
  if (!pats) {
    throw [
          $$Error$7,
          loc,
          env,
          /* Not_a_variant_type */Block.__(30, [lid])
        ];
  }
  var r = List.fold_left((function (pat, pat0) {
          return {
                  pat_desc: /* Tpat_or */Block.__(8, [
                      pat0,
                      pat,
                      row0
                    ]),
                  pat_loc: gloc,
                  pat_extra: /* [] */0,
                  pat_type: ty$1,
                  pat_env: env,
                  pat_attributes: /* [] */0
                };
        }), pats[0], pats[1]);
  return /* tuple */[
          path,
          rp({
                pat_desc: r.pat_desc,
                pat_loc: loc,
                pat_extra: r.pat_extra,
                pat_type: r.pat_type,
                pat_env: r.pat_env,
                pat_attributes: r.pat_attributes
              }),
          ty$1
        ];
}

function expand_path(env, _p) {
  while(true) {
    var p = _p;
    var decl;
    try {
      decl = find_type_full(p, env)[0];
    }
    catch (exn){
      if (exn !== Caml_builtin_exceptions.not_found) {
        throw exn;
      }
      decl = void 0;
    }
    if (decl !== void 0) {
      var match = decl.type_manifest;
      if (match !== void 0) {
        var match$1 = repr(match);
        var match$2 = match$1.desc;
        if (typeof match$2 === "number") {
          return p;
        }
        if (match$2.tag !== /* Tconstr */3) {
          return p;
        }
        _p = match$2[0];
        continue ;
      }
      
    }
    var p$prime = normalize_path$1(void 0, env, p);
    if (same(p, p$prime)) {
      return p;
    }
    _p = p$prime;
    continue ;
  };
}

function compare_type_path(env, tpath1, tpath2) {
  return same(expand_path(env, tpath1), expand_path(env, tpath2));
}

function wrap_disambiguate(kind, ty, f, x) {
  try {
    return Curry._1(f, x);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] !== $$Error$7) {
      throw exn;
    }
    var match = exn[3];
    if (typeof match === "number") {
      throw exn;
    }
    if (match.tag === /* Wrong_name */13) {
      throw [
            $$Error$7,
            exn[1],
            exn[2],
            /* Wrong_name */Block.__(13, [
                kind,
                ty,
                match[2],
                match[3],
                match[4]
              ])
          ];
    }
    throw exn;
  }
}

var type_kind = "record";

function get_type_path$1(env, d) {
  var match = d.lbl_res.desc;
  if (typeof match === "number") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "typecore.ml",
            602,
            11
          ]
        ];
  }
  if (match.tag === /* Tconstr */3) {
    return match[0];
  }
  throw [
        Caml_builtin_exceptions.assert_failure,
        /* tuple */[
          "typecore.ml",
          602,
          11
        ]
      ];
}

function lookup_from_type(env, tpath, lid) {
  var descrs = find_type_full(tpath, env)[1][1];
  mark_type_used(env, last(tpath), find_type_full(tpath, env)[0]);
  var match = lid.txt;
  switch (match.tag | 0) {
    case /* Lident */0 :
        var s = match[0];
        try {
          return List.find((function (nd) {
                        return nd.lbl_name === s;
                      }), descrs);
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            throw [
                  $$Error$7,
                  lid.loc,
                  env,
                  /* Wrong_name */Block.__(13, [
                      "",
                      newvar(void 0, void 0),
                      type_kind,
                      tpath,
                      lid.txt
                    ])
                ];
          }
          throw exn;
        }
    case /* Ldot */1 :
    case /* Lapply */2 :
        throw Caml_builtin_exceptions.not_found;
    
  }
}

function unique(eq, _acc, _param) {
  while(true) {
    var param = _param;
    var acc = _acc;
    if (!param) {
      return List.rev(acc);
    }
    var rem = param[1];
    var x = param[0];
    if (List.exists(Curry._1(eq, x), acc)) {
      _param = rem;
      continue ;
    } else {
      _param = rem;
      _acc = /* :: */[
        x,
        acc
      ];
      continue ;
    }
  };
}

function ambiguous_types(env, lbl, others) {
  var tpath = get_type_path$1(env, lbl);
  var others$1 = List.map((function (param) {
          return get_type_path$1(env, param[0]);
        }), others);
  var tpaths = unique((function (param, param$1) {
          return compare_type_path(env, param, param$1);
        }), /* :: */[
        tpath,
        /* [] */0
      ], others$1);
  if (tpaths && !tpaths[1]) {
    return /* [] */0;
  } else {
    return List.map(string_of_path, tpaths);
  }
}

function disambiguate_by_type(env, tpath, lbls) {
  var check_type = function (param) {
    var lbl_tpath = get_type_path$1(env, param[0]);
    return compare_type_path(env, tpath, lbl_tpath);
  };
  return List.find(check_type, lbls);
}

function disambiguate(warnOpt, check_lkOpt, scope, lid, env, opath, lbls) {
  var warn = warnOpt !== void 0 ? warnOpt : prerr_warning;
  var check_lk = check_lkOpt !== void 0 ? check_lkOpt : (function (param, param$1) {
        
      });
  var scope$1 = scope !== void 0 ? scope : lbls;
  var lbl;
  if (opath !== void 0) {
    var match = opath;
    var pr = match[2];
    var tpath = match[1];
    var warn_pr = function (param) {
      var kind = type_kind === "record" ? "field" : "constructor";
      return Curry._2(warn, lid.loc, /* Not_principal */Block.__(8, ["this type-based " + (kind + " disambiguation")]));
    };
    try {
      var match$1 = disambiguate_by_type(env, tpath, scope$1);
      var lbl$1 = match$1[0];
      Curry._1(match$1[1], void 0);
      if (!pr) {
        if (lbls) {
          var lbl_tpath = get_type_path$1(env, lbls[0][0]);
          if (compare_type_path(env, tpath, lbl_tpath)) {
            var paths = ambiguous_types(env, lbl$1, lbls[1]);
            if (paths !== /* [] */0) {
              Curry._2(warn, lid.loc, /* Ambiguous_name */Block.__(24, [
                      /* :: */[
                        last$1(lid.txt),
                        /* [] */0
                      ],
                      paths,
                      false
                    ]));
            }
            
          } else {
            warn_pr(void 0);
          }
        } else {
          warn_pr(void 0);
        }
      }
      lbl = lbl$1;
    }
    catch (exn){
      if (exn !== Caml_builtin_exceptions.not_found) {
        throw exn;
      }
      try {
        var lbl$2 = lookup_from_type(env, tpath, lid);
        Curry._2(check_lk, tpath, lbl$2);
        var s = string_of_out_ident(tree_of_path(tpath));
        Curry._2(warn, lid.loc, /* Name_out_of_scope */Block.__(23, [
                s,
                /* :: */[
                  last$1(lid.txt),
                  /* [] */0
                ],
                false
              ]));
        if (!pr) {
          warn_pr(void 0);
        }
        lbl = lbl$2;
      }
      catch (exn$1){
        if (exn$1 !== Caml_builtin_exceptions.not_found) {
          throw exn$1;
        }
        if (lbls === /* [] */0) {
          lbl = unbound_label_error(env, lid);
        } else {
          var tp_000 = match[0];
          var tp_001 = expand_path(env, tpath);
          var tp = /* tuple */[
            tp_000,
            tp_001
          ];
          var tpl = List.map((function (param) {
                  var tp0 = get_type_path$1(env, param[0]);
                  var tp = expand_path(env, tp0);
                  return /* tuple */[
                          tp0,
                          tp
                        ];
                }), lbls);
          throw [
                $$Error$7,
                lid.loc,
                env,
                /* Name_type_mismatch */Block.__(14, [
                    type_kind,
                    lid.txt,
                    tp,
                    tpl
                  ])
              ];
        }
      }
    }
  } else if (lbls) {
    var match$2 = lbls[0];
    var lbl$3 = match$2[0];
    Curry._1(match$2[1], void 0);
    var paths$1 = ambiguous_types(env, lbl$3, lbls[1]);
    if (paths$1 !== /* [] */0) {
      Curry._2(warn, lid.loc, /* Ambiguous_name */Block.__(24, [
              /* :: */[
                last$1(lid.txt),
                /* [] */0
              ],
              paths$1,
              false
            ]));
    }
    lbl = lbl$3;
  } else {
    lbl = unbound_label_error(env, lid);
  }
  if (scope$1 && scope$1[0][0] === lbl) {
    
  } else {
    prerr_warning(lid.loc, /* Disambiguated_name */Block.__(25, [lbl.lbl_name]));
  }
  return lbl;
}

function disambiguate_label_by_ids(keep, env, closed, ids, labels) {
  var check_ids = function (param) {
    var lbls = Hashtbl.create(void 0, 8);
    $$Array.iter((function (lbl) {
            return Hashtbl.add(lbls, lbl.lbl_name, void 0);
          }), param[0].lbl_all);
    return List.for_all((function (param) {
                  return Hashtbl.mem(lbls, param);
                }), ids);
  };
  var check_closed = function (param) {
    if (closed) {
      return List.length(ids) === param[0].lbl_all.length;
    } else {
      return true;
    }
  };
  var labels$prime = List.filter(check_ids)(labels);
  if (keep && labels$prime === /* [] */0) {
    return /* tuple */[
            false,
            labels
          ];
  }
  var labels$prime$prime = List.filter(check_closed)(labels$prime);
  if (keep && labels$prime$prime === /* [] */0) {
    return /* tuple */[
            false,
            labels$prime
          ];
  } else {
    return /* tuple */[
            true,
            labels$prime$prime
          ];
  }
}

function disambiguate_lid_a_list(loc, closed, env, opath, lid_a_list) {
  var ids = List.map((function (param) {
          return last$1(param[0].txt);
        }), lid_a_list);
  var w_pr = {
    contents: false
  };
  var w_amb = {
    contents: /* [] */0
  };
  var w_scope = {
    contents: /* [] */0
  };
  var w_scope_ty = {
    contents: ""
  };
  var warn = function (loc, msg) {
    if (typeof msg === "number") {
      return prerr_warning(loc, msg);
    }
    switch (msg.tag | 0) {
      case /* Not_principal */8 :
          w_pr.contents = true;
          return ;
      case /* Name_out_of_scope */23 :
          var match = msg[1];
          if (match && !match[1]) {
            w_scope.contents = /* :: */[
              match[0],
              w_scope.contents
            ];
            w_scope_ty.contents = msg[0];
            return ;
          } else {
            return prerr_warning(loc, msg);
          }
      case /* Ambiguous_name */24 :
          var match$1 = msg[0];
          if (match$1 && !match$1[1]) {
            w_amb.contents = /* :: */[
              /* tuple */[
                match$1[0],
                msg[1]
              ],
              w_amb.contents
            ];
            return ;
          } else {
            return prerr_warning(loc, msg);
          }
      default:
        return prerr_warning(loc, msg);
    }
  };
  var process_label = function (lid) {
    var scope = find_all_labels(env, lid.loc, lid.txt);
    if (opath === void 0 && scope === /* [] */0) {
      unbound_label_error(env, lid);
    }
    var match;
    var exit = 0;
    if (opath !== void 0 && opath[2]) {
      match = /* tuple */[
        true,
        scope
      ];
    } else {
      exit = 1;
    }
    if (exit === 1) {
      match = disambiguate_label_by_ids(opath === void 0, env, closed, ids, scope);
    }
    var labels = match[1];
    if (match[0]) {
      return disambiguate(warn, void 0, scope, lid, env, opath, labels);
    } else {
      return List.hd(labels)[0];
    }
  };
  var lbl_a_list = List.map((function (param) {
          var lid = param[0];
          return /* tuple */[
                  lid,
                  process_label(lid),
                  param[1]
                ];
        }), lid_a_list);
  if (w_pr.contents) {
    prerr_warning(loc, /* Not_principal */Block.__(8, ["this type-based record disambiguation"]));
  } else {
    var amb = List.rev(w_amb.contents);
    if (amb) {
      var paths = List.map((function (param) {
              return get_type_path$1(env, param[1]);
            }), lbl_a_list);
      var path = List.hd(paths);
      if (List.for_all((function (param) {
                return compare_type_path(env, path, param);
              }), List.tl(paths))) {
        prerr_warning(loc, /* Ambiguous_name */Block.__(24, [
                List.map((function (prim) {
                        return prim[0];
                      }), amb),
                amb[0][1],
                true
              ]));
      } else {
        List.iter((function (param) {
                return prerr_warning(loc, /* Ambiguous_name */Block.__(24, [
                              /* :: */[
                                param[0],
                                /* [] */0
                              ],
                              param[1],
                              false
                            ]));
              }), amb);
      }
    }
    
  }
  if (w_scope.contents !== /* [] */0) {
    prerr_warning(loc, /* Name_out_of_scope */Block.__(23, [
            w_scope_ty.contents,
            List.rev(w_scope.contents),
            true
          ]));
  }
  return lbl_a_list;
}

function find_record_qual(_param) {
  while(true) {
    var param = _param;
    if (!param) {
      return ;
    }
    var match = param[0][0].txt;
    switch (match.tag | 0) {
      case /* Ldot */1 :
          return match[0];
      case /* Lident */0 :
      case /* Lapply */2 :
          _param = param[1];
          continue ;
      
    }
  };
}

function type_label_a_list(labels, loc, closed, env, type_lbl_a, opath, lid_a_list) {
  var lbl_a_list;
  var exit = 0;
  if (lid_a_list) {
    var match = lid_a_list[0][0].txt;
    switch (match.tag | 0) {
      case /* Lident */0 :
          if (labels !== void 0) {
            var labels$1 = Caml_option.valFromOption(labels);
            if (Hashtbl.mem(labels$1, match[0])) {
              lbl_a_list = List.map((function (param) {
                      var lid = param[0];
                      var match = lid.txt;
                      switch (match.tag | 0) {
                        case /* Lident */0 :
                            return /* tuple */[
                                    lid,
                                    Hashtbl.find(labels$1, match[0]),
                                    param[1]
                                  ];
                        case /* Ldot */1 :
                        case /* Lapply */2 :
                            throw [
                                  Caml_builtin_exceptions.assert_failure,
                                  /* tuple */[
                                    "typecore.ml",
                                    819,
                                    17
                                  ]
                                ];
                        
                      }
                    }), lid_a_list);
            } else {
              exit = 1;
            }
          } else {
            exit = 1;
          }
          break;
      case /* Ldot */1 :
      case /* Lapply */2 :
          exit = 1;
          break;
      
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    var match$1 = find_record_qual(lid_a_list);
    var lid_a_list$1;
    if (match$1 !== void 0) {
      var modname = match$1;
      lid_a_list$1 = List.map((function (lid_a) {
              var lid = lid_a[0];
              var match = lid.txt;
              switch (match.tag | 0) {
                case /* Lident */0 :
                    return /* tuple */[
                            {
                              txt: /* Ldot */Block.__(1, [
                                  modname,
                                  match[0]
                                ]),
                              loc: lid.loc
                            },
                            lid_a[1]
                          ];
                case /* Ldot */1 :
                case /* Lapply */2 :
                    return lid_a;
                
              }
            }), lid_a_list);
    } else {
      lid_a_list$1 = lid_a_list;
    }
    lbl_a_list = disambiguate_lid_a_list(loc, closed, env, opath, lid_a_list$1);
  }
  var lbl_a_list$1 = List.sort((function (param, param$1) {
          return Caml_primitive.caml_int_compare(param[1].lbl_pos, param$1[1].lbl_pos);
        }), lbl_a_list);
  return List.map(type_lbl_a, lbl_a_list$1);
}

function check_recordpat_labels(loc, lbl_pat_list, closed) {
  if (!lbl_pat_list) {
    return ;
  }
  var all = lbl_pat_list[0][1].lbl_all;
  var defined = Caml_array.caml_make_vect(all.length, false);
  var check_defined = function (param) {
    var label = param[1];
    if (Caml_array.caml_array_get(defined, label.lbl_pos)) {
      throw [
            $$Error$7,
            loc,
            empty,
            /* Label_multiply_defined */Block.__(10, [label.lbl_name])
          ];
    }
    return Caml_array.caml_array_set(defined, label.lbl_pos, true);
  };
  List.iter(check_defined, lbl_pat_list);
  if (!(closed === /* Closed */0 && is_active(/* Non_closed_record_pattern */Block.__(4, [""])))) {
    return ;
  }
  var $$undefined = /* [] */0;
  for(var i = 0 ,i_finish = all.length - 1 | 0; i <= i_finish; ++i){
    if (!Caml_array.caml_array_get(defined, i)) {
      $$undefined = /* :: */[
        Caml_array.caml_array_get(all, i).lbl_name,
        $$undefined
      ];
    }
    
  }
  if ($$undefined === /* [] */0) {
    return ;
  }
  var u = $$String.concat(", ", List.rev($$undefined));
  return prerr_warning(loc, /* Non_closed_record_pattern */Block.__(4, [u]));
}

var type_kind$1 = "variant";

function get_type_path$2(env, d) {
  var match = d.cstr_res.desc;
  if (typeof match === "number") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "typecore.ml",
            602,
            11
          ]
        ];
  }
  if (match.tag === /* Tconstr */3) {
    return match[0];
  }
  throw [
        Caml_builtin_exceptions.assert_failure,
        /* tuple */[
          "typecore.ml",
          602,
          11
        ]
      ];
}

function lookup_from_type$1(env, tpath, lid) {
  var descrs = find_type_full(tpath, env)[1][0];
  mark_type_used(env, last(tpath), find_type_full(tpath, env)[0]);
  var match = lid.txt;
  switch (match.tag | 0) {
    case /* Lident */0 :
        var s = match[0];
        try {
          return List.find((function (nd) {
                        return nd.cstr_name === s;
                      }), descrs);
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            throw [
                  $$Error$7,
                  lid.loc,
                  env,
                  /* Wrong_name */Block.__(13, [
                      "",
                      newvar(void 0, void 0),
                      type_kind$1,
                      tpath,
                      lid.txt
                    ])
                ];
          }
          throw exn;
        }
    case /* Ldot */1 :
    case /* Lapply */2 :
        throw Caml_builtin_exceptions.not_found;
    
  }
}

function unique$1(eq, _acc, _param) {
  while(true) {
    var param = _param;
    var acc = _acc;
    if (!param) {
      return List.rev(acc);
    }
    var rem = param[1];
    var x = param[0];
    if (List.exists(Curry._1(eq, x), acc)) {
      _param = rem;
      continue ;
    } else {
      _param = rem;
      _acc = /* :: */[
        x,
        acc
      ];
      continue ;
    }
  };
}

function ambiguous_types$1(env, lbl, others) {
  var tpath = get_type_path$2(env, lbl);
  var others$1 = List.map((function (param) {
          return get_type_path$2(env, param[0]);
        }), others);
  var tpaths = unique$1((function (param, param$1) {
          return compare_type_path(env, param, param$1);
        }), /* :: */[
        tpath,
        /* [] */0
      ], others$1);
  if (tpaths && !tpaths[1]) {
    return /* [] */0;
  } else {
    return List.map(string_of_path, tpaths);
  }
}

function disambiguate_by_type$1(env, tpath, lbls) {
  var check_type = function (param) {
    var lbl_tpath = get_type_path$2(env, param[0]);
    return compare_type_path(env, tpath, lbl_tpath);
  };
  return List.find(check_type, lbls);
}

function disambiguate$1(warnOpt, check_lkOpt, scope, lid, env, opath, lbls) {
  var warn = warnOpt !== void 0 ? warnOpt : prerr_warning;
  var check_lk = check_lkOpt !== void 0 ? check_lkOpt : (function (param, param$1) {
        
      });
  var scope$1 = scope !== void 0 ? scope : lbls;
  var lbl;
  if (opath !== void 0) {
    var match = opath;
    var pr = match[2];
    var tpath = match[1];
    var warn_pr = function (param) {
      var kind = type_kind$1 === "record" ? "field" : "constructor";
      return Curry._2(warn, lid.loc, /* Not_principal */Block.__(8, ["this type-based " + (kind + " disambiguation")]));
    };
    try {
      var match$1 = disambiguate_by_type$1(env, tpath, scope$1);
      var lbl$1 = match$1[0];
      Curry._1(match$1[1], void 0);
      if (!pr) {
        if (lbls) {
          var lbl_tpath = get_type_path$2(env, lbls[0][0]);
          if (compare_type_path(env, tpath, lbl_tpath)) {
            var paths = ambiguous_types$1(env, lbl$1, lbls[1]);
            if (paths !== /* [] */0) {
              Curry._2(warn, lid.loc, /* Ambiguous_name */Block.__(24, [
                      /* :: */[
                        last$1(lid.txt),
                        /* [] */0
                      ],
                      paths,
                      false
                    ]));
            }
            
          } else {
            warn_pr(void 0);
          }
        } else {
          warn_pr(void 0);
        }
      }
      lbl = lbl$1;
    }
    catch (exn){
      if (exn !== Caml_builtin_exceptions.not_found) {
        throw exn;
      }
      try {
        var lbl$2 = lookup_from_type$1(env, tpath, lid);
        Curry._2(check_lk, tpath, lbl$2);
        var s = string_of_out_ident(tree_of_path(tpath));
        Curry._2(warn, lid.loc, /* Name_out_of_scope */Block.__(23, [
                s,
                /* :: */[
                  last$1(lid.txt),
                  /* [] */0
                ],
                false
              ]));
        if (!pr) {
          warn_pr(void 0);
        }
        lbl = lbl$2;
      }
      catch (exn$1){
        if (exn$1 !== Caml_builtin_exceptions.not_found) {
          throw exn$1;
        }
        if (lbls === /* [] */0) {
          lbl = unbound_constructor_error(env, lid);
        } else {
          var tp_000 = match[0];
          var tp_001 = expand_path(env, tpath);
          var tp = /* tuple */[
            tp_000,
            tp_001
          ];
          var tpl = List.map((function (param) {
                  var tp0 = get_type_path$2(env, param[0]);
                  var tp = expand_path(env, tp0);
                  return /* tuple */[
                          tp0,
                          tp
                        ];
                }), lbls);
          throw [
                $$Error$7,
                lid.loc,
                env,
                /* Name_type_mismatch */Block.__(14, [
                    type_kind$1,
                    lid.txt,
                    tp,
                    tpl
                  ])
              ];
        }
      }
    }
  } else if (lbls) {
    var match$2 = lbls[0];
    var lbl$3 = match$2[0];
    Curry._1(match$2[1], void 0);
    var paths$1 = ambiguous_types$1(env, lbl$3, lbls[1]);
    if (paths$1 !== /* [] */0) {
      Curry._2(warn, lid.loc, /* Ambiguous_name */Block.__(24, [
              /* :: */[
                last$1(lid.txt),
                /* [] */0
              ],
              paths$1,
              false
            ]));
    }
    lbl = lbl$3;
  } else {
    lbl = unbound_constructor_error(env, lid);
  }
  if (scope$1 && scope$1[0][0] === lbl) {
    
  } else {
    prerr_warning(lid.loc, /* Disambiguated_name */Block.__(25, [lbl.cstr_name]));
  }
  return lbl;
}

function unify_head_only(loc, env, ty, constr) {
  var match = instance_constructor(void 0, constr);
  var ty_res = match[1];
  var match$1 = repr(ty_res).desc;
  if (typeof match$1 === "number") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "typecore.ml",
            892,
            9
          ]
        ];
  }
  if (match$1.tag !== /* Tconstr */3) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "typecore.ml",
            892,
            9
          ]
        ];
  }
  ty_res.desc = /* Tconstr */Block.__(3, [
      match$1[0],
      List.map((function (param) {
              return newvar(void 0, void 0);
            }), match$1[1]),
      match$1[2]
    ]);
  enforce_constraints(env, ty_res);
  return unify_pat_types(loc, env, ty_res, ty);
}

function type_pat(constrs, labels, no_existentials, mode, env, sp, expected_ty) {
  var type_pat$1 = function (modeOpt, envOpt) {
    var mode$1 = modeOpt !== void 0 ? modeOpt : mode;
    var env$1 = envOpt !== void 0 ? envOpt : env;
    return (function (param, param$1) {
        return type_pat(constrs, labels, no_existentials, mode$1, env$1, param, param$1);
      });
  };
  var loc = sp.ppat_loc;
  var match = sp.ppat_desc;
  if (typeof match === "number") {
    return rp({
                pat_desc: /* Tpat_any */0,
                pat_loc: loc,
                pat_extra: /* [] */0,
                pat_type: expected_ty,
                pat_env: env.contents,
                pat_attributes: sp.ppat_attributes
              });
  }
  switch (match.tag | 0) {
    case /* Ppat_var */0 :
        var name = match[0];
        var id = enter_variable(void 0, void 0, loc, name, expected_ty);
        return rp({
                    pat_desc: /* Tpat_var */Block.__(0, [
                        id,
                        name
                      ]),
                    pat_loc: loc,
                    pat_extra: /* [] */0,
                    pat_type: expected_ty,
                    pat_env: env.contents,
                    pat_attributes: sp.ppat_attributes
                  });
    case /* Ppat_alias */1 :
        var name$1 = match[1];
        var q = type_pat$1(void 0, void 0)(match[0], expected_ty);
        begin_def(void 0);
        var ty_var = build_as_type(env.contents, q);
        end_def(void 0);
        iter_generalize$1({
              contents: /* [] */0
            }, ty_var);
        var id$1 = enter_variable(void 0, true, loc, name$1, ty_var);
        return rp({
                    pat_desc: /* Tpat_alias */Block.__(1, [
                        q,
                        id$1,
                        name$1
                      ]),
                    pat_loc: loc,
                    pat_extra: /* [] */0,
                    pat_type: q.pat_type,
                    pat_env: env.contents,
                    pat_attributes: sp.ppat_attributes
                  });
    case /* Ppat_constant */2 :
        var cst = match[0];
        unify_pat_types(loc, env.contents, type_constant(cst), expected_ty);
        return rp({
                    pat_desc: /* Tpat_constant */Block.__(2, [cst]),
                    pat_loc: loc,
                    pat_extra: /* [] */0,
                    pat_type: expected_ty,
                    pat_env: env.contents,
                    pat_attributes: sp.ppat_attributes
                  });
    case /* Ppat_interval */3 :
        var match$1 = match[0];
        if (match$1.tag !== /* Const_char */1) {
          throw [
                $$Error$7,
                loc,
                env.contents,
                /* Invalid_interval */5
              ];
        }
        var match$2 = match[1];
        if (match$2.tag !== /* Const_char */1) {
          throw [
                $$Error$7,
                loc,
                env.contents,
                /* Invalid_interval */5
              ];
        }
        var c2 = match$2[0];
        var c1 = match$1[0];
        var gloc_loc_start = loc.loc_start;
        var gloc_loc_end = loc.loc_end;
        var gloc = {
          loc_start: gloc_loc_start,
          loc_end: gloc_loc_end,
          loc_ghost: true
        };
        var loop = function (c1, c2) {
          if (c1 === c2) {
            return constant(gloc, void 0, /* Const_char */Block.__(1, [c1]));
          } else {
            return or_(gloc, void 0, constant(gloc, void 0, /* Const_char */Block.__(1, [c1])), loop(Char.chr(c1 + 1 | 0), c2));
          }
        };
        var p = c1 <= c2 ? loop(c1, c2) : loop(c2, c1);
        var p_ppat_desc = p.ppat_desc;
        var p_ppat_attributes = p.ppat_attributes;
        var p$1 = {
          ppat_desc: p_ppat_desc,
          ppat_loc: loc,
          ppat_attributes: p_ppat_attributes
        };
        return type_pat$1(void 0, void 0)(p$1, expected_ty);
    case /* Ppat_tuple */4 :
        var spl = match[0];
        if (List.length(spl) < 2) {
          ill_formed_ast(loc, "Tuples must have at least 2 components.");
        }
        var spl_ann = List.map((function (p) {
                return /* tuple */[
                        p,
                        newvar(void 0, void 0)
                      ];
              }), spl);
        var desc = /* Ttuple */Block.__(2, [List.map((function (prim) {
                    return prim[1];
                  }), spl_ann)]);
        var ty = newty2(current_level.contents, desc);
        unify_pat_types(loc, env.contents, ty, expected_ty);
        var pl = List.map((function (param) {
                return type_pat$1(void 0, void 0)(param[0], param[1]);
              }), spl_ann);
        return rp({
                    pat_desc: /* Tpat_tuple */Block.__(3, [pl]),
                    pat_loc: loc,
                    pat_extra: /* [] */0,
                    pat_type: expected_ty,
                    pat_env: env.contents,
                    pat_attributes: sp.ppat_attributes
                  });
    case /* Ppat_construct */5 :
        var sarg = match[1];
        var lid = match[0];
        var opath;
        try {
          var match$3 = extract_concrete_variant(env.contents, expected_ty);
          opath = /* tuple */[
            match$3[0],
            match$3[1],
            true
          ];
        }
        catch (exn){
          if (exn !== Caml_builtin_exceptions.not_found) {
            throw exn;
          }
          opath = void 0;
        }
        var match$4 = lid.txt;
        var constrs$1;
        var exit = 0;
        switch (match$4.tag | 0) {
          case /* Lident */0 :
              if (constrs !== void 0) {
                var constrs$2 = Caml_option.valFromOption(constrs);
                var s = match$4[0];
                if (Hashtbl.mem(constrs$2, s)) {
                  constrs$1 = /* :: */[
                    /* tuple */[
                      Hashtbl.find(constrs$2, s),
                      (function (param) {
                          
                        })
                    ],
                    /* [] */0
                  ];
                } else {
                  exit = 1;
                }
              } else {
                exit = 1;
              }
              break;
          case /* Ldot */1 :
          case /* Lapply */2 :
              exit = 1;
              break;
          
        }
        if (exit === 1) {
          constrs$1 = find_all_constructors(env.contents, lid.loc, lid.txt);
        }
        var check_lk = function (tpath, constr) {
          if (constr.cstr_generalized) {
            throw [
                  $$Error$7,
                  lid.loc,
                  env.contents,
                  /* Unqualified_gadt_pattern */Block.__(34, [
                      tpath,
                      constr.cstr_name
                    ])
                ];
          }
          
        };
        var partial_arg = env.contents;
        var partial_arg$1 = check_lk;
        var constr = wrap_disambiguate("This variant pattern is expected to have", expected_ty, (function (param) {
                return disambiguate$1(void 0, partial_arg$1, void 0, lid, partial_arg, opath, param);
              }), constrs$1);
        mark_constructor(/* Pattern */1, env.contents, last$1(lid.txt), constr);
        check_deprecated(loc, constr.cstr_attributes, constr.cstr_name);
        if (no_existentials && constr.cstr_existentials !== /* [] */0) {
          throw [
                $$Error$7,
                loc,
                env.contents,
                /* Unexpected_existential */4
              ];
        }
        if (constr.cstr_generalized) {
          unify_head_only(loc, env.contents, expected_ty, constr);
        }
        var sargs;
        if (sarg !== void 0) {
          var sp$1 = sarg;
          var match$5 = sp$1.ppat_desc;
          if (typeof match$5 === "number") {
            if (constr.cstr_arity !== 1) {
              if (constr.cstr_arity === 0) {
                prerr_warning(sp$1.ppat_loc, /* Wildcard_arg_to_constant_constr */13);
              }
              sargs = replicate_list(sp$1, constr.cstr_arity);
            } else {
              sargs = /* :: */[
                sp$1,
                /* [] */0
              ];
            }
          } else {
            sargs = match$5.tag === /* Ppat_tuple */4 && (constr.cstr_arity > 1 || explicit_arity(sp.ppat_attributes)) ? match$5[0] : /* :: */[
                sp$1,
                /* [] */0
              ];
          }
        } else {
          sargs = /* [] */0;
        }
        if (List.length(sargs) !== constr.cstr_arity) {
          throw [
                $$Error$7,
                loc,
                env.contents,
                /* Constructor_arity_mismatch */Block.__(1, [
                    lid.txt,
                    constr.cstr_arity,
                    List.length(sargs)
                  ])
              ];
        }
        var match$6 = instance_constructor(/* tuple */[
              env,
              get_newtype_level$1(void 0)
            ], constr);
        var ty_res = match$6[1];
        if (constr.cstr_generalized && mode === /* Normal */0) {
          unify_pat_types_gadt(loc, env, ty_res, expected_ty);
        } else {
          unify_pat_types(loc, env.contents, ty_res, expected_ty);
        }
        var args = List.map2((function (p, t) {
                return type_pat$1(void 0, void 0)(p, t);
              }), sargs, match$6[0]);
        return rp({
                    pat_desc: /* Tpat_construct */Block.__(4, [
                        lid,
                        constr,
                        args
                      ]),
                    pat_loc: loc,
                    pat_extra: /* [] */0,
                    pat_type: expected_ty,
                    pat_env: env.contents,
                    pat_attributes: sp.ppat_attributes
                  });
    case /* Ppat_variant */6 :
        var sarg$1 = match[1];
        var l = match[0];
        var arg_type = sarg$1 !== void 0 ? /* :: */[
            newvar(void 0, void 0),
            /* [] */0
          ] : /* [] */0;
        var row_row_fields = /* :: */[
          /* tuple */[
            l,
            /* Reither */Block.__(1, [
                sarg$1 === void 0,
                arg_type,
                true,
                {
                  contents: void 0
                }
              ])
          ],
          /* [] */0
        ];
        var row_row_more = newvar(void 0, void 0);
        var row = {
          row_fields: row_row_fields,
          row_more: row_row_more,
          row_bound: void 0,
          row_closed: false,
          row_fixed: false,
          row_name: void 0
        };
        unify_pat_types(loc, env.contents, newty2(current_level.contents, /* Tvariant */Block.__(8, [row])), expected_ty);
        var arg = sarg$1 !== void 0 && arg_type && !arg_type[1] ? type_pat$1(void 0, void 0)(sarg$1, arg_type[0]) : void 0;
        return rp({
                    pat_desc: /* Tpat_variant */Block.__(5, [
                        l,
                        arg,
                        {
                          contents: {
                            row_fields: row_row_fields,
                            row_more: newvar(void 0, void 0),
                            row_bound: void 0,
                            row_closed: false,
                            row_fixed: false,
                            row_name: void 0
                          }
                        }
                      ]),
                    pat_loc: loc,
                    pat_extra: /* [] */0,
                    pat_type: expected_ty,
                    pat_env: env.contents,
                    pat_attributes: sp.ppat_attributes
                  });
    case /* Ppat_record */7 :
        var closed = match[1];
        var lid_sp_list = match[0];
        if (lid_sp_list === /* [] */0) {
          ill_formed_ast(loc, "Records cannot be empty.");
        }
        var match$7;
        try {
          var match$8 = extract_concrete_record(env.contents, expected_ty);
          match$7 = /* tuple */[
            /* tuple */[
              match$8[0],
              match$8[1],
              true
            ],
            expected_ty
          ];
        }
        catch (exn$1){
          if (exn$1 !== Caml_builtin_exceptions.not_found) {
            throw exn$1;
          }
          match$7 = /* tuple */[
            void 0,
            newvar(void 0, void 0)
          ];
        }
        var record_ty = match$7[1];
        var opath$1 = match$7[0];
        var type_label_pat = function (param) {
          var label = param[1];
          var label_lid = param[0];
          begin_def(void 0);
          var match = instance_label(false, label);
          var ty_arg = match[1];
          var vars = match[0];
          if (vars === /* [] */0) {
            end_def(void 0);
          }
          try {
            unify_pat_types(loc, env.contents, match[2], record_ty);
          }
          catch (raw_exn){
            var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn[0] === Unify) {
              throw [
                    $$Error$7,
                    label_lid.loc,
                    env.contents,
                    /* Label_mismatch */Block.__(2, [
                        label_lid.txt,
                        exn[1]
                      ])
                  ];
            }
            throw exn;
          }
          var arg = type_pat$1(void 0, void 0)(param[2], ty_arg);
          if (vars !== /* [] */0) {
            end_def(void 0);
            iter_generalize$1({
                  contents: /* [] */0
                }, ty_arg);
            List.iter(generalize, vars);
            var instantiated = function (tv) {
              var tv$1 = expand_head(env.contents, tv);
              if (is_Tvar(tv$1)) {
                return tv$1.level !== 100000000;
              } else {
                return true;
              }
            };
            if (List.exists(instantiated, vars)) {
              throw [
                    $$Error$7,
                    label_lid.loc,
                    env.contents,
                    /* Polymorphic_label */Block.__(0, [label_lid.txt])
                  ];
            }
            
          }
          return /* tuple */[
                  label_lid,
                  label,
                  arg
                ];
        };
        var partial_arg$2 = env.contents;
        var lbl_pat_list = wrap_disambiguate("This record pattern is expected to have", expected_ty, (function (param) {
                return type_label_a_list(labels, loc, false, partial_arg$2, type_label_pat, opath$1, param);
              }), lid_sp_list);
        check_recordpat_labels(loc, lbl_pat_list, closed);
        unify_pat_types(loc, env.contents, record_ty, expected_ty);
        return rp({
                    pat_desc: /* Tpat_record */Block.__(6, [
                        lbl_pat_list,
                        closed
                      ]),
                    pat_loc: loc,
                    pat_extra: /* [] */0,
                    pat_type: expected_ty,
                    pat_env: env.contents,
                    pat_attributes: sp.ppat_attributes
                  });
    case /* Ppat_array */8 :
        var ty_elt = newvar(void 0, void 0);
        unify_pat_types(loc, env.contents, instance_def(type_array(ty_elt)), expected_ty);
        var spl_ann$1 = List.map((function (p) {
                return /* tuple */[
                        p,
                        newvar(void 0, void 0)
                      ];
              }), match[0]);
        var pl$1 = List.map((function (param) {
                return type_pat$1(void 0, void 0)(param[0], ty_elt);
              }), spl_ann$1);
        return rp({
                    pat_desc: /* Tpat_array */Block.__(7, [pl$1]),
                    pat_loc: loc,
                    pat_extra: /* [] */0,
                    pat_type: expected_ty,
                    pat_env: env.contents,
                    pat_attributes: sp.ppat_attributes
                  });
    case /* Ppat_or */9 :
        var initial_pattern_variables = pattern_variables.contents;
        var p1 = type_pat$1(/* Inside_or */1, void 0)(match[0], expected_ty);
        var p1_variables = pattern_variables.contents;
        pattern_variables.contents = initial_pattern_variables;
        var p2 = type_pat$1(/* Inside_or */1, void 0)(match[1], expected_ty);
        var p2_variables = pattern_variables.contents;
        var alpha_env = enter_orpat_variables(loc, env.contents, p1_variables, p2_variables);
        pattern_variables.contents = p1_variables;
        return rp({
                    pat_desc: /* Tpat_or */Block.__(8, [
                        p1,
                        alpha_pat(alpha_env, p2),
                        void 0
                      ]),
                    pat_loc: loc,
                    pat_extra: /* [] */0,
                    pat_type: expected_ty,
                    pat_env: env.contents,
                    pat_attributes: sp.ppat_attributes
                  });
    case /* Ppat_constraint */10 :
        var sp$2 = match[0];
        var match$9 = sp$2.ppat_desc;
        var exit$1 = 0;
        if (typeof match$9 === "number" || match$9.tag) {
          exit$1 = 1;
        } else {
          var sty = match[1];
          var tmp = sty.ptyp_desc;
          if (typeof tmp === "number" || tmp.tag !== /* Ptyp_poly */8) {
            exit$1 = 1;
          } else {
            var lloc = sp$2.ppat_loc;
            var name$2 = match$9[0];
            var match$10 = transl_simple_type_delayed(env.contents, sty);
            var cty = match$10[0];
            var ty$1 = cty.ctyp_type;
            unify_pat_types(lloc, env.contents, ty$1, expected_ty);
            pattern_force.contents = /* :: */[
              match$10[1],
              pattern_force.contents
            ];
            var match$11 = ty$1.desc;
            if (typeof match$11 === "number") {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    /* tuple */[
                      "typecore.ml",
                      955,
                      13
                    ]
                  ];
            }
            if (match$11.tag !== /* Tpoly */10) {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    /* tuple */[
                      "typecore.ml",
                      955,
                      13
                    ]
                  ];
            }
            begin_def(void 0);
            var match$12 = instance_poly(true, false, match$11[1], match$11[0]);
            var ty$prime = match$12[1];
            end_def(void 0);
            iter_generalize$1({
                  contents: /* [] */0
                }, ty$prime);
            var id$2 = enter_variable(void 0, void 0, lloc, name$2, ty$prime);
            return rp({
                        pat_desc: /* Tpat_var */Block.__(0, [
                            id$2,
                            name$2
                          ]),
                        pat_loc: lloc,
                        pat_extra: /* :: */[
                          /* tuple */[
                            /* Tpat_constraint */Block.__(0, [cty]),
                            loc,
                            sp.ppat_attributes
                          ],
                          /* [] */0
                        ],
                        pat_type: ty$1,
                        pat_env: env.contents,
                        pat_attributes: /* [] */0
                      });
          }
        }
        if (exit$1 === 1) {
          begin_def(void 0);
          var match$13 = transl_simple_type_delayed(env.contents, match[1]);
          var cty$1 = match$13[0];
          var ty$2 = cty$1.ctyp_type;
          end_def(void 0);
          generalize_structure$1(current_level.contents, ty$2);
          var match_000 = instance(void 0, env.contents, ty$2);
          var match_001 = instance(void 0, env.contents, ty$2);
          var ty$3 = match_000;
          unify_pat_types(loc, env.contents, ty$3, expected_ty);
          var p$2 = type_pat$1(void 0, void 0)(sp$2, match_001);
          pattern_force.contents = /* :: */[
            match$13[1],
            pattern_force.contents
          ];
          var extra_000 = /* Tpat_constraint */Block.__(0, [cty$1]);
          var extra_002 = sp$2.ppat_attributes;
          var extra = /* tuple */[
            extra_000,
            loc,
            extra_002
          ];
          var match$14 = p$2.pat_desc;
          if (typeof match$14 !== "number" && !match$14.tag) {
            return {
                    pat_desc: /* Tpat_alias */Block.__(1, [
                        {
                          pat_desc: /* Tpat_any */0,
                          pat_loc: p$2.pat_loc,
                          pat_extra: p$2.pat_extra,
                          pat_type: p$2.pat_type,
                          pat_env: p$2.pat_env,
                          pat_attributes: /* [] */0
                        },
                        match$14[0],
                        match$14[1]
                      ]),
                    pat_loc: p$2.pat_loc,
                    pat_extra: /* :: */[
                      extra,
                      /* [] */0
                    ],
                    pat_type: ty$3,
                    pat_env: p$2.pat_env,
                    pat_attributes: p$2.pat_attributes
                  };
          }
          return {
                  pat_desc: p$2.pat_desc,
                  pat_loc: p$2.pat_loc,
                  pat_extra: /* :: */[
                    extra,
                    p$2.pat_extra
                  ],
                  pat_type: ty$3,
                  pat_env: p$2.pat_env,
                  pat_attributes: p$2.pat_attributes
                };
        }
        break;
    case /* Ppat_type */11 :
        var lid$1 = match[0];
        var match$15 = build_or_pat(env.contents, loc, lid$1.txt);
        var p$3 = match$15[1];
        unify_pat_types(loc, env.contents, match$15[2], expected_ty);
        return {
                pat_desc: p$3.pat_desc,
                pat_loc: p$3.pat_loc,
                pat_extra: /* :: */[
                  /* tuple */[
                    /* Tpat_type */Block.__(1, [
                        match$15[0],
                        lid$1
                      ]),
                    loc,
                    sp.ppat_attributes
                  ],
                  p$3.pat_extra
                ],
                pat_type: p$3.pat_type,
                pat_env: p$3.pat_env,
                pat_attributes: p$3.pat_attributes
              };
    case /* Ppat_lazy */12 :
        var nv = newvar(void 0, void 0);
        unify_pat_types(loc, env.contents, instance_def(type_lazy_t(nv)), expected_ty);
        var p1$1 = type_pat$1(void 0, void 0)(match[0], nv);
        return rp({
                    pat_desc: /* Tpat_lazy */Block.__(9, [p1$1]),
                    pat_loc: loc,
                    pat_extra: /* [] */0,
                    pat_type: expected_ty,
                    pat_env: env.contents,
                    pat_attributes: sp.ppat_attributes
                  });
    case /* Ppat_unpack */13 :
        var name$3 = match[0];
        var id$3 = enter_variable(true, void 0, loc, name$3, expected_ty);
        return rp({
                    pat_desc: /* Tpat_var */Block.__(0, [
                        id$3,
                        name$3
                      ]),
                    pat_loc: sp.ppat_loc,
                    pat_extra: /* :: */[
                      /* tuple */[
                        /* Tpat_unpack */0,
                        loc,
                        sp.ppat_attributes
                      ],
                      /* [] */0
                    ],
                    pat_type: expected_ty,
                    pat_env: env.contents,
                    pat_attributes: /* [] */0
                  });
    case /* Ppat_exception */14 :
        throw [
              $$Error$7,
              loc,
              env.contents,
              /* Exception_pattern_below_toplevel */8
            ];
    case /* Ppat_extension */15 :
        throw [
              Error_forward$1,
              error_of_extension(match[0])
            ];
    
  }
}

function type_pat$1(allow_existentialsOpt, constrs, labels, levOpt, env, sp, expected_ty) {
  var allow_existentials = allow_existentialsOpt !== void 0 ? allow_existentialsOpt : false;
  var lev = levOpt !== void 0 ? levOpt : current_level.contents;
  newtype_level$1.contents = lev;
  try {
    var r = type_pat(constrs, labels, !allow_existentials, /* Normal */0, env, sp, expected_ty);
    iter_pattern((function (p) {
            p.pat_env = env.contents;
            
          }), r);
    newtype_level$1.contents = void 0;
    return r;
  }
  catch (e){
    newtype_level$1.contents = void 0;
    throw e;
  }
}

function partial_pred(lev, env, expected_ty, constrs, labels, p) {
  var snap = snapshot(void 0);
  try {
    reset_pattern(void 0, true);
    var typed_p = type_pat$1(true, Caml_option.some(constrs), Caml_option.some(labels), lev, {
          contents: env
        }, p, expected_ty);
    backtrack(snap);
    return typed_p;
  }
  catch (exn){
    backtrack(snap);
    return ;
  }
}

function check_partial$1(levOpt, env, expected_ty) {
  var lev = levOpt !== void 0 ? levOpt : current_level.contents;
  return (function (param, param$1) {
      var pred = function (param, param$1, param$2) {
        return partial_pred(lev, env, expected_ty, param, param$1, param$2);
      };
      var first_check = check_partial(param, param$1);
      if (first_check) {
        return check_partial_param((function (param, param$1, param$2) {
                      return do_check_partial(pred, exhaust_gadt$1, param, param$1, param$2);
                    }), do_check_fragile_gadt, param, param$1);
      } else {
        return /* Partial */0;
      }
    });
}

function add_pattern_variables(check, check_as, env) {
  var pv = get_ref(pattern_variables);
  return /* tuple */[
          List.fold_right((function (param, env) {
                  var check$1 = param[4] ? check_as : check;
                  return add_value(check$1, param[0], {
                              val_type: param[1],
                              val_kind: /* Val_reg */0,
                              val_loc: param[3],
                              val_attributes: /* [] */0
                            }, env);
                }), pv, env),
          get_ref(module_variables)
        ];
}

function type_pattern(lev, env, spat, scope, expected_ty) {
  reset_pattern(scope, true);
  var new_env = {
    contents: env
  };
  var pat = type_pat$1(true, void 0, void 0, lev, new_env, spat, expected_ty);
  var match = add_pattern_variables((function (s) {
          return /* Unused_var_strict */Block.__(13, [s]);
        }), (function (s) {
          return /* Unused_var */Block.__(12, [s]);
        }), new_env.contents);
  return /* tuple */[
          pat,
          match[0],
          get_ref(pattern_force),
          match[1]
        ];
}

function type_pattern_list(env, spatl, scope, expected_tys, allow) {
  reset_pattern(scope, allow);
  var new_env = {
    contents: env
  };
  var patl = List.map2((function (param, param$1) {
          return type_pat$1(void 0, void 0, void 0, void 0, new_env, param, param$1);
        }), spatl, expected_tys);
  var match = add_pattern_variables(void 0, void 0, new_env.contents);
  return /* tuple */[
          patl,
          match[0],
          get_ref(pattern_force),
          match[1]
        ];
}

function type_class_arg_pattern(cl_num, val_env, met_env, l, spat) {
  reset_pattern(void 0, false);
  var nv = newvar(void 0, void 0);
  var pat = type_pat$1(void 0, void 0, void 0, void 0, {
        contents: val_env
      }, spat, nv);
  if (has_variants(pat)) {
    pressure_variants$1(val_env, /* :: */[
          pat,
          /* [] */0
        ]);
    iter_pattern(finalize_variant, pat);
  }
  List.iter((function (f) {
          return Curry._1(f, void 0);
        }), get_ref(pattern_force));
  if (is_optional(l)) {
    unify_pat(val_env, pat, type_option$1(newvar(void 0, void 0)));
  }
  var match = List.fold_right((function (param, param$1) {
          var as_var = param[4];
          var ty = param[1];
          var id = param[0];
          var check = function (s) {
            if (as_var) {
              return /* Unused_var */Block.__(12, [s]);
            } else {
              return /* Unused_var_strict */Block.__(13, [s]);
            }
          };
          var id$prime = create(id.name);
          return /* tuple */[
                  /* :: */[
                    /* tuple */[
                      id$prime,
                      param[2],
                      id,
                      ty
                    ],
                    param$1[0]
                  ],
                  add_value(check, id$prime, {
                        val_type: ty,
                        val_kind: /* Val_ivar */Block.__(1, [
                            /* Immutable */0,
                            cl_num
                          ]),
                        val_loc: param[3],
                        val_attributes: /* [] */0
                      }, param$1[1])
                ];
        }), pattern_variables.contents, /* tuple */[
        /* [] */0,
        met_env
      ]);
  var match$1 = add_pattern_variables(void 0, void 0, val_env);
  return /* tuple */[
          pat,
          match[0],
          match$1[0],
          match[1]
        ];
}

function type_self_pattern(cl_num, privty, val_env, met_env, par_env, spat) {
  var spat$1 = mk$1(void 0, void 0, /* Ppat_alias */Block.__(1, [
          mk$1(void 0, void 0, /* Ppat_alias */Block.__(1, [
                  spat,
                  {
                    txt: "selfpat-*",
                    loc: none
                  }
                ])),
          {
            txt: "selfpat-" + cl_num,
            loc: none
          }
        ]));
  reset_pattern(void 0, false);
  var nv = newvar(void 0, void 0);
  var pat = type_pat$1(void 0, void 0, void 0, void 0, {
        contents: val_env
      }, spat$1, nv);
  List.iter((function (f) {
          return Curry._1(f, void 0);
        }), get_ref(pattern_force));
  var meths = {
    contents: /* Empty */0
  };
  var vars = {
    contents: /* Empty */0
  };
  var pv = pattern_variables.contents;
  pattern_variables.contents = /* [] */0;
  var match = List.fold_right((function (param, param$1) {
          var as_var = param[4];
          var loc = param[3];
          var ty = param[1];
          var id = param[0];
          return /* tuple */[
                  add_value(void 0, id, {
                        val_type: ty,
                        val_kind: /* Val_unbound */1,
                        val_loc: loc,
                        val_attributes: /* [] */0
                      }, param$1[0]),
                  add_value((function (s) {
                          if (as_var) {
                            return /* Unused_var */Block.__(12, [s]);
                          } else {
                            return /* Unused_var_strict */Block.__(13, [s]);
                          }
                        }), id, {
                        val_type: ty,
                        val_kind: /* Val_self */Block.__(2, [
                            meths,
                            vars,
                            cl_num,
                            privty
                          ]),
                        val_loc: loc,
                        val_attributes: /* [] */0
                      }, param$1[1]),
                  add_value(void 0, id, {
                        val_type: ty,
                        val_kind: /* Val_unbound */1,
                        val_loc: loc,
                        val_attributes: /* [] */0
                      }, param$1[2])
                ];
        }), pv, /* tuple */[
        val_env,
        met_env,
        par_env
      ]);
  return /* tuple */[
          pat,
          meths,
          vars,
          match[0],
          match[1],
          match[2]
        ];
}

var delayed_checks = {
  contents: /* [] */0
};

function add_delayed_check(f) {
  delayed_checks.contents = /* :: */[
    /* tuple */[
      f,
      current.contents
    ],
    delayed_checks.contents
  ];
  
}

function force_delayed_checks(param) {
  var snap = snapshot(void 0);
  var w_old = current.contents;
  List.iter((function (param) {
          current.contents = param[1];
          return Curry._1(param[0], void 0);
        }), List.rev(delayed_checks.contents));
  current.contents = w_old;
  delayed_checks.contents = /* [] */0;
  return backtrack(snap);
}

function final_subexpression(_sexp) {
  while(true) {
    var sexp = _sexp;
    var match = sexp.pexp_desc;
    switch (match.tag | 0) {
      case /* Pexp_let */2 :
          _sexp = match[2];
          continue ;
      case /* Pexp_match */6 :
          var match$1 = match[1];
          if (!match$1) {
            return sexp;
          }
          _sexp = match$1[0].pc_rhs;
          continue ;
      case /* Pexp_try */7 :
          _sexp = match[0];
          continue ;
      case /* Pexp_ifthenelse */15 :
      case /* Pexp_sequence */16 :
          _sexp = match[1];
          continue ;
      default:
        return sexp;
    }
  };
}

function is_nonexpansive(_exp) {
  while(true) {
    var exp = _exp;
    var match = exp.exp_desc;
    switch (match.tag | 0) {
      case /* Texp_let */2 :
          if (!List.for_all((function (vb) {
                    return is_nonexpansive(vb.vb_expr);
                  }), match[1])) {
            return false;
          }
          _exp = match[2];
          continue ;
      case /* Texp_ident */0 :
      case /* Texp_constant */1 :
      case /* Texp_function */3 :
          return true;
      case /* Texp_apply */4 :
          var match$1 = match[1];
          if (match$1 && !(match$1[0][1] !== void 0 || !is_nonexpansive(match[0]))) {
            return List.for_all(is_nonexpansive_opt, List.map(snd3, match$1[1]));
          } else {
            return false;
          }
      case /* Texp_match */5 :
          if (match[2] || !is_nonexpansive(match[0])) {
            return false;
          } else {
            return List.for_all((function (param) {
                          if (is_nonexpansive_opt(param.c_guard)) {
                            return is_nonexpansive(param.c_rhs);
                          } else {
                            return false;
                          }
                        }), match[1]);
          }
      case /* Texp_tuple */7 :
          return List.for_all(is_nonexpansive, match[0]);
      case /* Texp_construct */8 :
          return List.for_all(is_nonexpansive, match[2]);
      case /* Texp_variant */9 :
          return is_nonexpansive_opt(match[1]);
      case /* Texp_record */10 :
          if (List.for_all((function (param) {
                    return param[1].lbl_mut === /* Immutable */0 ? is_nonexpansive(param[2]) : false;
                  }), match[0])) {
            return is_nonexpansive_opt(match[1]);
          } else {
            return false;
          }
      case /* Texp_array */13 :
          if (match[0]) {
            return false;
          } else {
            return true;
          }
      case /* Texp_ifthenelse */14 :
          if (is_nonexpansive(match[1])) {
            return is_nonexpansive_opt(match[2]);
          } else {
            return false;
          }
      case /* Texp_sequence */15 :
          _exp = match[1];
          continue ;
      case /* Texp_new */19 :
          return class_type_arity(match[2].cty_type) > 0;
      case /* Texp_letmodule */23 :
          if (!is_nonexpansive_mod(match[2])) {
            return false;
          }
          _exp = match[3];
          continue ;
      case /* Texp_field */11 :
      case /* Texp_lazy */25 :
          _exp = match[0];
          continue ;
      case /* Texp_object */26 :
          var match$2 = match[0];
          var count = {
            contents: 0
          };
          if (List.for_all((function(count){
                return function (field) {
                  var match = field.cf_desc;
                  switch (match.tag | 0) {
                    case /* Tcf_inherit */0 :
                        return false;
                    case /* Tcf_val */1 :
                        var match$1 = match[3];
                        count.contents = count.contents + 1 | 0;
                        return match$1.tag ? is_nonexpansive(match$1[1]) : true;
                    case /* Tcf_initializer */4 :
                        return is_nonexpansive(match[0]);
                    default:
                      return true;
                  }
                }
                }(count)), match$2.cstr_fields) && fold((function(count){
                return function (param, param$1, b) {
                  count.contents = count.contents - 1 | 0;
                  return b ? param$1[0] === /* Immutable */0 : false;
                }
                }(count)), match$2.cstr_type.csig_vars, true)) {
            return count.contents === 0;
          } else {
            return false;
          }
      case /* Texp_pack */27 :
          return is_nonexpansive_mod(match[0]);
      default:
        return false;
    }
  };
}

function is_nonexpansive_mod(_mexp) {
  while(true) {
    var mexp = _mexp;
    var match = mexp.mod_desc;
    switch (match.tag | 0) {
      case /* Tmod_structure */1 :
          return List.for_all((function (item) {
                        var match = item.str_desc;
                        switch (match.tag | 0) {
                          case /* Tstr_value */1 :
                              return List.for_all((function (vb) {
                                            return is_nonexpansive(vb.vb_expr);
                                          }), match[1]);
                          case /* Tstr_typext */4 :
                              return List.for_all((function (param) {
                                            if (param.ext_kind.tag) {
                                              return true;
                                            } else {
                                              return false;
                                            }
                                          }), match[0].tyext_constructors);
                          case /* Tstr_exception */5 :
                              if (match[0].ext_kind.tag) {
                                return true;
                              } else {
                                return false;
                              }
                          case /* Tstr_module */6 :
                              return is_nonexpansive_mod(match[0].mb_expr);
                          case /* Tstr_recmodule */7 :
                              return List.for_all((function (param) {
                                            return is_nonexpansive_mod(param.mb_expr);
                                          }), match[0]);
                          case /* Tstr_class */10 :
                              return false;
                          case /* Tstr_include */12 :
                              return is_nonexpansive_mod(match[0].incl_mod);
                          case /* Tstr_attribute */13 :
                              return true;
                          default:
                            return true;
                        }
                      }), match[0].str_items);
      case /* Tmod_ident */0 :
      case /* Tmod_functor */2 :
          return true;
      case /* Tmod_apply */3 :
          return false;
      case /* Tmod_constraint */4 :
          _mexp = match[0];
          continue ;
      case /* Tmod_unpack */5 :
          return is_nonexpansive(match[0]);
      
    }
  };
}

function is_nonexpansive_opt(param) {
  if (param !== void 0) {
    return is_nonexpansive(param);
  } else {
    return true;
  }
}

function approx_type(env, _sty) {
  while(true) {
    var sty = _sty;
    var match = sty.ptyp_desc;
    if (typeof match === "number") {
      return newvar(void 0, void 0);
    }
    switch (match.tag | 0) {
      case /* Ptyp_arrow */1 :
          var p = match[0];
          var ty1 = is_optional(p) ? type_option$1(newvar(void 0, void 0)) : newvar(void 0, void 0);
          var desc_002 = approx_type(env, match[2]);
          var desc = /* Tarrow */Block.__(1, [
              p,
              ty1,
              desc_002,
              /* Cok */0
            ]);
          return newty2(current_level.contents, desc);
      case /* Ptyp_tuple */2 :
          var desc$1 = /* Ttuple */Block.__(2, [List.map((function (param) {
                      return approx_type(env, param);
                    }), match[0])]);
          return newty2(current_level.contents, desc$1);
      case /* Ptyp_constr */3 :
          var ctl = match[1];
          try {
            var match$1 = lookup_type$1(match[0].txt, env);
            if (List.length(ctl) !== match$1[1].type_arity) {
              throw Caml_builtin_exceptions.not_found;
            }
            var tyl = List.map((function (param) {
                    return approx_type(env, param);
                  }), ctl);
            return newconstr(match$1[0], tyl);
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              return newvar(void 0, void 0);
            }
            throw exn;
          }
      case /* Ptyp_poly */8 :
          _sty = match[1];
          continue ;
      default:
        return newvar(void 0, void 0);
    }
  };
}

function type_approx(env, _sexp) {
  while(true) {
    var sexp = _sexp;
    var match = sexp.pexp_desc;
    switch (match.tag | 0) {
      case /* Pexp_let */2 :
          _sexp = match[2];
          continue ;
      case /* Pexp_function */3 :
          var match$1 = match[0];
          if (!match$1) {
            return newvar(void 0, void 0);
          }
          var desc_001 = newvar(void 0, void 0);
          var desc_002 = type_approx(env, match$1[0].pc_rhs);
          var desc = /* Tarrow */Block.__(1, [
              "",
              desc_001,
              desc_002,
              /* Cok */0
            ]);
          return newty2(current_level.contents, desc);
      case /* Pexp_fun */4 :
          var e = match[3];
          var p = match[0];
          if (is_optional(p)) {
            var desc_001$1 = type_option$1(newvar(void 0, void 0));
            var desc_002$1 = type_approx(env, e);
            var desc$1 = /* Tarrow */Block.__(1, [
                p,
                desc_001$1,
                desc_002$1,
                /* Cok */0
              ]);
            return newty2(current_level.contents, desc$1);
          } else {
            var desc_001$2 = newvar(void 0, void 0);
            var desc_002$2 = type_approx(env, e);
            var desc$2 = /* Tarrow */Block.__(1, [
                p,
                desc_001$2,
                desc_002$2,
                /* Cok */0
              ]);
            return newty2(current_level.contents, desc$2);
          }
      case /* Pexp_match */6 :
          var match$2 = match[1];
          if (!match$2) {
            return newvar(void 0, void 0);
          }
          _sexp = match$2[0].pc_rhs;
          continue ;
      case /* Pexp_try */7 :
          _sexp = match[0];
          continue ;
      case /* Pexp_tuple */8 :
          var desc$3 = /* Ttuple */Block.__(2, [List.map((function (param) {
                      return type_approx(env, param);
                    }), match[0])]);
          return newty2(current_level.contents, desc$3);
      case /* Pexp_ifthenelse */15 :
      case /* Pexp_sequence */16 :
          _sexp = match[1];
          continue ;
      case /* Pexp_constraint */19 :
          var ty = type_approx(env, match[0]);
          var ty1 = approx_type(env, match[1]);
          try {
            unify$2(env, ty, ty1);
          }
          catch (raw_exn){
            var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn[0] === Unify) {
              throw [
                    $$Error$7,
                    sexp.pexp_loc,
                    env,
                    /* Expr_type_clash */Block.__(7, [exn[1]])
                  ];
            }
            throw exn;
          }
          return ty1;
      case /* Pexp_coerce */20 :
          var approx_ty_opt = function (param) {
            if (param !== void 0) {
              return approx_type(env, param);
            } else {
              return newvar(void 0, void 0);
            }
          };
          var ty$1 = type_approx(env, match[0]);
          var ty1$1 = approx_ty_opt(match[1]);
          var ty2 = approx_type(env, match[2]);
          try {
            unify$2(env, ty$1, ty1$1);
          }
          catch (raw_exn$1){
            var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
            if (exn$1[0] === Unify) {
              throw [
                    $$Error$7,
                    sexp.pexp_loc,
                    env,
                    /* Expr_type_clash */Block.__(7, [exn$1[1]])
                  ];
            }
            throw exn$1;
          }
          return ty2;
      default:
        return newvar(void 0, void 0);
    }
  };
}

function list_labels(env, ty) {
  return wrap_trace_gadt_instances(env, (function (param) {
                var _visited = /* [] */0;
                var _ls = /* [] */0;
                var _ty_fun = param;
                while(true) {
                  var ty_fun = _ty_fun;
                  var ls = _ls;
                  var visited = _visited;
                  var ty = expand_head(env, ty_fun);
                  if (List.memq(ty, visited)) {
                    return /* tuple */[
                            List.rev(ls),
                            false
                          ];
                  }
                  var match = ty.desc;
                  if (typeof match === "number") {
                    return /* tuple */[
                            List.rev(ls),
                            is_Tvar(ty)
                          ];
                  }
                  if (match.tag !== /* Tarrow */1) {
                    return /* tuple */[
                            List.rev(ls),
                            is_Tvar(ty)
                          ];
                  }
                  _ty_fun = match[2];
                  _ls = /* :: */[
                    match[0],
                    ls
                  ];
                  _visited = /* :: */[
                    ty,
                    visited
                  ];
                  continue ;
                };
              }), ty);
}

function check_univars(env, expans, kind, exp, ty_expected, vars) {
  if (expans && !is_nonexpansive(exp)) {
    generalize_expansive$1(env, exp.exp_type);
  }
  var vars$1 = List.map((function (param) {
          return expand_head(env, param);
        }), vars);
  var vars$2 = List.map((function (param) {
          return expand_head(env, param);
        }), vars$1);
  var vars$prime = List.filter((function (t) {
            var t$1 = repr(t);
            iter_generalize$1({
                  contents: /* [] */0
                }, t$1);
            var match = t$1.desc;
            if (typeof match === "number" || match.tag || t$1.level !== 100000000) {
              return false;
            } else {
              log_type(t$1);
              t$1.desc = /* Tunivar */Block.__(9, [match[0]]);
              return true;
            }
          }))(vars$2);
  if (List.length(vars$2) === List.length(vars$prime)) {
    return ;
  }
  var ty = newty2(100000000, /* Tpoly */Block.__(10, [
          repr(exp.exp_type),
          vars$prime
        ]));
  var ty_expected$1 = repr(ty_expected);
  throw [
        $$Error$7,
        exp.exp_loc,
        env,
        /* Less_general */Block.__(31, [
            kind,
            /* :: */[
              /* tuple */[
                ty,
                ty
              ],
              /* :: */[
                /* tuple */[
                  ty_expected$1,
                  ty_expected$1
                ],
                /* [] */0
              ]
            ]
          ])
      ];
}

function check_application_result(env, statement, exp) {
  var loc = exp.exp_loc;
  var match = expand_head(env, exp.exp_type).desc;
  if (typeof match !== "number") {
    switch (match.tag | 0) {
      case /* Tvar */0 :
          return ;
      case /* Tarrow */1 :
          return prerr_warning(exp.exp_loc, /* Partial_application */2);
      case /* Tconstr */3 :
          if (same(match[0], path_unit)) {
            return ;
          }
          break;
      default:
        
    }
  }
  if (statement) {
    return prerr_warning(loc, /* Statement_type */4);
  }
  
}

function generalizable(level, ty) {
  var check = function (ty) {
    var ty$1 = repr(ty);
    if (ty$1.level < 0) {
      return ;
    }
    if (ty$1.level <= level) {
      throw Pervasives.Exit;
    }
    mark_type_node(ty$1);
    return iter_type_expr(check, ty$1);
  };
  try {
    check(ty);
    unmark_type(ty);
    return true;
  }
  catch (exn){
    if (exn !== Pervasives.Exit) {
      throw exn;
    }
    unmark_type(ty);
    return false;
  }
}

var self_coercion = {
  contents: /* [] */0
};

function wrap_unpacks(sexp, unpacks) {
  return List.fold_left((function (sexp, param) {
                var name = param[0];
                return Curry._5(Ast_helper_Exp.letmodule, sexp.pexp_loc, void 0, name, unpack$1(param[1], void 0, Curry._3(Ast_helper_Exp.ident, name.loc, void 0, {
                                    txt: /* Lident */Block.__(0, [name.txt]),
                                    loc: name.loc
                                  })), sexp);
              }), sexp, unpacks);
}

function contains_variant_either(ty) {
  var loop = function (ty) {
    var ty$1 = repr(ty);
    if (ty$1.level < 0) {
      return ;
    }
    mark_type_node(ty$1);
    var match = ty$1.desc;
    if (typeof match === "number") {
      return iter_type_expr(loop, ty$1);
    }
    if (match.tag !== /* Tvariant */8) {
      return iter_type_expr(loop, ty$1);
    }
    var row = row_repr_aux(/* [] */0, match[0]);
    if (!row.row_fixed) {
      List.iter((function (param) {
              var match = row_field_repr_aux(/* [] */0, param[1]);
              if (typeof match === "number") {
                return ;
              }
              if (match.tag) {
                throw Pervasives.Exit;
              }
              
            }), row.row_fields);
    }
    return iter_row(loop, row);
  };
  try {
    loop(ty);
    unmark_type(ty);
    return false;
  }
  catch (exn){
    if (exn !== Pervasives.Exit) {
      throw exn;
    }
    unmark_type(ty);
    return true;
  }
}

function iter_ppat(f, p) {
  var match = p.ppat_desc;
  if (typeof match === "number") {
    return ;
  }
  switch (match.tag | 0) {
    case /* Ppat_construct */5 :
    case /* Ppat_variant */6 :
        return may(f, match[1]);
    case /* Ppat_record */7 :
        return List.iter((function (param) {
                      return Curry._1(f, param[1]);
                    }), match[0]);
    case /* Ppat_tuple */4 :
    case /* Ppat_array */8 :
        return List.iter(f, match[0]);
    case /* Ppat_or */9 :
        Curry._1(f, match[0]);
        return Curry._1(f, match[1]);
    case /* Ppat_alias */1 :
    case /* Ppat_constraint */10 :
    case /* Ppat_lazy */12 :
    case /* Ppat_exception */14 :
        return Curry._1(f, match[0]);
    default:
      return ;
  }
}

function contains_polymorphic_variant(p) {
  var loop = function (p) {
    var match = p.ppat_desc;
    if (typeof match === "number") {
      return iter_ppat(loop, p);
    }
    switch (match.tag | 0) {
      case /* Ppat_variant */6 :
      case /* Ppat_type */11 :
          throw Pervasives.Exit;
      default:
        return iter_ppat(loop, p);
    }
  };
  try {
    loop(p);
    return false;
  }
  catch (exn){
    if (exn === Pervasives.Exit) {
      return true;
    }
    throw exn;
  }
}

function contains_gadt(env, p) {
  var loop = function (p) {
    var match = p.ppat_desc;
    if (typeof match === "number") {
      return iter_ppat(loop, p);
    }
    if (match.tag !== /* Ppat_construct */5) {
      return iter_ppat(loop, p);
    }
    try {
      var cstrs = lookup_all_constructors$1(match[0].txt, env);
      List.iter((function (param) {
              if (param[0].cstr_generalized) {
                throw Pervasives.Exit;
              }
              
            }), cstrs);
    }
    catch (exn){
      if (exn !== Caml_builtin_exceptions.not_found) {
        throw exn;
      }
      
    }
    return iter_ppat(loop, p);
  };
  try {
    loop(p);
    return false;
  }
  catch (exn){
    if (exn === Pervasives.Exit) {
      return true;
    }
    throw exn;
  }
}

function check_absent_variant(env) {
  return (function (param) {
      return iter_pattern((function (pat) {
                    var match = pat.pat_desc;
                    if (typeof match === "number") {
                      return ;
                    }
                    if (match.tag !== /* Tpat_variant */5) {
                      return ;
                    }
                    var arg = match[1];
                    var s = match[0];
                    var row = row_repr_aux(/* [] */0, match[2].contents);
                    if (List.exists((function (param) {
                              if (s === param[0]) {
                                return row_field_repr_aux(/* [] */0, param[1]) !== /* Rabsent */0;
                              } else {
                                return false;
                              }
                            }), row.row_fields) || !row.row_fixed && !static_row(row)) {
                      return ;
                    }
                    var ty_arg = arg !== void 0 ? /* :: */[
                        type_expr(identity, arg.pat_type),
                        /* [] */0
                      ] : /* [] */0;
                    var row$prime_row_fields = /* :: */[
                      /* tuple */[
                        s,
                        /* Reither */Block.__(1, [
                            arg === void 0,
                            ty_arg,
                            true,
                            {
                              contents: void 0
                            }
                          ])
                      ],
                      /* [] */0
                    ];
                    var row$prime_row_more = newvar(void 0, void 0);
                    var row$prime = {
                      row_fields: row$prime_row_fields,
                      row_more: row$prime_row_more,
                      row_bound: void 0,
                      row_closed: false,
                      row_fixed: false,
                      row_name: void 0
                    };
                    return unify_pat(env, {
                                pat_desc: pat.pat_desc,
                                pat_loc: pat.pat_loc,
                                pat_extra: pat.pat_extra,
                                pat_type: newty2(current_level.contents, /* Tvariant */Block.__(8, [row$prime])),
                                pat_env: pat.pat_env,
                                pat_attributes: pat.pat_attributes
                              }, type_expr(identity, pat.pat_type));
                  }), param);
    });
}

function duplicate_ident_types(loc, caselist, env) {
  var caselist$1 = List.filter((function (param) {
            return contains_gadt(env, param.pc_lhs);
          }))(caselist);
  var idents = all_idents_cases(caselist$1);
  return List.fold_left((function (env, s) {
                try {
                  var match = lookup_value$1(/* Lident */Block.__(0, [s]), env);
                  var desc = match[1];
                  var path = match[0];
                  switch (path.tag | 0) {
                    case /* Pident */0 :
                        var desc_val_type = type_expr(identity, desc.val_type);
                        var desc_val_kind = desc.val_kind;
                        var desc_val_loc = desc.val_loc;
                        var desc_val_attributes = desc.val_attributes;
                        var desc$1 = {
                          val_type: desc_val_type,
                          val_kind: desc_val_kind,
                          val_loc: desc_val_loc,
                          val_attributes: desc_val_attributes
                        };
                        return add_value(void 0, path[0], desc$1, env);
                    case /* Pdot */1 :
                    case /* Papply */2 :
                        return env;
                    
                  }
                }
                catch (exn){
                  if (exn === Caml_builtin_exceptions.not_found) {
                    return env;
                  }
                  throw exn;
                }
              }), env, idents);
}

function unify_exp(env, exp, expected_ty) {
  return unify_exp_types(exp.exp_loc, env, exp.exp_type, expected_ty);
}

function type_exp(env, sexp) {
  return type_expect(void 0, env, sexp, newvar(void 0, void 0));
}

function type_expect(in_function, env, sexp, ty_expected) {
  var previous_saved_types = saved_types.contents;
  warning_enter_scope(void 0);
  warning_attribute(sexp.pexp_attributes);
  var exp = type_expect_(in_function, env, sexp, ty_expected);
  warning_leave_scope(void 0);
  saved_types.contents = /* :: */[
    /* Partial_expression */Block.__(2, [exp]),
    previous_saved_types
  ];
  return exp;
}

function type_expect_(in_function, env, sexp, ty_expected) {
  var loc = sexp.pexp_loc;
  var rue = function (exp) {
    unify_exp(env, re(exp), instance(void 0, env, ty_expected));
    return exp;
  };
  var match = sexp.pexp_desc;
  switch (match.tag | 0) {
    case /* Pexp_ident */0 :
        var lid = match[0];
        var match$1 = find_value$1(env, loc, lid.txt);
        var desc = match$1[1];
        var path = match$1[0];
        if (annotations.contents) {
          var dloc = desc.val_loc;
          var annot = dloc.loc_ghost ? /* Iref_external */0 : /* Iref_internal */Block.__(0, [dloc]);
          var name$1 = name(parenthesized_ident, path);
          record$2(/* An_ident */Block.__(5, [
                  loc,
                  name$1,
                  annot
                ]));
        }
        var match$2 = desc.val_kind;
        var tmp;
        if (typeof match$2 === "number") {
          if (match$2 === /* Val_unbound */1) {
            throw [
                  $$Error$7,
                  loc,
                  env,
                  /* Masked_instance_variable */Block.__(29, [lid.txt])
                ];
          }
          tmp = /* Texp_ident */Block.__(0, [
              path,
              lid,
              desc
            ]);
        } else {
          switch (match$2.tag | 0) {
            case /* Val_ivar */1 :
                var match$3 = lookup_value$1(/* Lident */Block.__(0, ["self-" + match$2[1]]), env);
                var match$4 = lid.txt;
                var tmp$1;
                switch (match$4.tag | 0) {
                  case /* Lident */0 :
                      tmp$1 = {
                        txt: match$4[0],
                        loc: lid.loc
                      };
                      break;
                  case /* Ldot */1 :
                  case /* Lapply */2 :
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            /* tuple */[
                              "typecore.ml",
                              1773,
                              38
                            ]
                          ];
                  
                }
                tmp = /* Texp_instvar */Block.__(20, [
                    match$3[0],
                    path,
                    tmp$1
                  ]);
                break;
            case /* Val_self */2 :
                var match$5 = lookup_value$1(/* Lident */Block.__(0, ["self-" + match$2[2]]), env);
                tmp = /* Texp_ident */Block.__(0, [
                    match$5[0],
                    lid,
                    desc
                  ]);
                break;
            default:
              tmp = /* Texp_ident */Block.__(0, [
                  path,
                  lid,
                  desc
                ]);
          }
        }
        return rue({
                    exp_desc: tmp,
                    exp_loc: loc,
                    exp_extra: /* [] */0,
                    exp_type: instance(void 0, env, desc.val_type),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  });
    case /* Pexp_constant */1 :
        var cst = match[0];
        if (cst.tag !== /* Const_string */2) {
          return rue({
                      exp_desc: /* Texp_constant */Block.__(1, [cst]),
                      exp_loc: loc,
                      exp_extra: /* [] */0,
                      exp_type: type_constant(cst),
                      exp_env: env,
                      exp_attributes: sexp.pexp_attributes
                    });
        }
        var ty_exp = expand_head(env, ty_expected);
        var fmt6_path_000 = /* Pident */Block.__(0, [{
              stamp: 0,
              name: "CamlinternalFormatBasics",
              flags: 1
            }]);
        var fmt6_path = /* Pdot */Block.__(1, [
            fmt6_path_000,
            "format6",
            0
          ]);
        var match$6 = ty_exp.desc;
        var is_format;
        if (typeof match$6 === "number" || !(match$6.tag === /* Tconstr */3 && same(match$6[0], fmt6_path))) {
          is_format = false;
        } else {
          if (principal.contents && ty_exp.level !== 100000000) {
            prerr_warning(loc, /* Not_principal */Block.__(8, ["this coercion to format6"]));
          }
          is_format = true;
        }
        if (!is_format) {
          return rue({
                      exp_desc: /* Texp_constant */Block.__(1, [cst]),
                      exp_loc: loc,
                      exp_extra: /* [] */0,
                      exp_type: instance_def(type_string),
                      exp_env: env,
                      exp_attributes: sexp.pexp_attributes
                    });
        }
        var init = type_format(loc, cst[0], env);
        var format_parsetree_pexp_desc = init.pexp_desc;
        var format_parsetree_pexp_loc = sexp.pexp_loc;
        var format_parsetree_pexp_attributes = init.pexp_attributes;
        var format_parsetree = {
          pexp_desc: format_parsetree_pexp_desc,
          pexp_loc: format_parsetree_pexp_loc,
          pexp_attributes: format_parsetree_pexp_attributes
        };
        return type_expect(in_function, env, format_parsetree, ty_expected);
    case /* Pexp_let */2 :
        var rec_flag = match[0];
        var exit = 0;
        if (rec_flag) {
          exit = 1;
        } else {
          var match$7 = match[1];
          if (match$7) {
            var match$8 = match$7[0];
            if (match$8.pvb_attributes || match$7[1]) {
              exit = 1;
            } else {
              var spat = match$8.pvb_pat;
              if (contains_gadt(env, spat)) {
                return type_expect(in_function, env, {
                            pexp_desc: /* Pexp_match */Block.__(6, [
                                match$8.pvb_expr,
                                /* :: */[
                                  Curry._3(Ast_helper_Exp.$$case, spat, void 0, match[2]),
                                  /* [] */0
                                ]
                              ]),
                            pexp_loc: sexp.pexp_loc,
                            pexp_attributes: sexp.pexp_attributes
                          }, ty_expected);
              }
              exit = 1;
            }
          } else {
            exit = 1;
          }
        }
        if (exit === 1) {
          var sbody = match[2];
          var match$9 = sexp.pexp_attributes;
          var scp;
          var exit$1 = 0;
          if (match$9 && match$9[0][0].txt === "#default" && !match$9[1]) {
            scp = void 0;
          } else {
            exit$1 = 2;
          }
          if (exit$1 === 2) {
            scp = rec_flag ? /* Idef */Block.__(1, [loc]) : /* Idef */Block.__(1, [sbody.pexp_loc]);
          }
          var match$10 = type_let(void 0, void 0, env, rec_flag, match[1], scp, true);
          var body = type_expect(void 0, match$10[1], wrap_unpacks(sbody, match$10[2]), ty_expected);
          return re({
                      exp_desc: /* Texp_let */Block.__(2, [
                          rec_flag,
                          match$10[0],
                          body
                        ]),
                      exp_loc: loc,
                      exp_extra: /* [] */0,
                      exp_type: body.exp_type,
                      exp_env: env,
                      exp_attributes: sexp.pexp_attributes
                    });
        }
        break;
    case /* Pexp_function */3 :
        return type_function(in_function, loc, sexp.pexp_attributes, env, ty_expected, "", match[0]);
    case /* Pexp_fun */4 :
        var match$11 = match[1];
        var l = match[0];
        if (match$11 !== void 0) {
          var $$default = match$11;
          if (!is_optional(l)) {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  /* tuple */[
                    "typecore.ml",
                    1852,
                    6
                  ]
                ];
          }
          var default_loc = $$default.pexp_loc;
          var scases_000 = Curry._3(Ast_helper_Exp.$$case, construct(default_loc, void 0, {
                    txt: /* Ldot */Block.__(1, [
                        /* Lident */Block.__(0, ["*predef*"]),
                        "Some"
                      ]),
                    loc: none
                  }, $$var$1(default_loc, void 0, {
                        txt: "*sth*",
                        loc: none
                      })), void 0, Curry._3(Ast_helper_Exp.ident, default_loc, void 0, {
                    txt: /* Lident */Block.__(0, ["*sth*"]),
                    loc: none
                  }));
          var scases_001 = /* :: */[
            Curry._3(Ast_helper_Exp.$$case, construct(default_loc, void 0, {
                      txt: /* Ldot */Block.__(1, [
                          /* Lident */Block.__(0, ["*predef*"]),
                          "None"
                        ]),
                      loc: none
                    }, void 0), void 0, $$default),
            /* [] */0
          ];
          var scases = /* :: */[
            scases_000,
            scases_001
          ];
          var smatch = Curry._4(Ast_helper_Exp.match_, loc, void 0, Curry._3(Ast_helper_Exp.ident, loc, void 0, {
                    txt: /* Lident */Block.__(0, ["*opt*"]),
                    loc: none
                  }), scases);
          var sfun = Curry._6(Ast_helper_Exp.fun_, loc, void 0, l, void 0, $$var$1(loc, void 0, {
                    txt: "*opt*",
                    loc: none
                  }), Curry._5(Ast_helper_Exp.let_, loc, /* :: */[
                    /* tuple */[
                      {
                        txt: "#default",
                        loc: none
                      },
                      /* PStr */Block.__(0, [/* [] */0])
                    ],
                    /* [] */0
                  ], /* Nonrecursive */0, /* :: */[
                    mk$17(void 0, void 0, void 0, void 0, match[2], smatch),
                    /* [] */0
                  ], match[3]));
          return type_expect(in_function, env, sfun, ty_expected);
        } else {
          var sexp$1 = match[3];
          return type_function(in_function, loc, sexp$1.pexp_attributes, env, ty_expected, l, /* :: */[
                      {
                        pc_lhs: match[2],
                        pc_guard: void 0,
                        pc_rhs: sexp$1
                      },
                      /* [] */0
                    ]);
        }
    case /* Pexp_apply */5 :
        var sargs = match[1];
        if (sargs === /* [] */0) {
          ill_formed_ast(loc, "Function application with no argument.");
        }
        begin_def(void 0);
        if (principal.contents) {
          begin_def(void 0);
        }
        var funct = type_exp(env, match[0]);
        if (principal.contents) {
          end_def(void 0);
          generalize_structure$1(current_level.contents, funct.exp_type);
        }
        var ty = instance(void 0, env, funct.exp_type);
        end_def(void 0);
        wrap_trace_gadt_instances(env, (function (param) {
                var _seen = /* [] */0;
                var _ty_fun = param;
                while(true) {
                  var ty_fun = _ty_fun;
                  var seen = _seen;
                  var ty = expand_head(env, ty_fun);
                  if (List.memq(ty, seen)) {
                    return ;
                  }
                  var match = ty.desc;
                  if (typeof match === "number") {
                    return ;
                  }
                  if (match.tag !== /* Tarrow */1) {
                    return ;
                  }
                  try {
                    unify_var(env, newvar(void 0, void 0), match[1]);
                  }
                  catch (raw_exn){
                    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                    if (exn[0] === Unify) {
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            /* tuple */[
                              "typecore.ml",
                              1903,
                              65
                            ]
                          ];
                    }
                    throw exn;
                  }
                  _ty_fun = match[2];
                  _seen = /* :: */[
                    ty,
                    seen
                  ];
                  continue ;
                };
              }), ty);
        begin_def(void 0);
        var match$12 = type_application(env, funct, sargs);
        end_def(void 0);
        unify_var(env, newvar(void 0, void 0), funct.exp_type);
        return rue({
                    exp_desc: /* Texp_apply */Block.__(4, [
                        funct,
                        match$12[0]
                      ]),
                    exp_loc: loc,
                    exp_extra: /* [] */0,
                    exp_type: match$12[1],
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  });
    case /* Pexp_match */6 :
        begin_def(void 0);
        var arg = type_exp(env, match[0]);
        end_def(void 0);
        if (is_nonexpansive(arg)) {
          iter_generalize$1({
                contents: /* [] */0
              }, arg.exp_type);
        } else {
          generalize_expansive$1(env, arg.exp_type);
        }
        var split_cases = function (_vc, _ec, _param) {
          while(true) {
            var param = _param;
            var ec = _ec;
            var vc = _vc;
            if (!param) {
              return /* tuple */[
                      List.rev(vc),
                      List.rev(ec)
                    ];
            }
            var c = param[0];
            var match = c.pc_lhs.ppat_desc;
            if (typeof match !== "number" && match.tag === /* Ppat_exception */14) {
              _param = param[1];
              _ec = /* :: */[
                {
                  pc_lhs: match[0],
                  pc_guard: c.pc_guard,
                  pc_rhs: c.pc_rhs
                },
                ec
              ];
              continue ;
            }
            _param = param[1];
            _vc = /* :: */[
              c,
              vc
            ];
            continue ;
          };
        };
        var match$13 = split_cases(/* [] */0, /* [] */0, match[1]);
        var exn_caselist = match$13[1];
        var val_caselist = match$13[0];
        if (val_caselist === /* [] */0 && exn_caselist !== /* [] */0) {
          throw [
                $$Error$7,
                loc,
                env,
                /* No_value_clauses */7
              ];
        }
        var match$14 = type_cases(void 0, env, arg.exp_type, ty_expected, true, loc, val_caselist);
        var match$15 = type_cases(void 0, env, type_exn, ty_expected, false, loc, exn_caselist);
        return re({
                    exp_desc: /* Texp_match */Block.__(5, [
                        arg,
                        match$14[0],
                        match$15[0],
                        match$14[1]
                      ]),
                    exp_loc: loc,
                    exp_extra: /* [] */0,
                    exp_type: instance(void 0, env, ty_expected),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  });
    case /* Pexp_try */7 :
        var body$1 = type_expect(void 0, env, match[0], ty_expected);
        var match$16 = type_cases(void 0, env, type_exn, ty_expected, false, loc, match[1]);
        return re({
                    exp_desc: /* Texp_try */Block.__(6, [
                        body$1,
                        match$16[0]
                      ]),
                    exp_loc: loc,
                    exp_extra: /* [] */0,
                    exp_type: body$1.exp_type,
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  });
    case /* Pexp_tuple */8 :
        var sexpl = match[0];
        if (List.length(sexpl) < 2) {
          ill_formed_ast(loc, "Tuples must have at least 2 components.");
        }
        var subtypes = List.map((function (param) {
                return newty2(100000000, /* Tvar */Block.__(0, [void 0]));
              }), sexpl);
        var to_unify = newty2(100000000, /* Ttuple */Block.__(2, [subtypes]));
        unify_exp_types(loc, env, to_unify, ty_expected);
        var expl = List.map2((function (body, ty) {
                return type_expect(void 0, env, body, ty);
              }), sexpl, subtypes);
        var desc$1 = /* Ttuple */Block.__(2, [List.map((function (e) {
                    return e.exp_type;
                  }), expl)]);
        return re({
                    exp_desc: /* Texp_tuple */Block.__(7, [expl]),
                    exp_loc: loc,
                    exp_extra: /* [] */0,
                    exp_type: newty2(current_level.contents, desc$1),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  });
    case /* Pexp_construct */9 :
        var lid$1 = match[0];
        var sarg = match[1];
        var attrs = sexp.pexp_attributes;
        var opath;
        try {
          var match$17 = extract_concrete_variant(env, ty_expected);
          opath = /* tuple */[
            match$17[0],
            match$17[1],
            ty_expected.level === 100000000 || !principal.contents
          ];
        }
        catch (exn){
          if (exn !== Caml_builtin_exceptions.not_found) {
            throw exn;
          }
          opath = void 0;
        }
        var constrs = find_all_constructors(env, lid$1.loc, lid$1.txt);
        var constr = wrap_disambiguate("This variant expression is expected to have", ty_expected, (function (param) {
                return disambiguate$1(void 0, void 0, void 0, lid$1, env, opath, param);
              }), constrs);
        mark_constructor(/* Positive */0, env, last$1(lid$1.txt), constr);
        check_deprecated(loc, constr.cstr_attributes, constr.cstr_name);
        var sargs$1;
        if (sarg !== void 0) {
          var se = sarg;
          var match$18 = se.pexp_desc;
          sargs$1 = match$18.tag === /* Pexp_tuple */8 && (constr.cstr_arity > 1 || explicit_arity(attrs)) ? match$18[0] : /* :: */[
              se,
              /* [] */0
            ];
        } else {
          sargs$1 = /* [] */0;
        }
        if (List.length(sargs$1) !== constr.cstr_arity) {
          throw [
                $$Error$7,
                loc,
                env,
                /* Constructor_arity_mismatch */Block.__(1, [
                    lid$1.txt,
                    constr.cstr_arity,
                    List.length(sargs$1)
                  ])
              ];
        }
        var separate = principal.contents || env.local_constraints;
        if (separate) {
          begin_def(void 0);
          begin_def(void 0);
        }
        var match$19 = instance_constructor(void 0, constr);
        var ty_res = match$19[1];
        var ty_args = match$19[0];
        var texp = re({
              exp_desc: /* Texp_construct */Block.__(8, [
                  lid$1,
                  constr,
                  /* [] */0
                ]),
              exp_loc: loc,
              exp_extra: /* [] */0,
              exp_type: ty_res,
              exp_env: env,
              exp_attributes: attrs
            });
        if (separate) {
          end_def(void 0);
          generalize_structure$1(current_level.contents, ty_res);
          unify_exp(env, {
                exp_desc: texp.exp_desc,
                exp_loc: texp.exp_loc,
                exp_extra: texp.exp_extra,
                exp_type: instance_def(ty_res),
                exp_env: texp.exp_env,
                exp_attributes: texp.exp_attributes
              }, instance(void 0, env, ty_expected));
          end_def(void 0);
          List.iter(generalize_structure$2, ty_args);
          generalize_structure$1(current_level.contents, ty_res);
        }
        var match$20 = instance_list(env, /* :: */[
              ty_res,
              ty_args
            ]);
        var match$21;
        if (!match$20) {
          throw [
                Caml_builtin_exceptions.assert_failure,
                /* tuple */[
                  "typecore.ml",
                  3375,
                  11
                ]
              ];
        }
        match$21 = /* tuple */[
          match$20[1],
          match$20[0]
        ];
        var ty_res$1 = match$21[1];
        var texp_exp_desc = texp.exp_desc;
        var texp_exp_loc = texp.exp_loc;
        var texp_exp_extra = texp.exp_extra;
        var texp_exp_env = texp.exp_env;
        var texp_exp_attributes = texp.exp_attributes;
        var texp$1 = {
          exp_desc: texp_exp_desc,
          exp_loc: texp_exp_loc,
          exp_extra: texp_exp_extra,
          exp_type: ty_res$1,
          exp_env: texp_exp_env,
          exp_attributes: texp_exp_attributes
        };
        if (!separate) {
          unify_exp(env, texp$1, instance(void 0, env, ty_expected));
        }
        var args = List.map2((function (e, param) {
                return type_argument(env, e, param[0], param[1]);
              }), sargs$1, List.combine(ty_args, match$21[0]));
        if (constr.cstr_private === /* Private */0) {
          throw [
                $$Error$7,
                loc,
                env,
                /* Private_type */Block.__(19, [ty_res$1])
              ];
        }
        return {
                exp_desc: /* Texp_construct */Block.__(8, [
                    lid$1,
                    constr,
                    args
                  ]),
                exp_loc: texp_exp_loc,
                exp_extra: texp_exp_extra,
                exp_type: ty_res$1,
                exp_env: texp_exp_env,
                exp_attributes: texp_exp_attributes
              };
    case /* Pexp_variant */10 :
        var sarg$1 = match[1];
        var l$1 = match[0];
        var ty_expected0 = instance(void 0, env, ty_expected);
        try {
          var match$22 = expand_head(env, ty_expected);
          var match$23 = expand_head(env, ty_expected0);
          if (sarg$1 === void 0) {
            throw Caml_builtin_exceptions.not_found;
          }
          var match$24 = match$22.desc;
          if (typeof match$24 === "number") {
            throw Caml_builtin_exceptions.not_found;
          }
          if (match$24.tag !== /* Tvariant */8) {
            throw Caml_builtin_exceptions.not_found;
          }
          var match$25 = match$23.desc;
          if (typeof match$25 === "number") {
            throw Caml_builtin_exceptions.not_found;
          }
          if (match$25.tag !== /* Tvariant */8) {
            throw Caml_builtin_exceptions.not_found;
          }
          var row = row_repr_aux(/* [] */0, match$24[0]);
          var match$26 = row_field_repr_aux(/* [] */0, List.assoc(l$1, row.row_fields));
          var match$27 = row_field_repr_aux(/* [] */0, List.assoc(l$1, match$25[0].row_fields));
          if (typeof match$26 === "number") {
            throw Caml_builtin_exceptions.not_found;
          }
          if (match$26.tag) {
            throw Caml_builtin_exceptions.not_found;
          }
          var match$28 = match$26[0];
          if (match$28 === void 0) {
            throw Caml_builtin_exceptions.not_found;
          }
          if (typeof match$27 === "number") {
            throw Caml_builtin_exceptions.not_found;
          }
          if (match$27.tag) {
            throw Caml_builtin_exceptions.not_found;
          }
          var match$29 = match$27[0];
          if (match$29 === void 0) {
            throw Caml_builtin_exceptions.not_found;
          }
          var arg$1 = type_argument(env, sarg$1, match$28, match$29);
          return re({
                      exp_desc: /* Texp_variant */Block.__(9, [
                          l$1,
                          arg$1
                        ]),
                      exp_loc: loc,
                      exp_extra: /* [] */0,
                      exp_type: ty_expected0,
                      exp_env: env,
                      exp_attributes: sexp.pexp_attributes
                    });
        }
        catch (exn$1){
          if (exn$1 !== Caml_builtin_exceptions.not_found) {
            throw exn$1;
          }
          var arg$2 = may_map((function (param) {
                  return type_exp(env, param);
                }), sarg$1);
          var arg_type = may_map((function (arg) {
                  return arg.exp_type;
                }), arg$2);
          var desc$2 = /* Tvariant */Block.__(8, [{
                row_fields: /* :: */[
                  /* tuple */[
                    l$1,
                    /* Rpresent */Block.__(0, [arg_type])
                  ],
                  /* [] */0
                ],
                row_more: newvar(void 0, void 0),
                row_bound: void 0,
                row_closed: false,
                row_fixed: false,
                row_name: void 0
              }]);
          return rue({
                      exp_desc: /* Texp_variant */Block.__(9, [
                          l$1,
                          arg$2
                        ]),
                      exp_loc: loc,
                      exp_extra: /* [] */0,
                      exp_type: newty2(current_level.contents, desc$2),
                      exp_env: env,
                      exp_attributes: sexp.pexp_attributes
                    });
        }
    case /* Pexp_record */11 :
        var opt_sexp = match[1];
        var lid_sexp_list = match[0];
        if (lid_sexp_list === /* [] */0) {
          ill_formed_ast(loc, "Records cannot be empty.");
        }
        var opt_exp;
        if (opt_sexp !== void 0) {
          if (principal.contents) {
            begin_def(void 0);
          }
          var exp = type_exp(env, opt_sexp);
          if (principal.contents) {
            end_def(void 0);
            generalize_structure$1(current_level.contents, exp.exp_type);
          }
          opt_exp = exp;
        } else {
          opt_exp = void 0;
        }
        var get_path = function (ty) {
          try {
            var match = extract_concrete_record(env, ty);
            return /* tuple */[
                    match[0],
                    match[1],
                    ty.level === 100000000 || !principal.contents
                  ];
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              return ;
            }
            throw exn;
          }
        };
        var op = get_path(ty_expected);
        var match$30;
        if (op !== void 0) {
          match$30 = /* tuple */[
            ty_expected,
            op
          ];
        } else if (opt_exp !== void 0) {
          var op$1 = get_path(opt_exp.exp_type);
          if (op$1 !== void 0) {
            var p$prime = op$1[1];
            var decl = find_type_full(p$prime, env)[0];
            begin_def(void 0);
            var ty$1 = newconstr(p$prime, instance_list(env, decl.type_params));
            end_def(void 0);
            generalize_structure$1(current_level.contents, ty$1);
            match$30 = /* tuple */[
              ty$1,
              op$1
            ];
          } else {
            match$30 = /* tuple */[
              newvar(void 0, void 0),
              void 0
            ];
          }
        } else {
          match$30 = /* tuple */[
            newvar(void 0, void 0),
            void 0
          ];
        }
        var opath$1 = match$30[1];
        var ty_record = match$30[0];
        var closed = opt_sexp === void 0;
        var lbl_exp_list = wrap_disambiguate("This record expression is expected to have", ty_record, (function (param) {
                return type_label_a_list(void 0, loc, closed, env, (function (param) {
                              return type_label_exp(true, env, loc, ty_record, param);
                            }), opath$1, param);
              }), lid_sexp_list);
        unify_exp_types(loc, env, ty_record, instance(void 0, env, ty_expected));
        var check_duplicates = function (_param) {
          while(true) {
            var param = _param;
            if (!param) {
              return ;
            }
            var rem = param[1];
            var lbl1 = param[0][1];
            if (rem) {
              if (lbl1.lbl_pos === rem[0][1].lbl_pos) {
                throw [
                      $$Error$7,
                      loc,
                      env,
                      /* Label_multiply_defined */Block.__(10, [lbl1.lbl_name])
                    ];
              }
              _param = rem;
              continue ;
            } else {
              _param = rem;
              continue ;
            }
          };
        };
        check_duplicates(lbl_exp_list);
        var opt_exp$1;
        if (opt_exp !== void 0) {
          if (!lbl_exp_list) {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  /* tuple */[
                    "typecore.ml",
                    2092,
                    15
                  ]
                ];
          }
          var exp$1 = opt_exp;
          var ty_exp$1 = instance(void 0, env, exp$1.exp_type);
          var unify_kept = function (lbl) {
            if (!List.for_all((function (param) {
                      return param[1].lbl_pos !== lbl.lbl_pos;
                    }), lbl_exp_list)) {
              return ;
            }
            var match = instance_label(false, lbl);
            var match$1 = instance_label(false, lbl);
            unify$2(env, match[1], match$1[1]);
            unify$2(env, instance(void 0, env, ty_expected), match$1[2]);
            return unify_exp_types(exp$1.exp_loc, env, ty_exp$1, match[2]);
          };
          $$Array.iter(unify_kept, lbl_exp_list[0][1].lbl_all);
          opt_exp$1 = {
            exp_desc: exp$1.exp_desc,
            exp_loc: exp$1.exp_loc,
            exp_extra: exp$1.exp_extra,
            exp_type: ty_exp$1,
            exp_env: exp$1.exp_env,
            exp_attributes: exp$1.exp_attributes
          };
        } else {
          opt_exp$1 = void 0;
        }
        var num_fields;
        if (!lbl_exp_list) {
          throw [
                Caml_builtin_exceptions.assert_failure,
                /* tuple */[
                  "typecore.ml",
                  2095,
                  38
                ]
              ];
        }
        num_fields = lbl_exp_list[0][1].lbl_all.length;
        if (opt_sexp === void 0 && List.length(lid_sexp_list) !== num_fields) {
          var present_indices = List.map((function (param) {
                  return param[1].lbl_pos;
                }), lbl_exp_list);
          var label_names = extract_label_names(sexp, env, ty_expected);
          var missing_labels = function (_n, _param) {
            while(true) {
              var param = _param;
              var n = _n;
              if (!param) {
                return /* [] */0;
              }
              var rem = param[1];
              if (!List.mem(n, present_indices)) {
                return /* :: */[
                        param[0],
                        missing_labels(n + 1 | 0, rem)
                      ];
              }
              _param = rem;
              _n = n + 1 | 0;
              continue ;
            };
          };
          var missing = missing_labels(0, label_names);
          throw [
                $$Error$7,
                loc,
                env,
                /* Label_missing */Block.__(11, [missing])
              ];
        } else if (opt_sexp !== void 0 && List.length(lid_sexp_list) === num_fields) {
          prerr_warning(loc, /* Useless_record_with */11);
        }
        return re({
                    exp_desc: /* Texp_record */Block.__(10, [
                        lbl_exp_list,
                        opt_exp$1
                      ]),
                    exp_loc: loc,
                    exp_extra: /* [] */0,
                    exp_type: instance(void 0, env, ty_expected),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  });
    case /* Pexp_field */12 :
        var lid$2 = match[1];
        var match$31 = type_label_access(env, loc, match[0], lid$2);
        var label = match$31[1];
        var record$3 = match$31[0];
        var match$32 = instance_label(false, label);
        unify_exp(env, record$3, match$32[2]);
        return rue({
                    exp_desc: /* Texp_field */Block.__(11, [
                        record$3,
                        lid$2,
                        label
                      ]),
                    exp_loc: loc,
                    exp_extra: /* [] */0,
                    exp_type: match$32[1],
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  });
    case /* Pexp_setfield */13 :
        var lid$3 = match[1];
        var match$33 = type_label_access(env, loc, match[0], lid$3);
        var record$4 = match$33[0];
        var ty_record$1 = match$33[2] === void 0 ? newvar(void 0, void 0) : record$4.exp_type;
        var match$34 = type_label_exp(false, env, loc, ty_record$1, /* tuple */[
              lid$3,
              match$33[1],
              match[2]
            ]);
        var label$1 = match$34[1];
        unify_exp(env, record$4, ty_record$1);
        if (label$1.lbl_mut === /* Immutable */0) {
          throw [
                $$Error$7,
                loc,
                env,
                /* Label_not_mutable */Block.__(12, [lid$3.txt])
              ];
        }
        return rue({
                    exp_desc: /* Texp_setfield */Block.__(12, [
                        record$4,
                        match$34[0],
                        label$1,
                        match$34[2]
                      ]),
                    exp_loc: loc,
                    exp_extra: /* [] */0,
                    exp_type: instance_def(type_unit),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  });
    case /* Pexp_array */14 :
        var ty$2 = newty2(100000000, /* Tvar */Block.__(0, [void 0]));
        var to_unify$1 = type_array(ty$2);
        unify_exp_types(loc, env, to_unify$1, ty_expected);
        var argl = List.map((function (sarg) {
                return type_expect(void 0, env, sarg, ty$2);
              }), match[0]);
        return re({
                    exp_desc: /* Texp_array */Block.__(13, [argl]),
                    exp_loc: loc,
                    exp_extra: /* [] */0,
                    exp_type: instance(void 0, env, ty_expected),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  });
    case /* Pexp_ifthenelse */15 :
        var sifnot = match[2];
        var sifso = match[1];
        var cond = type_expect(void 0, env, match[0], type_bool);
        if (sifnot !== void 0) {
          var ifso = type_expect(void 0, env, sifso, ty_expected);
          var ifnot = type_expect(void 0, env, sifnot, ty_expected);
          unify_exp(env, ifnot, ifso.exp_type);
          return re({
                      exp_desc: /* Texp_ifthenelse */Block.__(14, [
                          cond,
                          ifso,
                          ifnot
                        ]),
                      exp_loc: loc,
                      exp_extra: /* [] */0,
                      exp_type: ifso.exp_type,
                      exp_env: env,
                      exp_attributes: sexp.pexp_attributes
                    });
        } else {
          var ifso$1 = type_expect(void 0, env, sifso, type_unit);
          return rue({
                      exp_desc: /* Texp_ifthenelse */Block.__(14, [
                          cond,
                          ifso$1,
                          void 0
                        ]),
                      exp_loc: loc,
                      exp_extra: /* [] */0,
                      exp_type: ifso$1.exp_type,
                      exp_env: env,
                      exp_attributes: sexp.pexp_attributes
                    });
        }
    case /* Pexp_sequence */16 :
        var exp1 = type_statement(env, match[0]);
        var exp2 = type_expect(void 0, env, match[1], ty_expected);
        return re({
                    exp_desc: /* Texp_sequence */Block.__(15, [
                        exp1,
                        exp2
                      ]),
                    exp_loc: loc,
                    exp_extra: /* [] */0,
                    exp_type: exp2.exp_type,
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  });
    case /* Pexp_while */17 :
        var cond$1 = type_expect(void 0, env, match[0], type_bool);
        var body$2 = type_statement(env, match[1]);
        return rue({
                    exp_desc: /* Texp_while */Block.__(16, [
                        cond$1,
                        body$2
                      ]),
                    exp_loc: loc,
                    exp_extra: /* [] */0,
                    exp_type: instance_def(type_unit),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  });
    case /* Pexp_for */18 :
        var param = match[0];
        var low = type_expect(void 0, env, match[1], type_int);
        var high = type_expect(void 0, env, match[2], type_int);
        var match$35 = param.ppat_desc;
        var match$36;
        if (typeof match$35 === "number") {
          match$36 = /* tuple */[
            create("_for"),
            env
          ];
        } else {
          if (match$35.tag) {
            throw [
                  $$Error$7,
                  param.ppat_loc,
                  env,
                  /* Invalid_for_loop_index */6
                ];
          }
          match$36 = enter_value((function (s) {
                    return /* Unused_for_index */Block.__(19, [s]);
                  }))(match$35[0].txt, {
                val_type: instance_def(type_int),
                val_kind: /* Val_reg */0,
                val_loc: loc,
                val_attributes: /* [] */0
              }, env);
        }
        var body$3 = type_statement(match$36[1], match[4]);
        return rue({
                    exp_desc: /* Texp_for */Block.__(17, [
                        match$36[0],
                        param,
                        low,
                        high,
                        match[3],
                        body$3
                      ]),
                    exp_loc: loc,
                    exp_extra: /* [] */0,
                    exp_type: instance_def(type_unit),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  });
    case /* Pexp_constraint */19 :
        var sarg$2 = match[0];
        begin_def(void 0);
        var cty = transl_simple_type(env, false, match[1]);
        var ty$3 = cty.ctyp_type;
        end_def(void 0);
        generalize_structure$1(current_level.contents, ty$3);
        var match_000 = type_argument(env, sarg$2, ty$3, instance(void 0, env, ty$3));
        var match_001 = instance(void 0, env, ty$3);
        var arg$3 = match_000;
        return rue({
                    exp_desc: arg$3.exp_desc,
                    exp_loc: arg$3.exp_loc,
                    exp_extra: /* :: */[
                      /* tuple */[
                        /* Texp_constraint */Block.__(0, [cty]),
                        loc,
                        sexp.pexp_attributes
                      ],
                      arg$3.exp_extra
                    ],
                    exp_type: match_001,
                    exp_env: env,
                    exp_attributes: arg$3.exp_attributes
                  });
    case /* Pexp_coerce */20 :
        var sty$prime = match[2];
        var sty = match[1];
        var sarg$3 = match[0];
        var match$37;
        if (sty !== void 0) {
          begin_def(void 0);
          var match$38 = transl_simple_type_delayed(env, sty);
          var cty$1 = match$38[0];
          var match$39 = transl_simple_type_delayed(env, sty$prime);
          var cty$prime = match$39[0];
          var ty$4 = cty$1.ctyp_type;
          var ty$prime = cty$prime.ctyp_type;
          try {
            var force$prime$prime = subtype(env, ty$4, ty$prime);
            Curry._1(match$38[1], void 0);
            Curry._1(match$39[1], void 0);
            Curry._1(force$prime$prime, void 0);
          }
          catch (raw_exn){
            var exn$2 = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn$2[0] === Subtype) {
              throw [
                    $$Error$7,
                    loc,
                    env,
                    /* Not_subtype */Block.__(23, [
                        exn$2[1],
                        exn$2[2]
                      ])
                  ];
            }
            throw exn$2;
          }
          end_def(void 0);
          generalize_structure$1(current_level.contents, ty$4);
          generalize_structure$1(current_level.contents, ty$prime);
          match$37 = /* tuple */[
            type_argument(env, sarg$3, ty$4, instance(void 0, env, ty$4)),
            instance(void 0, env, ty$prime),
            cty$1,
            cty$prime
          ];
        } else {
          var match$40 = transl_simple_type_delayed(env, sty$prime);
          var force = match$40[1];
          var cty$prime$1 = match$40[0];
          var ty$prime$1 = cty$prime$1.ctyp_type;
          begin_def(void 0);
          var arg$4 = type_exp(env, sarg$3);
          end_def(void 0);
          var tv = newvar(void 0, void 0);
          var gen = generalizable(tv.level, arg$4.exp_type);
          unify_var(env, tv, arg$4.exp_type);
          var gen$1 = gen;
          var match$41 = arg$4.exp_desc;
          var match$42 = self_coercion.contents;
          var match$43 = repr(ty$prime$1).desc;
          var exit$2 = 0;
          if (match$41.tag) {
            exit$2 = 1;
          } else {
            var tmp$2 = match$41[2].val_kind;
            if (typeof tmp$2 === "number" || !(tmp$2.tag === /* Val_self */2 && match$42 && !(typeof match$43 === "number" || match$43.tag !== /* Tconstr */3))) {
              exit$2 = 1;
            } else {
              var match$44 = match$42[0];
              var r = match$44[1];
              if (same(match$44[0], match$43[0])) {
                r.contents = /* :: */[
                  loc,
                  r.contents
                ];
                Curry._1(force, void 0);
              } else {
                exit$2 = 1;
              }
            }
          }
          if (exit$2 === 1) {
            if (free_variables$1(Caml_option.some(env), arg$4.exp_type) === /* [] */0 && free_variables$1(Caml_option.some(env), ty$prime$1) === /* [] */0) {
              var tmp$3 = false;
              if (!gen$1) {
                var snap = snapshot(void 0);
                var match$45 = enlarge_type(env, ty$prime$1);
                var tmp$4;
                try {
                  Curry._1(force, void 0);
                  unify$2(env, arg$4.exp_type, match$45[0]);
                  tmp$4 = true;
                }
                catch (raw_exn$1){
                  var exn$3 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
                  if (exn$3[0] !== Unify) {
                    throw exn$3;
                  }
                  backtrack(snap);
                  tmp$4 = false;
                }
                tmp$3 = tmp$4;
              }
              if (!tmp$3) {
                try {
                  var force$prime = subtype(env, arg$4.exp_type, ty$prime$1);
                  Curry._1(force, void 0);
                  Curry._1(force$prime, void 0);
                  if (!gen$1) {
                    prerr_warning(loc, /* Not_principal */Block.__(8, ["this ground coercion"]));
                  }
                  
                }
                catch (raw_exn$2){
                  var exn$4 = Caml_js_exceptions.internalToOCamlException(raw_exn$2);
                  if (exn$4[0] === Subtype) {
                    throw [
                          $$Error$7,
                          loc,
                          env,
                          /* Not_subtype */Block.__(23, [
                              exn$4[1],
                              exn$4[2]
                            ])
                        ];
                  }
                  throw exn$4;
                }
              }
              
            } else {
              var match$46 = enlarge_type(env, ty$prime$1);
              Curry._1(force, void 0);
              try {
                unify$2(env, arg$4.exp_type, match$46[0]);
              }
              catch (raw_exn$3){
                var exn$5 = Caml_js_exceptions.internalToOCamlException(raw_exn$3);
                if (exn$5[0] === Unify) {
                  throw [
                        $$Error$7,
                        sarg$3.pexp_loc,
                        env,
                        /* Coercion_failure */Block.__(25, [
                            ty$prime$1,
                            full_expand(env, ty$prime$1),
                            exn$5[1],
                            match$46[1]
                          ])
                      ];
                }
                throw exn$5;
              }
            }
          }
          match$37 = /* tuple */[
            arg$4,
            ty$prime$1,
            void 0,
            cty$prime$1
          ];
        }
        var arg$5 = match$37[0];
        return rue({
                    exp_desc: arg$5.exp_desc,
                    exp_loc: arg$5.exp_loc,
                    exp_extra: /* :: */[
                      /* tuple */[
                        /* Texp_coerce */Block.__(1, [
                            match$37[2],
                            match$37[3]
                          ]),
                        loc,
                        sexp.pexp_attributes
                      ],
                      arg$5.exp_extra
                    ],
                    exp_type: match$37[1],
                    exp_env: env,
                    exp_attributes: arg$5.exp_attributes
                  });
    case /* Pexp_send */21 :
        var met = match[1];
        var e = match[0];
        if (principal.contents) {
          begin_def(void 0);
        }
        var obj = type_exp(env, e);
        try {
          var match$47 = obj.exp_desc;
          var match$48;
          var exit$3 = 0;
          if (match$47.tag) {
            exit$3 = 1;
          } else {
            var match$49 = match$47[2].val_kind;
            var lid$4 = match$47[1];
            if (typeof match$49 === "number") {
              exit$3 = 1;
            } else {
              switch (match$49.tag | 0) {
                case /* Val_self */2 :
                    var match$50 = filter_self_method(env, met, /* Private */0, match$49[0], match$49[3]);
                    var typ = match$50[1];
                    if (is_Tvar(repr(typ))) {
                      prerr_warning(loc, /* Undeclared_virtual_method */Block.__(7, [met]));
                    }
                    match$48 = /* tuple */[
                      /* Tmeth_val */Block.__(1, [match$50[0]]),
                      void 0,
                      typ
                    ];
                    break;
                case /* Val_anc */3 :
                    var cl_num = match$49[1];
                    var method_id;
                    try {
                      method_id = List.assoc(met, match$49[0]);
                    }
                    catch (exn$6){
                      if (exn$6 === Caml_builtin_exceptions.not_found) {
                        throw [
                              $$Error$7,
                              e.pexp_loc,
                              env,
                              /* Undefined_inherited_method */Block.__(17, [met])
                            ];
                      }
                      throw exn$6;
                    }
                    var match$51 = lookup_value$1(/* Lident */Block.__(0, ["selfpat-" + cl_num]), env);
                    var match$52 = lookup_value$1(/* Lident */Block.__(0, ["self-" + cl_num]), env);
                    var desc$3 = match$51[1];
                    var match$53 = desc$3.val_kind;
                    if (typeof match$53 === "number") {
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            /* tuple */[
                              "typecore.ml",
                              2384,
                              18
                            ]
                          ];
                    }
                    if (match$53.tag !== /* Val_self */2) {
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            /* tuple */[
                              "typecore.ml",
                              2384,
                              18
                            ]
                          ];
                    }
                    var match$54 = filter_self_method(env, met, /* Private */0, match$53[0], match$53[3]);
                    var typ$1 = match$54[1];
                    var method_type = newvar(void 0, void 0);
                    var match$55 = filter_arrow(env, method_type, "");
                    unify$2(env, match$55[0], desc$3.val_type);
                    unify$2(env, match$55[1], instance(void 0, env, typ$1));
                    var exp_000 = {
                      exp_desc: /* Texp_ident */Block.__(0, [
                          /* Pident */Block.__(0, [method_id]),
                          lid$4,
                          {
                            val_type: method_type,
                            val_kind: /* Val_reg */0,
                            val_loc: none,
                            val_attributes: /* [] */0
                          }
                        ]),
                      exp_loc: loc,
                      exp_extra: /* [] */0,
                      exp_type: method_type,
                      exp_env: env,
                      exp_attributes: /* [] */0
                    };
                    var exp_001 = /* :: */[
                      /* tuple */[
                        "",
                        {
                          exp_desc: /* Texp_ident */Block.__(0, [
                              match$52[0],
                              lid$4,
                              desc$3
                            ]),
                          exp_loc: obj.exp_loc,
                          exp_extra: /* [] */0,
                          exp_type: desc$3.val_type,
                          exp_env: env,
                          exp_attributes: /* [] */0
                        },
                        /* Required */0
                      ],
                      /* [] */0
                    ];
                    var exp$2 = /* Texp_apply */Block.__(4, [
                        exp_000,
                        exp_001
                      ]);
                    match$48 = /* tuple */[
                      /* Tmeth_name */Block.__(0, [met]),
                      re({
                            exp_desc: exp$2,
                            exp_loc: loc,
                            exp_extra: /* [] */0,
                            exp_type: typ$1,
                            exp_env: env,
                            exp_attributes: /* [] */0
                          }),
                      typ$1
                    ];
                    break;
                default:
                  exit$3 = 1;
              }
            }
          }
          if (exit$3 === 1) {
            match$48 = /* tuple */[
              /* Tmeth_name */Block.__(0, [met]),
              void 0,
              filter_method(env, met, /* Public */1, obj.exp_type)
            ];
          }
          var typ$2 = match$48[2];
          if (principal.contents) {
            end_def(void 0);
            generalize_structure$1(current_level.contents, typ$2);
          }
          var ty$5 = repr(typ$2);
          var match$56 = ty$5.desc;
          var typ$3;
          if (typeof match$56 === "number") {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  /* tuple */[
                    "typecore.ml",
                    2410,
                    14
                  ]
                ];
          }
          switch (match$56.tag | 0) {
            case /* Tvar */0 :
                var ty$prime$2 = newvar(void 0, void 0);
                unify$2(env, instance_def(ty$5), newty2(current_level.contents, /* Tpoly */Block.__(10, [
                            ty$prime$2,
                            /* [] */0
                          ])));
                typ$3 = ty$prime$2;
                break;
            case /* Tpoly */10 :
                var tl = match$56[1];
                var ty$6 = match$56[0];
                if (tl) {
                  var l$2 = ty$5.level;
                  if (principal.contents && l$2 !== 100000000) {
                    prerr_warning(loc, /* Not_principal */Block.__(8, ["this use of a polymorphic method"]));
                  }
                  typ$3 = instance_poly(void 0, false, tl, ty$6)[1];
                } else {
                  typ$3 = instance(void 0, env, ty$6);
                }
                break;
            default:
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    /* tuple */[
                      "typecore.ml",
                      2410,
                      14
                    ]
                  ];
          }
          return rue({
                      exp_desc: /* Texp_send */Block.__(18, [
                          obj,
                          match$48[0],
                          match$48[1]
                        ]),
                      exp_loc: loc,
                      exp_extra: /* [] */0,
                      exp_type: typ$3,
                      exp_env: env,
                      exp_attributes: sexp.pexp_attributes
                    });
        }
        catch (raw_exn$4){
          var exn$7 = Caml_js_exceptions.internalToOCamlException(raw_exn$4);
          if (exn$7[0] === Unify) {
            throw [
                  $$Error$7,
                  e.pexp_loc,
                  env,
                  /* Undefined_method */Block.__(16, [
                      obj.exp_type,
                      met
                    ])
                ];
          }
          throw exn$7;
        }
        break;
    case /* Pexp_new */22 :
        var cl = match[0];
        var match$57 = find_class$1(env, loc, cl.txt);
        var cl_decl = match$57[1];
        var match$58 = cl_decl.cty_new;
        if (match$58 !== void 0) {
          return rue({
                      exp_desc: /* Texp_new */Block.__(19, [
                          match$57[0],
                          cl,
                          cl_decl
                        ]),
                      exp_loc: loc,
                      exp_extra: /* [] */0,
                      exp_type: instance_def(match$58),
                      exp_env: env,
                      exp_attributes: sexp.pexp_attributes
                    });
        }
        throw [
              $$Error$7,
              loc,
              env,
              /* Virtual_class */Block.__(18, [cl.txt])
            ];
    case /* Pexp_setinstvar */23 :
        var lab = match[0];
        try {
          var match$59 = lookup_value$1(/* Lident */Block.__(0, [lab.txt]), env);
          var desc$4 = match$59[1];
          var match$60 = desc$4.val_kind;
          var exit$4 = 0;
          if (typeof match$60 === "number" || match$60.tag !== /* Val_ivar */1) {
            exit$4 = 1;
          } else {
            if (!match$60[0]) {
              throw [
                    $$Error$7,
                    loc,
                    env,
                    /* Instance_variable_not_mutable */Block.__(22, [
                        true,
                        lab.txt
                      ])
                  ];
            }
            var newval = type_expect(void 0, env, match[1], instance(void 0, env, desc$4.val_type));
            var match$61 = lookup_value$1(/* Lident */Block.__(0, ["self-" + match$60[1]]), env);
            return rue({
                        exp_desc: /* Texp_setinstvar */Block.__(21, [
                            match$61[0],
                            match$59[0],
                            lab,
                            newval
                          ]),
                        exp_loc: loc,
                        exp_extra: /* [] */0,
                        exp_type: instance_def(type_unit),
                        exp_env: env,
                        exp_attributes: sexp.pexp_attributes
                      });
          }
          if (exit$4 === 1) {
            throw [
                  $$Error$7,
                  loc,
                  env,
                  /* Instance_variable_not_mutable */Block.__(22, [
                      false,
                      lab.txt
                    ])
                ];
          }
          
        }
        catch (exn$8){
          if (exn$8 === Caml_builtin_exceptions.not_found) {
            throw [
                  $$Error$7,
                  loc,
                  env,
                  /* Unbound_instance_variable */Block.__(21, [lab.txt])
                ];
          }
          throw exn$8;
        }
        break;
    case /* Pexp_override */24 :
        var lst = match[0];
        List.fold_right((function (param, l) {
                var lab = param[0];
                if (List.exists((function (l) {
                          return l.txt === lab.txt;
                        }), l)) {
                  throw [
                        $$Error$7,
                        loc,
                        env,
                        /* Value_multiply_overridden */Block.__(24, [lab.txt])
                      ];
                }
                return /* :: */[
                        lab,
                        l
                      ];
              }), lst, /* [] */0);
        var match$62;
        try {
          match$62 = /* tuple */[
            lookup_value$1(/* Lident */Block.__(0, ["selfpat-*"]), env),
            lookup_value$1(/* Lident */Block.__(0, ["self-*"]), env)
          ];
        }
        catch (exn$9){
          if (exn$9 === Caml_builtin_exceptions.not_found) {
            throw [
                  $$Error$7,
                  loc,
                  env,
                  /* Outside_class */0
                ];
          }
          throw exn$9;
        }
        var match$63 = match$62[0][1];
        var match$64 = match$63.val_kind;
        if (typeof match$64 === "number") {
          throw [
                Caml_builtin_exceptions.assert_failure,
                /* tuple */[
                  "typecore.ml",
                  2494,
                  10
                ]
              ];
        }
        if (match$64.tag !== /* Val_self */2) {
          throw [
                Caml_builtin_exceptions.assert_failure,
                /* tuple */[
                  "typecore.ml",
                  2494,
                  10
                ]
              ];
        }
        var vars = match$64[1];
        var type_override = function (param) {
          var lab = param[0];
          try {
            var match = find(lab.txt, vars.contents);
            return /* tuple */[
                    /* Pident */Block.__(0, [match[0]]),
                    lab,
                    type_expect(void 0, env, param[1], instance(void 0, env, match[3]))
                  ];
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              throw [
                    $$Error$7,
                    loc,
                    env,
                    /* Unbound_instance_variable */Block.__(21, [lab.txt])
                  ];
            }
            throw exn;
          }
        };
        var modifs = List.map(type_override, lst);
        return rue({
                    exp_desc: /* Texp_override */Block.__(22, [
                        match$62[1][0],
                        modifs
                      ]),
                    exp_loc: loc,
                    exp_extra: /* [] */0,
                    exp_type: match$63.val_type,
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  });
    case /* Pexp_letmodule */25 :
        var name$2 = match[0];
        var ty$7 = newvar(void 0, void 0);
        begin_def(void 0);
        set_current_time(ty$7.level);
        var context = narrow(void 0);
        var modl = Curry._2(type_module.contents, env, match[1]);
        var match$65 = enter_module(void 0, name$2.txt, modl.mod_type, env);
        var new_env = match$65[1];
        init_def(currentstamp.contents);
        widen(context);
        var body$4 = type_expect(void 0, new_env, match[2], ty_expected);
        end_def(void 0);
        try {
          unify_var(new_env, ty$7, body$4.exp_type);
        }
        catch (raw_exn$5){
          var exn$10 = Caml_js_exceptions.internalToOCamlException(raw_exn$5);
          if (exn$10[0] === Unify) {
            throw [
                  $$Error$7,
                  loc,
                  env,
                  /* Scoping_let_module */Block.__(28, [
                      name$2.txt,
                      body$4.exp_type
                    ])
                ];
          }
          throw exn$10;
        }
        return re({
                    exp_desc: /* Texp_letmodule */Block.__(23, [
                        match$65[0],
                        name$2,
                        modl,
                        body$4
                      ]),
                    exp_loc: loc,
                    exp_extra: /* [] */0,
                    exp_type: ty$7,
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  });
    case /* Pexp_assert */26 :
        var cond$2 = type_expect(void 0, env, match[0], type_bool);
        var match$66 = cond$2.exp_desc;
        var exp_type;
        exp_type = match$66.tag === /* Texp_construct */8 && match$66[1].cstr_name === "false" ? instance(void 0, env, ty_expected) : instance_def(type_unit);
        return rue({
                    exp_desc: /* Texp_assert */Block.__(24, [cond$2]),
                    exp_loc: loc,
                    exp_extra: /* [] */0,
                    exp_type: exp_type,
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  });
    case /* Pexp_lazy */27 :
        var ty$8 = newty2(100000000, /* Tvar */Block.__(0, [void 0]));
        var to_unify$2 = type_lazy_t(ty$8);
        unify_exp_types(loc, env, to_unify$2, ty_expected);
        var arg$6 = type_expect(void 0, env, match[0], ty$8);
        return re({
                    exp_desc: /* Texp_lazy */Block.__(25, [arg$6]),
                    exp_loc: loc,
                    exp_extra: /* [] */0,
                    exp_type: instance(void 0, env, ty_expected),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  });
    case /* Pexp_poly */28 :
        var sty$1 = match[1];
        var sbody$1 = match[0];
        if (principal.contents) {
          begin_def(void 0);
        }
        var match$67;
        if (sty$1 !== void 0) {
          var sty$2 = force_poly(sty$1);
          var cty$2 = transl_simple_type(env, false, sty$2);
          match$67 = /* tuple */[
            repr(cty$2.ctyp_type),
            cty$2
          ];
        } else {
          match$67 = /* tuple */[
            repr(ty_expected),
            void 0
          ];
        }
        var ty$9 = match$67[0];
        if (principal.contents) {
          end_def(void 0);
          generalize_structure$1(current_level.contents, ty$9);
        }
        if (sty$1 !== void 0) {
          unify_exp_types(loc, env, instance(void 0, env, ty$9), instance(void 0, env, ty_expected));
        }
        var match$68 = expand_head(env, ty$9).desc;
        var exp$3;
        if (typeof match$68 === "number") {
          throw [
                Caml_builtin_exceptions.assert_failure,
                /* tuple */[
                  "typecore.ml",
                  2600,
                  15
                ]
              ];
        }
        switch (match$68.tag | 0) {
          case /* Tvar */0 :
              var exp$4 = type_exp(env, sbody$1);
              var exp_exp_desc = exp$4.exp_desc;
              var exp_exp_loc = exp$4.exp_loc;
              var exp_exp_extra = exp$4.exp_extra;
              var exp_exp_type = newty2(current_level.contents, /* Tpoly */Block.__(10, [
                      exp$4.exp_type,
                      /* [] */0
                    ]));
              var exp_exp_env = exp$4.exp_env;
              var exp_exp_attributes = exp$4.exp_attributes;
              var exp$5 = {
                exp_desc: exp_exp_desc,
                exp_loc: exp_exp_loc,
                exp_extra: exp_exp_extra,
                exp_type: exp_exp_type,
                exp_env: exp_exp_env,
                exp_attributes: exp_exp_attributes
              };
              unify_exp(env, exp$5, ty$9);
              exp$3 = exp$5;
              break;
          case /* Tpoly */10 :
              var tl$1 = match$68[1];
              var ty$prime$3 = match$68[0];
              if (tl$1) {
                begin_def(void 0);
                if (principal.contents) {
                  begin_def(void 0);
                }
                var match$69 = instance_poly(void 0, true, tl$1, ty$prime$3);
                var ty$prime$prime = match$69[1];
                if (principal.contents) {
                  end_def(void 0);
                  generalize_structure$1(current_level.contents, ty$prime$prime);
                }
                var exp$6 = type_expect(void 0, env, sbody$1, ty$prime$prime);
                end_def(void 0);
                check_univars(env, false, "method", exp$6, ty_expected, match$69[0]);
                exp$3 = {
                  exp_desc: exp$6.exp_desc,
                  exp_loc: exp$6.exp_loc,
                  exp_extra: exp$6.exp_extra,
                  exp_type: instance(void 0, env, ty$9),
                  exp_env: exp$6.exp_env,
                  exp_attributes: exp$6.exp_attributes
                };
              } else {
                var exp$7 = type_expect(void 0, env, sbody$1, ty$prime$3);
                exp$3 = {
                  exp_desc: exp$7.exp_desc,
                  exp_loc: exp$7.exp_loc,
                  exp_extra: exp$7.exp_extra,
                  exp_type: instance(void 0, env, ty$9),
                  exp_env: exp$7.exp_env,
                  exp_attributes: exp$7.exp_attributes
                };
              }
              break;
          default:
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  /* tuple */[
                    "typecore.ml",
                    2600,
                    15
                  ]
                ];
        }
        return re({
                    exp_desc: exp$3.exp_desc,
                    exp_loc: exp$3.exp_loc,
                    exp_extra: /* :: */[
                      /* tuple */[
                        /* Texp_poly */Block.__(3, [match$67[1]]),
                        loc,
                        sexp.pexp_attributes
                      ],
                      exp$3.exp_extra
                    ],
                    exp_type: exp$3.exp_type,
                    exp_env: exp$3.exp_env,
                    exp_attributes: exp$3.exp_attributes
                  });
    case /* Pexp_object */29 :
        var match$70 = Curry._3(type_object.contents, env, loc, match[0]);
        return rue({
                    exp_desc: /* Texp_object */Block.__(26, [
                        match$70[0],
                        match$70[2]
                      ]),
                    exp_loc: loc,
                    exp_extra: /* [] */0,
                    exp_type: match$70[1].csig_self,
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  });
    case /* Pexp_newtype */30 :
        var name$3 = match[0];
        var ty$10 = newvar(void 0, void 0);
        begin_def(void 0);
        var level = current_level.contents;
        var decl_type_newtype_level = /* tuple */[
          level,
          level
        ];
        var decl$1 = {
          type_params: /* [] */0,
          type_arity: 0,
          type_kind: /* Type_abstract */0,
          type_private: /* Public */1,
          type_manifest: void 0,
          type_variance: /* [] */0,
          type_newtype_level: decl_type_newtype_level,
          type_loc: loc,
          type_attributes: /* [] */0
        };
        set_current_time(ty$10.level);
        var match$71 = enter_type(name$3, decl$1, env);
        var id = match$71[0];
        init_def(currentstamp.contents);
        var body$5 = type_exp(match$71[1], match[1]);
        var seen = Hashtbl.create(void 0, 8);
        var replace = function (t) {
          if (Hashtbl.mem(seen, t.id)) {
            return ;
          }
          Hashtbl.add(seen, t.id, void 0);
          var match = t.desc;
          if (typeof match === "number") {
            return iter_type_expr(replace, t);
          }
          if (match.tag !== /* Tconstr */3) {
            return iter_type_expr(replace, t);
          }
          var match$1 = match[0];
          switch (match$1.tag | 0) {
            case /* Pident */0 :
                if (id === match$1[0]) {
                  return link_type(t, ty$10);
                } else {
                  return iter_type_expr(replace, t);
                }
            case /* Pdot */1 :
            case /* Papply */2 :
                return iter_type_expr(replace, t);
            
          }
        };
        var ety = type_expr(identity, body$5.exp_type);
        replace(ety);
        end_def(void 0);
        return rue({
                    exp_desc: body$5.exp_desc,
                    exp_loc: loc,
                    exp_extra: /* :: */[
                      /* tuple */[
                        /* Texp_newtype */Block.__(4, [name$3]),
                        loc,
                        sexp.pexp_attributes
                      ],
                      body$5.exp_extra
                    ],
                    exp_type: ety,
                    exp_env: body$5.exp_env,
                    exp_attributes: body$5.exp_attributes
                  });
    case /* Pexp_pack */31 :
        var match$72 = expand_head(env, instance(void 0, env, ty_expected));
        var match$73 = match$72.desc;
        var match$74;
        if (typeof match$73 === "number") {
          throw [
                $$Error$7,
                loc,
                env,
                /* Not_a_packed_module */Block.__(32, [ty_expected])
              ];
        }
        switch (match$73.tag | 0) {
          case /* Tvar */0 :
              throw [
                    $$Error$7,
                    loc,
                    env,
                    /* Cannot_infer_signature */3
                  ];
          case /* Tpackage */11 :
              if (principal.contents && expand_head(env, ty_expected).level < 100000000) {
                prerr_warning(loc, /* Not_principal */Block.__(8, ["this module packing"]));
              }
              match$74 = /* tuple */[
                match$73[0],
                match$73[1],
                match$73[2]
              ];
              break;
          default:
            throw [
                  $$Error$7,
                  loc,
                  env,
                  /* Not_a_packed_module */Block.__(32, [ty_expected])
                ];
        }
        var nl = match$74[1];
        var p = match$74[0];
        var match$75 = Curry._5(type_package.contents, env, match[0], p, nl, match$74[2]);
        return rue({
                    exp_desc: /* Texp_pack */Block.__(27, [match$75[0]]),
                    exp_loc: loc,
                    exp_extra: /* [] */0,
                    exp_type: newty2(current_level.contents, /* Tpackage */Block.__(11, [
                            p,
                            nl,
                            match$75[1]
                          ])),
                    exp_env: env,
                    exp_attributes: sexp.pexp_attributes
                  });
    case /* Pexp_open */32 :
        var lid$5 = match[1];
        var ovf = match[0];
        var match$76 = Curry._4(type_open.contents, ovf, env, sexp.pexp_loc, lid$5);
        var newenv = match$76[1];
        var exp$8 = type_expect(void 0, newenv, match[2], ty_expected);
        return {
                exp_desc: exp$8.exp_desc,
                exp_loc: exp$8.exp_loc,
                exp_extra: /* :: */[
                  /* tuple */[
                    /* Texp_open */Block.__(2, [
                        ovf,
                        match$76[0],
                        lid$5,
                        newenv
                      ]),
                    loc,
                    sexp.pexp_attributes
                  ],
                  exp$8.exp_extra
                ],
                exp_type: exp$8.exp_type,
                exp_env: exp$8.exp_env,
                exp_attributes: exp$8.exp_attributes
              };
    case /* Pexp_extension */33 :
        throw [
              Error_forward$1,
              error_of_extension(match[0])
            ];
    
  }
}

function type_function(in_function, loc, attrs, env, ty_expected, l, caselist) {
  var match = in_function !== void 0 ? in_function : /* tuple */[
      loc,
      instance(void 0, env, ty_expected)
    ];
  var ty_fun = match[1];
  var loc_fun = match[0];
  var separate = principal.contents || env.local_constraints;
  if (separate) {
    begin_def(void 0);
  }
  var match$1;
  try {
    match$1 = filter_arrow(env, instance(void 0, env, ty_expected), l);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] !== Unify) {
      throw exn;
    }
    var ty = expand_head(env, ty_expected);
    var match$2 = ty.desc;
    var exit = 0;
    if (typeof match$2 === "number") {
      exit = 1;
    } else {
      if (match$2.tag === /* Tarrow */1) {
        throw [
              $$Error$7,
              loc,
              env,
              /* Abstract_wrong_label */Block.__(27, [
                  l,
                  ty
                ])
            ];
      }
      exit = 1;
    }
    if (exit === 1) {
      throw [
            $$Error$7,
            loc_fun,
            env,
            /* Too_many_arguments */Block.__(26, [
                in_function !== void 0,
                ty_fun
              ])
          ];
    }
    
  }
  var ty_res = match$1[1];
  var ty_arg = match$1[0];
  var ty_arg$1;
  if (is_optional(l)) {
    var tv = newvar(void 0, void 0);
    try {
      unify$2(env, ty_arg, type_option$1(tv));
    }
    catch (raw_exn$1){
      var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
      if (exn$1[0] === Unify) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "typecore.ml",
                2706,
                24
              ]
            ];
      }
      throw exn$1;
    }
    ty_arg$1 = type_option$1(tv);
  } else {
    ty_arg$1 = ty_arg;
  }
  if (separate) {
    end_def(void 0);
    generalize_structure$1(current_level.contents, ty_arg$1);
    generalize_structure$1(current_level.contents, ty_res);
  }
  var match$3 = type_cases(/* tuple */[
        loc_fun,
        ty_fun
      ], env, ty_arg$1, ty_res, true, loc, caselist);
  var cases = match$3[0];
  var not_function = function (ty) {
    var match = list_labels(env, ty);
    if (match[0] === /* [] */0) {
      return !match[1];
    } else {
      return false;
    }
  };
  if (is_optional(l) && not_function(ty_res)) {
    prerr_warning(List.hd(cases).c_lhs.pat_loc, /* Unerasable_optional_argument */8);
  }
  return re({
              exp_desc: /* Texp_function */Block.__(3, [
                  l,
                  cases,
                  match$3[1]
                ]),
              exp_loc: loc,
              exp_extra: /* [] */0,
              exp_type: instance(void 0, env, newty2(100000000, /* Tarrow */Block.__(1, [
                          l,
                          ty_arg$1,
                          ty_res,
                          /* Cok */0
                        ]))),
              exp_env: env,
              exp_attributes: attrs
            });
}

function type_label_access(env, loc, srecord, lid) {
  if (principal.contents) {
    begin_def(void 0);
  }
  var record = type_exp(env, srecord);
  if (principal.contents) {
    end_def(void 0);
    generalize_structure$1(current_level.contents, record.exp_type);
  }
  var ty_exp = record.exp_type;
  var opath;
  try {
    var match = extract_concrete_record(env, ty_exp);
    opath = /* tuple */[
      match[0],
      match[1],
      ty_exp.level === 100000000 || !principal.contents
    ];
  }
  catch (exn){
    if (exn !== Caml_builtin_exceptions.not_found) {
      throw exn;
    }
    opath = void 0;
  }
  var labels = find_all_labels(env, lid.loc, lid.txt);
  var label = wrap_disambiguate("This expression has", ty_exp, (function (param) {
          return disambiguate(void 0, void 0, void 0, lid, env, opath, param);
        }), labels);
  return /* tuple */[
          record,
          label,
          opath
        ];
}

function type_format(loc, str, env) {
  throw [
        Caml_builtin_exceptions.assert_failure,
        /* tuple */[
          "typecore.ml",
          2759,
          11
        ]
      ];
}

function type_label_exp(create, env, loc, ty_expected, param) {
  var sarg = param[2];
  var label = param[1];
  var lid = param[0];
  begin_def(void 0);
  var separate = principal.contents || env.local_constraints;
  if (separate) {
    begin_def(void 0);
    begin_def(void 0);
  }
  var match = instance_label(true, label);
  var ty_res = match[2];
  var ty_arg = match[1];
  var vars = match[0];
  if (separate) {
    end_def(void 0);
    generalize_structure$1(current_level.contents, ty_arg);
    generalize_structure$1(current_level.contents, ty_res);
  }
  try {
    unify$2(env, instance_def(ty_res), instance(void 0, env, ty_expected));
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === Unify) {
      throw [
            $$Error$7,
            lid.loc,
            env,
            /* Label_mismatch */Block.__(2, [
                lid.txt,
                exn[1]
              ])
          ];
    }
    throw exn;
  }
  var ty_arg$1 = instance_def(ty_arg);
  if (separate) {
    end_def(void 0);
    generalize_structure$1(current_level.contents, ty_arg$1);
  }
  if (label.lbl_private === /* Private */0) {
    if (create) {
      throw [
            $$Error$7,
            loc,
            env,
            /* Private_type */Block.__(19, [ty_expected])
          ];
    }
    throw [
          $$Error$7,
          lid.loc,
          env,
          /* Private_label */Block.__(20, [
              lid.txt,
              ty_expected
            ])
        ];
  }
  var snap = vars === /* [] */0 ? void 0 : Caml_option.some(snapshot(void 0));
  var arg = type_argument(env, sarg, ty_arg$1, instance(void 0, env, ty_arg$1));
  end_def(void 0);
  var arg$1;
  try {
    check_univars(env, vars !== /* [] */0, "field value", arg, label.lbl_arg, vars);
    arg$1 = arg;
  }
  catch (exn$1){
    if (is_nonexpansive(arg)) {
      throw exn$1;
    }
    try {
      may(backtrack, snap);
      begin_def(void 0);
      var arg$2 = type_exp(env, sarg);
      end_def(void 0);
      generalize_expansive$1(env, arg$2.exp_type);
      unify_exp(env, arg$2, ty_arg$1);
      check_univars(env, false, "field value", arg$2, label.lbl_arg, vars);
      arg$1 = arg$2;
    }
    catch (raw_e){
      var e = Caml_js_exceptions.internalToOCamlException(raw_e);
      if (e[0] !== $$Error$7) {
        throw exn$1;
      }
      var tmp = e[3];
      if (typeof tmp === "number") {
        throw exn$1;
      }
      if (tmp.tag === /* Less_general */31) {
        throw e;
      }
      throw exn$1;
    }
  }
  return /* tuple */[
          lid,
          label,
          {
            exp_desc: arg$1.exp_desc,
            exp_loc: arg$1.exp_loc,
            exp_extra: arg$1.exp_extra,
            exp_type: instance(void 0, env, arg$1.exp_type),
            exp_env: arg$1.exp_env,
            exp_attributes: arg$1.exp_attributes
          }
        ];
}

function type_argument(env, sarg, ty_expected$prime, ty_expected) {
  var no_labels = function (ty) {
    var match = list_labels(env, ty);
    if (match[1]) {
      return false;
    } else {
      return List.for_all((function (param) {
                    return "" === param;
                  }), match[0]);
    }
  };
  var is_inferred = function (_sexp) {
    while(true) {
      var sexp = _sexp;
      var match = sexp.pexp_desc;
      switch (match.tag | 0) {
        case /* Pexp_ifthenelse */15 :
            var match$1 = match[2];
            if (match$1 === void 0) {
              return false;
            }
            if (!is_inferred(match[1])) {
              return false;
            }
            _sexp = match$1;
            continue ;
        case /* Pexp_sequence */16 :
            _sexp = match[1];
            continue ;
        case /* Pexp_ident */0 :
        case /* Pexp_apply */5 :
        case /* Pexp_field */12 :
        case /* Pexp_constraint */19 :
        case /* Pexp_coerce */20 :
        case /* Pexp_send */21 :
        case /* Pexp_new */22 :
            return true;
        case /* Pexp_open */32 :
            _sexp = match[2];
            continue ;
        default:
          return false;
      }
    };
  };
  var match = expand_head(env, ty_expected$prime);
  var match$1 = match.desc;
  if (typeof match$1 !== "number" && match$1.tag === /* Tarrow */1 && match$1[0] === "") {
    var ty_res = match$1[2];
    var lv = match.level;
    if (is_inferred(sarg)) {
      if (principal.contents) {
        begin_def(void 0);
      }
      var texp = type_exp(env, sarg);
      if (principal.contents) {
        end_def(void 0);
        generalize_structure$1(current_level.contents, texp.exp_type);
      }
      var make_args = function (_args, _ty_fun) {
        while(true) {
          var ty_fun = _ty_fun;
          var args = _args;
          var match = expand_head(env, ty_fun).desc;
          if (typeof match !== "number") {
            switch (match.tag | 0) {
              case /* Tvar */0 :
                  return /* tuple */[
                          List.rev(args),
                          ty_fun,
                          false
                        ];
              case /* Tarrow */1 :
                  var ty_fun$1 = match[2];
                  var l = match[0];
                  if (is_optional(l)) {
                    var ty = option_none(instance(void 0, env, match[1]), sarg.pexp_loc);
                    _ty_fun = ty_fun$1;
                    _args = /* :: */[
                      /* tuple */[
                        l,
                        ty,
                        /* Optional */1
                      ],
                      args
                    ];
                    continue ;
                  } else if (l === "" || classic.contents) {
                    return /* tuple */[
                            List.rev(args),
                            ty_fun,
                            no_labels(ty_fun$1)
                          ];
                  }
                  break;
              default:
                
            }
          }
          return /* tuple */[
                  /* [] */0,
                  texp.exp_type,
                  false
                ];
        };
      };
      var match$2 = make_args(/* [] */0, texp.exp_type);
      var ty_fun$prime = match$2[1];
      var args = match$2[0];
      var warn = principal.contents && (lv !== 100000000 || repr(ty_fun$prime).level !== 100000000);
      var texp_exp_desc = texp.exp_desc;
      var texp_exp_loc = texp.exp_loc;
      var texp_exp_extra = texp.exp_extra;
      var texp_exp_type = instance(void 0, env, texp.exp_type);
      var texp_exp_env = texp.exp_env;
      var texp_exp_attributes = texp.exp_attributes;
      var texp$1 = {
        exp_desc: texp_exp_desc,
        exp_loc: texp_exp_loc,
        exp_extra: texp_exp_extra,
        exp_type: texp_exp_type,
        exp_env: texp_exp_env,
        exp_attributes: texp_exp_attributes
      };
      var ty_fun = instance(void 0, env, ty_fun$prime);
      if (match$2[2] || no_labels(ty_res)) {
        unify_exp(env, {
              exp_desc: texp_exp_desc,
              exp_loc: texp_exp_loc,
              exp_extra: texp_exp_extra,
              exp_type: ty_fun,
              exp_env: texp_exp_env,
              exp_attributes: texp_exp_attributes
            }, ty_expected);
        if (args === /* [] */0) {
          return texp$1;
        }
        var var_pair = function (name, ty) {
          var id = create(name);
          return /* tuple */[
                  {
                    pat_desc: /* Tpat_var */Block.__(0, [
                        id,
                        {
                          txt: name,
                          loc: none
                        }
                      ]),
                    pat_loc: none,
                    pat_extra: /* [] */0,
                    pat_type: ty,
                    pat_env: env,
                    pat_attributes: /* [] */0
                  },
                  {
                    exp_desc: /* Texp_ident */Block.__(0, [
                        /* Pident */Block.__(0, [id]),
                        {
                          txt: /* Lident */Block.__(0, [name]),
                          loc: none
                        },
                        {
                          val_type: ty,
                          val_kind: /* Val_reg */0,
                          val_loc: none,
                          val_attributes: /* [] */0
                        }
                      ]),
                    exp_loc: none,
                    exp_extra: /* [] */0,
                    exp_type: ty,
                    exp_env: env,
                    exp_attributes: /* [] */0
                  }
                ];
        };
        var match$3 = var_pair("eta", match$1[1]);
        var eta_var = match$3[1];
        var eta_pat = match$3[0];
        var func = function (texp) {
          var e_exp_desc = /* Texp_apply */Block.__(4, [
              texp,
              Pervasives.$at(args, /* :: */[
                    /* tuple */[
                      "",
                      eta_var,
                      /* Required */0
                    ],
                    /* [] */0
                  ])
            ]);
          var e_exp_loc = texp.exp_loc;
          var e_exp_extra = texp.exp_extra;
          var e_exp_env = texp.exp_env;
          var e_exp_attributes = texp.exp_attributes;
          var e = {
            exp_desc: e_exp_desc,
            exp_loc: e_exp_loc,
            exp_extra: e_exp_extra,
            exp_type: ty_res,
            exp_env: e_exp_env,
            exp_attributes: e_exp_attributes
          };
          return {
                  exp_desc: /* Texp_function */Block.__(3, [
                      "",
                      /* :: */[
                        {
                          c_lhs: eta_pat,
                          c_guard: void 0,
                          c_rhs: e
                        },
                        /* [] */0
                      ],
                      /* Total */1
                    ]),
                  exp_loc: texp.exp_loc,
                  exp_extra: texp.exp_extra,
                  exp_type: ty_fun,
                  exp_env: texp.exp_env,
                  exp_attributes: texp.exp_attributes
                };
        };
        prerr_warning(texp_exp_loc, /* Eliminated_optional_arguments */Block.__(31, [List.map((function (param) {
                        return param[0];
                      }), args)]));
        if (warn) {
          prerr_warning(texp_exp_loc, /* Without_principality */Block.__(9, ["eliminated optional argument"]));
        }
        if (is_nonexpansive(texp$1)) {
          return func(texp$1);
        }
        var match$4 = var_pair("arg", texp_exp_type);
        return re({
                    exp_desc: /* Texp_let */Block.__(2, [
                        /* Nonrecursive */0,
                        /* :: */[
                          {
                            vb_pat: match$4[0],
                            vb_expr: texp$1,
                            vb_attributes: /* [] */0,
                            vb_loc: none
                          },
                          /* [] */0
                        ],
                        func(match$4[1])
                      ]),
                    exp_loc: texp_exp_loc,
                    exp_extra: texp_exp_extra,
                    exp_type: ty_fun,
                    exp_env: texp_exp_env,
                    exp_attributes: texp_exp_attributes
                  });
      } else {
        unify_exp(env, texp$1, ty_expected);
        return texp$1;
      }
    }
    
  }
  var texp$2 = type_expect(void 0, env, sarg, ty_expected$prime);
  unify_exp(env, texp$2, ty_expected);
  return texp$2;
}

function type_application(env, funct, sargs) {
  var result_type = function (omitted, ty_fun) {
    return List.fold_left((function (ty_fun, param) {
                  return newty2(param[2], /* Tarrow */Block.__(1, [
                                param[0],
                                param[1],
                                ty_fun,
                                /* Cok */0
                              ]));
                }), ty_fun, omitted);
  };
  var has_label = function (l, ty_fun) {
    var match = list_labels(env, ty_fun);
    if (match[1]) {
      return true;
    } else {
      return List.mem(l, match[0]);
    }
  };
  var ignored = {
    contents: /* [] */0
  };
  var ignore_labels = true;
  if (!classic.contents) {
    var match = list_labels(env, funct.exp_type);
    var tmp = false;
    if (!match[1]) {
      var labels = List.filter((function (l) {
                return !is_optional(l);
              }))(match[0]);
      tmp = List.length(labels) === List.length(sargs) && List.for_all((function (param) {
              return param[0] === "";
            }), sargs) && List.exists((function (l) {
              return l !== "";
            }), labels) && (prerr_warning(funct.exp_loc, /* Labels_omitted */3), true);
    }
    ignore_labels = tmp;
  }
  var warned = {
    contents: false
  };
  var type_args = function (_args, _omitted, _ty_fun, _ty_fun0, _ty_old, _sargs, _more_sargs) {
    while(true) {
      var more_sargs = _more_sargs;
      var sargs = _sargs;
      var ty_old = _ty_old;
      var ty_fun0 = _ty_fun0;
      var ty_fun = _ty_fun;
      var omitted = _omitted;
      var args = _args;
      var match = expand_head(env, ty_fun);
      var match$1 = expand_head(env, ty_fun0);
      var match$2 = match.desc;
      var exit = 0;
      if (typeof match$2 === "number" || match$2.tag !== /* Tarrow */1) {
        exit = 1;
      } else {
        var ty_fun$1 = match$2[2];
        var ty = match$2[1];
        var l = match$2[0];
        var lv = match.level;
        var match$3 = match$1.desc;
        if (typeof match$3 === "number" || match$3.tag !== /* Tarrow */1) {
          exit = 1;
        } else {
          var ty0 = match$3[1];
          if ((sargs !== /* [] */0 || more_sargs !== /* [] */0) && commu_repr(match$2[3]) === /* Cok */0) {
            var may_warn = (function(lv){
            return function may_warn(loc, w) {
              if (!warned.contents && principal.contents && lv !== 100000000) {
                warned.contents = true;
                return prerr_warning(loc, w);
              }
              
            }
            }(lv));
            var name = label_name(l);
            var optional = is_optional(l) ? /* Optional */1 : /* Required */0;
            var match$4;
            if (ignore_labels && !is_optional(l)) {
              if (sargs) {
                var match$5 = sargs[0];
                throw [
                      $$Error$7,
                      match$5[1].pexp_loc,
                      env,
                      /* Apply_wrong_label */Block.__(9, [
                          match$5[0],
                          ty_old
                        ])
                    ];
              } else {
                if (!more_sargs) {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        /* tuple */[
                          "typecore.ml",
                          3250,
                          16
                        ]
                      ];
                }
                var match$6 = more_sargs[0];
                var sarg0 = match$6[1];
                var l$prime = match$6[0];
                if (l !== l$prime && l$prime !== "") {
                  throw [
                        $$Error$7,
                        sarg0.pexp_loc,
                        env,
                        /* Apply_wrong_label */Block.__(9, [
                            l$prime,
                            match
                          ])
                      ];
                }
                match$4 = /* tuple */[
                  /* [] */0,
                  more_sargs[1],
                  (function(ty,ty0,sarg0){
                  return function (param) {
                    return type_argument(env, sarg0, ty, ty0);
                  }
                  }(ty,ty0,sarg0))
                ];
              }
            } else {
              try {
                var match$7;
                try {
                  var match$8 = extract_label_aux(/* [] */0, name, sargs);
                  var sargs1 = match$8[2];
                  var sarg0$1 = match$8[1];
                  if (sargs1 !== /* [] */0) {
                    may_warn(sarg0$1.pexp_loc, /* Not_principal */Block.__(8, ["commuting this argument"]));
                  }
                  match$7 = /* tuple */[
                    match$8[0],
                    sarg0$1,
                    Pervasives.$at(sargs1, match$8[3]),
                    more_sargs
                  ];
                }
                catch (exn){
                  if (exn !== Caml_builtin_exceptions.not_found) {
                    throw exn;
                  }
                  var match$9 = extract_label_aux(/* [] */0, name, more_sargs);
                  var sargs1$1 = match$9[2];
                  var sarg0$2 = match$9[1];
                  if (sargs1$1 !== /* [] */0 || sargs !== /* [] */0) {
                    may_warn(sarg0$2.pexp_loc, /* Not_principal */Block.__(8, ["commuting this argument"]));
                  }
                  match$7 = /* tuple */[
                    match$9[0],
                    sarg0$2,
                    Pervasives.$at(sargs, sargs1$1),
                    match$9[3]
                  ];
                }
                var sarg0$3 = match$7[1];
                var l$prime$1 = match$7[0];
                if (optional === /* Required */0 && is_optional(l$prime$1)) {
                  prerr_warning(sarg0$3.pexp_loc, /* Nonoptional_label */Block.__(26, [l]));
                }
                match$4 = /* tuple */[
                  match$7[2],
                  match$7[3],
                  optional === /* Required */0 || is_optional(l$prime$1) ? (function(ty,ty0,sarg0$3){
                    return function (param) {
                      return type_argument(env, sarg0$3, ty, ty0);
                    }
                    }(ty,ty0,sarg0$3)) : (may_warn(sarg0$3.pexp_loc, /* Not_principal */Block.__(8, ["using an optional argument here"])), (function(ty,ty0,sarg0$3){
                      return function (param) {
                        return option_some(type_argument(env, sarg0$3, extract_option_type(env, ty), extract_option_type(env, ty0)));
                      }
                      }(ty,ty0,sarg0$3)))
                ];
              }
              catch (exn$1){
                if (exn$1 !== Caml_builtin_exceptions.not_found) {
                  throw exn$1;
                }
                match$4 = /* tuple */[
                  sargs,
                  more_sargs,
                  optional === /* Optional */1 && (List.mem_assoc("", sargs) || List.mem_assoc("", more_sargs)) ? (may_warn(funct.exp_loc, /* Without_principality */Block.__(9, ["eliminated optional argument"])), ignored.contents = /* :: */[
                        /* tuple */[
                          l,
                          ty,
                          lv
                        ],
                        ignored.contents
                      ], (function(ty){
                      return function (param) {
                        return option_none(instance(void 0, env, ty), none);
                      }
                      }(ty))) : (may_warn(funct.exp_loc, /* Without_principality */Block.__(9, ["commuted an argument"])), void 0)
                ];
              }
            }
            var arg = match$4[2];
            var sargs$1 = match$4[0];
            var omitted$1 = arg === void 0 ? /* :: */[
                /* tuple */[
                  l,
                  ty,
                  lv
                ],
                omitted
              ] : omitted;
            var ty_old$1 = sargs$1 === /* [] */0 ? ty_fun$1 : ty_old;
            _more_sargs = match$4[1];
            _sargs = sargs$1;
            _ty_old = ty_old$1;
            _ty_fun0 = match$3[2];
            _ty_fun = ty_fun$1;
            _omitted = omitted$1;
            _args = /* :: */[
              /* tuple */[
                l,
                arg,
                optional
              ],
              args
            ];
            continue ;
          } else {
            exit = 1;
          }
        }
      }
      if (exit === 1) {
        if (sargs && ignore_labels) {
          var match$10 = sargs[0];
          throw [
                $$Error$7,
                match$10[1].pexp_loc,
                env,
                /* Apply_wrong_label */Block.__(9, [
                    match$10[0],
                    ty_old
                  ])
              ];
        }
        var _args$1 = args;
        var _ty_fun$1 = ty_fun0;
        var _param = Pervasives.$at(sargs, more_sargs);
        while(true) {
          var param = _param;
          var ty_fun$2 = _ty_fun$1;
          var args$1 = _args$1;
          if (!param) {
            return /* tuple */[
                    List.map((function (param) {
                            var match = param[1];
                            var l = param[0];
                            if (match !== void 0) {
                              return /* tuple */[
                                      l,
                                      Curry._1(match, void 0),
                                      param[2]
                                    ];
                            } else {
                              return /* tuple */[
                                      l,
                                      void 0,
                                      param[2]
                                    ];
                            }
                          }), List.rev(args$1)),
                    instance(void 0, env, result_type(omitted, ty_fun$2))
                  ];
          }
          var match$11 = param[0];
          var sarg1 = match$11[1];
          var l1 = match$11[0];
          var ty_fun$3 = expand_head(env, ty_fun$2);
          var td = ty_fun$3.desc;
          var match$12;
          var exit$1 = 0;
          if (typeof td === "number") {
            exit$1 = 1;
          } else {
            switch (td.tag | 0) {
              case /* Tvar */0 :
                  var t1 = newvar(void 0, void 0);
                  var t2 = newvar(void 0, void 0);
                  var not_identity = function (param) {
                    if (param.tag) {
                      return true;
                    }
                    var match = param[2].val_kind;
                    if (typeof match === "number" || match.tag || match[0].prim_name !== "%identity") {
                      return true;
                    } else {
                      return false;
                    }
                  };
                  if (ty_fun$3.level >= t1.level && not_identity(funct.exp_desc)) {
                    prerr_warning(sarg1.pexp_loc, /* Unused_argument */9);
                  }
                  unify$2(env, ty_fun$3, newty2(current_level.contents, /* Tarrow */Block.__(1, [
                              l1,
                              t1,
                              t2,
                              /* Clink */[{
                                  contents: /* Cunknown */1
                                }]
                            ])));
                  match$12 = /* tuple */[
                    t1,
                    t2
                  ];
                  break;
              case /* Tarrow */1 :
                  var l$1 = td[0];
                  if (l$1 === l1 || classic.contents && l1 === "" && !is_optional(l$1)) {
                    match$12 = /* tuple */[
                      td[1],
                      td[2]
                    ];
                  } else {
                    exit$1 = 1;
                  }
                  break;
              default:
                exit$1 = 1;
            }
          }
          if (exit$1 === 1) {
            var ty_fun$4;
            ty_fun$4 = typeof td === "number" || td.tag !== /* Tarrow */1 ? ty_fun$3 : newty2(current_level.contents, td);
            var ty_res = result_type(Pervasives.$at(omitted, ignored.contents), ty_fun$4);
            var match$13 = ty_res.desc;
            var exit$2 = 0;
            if (typeof match$13 === "number" || match$13.tag !== /* Tarrow */1) {
              exit$2 = 2;
            } else {
              if (classic.contents || !has_label(l1, ty_fun$4)) {
                throw [
                      $$Error$7,
                      sarg1.pexp_loc,
                      env,
                      /* Apply_wrong_label */Block.__(9, [
                          l1,
                          ty_res
                        ])
                    ];
              }
              throw [
                    $$Error$7,
                    funct.exp_loc,
                    env,
                    /* Incoherent_label_order */1
                  ];
            }
            if (exit$2 === 2) {
              throw [
                    $$Error$7,
                    funct.exp_loc,
                    env,
                    /* Apply_non_function */Block.__(8, [expand_head(env, funct.exp_type)])
                  ];
            }
            
          }
          var ty1 = match$12[0];
          var optional$1 = is_optional(l1) ? /* Optional */1 : /* Required */0;
          var arg1 = (function(sarg1,ty1,optional$1){
          return function arg1(param) {
            var arg1$1 = type_expect(void 0, env, sarg1, ty1);
            if (optional$1 === /* Optional */1) {
              unify_exp(env, arg1$1, type_option$1(newvar(void 0, void 0)));
            }
            return arg1$1;
          }
          }(sarg1,ty1,optional$1));
          _param = param[1];
          _ty_fun$1 = match$12[1];
          _args$1 = /* :: */[
            /* tuple */[
              l1,
              arg1,
              optional$1
            ],
            args$1
          ];
          continue ;
        };
      }
      
    };
  };
  var match$1 = funct.exp_desc;
  if (!match$1.tag) {
    var match$2 = match$1[2].val_kind;
    if (typeof match$2 !== "number" && !match$2.tag && match$2[0].prim_name === "%ignore" && sargs) {
      var match$3 = sargs[0];
      if (match$3[0] === "" && !sargs[1]) {
        var match$4 = filter_arrow(env, instance(void 0, env, funct.exp_type), "");
        var exp = type_expect(void 0, env, match$3[1], match$4[0]);
        var match$5 = expand_head(env, exp.exp_type).desc;
        if (typeof match$5 !== "number") {
          switch (match$5.tag | 0) {
            case /* Tvar */0 :
                add_delayed_check((function (param) {
                        return check_application_result(env, false, exp);
                      }));
                break;
            case /* Tarrow */1 :
                prerr_warning(exp.exp_loc, /* Partial_application */2);
                break;
            default:
              
          }
        }
        return /* tuple */[
                /* :: */[
                  /* tuple */[
                    "",
                    exp,
                    /* Required */0
                  ],
                  /* [] */0
                ],
                match$4[1]
              ];
      }
      
    }
    
  }
  var ty = funct.exp_type;
  if (ignore_labels) {
    return type_args(/* [] */0, /* [] */0, ty, instance(void 0, env, ty), ty, /* [] */0, sargs);
  } else {
    return type_args(/* [] */0, /* [] */0, ty, instance(void 0, env, ty), ty, sargs, /* [] */0);
  }
}

function type_statement(env, sexp) {
  var loc = final_subexpression(sexp).pexp_loc;
  begin_def(void 0);
  var exp = type_exp(env, sexp);
  end_def(void 0);
  if (strict_sequence.contents) {
    var expected_ty = instance_def(type_unit);
    unify_exp(env, exp, expected_ty);
    return exp;
  } else {
    var ty = expand_head(env, exp.exp_type);
    var tv = newvar(void 0, void 0);
    var match = ty.desc;
    if (typeof match === "number") {
      prerr_warning(loc, /* Statement_type */4);
    } else {
      switch (match.tag | 0) {
        case /* Tvar */0 :
            if (ty.level > tv.level) {
              prerr_warning(loc, /* Nonreturning_statement */10);
            } else {
              add_delayed_check((function (param) {
                      return check_application_result(env, true, exp);
                    }));
            }
            break;
        case /* Tarrow */1 :
            prerr_warning(loc, /* Partial_application */2);
            break;
        case /* Tconstr */3 :
            if (same(match[0], path_unit)) {
              
            } else {
              prerr_warning(loc, /* Statement_type */4);
            }
            break;
        default:
          prerr_warning(loc, /* Statement_type */4);
      }
    }
    unify_var(env, tv, ty);
    return exp;
  }
}

function type_cases(in_function, env, ty_arg, ty_res, partial_flag, loc, caselist) {
  var patterns = List.map((function (param) {
          return param.pc_lhs;
        }), caselist);
  var erase_either = List.exists(contains_polymorphic_variant, patterns) && contains_variant_either(ty_arg);
  var has_gadts = List.exists((function (param) {
          return contains_gadt(env, param);
        }), patterns);
  var ty_arg$1 = (has_gadts || erase_either) && !principal.contents ? type_expr(identity, ty_arg) : ty_arg;
  var match = has_gadts && !principal.contents ? /* tuple */[
      type_expr(identity, ty_res),
      duplicate_ident_types(loc, caselist, env)
    ] : /* tuple */[
      ty_res,
      env
    ];
  var env$1 = match[1];
  var ty_res$1 = match[0];
  var match$1;
  if (has_gadts) {
    begin_def(void 0);
    set_current_time(current_level.contents);
    var lev = currentstamp.contents;
    init_def(lev + 1000 | 0);
    match$1 = /* tuple */[
      lev,
      add_gadt_instance_level(lev, env$1)
    ];
  } else {
    match$1 = /* tuple */[
      current_level.contents,
      env$1
    ];
  }
  var env$2 = match$1[1];
  var lev$1 = match$1[0];
  begin_def(void 0);
  var ty_arg$prime = newvar(void 0, void 0);
  var pattern_force = {
    contents: /* [] */0
  };
  var pat_env_list = List.map((function (param) {
          var pc_rhs = param.pc_rhs;
          var pc_guard = param.pc_guard;
          var loc;
          if (pc_guard !== void 0) {
            var init = pc_rhs.pexp_loc;
            loc = {
              loc_start: pc_guard.pexp_loc.loc_start,
              loc_end: init.loc_end,
              loc_ghost: init.loc_ghost
            };
          } else {
            loc = pc_rhs.pexp_loc;
          }
          if (principal.contents) {
            begin_def(void 0);
          }
          var scope = /* Idef */Block.__(1, [loc]);
          var partial = principal.contents || erase_either ? false : void 0;
          var ty_arg$2 = instance(partial, env$2, ty_arg$1);
          var match = type_pattern(lev$1, env$2, param.pc_lhs, scope, ty_arg$2);
          var pat = match[0];
          pattern_force.contents = Pervasives.$at(match[2], pattern_force.contents);
          var pat$1 = principal.contents ? (end_def(void 0), iter_pattern((function (param) {
                      return generalize_structure$1(current_level.contents, param.pat_type);
                    }), pat), {
                pat_desc: pat.pat_desc,
                pat_loc: pat.pat_loc,
                pat_extra: pat.pat_extra,
                pat_type: instance(void 0, env$2, pat.pat_type),
                pat_env: pat.pat_env,
                pat_attributes: pat.pat_attributes
              }) : pat;
          return /* tuple */[
                  pat$1,
                  /* tuple */[
                    match[1],
                    match[3]
                  ]
                ];
        }), caselist);
  var patl = List.map((function (prim) {
          return prim[0];
        }), pat_env_list);
  List.iter((function (pat) {
          return unify_pat(env$2, pat, ty_arg$prime);
        }), patl);
  if (List.exists(has_variants, patl)) {
    pressure_variants$1(env$2, patl);
    List.iter((function (param) {
            return iter_pattern(finalize_variant, param);
          }), patl);
  }
  List.iter((function (f) {
          return Curry._1(f, void 0);
        }), pattern_force.contents);
  List.iter((function (param) {
          return iter_pattern((function (param) {
                        return unify_var(env$2, param.pat_type, newvar(void 0, void 0));
                      }), param);
        }), patl);
  List.iter((function (pat) {
          return unify_pat(env$2, pat, instance(void 0, env$2, ty_arg$1));
        }), patl);
  end_def(void 0);
  List.iter((function (param) {
          return iter_pattern((function (param) {
                        return iter_generalize$1({
                                    contents: /* [] */0
                                  }, param.pat_type);
                      }), param);
        }), patl);
  var in_function$1 = List.length(caselist) === 1 ? in_function : void 0;
  var cases = List.map2((function (param, param$1) {
          var pc_guard = param$1.pc_guard;
          var match = param[1];
          var unpacks = match[1];
          var ext_env = match[0];
          var sexp = wrap_unpacks(param$1.pc_rhs, unpacks);
          var ty_res$prime;
          if (principal.contents) {
            begin_def(void 0);
            var ty = instance(true, env$2, ty_res$1);
            end_def(void 0);
            generalize_structure$1(current_level.contents, ty);
            ty_res$prime = ty;
          } else {
            ty_res$prime = contains_gadt(env$2, param$1.pc_lhs) ? type_expr(identity, ty_res$1) : ty_res$1;
          }
          var guard = pc_guard !== void 0 ? type_expect(void 0, ext_env, wrap_unpacks(pc_guard, unpacks), type_bool) : void 0;
          var exp = type_expect(in_function$1, ext_env, sexp, ty_res$prime);
          return {
                  c_lhs: param[0],
                  c_guard: guard,
                  c_rhs: {
                    exp_desc: exp.exp_desc,
                    exp_loc: exp.exp_loc,
                    exp_extra: exp.exp_extra,
                    exp_type: instance(void 0, env$2, ty_res$prime),
                    exp_env: exp.exp_env,
                    exp_attributes: exp.exp_attributes
                  }
                };
        }), pat_env_list, caselist);
  if (principal.contents || has_gadts) {
    var ty_res$prime = instance(void 0, env$2, ty_res$1);
    List.iter((function (c) {
            return unify_exp(env$2, c.c_rhs, ty_res$prime);
          }), cases);
  }
  var partial = partial_flag ? check_partial$1(lev$1, env$2, ty_arg$1)(loc, cases) : /* Partial */0;
  add_delayed_check((function (param) {
          List.iter((function (param) {
                  return check_absent_variant(param[1][0])(param[0]);
                }), pat_env_list);
          if (!is_active(/* Unused_match */5)) {
            return ;
          }
          var _pref = /* [] */0;
          var _param = cases;
          while(true) {
            var param$1 = _param;
            var pref = _pref;
            if (!param$1) {
              return ;
            }
            var rem = param$1[1];
            var match = param$1[0];
            var q = match.c_lhs;
            var qs = /* :: */[
              q,
              /* [] */0
            ];
            try {
              var pss = get_mins(le_pats, List.filter((function(qs){
                        return function (param) {
                          return compats(qs, param);
                        }
                        }(qs)))(pref));
              var r = every_satisfiables(List.map(make_row, pss), {
                    no_ors: /* [] */0,
                    ors: /* [] */0,
                    active: qs
                  });
              if (typeof r === "number") {
                if (r !== 0) {
                  prerr_warning(q.pat_loc, /* Unused_match */5);
                }
                
              } else {
                List.iter((function (p) {
                        return prerr_warning(p.pat_loc, /* Unused_pat */6);
                      }), r[0]);
              }
            }
            catch (exn){
              var exit = 0;
              if (exn === Empty || exn === Caml_builtin_exceptions.not_found) {
                exit = 1;
              } else {
                if (exn !== NoGuard) {
                  throw exn;
                }
                exit = 1;
              }
              if (exit === 1) {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      /* tuple */[
                        "parmatch.ml",
                        1947,
                        48
                      ]
                    ];
              }
              
            }
            if (match.c_guard !== void 0) {
              _param = rem;
              continue ;
            } else {
              _param = rem;
              _pref = /* :: */[
                /* :: */[
                  q,
                  /* [] */0
                ],
                pref
              ];
              continue ;
            }
          };
        }));
  if (has_gadts) {
    end_def(void 0);
    unify_exp_types(loc, env$2, instance(void 0, env$2, ty_res$1), newvar(void 0, void 0));
  }
  return /* tuple */[
          cases,
          partial
        ];
}

function type_let(checkOpt, check_strictOpt, env, rec_flag, spat_sexp_list, scope, allow) {
  var check = checkOpt !== void 0 ? checkOpt : (function (s) {
        return /* Unused_var */Block.__(12, [s]);
      });
  var check_strict = check_strictOpt !== void 0 ? check_strictOpt : (function (s) {
        return /* Unused_var_strict */Block.__(13, [s]);
      });
  begin_def(void 0);
  if (principal.contents) {
    begin_def(void 0);
  }
  var is_fake_let;
  if (spat_sexp_list) {
    var match = spat_sexp_list[0].pvb_expr.pexp_desc;
    if (match.tag === /* Pexp_match */6) {
      var match$1 = match[0].pexp_desc;
      if (match$1.tag) {
        is_fake_let = false;
      } else {
        var match$2 = match$1[0].txt;
        switch (match$2.tag | 0) {
          case /* Lident */0 :
              is_fake_let = match$2[0] === "*opt*" && !spat_sexp_list[1] ? true : false;
              break;
          case /* Ldot */1 :
          case /* Lapply */2 :
              is_fake_let = false;
              break;
          
        }
      }
    } else {
      is_fake_let = false;
    }
  } else {
    is_fake_let = false;
  }
  var check$1 = is_fake_let ? check_strict : check;
  var spatl = List.map((function (param) {
          var spat = param.pvb_pat;
          var match = spat.ppat_desc;
          var match$1 = param.pvb_expr.pexp_desc;
          var sty;
          if (typeof match === "number") {
            return spat;
          }
          if (match.tag === /* Ppat_constraint */10) {
            return spat;
          }
          switch (match$1.tag | 0) {
            case /* Pexp_constraint */19 :
                sty = match$1[1];
                break;
            case /* Pexp_coerce */20 :
                sty = match$1[2];
                break;
            default:
              return spat;
          }
          if (!principal.contents) {
            return spat;
          }
          var init = spat.ppat_loc;
          return constraint_({
                      loc_start: init.loc_start,
                      loc_end: init.loc_end,
                      loc_ghost: true
                    }, void 0, spat, sty);
        }), spat_sexp_list);
  var nvs = List.map((function (param) {
          return newvar(void 0, void 0);
        }), spatl);
  var match$3 = type_pattern_list(env, spatl, scope, nvs, allow);
  var unpacks = match$3[3];
  var new_env = match$3[1];
  var pat_list = match$3[0];
  var is_recursive = rec_flag === /* Recursive */1;
  if (is_recursive) {
    List.iter2((function (pat, binding) {
            var match = pat.pat_type.desc;
            var pat$1;
            pat$1 = typeof match === "number" || match.tag !== /* Tpoly */10 ? pat : ({
                  pat_desc: pat.pat_desc,
                  pat_loc: pat.pat_loc,
                  pat_extra: pat.pat_extra,
                  pat_type: instance_poly(true, false, match[1], match[0])[1],
                  pat_env: pat.pat_env,
                  pat_attributes: pat.pat_attributes
                });
            return unify_pat(env, pat$1, type_approx(env, binding.pvb_expr));
          }), pat_list, spat_sexp_list);
  }
  List.iter((function (pat) {
          if (has_variants(pat)) {
            pressure_variants$1(env, /* :: */[
                  pat,
                  /* [] */0
                ]);
            return iter_pattern(finalize_variant, pat);
          }
          
        }), pat_list);
  var pat_list$1 = principal.contents ? (end_def(void 0), List.map((function (pat) {
              iter_pattern((function (pat) {
                      return generalize_structure$1(current_level.contents, pat.pat_type);
                    }), pat);
              return {
                      pat_desc: pat.pat_desc,
                      pat_loc: pat.pat_loc,
                      pat_extra: pat.pat_extra,
                      pat_type: instance(void 0, env, pat.pat_type),
                      pat_env: pat.pat_env,
                      pat_attributes: pat.pat_attributes
                    };
            }), pat_list)) : pat_list;
  List.iter((function (f) {
          return Curry._1(f, void 0);
        }), match$3[2]);
  var exp_env = is_recursive ? new_env : env;
  var current_slot = {
    contents: void 0
  };
  var rec_needed = {
    contents: false
  };
  var warn_unused = is_active(Curry._1(check$1, "")) || is_active(Curry._1(check_strict, "")) || is_recursive && is_active(/* Unused_rec_flag */15);
  var pat_slot_list = List.map((function (pat) {
          if (!warn_unused) {
            return /* tuple */[
                    pat,
                    void 0
                  ];
          }
          var some_used = {
            contents: false
          };
          var slot = {
            contents: /* [] */0
          };
          List.iter((function (param) {
                  var id = param[0];
                  var vd = find_value(/* Pident */Block.__(0, [id]), new_env);
                  var name = id.name;
                  var used = {
                    contents: false
                  };
                  if (!(name === "" || Caml_string.get(name, 0) === /* "_" */95 || Caml_string.get(name, 0) === /* "#" */35)) {
                    add_delayed_check((function (param) {
                            if (!used.contents) {
                              return prerr_warning(vd.val_loc, Curry._1(some_used.contents ? check_strict : check$1, name));
                            }
                            
                          }));
                  }
                  var callback = function (param) {
                    var match = current_slot.contents;
                    if (match !== void 0) {
                      var slot$1 = match;
                      slot$1.contents = /* :: */[
                        /* tuple */[
                          name,
                          vd
                        ],
                        slot$1.contents
                      ];
                      rec_needed.contents = true;
                      return ;
                    } else {
                      List.iter((function (param) {
                              return mark_value_used(env, param[0], param[1]);
                            }), get_ref(slot));
                      used.contents = true;
                      some_used.contents = true;
                      return ;
                    }
                  };
                  var key_001 = vd.val_loc;
                  var key = /* tuple */[
                    name,
                    key_001
                  ];
                  try {
                    var old = Hashtbl.find(value_declarations, key);
                    return Hashtbl.replace(value_declarations, key, (function (param) {
                                  Curry._1(old, void 0);
                                  return Curry._1(callback, void 0);
                                }));
                  }
                  catch (exn){
                    if (exn === Caml_builtin_exceptions.not_found) {
                      return Hashtbl.add(value_declarations, key, callback);
                    }
                    throw exn;
                  }
                }), pat_bound_idents(pat));
          return /* tuple */[
                  pat,
                  slot
                ];
        }), pat_list$1);
  var exp_list = List.map2((function (param, param$1) {
          var pat = param$1[0];
          var sexp = param.pvb_expr;
          var sexp$1 = rec_flag === /* Recursive */1 ? wrap_unpacks(sexp, unpacks) : sexp;
          if (is_recursive) {
            current_slot.contents = param$1[1];
          }
          var match = pat.pat_type.desc;
          if (typeof match === "number") {
            return type_expect(void 0, exp_env, sexp$1, pat.pat_type);
          }
          if (match.tag !== /* Tpoly */10) {
            return type_expect(void 0, exp_env, sexp$1, pat.pat_type);
          }
          begin_def(void 0);
          if (principal.contents) {
            begin_def(void 0);
          }
          var match$1 = instance_poly(true, true, match[1], match[0]);
          var ty$prime = match$1[1];
          if (principal.contents) {
            end_def(void 0);
            generalize_structure$1(current_level.contents, ty$prime);
          }
          var exp = type_expect(void 0, exp_env, sexp$1, ty$prime);
          end_def(void 0);
          check_univars(env, true, "definition", exp, pat.pat_type, match$1[0]);
          return {
                  exp_desc: exp.exp_desc,
                  exp_loc: exp.exp_loc,
                  exp_extra: exp.exp_extra,
                  exp_type: instance(void 0, env, exp.exp_type),
                  exp_env: exp.exp_env,
                  exp_attributes: exp.exp_attributes
                };
        }), spat_sexp_list, pat_slot_list);
  current_slot.contents = void 0;
  if (is_recursive && !rec_needed.contents && is_active(/* Unused_rec_flag */15)) {
    prerr_warning(List.hd(spat_sexp_list).pvb_pat.ppat_loc, /* Unused_rec_flag */15);
  }
  List.iter2((function (pat, exp) {
          check_partial$1(void 0, env, pat.pat_type)(pat.pat_loc, /* :: */[
                {
                  c_lhs: pat,
                  c_guard: void 0,
                  c_rhs: exp
                },
                /* [] */0
              ]);
          
        }), pat_list$1, exp_list);
  end_def(void 0);
  List.iter2((function (pat, exp) {
          if (!is_nonexpansive(exp)) {
            return iter_pattern((function (pat) {
                          return generalize_expansive$1(env, pat.pat_type);
                        }), pat);
          }
          
        }), pat_list$1, exp_list);
  List.iter((function (pat) {
          return iter_pattern((function (pat) {
                        return iter_generalize$1({
                                    contents: /* [] */0
                                  }, pat.pat_type);
                      }), pat);
        }), pat_list$1);
  var l = List.combine(pat_list$1, exp_list);
  var l$1 = List.map2((function (param, pvb) {
          return {
                  vb_pat: param[0],
                  vb_expr: param[1],
                  vb_attributes: pvb.pvb_attributes,
                  vb_loc: pvb.pvb_loc
                };
        }), l, spat_sexp_list);
  return /* tuple */[
          l$1,
          new_env,
          unpacks
        ];
}

function type_binding(env, rec_flag, spat_sexp_list, scope) {
  reset_type_variables(void 0);
  var match = type_let((function (s) {
          return /* Unused_value_declaration */Block.__(16, [s]);
        }), (function (s) {
          return /* Unused_value_declaration */Block.__(16, [s]);
        }), env, rec_flag, spat_sexp_list, scope, false);
  return /* tuple */[
          match[0],
          match[1]
        ];
}

function type_let$1(env, rec_flag, spat_sexp_list, scope) {
  var match = type_let(void 0, void 0, env, rec_flag, spat_sexp_list, scope, false);
  return /* tuple */[
          match[0],
          match[1]
        ];
}

function type_expression(env, sexp) {
  reset_type_variables(void 0);
  begin_def(void 0);
  var exp = type_exp(env, sexp);
  end_def(void 0);
  if (is_nonexpansive(exp)) {
    iter_generalize$1({
          contents: /* [] */0
        }, exp.exp_type);
  } else {
    generalize_expansive$1(env, exp.exp_type);
  }
  var match = sexp.pexp_desc;
  if (match.tag) {
    return exp;
  }
  var match$1 = lookup_value$1(match[0].txt, env);
  return {
          exp_desc: exp.exp_desc,
          exp_loc: exp.exp_loc,
          exp_extra: exp.exp_extra,
          exp_type: match$1[1].val_type,
          exp_env: exp.exp_env,
          exp_attributes: exp.exp_attributes
        };
}

register_error_of_exn((function (param) {
        if (param[0] !== $$Error$7) {
          if (param[0] === Error_forward$1) {
            return param[1];
          } else {
            return ;
          }
        }
        var env = param[2];
        return error_of_printer(param[1], (function (param, param$1) {
                      return wrap_printing_env(env, (function (param$2) {
                                    if (typeof param$1 === "number") {
                                      switch (param$1) {
                                        case /* Outside_class */0 :
                                            return Format.fprintf(param, /* Format */[
                                                        /* String_literal */Block.__(11, [
                                                            "This object duplication occurs outside a method definition",
                                                            /* End_of_format */0
                                                          ]),
                                                        "This object duplication occurs outside a method definition"
                                                      ]);
                                        case /* Incoherent_label_order */1 :
                                            Format.fprintf(param, /* Format */[
                                                  /* String_literal */Block.__(11, [
                                                      "This function is applied to arguments",
                                                      /* Formatting_lit */Block.__(17, [
                                                          /* Break */Block.__(0, [
                                                              "@ ",
                                                              1,
                                                              0
                                                            ]),
                                                          /* End_of_format */0
                                                        ])
                                                    ]),
                                                  "This function is applied to arguments@ "
                                                ]);
                                            Format.fprintf(param, /* Format */[
                                                  /* String_literal */Block.__(11, [
                                                      "in an order different from other calls.",
                                                      /* Formatting_lit */Block.__(17, [
                                                          /* Break */Block.__(0, [
                                                              "@ ",
                                                              1,
                                                              0
                                                            ]),
                                                          /* End_of_format */0
                                                        ])
                                                    ]),
                                                  "in an order different from other calls.@ "
                                                ]);
                                            return Format.fprintf(param, /* Format */[
                                                        /* String_literal */Block.__(11, [
                                                            "This is only allowed when the real type is known.",
                                                            /* End_of_format */0
                                                          ]),
                                                        "This is only allowed when the real type is known."
                                                      ]);
                                        case /* Modules_not_allowed */2 :
                                            return Format.fprintf(param, /* Format */[
                                                        /* String_literal */Block.__(11, [
                                                            "Modules are not allowed in this pattern.",
                                                            /* End_of_format */0
                                                          ]),
                                                        "Modules are not allowed in this pattern."
                                                      ]);
                                        case /* Cannot_infer_signature */3 :
                                            return Format.fprintf(param, /* Format */[
                                                        /* String_literal */Block.__(11, [
                                                            "The signature for this packaged module couldn't be inferred.",
                                                            /* End_of_format */0
                                                          ]),
                                                        "The signature for this packaged module couldn't be inferred."
                                                      ]);
                                        case /* Unexpected_existential */4 :
                                            return Format.fprintf(param, /* Format */[
                                                        /* String_literal */Block.__(11, [
                                                            "Unexpected existential",
                                                            /* End_of_format */0
                                                          ]),
                                                        "Unexpected existential"
                                                      ]);
                                        case /* Invalid_interval */5 :
                                            return Format.fprintf(param, /* Format */[
                                                        /* Formatting_gen */Block.__(18, [
                                                            /* Open_box */Block.__(1, [/* Format */[
                                                                  /* End_of_format */0,
                                                                  ""
                                                                ]]),
                                                            /* String_literal */Block.__(11, [
                                                                "Only character intervals are supported in patterns.",
                                                                /* Formatting_lit */Block.__(17, [
                                                                    /* Close_box */0,
                                                                    /* End_of_format */0
                                                                  ])
                                                              ])
                                                          ]),
                                                        "@[Only character intervals are supported in patterns.@]"
                                                      ]);
                                        case /* Invalid_for_loop_index */6 :
                                            return Format.fprintf(param, /* Format */[
                                                        /* Formatting_gen */Block.__(18, [
                                                            /* Open_box */Block.__(1, [/* Format */[
                                                                  /* End_of_format */0,
                                                                  ""
                                                                ]]),
                                                            /* String_literal */Block.__(11, [
                                                                "Invalid for-loop index: only variables and _ are allowed.",
                                                                /* Formatting_lit */Block.__(17, [
                                                                    /* Close_box */0,
                                                                    /* End_of_format */0
                                                                  ])
                                                              ])
                                                          ]),
                                                        "@[Invalid for-loop index: only variables and _ are allowed.@]"
                                                      ]);
                                        case /* No_value_clauses */7 :
                                            return Format.fprintf(param, /* Format */[
                                                        /* String_literal */Block.__(11, [
                                                            "None of the patterns in this 'match' expression match values.",
                                                            /* End_of_format */0
                                                          ]),
                                                        "None of the patterns in this 'match' expression match values."
                                                      ]);
                                        case /* Exception_pattern_below_toplevel */8 :
                                            return Format.fprintf(param, /* Format */[
                                                        /* Formatting_gen */Block.__(18, [
                                                            /* Open_box */Block.__(1, [/* Format */[
                                                                  /* End_of_format */0,
                                                                  ""
                                                                ]]),
                                                            /* String_literal */Block.__(11, [
                                                                "Exception patterns must be at the top level of a match case.",
                                                                /* Formatting_lit */Block.__(17, [
                                                                    /* Close_box */0,
                                                                    /* End_of_format */0
                                                                  ])
                                                              ])
                                                          ]),
                                                        "@[Exception patterns must be at the top level of a match case.@]"
                                                      ]);
                                        
                                      }
                                    } else {
                                      switch (param$1.tag | 0) {
                                        case /* Polymorphic_label */0 :
                                            return Curry._3(Format.fprintf(param, /* Format */[
                                                            /* Formatting_gen */Block.__(18, [
                                                                /* Open_box */Block.__(1, [/* Format */[
                                                                      /* End_of_format */0,
                                                                      ""
                                                                    ]]),
                                                                /* String_literal */Block.__(11, [
                                                                    "The record field ",
                                                                    /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                                                            " is polymorphic.",
                                                                            /* Formatting_lit */Block.__(17, [
                                                                                /* Break */Block.__(0, [
                                                                                    "@ ",
                                                                                    1,
                                                                                    0
                                                                                  ]),
                                                                                /* String */Block.__(2, [
                                                                                    /* No_padding */0,
                                                                                    /* Formatting_lit */Block.__(17, [
                                                                                        /* Close_box */0,
                                                                                        /* End_of_format */0
                                                                                      ])
                                                                                  ])
                                                                              ])
                                                                          ])])
                                                                  ])
                                                              ]),
                                                            "@[The record field %a is polymorphic.@ %s@]"
                                                          ]), longident, param$1[0], "You cannot instantiate it in a pattern.");
                                        case /* Constructor_arity_mismatch */1 :
                                            return Curry._4(Format.fprintf(param, /* Format */[
                                                            /* Formatting_gen */Block.__(18, [
                                                                /* Open_box */Block.__(1, [/* Format */[
                                                                      /* End_of_format */0,
                                                                      ""
                                                                    ]]),
                                                                /* String_literal */Block.__(11, [
                                                                    "The constructor ",
                                                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                            /* Break */Block.__(0, [
                                                                                "@ ",
                                                                                1,
                                                                                0
                                                                              ]),
                                                                            /* String_literal */Block.__(11, [
                                                                                "expects ",
                                                                                /* Int */Block.__(4, [
                                                                                    /* Int_i */3,
                                                                                    /* No_padding */0,
                                                                                    /* No_precision */0,
                                                                                    /* String_literal */Block.__(11, [
                                                                                        " argument(s),",
                                                                                        /* Formatting_lit */Block.__(17, [
                                                                                            /* Break */Block.__(0, [
                                                                                                "@ ",
                                                                                                1,
                                                                                                0
                                                                                              ]),
                                                                                            /* String_literal */Block.__(11, [
                                                                                                "but is applied here to ",
                                                                                                /* Int */Block.__(4, [
                                                                                                    /* Int_i */3,
                                                                                                    /* No_padding */0,
                                                                                                    /* No_precision */0,
                                                                                                    /* String_literal */Block.__(11, [
                                                                                                        " argument(s)",
                                                                                                        /* Formatting_lit */Block.__(17, [
                                                                                                            /* Close_box */0,
                                                                                                            /* End_of_format */0
                                                                                                          ])
                                                                                                      ])
                                                                                                  ])
                                                                                              ])
                                                                                          ])
                                                                                      ])
                                                                                  ])
                                                                              ])
                                                                          ])])
                                                                  ])
                                                              ]),
                                                            "@[The constructor %a@ expects %i argument(s),@ but is applied here to %i argument(s)@]"
                                                          ]), longident, param$1[0], param$1[1], param$1[2]);
                                        case /* Label_mismatch */2 :
                                            var lid = param$1[0];
                                            return report_unification_error(param, env, void 0, param$1[1], (function (ppf) {
                                                          return Curry._2(Format.fprintf(ppf, /* Format */[
                                                                          /* String_literal */Block.__(11, [
                                                                              "The record field ",
                                                                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                      /* Break */Block.__(0, [
                                                                                          "@ ",
                                                                                          1,
                                                                                          0
                                                                                        ]),
                                                                                      /* String_literal */Block.__(11, [
                                                                                          "belongs to the type",
                                                                                          /* End_of_format */0
                                                                                        ])
                                                                                    ])])
                                                                            ]),
                                                                          "The record field %a@ belongs to the type"
                                                                        ]), longident, lid);
                                                        }), (function (ppf) {
                                                          return Format.fprintf(ppf, /* Format */[
                                                                      /* String_literal */Block.__(11, [
                                                                          "but is mixed here with fields of type",
                                                                          /* End_of_format */0
                                                                        ]),
                                                                      "but is mixed here with fields of type"
                                                                    ]);
                                                        }));
                                        case /* Pattern_type_clash */3 :
                                            return report_unification_error(param, env, void 0, param$1[0], (function (ppf) {
                                                          return Format.fprintf(ppf, /* Format */[
                                                                      /* String_literal */Block.__(11, [
                                                                          "This pattern matches values of type",
                                                                          /* End_of_format */0
                                                                        ]),
                                                                      "This pattern matches values of type"
                                                                    ]);
                                                        }), (function (ppf) {
                                                          return Format.fprintf(ppf, /* Format */[
                                                                      /* String_literal */Block.__(11, [
                                                                          "but a pattern was expected which matches values of type",
                                                                          /* End_of_format */0
                                                                        ]),
                                                                      "but a pattern was expected which matches values of type"
                                                                    ]);
                                                        }));
                                        case /* Or_pattern_type_clash */4 :
                                            var id = param$1[0];
                                            return report_unification_error(param, env, void 0, param$1[1], (function (ppf) {
                                                          return Curry._1(Format.fprintf(ppf, /* Format */[
                                                                          /* String_literal */Block.__(11, [
                                                                              "The variable ",
                                                                              /* String */Block.__(2, [
                                                                                  /* No_padding */0,
                                                                                  /* String_literal */Block.__(11, [
                                                                                      " on the left-hand side of this or-pattern has type",
                                                                                      /* End_of_format */0
                                                                                    ])
                                                                                ])
                                                                            ]),
                                                                          "The variable %s on the left-hand side of this or-pattern has type"
                                                                        ]), id.name);
                                                        }), (function (ppf) {
                                                          return Format.fprintf(ppf, /* Format */[
                                                                      /* String_literal */Block.__(11, [
                                                                          "but on the right-hand side it has type",
                                                                          /* End_of_format */0
                                                                        ]),
                                                                      "but on the right-hand side it has type"
                                                                    ]);
                                                        }));
                                        case /* Multiply_bound_variable */5 :
                                            return Curry._1(Format.fprintf(param, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "Variable ",
                                                                /* String */Block.__(2, [
                                                                    /* No_padding */0,
                                                                    /* String_literal */Block.__(11, [
                                                                        " is bound several times in this matching",
                                                                        /* End_of_format */0
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "Variable %s is bound several times in this matching"
                                                          ]), param$1[0]);
                                        case /* Orpat_vars */6 :
                                            return Curry._1(Format.fprintf(param, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "Variable ",
                                                                /* String */Block.__(2, [
                                                                    /* No_padding */0,
                                                                    /* String_literal */Block.__(11, [
                                                                        " must occur on both sides of this | pattern",
                                                                        /* End_of_format */0
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "Variable %s must occur on both sides of this | pattern"
                                                          ]), param$1[0].name);
                                        case /* Expr_type_clash */7 :
                                            return report_unification_error(param, env, void 0, param$1[0], (function (ppf) {
                                                          return Format.fprintf(ppf, /* Format */[
                                                                      /* String_literal */Block.__(11, [
                                                                          "This expression has type",
                                                                          /* End_of_format */0
                                                                        ]),
                                                                      "This expression has type"
                                                                    ]);
                                                        }), (function (ppf) {
                                                          return Format.fprintf(ppf, /* Format */[
                                                                      /* String_literal */Block.__(11, [
                                                                          "but an expression was expected of type",
                                                                          /* End_of_format */0
                                                                        ]),
                                                                      "but an expression was expected of type"
                                                                    ]);
                                                        }));
                                        case /* Apply_non_function */8 :
                                            var typ = param$1[0];
                                            reset(void 0);
                                            mark_loops(typ);
                                            var match = repr(typ).desc;
                                            if (typeof match !== "number" && match.tag === /* Tarrow */1) {
                                              Curry._2(Format.fprintf(param, /* Format */[
                                                        /* Formatting_gen */Block.__(18, [
                                                            /* Open_box */Block.__(1, [/* Format */[
                                                                  /* String_literal */Block.__(11, [
                                                                      "<v>",
                                                                      /* End_of_format */0
                                                                    ]),
                                                                  "<v>"
                                                                ]]),
                                                            /* Formatting_gen */Block.__(18, [
                                                                /* Open_box */Block.__(1, [/* Format */[
                                                                      /* String_literal */Block.__(11, [
                                                                          "<2>",
                                                                          /* End_of_format */0
                                                                        ]),
                                                                      "<2>"
                                                                    ]]),
                                                                /* String_literal */Block.__(11, [
                                                                    "This function has type",
                                                                    /* Formatting_lit */Block.__(17, [
                                                                        /* Break */Block.__(0, [
                                                                            "@ ",
                                                                            1,
                                                                            0
                                                                          ]),
                                                                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                /* Close_box */0,
                                                                                /* End_of_format */0
                                                                              ])])
                                                                      ])
                                                                  ])
                                                              ])
                                                          ]),
                                                        "@[<v>@[<2>This function has type@ %a@]"
                                                      ]), type_expr$1, typ);
                                              return Curry._1(Format.fprintf(param, /* Format */[
                                                              /* Formatting_lit */Block.__(17, [
                                                                  /* Break */Block.__(0, [
                                                                      "@ ",
                                                                      1,
                                                                      0
                                                                    ]),
                                                                  /* Formatting_gen */Block.__(18, [
                                                                      /* Open_box */Block.__(1, [/* Format */[
                                                                            /* End_of_format */0,
                                                                            ""
                                                                          ]]),
                                                                      /* String_literal */Block.__(11, [
                                                                          "It is applied to too many arguments;",
                                                                          /* Formatting_lit */Block.__(17, [
                                                                              /* Break */Block.__(0, [
                                                                                  "@ ",
                                                                                  1,
                                                                                  0
                                                                                ]),
                                                                              /* String */Block.__(2, [
                                                                                  /* No_padding */0,
                                                                                  /* Formatting_lit */Block.__(17, [
                                                                                      /* Close_box */0,
                                                                                      /* Formatting_lit */Block.__(17, [
                                                                                          /* Close_box */0,
                                                                                          /* End_of_format */0
                                                                                        ])
                                                                                    ])
                                                                                ])
                                                                            ])
                                                                        ])
                                                                    ])
                                                                ]),
                                                              "@ @[It is applied to too many arguments;@ %s@]@]"
                                                            ]), "maybe you forgot a `;'.");
                                            }
                                            return Curry._3(Format.fprintf(param, /* Format */[
                                                            /* Formatting_gen */Block.__(18, [
                                                                /* Open_box */Block.__(1, [/* Format */[
                                                                      /* String_literal */Block.__(11, [
                                                                          "<v>",
                                                                          /* End_of_format */0
                                                                        ]),
                                                                      "<v>"
                                                                    ]]),
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* String_literal */Block.__(11, [
                                                                              "<2>",
                                                                              /* End_of_format */0
                                                                            ]),
                                                                          "<2>"
                                                                        ]]),
                                                                    /* String_literal */Block.__(11, [
                                                                        "This expression has type",
                                                                        /* Formatting_lit */Block.__(17, [
                                                                            /* Break */Block.__(0, [
                                                                                "@ ",
                                                                                1,
                                                                                0
                                                                              ]),
                                                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                    /* Close_box */0,
                                                                                    /* Formatting_lit */Block.__(17, [
                                                                                        /* Break */Block.__(0, [
                                                                                            "@ ",
                                                                                            1,
                                                                                            0
                                                                                          ]),
                                                                                        /* String */Block.__(2, [
                                                                                            /* No_padding */0,
                                                                                            /* Formatting_lit */Block.__(17, [
                                                                                                /* Close_box */0,
                                                                                                /* End_of_format */0
                                                                                              ])
                                                                                          ])
                                                                                      ])
                                                                                  ])])
                                                                          ])
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "@[<v>@[<2>This expression has type@ %a@]@ %s@]"
                                                          ]), type_expr$1, typ, "This is not a function; it cannot be applied.");
                                        case /* Apply_wrong_label */9 :
                                            var ty = param$1[1];
                                            var print_label = function (ppf, l) {
                                              if (l === "") {
                                                return Format.fprintf(ppf, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "without label",
                                                                /* End_of_format */0
                                                              ]),
                                                            "without label"
                                                          ]);
                                              } else {
                                                return Curry._1(Format.fprintf(ppf, /* Format */[
                                                                /* String_literal */Block.__(11, [
                                                                    "with label ",
                                                                    /* String */Block.__(2, [
                                                                        /* No_padding */0,
                                                                        /* End_of_format */0
                                                                      ])
                                                                  ]),
                                                                "with label %s"
                                                              ]), prefixed_label_name(l));
                                              }
                                            };
                                            reset(void 0);
                                            mark_loops(ty);
                                            return Curry._4(Format.fprintf(param, /* Format */[
                                                            /* Formatting_gen */Block.__(18, [
                                                                /* Open_box */Block.__(1, [/* Format */[
                                                                      /* String_literal */Block.__(11, [
                                                                          "<v>",
                                                                          /* End_of_format */0
                                                                        ]),
                                                                      "<v>"
                                                                    ]]),
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* String_literal */Block.__(11, [
                                                                              "<2>",
                                                                              /* End_of_format */0
                                                                            ]),
                                                                          "<2>"
                                                                        ]]),
                                                                    /* String_literal */Block.__(11, [
                                                                        "The function applied to this argument has type",
                                                                        /* Formatting_lit */Block.__(17, [
                                                                            /* Break */Block.__(0, [
                                                                                "@ ",
                                                                                1,
                                                                                0
                                                                              ]),
                                                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                    /* Close_box */0,
                                                                                    /* Formatting_lit */Block.__(17, [
                                                                                        /* Flush_newline */4,
                                                                                        /* String_literal */Block.__(11, [
                                                                                            "This argument cannot be applied ",
                                                                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                                    /* Close_box */0,
                                                                                                    /* End_of_format */0
                                                                                                  ])])
                                                                                          ])
                                                                                      ])
                                                                                  ])])
                                                                          ])
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "@[<v>@[<2>The function applied to this argument has type@ %a@]@.This argument cannot be applied %a@]"
                                                          ]), type_expr$1, ty, print_label, param$1[0]);
                                        case /* Label_multiply_defined */10 :
                                            return Curry._1(Format.fprintf(param, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "The record field label ",
                                                                /* String */Block.__(2, [
                                                                    /* No_padding */0,
                                                                    /* String_literal */Block.__(11, [
                                                                        " is defined several times",
                                                                        /* End_of_format */0
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "The record field label %s is defined several times"
                                                          ]), param$1[0]);
                                        case /* Label_missing */11 :
                                            var print_labels = function (ppf) {
                                              return (function (param) {
                                                  return List.iter((function (lbl) {
                                                                return Curry._1(Format.fprintf(ppf, /* Format */[
                                                                                /* Formatting_lit */Block.__(17, [
                                                                                    /* Break */Block.__(0, [
                                                                                        "@ ",
                                                                                        1,
                                                                                        0
                                                                                      ]),
                                                                                    /* String */Block.__(2, [
                                                                                        /* No_padding */0,
                                                                                        /* End_of_format */0
                                                                                      ])
                                                                                  ]),
                                                                                "@ %s"
                                                                              ]), lbl.name);
                                                              }), param);
                                                });
                                            };
                                            return Curry._2(Format.fprintf(param, /* Format */[
                                                            /* Formatting_gen */Block.__(18, [
                                                                /* Open_box */Block.__(1, [/* Format */[
                                                                      /* String_literal */Block.__(11, [
                                                                          "<hov>",
                                                                          /* End_of_format */0
                                                                        ]),
                                                                      "<hov>"
                                                                    ]]),
                                                                /* String_literal */Block.__(11, [
                                                                    "Some record fields are undefined:",
                                                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                            /* Close_box */0,
                                                                            /* End_of_format */0
                                                                          ])])
                                                                  ])
                                                              ]),
                                                            "@[<hov>Some record fields are undefined:%a@]"
                                                          ]), print_labels, param$1[0]);
                                        case /* Label_not_mutable */12 :
                                            return Curry._2(Format.fprintf(param, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "The record field ",
                                                                /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                                                        " is not mutable",
                                                                        /* End_of_format */0
                                                                      ])])
                                                              ]),
                                                            "The record field %a is not mutable"
                                                          ]), longident, param$1[0]);
                                        case /* Wrong_name */13 :
                                            var lid$1 = param$1[4];
                                            var p = param$1[3];
                                            var kind = param$1[2];
                                            var ty$1 = param$1[1];
                                            reset(void 0);
                                            mark_loops(ty$1);
                                            Curry._3(Format.fprintf(param, /* Format */[
                                                      /* Formatting_gen */Block.__(18, [
                                                          /* Open_box */Block.__(1, [/* Format */[
                                                                /* End_of_format */0,
                                                                ""
                                                              ]]),
                                                          /* Formatting_gen */Block.__(18, [
                                                              /* Open_box */Block.__(1, [/* Format */[
                                                                    /* String_literal */Block.__(11, [
                                                                        "<2>",
                                                                        /* End_of_format */0
                                                                      ]),
                                                                    "<2>"
                                                                  ]]),
                                                              /* String */Block.__(2, [
                                                                  /* No_padding */0,
                                                                  /* String_literal */Block.__(11, [
                                                                      " type",
                                                                      /* Formatting_lit */Block.__(17, [
                                                                          /* Break */Block.__(0, [
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            ]),
                                                                          /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                  /* Close_box */0,
                                                                                  /* Formatting_lit */Block.__(17, [
                                                                                      /* Break */Block.__(0, [
                                                                                          "@ ",
                                                                                          1,
                                                                                          0
                                                                                        ]),
                                                                                      /* End_of_format */0
                                                                                    ])
                                                                                ])])
                                                                        ])
                                                                    ])
                                                                ])
                                                            ])
                                                        ]),
                                                      "@[@[<2>%s type@ %a@]@ "
                                                    ]), param$1[0], type_expr$1, ty$1);
                                            Curry._5(Format.fprintf(param, /* Format */[
                                                      /* String_literal */Block.__(11, [
                                                          "The ",
                                                          /* String */Block.__(2, [
                                                              /* No_padding */0,
                                                              /* Char_literal */Block.__(12, [
                                                                  /* " " */32,
                                                                  /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                                                          " does not belong to type ",
                                                                          /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                  /* Close_box */0,
                                                                                  /* End_of_format */0
                                                                                ])])
                                                                        ])])
                                                                ])
                                                            ])
                                                        ]),
                                                      "The %s %a does not belong to type %a@]"
                                                    ]), kind === "record" ? "field" : "constructor", longident, lid$1, path, p);
                                            if (kind === "record") {
                                              return spellcheck_simple(param, fold_labels, (function (d) {
                                                              if (compare_type_path(env, p, get_type_path$1(env, d))) {
                                                                return d.lbl_name;
                                                              } else {
                                                                return "";
                                                              }
                                                            }))(env, lid$1);
                                            } else {
                                              return spellcheck_simple(param, fold_constructors, (function (d) {
                                                              if (compare_type_path(env, p, get_type_path$2(env, d))) {
                                                                return d.cstr_name;
                                                              } else {
                                                                return "";
                                                              }
                                                            }))(env, lid$1);
                                            }
                                        case /* Name_type_mismatch */14 :
                                            var lid$2 = param$1[1];
                                            var kind$1 = param$1[0];
                                            var name = kind$1 === "record" ? "field" : "constructor";
                                            var param$3 = param$1[2];
                                            var tpl = param$1[3];
                                            var txt1 = function (ppf) {
                                              return Curry._4(Format.fprintf(ppf, /* Format */[
                                                              /* String_literal */Block.__(11, [
                                                                  "The ",
                                                                  /* String */Block.__(2, [
                                                                      /* No_padding */0,
                                                                      /* Char_literal */Block.__(12, [
                                                                          /* " " */32,
                                                                          /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                  /* Break */Block.__(0, [
                                                                                      "@ ",
                                                                                      1,
                                                                                      0
                                                                                    ]),
                                                                                  /* String_literal */Block.__(11, [
                                                                                      "belongs to the ",
                                                                                      /* String */Block.__(2, [
                                                                                          /* No_padding */0,
                                                                                          /* String_literal */Block.__(11, [
                                                                                              " type",
                                                                                              /* End_of_format */0
                                                                                            ])
                                                                                        ])
                                                                                    ])
                                                                                ])])
                                                                        ])
                                                                    ])
                                                                ]),
                                                              "The %s %a@ belongs to the %s type"
                                                            ]), name, longident, lid$2, kind$1);
                                            };
                                            var txt2 = function (ppf) {
                                              return Curry._4(Format.fprintf(ppf, /* Format */[
                                                              /* String_literal */Block.__(11, [
                                                                  "The ",
                                                                  /* String */Block.__(2, [
                                                                      /* No_padding */0,
                                                                      /* Char_literal */Block.__(12, [
                                                                          /* " " */32,
                                                                          /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                  /* Break */Block.__(0, [
                                                                                      "@ ",
                                                                                      1,
                                                                                      0
                                                                                    ]),
                                                                                  /* String_literal */Block.__(11, [
                                                                                      "belongs to one of the following ",
                                                                                      /* String */Block.__(2, [
                                                                                          /* No_padding */0,
                                                                                          /* String_literal */Block.__(11, [
                                                                                              " types:",
                                                                                              /* End_of_format */0
                                                                                            ])
                                                                                        ])
                                                                                    ])
                                                                                ])])
                                                                        ])
                                                                    ])
                                                                ]),
                                                              "The %s %a@ belongs to one of the following %s types:"
                                                            ]), name, longident, lid$2, kind$1);
                                            };
                                            var txt3 = function (ppf) {
                                              return Curry._2(Format.fprintf(ppf, /* Format */[
                                                              /* String_literal */Block.__(11, [
                                                                  "but a ",
                                                                  /* String */Block.__(2, [
                                                                      /* No_padding */0,
                                                                      /* String_literal */Block.__(11, [
                                                                          " was expected belonging to the ",
                                                                          /* String */Block.__(2, [
                                                                              /* No_padding */0,
                                                                              /* String_literal */Block.__(11, [
                                                                                  " type",
                                                                                  /* End_of_format */0
                                                                                ])
                                                                            ])
                                                                        ])
                                                                    ])
                                                                ]),
                                                              "but a %s was expected belonging to the %s type"
                                                            ]), name, kind$1);
                                            };
                                            var tp0$prime = param$3[1];
                                            var tp0 = param$3[0];
                                            return wrap_printing_env(env, (function (param$4) {
                                                          reset(void 0);
                                                          List.iter((function (param) {
                                                                  path_same_name(tp0, param[0]);
                                                                  return path_same_name(tp0$prime, param[1]);
                                                                }), tpl);
                                                          if (!tpl) {
                                                            throw [
                                                                  Caml_builtin_exceptions.assert_failure,
                                                                  /* tuple */[
                                                                    "printtyp.ml",
                                                                    1585,
                                                                    12
                                                                  ]
                                                                ];
                                                          }
                                                          if (tpl[1]) {
                                                            return Curry._6(Format.fprintf(param, /* Format */[
                                                                            /* Formatting_gen */Block.__(18, [
                                                                                /* Open_box */Block.__(1, [/* Format */[
                                                                                      /* End_of_format */0,
                                                                                      ""
                                                                                    ]]),
                                                                                /* Theta */Block.__(16, [/* Formatting_lit */Block.__(17, [
                                                                                        /* Break */Block.__(0, [
                                                                                            "@;<1 2>",
                                                                                            1,
                                                                                            2
                                                                                          ]),
                                                                                        /* Formatting_gen */Block.__(18, [
                                                                                            /* Open_box */Block.__(1, [/* Format */[
                                                                                                  /* String_literal */Block.__(11, [
                                                                                                      "<hv>",
                                                                                                      /* End_of_format */0
                                                                                                    ]),
                                                                                                  "<hv>"
                                                                                                ]]),
                                                                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                                    /* Close_box */0,
                                                                                                    /* Formatting_lit */Block.__(17, [
                                                                                                        /* Break */Block.__(0, [
                                                                                                            "@ ",
                                                                                                            1,
                                                                                                            0
                                                                                                          ]),
                                                                                                        /* Theta */Block.__(16, [/* Formatting_lit */Block.__(17, [
                                                                                                                /* Break */Block.__(0, [
                                                                                                                    "@;<1 2>",
                                                                                                                    1,
                                                                                                                    2
                                                                                                                  ]),
                                                                                                                /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                                                        /* Close_box */0,
                                                                                                                        /* End_of_format */0
                                                                                                                      ])])
                                                                                                              ])])
                                                                                                      ])
                                                                                                  ])])
                                                                                          ])
                                                                                      ])])
                                                                              ]),
                                                                            "@[%t@;<1 2>@[<hv>%a@]@ %t@;<1 2>%a@]"
                                                                          ]), txt2, type_path_list, tpl, txt3, (function (param, param$1) {
                                                                          return type_path_expansion(tp0, param, param$1);
                                                                        }), tp0$prime);
                                                          }
                                                          var match = tpl[0];
                                                          var tp = match[0];
                                                          return Curry._6(Format.fprintf(param, /* Format */[
                                                                          /* Formatting_gen */Block.__(18, [
                                                                              /* Open_box */Block.__(1, [/* Format */[
                                                                                    /* End_of_format */0,
                                                                                    ""
                                                                                  ]]),
                                                                              /* Theta */Block.__(16, [/* Formatting_lit */Block.__(17, [
                                                                                      /* Break */Block.__(0, [
                                                                                          "@;<1 2>",
                                                                                          1,
                                                                                          2
                                                                                        ]),
                                                                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                              /* Break */Block.__(0, [
                                                                                                  "@ ",
                                                                                                  1,
                                                                                                  0
                                                                                                ]),
                                                                                              /* Theta */Block.__(16, [/* Formatting_lit */Block.__(17, [
                                                                                                      /* Break */Block.__(0, [
                                                                                                          "@;<1 2>",
                                                                                                          1,
                                                                                                          2
                                                                                                        ]),
                                                                                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                                              /* Close_box */0,
                                                                                                              /* End_of_format */0
                                                                                                            ])])
                                                                                                    ])])
                                                                                            ])])
                                                                                    ])])
                                                                            ]),
                                                                          "@[%t@;<1 2>%a@ %t@;<1 2>%a@]"
                                                                        ]), txt1, (function (param, param$1) {
                                                                        return type_path_expansion(tp, param, param$1);
                                                                      }), match[1], txt3, (function (param, param$1) {
                                                                        return type_path_expansion(tp0, param, param$1);
                                                                      }), tp0$prime);
                                                        }));
                                        case /* Invalid_format */15 :
                                            return Curry._1(Format.fprintf(param, /* Format */[
                                                            /* String */Block.__(2, [
                                                                /* No_padding */0,
                                                                /* End_of_format */0
                                                              ]),
                                                            "%s"
                                                          ]), param$1[0]);
                                        case /* Undefined_method */16 :
                                            var ty$2 = param$1[0];
                                            reset(void 0);
                                            mark_loops(ty$2);
                                            return Curry._3(Format.fprintf(param, /* Format */[
                                                            /* Formatting_gen */Block.__(18, [
                                                                /* Open_box */Block.__(1, [/* Format */[
                                                                      /* String_literal */Block.__(11, [
                                                                          "<v>",
                                                                          /* End_of_format */0
                                                                        ]),
                                                                      "<v>"
                                                                    ]]),
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* End_of_format */0,
                                                                          ""
                                                                        ]]),
                                                                    /* String_literal */Block.__(11, [
                                                                        "This expression has type",
                                                                        /* Formatting_lit */Block.__(17, [
                                                                            /* Break */Block.__(0, [
                                                                                "@;<1 2>",
                                                                                1,
                                                                                2
                                                                              ]),
                                                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                    /* Close_box */0,
                                                                                    /* Formatting_lit */Block.__(17, [
                                                                                        /* Break */Block.__(0, [
                                                                                            "@,",
                                                                                            0,
                                                                                            0
                                                                                          ]),
                                                                                        /* String_literal */Block.__(11, [
                                                                                            "It has no method ",
                                                                                            /* String */Block.__(2, [
                                                                                                /* No_padding */0,
                                                                                                /* Formatting_lit */Block.__(17, [
                                                                                                    /* Close_box */0,
                                                                                                    /* End_of_format */0
                                                                                                  ])
                                                                                              ])
                                                                                          ])
                                                                                      ])
                                                                                  ])])
                                                                          ])
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "@[<v>@[This expression has type@;<1 2>%a@]@,It has no method %s@]"
                                                          ]), type_expr$1, ty$2, param$1[1]);
                                        case /* Undefined_inherited_method */17 :
                                            return Curry._1(Format.fprintf(param, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "This expression has no method ",
                                                                /* String */Block.__(2, [
                                                                    /* No_padding */0,
                                                                    /* End_of_format */0
                                                                  ])
                                                              ]),
                                                            "This expression has no method %s"
                                                          ]), param$1[0]);
                                        case /* Virtual_class */18 :
                                            return Curry._2(Format.fprintf(param, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "Cannot instantiate the virtual class ",
                                                                /* Alpha */Block.__(15, [/* End_of_format */0])
                                                              ]),
                                                            "Cannot instantiate the virtual class %a"
                                                          ]), longident, param$1[0]);
                                        case /* Private_type */19 :
                                            return Curry._2(Format.fprintf(param, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "Cannot create values of the private type ",
                                                                /* Alpha */Block.__(15, [/* End_of_format */0])
                                                              ]),
                                                            "Cannot create values of the private type %a"
                                                          ]), type_expr$1, param$1[0]);
                                        case /* Private_label */20 :
                                            return Curry._4(Format.fprintf(param, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "Cannot assign field ",
                                                                /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                                                        " of the private type ",
                                                                        /* Alpha */Block.__(15, [/* End_of_format */0])
                                                                      ])])
                                                              ]),
                                                            "Cannot assign field %a of the private type %a"
                                                          ]), longident, param$1[0], type_expr$1, param$1[1]);
                                        case /* Unbound_instance_variable */21 :
                                            return Curry._1(Format.fprintf(param, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "Unbound instance variable ",
                                                                /* String */Block.__(2, [
                                                                    /* No_padding */0,
                                                                    /* End_of_format */0
                                                                  ])
                                                              ]),
                                                            "Unbound instance variable %s"
                                                          ]), param$1[0]);
                                        case /* Instance_variable_not_mutable */22 :
                                            var v = param$1[1];
                                            if (param$1[0]) {
                                              return Curry._1(Format.fprintf(param, /* Format */[
                                                              /* String_literal */Block.__(11, [
                                                                  "The instance variable ",
                                                                  /* String */Block.__(2, [
                                                                      /* No_padding */0,
                                                                      /* String_literal */Block.__(11, [
                                                                          " is not mutable",
                                                                          /* End_of_format */0
                                                                        ])
                                                                    ])
                                                                ]),
                                                              "The instance variable %s is not mutable"
                                                            ]), v);
                                            } else {
                                              return Curry._1(Format.fprintf(param, /* Format */[
                                                              /* String_literal */Block.__(11, [
                                                                  "The value ",
                                                                  /* String */Block.__(2, [
                                                                      /* No_padding */0,
                                                                      /* String_literal */Block.__(11, [
                                                                          " is not an instance variable",
                                                                          /* End_of_format */0
                                                                        ])
                                                                    ])
                                                                ]),
                                                              "The value %s is not an instance variable"
                                                            ]), v);
                                            }
                                        case /* Not_subtype */23 :
                                            var tr1 = param$1[0];
                                            var txt1$1 = "is not a subtype of";
                                            var tr2 = param$1[1];
                                            return wrap_printing_env(env, (function (param$4) {
                                                          reset(void 0);
                                                          var tr1$1 = List.map(prepare_expansion, tr1);
                                                          var tr2$1 = List.map(prepare_expansion, tr2);
                                                          var partial_arg = tr2$1 === /* [] */0;
                                                          Curry._2(Format.fprintf(param, /* Format */[
                                                                    /* Formatting_gen */Block.__(18, [
                                                                        /* Open_box */Block.__(1, [/* Format */[
                                                                              /* String_literal */Block.__(11, [
                                                                                  "<v>",
                                                                                  /* End_of_format */0
                                                                                ]),
                                                                              "<v>"
                                                                            ]]),
                                                                        /* Alpha */Block.__(15, [/* End_of_format */0])
                                                                      ]),
                                                                    "@[<v>%a"
                                                                  ]), (function (param, param$1) {
                                                                  return trace$1(true, partial_arg, txt1$1, param, param$1);
                                                                }), tr1$1);
                                                          if (tr2$1 === /* [] */0) {
                                                            return Format.fprintf(param, /* Format */[
                                                                        /* Formatting_lit */Block.__(17, [
                                                                            /* Close_box */0,
                                                                            /* End_of_format */0
                                                                          ]),
                                                                        "@]"
                                                                      ]);
                                                          }
                                                          var mis = mismatch(true, tr2$1);
                                                          var partial_arg$1 = mis === void 0;
                                                          return Curry._3(Format.fprintf(param, /* Format */[
                                                                          /* Alpha */Block.__(15, [/* Theta */Block.__(16, [/* Formatting_lit */Block.__(17, [
                                                                                      /* Close_box */0,
                                                                                      /* End_of_format */0
                                                                                    ])])]),
                                                                          "%a%t@]"
                                                                        ]), (function (param, param$1) {
                                                                        return trace$1(false, partial_arg$1, "is not compatible with type", param, param$1);
                                                                      }), tr2$1, (function (param) {
                                                                        return explanation(true, mis, param);
                                                                      }));
                                                        }));
                                        case /* Value_multiply_overridden */24 :
                                            return Curry._1(Format.fprintf(param, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "The instance variable ",
                                                                /* String */Block.__(2, [
                                                                    /* No_padding */0,
                                                                    /* String_literal */Block.__(11, [
                                                                        " is overridden several times",
                                                                        /* End_of_format */0
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "The instance variable %s is overridden several times"
                                                          ]), param$1[0]);
                                        case /* Coercion_failure */25 :
                                            var ty$prime = param$1[1];
                                            var ty$3 = param$1[0];
                                            report_unification_error(param, env, void 0, param$1[2], (function (ppf) {
                                                    var match = prepare_expansion(/* tuple */[
                                                          ty$3,
                                                          ty$prime
                                                        ]);
                                                    var ty$4 = match[0];
                                                    return Curry._2(Format.fprintf(ppf, /* Format */[
                                                                    /* String_literal */Block.__(11, [
                                                                        "This expression cannot be coerced to type",
                                                                        /* Formatting_lit */Block.__(17, [
                                                                            /* Break */Block.__(0, [
                                                                                "@;<1 2>",
                                                                                1,
                                                                                2
                                                                              ]),
                                                                            /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                                                    /* ";" */59,
                                                                                    /* Formatting_lit */Block.__(17, [
                                                                                        /* Break */Block.__(0, [
                                                                                            "@ ",
                                                                                            1,
                                                                                            0
                                                                                          ]),
                                                                                        /* String_literal */Block.__(11, [
                                                                                            "it has type",
                                                                                            /* End_of_format */0
                                                                                          ])
                                                                                      ])
                                                                                  ])])
                                                                          ])
                                                                      ]),
                                                                    "This expression cannot be coerced to type@;<1 2>%a;@ it has type"
                                                                  ]), (function (param, param$1) {
                                                                  return type_expansion(ty$4, param, param$1);
                                                                }), match[1]);
                                                  }), (function (ppf) {
                                                    return Format.fprintf(ppf, /* Format */[
                                                                /* String_literal */Block.__(11, [
                                                                    "but is here used with type",
                                                                    /* End_of_format */0
                                                                  ]),
                                                                "but is here used with type"
                                                              ]);
                                                  }));
                                            if (param$1[3]) {
                                              return Curry._2(Format.fprintf(param, /* Format */[
                                                              /* Char_literal */Block.__(12, [
                                                                  /* "." */46,
                                                                  /* Formatting_lit */Block.__(17, [
                                                                      /* Flush_newline */4,
                                                                      /* Formatting_gen */Block.__(18, [
                                                                          /* Open_box */Block.__(1, [/* Format */[
                                                                                /* String_literal */Block.__(11, [
                                                                                    "<hov>",
                                                                                    /* End_of_format */0
                                                                                  ]),
                                                                                "<hov>"
                                                                              ]]),
                                                                          /* String */Block.__(2, [
                                                                              /* No_padding */0,
                                                                              /* Formatting_lit */Block.__(17, [
                                                                                  /* Break */Block.__(0, [
                                                                                      "@ ",
                                                                                      1,
                                                                                      0
                                                                                    ]),
                                                                                  /* String */Block.__(2, [
                                                                                      /* No_padding */0,
                                                                                      /* Formatting_lit */Block.__(17, [
                                                                                          /* Close_box */0,
                                                                                          /* End_of_format */0
                                                                                        ])
                                                                                    ])
                                                                                ])
                                                                            ])
                                                                        ])
                                                                    ])
                                                                ]),
                                                              ".@.@[<hov>%s@ %s@]"
                                                            ]), "This simple coercion was not fully general.", "Consider using a double coercion.");
                                            } else {
                                              return ;
                                            }
                                        case /* Too_many_arguments */26 :
                                            var ty$4 = param$1[1];
                                            reset(void 0);
                                            mark_loops(ty$4);
                                            if (param$1[0]) {
                                              Format.fprintf(param, /* Format */[
                                                    /* String_literal */Block.__(11, [
                                                        "This function expects too many arguments,",
                                                        /* Formatting_lit */Block.__(17, [
                                                            /* Break */Block.__(0, [
                                                                "@ ",
                                                                1,
                                                                0
                                                              ]),
                                                            /* End_of_format */0
                                                          ])
                                                      ]),
                                                    "This function expects too many arguments,@ "
                                                  ]);
                                              return Curry._2(Format.fprintf(param, /* Format */[
                                                              /* String_literal */Block.__(11, [
                                                                  "it should have type",
                                                                  /* Formatting_lit */Block.__(17, [
                                                                      /* Break */Block.__(0, [
                                                                          "@ ",
                                                                          1,
                                                                          0
                                                                        ]),
                                                                      /* Alpha */Block.__(15, [/* End_of_format */0])
                                                                    ])
                                                                ]),
                                                              "it should have type@ %a"
                                                            ]), type_expr$1, ty$4);
                                            } else {
                                              Format.fprintf(param, /* Format */[
                                                    /* String_literal */Block.__(11, [
                                                        "This expression should not be a function,",
                                                        /* Formatting_lit */Block.__(17, [
                                                            /* Break */Block.__(0, [
                                                                "@ ",
                                                                1,
                                                                0
                                                              ]),
                                                            /* End_of_format */0
                                                          ])
                                                      ]),
                                                    "This expression should not be a function,@ "
                                                  ]);
                                              return Curry._2(Format.fprintf(param, /* Format */[
                                                              /* String_literal */Block.__(11, [
                                                                  "the expected type is",
                                                                  /* Formatting_lit */Block.__(17, [
                                                                      /* Break */Block.__(0, [
                                                                          "@ ",
                                                                          1,
                                                                          0
                                                                        ]),
                                                                      /* Alpha */Block.__(15, [/* End_of_format */0])
                                                                    ])
                                                                ]),
                                                              "the expected type is@ %a"
                                                            ]), type_expr$1, ty$4);
                                            }
                                        case /* Abstract_wrong_label */27 :
                                            var ty$5 = param$1[1];
                                            var label_mark = function (l) {
                                              if (l === "") {
                                                return "but its first argument is not labelled";
                                              } else {
                                                return Curry._1(Format.sprintf(/* Format */[
                                                                /* String_literal */Block.__(11, [
                                                                    "but its first argument is labelled ",
                                                                    /* String */Block.__(2, [
                                                                        /* No_padding */0,
                                                                        /* End_of_format */0
                                                                      ])
                                                                  ]),
                                                                "but its first argument is labelled %s"
                                                              ]), prefixed_label_name(l));
                                              }
                                            };
                                            reset(void 0);
                                            mark_loops(ty$5);
                                            return Curry._3(Format.fprintf(param, /* Format */[
                                                            /* Formatting_gen */Block.__(18, [
                                                                /* Open_box */Block.__(1, [/* Format */[
                                                                      /* String_literal */Block.__(11, [
                                                                          "<v>",
                                                                          /* End_of_format */0
                                                                        ]),
                                                                      "<v>"
                                                                    ]]),
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* String_literal */Block.__(11, [
                                                                              "<2>",
                                                                              /* End_of_format */0
                                                                            ]),
                                                                          "<2>"
                                                                        ]]),
                                                                    /* String_literal */Block.__(11, [
                                                                        "This function should have type",
                                                                        /* Formatting_lit */Block.__(17, [
                                                                            /* Break */Block.__(0, [
                                                                                "@ ",
                                                                                1,
                                                                                0
                                                                              ]),
                                                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                    /* Close_box */0,
                                                                                    /* Formatting_lit */Block.__(17, [
                                                                                        /* Break */Block.__(0, [
                                                                                            "@,",
                                                                                            0,
                                                                                            0
                                                                                          ]),
                                                                                        /* String */Block.__(2, [
                                                                                            /* No_padding */0,
                                                                                            /* Formatting_lit */Block.__(17, [
                                                                                                /* Close_box */0,
                                                                                                /* End_of_format */0
                                                                                              ])
                                                                                          ])
                                                                                      ])
                                                                                  ])])
                                                                          ])
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "@[<v>@[<2>This function should have type@ %a@]@,%s@]"
                                                          ]), type_expr$1, ty$5, label_mark(param$1[0]));
                                        case /* Scoping_let_module */28 :
                                            var ty$6 = param$1[1];
                                            reset(void 0);
                                            mark_loops(ty$6);
                                            Curry._2(Format.fprintf(param, /* Format */[
                                                      /* String_literal */Block.__(11, [
                                                          "This `let module' expression has type",
                                                          /* Formatting_lit */Block.__(17, [
                                                              /* Break */Block.__(0, [
                                                                  "@ ",
                                                                  1,
                                                                  0
                                                                ]),
                                                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                      /* Break */Block.__(0, [
                                                                          "@ ",
                                                                          1,
                                                                          0
                                                                        ]),
                                                                      /* End_of_format */0
                                                                    ])])
                                                            ])
                                                        ]),
                                                      "This `let module' expression has type@ %a@ "
                                                    ]), type_expr$1, ty$6);
                                            return Curry._1(Format.fprintf(param, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "In this type, the locally bound module name ",
                                                                /* String */Block.__(2, [
                                                                    /* No_padding */0,
                                                                    /* String_literal */Block.__(11, [
                                                                        " escapes its scope",
                                                                        /* End_of_format */0
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "In this type, the locally bound module name %s escapes its scope"
                                                          ]), param$1[0]);
                                        case /* Masked_instance_variable */29 :
                                            return Curry._2(Format.fprintf(param, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "The instance variable ",
                                                                /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                        /* Break */Block.__(0, [
                                                                            "@ ",
                                                                            1,
                                                                            0
                                                                          ]),
                                                                        /* String_literal */Block.__(11, [
                                                                            "cannot be accessed from the definition of another instance variable",
                                                                            /* End_of_format */0
                                                                          ])
                                                                      ])])
                                                              ]),
                                                            "The instance variable %a@ cannot be accessed from the definition of another instance variable"
                                                          ]), longident, param$1[0]);
                                        case /* Not_a_variant_type */30 :
                                            return Curry._2(Format.fprintf(param, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "The type ",
                                                                /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                        /* Break */Block.__(0, [
                                                                            "@ ",
                                                                            1,
                                                                            0
                                                                          ]),
                                                                        /* String_literal */Block.__(11, [
                                                                            "is not a variant type",
                                                                            /* End_of_format */0
                                                                          ])
                                                                      ])])
                                                              ]),
                                                            "The type %a@ is not a variant type"
                                                          ]), longident, param$1[0]);
                                        case /* Less_general */31 :
                                            var kind$2 = param$1[0];
                                            return report_unification_error(param, env, void 0, param$1[1], (function (ppf) {
                                                          return Curry._1(Format.fprintf(ppf, /* Format */[
                                                                          /* String_literal */Block.__(11, [
                                                                              "This ",
                                                                              /* String */Block.__(2, [
                                                                                  /* No_padding */0,
                                                                                  /* String_literal */Block.__(11, [
                                                                                      " has type",
                                                                                      /* End_of_format */0
                                                                                    ])
                                                                                ])
                                                                            ]),
                                                                          "This %s has type"
                                                                        ]), kind$2);
                                                        }), (function (ppf) {
                                                          return Format.fprintf(ppf, /* Format */[
                                                                      /* String_literal */Block.__(11, [
                                                                          "which is less general than",
                                                                          /* End_of_format */0
                                                                        ]),
                                                                      "which is less general than"
                                                                    ]);
                                                        }));
                                        case /* Not_a_packed_module */32 :
                                            return Curry._2(Format.fprintf(param, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "This expression is packed module, but the expected type is",
                                                                /* Formatting_lit */Block.__(17, [
                                                                    /* Break */Block.__(0, [
                                                                        "@ ",
                                                                        1,
                                                                        0
                                                                      ]),
                                                                    /* Alpha */Block.__(15, [/* End_of_format */0])
                                                                  ])
                                                              ]),
                                                            "This expression is packed module, but the expected type is@ %a"
                                                          ]), type_expr$1, param$1[0]);
                                        case /* Recursive_local_constraint */33 :
                                            return report_unification_error(param, env, void 0, param$1[0], (function (ppf) {
                                                          return Format.fprintf(ppf, /* Format */[
                                                                      /* String_literal */Block.__(11, [
                                                                          "Recursive local constraint when unifying",
                                                                          /* End_of_format */0
                                                                        ]),
                                                                      "Recursive local constraint when unifying"
                                                                    ]);
                                                        }), (function (ppf) {
                                                          return Format.fprintf(ppf, /* Format */[
                                                                      /* String_literal */Block.__(11, [
                                                                          "with",
                                                                          /* End_of_format */0
                                                                        ]),
                                                                      "with"
                                                                    ]);
                                                        }));
                                        case /* Unqualified_gadt_pattern */34 :
                                            return Curry._4(Format.fprintf(param, /* Format */[
                                                            /* Formatting_gen */Block.__(18, [
                                                                /* Open_box */Block.__(1, [/* Format */[
                                                                      /* End_of_format */0,
                                                                      ""
                                                                    ]]),
                                                                /* String_literal */Block.__(11, [
                                                                    "The GADT constructor ",
                                                                    /* String */Block.__(2, [
                                                                        /* No_padding */0,
                                                                        /* String_literal */Block.__(11, [
                                                                            " of type ",
                                                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                    /* Break */Block.__(0, [
                                                                                        "@ ",
                                                                                        1,
                                                                                        0
                                                                                      ]),
                                                                                    /* String */Block.__(2, [
                                                                                        /* No_padding */0,
                                                                                        /* Char_literal */Block.__(12, [
                                                                                            /* "." */46,
                                                                                            /* Formatting_lit */Block.__(17, [
                                                                                                /* Close_box */0,
                                                                                                /* End_of_format */0
                                                                                              ])
                                                                                          ])
                                                                                      ])
                                                                                  ])])
                                                                          ])
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "@[The GADT constructor %s of type %a@ %s.@]"
                                                          ]), param$1[1], path, param$1[0], "must be qualified in this pattern");
                                        
                                      }
                                    }
                                  }));
                    }), param[3]);
      }));

add_delayed_check_forward.contents = add_delayed_check;

var $$Error$8 = Caml_exceptions.create("Ocaml_typedtree_test.Typedecl.Error");

function enter_type$1(env, sdecl, id) {
  var match = sdecl.ptype_manifest;
  var decl_type_params = List.map((function (param) {
          return newty2(100000000, /* Tvar */Block.__(0, [void 0]));
        }), sdecl.ptype_params);
  var decl_type_arity = List.length(sdecl.ptype_params);
  var decl_type_private = sdecl.ptype_private;
  var decl_type_manifest = match !== void 0 ? newvar(void 0, void 0) : void 0;
  var decl_type_variance = List.map((function (param) {
          return Types_Variance.full;
        }), sdecl.ptype_params);
  var decl_type_loc = sdecl.ptype_loc;
  var decl_type_attributes = sdecl.ptype_attributes;
  var decl = {
    type_params: decl_type_params,
    type_arity: decl_type_arity,
    type_kind: /* Type_abstract */0,
    type_private: decl_type_private,
    type_manifest: decl_type_manifest,
    type_variance: decl_type_variance,
    type_newtype_level: void 0,
    type_loc: decl_type_loc,
    type_attributes: decl_type_attributes
  };
  return add_type$1(true, id, decl, env);
}

function is_fixed_type(sd) {
  var match = sd.ptype_manifest;
  if (match !== void 0 && sd.ptype_kind === /* Ptype_abstract */0 && sd.ptype_private === /* Private */0) {
    var _sty = match;
    while(true) {
      var sty = _sty;
      var match$1 = sty.ptyp_desc;
      if (typeof match$1 === "number") {
        return false;
      }
      switch (match$1.tag | 0) {
        case /* Ptyp_object */4 :
            if (match$1[1]) {
              return true;
            } else {
              return false;
            }
        case /* Ptyp_class */5 :
            return true;
        case /* Ptyp_alias */6 :
            _sty = match$1[0];
            continue ;
        case /* Ptyp_variant */7 :
            if (match$1[1]) {
              return true;
            } else {
              return match$1[2] !== void 0;
            }
        default:
          return false;
      }
    };
  } else {
    return false;
  }
}

function set_fixed_row(env, loc, p, decl) {
  var match = decl.type_manifest;
  var tm;
  if (match === void 0) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "typedecl.ml",
            113,
            14
          ]
        ];
  }
  tm = expand_head(env, match);
  var match$1 = tm.desc;
  var rv;
  if (typeof match$1 === "number") {
    throw [
          $$Error$8,
          loc,
          /* Bad_fixed_type */Block.__(18, ["is not an object or variant"])
        ];
  }
  switch (match$1.tag | 0) {
    case /* Tobject */4 :
        rv = flatten_fields(match$1[0])[1];
        break;
    case /* Tvariant */8 :
        var row = row_repr_aux(/* [] */0, match$1[0]);
        tm.desc = /* Tvariant */Block.__(8, [{
              row_fields: row.row_fields,
              row_more: row.row_more,
              row_bound: row.row_bound,
              row_closed: row.row_closed,
              row_fixed: true,
              row_name: row.row_name
            }]);
        rv = static_row(row) ? newty2(100000000, /* Tnil */0) : row.row_more;
        break;
    default:
      throw [
            $$Error$8,
            loc,
            /* Bad_fixed_type */Block.__(18, ["is not an object or variant"])
          ];
  }
  if (!is_Tvar(rv)) {
    throw [
          $$Error$8,
          loc,
          /* Bad_fixed_type */Block.__(18, ["has no row variable"])
        ];
  }
  rv.desc = /* Tconstr */Block.__(3, [
      p,
      decl.type_params,
      {
        contents: /* Mnil */0
      }
    ]);
  
}

function height$10(param) {
  if (param) {
    return param[/* h */3];
  } else {
    return 0;
  }
}

function create$11(l, v, r) {
  var hl = l ? l[/* h */3] : 0;
  var hr = r ? r[/* h */3] : 0;
  return /* Node */[
          /* l */l,
          /* v */v,
          /* r */r,
          /* h */hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        ];
}

function bal$10(l, v, r) {
  var hl = l ? l[/* h */3] : 0;
  var hr = r ? r[/* h */3] : 0;
  if (hl > (hr + 2 | 0)) {
    if (!l) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          ];
    }
    var lr = l[/* r */2];
    var lv = l[/* v */1];
    var ll = l[/* l */0];
    if (height$10(ll) >= height$10(lr)) {
      return create$11(ll, lv, create$11(lr, v, r));
    }
    if (lr) {
      return create$11(create$11(ll, lv, lr[/* l */0]), lr[/* v */1], create$11(lr[/* r */2], v, r));
    }
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Set.bal"
        ];
  } else {
    if (hr <= (hl + 2 | 0)) {
      return /* Node */[
              /* l */l,
              /* v */v,
              /* r */r,
              /* h */hl >= hr ? hl + 1 | 0 : hr + 1 | 0
            ];
    }
    if (!r) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          ];
    }
    var rr = r[/* r */2];
    var rv = r[/* v */1];
    var rl = r[/* l */0];
    if (height$10(rr) >= height$10(rl)) {
      return create$11(create$11(l, v, rl), rv, rr);
    }
    if (rl) {
      return create$11(create$11(l, v, rl[/* l */0]), rl[/* v */1], create$11(rl[/* r */2], rv, rr));
    }
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Set.bal"
        ];
  }
}

function add$12(x, t) {
  if (!t) {
    return /* Node */[
            /* l : Empty */0,
            /* v */x,
            /* r : Empty */0,
            /* h */1
          ];
  }
  var r = t[/* r */2];
  var v = t[/* v */1];
  var l = t[/* l */0];
  var c = Caml_primitive.caml_string_compare(x, v);
  if (c === 0) {
    return t;
  }
  if (c < 0) {
    var ll = add$12(x, l);
    if (l === ll) {
      return t;
    } else {
      return bal$10(ll, v, r);
    }
  } else {
    var rr = add$12(x, r);
    if (r === rr) {
      return t;
    } else {
      return bal$10(l, v, rr);
    }
  }
}

function mem$6(x, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return false;
    }
    var c = Caml_primitive.caml_string_compare(x, param[/* v */1]);
    if (c === 0) {
      return true;
    }
    _param = c < 0 ? param[/* l */0] : param[/* r */2];
    continue ;
  };
}

function make_params(env, params) {
  var make_param = function (param) {
    var sty = param[0];
    try {
      return /* tuple */[
              transl_type_param(env, sty),
              param[1]
            ];
    }
    catch (exn){
      if (exn === Already_bound) {
        throw [
              $$Error$8,
              sty.ptyp_loc,
              /* Repeated_parameter */0
            ];
      }
      throw exn;
    }
  };
  return List.map(make_param, params);
}

function make_constructor(env, type_path, type_params, sargs, sret_type) {
  if (sret_type !== void 0) {
    var sret_type$1 = sret_type;
    var z = narrow(void 0);
    reset_type_variables(void 0);
    var targs = List.map((function (param) {
            return transl_simple_type(env, false, param);
          }), sargs);
    var args = List.map((function (cty) {
            return cty.ctyp_type;
          }), targs);
    var tret_type = transl_simple_type(env, false, sret_type$1);
    var ret_type = tret_type.ctyp_type;
    var match = repr(ret_type).desc;
    var exit = 0;
    if (typeof match === "number" || !(match.tag === /* Tconstr */3 && same(type_path, match[0]))) {
      exit = 1;
    }
    if (exit === 1) {
      throw [
            $$Error$8,
            sret_type$1.ptyp_loc,
            /* Constraint_failed */Block.__(5, [
                ret_type,
                newconstr(type_path, type_params)
              ])
          ];
    }
    widen(z);
    return /* tuple */[
            targs,
            tret_type,
            args,
            ret_type
          ];
  } else {
    var targs$1 = List.map((function (param) {
            return transl_simple_type(env, true, param);
          }), sargs);
    var args$1 = List.map((function (cty) {
            return cty.ctyp_type;
          }), targs$1);
    return /* tuple */[
            targs$1,
            void 0,
            args$1,
            void 0
          ];
  }
}

function generalize_decl(decl) {
  List.iter(generalize, decl.type_params);
  var match = decl.type_kind;
  if (typeof match === "number") {
    match === /* Type_abstract */0;
  } else if (match.tag) {
    List.iter((function (c) {
            List.iter(generalize, c.cd_args);
            return may(generalize, c.cd_res);
          }), match[0]);
  } else {
    List.iter((function (l) {
            return iter_generalize$1({
                        contents: /* [] */0
                      }, l.ld_type);
          }), match[0]);
  }
  var match$1 = decl.type_manifest;
  if (match$1 !== void 0) {
    return iter_generalize$1({
                contents: /* [] */0
              }, match$1);
  }
  
}

function check_constraints_rec(env, loc, visited, _ty) {
  while(true) {
    var ty = _ty;
    var ty$1 = repr(ty);
    if (mem$3(ty$1, visited.contents)) {
      return ;
    }
    visited.contents = add$3(ty$1, visited.contents);
    var match = ty$1.desc;
    if (typeof match === "number") {
      return iter_type_expr((function (param) {
                    return check_constraints_rec(env, loc, visited, param);
                  }), ty$1);
    }
    switch (match.tag | 0) {
      case /* Tconstr */3 :
          var args = match[1];
          var path = match[0];
          var args$prime = List.map((function (param) {
                  return newvar(void 0, void 0);
                }), args);
          var ty$prime = newconstr(path, args$prime);
          try {
            enforce_constraints(env, ty$prime);
          }
          catch (raw_exn){
            var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn[0] === Unify) {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    /* tuple */[
                      "typedecl.ml",
                      360,
                      28
                    ]
                  ];
            }
            if (exn === Caml_builtin_exceptions.not_found) {
              throw [
                    $$Error$8,
                    loc,
                    /* Unavailable_type_constructor */Block.__(17, [path])
                  ];
            }
            throw exn;
          }
          if (!matches(env, ty$1, ty$prime)) {
            throw [
                  $$Error$8,
                  loc,
                  /* Constraint_failed */Block.__(5, [
                      ty$1,
                      ty$prime
                    ])
                ];
          }
          return List.iter((function (param) {
                        return check_constraints_rec(env, loc, visited, param);
                      }), args);
      case /* Tpoly */10 :
          var match$1 = instance_poly(void 0, false, match[1], match[0]);
          _ty = match$1[1];
          continue ;
      default:
        return iter_type_expr((function (param) {
                      return check_constraints_rec(env, loc, visited, param);
                    }), ty$1);
    }
  };
}

function height$11(param) {
  if (param) {
    return param[/* h */4];
  } else {
    return 0;
  }
}

function create$12(l, x, d, r) {
  var hl = height$11(l);
  var hr = height$11(r);
  return /* Node */[
          /* l */l,
          /* v */x,
          /* d */d,
          /* r */r,
          /* h */hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        ];
}

function bal$11(l, x, d, r) {
  var hl = l ? l[/* h */4] : 0;
  var hr = r ? r[/* h */4] : 0;
  if (hl > (hr + 2 | 0)) {
    if (!l) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Map.bal"
          ];
    }
    var lr = l[/* r */3];
    var ld = l[/* d */2];
    var lv = l[/* v */1];
    var ll = l[/* l */0];
    if (height$11(ll) >= height$11(lr)) {
      return create$12(ll, lv, ld, create$12(lr, x, d, r));
    }
    if (lr) {
      return create$12(create$12(ll, lv, ld, lr[/* l */0]), lr[/* v */1], lr[/* d */2], create$12(lr[/* r */3], x, d, r));
    }
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Map.bal"
        ];
  } else {
    if (hr <= (hl + 2 | 0)) {
      return /* Node */[
              /* l */l,
              /* v */x,
              /* d */d,
              /* r */r,
              /* h */hl >= hr ? hl + 1 | 0 : hr + 1 | 0
            ];
    }
    if (!r) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Map.bal"
          ];
    }
    var rr = r[/* r */3];
    var rd = r[/* d */2];
    var rv = r[/* v */1];
    var rl = r[/* l */0];
    if (height$11(rr) >= height$11(rl)) {
      return create$12(create$12(l, x, d, rl), rv, rd, rr);
    }
    if (rl) {
      return create$12(create$12(l, x, d, rl[/* l */0]), rl[/* v */1], rl[/* d */2], create$12(rl[/* r */3], rv, rd, rr));
    }
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Map.bal"
        ];
  }
}

function add$13(x, data, m) {
  if (!m) {
    return /* Node */[
            /* l : Empty */0,
            /* v */x,
            /* d */data,
            /* r : Empty */0,
            /* h */1
          ];
  }
  var r = m[/* r */3];
  var d = m[/* d */2];
  var v = m[/* v */1];
  var l = m[/* l */0];
  var c = Caml_primitive.caml_string_compare(x, v);
  if (c === 0) {
    if (d === data) {
      return m;
    } else {
      return /* Node */[
              /* l */l,
              /* v */x,
              /* d */data,
              /* r */r,
              /* h */m[/* h */4]
            ];
    }
  }
  if (c < 0) {
    var ll = add$13(x, data, l);
    if (l === ll) {
      return m;
    } else {
      return bal$11(ll, v, d, r);
    }
  } else {
    var rr = add$13(x, data, r);
    if (r === rr) {
      return m;
    } else {
      return bal$11(l, v, d, rr);
    }
  }
}

function find$6(x, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      throw Caml_builtin_exceptions.not_found;
    }
    var c = Caml_primitive.caml_string_compare(x, param[/* v */1]);
    if (c === 0) {
      return param[/* d */2];
    }
    _param = c < 0 ? param[/* l */0] : param[/* r */3];
    continue ;
  };
}

function check_coherence(env, loc, id, decl) {
  var match = decl.type_kind;
  if (typeof match === "number" && match === 0) {
    return ;
  }
  var match$1 = decl.type_manifest;
  if (match$1 === void 0) {
    return ;
  }
  var ty = match$1;
  var match$2 = repr(ty).desc;
  if (typeof match$2 === "number") {
    throw [
          $$Error$8,
          loc,
          /* Definition_mismatch */Block.__(4, [
              ty,
              /* [] */0
            ])
        ];
  }
  if (match$2.tag !== /* Tconstr */3) {
    throw [
          $$Error$8,
          loc,
          /* Definition_mismatch */Block.__(4, [
              ty,
              /* [] */0
            ])
        ];
  }
  var args = match$2[1];
  var path = match$2[0];
  try {
    var decl$prime = find_type_full(path, env)[0];
    var err = List.length(args) !== List.length(decl.type_params) ? /* :: */[
        /* Arity */0,
        /* [] */0
      ] : (
        equal$4(env, false, args, decl.type_params) ? type_declarations$1(true, env, last(path), decl$prime, id, type_declaration(add_type(id, path, identity), decl)) : /* :: */[
            /* Constraint */3,
            /* [] */0
          ]
      );
    if (err !== /* [] */0) {
      throw [
            $$Error$8,
            loc,
            /* Definition_mismatch */Block.__(4, [
                ty,
                err
              ])
          ];
    }
    return ;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      throw [
            $$Error$8,
            loc,
            /* Unavailable_type_constructor */Block.__(17, [path])
          ];
    }
    throw exn;
  }
}

function check_well_founded(env, loc, path, to_check, ty) {
  var visited = {
    contents: /* Empty */0
  };
  var check = function (ty0, exp_nodes, ty) {
    var ty$1 = repr(ty);
    if (mem$3(ty$1, exp_nodes)) {
      var match = ty0.desc;
      var tmp;
      tmp = typeof match === "number" || match.tag !== /* Tconstr */3 ? false : same(match[0], path);
      if (tmp) {
        throw [
              $$Error$8,
              loc,
              /* Recursive_abbrev */Block.__(2, [name(void 0, path)])
            ];
      }
      throw [
            $$Error$8,
            loc,
            /* Cycle_in_def */Block.__(3, [
                name(void 0, path),
                ty0
              ])
          ];
    }
    var match$1;
    try {
      var prev = find$1(ty$1, visited.contents);
      match$1 = subset$1(exp_nodes, prev) ? /* tuple */[
          true,
          exp_nodes
        ] : /* tuple */[
          false,
          union$2(exp_nodes, prev)
        ];
    }
    catch (exn){
      if (exn !== Caml_builtin_exceptions.not_found) {
        throw exn;
      }
      match$1 = /* tuple */[
        false,
        exp_nodes
      ];
    }
    var exp_nodes$1 = match$1[1];
    var snap = snapshot(void 0);
    if (match$1[0]) {
      return ;
    }
    try {
      visited.contents = add$4(ty$1, exp_nodes$1, visited.contents);
      var match$2 = ty$1.desc;
      if (typeof match$2 === "number") {
        throw Cannot_expand;
      }
      if (match$2.tag !== /* Tconstr */3) {
        throw Cannot_expand;
      }
      if (!(!(
            exp_nodes$1 ? false : true
          ) || Curry._1(to_check, match$2[0]))) {
        throw Cannot_expand;
      }
      var ty$prime = try_expand_once_opt(env, ty$1);
      var ty0$1 = (
        exp_nodes$1 ? false : true
      ) ? ty$1 : ty0;
      return check(ty0$1, add$3(ty$1, exp_nodes$1), ty$prime);
    }
    catch (raw_exn){
      var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn$1 === Cannot_expand) {
        var tmp$1 = true;
        if (!(recursive_types.contents && is_contractive(env, ty$1))) {
          var match$3 = ty$1.desc;
          var tmp$2;
          if (typeof match$3 === "number") {
            tmp$2 = false;
          } else {
            switch (match$3.tag | 0) {
              case /* Tobject */4 :
              case /* Tvariant */8 :
                  tmp$2 = true;
                  break;
              default:
                tmp$2 = false;
            }
          }
          tmp$1 = tmp$2;
        }
        var nodes = tmp$1 ? /* Empty */0 : exp_nodes$1;
        return iter_type_expr((function (param) {
                      return check(ty0, nodes, param);
                    }), ty$1);
      } else {
        if (exn$1[0] === Unify) {
          return backtrack(snap);
        }
        throw exn$1;
      }
    }
  };
  return wrap_trace_gadt_instances(env, (function (param) {
                return check(ty, /* Empty */0, param);
              }), ty);
}

function check_well_founded_decl(env, loc, path, decl, to_check) {
  var it_it_type_expr = function (param) {
    return (function (param) {
        return check_well_founded(env, loc, path, to_check, param);
      });
  };
  var it = {
    it_signature: it_signature,
    it_signature_item: it_signature_item,
    it_value_description: it_value_description,
    it_type_declaration: it_type_declaration,
    it_extension_constructor: it_extension_constructor,
    it_module_declaration: it_module_declaration,
    it_modtype_declaration: it_modtype_declaration,
    it_class_declaration: it_class_declaration,
    it_class_type_declaration: it_class_type_declaration,
    it_module_type: it_module_type,
    it_class_type: it_class_type,
    it_type_kind: it_type_kind,
    it_do_type_expr: it_do_type_expr,
    it_type_expr: it_it_type_expr,
    it_path: it_path
  };
  return it_type_declaration(it, instance_declaration(decl));
}

function check_recursion(env, loc, path, decl, to_check) {
  if (decl.type_params === /* [] */0) {
    return ;
  }
  var visited = {
    contents: /* [] */0
  };
  var check_regular = function (cpath, args, prev_exp, _ty) {
    while(true) {
      var ty = _ty;
      var ty$1 = repr(ty);
      if (List.memq(ty$1, visited.contents)) {
        return ;
      }
      visited.contents = /* :: */[
        ty$1,
        visited.contents
      ];
      var match = ty$1.desc;
      if (typeof match === "number") {
        return iter_type_expr((function (param) {
                      return check_regular(cpath, args, prev_exp, param);
                    }), ty$1);
      }
      switch (match.tag | 0) {
        case /* Tconstr */3 :
            var args$prime = match[1];
            var path$prime = match[0];
            if (same(path, path$prime)) {
              if (!equal$4(env, false, args, args$prime)) {
                throw [
                      $$Error$8,
                      loc,
                      /* Parameters_differ */Block.__(8, [
                          cpath,
                          ty$1,
                          newconstr(path, args)
                        ])
                    ];
              }
              
            } else if (Curry._1(to_check, path$prime) && !List.mem(path$prime, prev_exp)) {
              try {
                var match$1 = find_type_expansion(path$prime, env);
                var params0 = match$1[0];
                var match$2 = instance_parameterized_type(void 0, params0, match$1[1]);
                try {
                  List.iter2((function (param, param$1) {
                          return unify$2(env, param, param$1);
                        }), match$2[0], args$prime);
                }
                catch (raw_exn){
                  var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                  if (exn[0] === Unify) {
                    throw [
                          $$Error$8,
                          loc,
                          /* Constraint_failed */Block.__(5, [
                              ty$1,
                              newconstr(path$prime, params0)
                            ])
                        ];
                  }
                  throw exn;
                }
                check_regular(path$prime, args, /* :: */[
                      path$prime,
                      prev_exp
                    ], match$2[1]);
              }
              catch (exn$1){
                if (exn$1 !== Caml_builtin_exceptions.not_found) {
                  throw exn$1;
                }
                
              }
            }
            return List.iter((function (param) {
                          return check_regular(cpath, args, prev_exp, param);
                        }), args$prime);
        case /* Tpoly */10 :
            var match$3 = instance_poly(true, false, match[1], match[0]);
            _ty = match$3[1];
            continue ;
        default:
          return iter_type_expr((function (param) {
                        return check_regular(cpath, args, prev_exp, param);
                      }), ty$1);
      }
    };
  };
  return may((function (body) {
                var match = instance_parameterized_type(true, decl.type_params, body);
                return check_regular(path, match[0], /* [] */0, match[1]);
              }), decl.type_manifest);
}

function get_variance(ty, visited) {
  try {
    return find$1(ty, visited.contents);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return Types_Variance.$$null;
    }
    throw exn;
  }
}

function compute_variance(env, visited, vari, ty) {
  var compute_variance_rec = function (_vari, _ty) {
    while(true) {
      var ty = _ty;
      var vari = _vari;
      var ty$1 = repr(ty);
      var vari$prime = get_variance(ty$1, visited);
      if (Curry._2(Types_Variance.subset, vari, vari$prime)) {
        return ;
      }
      var vari$1 = Curry._2(Types_Variance.union, vari, vari$prime);
      visited.contents = add$4(ty$1, vari$1, visited.contents);
      var compute_same = (function(vari$1){
      return function compute_same(param) {
        return compute_variance_rec(vari$1, param);
      }
      }(vari$1));
      var match = ty$1.desc;
      if (typeof match === "number") {
        return ;
      }
      switch (match.tag | 0) {
        case /* Tarrow */1 :
            var v = Curry._1(Types_Variance.conjugate, vari$1);
            var v1 = Curry._2(Types_Variance.mem, /* May_pos */0, v) || Curry._2(Types_Variance.mem, /* May_neg */1, v) ? Curry._3(Types_Variance.set, /* May_weak */2, true, v) : v;
            compute_variance_rec(v1, match[1]);
            _ty = match[2];
            _vari = vari$1;
            continue ;
        case /* Ttuple */2 :
            return List.iter(compute_same, match[0]);
        case /* Tconstr */3 :
            var tl = match[1];
            if (tl === /* [] */0) {
              return ;
            }
            try {
              var decl = find_type_full(match[0], env)[0];
              return List.iter2((function(vari$1){
                        return function (ty, v) {
                          var strict = Curry._2(Types_Variance.mem, /* Inv */6, vari$1) && Curry._2(Types_Variance.mem, /* Inj */3, v) || (Curry._2(Types_Variance.mem, /* Pos */4, vari$1) || Curry._2(Types_Variance.mem, /* Neg */5, vari$1)) && Curry._2(Types_Variance.mem, /* Inv */6, v);
                          if (strict) {
                            return compute_variance_rec(Types_Variance.full, ty);
                          }
                          var p1 = Curry._2(Types_Variance.inter, v, vari$1);
                          var n1 = Curry._2(Types_Variance.inter, v, Curry._1(Types_Variance.conjugate, vari$1));
                          var v1 = Curry._2(Types_Variance.union, Curry._2(Types_Variance.inter, Types_Variance.covariant, Curry._2(Types_Variance.union, p1, Curry._1(Types_Variance.conjugate, p1))), Curry._2(Types_Variance.inter, Curry._1(Types_Variance.conjugate, Types_Variance.covariant), Curry._2(Types_Variance.union, n1, Curry._1(Types_Variance.conjugate, n1))));
                          var weak = Curry._2(Types_Variance.mem, /* May_weak */2, vari$1) && (Curry._2(Types_Variance.mem, /* May_pos */0, v) || Curry._2(Types_Variance.mem, /* May_neg */1, v)) || (Curry._2(Types_Variance.mem, /* May_pos */0, vari$1) || Curry._2(Types_Variance.mem, /* May_neg */1, vari$1)) && Curry._2(Types_Variance.mem, /* May_weak */2, v);
                          var v2 = Curry._3(Types_Variance.set, /* May_weak */2, weak, v1);
                          return compute_variance_rec(v2, ty);
                        }
                        }(vari$1)), tl, decl.type_variance);
            }
            catch (exn){
              if (exn === Caml_builtin_exceptions.not_found) {
                return List.iter((function (param) {
                              return compute_variance_rec(Types_Variance.may_inv, param);
                            }), tl);
              }
              throw exn;
            }
        case /* Tfield */5 :
            compute_variance_rec(vari$1, match[2]);
            _ty = match[3];
            _vari = vari$1;
            continue ;
        case /* Tvariant */8 :
            var row = row_repr_aux(/* [] */0, match[0]);
            List.iter((function(vari$1){
                return function (param) {
                  var match = row_field_repr_aux(/* [] */0, param[1]);
                  if (typeof match === "number") {
                    return ;
                  }
                  if (match.tag) {
                    var upper = List.fold_left((function (s, f) {
                            return Curry._3(Types_Variance.set, f, true, s);
                          }), Types_Variance.$$null, /* :: */[
                          /* May_pos */0,
                          /* :: */[
                            /* May_neg */1,
                            /* :: */[
                              /* May_weak */2,
                              /* [] */0
                            ]
                          ]
                        ]);
                    var v = Curry._2(Types_Variance.inter, vari$1, upper);
                    return List.iter((function (param) {
                                  return compute_variance_rec(v, param);
                                }), match[1]);
                  } else {
                    var match$1 = match[0];
                    if (match$1 !== void 0) {
                      return compute_variance_rec(vari$1, match$1);
                    } else {
                      return ;
                    }
                  }
                }
                }(vari$1)), row.row_fields);
            _ty = row.row_more;
            _vari = vari$1;
            continue ;
        case /* Tobject */4 :
        case /* Tsubst */7 :
        case /* Tpoly */10 :
            _ty = match[0];
            _vari = vari$1;
            continue ;
        case /* Tpackage */11 :
            var v$1 = Curry._2(Types_Variance.mem, /* Pos */4, vari$1) || Curry._2(Types_Variance.mem, /* Neg */5, vari$1) ? Types_Variance.full : Types_Variance.may_inv;
            return List.iter((function(v$1){
                      return function (param) {
                        return compute_variance_rec(v$1, param);
                      }
                      }(v$1)), match[2]);
        default:
          return ;
      }
    };
  };
  return compute_variance_rec(vari, ty);
}

function make(p, n, i) {
  return Curry._3(Types_Variance.set, /* May_pos */0, p, Curry._3(Types_Variance.set, /* May_neg */1, n, Curry._3(Types_Variance.set, /* May_weak */2, n, Curry._3(Types_Variance.set, /* Inj */3, i, Types_Variance.$$null))));
}

function compute_variance_type(env, check, param, decl, tyl) {
  var loc = param[1];
  var required = List.map((function (param) {
          var i = param[2];
          var n = param[1];
          var c = param[0];
          if (c || n) {
            return /* tuple */[
                    c,
                    n,
                    i
                  ];
          } else {
            return /* tuple */[
                    true,
                    true,
                    i
                  ];
          }
        }), param[0]);
  var params = List.map(repr, decl.type_params);
  var tvl = {
    contents: /* Empty */0
  };
  List.iter((function (param) {
          return compute_variance(env, tvl, param[0] ? Types_Variance.full : Types_Variance.covariant, param[1]);
        }), tyl);
  if (check) {
    var pos = {
      contents: 0
    };
    List.iter2((function (ty, param) {
            var i = param[2];
            var n = param[1];
            var c = param[0];
            pos.contents = pos.contents + 1 | 0;
            var $$var = get_variance(ty, tvl);
            var match = Curry._1(Types_Variance.get_upper, $$var);
            var cn = match[1];
            var co = match[0];
            var ij = Curry._2(Types_Variance.mem, /* Inj */3, $$var);
            if (is_Tvar(ty) && (co && !c || cn && !n || !ij && i)) {
              throw [
                    $$Error$8,
                    loc,
                    /* Bad_variance */Block.__(16, [
                        pos.contents,
                        /* tuple */[
                          co,
                          cn,
                          ij
                        ],
                        /* tuple */[
                          c,
                          n,
                          i
                        ]
                      ])
                  ];
            }
            
          }), params, required);
    var args = newty2(100000000, /* Ttuple */Block.__(2, [params]));
    var fvl = free_variables$1(void 0, args);
    var fvl$1 = List.filter((function (v) {
              return !List.memq(v, params);
            }))(fvl);
    if (fvl$1 !== /* [] */0) {
      var tvl2 = {
        contents: /* Empty */0
      };
      List.iter2((function (ty, param) {
              if (is_Tvar(ty)) {
                return ;
              }
              var v = param[0] ? (
                  param[1] ? Types_Variance.full : Types_Variance.covariant
                ) : Curry._1(Types_Variance.conjugate, Types_Variance.covariant);
              return compute_variance(env, tvl2, v, ty);
            }), params, required);
      var visited = {
        contents: /* Empty */0
      };
      var check$1 = function (ty) {
        var ty$1 = repr(ty);
        if (mem$3(ty$1, visited.contents)) {
          return ;
        }
        var visited$prime = add$3(ty$1, visited.contents);
        visited.contents = visited$prime;
        var v1 = get_variance(ty$1, tvl);
        var snap = snapshot(void 0);
        var v2 = fold$3((function (t, vt, v) {
                if (equal$4(env, false, /* :: */[
                        ty$1,
                        /* [] */0
                      ], /* :: */[
                        t,
                        /* [] */0
                      ])) {
                  return Curry._2(Types_Variance.union, vt, v);
                } else {
                  return v;
                }
              }), tvl2.contents, Types_Variance.$$null);
        backtrack(snap);
        var match = Curry._1(Types_Variance.get_upper, v1);
        var n1 = match[1];
        var c1 = match[0];
        var match$1 = Curry._1(Types_Variance.get_lower, v2);
        var n2 = match$1[1];
        var c2 = match$1[0];
        if (!(c1 && !c2 || n1 && !n2)) {
          return ;
        }
        if (!List.memq(ty$1, fvl$1)) {
          return iter_type_expr(check$1, ty$1);
        }
        var code = match$1[3] ? (
            c2 || n2 ? -1 : -3
          ) : -2;
        throw [
              $$Error$8,
              loc,
              /* Bad_variance */Block.__(16, [
                  code,
                  /* tuple */[
                    c1,
                    n1,
                    false
                  ],
                  /* tuple */[
                    c2,
                    n2,
                    false
                  ]
                ])
            ];
      };
      List.iter((function (param) {
              return check$1(param[1]);
            }), tyl);
    }
    
  }
  return List.map2((function (ty, param) {
                var v = get_variance(ty, tvl);
                var tr = decl.type_private;
                var concr = decl.type_kind !== /* Type_abstract */0;
                var match = tr === /* Private */0 || !is_Tvar(ty) ? /* tuple */[
                    param[0],
                    param[1]
                  ] : /* tuple */[
                    false,
                    false
                  ];
                var n = match[1];
                var p = match[0];
                var i = concr || param[2] && tr === /* Private */0;
                var v$1 = Curry._2(Types_Variance.union, v, make(p, n, i));
                var v$2 = concr ? (
                    Curry._2(Types_Variance.mem, /* Pos */4, v$1) && Curry._2(Types_Variance.mem, /* Neg */5, v$1) ? Types_Variance.full : (
                        is_Tvar(ty) ? v$1 : Curry._2(Types_Variance.union, v$1, p ? (
                                  n ? Types_Variance.full : Types_Variance.covariant
                                ) : Curry._1(Types_Variance.conjugate, Types_Variance.covariant))
                      )
                  ) : v$1;
                if (decl.type_kind === /* Type_abstract */0 && tr === /* Public */1) {
                  return v$2;
                } else {
                  return Curry._3(Types_Variance.set, /* May_weak */2, Curry._2(Types_Variance.mem, /* May_neg */1, v$2), v$2);
                }
              }), params, required);
}

function add_false(param) {
  return List.map((function (ty) {
                return /* tuple */[
                        false,
                        ty
                      ];
              }), param);
}

function constrained(env, vars, ty) {
  var match = ty.desc;
  if (typeof match === "number" || match.tag) {
    return true;
  } else {
    return List.exists((function (tl) {
                  return List.memq(ty, tl);
                }), vars);
  }
}

function compute_variance_gadt(env, check, rloc, decl, param) {
  var ret_type_opt = param[1];
  var tl = param[0];
  var loc = rloc[1];
  if (ret_type_opt === void 0) {
    return compute_variance_type(env, check, rloc, {
                type_params: decl.type_params,
                type_arity: decl.type_arity,
                type_kind: decl.type_kind,
                type_private: /* Private */0,
                type_manifest: decl.type_manifest,
                type_variance: decl.type_variance,
                type_newtype_level: decl.type_newtype_level,
                type_loc: decl.type_loc,
                type_attributes: decl.type_attributes
              }, add_false(tl));
  }
  var match = repr(ret_type_opt);
  var match$1 = match.desc;
  if (typeof match$1 === "number") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "typedecl.ml",
            809,
            13
          ]
        ];
  }
  if (match$1.tag !== /* Tconstr */3) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "typedecl.ml",
            809,
            13
          ]
        ];
  }
  var tyl = List.map(repr, match$1[1]);
  var fvl = List.map((function (param) {
          return free_variables$1(void 0, param);
        }), tyl);
  List.fold_left2((function (param, ty, param$1) {
          var fv2 = param[1];
          if (!fv2) {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  /* tuple */[
                    "typedecl.ml",
                    798,
                    37
                  ]
                ];
          }
          var fv2$1 = fv2[1];
          var fv1 = param[0];
          if ((param$1[0] || param$1[1]) && constrained(env, Pervasives.$at(fv1, fv2$1), ty)) {
            throw [
                  $$Error$8,
                  loc,
                  /* Varying_anonymous */4
                ];
          }
          return /* tuple */[
                  /* :: */[
                    fv2[0],
                    fv1
                  ],
                  fv2$1
                ];
        }), /* tuple */[
        /* [] */0,
        fvl
      ], tyl, rloc[0]);
  return compute_variance_type(env, check, rloc, {
              type_params: tyl,
              type_arity: decl.type_arity,
              type_kind: decl.type_kind,
              type_private: /* Private */0,
              type_manifest: decl.type_manifest,
              type_variance: decl.type_variance,
              type_newtype_level: decl.type_newtype_level,
              type_loc: decl.type_loc,
              type_attributes: decl.type_attributes
            }, add_false(tl));
}

function compute_variance_extension(env, check, decl, ext, rloc) {
  return compute_variance_gadt(env, check, rloc, {
              type_params: ext.ext_type_params,
              type_arity: decl.type_arity,
              type_kind: decl.type_kind,
              type_private: decl.type_private,
              type_manifest: decl.type_manifest,
              type_variance: decl.type_variance,
              type_newtype_level: decl.type_newtype_level,
              type_loc: decl.type_loc,
              type_attributes: decl.type_attributes
            }, /* tuple */[
              ext.ext_args,
              ext.ext_ret_type
            ]);
}

function compute_variance_decl(env, check, decl, rloc) {
  if ((decl.type_kind === /* Type_abstract */0 || decl.type_kind === /* Type_open */1) && decl.type_manifest === void 0) {
    return List.map((function (param) {
                  return make(!param[1], !param[0], decl.type_kind !== /* Type_abstract */0 || param[2]);
                }), rloc[0]);
  }
  var match = decl.type_manifest;
  var mn = match !== void 0 ? /* :: */[
      /* tuple */[
        false,
        match
      ],
      /* [] */0
    ] : /* [] */0;
  var match$1 = decl.type_kind;
  if (typeof match$1 === "number") {
    return compute_variance_type(env, check, rloc, decl, mn);
  }
  if (!match$1.tag) {
    return compute_variance_type(env, check, rloc, decl, Pervasives.$at(mn, List.map((function (param) {
                          return /* tuple */[
                                  param.ld_mutable === /* Mutable */1,
                                  param.ld_type
                                ];
                        }), match$1[0])));
  }
  var tll = match$1[0];
  if (List.for_all((function (c) {
            return c.cd_res === void 0;
          }), tll)) {
    return compute_variance_type(env, check, rloc, decl, Pervasives.$at(mn, add_false(List.flatten(List.map((function (c) {
                                  return c.cd_args;
                                }), tll)))));
  }
  var mn$1 = List.map((function (param) {
          return /* tuple */[
                  /* :: */[
                    param[1],
                    /* [] */0
                  ],
                  void 0
                ];
        }), mn);
  var tll$1 = Pervasives.$at(mn$1, List.map((function (c) {
              return /* tuple */[
                      c.cd_args,
                      c.cd_res
                    ];
            }), tll));
  var match$2 = List.map((function (param) {
          return compute_variance_gadt(env, check, rloc, decl, param);
        }), tll$1);
  if (!match$2) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "typedecl.ml",
            848,
            15
          ]
        ];
  }
  var varl = List.fold_left((function (param, param$1) {
          return List.map2(Types_Variance.union, param, param$1);
        }), match$2[0], match$2[1]);
  return List.map((function (v) {
                if (Curry._2(Types_Variance.mem, /* Pos */4, v) && Curry._2(Types_Variance.mem, /* Neg */5, v)) {
                  return Types_Variance.full;
                } else {
                  return v;
                }
              }), varl);
}

function is_sharp(id) {
  var s = id.name;
  if (s.length !== 0) {
    return Caml_string.get(s, 0) === /* "#" */35;
  } else {
    return false;
  }
}

function compute_variance_fixpoint(env, decls, required, _variances) {
  while(true) {
    var variances = _variances;
    var new_decls = List.map2((function (param, variance) {
            var decl = param[1];
            return /* tuple */[
                    param[0],
                    {
                      type_params: decl.type_params,
                      type_arity: decl.type_arity,
                      type_kind: decl.type_kind,
                      type_private: decl.type_private,
                      type_manifest: decl.type_manifest,
                      type_variance: variance,
                      type_newtype_level: decl.type_newtype_level,
                      type_loc: decl.type_loc,
                      type_attributes: decl.type_attributes
                    }
                  ];
          }), decls, variances);
    var new_env = List.fold_right((function (param, env) {
            return add_type$1(true, param[0], param[1], env);
          }), new_decls, env);
    var new_variances = List.map2((function(new_env){
        return function (param) {
          var decl = param[1];
          return (function (param) {
              return compute_variance_decl(new_env, false, decl, param);
            });
        }
        }(new_env)), new_decls, required);
    var new_variances$1 = List.map2((function (param, param$1) {
            return List.map2(Types_Variance.union, param, param$1);
          }), new_variances, variances);
    if (Caml_obj.caml_notequal(new_variances$1, variances)) {
      _variances = new_variances$1;
      continue ;
    } else {
      List.iter2((function(new_env){
          return function (param, req) {
            if (!is_sharp(param[0])) {
              compute_variance_decl(new_env, true, param[1], req);
              return ;
            }
            
          }
          }(new_env)), new_decls, required);
      return /* tuple */[
              new_decls,
              new_env
            ];
    }
  };
}

function init_variance(param) {
  return List.map((function (param) {
                return Types_Variance.$$null;
              }), param[1].type_params);
}

function add_injectivity(param) {
  return List.map((function (param) {
                switch (param) {
                  case /* Covariant */0 :
                      return /* tuple */[
                              true,
                              false,
                              false
                            ];
                  case /* Contravariant */1 :
                      return /* tuple */[
                              false,
                              true,
                              false
                            ];
                  case /* Invariant */2 :
                      return /* tuple */[
                              false,
                              false,
                              false
                            ];
                  
                }
              }), param);
}

function compute_variance_decls(env, cldecls) {
  var match = List.fold_right((function (param, param$1) {
          var ci = param[5];
          var variance = List.map((function (prim) {
                  return prim[1];
                }), ci.ci_params);
          return /* tuple */[
                  /* :: */[
                    /* tuple */[
                      param[0],
                      param[1]
                    ],
                    param$1[0]
                  ],
                  /* :: */[
                    /* tuple */[
                      add_injectivity(variance),
                      ci.ci_loc
                    ],
                    param$1[1]
                  ]
                ];
        }), cldecls, /* tuple */[
        /* [] */0,
        /* [] */0
      ]);
  var decls = match[0];
  var variances = List.map(init_variance, decls);
  var match$1 = compute_variance_fixpoint(env, decls, match[1], variances);
  return List.map2((function (param, param$1) {
                var cltydef = param$1[4];
                var clty = param$1[3];
                var cl_abbr = param$1[2];
                var decl = param[1];
                var variance = decl.type_variance;
                return /* tuple */[
                        decl,
                        {
                          type_params: cl_abbr.type_params,
                          type_arity: cl_abbr.type_arity,
                          type_kind: cl_abbr.type_kind,
                          type_private: cl_abbr.type_private,
                          type_manifest: cl_abbr.type_manifest,
                          type_variance: variance,
                          type_newtype_level: cl_abbr.type_newtype_level,
                          type_loc: cl_abbr.type_loc,
                          type_attributes: cl_abbr.type_attributes
                        },
                        {
                          cty_params: clty.cty_params,
                          cty_type: clty.cty_type,
                          cty_path: clty.cty_path,
                          cty_new: clty.cty_new,
                          cty_variance: variance,
                          cty_loc: clty.cty_loc,
                          cty_attributes: clty.cty_attributes
                        },
                        {
                          clty_params: cltydef.clty_params,
                          clty_type: cltydef.clty_type,
                          clty_path: cltydef.clty_path,
                          clty_variance: variance,
                          clty_loc: cltydef.clty_loc,
                          clty_attributes: cltydef.clty_attributes
                        }
                      ];
              }), match$1[0], cldecls);
}

function check_duplicates(sdecl_list) {
  var labels = Hashtbl.create(void 0, 7);
  var constrs = Hashtbl.create(void 0, 7);
  return List.iter((function (sdecl) {
                var match = sdecl.ptype_kind;
                if (typeof match === "number") {
                  return ;
                } else if (match.tag) {
                  return List.iter((function (param) {
                                var cname = param.pld_name;
                                try {
                                  var name$prime = Hashtbl.find(labels, cname.txt);
                                  return prerr_warning(param.pld_loc, /* Duplicate_definitions */Block.__(14, [
                                                "label",
                                                cname.txt,
                                                name$prime,
                                                sdecl.ptype_name.txt
                                              ]));
                                }
                                catch (exn){
                                  if (exn === Caml_builtin_exceptions.not_found) {
                                    return Hashtbl.add(labels, cname.txt, sdecl.ptype_name.txt);
                                  }
                                  throw exn;
                                }
                              }), match[0]);
                } else {
                  return List.iter((function (pcd) {
                                try {
                                  var name$prime = Hashtbl.find(constrs, pcd.pcd_name.txt);
                                  return prerr_warning(pcd.pcd_loc, /* Duplicate_definitions */Block.__(14, [
                                                "constructor",
                                                pcd.pcd_name.txt,
                                                name$prime,
                                                sdecl.ptype_name.txt
                                              ]));
                                }
                                catch (exn){
                                  if (exn === Caml_builtin_exceptions.not_found) {
                                    return Hashtbl.add(constrs, pcd.pcd_name.txt, sdecl.ptype_name.txt);
                                  }
                                  throw exn;
                                }
                              }), match[0]);
                }
              }), sdecl_list);
}

function name_recursion(sdecl, id, decl) {
  var match = decl.type_kind;
  if (typeof match !== "number") {
    return decl;
  }
  if (match !== 0) {
    return decl;
  }
  if (decl.type_private) {
    return decl;
  }
  var match$1 = decl.type_manifest;
  if (match$1 === void 0) {
    return decl;
  }
  if (!is_fixed_type(sdecl)) {
    return decl;
  }
  var ty = repr(match$1);
  var ty$prime = newty2(ty.level, ty.desc);
  if (!deep_occur(ty, ty$prime)) {
    return decl;
  }
  var td_000 = /* Pident */Block.__(0, [id]);
  var td_001 = decl.type_params;
  var td_002 = {
    contents: /* Mnil */0
  };
  var td = /* Tconstr */Block.__(3, [
      td_000,
      td_001,
      td_002
    ]);
  link_type(ty, newty2(ty.level, td));
  return {
          type_params: decl.type_params,
          type_arity: decl.type_arity,
          type_kind: decl.type_kind,
          type_private: decl.type_private,
          type_manifest: ty$prime,
          type_variance: decl.type_variance,
          type_newtype_level: decl.type_newtype_level,
          type_loc: decl.type_loc,
          type_attributes: decl.type_attributes
        };
}

function transl_type_decl(env, rec_flag, sdecl_list) {
  var fixed_types = List.filter(is_fixed_type)(sdecl_list);
  var sdecl_list$1 = Pervasives.$at(List.map((function (sdecl) {
              var ptype_name_txt = sdecl.ptype_name.txt + "#row";
              var ptype_name_loc = sdecl.ptype_name.loc;
              var ptype_name = {
                txt: ptype_name_txt,
                loc: ptype_name_loc
              };
              return {
                      ptype_name: ptype_name,
                      ptype_params: sdecl.ptype_params,
                      ptype_cstrs: sdecl.ptype_cstrs,
                      ptype_kind: /* Ptype_abstract */0,
                      ptype_private: sdecl.ptype_private,
                      ptype_manifest: void 0,
                      ptype_attributes: sdecl.ptype_attributes,
                      ptype_loc: sdecl.ptype_loc
                    };
            }), fixed_types), sdecl_list);
  var id_list = List.map((function (sdecl) {
          return create(sdecl.ptype_name.txt);
        }), sdecl_list$1);
  init_def(currentstamp.contents);
  begin_def(void 0);
  var temp_env = rec_flag ? List.fold_left2(enter_type$1, env, sdecl_list$1, id_list) : env;
  var current_slot = {
    contents: void 0
  };
  var warn_unused = is_active(/* Unused_type_declaration */Block.__(18, [""]));
  var id_slots = function (id) {
    if (!rec_flag) {
      return /* tuple */[
              id,
              void 0
            ];
    }
    if (!warn_unused) {
      return /* tuple */[
              id,
              void 0
            ];
    }
    var slot = {
      contents: /* [] */0
    };
    var td = find_type_full(/* Pident */Block.__(0, [id]), temp_env)[0];
    var name = id.name;
    set_type_used_callback(name, td, (function (old_callback) {
            var match = current_slot.contents;
            if (match !== void 0) {
              var slot$1 = match;
              slot$1.contents = /* :: */[
                /* tuple */[
                  name,
                  td
                ],
                slot$1.contents
              ];
              return ;
            } else {
              List.iter((function (param) {
                      return mark_type_used(env, param[0], param[1]);
                    }), get_ref(slot));
              return Curry._1(old_callback, void 0);
            }
          }));
    return /* tuple */[
            id,
            slot
          ];
  };
  var transl_declaration = function (name_sdecl, param) {
    current_slot.contents = param[1];
    var id = param[0];
    reset_type_variables(void 0);
    begin_def(void 0);
    var tparams = make_params(temp_env, name_sdecl.ptype_params);
    var params = List.map((function (param) {
            return param[0].ctyp_type;
          }), tparams);
    var cstrs = List.map((function (param) {
            return /* tuple */[
                    transl_simple_type(temp_env, false, param[0]),
                    transl_simple_type(temp_env, false, param[1]),
                    param[2]
                  ];
          }), name_sdecl.ptype_cstrs);
    var match = name_sdecl.ptype_kind;
    var match$1;
    if (typeof match === "number") {
      match$1 = match === /* Ptype_abstract */0 ? /* tuple */[
          /* Ttype_abstract */0,
          /* Type_abstract */0
        ] : /* tuple */[
          /* Ttype_open */1,
          /* Type_open */1
        ];
    } else if (match.tag) {
      var lbls = match[0];
      if (lbls === /* [] */0) {
        ill_formed_ast(name_sdecl.ptype_loc, "Records cannot be empty.");
      }
      var all_labels = {
        contents: /* Empty */0
      };
      List.iter((function (param) {
              var name = param.pld_name.txt;
              if (mem$6(name, all_labels.contents)) {
                throw [
                      $$Error$8,
                      name_sdecl.ptype_loc,
                      /* Duplicate_label */Block.__(1, [name])
                    ];
              }
              all_labels.contents = add$12(name, all_labels.contents);
              
            }), lbls);
      var lbls$1 = List.map((function (param) {
              var name = param.pld_name;
              var arg = force_poly(param.pld_type);
              var cty = transl_simple_type(temp_env, true, arg);
              return {
                      ld_id: create(name.txt),
                      ld_name: name,
                      ld_mutable: param.pld_mutable,
                      ld_type: cty,
                      ld_loc: param.pld_loc,
                      ld_attributes: param.pld_attributes
                    };
            }), lbls);
      var lbls$prime = List.map((function (ld) {
              var ty = ld.ld_type.ctyp_type;
              var match = ty.desc;
              var ty$1;
              ty$1 = typeof match === "number" || !(match.tag === /* Tpoly */10 && !match[1]) ? ty : match[0];
              return {
                      ld_id: ld.ld_id,
                      ld_mutable: ld.ld_mutable,
                      ld_type: ty$1,
                      ld_loc: ld.ld_loc,
                      ld_attributes: ld.ld_attributes
                    };
            }), lbls$1);
      var rep = List.for_all((function (l) {
              var ty = l.ld_type;
              var match = repr(expand_head_opt(temp_env, ty));
              var match$1 = match.desc;
              if (typeof match$1 === "number" || match$1.tag !== /* Tconstr */3) {
                return false;
              } else {
                return same(match$1[0], path_float);
              }
            }), lbls$prime) ? /* Record_float */1 : /* Record_regular */0;
      match$1 = /* tuple */[
        /* Ttype_record */Block.__(1, [lbls$1]),
        /* Type_record */Block.__(0, [
            lbls$prime,
            rep
          ])
      ];
    } else {
      var scstrs = match[0];
      if (scstrs === /* [] */0) {
        ill_formed_ast(name_sdecl.ptype_loc, "Variant types cannot be empty.");
      }
      var all_constrs = {
        contents: /* Empty */0
      };
      List.iter((function (param) {
              var name = param.pcd_name.txt;
              if (mem$6(name, all_constrs.contents)) {
                throw [
                      $$Error$8,
                      name_sdecl.ptype_loc,
                      /* Duplicate_constructor */Block.__(0, [name])
                    ];
              }
              all_constrs.contents = add$12(name, all_constrs.contents);
              
            }), scstrs);
      if (List.length(List.filter((function (cd) {
                      return cd.pcd_args !== /* [] */0;
                    }))(scstrs)) > 246) {
        throw [
              $$Error$8,
              name_sdecl.ptype_loc,
              /* Too_many_constructors */1
            ];
      }
      var make_cstr = function (scstr) {
        var name = create(scstr.pcd_name.txt);
        var match = make_constructor(temp_env, /* Pident */Block.__(0, [id]), params, scstr.pcd_args, scstr.pcd_res);
        var tcstr_cd_name = scstr.pcd_name;
        var tcstr_cd_args = match[0];
        var tcstr_cd_res = match[1];
        var tcstr_cd_loc = scstr.pcd_loc;
        var tcstr_cd_attributes = scstr.pcd_attributes;
        var tcstr = {
          cd_id: name,
          cd_name: tcstr_cd_name,
          cd_args: tcstr_cd_args,
          cd_res: tcstr_cd_res,
          cd_loc: tcstr_cd_loc,
          cd_attributes: tcstr_cd_attributes
        };
        var cstr_cd_args = match[2];
        var cstr_cd_res = match[3];
        var cstr_cd_loc = scstr.pcd_loc;
        var cstr_cd_attributes = scstr.pcd_attributes;
        var cstr = {
          cd_id: name,
          cd_args: cstr_cd_args,
          cd_res: cstr_cd_res,
          cd_loc: cstr_cd_loc,
          cd_attributes: cstr_cd_attributes
        };
        return /* tuple */[
                tcstr,
                cstr
              ];
      };
      var match$2 = List.split(List.map(make_cstr, scstrs));
      match$1 = /* tuple */[
        /* Ttype_variant */Block.__(0, [match$2[0]]),
        /* Type_variant */Block.__(1, [match$2[1]])
      ];
    }
    var match$3 = name_sdecl.ptype_manifest;
    var match$4;
    if (match$3 !== void 0) {
      var no_row = !is_fixed_type(name_sdecl);
      var cty = transl_simple_type(temp_env, no_row, match$3);
      match$4 = /* tuple */[
        cty,
        cty.ctyp_type
      ];
    } else {
      match$4 = /* tuple */[
        void 0,
        void 0
      ];
    }
    var man = match$4[1];
    var decl_type_arity = List.length(params);
    var decl_type_kind = match$1[1];
    var decl_type_private = name_sdecl.ptype_private;
    var decl_type_variance = List.map((function (param) {
            return Types_Variance.full;
          }), params);
    var decl_type_loc = name_sdecl.ptype_loc;
    var decl_type_attributes = name_sdecl.ptype_attributes;
    var decl = {
      type_params: params,
      type_arity: decl_type_arity,
      type_kind: decl_type_kind,
      type_private: decl_type_private,
      type_manifest: man,
      type_variance: decl_type_variance,
      type_newtype_level: void 0,
      type_loc: decl_type_loc,
      type_attributes: decl_type_attributes
    };
    List.iter((function (param) {
            var ty = param[0].ctyp_type;
            var ty$prime = param[1].ctyp_type;
            try {
              return unify$2(temp_env, ty, ty$prime);
            }
            catch (raw_exn){
              var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
              if (exn[0] === Unify) {
                throw [
                      $$Error$8,
                      param[2],
                      /* Inconsistent_constraint */Block.__(6, [
                          temp_env,
                          exn[1]
                        ])
                    ];
              }
              throw exn;
            }
          }), cstrs);
    end_def(void 0);
    if (is_fixed_type(name_sdecl)) {
      var match$5;
      try {
        match$5 = lookup_type$1(/* Lident */Block.__(0, [id.name + "#row"]), temp_env);
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          throw [
                Caml_builtin_exceptions.assert_failure,
                /* tuple */[
                  "typedecl.ml",
                  301,
                  26
                ]
              ];
        }
        throw exn;
      }
      set_fixed_row(temp_env, name_sdecl.ptype_loc, match$5[0], decl);
    }
    if (man !== void 0 && cyclic_abbrev(temp_env, id, man)) {
      throw [
            $$Error$8,
            name_sdecl.ptype_loc,
            /* Recursive_abbrev */Block.__(2, [name_sdecl.ptype_name.txt])
          ];
    }
    return {
            typ_id: id,
            typ_name: name_sdecl.ptype_name,
            typ_params: tparams,
            typ_type: decl,
            typ_cstrs: cstrs,
            typ_kind: match$1[0],
            typ_private: name_sdecl.ptype_private,
            typ_manifest: match$4[0],
            typ_loc: name_sdecl.ptype_loc,
            typ_attributes: name_sdecl.ptype_attributes
          };
  };
  var tdecls = List.map2(transl_declaration, sdecl_list$1, List.map(id_slots, id_list));
  var decls = List.map((function (tdecl) {
          return /* tuple */[
                  tdecl.typ_id,
                  tdecl.typ_type
                ];
        }), tdecls);
  current_slot.contents = void 0;
  check_duplicates(sdecl_list$1);
  var newenv = List.fold_right((function (param, env) {
          return add_type$1(true, param[0], param[1], env);
        }), decls, env);
  if (rec_flag) {
    List.iter2((function (id, sdecl) {
            var loc = sdecl.ptype_loc;
            var path = /* Pident */Block.__(0, [id]);
            var decl = find_type_full(path, temp_env)[0];
            var match = decl.type_manifest;
            if (match === void 0) {
              return ;
            }
            var params = List.map((function (param) {
                    return newvar(void 0, void 0);
                  }), decl.type_params);
            try {
              return unify$2(newenv, newconstr(path, params), match);
            }
            catch (raw_exn){
              var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
              if (exn[0] === Unify) {
                throw [
                      $$Error$8,
                      loc,
                      /* Type_clash */Block.__(7, [
                          newenv,
                          exn[1]
                        ])
                    ];
              }
              throw exn;
            }
          }), id_list, sdecl_list$1);
  }
  end_def(void 0);
  List.iter((function (param) {
          return generalize_decl(param[1]);
        }), decls);
  var id_loc_list = List.map2((function (id, sdecl) {
          return /* tuple */[
                  id,
                  sdecl.ptype_loc
                ];
        }), id_list, sdecl_list$1);
  List.iter((function (param) {
          var id = param[0];
          var loc = List.assoc(id, id_loc_list);
          var path = /* Pident */Block.__(0, [id]);
          var decl = param[1];
          if (decl.type_manifest === void 0) {
            return ;
          }
          var args = List.map((function (param) {
                  return newvar(void 0, void 0);
                }), decl.type_params);
          return check_well_founded(newenv, loc, path, (function (param) {
                        return same(path, param);
                      }), newconstr(path, args));
        }), decls);
  var to_check = function (param) {
    switch (param.tag | 0) {
      case /* Pident */0 :
          return List.mem_assoc(param[0], id_loc_list);
      case /* Pdot */1 :
      case /* Papply */2 :
          return false;
      
    }
  };
  List.iter((function (param) {
          var id = param[0];
          return check_well_founded_decl(newenv, List.assoc(id, id_loc_list), /* Pident */Block.__(0, [id]), param[1], to_check);
        }), decls);
  List.iter((function (param) {
          var decl = param.typ_type;
          var id = param.typ_id;
          return check_recursion(newenv, List.assoc(id, id_loc_list), /* Pident */Block.__(0, [id]), decl, to_check);
        }), tdecls);
  List.iter2((function (sdecl, tdecl) {
          var decl = tdecl.typ_type;
          var match = closed_type_decl(decl);
          if (match !== void 0) {
            throw [
                  $$Error$8,
                  sdecl.ptype_loc,
                  /* Unbound_type_var */Block.__(9, [
                      match,
                      decl
                    ])
                ];
          }
          
        }), sdecl_list$1, tdecls);
  List.iter2((function (param, param$1) {
          var decl = param$1[1];
          var visited = {
            contents: /* Empty */0
          };
          var match = decl.type_kind;
          if (typeof match === "number") {
            match === /* Type_abstract */0;
          } else if (match.tag) {
            var find_pl = function (param) {
              if (typeof param === "number") {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      /* tuple */[
                        "typedecl.ml",
                        382,
                        58
                      ]
                    ];
              }
              if (param.tag) {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      /* tuple */[
                        "typedecl.ml",
                        382,
                        58
                      ]
                    ];
              }
              return param[0];
            };
            var pl = find_pl(param.ptype_kind);
            var foldf = function (acc, x) {
              return add$13(x.pcd_name.txt, x, acc);
            };
            var pl_index = List.fold_left(foldf, /* Empty */0, pl);
            List.iter((function (param) {
                    var ret_type = param.cd_res;
                    var match;
                    try {
                      match = find$6(param.cd_id.name, pl_index);
                    }
                    catch (exn){
                      if (exn === Caml_builtin_exceptions.not_found) {
                        throw [
                              Caml_builtin_exceptions.assert_failure,
                              /* tuple */[
                                "typedecl.ml",
                                395,
                                30
                              ]
                            ];
                      }
                      throw exn;
                    }
                    var sret_type = match.pcd_res;
                    List.iter2((function (sty, ty) {
                            return check_constraints_rec(newenv, sty.ptyp_loc, visited, ty);
                          }), match.pcd_args, param.cd_args);
                    if (sret_type !== void 0 && ret_type !== void 0) {
                      return check_constraints_rec(newenv, sret_type.ptyp_loc, visited, ret_type);
                    }
                    
                  }), match[0]);
          } else {
            var find_pl$1 = function (param) {
              if (typeof param === "number") {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      /* tuple */[
                        "typedecl.ml",
                        409,
                        59
                      ]
                    ];
              }
              if (param.tag === /* Ptype_record */1) {
                return param[0];
              }
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    /* tuple */[
                      "typedecl.ml",
                      409,
                      59
                    ]
                  ];
            };
            var pl$1 = find_pl$1(param.ptype_kind);
            var get_loc = function (name, _param) {
              while(true) {
                var param = _param;
                if (!param) {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        /* tuple */[
                          "typedecl.ml",
                          413,
                          16
                        ]
                      ];
                }
                var pld = param[0];
                if (name === pld.pld_name.txt) {
                  return pld.pld_type.ptyp_loc;
                }
                _param = param[1];
                continue ;
              };
            };
            List.iter((function (param) {
                    return check_constraints_rec(newenv, get_loc(param.ld_id.name, pl$1), visited, param.ld_type);
                  }), match[0]);
          }
          var match$1 = decl.type_manifest;
          if (match$1 === void 0) {
            return ;
          }
          var match$2 = param.ptype_manifest;
          var sty;
          if (match$2 === void 0) {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  /* tuple */[
                    "typedecl.ml",
                    428,
                    63
                  ]
                ];
          }
          sty = match$2;
          return check_constraints_rec(newenv, sty.ptyp_loc, visited, match$1);
        }), sdecl_list$1, decls);
  var decls$1 = List.map2((function (sdecl, param) {
          var id = param[0];
          return /* tuple */[
                  id,
                  name_recursion(sdecl, id, param[1])
                ];
        }), sdecl_list$1, decls);
  var required = List.map((function (sdecl) {
          return /* tuple */[
                  add_injectivity(List.map((function (prim) {
                              return prim[1];
                            }), sdecl.ptype_params)),
                  sdecl.ptype_loc
                ];
        }), sdecl_list$1);
  var match = compute_variance_fixpoint(env, decls$1, required, List.map(init_variance, decls$1));
  var final_env = match[1];
  var final_decls = match[0];
  List.iter2((function (param, param$1) {
          return check_coherence(final_env, param.ptype_loc, param$1[0], param$1[1]);
        }), sdecl_list$1, final_decls);
  var final_decls$1 = List.map2((function (tdecl, param) {
          return {
                  typ_id: tdecl.typ_id,
                  typ_name: tdecl.typ_name,
                  typ_params: tdecl.typ_params,
                  typ_type: param[1],
                  typ_cstrs: tdecl.typ_cstrs,
                  typ_kind: tdecl.typ_kind,
                  typ_private: tdecl.typ_private,
                  typ_manifest: tdecl.typ_manifest,
                  typ_loc: tdecl.typ_loc,
                  typ_attributes: tdecl.typ_attributes
                };
        }), tdecls, final_decls);
  return /* tuple */[
          final_decls$1,
          final_env
        ];
}

function transl_extension_constructor(env, check_open, type_path, type_params, typext_params, priv, sext) {
  var id = create(sext.pext_name.txt);
  var match = sext.pext_kind;
  var match$1;
  if (match.tag) {
    var lid = match[0];
    var cdescr = find_constructor(env, sext.pext_loc, lid.txt);
    var usage = cdescr.cstr_private === /* Private */0 || priv === /* Public */1 ? /* Positive */0 : /* Privatize */2;
    mark_constructor(usage, env, last$1(lid.txt), cdescr);
    var match$2 = instance_constructor(void 0, cdescr);
    var args = match$2[0];
    var match$3;
    if (cdescr.cstr_generalized) {
      var params = instance_list(env, type_params);
      var res = newconstr(type_path, params);
      var ret_type = newconstr(type_path, params);
      match$3 = /* tuple */[
        res,
        ret_type
      ];
    } else {
      match$3 = /* tuple */[
        newconstr(type_path, typext_params),
        void 0
      ];
    }
    try {
      unify$2(env, match$2[1], match$3[0]);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn[0] === Unify) {
        throw [
              $$Error$8,
              lid.loc,
              /* Rebind_wrong_type */Block.__(13, [
                  lid.txt,
                  env,
                  exn[1]
                ])
            ];
      }
      throw exn;
    }
    if (!cdescr.cstr_generalized) {
      var vars = free_variables$1(void 0, newty2(100000000, /* Ttuple */Block.__(2, [args])));
      List.iter((function (ty) {
              var match = ty.desc;
              if (typeof match === "number") {
                return ;
              }
              if (match.tag) {
                return ;
              }
              var match$1 = match[0];
              if (match$1 !== void 0 && match$1 === "_" && List.memq(ty, vars)) {
                ty.desc = /* Tvar */Block.__(0, [void 0]);
                return ;
              }
              
            }), typext_params);
    }
    var match$4 = cdescr.cstr_res.desc;
    var match$5;
    if (typeof match$4 === "number") {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "typedecl.ml",
              1162,
              17
            ]
          ];
    }
    if (match$4.tag !== /* Tconstr */3) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "typedecl.ml",
              1162,
              17
            ]
          ];
    }
    var p = match$4[0];
    var decl = find_type_full(p, env)[0];
    match$5 = /* tuple */[
      p,
      decl.type_params
    ];
    var cstr_type_params = match$5[1];
    var cstr_type_path = match$5[0];
    var cstr_types_000 = newty2(100000000, /* Tconstr */Block.__(3, [
            cstr_type_path,
            cstr_type_params,
            {
              contents: /* Mnil */0
            }
          ]));
    var cstr_types = /* :: */[
      cstr_types_000,
      cstr_type_params
    ];
    var ext_types_000 = newty2(100000000, /* Tconstr */Block.__(3, [
            type_path,
            type_params,
            {
              contents: /* Mnil */0
            }
          ]));
    var ext_types = /* :: */[
      ext_types_000,
      type_params
    ];
    if (!equal$4(env, true, cstr_types, ext_types)) {
      throw [
            $$Error$8,
            lid.loc,
            /* Rebind_mismatch */Block.__(14, [
                lid.txt,
                cstr_type_path,
                type_path
              ])
          ];
    }
    var match$6 = cdescr.cstr_private;
    if (!match$6 && priv) {
      throw [
            $$Error$8,
            lid.loc,
            /* Rebind_private */Block.__(15, [lid.txt])
          ];
    }
    var match$7 = cdescr.cstr_tag;
    var path;
    switch (match$7.tag | 0) {
      case /* Cstr_constant */0 :
      case /* Cstr_block */1 :
          throw [
                Caml_builtin_exceptions.assert_failure,
                /* tuple */[
                  "typedecl.ml",
                  1187,
                  17
                ]
              ];
      case /* Cstr_extension */2 :
          path = match$7[0];
          break;
      
    }
    match$1 = /* tuple */[
      args,
      match$3[1],
      /* Text_rebind */Block.__(1, [
          path,
          lid
        ])
    ];
  } else {
    var match$8 = make_constructor(env, type_path, typext_params, match[0], match[1]);
    match$1 = /* tuple */[
      match$8[2],
      match$8[3],
      /* Text_decl */Block.__(0, [
          match$8[0],
          match$8[1]
        ])
    ];
  }
  var ext_ext_args = match$1[0];
  var ext_ext_ret_type = match$1[1];
  var ext_ext_loc = sext.pext_loc;
  var ext_ext_attributes = sext.pext_attributes;
  var ext = {
    ext_type_path: type_path,
    ext_type_params: typext_params,
    ext_args: ext_ext_args,
    ext_ret_type: ext_ext_ret_type,
    ext_private: priv,
    ext_loc: ext_ext_loc,
    ext_attributes: ext_ext_attributes
  };
  return {
          ext_id: id,
          ext_name: sext.pext_name,
          ext_type: ext,
          ext_kind: match$1[2],
          ext_loc: sext.pext_loc,
          ext_attributes: sext.pext_attributes
        };
}

function transl_type_extension(check_open, env, loc, styext) {
  reset_type_variables(void 0);
  begin_def(void 0);
  var match = find_type(env, loc, styext.ptyext_path.txt);
  var type_decl = match[1];
  var type_path = match[0];
  var match$1 = type_decl.type_kind;
  if (typeof match$1 !== "number") {
    throw [
          $$Error$8,
          loc,
          /* Not_extensible_type */Block.__(11, [type_path])
        ];
  }
  if (match$1 === 0 && check_open) {
    try {
      var match$2 = List.find((function (param) {
              if (param.pext_kind.tag) {
                return false;
              } else {
                return true;
              }
            }), styext.ptyext_constructors);
      throw [
            $$Error$8,
            match$2.pext_loc,
            /* Not_open_type */Block.__(10, [type_path])
          ];
    }
    catch (exn){
      if (exn !== Caml_builtin_exceptions.not_found) {
        throw exn;
      }
      
    }
  }
  var type_variance = List.map((function (v) {
          var match = Curry._1(Types_Variance.get_upper, v);
          return /* tuple */[
                  !match[1],
                  !match[0],
                  false
                ];
        }), type_decl.type_variance);
  var err = type_decl.type_arity !== List.length(styext.ptyext_params) ? /* :: */[
      /* Arity */0,
      /* [] */0
    ] : (
      List.for_all2((function (param, param$1) {
              if (!param$1[0] || param[0]) {
                if (param$1[1]) {
                  return param[1];
                } else {
                  return true;
                }
              } else {
                return false;
              }
            }), type_variance, add_injectivity(List.map((function (prim) {
                      return prim[1];
                    }), styext.ptyext_params))) ? /* [] */0 : /* :: */[
          /* Variance */5,
          /* [] */0
        ]
    );
  if (err !== /* [] */0) {
    throw [
          $$Error$8,
          loc,
          /* Extension_mismatch */Block.__(12, [
              type_path,
              err
            ])
        ];
  }
  var ttype_params = make_params(env, styext.ptyext_params);
  var type_params = List.map((function (param) {
          return param[0].ctyp_type;
        }), ttype_params);
  List.iter2((function (param, param$1) {
          return unify_var(env, param, param$1);
        }), instance_list(env, type_decl.type_params), type_params);
  var partial_arg = styext.ptyext_private;
  var partial_arg$1 = type_decl.type_params;
  var constructors = List.map((function (param) {
          return transl_extension_constructor(env, check_open, type_path, partial_arg$1, type_params, partial_arg, param);
        }), styext.ptyext_constructors);
  end_def(void 0);
  List.iter(generalize, type_params);
  List.iter((function (ext) {
          List.iter(generalize, ext.ext_type.ext_args);
          return may(generalize, ext.ext_type.ext_ret_type);
        }), constructors);
  List.iter((function (ext) {
          var match = closed_extension_constructor(ext.ext_type);
          if (match !== void 0) {
            throw [
                  $$Error$8,
                  ext.ext_loc,
                  /* Unbound_type_var_ext */Block.__(19, [
                      match,
                      ext.ext_type
                    ])
                ];
          }
          
        }), constructors);
  List.iter((function (ext) {
          compute_variance_extension(env, true, type_decl, ext.ext_type, /* tuple */[
                type_variance,
                loc
              ]);
          
        }), constructors);
  var newenv = List.fold_left((function (env, ext) {
          return add_extension(true, ext.ext_id, ext.ext_type, env);
        }), env, constructors);
  var tyext_tyext_txt = styext.ptyext_path;
  var tyext_tyext_private = styext.ptyext_private;
  var tyext_tyext_attributes = styext.ptyext_attributes;
  var tyext = {
    tyext_path: type_path,
    tyext_txt: tyext_tyext_txt,
    tyext_params: ttype_params,
    tyext_constructors: constructors,
    tyext_private: tyext_tyext_private,
    tyext_attributes: tyext_tyext_attributes
  };
  return /* tuple */[
          tyext,
          newenv
        ];
}

function transl_exception(env, sext) {
  reset_type_variables(void 0);
  begin_def(void 0);
  var ext = transl_extension_constructor(env, false, path_exn, /* [] */0, /* [] */0, /* Public */1, sext);
  end_def(void 0);
  List.iter(generalize, ext.ext_type.ext_args);
  may(generalize, ext.ext_type.ext_ret_type);
  var match = closed_extension_constructor(ext.ext_type);
  if (match !== void 0) {
    throw [
          $$Error$8,
          ext.ext_loc,
          /* Unbound_type_var_ext */Block.__(19, [
              match,
              ext.ext_type
            ])
        ];
  }
  var newenv = add_extension(true, ext.ext_id, ext.ext_type, env);
  return /* tuple */[
          ext,
          newenv
        ];
}

function customize_arity(arity, pval_attributes) {
  var cur_arity = {
    contents: arity
  };
  List.iter((function (x) {
          if (x[0].txt !== "internal.arity") {
            return ;
          }
          var match = x[1];
          switch (match.tag | 0) {
            case /* PStr */0 :
                var match$1 = match[0];
                if (!match$1) {
                  return ;
                }
                var match$2 = match$1[0].pstr_desc;
                if (match$2.tag) {
                  return ;
                }
                var match$3 = match$2[0].pexp_desc;
                if (match$3.tag !== /* Pexp_constant */1) {
                  return ;
                }
                var match$4 = match$3[0];
                if (match$4.tag) {
                  return ;
                }
                if (match$1[1]) {
                  return ;
                }
                var i = match$4[0];
                if (i < cur_arity.contents) {
                  cur_arity.contents = i;
                  return ;
                } else {
                  return ;
                }
            case /* PTyp */1 :
            case /* PPat */2 :
                return ;
            
          }
        }), pval_attributes);
  return cur_arity.contents;
}

function transl_value_decl(env, loc, valdecl) {
  var cty = transl_type_scheme(env, valdecl.pval_type);
  var ty = cty.ctyp_type;
  var decl = valdecl.pval_prim;
  var v;
  if (decl) {
    var arity$1 = customize_arity(arity(ty), valdecl.pval_attributes);
    var prim = parse_declaration(arity$1, decl);
    var prim_native_name = prim.prim_native_name;
    if (arity$1 === 0 && !(prim_native_name.length > 3 && prim_native_name[0] === "B" && prim_native_name[1] === "S" && prim_native_name[2] === ":") && (prim.prim_name.length === 0 || Caml_string.get(prim.prim_name, 0) !== /* "%" */37 && Caml_string.get(prim.prim_name, 0) !== /* "#" */35)) {
      throw [
            $$Error$8,
            valdecl.pval_type.ptyp_loc,
            /* Null_arity_external */2
          ];
    }
    if (native_code.contents && prim.prim_arity > 5 && prim_native_name === "") {
      throw [
            $$Error$8,
            valdecl.pval_type.ptyp_loc,
            /* Missing_native_external */3
          ];
    }
    v = {
      val_type: ty,
      val_kind: /* Val_prim */Block.__(0, [prim]),
      val_loc: loc,
      val_attributes: valdecl.pval_attributes
    };
  } else {
    v = {
      val_type: ty,
      val_kind: /* Val_reg */0,
      val_loc: loc,
      val_attributes: valdecl.pval_attributes
    };
  }
  var match = enter_value((function (s) {
            return /* Unused_value_declaration */Block.__(16, [s]);
          }))(valdecl.pval_name.txt, v, env);
  var desc_val_id = match[0];
  var desc_val_name = valdecl.pval_name;
  var desc_val_prim = valdecl.pval_prim;
  var desc_val_loc = valdecl.pval_loc;
  var desc_val_attributes = valdecl.pval_attributes;
  var desc = {
    val_id: desc_val_id,
    val_name: desc_val_name,
    val_desc: cty,
    val_val: v,
    val_prim: desc_val_prim,
    val_loc: desc_val_loc,
    val_attributes: desc_val_attributes
  };
  return /* tuple */[
          desc,
          match[1]
        ];
}

function transl_with_constraint(env, id, row_path, orig_decl, sdecl) {
  mark_type_used(env, id.name, orig_decl);
  reset_type_variables(void 0);
  begin_def(void 0);
  var tparams = make_params(env, sdecl.ptype_params);
  var params = List.map((function (param) {
          return param[0].ctyp_type;
        }), tparams);
  var orig_decl$1 = instance_declaration(orig_decl);
  var arity_ok = List.length(params) === orig_decl$1.type_arity;
  if (arity_ok) {
    List.iter2((function (param, param$1) {
            return unify_var(env, param, param$1);
          }), params, orig_decl$1.type_params);
  }
  var constraints = List.map((function (param) {
          var loc = param[2];
          try {
            var cty = transl_simple_type(env, false, param[0]);
            var cty$prime = transl_simple_type(env, false, param[1]);
            var ty = cty.ctyp_type;
            var ty$prime = cty$prime.ctyp_type;
            unify$2(env, ty, ty$prime);
            return /* tuple */[
                    cty,
                    cty$prime,
                    loc
                  ];
          }
          catch (raw_exn){
            var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn[0] === Unify) {
              throw [
                    $$Error$8,
                    loc,
                    /* Inconsistent_constraint */Block.__(6, [
                        env,
                        exn[1]
                      ])
                  ];
            }
            throw exn;
          }
        }), sdecl.ptype_cstrs);
  var no_row = !is_fixed_type(sdecl);
  var match = sdecl.ptype_manifest;
  var match$1;
  if (match !== void 0) {
    var cty = transl_simple_type(env, no_row, match);
    match$1 = /* tuple */[
      cty,
      cty.ctyp_type
    ];
  } else {
    match$1 = /* tuple */[
      void 0,
      void 0
    ];
  }
  var man = match$1[1];
  var priv = sdecl.ptype_private === /* Private */0 ? /* Private */0 : (
      arity_ok && orig_decl$1.type_kind !== /* Type_abstract */0 ? orig_decl$1.type_private : sdecl.ptype_private
    );
  if (arity_ok && orig_decl$1.type_kind !== /* Type_abstract */0 && sdecl.ptype_private === /* Private */0) {
    prerr_warning(sdecl.ptype_loc, /* Deprecated */Block.__(0, ["spurious use of private"]));
  }
  var decl_type_arity = List.length(params);
  var decl_type_kind = arity_ok && man !== void 0 ? orig_decl$1.type_kind : /* Type_abstract */0;
  var decl_type_loc = sdecl.ptype_loc;
  var decl_type_attributes = sdecl.ptype_attributes;
  var decl = {
    type_params: params,
    type_arity: decl_type_arity,
    type_kind: decl_type_kind,
    type_private: priv,
    type_manifest: man,
    type_variance: /* [] */0,
    type_newtype_level: void 0,
    type_loc: decl_type_loc,
    type_attributes: decl_type_attributes
  };
  if (row_path !== void 0) {
    set_fixed_row(env, sdecl.ptype_loc, row_path, decl);
  }
  var match$2 = closed_type_decl(decl);
  if (match$2 !== void 0) {
    throw [
          $$Error$8,
          sdecl.ptype_loc,
          /* Unbound_type_var */Block.__(9, [
              match$2,
              decl
            ])
        ];
  }
  var decl$1 = name_recursion(sdecl, id, decl);
  var decl_type_params = decl$1.type_params;
  var decl_type_arity$1 = decl$1.type_arity;
  var decl_type_kind$1 = decl$1.type_kind;
  var decl_type_private = decl$1.type_private;
  var decl_type_manifest = decl$1.type_manifest;
  var decl_type_variance = compute_variance_decl(env, false, decl$1, /* tuple */[
        add_injectivity(List.map((function (prim) {
                    return prim[1];
                  }), sdecl.ptype_params)),
        sdecl.ptype_loc
      ]);
  var decl_type_newtype_level = decl$1.type_newtype_level;
  var decl_type_loc$1 = decl$1.type_loc;
  var decl_type_attributes$1 = decl$1.type_attributes;
  var decl$2 = {
    type_params: decl_type_params,
    type_arity: decl_type_arity$1,
    type_kind: decl_type_kind$1,
    type_private: decl_type_private,
    type_manifest: decl_type_manifest,
    type_variance: decl_type_variance,
    type_newtype_level: decl_type_newtype_level,
    type_loc: decl_type_loc$1,
    type_attributes: decl_type_attributes$1
  };
  end_def(void 0);
  generalize_decl(decl$2);
  return {
          typ_id: id,
          typ_name: sdecl.ptype_name,
          typ_params: tparams,
          typ_type: decl$2,
          typ_cstrs: constraints,
          typ_kind: /* Ttype_abstract */0,
          typ_private: sdecl.ptype_private,
          typ_manifest: match$1[0],
          typ_loc: sdecl.ptype_loc,
          typ_attributes: sdecl.ptype_attributes
        };
}

function abstract_type_decl(arity) {
  var make_params = function (n) {
    if (n <= 0) {
      return /* [] */0;
    } else {
      return /* :: */[
              newvar(void 0, void 0),
              make_params(n - 1 | 0)
            ];
    }
  };
  begin_def(void 0);
  var decl_type_params = make_params(arity);
  var decl_type_variance = replicate_list(Types_Variance.full, arity);
  var decl = {
    type_params: decl_type_params,
    type_arity: arity,
    type_kind: /* Type_abstract */0,
    type_private: /* Public */1,
    type_manifest: void 0,
    type_variance: decl_type_variance,
    type_newtype_level: void 0,
    type_loc: none,
    type_attributes: /* [] */0
  };
  end_def(void 0);
  generalize_decl(decl);
  return decl;
}

function approx_type_decl(env, sdecl_list) {
  return List.map((function (sdecl) {
                return /* tuple */[
                        create(sdecl.ptype_name.txt),
                        abstract_type_decl(List.length(sdecl.ptype_params))
                      ];
              }), sdecl_list);
}

function explain_unbound(ppf, tv, tl, typ, kwd, lab) {
  try {
    var ti = List.find((function (ti) {
            return deep_occur(tv, Curry._1(typ, ti));
          }), tl);
    var ty0 = newty2(100000000, /* Tobject */Block.__(4, [
            tv,
            {
              contents: void 0
            }
          ]));
    reset_and_mark_loops_list(/* :: */[
          Curry._1(typ, ti),
          /* :: */[
            ty0,
            /* [] */0
          ]
        ]);
    return Curry._6(Format.fprintf(ppf, /* Format */[
                    /* Char_literal */Block.__(12, [
                        /* "." */46,
                        /* Formatting_lit */Block.__(17, [
                            /* Flush_newline */4,
                            /* Formatting_gen */Block.__(18, [
                                /* Open_box */Block.__(1, [/* Format */[
                                      /* String_literal */Block.__(11, [
                                          "<hov2>",
                                          /* End_of_format */0
                                        ]),
                                      "<hov2>"
                                    ]]),
                                /* String_literal */Block.__(11, [
                                    "In ",
                                    /* String */Block.__(2, [
                                        /* No_padding */0,
                                        /* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@ ",
                                                1,
                                                0
                                              ]),
                                            /* String */Block.__(2, [
                                                /* No_padding */0,
                                                /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                        /* Break */Block.__(0, [
                                                            "@;<1 -2>",
                                                            1,
                                                            -2
                                                          ]),
                                                        /* String_literal */Block.__(11, [
                                                            "the variable ",
                                                            /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                                                    " is unbound",
                                                                    /* Formatting_lit */Block.__(17, [
                                                                        /* Close_box */0,
                                                                        /* End_of_format */0
                                                                      ])
                                                                  ])])
                                                          ])
                                                      ])])
                                              ])
                                          ])
                                      ])
                                  ])
                              ])
                          ])
                      ]),
                    ".@.@[<hov2>In %s@ %s%a@;<1 -2>the variable %a is unbound@]"
                  ]), kwd, Curry._1(lab, ti), type_expr$1, Curry._1(typ, ti), type_expr$1, tv);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return ;
    }
    throw exn;
  }
}

function report_error$5(ppf, param) {
  if (typeof param === "number") {
    switch (param) {
      case /* Repeated_parameter */0 :
          return Format.fprintf(ppf, /* Format */[
                      /* String_literal */Block.__(11, [
                          "A type parameter occurs several times",
                          /* End_of_format */0
                        ]),
                      "A type parameter occurs several times"
                    ]);
      case /* Too_many_constructors */1 :
          return Curry._2(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* End_of_format */0,
                                    ""
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "Too many non-constant constructors",
                                  /* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@ ",
                                          1,
                                          0
                                        ]),
                                      /* String_literal */Block.__(11, [
                                          "-- maximum is ",
                                          /* Int */Block.__(4, [
                                              /* Int_i */3,
                                              /* No_padding */0,
                                              /* No_precision */0,
                                              /* Char_literal */Block.__(12, [
                                                  /* " " */32,
                                                  /* String */Block.__(2, [
                                                      /* No_padding */0,
                                                      /* Formatting_lit */Block.__(17, [
                                                          /* Close_box */0,
                                                          /* End_of_format */0
                                                        ])
                                                    ])
                                                ])
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "@[Too many non-constant constructors@ -- maximum is %i %s@]"
                        ]), 246, "non-constant constructors");
      case /* Null_arity_external */2 :
          return Format.fprintf(ppf, /* Format */[
                      /* String_literal */Block.__(11, [
                          "External identifiers must be functions",
                          /* End_of_format */0
                        ]),
                      "External identifiers must be functions"
                    ]);
      case /* Missing_native_external */3 :
          return Format.fprintf(ppf, /* Format */[
                      /* Formatting_gen */Block.__(18, [
                          /* Open_box */Block.__(1, [/* Format */[
                                /* String_literal */Block.__(11, [
                                    "<hv>",
                                    /* End_of_format */0
                                  ]),
                                "<hv>"
                              ]]),
                          /* String_literal */Block.__(11, [
                              "An external function with more than 5 arguments requires a second stub function",
                              /* Formatting_lit */Block.__(17, [
                                  /* Break */Block.__(0, [
                                      "@ ",
                                      1,
                                      0
                                    ]),
                                  /* String_literal */Block.__(11, [
                                      "for native-code compilation",
                                      /* Formatting_lit */Block.__(17, [
                                          /* Close_box */0,
                                          /* End_of_format */0
                                        ])
                                    ])
                                ])
                            ])
                        ]),
                      "@[<hv>An external function with more than 5 arguments requires a second stub function@ for native-code compilation@]"
                    ]);
      case /* Varying_anonymous */4 :
          return Curry._3(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* End_of_format */0,
                                    ""
                                  ]]),
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@ ",
                                          1,
                                          0
                                        ]),
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* Formatting_lit */Block.__(17, [
                                              /* Break */Block.__(0, [
                                                  "@ ",
                                                  1,
                                                  0
                                                ]),
                                              /* String */Block.__(2, [
                                                  /* No_padding */0,
                                                  /* Formatting_lit */Block.__(17, [
                                                      /* Close_box */0,
                                                      /* End_of_format */0
                                                    ])
                                                ])
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "@[%s@ %s@ %s@]"
                        ]), "In this GADT definition,", "the variance of some parameter", "cannot be checked");
      
    }
  } else {
    switch (param.tag | 0) {
      case /* Duplicate_constructor */0 :
          return Curry._1(Format.fprintf(ppf, /* Format */[
                          /* String_literal */Block.__(11, [
                              "Two constructors are named ",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* End_of_format */0
                                ])
                            ]),
                          "Two constructors are named %s"
                        ]), param[0]);
      case /* Duplicate_label */1 :
          return Curry._1(Format.fprintf(ppf, /* Format */[
                          /* String_literal */Block.__(11, [
                              "Two labels are named ",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* End_of_format */0
                                ])
                            ]),
                          "Two labels are named %s"
                        ]), param[0]);
      case /* Recursive_abbrev */2 :
          return Curry._1(Format.fprintf(ppf, /* Format */[
                          /* String_literal */Block.__(11, [
                              "The type abbreviation ",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* String_literal */Block.__(11, [
                                      " is cyclic",
                                      /* End_of_format */0
                                    ])
                                ])
                            ]),
                          "The type abbreviation %s is cyclic"
                        ]), param[0]);
      case /* Cycle_in_def */3 :
          var ty = param[1];
          reset(void 0);
          mark_loops(ty);
          return Curry._3(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<v>",
                                        /* End_of_format */0
                                      ]),
                                    "<v>"
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "The definition of ",
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* String_literal */Block.__(11, [
                                          " contains a cycle:",
                                          /* Formatting_lit */Block.__(17, [
                                              /* Break */Block.__(0, [
                                                  "@ ",
                                                  1,
                                                  0
                                                ]),
                                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                      /* Close_box */0,
                                                      /* End_of_format */0
                                                    ])])
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "@[<v>The definition of %s contains a cycle:@ %a@]"
                        ]), param[0], type_expr$1, ty);
      case /* Definition_mismatch */4 :
          var ty$1 = param[0];
          reset(void 0);
          mark_loops(ty$1);
          return Curry._6(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<v>",
                                        /* End_of_format */0
                                      ]),
                                    "<v>"
                                  ]]),
                              /* Formatting_gen */Block.__(18, [
                                  /* Open_box */Block.__(1, [/* Format */[
                                        /* String_literal */Block.__(11, [
                                            "<hov>",
                                            /* End_of_format */0
                                          ]),
                                        "<hov>"
                                      ]]),
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* Formatting_lit */Block.__(17, [
                                          /* Break */Block.__(0, [
                                              "@ ",
                                              1,
                                              0
                                            ]),
                                          /* String */Block.__(2, [
                                              /* No_padding */0,
                                              /* Formatting_lit */Block.__(17, [
                                                  /* Break */Block.__(0, [
                                                      "@;<1 2>",
                                                      1,
                                                      2
                                                    ]),
                                                  /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                          /* Close_box */0,
                                                          /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                  /* Close_box */0,
                                                                  /* End_of_format */0
                                                                ])])
                                                        ])])
                                                ])
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "@[<v>@[<hov>%s@ %s@;<1 2>%a@]%a@]"
                        ]), "This variant or record definition", "does not match that of type", type_expr$1, ty$1, (function (param) {
                        return report_type_mismatch("the original", "this", "definition", param);
                      }), param[1]);
      case /* Constraint_failed */5 :
          var ty$prime = param[1];
          var ty$2 = param[0];
          reset(void 0);
          mark_loops(ty$2);
          mark_loops(ty$prime);
          return Curry._5(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* End_of_format */0,
                                    ""
                                  ]]),
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@ ",
                                          1,
                                          0
                                        ]),
                                      /* Formatting_gen */Block.__(18, [
                                          /* Open_box */Block.__(1, [/* Format */[
                                                /* String_literal */Block.__(11, [
                                                    "<hv>",
                                                    /* End_of_format */0
                                                  ]),
                                                "<hv>"
                                              ]]),
                                          /* String_literal */Block.__(11, [
                                              "Type",
                                              /* Formatting_lit */Block.__(17, [
                                                  /* Break */Block.__(0, [
                                                      "@ ",
                                                      1,
                                                      0
                                                    ]),
                                                  /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                          /* Break */Block.__(0, [
                                                              "@ ",
                                                              1,
                                                              0
                                                            ]),
                                                          /* String_literal */Block.__(11, [
                                                              "should be an instance of",
                                                              /* Formatting_lit */Block.__(17, [
                                                                  /* Break */Block.__(0, [
                                                                      "@ ",
                                                                      1,
                                                                      0
                                                                    ]),
                                                                  /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                          /* Close_box */0,
                                                                          /* Formatting_lit */Block.__(17, [
                                                                              /* Close_box */0,
                                                                              /* End_of_format */0
                                                                            ])
                                                                        ])])
                                                                ])
                                                            ])
                                                        ])])
                                                ])
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "@[%s@ @[<hv>Type@ %a@ should be an instance of@ %a@]@]"
                        ]), "Constraints are not satisfied in this type.", type_expr$1, ty$2, type_expr$1, ty$prime);
      case /* Inconsistent_constraint */6 :
          Format.fprintf(ppf, /* Format */[
                /* String_literal */Block.__(11, [
                    "The type constraints are not consistent.",
                    /* Formatting_lit */Block.__(17, [
                        /* Flush_newline */4,
                        /* End_of_format */0
                      ])
                  ]),
                "The type constraints are not consistent.@."
              ]);
          return report_unification_error(ppf, param[0], void 0, param[1], (function (ppf) {
                        return Format.fprintf(ppf, /* Format */[
                                    /* String_literal */Block.__(11, [
                                        "Type",
                                        /* End_of_format */0
                                      ]),
                                    "Type"
                                  ]);
                      }), (function (ppf) {
                        return Format.fprintf(ppf, /* Format */[
                                    /* String_literal */Block.__(11, [
                                        "is not compatible with type",
                                        /* End_of_format */0
                                      ]),
                                    "is not compatible with type"
                                  ]);
                      }));
      case /* Type_clash */7 :
          return report_unification_error(ppf, param[0], void 0, param[1], (function (ppf) {
                        return Format.fprintf(ppf, /* Format */[
                                    /* String_literal */Block.__(11, [
                                        "This type constructor expands to type",
                                        /* End_of_format */0
                                      ]),
                                    "This type constructor expands to type"
                                  ]);
                      }), (function (ppf) {
                        return Format.fprintf(ppf, /* Format */[
                                    /* String_literal */Block.__(11, [
                                        "but is used here with type",
                                        /* End_of_format */0
                                      ]),
                                    "but is used here with type"
                                  ]);
                      }));
      case /* Parameters_differ */8 :
          var ty$prime$1 = param[2];
          var ty$3 = param[1];
          reset(void 0);
          mark_loops(ty$3);
          mark_loops(ty$prime$1);
          return Curry._5(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<hv>",
                                        /* End_of_format */0
                                      ]),
                                    "<hv>"
                                  ]]),
                              /* String_literal */Block.__(11, [
                                  "In the definition of ",
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* String_literal */Block.__(11, [
                                          ", type",
                                          /* Formatting_lit */Block.__(17, [
                                              /* Break */Block.__(0, [
                                                  "@ ",
                                                  1,
                                                  0
                                                ]),
                                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                      /* Break */Block.__(0, [
                                                          "@ ",
                                                          1,
                                                          0
                                                        ]),
                                                      /* String_literal */Block.__(11, [
                                                          "should be",
                                                          /* Formatting_lit */Block.__(17, [
                                                              /* Break */Block.__(0, [
                                                                  "@ ",
                                                                  1,
                                                                  0
                                                                ]),
                                                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                      /* Close_box */0,
                                                                      /* End_of_format */0
                                                                    ])])
                                                            ])
                                                        ])
                                                    ])])
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "@[<hv>In the definition of %s, type@ %a@ should be@ %a@]"
                        ]), name(void 0, param[0]), type_expr$1, ty$3, type_expr$1, ty$prime$1);
      case /* Unbound_type_var */9 :
          var decl = param[1];
          Format.fprintf(ppf, /* Format */[
                /* String_literal */Block.__(11, [
                    "A type variable is unbound in this type declaration",
                    /* End_of_format */0
                  ]),
                "A type variable is unbound in this type declaration"
              ]);
          var ty$4 = repr(param[0]);
          var match = decl.type_kind;
          var match$1 = decl.type_manifest;
          if (typeof match === "number") {
            if (match === /* Type_abstract */0 && match$1 !== void 0) {
              var trivial = function (ty$5) {
                return explain_unbound(ppf, ty$4, /* :: */[
                            ty$5,
                            /* [] */0
                          ], (function (t) {
                              return t;
                            }), "type", (function (param) {
                              return "";
                            }));
              };
              var match$2 = repr(match$1).desc;
              if (typeof match$2 === "number") {
                return trivial(match$1);
              }
              switch (match$2.tag | 0) {
                case /* Tobject */4 :
                    var match$3 = flatten_fields(match$2[0]);
                    if (match$3[1] === ty$4) {
                      return trivial(match$1);
                    } else {
                      return explain_unbound(ppf, ty$4, match$3[0], (function (param) {
                                    return param[2];
                                  }), "method", (function (param) {
                                    return param[0] + ": ";
                                  }));
                    }
                case /* Tvariant */8 :
                    var row = row_repr_aux(/* [] */0, match$2[0]);
                    if (row.row_more === ty$4) {
                      return trivial(match$1);
                    } else {
                      return explain_unbound(ppf, ty$4, row.row_fields, (function (param) {
                                    var match = row_field_repr_aux(/* [] */0, param[1]);
                                    if (typeof match === "number") {
                                      return newty2(100000000, /* Ttuple */Block.__(2, [/* [] */0]));
                                    }
                                    if (match.tag) {
                                      var tl = match[1];
                                      if (tl && !tl[1]) {
                                        return tl[0];
                                      } else {
                                        return newty2(100000000, /* Ttuple */Block.__(2, [tl]));
                                      }
                                    } else {
                                      var match$1 = match[0];
                                      if (match$1 !== void 0) {
                                        return match$1;
                                      } else {
                                        return newty2(100000000, /* Ttuple */Block.__(2, [/* [] */0]));
                                      }
                                    }
                                  }), "case", (function (param) {
                                    return "`" + (param[0] + " of ");
                                  }));
                    }
                default:
                  return trivial(match$1);
              }
            } else {
              return ;
            }
          } else if (match.tag) {
            return explain_unbound(ppf, ty$4, match[0], (function (c) {
                          return newty2(100000000, /* Ttuple */Block.__(2, [c.cd_args]));
                        }), "case", (function (c) {
                          return c.cd_id.name + " of ";
                        }));
          } else {
            return explain_unbound(ppf, ty$4, match[0], (function (l) {
                          return l.ld_type;
                        }), "field", (function (l) {
                          return l.ld_id.name + ": ";
                        }));
          }
      case /* Not_open_type */10 :
          return Curry._3(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* End_of_format */0,
                                    ""
                                  ]]),
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@ ",
                                          1,
                                          0
                                        ]),
                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                              /* Close_box */0,
                                              /* End_of_format */0
                                            ])])
                                    ])
                                ])
                            ]),
                          "@[%s@ %a@]"
                        ]), "Cannot extend type definition", path, param[0]);
      case /* Not_extensible_type */11 :
          return Curry._4(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* End_of_format */0,
                                    ""
                                  ]]),
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@ ",
                                          1,
                                          0
                                        ]),
                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                              /* Break */Block.__(0, [
                                                  "@ ",
                                                  1,
                                                  0
                                                ]),
                                              /* String */Block.__(2, [
                                                  /* No_padding */0,
                                                  /* Formatting_lit */Block.__(17, [
                                                      /* Close_box */0,
                                                      /* End_of_format */0
                                                    ])
                                                ])
                                            ])])
                                    ])
                                ])
                            ]),
                          "@[%s@ %a@ %s@]"
                        ]), "Type", path, param[0], "is not extensible");
      case /* Extension_mismatch */12 :
          return Curry._5(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* String_literal */Block.__(11, [
                                        "<v>",
                                        /* End_of_format */0
                                      ]),
                                    "<v>"
                                  ]]),
                              /* Formatting_gen */Block.__(18, [
                                  /* Open_box */Block.__(1, [/* Format */[
                                        /* String_literal */Block.__(11, [
                                            "<hov>",
                                            /* End_of_format */0
                                          ]),
                                        "<hov>"
                                      ]]),
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* Formatting_lit */Block.__(17, [
                                          /* Break */Block.__(0, [
                                              "@ ",
                                              1,
                                              0
                                            ]),
                                          /* String */Block.__(2, [
                                              /* No_padding */0,
                                              /* Formatting_lit */Block.__(17, [
                                                  /* Break */Block.__(0, [
                                                      "@;<1 2>",
                                                      1,
                                                      2
                                                    ]),
                                                  /* String */Block.__(2, [
                                                      /* No_padding */0,
                                                      /* Formatting_lit */Block.__(17, [
                                                          /* Close_box */0,
                                                          /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                  /* Close_box */0,
                                                                  /* End_of_format */0
                                                                ])])
                                                        ])
                                                    ])
                                                ])
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "@[<v>@[<hov>%s@ %s@;<1 2>%s@]%a@]"
                        ]), "This extension", "does not match the definition of type", name(void 0, param[0]), (function (param) {
                        return report_type_mismatch("the type", "this extension", "definition", param);
                      }), param[1]);
      case /* Rebind_wrong_type */13 :
          var lid = param[0];
          return report_unification_error(ppf, param[1], void 0, param[2], (function (ppf) {
                        return Curry._2(Format.fprintf(ppf, /* Format */[
                                        /* String_literal */Block.__(11, [
                                            "The constructor ",
                                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                    /* Break */Block.__(0, [
                                                        "@ ",
                                                        1,
                                                        0
                                                      ]),
                                                    /* String_literal */Block.__(11, [
                                                        "has type",
                                                        /* End_of_format */0
                                                      ])
                                                  ])])
                                          ]),
                                        "The constructor %a@ has type"
                                      ]), longident, lid);
                      }), (function (ppf) {
                        return Format.fprintf(ppf, /* Format */[
                                    /* String_literal */Block.__(11, [
                                        "but was expected to be of type",
                                        /* End_of_format */0
                                      ]),
                                    "but was expected to be of type"
                                  ]);
                      }));
      case /* Rebind_mismatch */14 :
          return Curry._8(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* End_of_format */0,
                                    ""
                                  ]]),
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@ ",
                                          1,
                                          0
                                        ]),
                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                              /* Break */Block.__(0, [
                                                  "@ ",
                                                  1,
                                                  0
                                                ]),
                                              /* String */Block.__(2, [
                                                  /* No_padding */0,
                                                  /* Formatting_lit */Block.__(17, [
                                                      /* Break */Block.__(0, [
                                                          "@ ",
                                                          1,
                                                          0
                                                        ]),
                                                      /* String */Block.__(2, [
                                                          /* No_padding */0,
                                                          /* Formatting_lit */Block.__(17, [
                                                              /* Break */Block.__(0, [
                                                                  "@ ",
                                                                  1,
                                                                  0
                                                                ]),
                                                              /* String */Block.__(2, [
                                                                  /* No_padding */0,
                                                                  /* Formatting_lit */Block.__(17, [
                                                                      /* Break */Block.__(0, [
                                                                          "@ ",
                                                                          1,
                                                                          0
                                                                        ]),
                                                                      /* String */Block.__(2, [
                                                                          /* No_padding */0,
                                                                          /* Formatting_lit */Block.__(17, [
                                                                              /* Break */Block.__(0, [
                                                                                  "@ ",
                                                                                  1,
                                                                                  0
                                                                                ]),
                                                                              /* String */Block.__(2, [
                                                                                  /* No_padding */0,
                                                                                  /* Formatting_lit */Block.__(17, [
                                                                                      /* Close_box */0,
                                                                                      /* End_of_format */0
                                                                                    ])
                                                                                ])
                                                                            ])
                                                                        ])
                                                                    ])
                                                                ])
                                                            ])
                                                        ])
                                                    ])
                                                ])
                                            ])])
                                    ])
                                ])
                            ]),
                          "@[%s@ %a@ %s@ %s@ %s@ %s@ %s@]"
                        ]), "The constructor", longident, param[0], "extends type", name(void 0, param[1]), "whose declaration does not match", "the declaration of type", name(void 0, param[2]));
      case /* Rebind_private */15 :
          return Curry._4(Format.fprintf(ppf, /* Format */[
                          /* Formatting_gen */Block.__(18, [
                              /* Open_box */Block.__(1, [/* Format */[
                                    /* End_of_format */0,
                                    ""
                                  ]]),
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@ ",
                                          1,
                                          0
                                        ]),
                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                              /* Break */Block.__(0, [
                                                  "@ ",
                                                  1,
                                                  0
                                                ]),
                                              /* String */Block.__(2, [
                                                  /* No_padding */0,
                                                  /* Formatting_lit */Block.__(17, [
                                                      /* Close_box */0,
                                                      /* End_of_format */0
                                                    ])
                                                ])
                                            ])])
                                    ])
                                ])
                            ]),
                          "@[%s@ %a@ %s@]"
                        ]), "The constructor", longident, param[0], "is private");
      case /* Bad_variance */16 :
          var n = param[0];
          var variance = function (param) {
            var n = param[1];
            var inj = param[2] ? "injective " : "";
            if (param[0]) {
              if (n) {
                return inj + "invariant";
              } else {
                return inj + "covariant";
              }
            } else if (n) {
              return inj + "contravariant";
            } else if (inj === "") {
              return "unrestricted";
            } else {
              return inj;
            }
          };
          var suffix = function (n) {
            var teen = (n % 100 / 10 | 0) === 1;
            var match = n % 10;
            switch (match) {
              case 1 :
                  if (teen) {
                    return "th";
                  } else {
                    return "st";
                  }
              case 2 :
                  if (teen) {
                    return "th";
                  } else {
                    return "nd";
                  }
              case 3 :
                  if (teen) {
                    return "th";
                  } else {
                    return "rd";
                  }
              default:
                return "th";
            }
          };
          if (n === -1) {
            Curry._2(Format.fprintf(ppf, /* Format */[
                      /* Formatting_gen */Block.__(18, [
                          /* Open_box */Block.__(1, [/* Format */[
                                /* End_of_format */0,
                                ""
                              ]]),
                          /* String */Block.__(2, [
                              /* No_padding */0,
                              /* Formatting_lit */Block.__(17, [
                                  /* Break */Block.__(0, [
                                      "@ ",
                                      1,
                                      0
                                    ]),
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* Formatting_lit */Block.__(17, [
                                          /* Break */Block.__(0, [
                                              "@ ",
                                              1,
                                              0
                                            ]),
                                          /* String_literal */Block.__(11, [
                                              "It",
                                              /* End_of_format */0
                                            ])
                                        ])
                                    ])
                                ])
                            ])
                        ]),
                      "@[%s@ %s@ It"
                    ]), "In this definition, a type variable has a variance that", "is not reflected by its occurrence in type parameters.");
          } else if (n === -2) {
            Curry._2(Format.fprintf(ppf, /* Format */[
                      /* Formatting_gen */Block.__(18, [
                          /* Open_box */Block.__(1, [/* Format */[
                                /* End_of_format */0,
                                ""
                              ]]),
                          /* String */Block.__(2, [
                              /* No_padding */0,
                              /* Formatting_lit */Block.__(17, [
                                  /* Break */Block.__(0, [
                                      "@ ",
                                      1,
                                      0
                                    ]),
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* Formatting_lit */Block.__(17, [
                                          /* Close_box */0,
                                          /* End_of_format */0
                                        ])
                                    ])
                                ])
                            ])
                        ]),
                      "@[%s@ %s@]"
                    ]), "In this definition, a type variable cannot be deduced", "from the type parameters.");
          } else if (n === -3) {
            Curry._2(Format.fprintf(ppf, /* Format */[
                      /* Formatting_gen */Block.__(18, [
                          /* Open_box */Block.__(1, [/* Format */[
                                /* End_of_format */0,
                                ""
                              ]]),
                          /* String */Block.__(2, [
                              /* No_padding */0,
                              /* Formatting_lit */Block.__(17, [
                                  /* Break */Block.__(0, [
                                      "@ ",
                                      1,
                                      0
                                    ]),
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* Formatting_lit */Block.__(17, [
                                          /* Break */Block.__(0, [
                                              "@ ",
                                              1,
                                              0
                                            ]),
                                          /* String_literal */Block.__(11, [
                                              "It",
                                              /* End_of_format */0
                                            ])
                                        ])
                                    ])
                                ])
                            ])
                        ]),
                      "@[%s@ %s@ It"
                    ]), "In this definition, a type variable has a variance that", "cannot be deduced from the type parameters.");
          } else {
            Curry._4(Format.fprintf(ppf, /* Format */[
                      /* Formatting_gen */Block.__(18, [
                          /* Open_box */Block.__(1, [/* Format */[
                                /* End_of_format */0,
                                ""
                              ]]),
                          /* String */Block.__(2, [
                              /* No_padding */0,
                              /* Formatting_lit */Block.__(17, [
                                  /* Break */Block.__(0, [
                                      "@ ",
                                      1,
                                      0
                                    ]),
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* Formatting_lit */Block.__(17, [
                                          /* Break */Block.__(0, [
                                              "@ ",
                                              1,
                                              0
                                            ]),
                                          /* String_literal */Block.__(11, [
                                              "The ",
                                              /* Int */Block.__(4, [
                                                  /* Int_d */0,
                                                  /* No_padding */0,
                                                  /* No_precision */0,
                                                  /* String */Block.__(2, [
                                                      /* No_padding */0,
                                                      /* String_literal */Block.__(11, [
                                                          " type parameter",
                                                          /* End_of_format */0
                                                        ])
                                                    ])
                                                ])
                                            ])
                                        ])
                                    ])
                                ])
                            ])
                        ]),
                      "@[%s@ %s@ The %d%s type parameter"
                    ]), "In this definition, expected parameter", "variances are not satisfied.", n, suffix(n));
          }
          if (n !== -2) {
            return Curry._2(Format.fprintf(ppf, /* Format */[
                            /* String_literal */Block.__(11, [
                                " was expected to be ",
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* Char_literal */Block.__(12, [
                                        /* "," */44,
                                        /* Formatting_lit */Block.__(17, [
                                            /* Break */Block.__(0, [
                                                "@ ",
                                                1,
                                                0
                                              ]),
                                            /* String_literal */Block.__(11, [
                                                "but it is ",
                                                /* String */Block.__(2, [
                                                    /* No_padding */0,
                                                    /* Char_literal */Block.__(12, [
                                                        /* "." */46,
                                                        /* Formatting_lit */Block.__(17, [
                                                            /* Close_box */0,
                                                            /* End_of_format */0
                                                          ])
                                                      ])
                                                  ])
                                              ])
                                          ])
                                      ])
                                  ])
                              ]),
                            " was expected to be %s,@ but it is %s.@]"
                          ]), variance(param[2]), variance(param[1]));
          } else {
            return ;
          }
      case /* Unavailable_type_constructor */17 :
          return Curry._2(Format.fprintf(ppf, /* Format */[
                          /* String_literal */Block.__(11, [
                              "The definition of type ",
                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                      /* Break */Block.__(0, [
                                          "@ ",
                                          1,
                                          0
                                        ]),
                                      /* String_literal */Block.__(11, [
                                          "is unavailable",
                                          /* End_of_format */0
                                        ])
                                    ])])
                            ]),
                          "The definition of type %a@ is unavailable"
                        ]), path, param[0]);
      case /* Bad_fixed_type */18 :
          return Curry._1(Format.fprintf(ppf, /* Format */[
                          /* String_literal */Block.__(11, [
                              "This fixed type ",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* End_of_format */0
                                ])
                            ]),
                          "This fixed type %s"
                        ]), param[0]);
      case /* Unbound_type_var_ext */19 :
          Format.fprintf(ppf, /* Format */[
                /* String_literal */Block.__(11, [
                    "A type variable is unbound in this extension constructor",
                    /* End_of_format */0
                  ]),
                "A type variable is unbound in this extension constructor"
              ]);
          return explain_unbound(ppf, param[0], param[1].ext_args, (function (c) {
                        return c;
                      }), "type", (function (param) {
                        return "";
                      }));
      
    }
  }
}

register_error_of_exn((function (param) {
        if (param[0] === $$Error$8) {
          return error_of_printer(param[1], report_error$5, param[2]);
        }
        
      }));

var $$Error$9 = Caml_exceptions.create("Ocaml_typedtree_test.Typeclass.Error");

var Error_forward$2 = Caml_exceptions.create("Ocaml_typedtree_test.Typeclass.Error_forward");

function ctyp(desc, typ, env, loc) {
  return {
          ctyp_desc: desc,
          ctyp_type: typ,
          ctyp_env: env,
          ctyp_loc: loc,
          ctyp_attributes: /* [] */0
        };
}

var unbound_class = /* Pident */Block.__(0, [create("")]);

function scrape_class_type(_cty) {
  while(true) {
    var cty = _cty;
    switch (cty.tag | 0) {
      case /* Cty_constr */0 :
          _cty = cty[2];
          continue ;
      case /* Cty_signature */1 :
      case /* Cty_arrow */2 :
          return cty;
      
    }
  };
}

function generalize_class_type(gen, _param) {
  while(true) {
    var param = _param;
    switch (param.tag | 0) {
      case /* Cty_constr */0 :
          List.iter(gen, param[1]);
          _param = param[2];
          continue ;
      case /* Cty_signature */1 :
          var match = param[0];
          Curry._1(gen, match.csig_self);
          iter$1((function (param, param$1) {
                  return Curry._1(gen, param$1[2]);
                }), match.csig_vars);
          return List.iter((function (param) {
                        return List.iter(gen, param[1]);
                      }), match.csig_inher);
      case /* Cty_arrow */2 :
          Curry._1(gen, param[1]);
          _param = param[2];
          continue ;
      
    }
  };
}

function virtual_methods(sign) {
  var match = flatten_fields(object_fields(sign.csig_self));
  return List.fold_left((function (virt, param) {
                var lab = param[0];
                if (lab === dummy_method || mem$2(lab, sign.csig_concr)) {
                  return virt;
                } else {
                  return /* :: */[
                          lab,
                          virt
                        ];
                }
              }), /* [] */0, match[0]);
}

function constructor_type(constr, _cty) {
  while(true) {
    var cty = _cty;
    switch (cty.tag | 0) {
      case /* Cty_constr */0 :
          _cty = cty[2];
          continue ;
      case /* Cty_signature */1 :
          return constr;
      case /* Cty_arrow */2 :
          var desc_000 = cty[0];
          var desc_001 = cty[1];
          var desc_002 = constructor_type(constr, cty[2]);
          var desc = /* Tarrow */Block.__(1, [
              desc_000,
              desc_001,
              desc_002,
              /* Cok */0
            ]);
          return newty2(current_level.contents, desc);
      
    }
  };
}

function class_body(_cty) {
  while(true) {
    var cty = _cty;
    switch (cty.tag | 0) {
      case /* Cty_constr */0 :
      case /* Cty_signature */1 :
          return cty;
      case /* Cty_arrow */2 :
          _cty = cty[2];
          continue ;
      
    }
  };
}

function extract_constraints(cty) {
  var sign = signature_of_class_type(cty);
  var match = flatten_fields(object_fields(sign.csig_self));
  return /* tuple */[
          fold((function (lab, param, vars) {
                  return /* :: */[
                          lab,
                          vars
                        ];
                }), sign.csig_vars, /* [] */0),
          List.fold_left((function (meths, param) {
                  var lab = param[0];
                  if (lab === dummy_method) {
                    return meths;
                  } else {
                    return /* :: */[
                            lab,
                            meths
                          ];
                  }
                }), /* [] */0, match[0]),
          sign.csig_concr
        ];
}

function abbreviate_class_type(path, params, cty) {
  switch (cty.tag | 0) {
    case /* Cty_constr */0 :
    case /* Cty_signature */1 :
        return /* Cty_constr */Block.__(0, [
                  path,
                  params,
                  cty
                ]);
    case /* Cty_arrow */2 :
        return /* Cty_arrow */Block.__(2, [
                  cty[0],
                  cty[1],
                  abbreviate_class_type(path, params, cty[2])
                ]);
    
  }
}

function closed_class$1(cty) {
  if (List.for_all(closed_schema, cty.cty_params)) {
    var _param = cty.cty_type;
    while(true) {
      var param = _param;
      switch (param.tag | 0) {
        case /* Cty_constr */0 :
            return List.for_all(closed_schema, param[1]);
        case /* Cty_signature */1 :
            var sign = param[0];
            if (closed_schema(sign.csig_self)) {
              return fold((function (param, param$1, cc) {
                            if (closed_schema(param$1[2])) {
                              return cc;
                            } else {
                              return false;
                            }
                          }), sign.csig_vars, true);
            } else {
              return false;
            }
        case /* Cty_arrow */2 :
            if (!closed_schema(param[1])) {
              return false;
            }
            _param = param[2];
            continue ;
        
      }
    };
  } else {
    return false;
  }
}

function limited_generalize$1(rv, _param) {
  while(true) {
    var param = _param;
    switch (param.tag | 0) {
      case /* Cty_constr */0 :
          List.iter((function (param) {
                  return limited_generalize(rv, param);
                }), param[1]);
          _param = param[2];
          continue ;
      case /* Cty_signature */1 :
          var sign = param[0];
          limited_generalize(rv, sign.csig_self);
          iter$1((function (param, param$1) {
                  return limited_generalize(rv, param$1[2]);
                }), sign.csig_vars);
          return List.iter((function (param) {
                        return List.iter((function (param) {
                                      return limited_generalize(rv, param);
                                    }), param[1]);
                      }), sign.csig_inher);
      case /* Cty_arrow */2 :
          limited_generalize(rv, param[1]);
          _param = param[2];
          continue ;
      
    }
  };
}

function rc(node) {
  add_saved_type(/* Partial_class_expr */Block.__(4, [node]));
  record$2(/* Ti_class */Block.__(2, [node]));
  return node;
}

function enter_met_env(check, loc, lab, kind, ty, val_env, met_env, par_env) {
  var match = enter_value(void 0)(lab, {
        val_type: ty,
        val_kind: /* Val_unbound */1,
        val_loc: loc,
        val_attributes: /* [] */0
      }, val_env);
  var id = match[0];
  return /* tuple */[
          id,
          match[1],
          add_value(check, id, {
                val_type: ty,
                val_kind: kind,
                val_loc: loc,
                val_attributes: /* [] */0
              }, met_env),
          add_value(void 0, id, {
                val_type: ty,
                val_kind: /* Val_unbound */1,
                val_loc: loc,
                val_attributes: /* [] */0
              }, par_env)
        ];
}

function enter_val(cl_num, vars, inh, lab, mut, virt, ty, val_env, met_env, par_env, loc) {
  var match;
  try {
    var match$1 = find(lab, vars.contents);
    var virt$prime = match$1[2];
    if (match$1[1] !== mut) {
      throw [
            $$Error$9,
            loc,
            val_env,
            /* Mutability_mismatch */Block.__(22, [
                lab,
                mut
              ])
          ];
    }
    unify$2(val_env, instance(void 0, val_env, ty), instance(void 0, val_env, match$1[3]));
    match = /* tuple */[
      !inh ? match$1[0] : void 0,
      virt$prime === /* Concrete */1 ? virt$prime : virt
    ];
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === Unify) {
      throw [
            $$Error$9,
            loc,
            val_env,
            /* Field_type_mismatch */Block.__(1, [
                "instance variable",
                lab,
                exn[1]
              ])
          ];
    }
    if (exn !== Caml_builtin_exceptions.not_found) {
      throw exn;
    }
    match = /* tuple */[
      void 0,
      virt
    ];
  }
  var id = match[0];
  var result = id !== void 0 ? /* tuple */[
      id,
      val_env,
      met_env,
      par_env
    ] : enter_met_env(void 0, none, lab, /* Val_ivar */Block.__(1, [
            mut,
            cl_num
          ]), ty, val_env, met_env, par_env);
  vars.contents = add$1(lab, /* tuple */[
        result[0],
        mut,
        match[1],
        ty
      ], vars.contents);
  return result;
}

function concr_vals(vars) {
  return fold((function (id, param, s) {
                if (param[1] === /* Virtual */0) {
                  return s;
                } else {
                  return add$2(id, s);
                }
              }), vars, /* Empty */0);
}

function inheritance(self_type, env, ovf, concr_meths, warn_vals, loc, parent) {
  var match = scrape_class_type(parent);
  switch (match.tag | 0) {
    case /* Cty_signature */1 :
        var cl_sig = match[0];
        try {
          unify$2(env, self_type, cl_sig.csig_self);
        }
        catch (raw_exn){
          var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn[0] !== Unify) {
            throw exn;
          }
          var trace = exn[1];
          var exit = 0;
          if (trace) {
            var match$1 = trace[1];
            if (match$1) {
              var match$2 = match$1[1];
              if (match$2) {
                var match$3 = match$2[1];
                if (match$3) {
                  var match$4 = match$3[0][0].desc;
                  if (typeof match$4 === "number") {
                    exit = 1;
                  } else {
                    if (match$4.tag === /* Tfield */5) {
                      throw [
                            $$Error$9,
                            loc,
                            env,
                            /* Field_type_mismatch */Block.__(1, [
                                "method",
                                match$4[0],
                                match$3[1]
                              ])
                          ];
                    }
                    exit = 1;
                  }
                } else {
                  exit = 1;
                }
              } else {
                exit = 1;
              }
            } else {
              exit = 1;
            }
          } else {
            exit = 1;
          }
          if (exit === 1) {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  /* tuple */[
                    "typeclass.ml",
                    261,
                    12
                  ]
                ];
          }
          
        }
        var over_meths = inter$1(cl_sig.csig_concr, concr_meths);
        var concr_vals$1 = concr_vals(cl_sig.csig_vars);
        var over_vals = inter$1(concr_vals$1, warn_vals);
        if (ovf !== void 0) {
          if (ovf) {
            var cname;
            switch (parent.tag | 0) {
              case /* Cty_constr */0 :
                  cname = name(void 0, parent[0]);
                  break;
              case /* Cty_signature */1 :
              case /* Cty_arrow */2 :
                  cname = "inherited";
                  break;
              
            }
            if (!(
                over_meths ? false : true
              )) {
              prerr_warning(loc, /* Method_override */Block.__(2, [/* :: */[
                        cname,
                        elements_aux(/* [] */0, over_meths)
                      ]]));
            }
            if (!(
                over_vals ? false : true
              )) {
              prerr_warning(loc, /* Instance_variable_override */Block.__(5, [/* :: */[
                        cname,
                        elements_aux(/* [] */0, over_vals)
                      ]]));
            }
            
          } else if ((
              over_meths ? false : true
            ) && (
              over_vals ? false : true
            )) {
            throw [
                  $$Error$9,
                  loc,
                  env,
                  /* No_overriding */Block.__(23, [
                      "",
                      ""
                    ])
                ];
          }
          
        }
        var concr_meths$1 = union$1(cl_sig.csig_concr, concr_meths);
        var warn_vals$1 = union$1(concr_vals$1, warn_vals);
        return /* tuple */[
                cl_sig,
                concr_meths$1,
                warn_vals$1
              ];
    case /* Cty_constr */0 :
    case /* Cty_arrow */2 :
        throw [
              $$Error$9,
              loc,
              env,
              /* Structure_expected */Block.__(2, [parent])
            ];
    
  }
}

function virtual_method(val_env, meths, self_type, lab, priv, sty, loc) {
  var match = filter_self_method(val_env, lab, priv, meths, self_type);
  var sty$1 = force_poly(sty);
  var cty = transl_simple_type(val_env, false, sty$1);
  var ty = cty.ctyp_type;
  try {
    unify$2(val_env, ty, match[1]);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === Unify) {
      throw [
            $$Error$9,
            loc,
            val_env,
            /* Field_type_mismatch */Block.__(1, [
                "method",
                lab,
                exn[1]
              ])
          ];
    }
    throw exn;
  }
  return cty;
}

var delayed_meth_specs = {
  contents: /* [] */0
};

function declare_method(val_env, meths, self_type, lab, priv, sty, loc) {
  var match = filter_self_method(val_env, lab, priv, meths, self_type);
  var ty$prime = match[1];
  var unif = function (ty) {
    try {
      return unify$2(val_env, ty, ty$prime);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn[0] === Unify) {
        throw [
              $$Error$9,
              loc,
              val_env,
              /* Field_type_mismatch */Block.__(1, [
                  "method",
                  lab,
                  exn[1]
                ])
            ];
      }
      throw exn;
    }
  };
  var sty$1 = force_poly(sty);
  var match$1 = sty$1.ptyp_desc;
  if (typeof match$1 !== "number" && match$1.tag === /* Ptyp_poly */8 && !match$1[0] && priv) {
    var sty$prime = match$1[1];
    var returned_cty = ctyp(/* Ttyp_any */0, newty2(current_level.contents, /* Tnil */0), val_env, loc);
    delayed_meth_specs.contents = /* :: */[
      Caml_obj.caml_lazy_make((function (param) {
              var cty = transl_simple_type_univars(val_env, sty$prime);
              var ty = cty.ctyp_type;
              unif(ty);
              returned_cty.ctyp_desc = /* Ttyp_poly */Block.__(8, [
                  /* [] */0,
                  cty
                ]);
              returned_cty.ctyp_type = ty;
              
            })),
      delayed_meth_specs.contents
    ];
    return returned_cty;
  }
  var cty = transl_simple_type(val_env, false, sty$1);
  var ty = cty.ctyp_type;
  unif(ty);
  return cty;
}

function type_constraint(val_env, sty, sty$prime, loc) {
  var cty = transl_simple_type(val_env, false, sty);
  var ty = cty.ctyp_type;
  var cty$prime = transl_simple_type(val_env, false, sty$prime);
  var ty$prime = cty$prime.ctyp_type;
  try {
    unify$2(val_env, ty, ty$prime);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === Unify) {
      throw [
            $$Error$9,
            loc,
            val_env,
            /* Unconsistent_constraint */Block.__(0, [exn[1]])
          ];
    }
    throw exn;
  }
  return /* tuple */[
          cty,
          cty$prime
        ];
}

function make_method(loc, cl_num, expr) {
  return Curry._6(Ast_helper_Exp.fun_, expr.pexp_loc, void 0, "", void 0, alias$1(loc, void 0, $$var$1(loc, void 0, {
                      txt: "self-*",
                      loc: loc
                    }), {
                  txt: "self-" + cl_num,
                  loc: loc
                }), expr);
}

function add_val(env, loc, lab, param, val_sig) {
  var virt = param[1];
  var virt$1;
  try {
    var match = find(lab, val_sig);
    var virt$prime = match[1];
    virt$1 = virt$prime === /* Concrete */1 ? virt$prime : virt;
  }
  catch (exn){
    if (exn !== Caml_builtin_exceptions.not_found) {
      throw exn;
    }
    virt$1 = virt;
  }
  return add$1(lab, /* tuple */[
              param[0],
              virt$1,
              param[2]
            ], val_sig);
}

function class_signature$1(env, param) {
  var sty = param.pcsig_self;
  var meths = {
    contents: /* Empty */0
  };
  var self_cty = transl_simple_type(env, false, sty);
  var self_cty$1 = {
    ctyp_desc: self_cty.ctyp_desc,
    ctyp_type: expand_head(env, self_cty.ctyp_type),
    ctyp_env: self_cty.ctyp_env,
    ctyp_loc: self_cty.ctyp_loc,
    ctyp_attributes: self_cty.ctyp_attributes
  };
  var self_type = self_cty$1.ctyp_type;
  var dummy_obj = newvar(void 0, void 0);
  unify$2(env, filter_method(env, dummy_method, /* Private */0, dummy_obj), newty2(current_level.contents, /* Ttuple */Block.__(2, [/* [] */0])));
  try {
    unify$2(env, self_type, dummy_obj);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === Unify) {
      throw [
            $$Error$9,
            sty.ptyp_loc,
            env,
            /* Pattern_type_clash */Block.__(5, [self_type])
          ];
    }
    throw exn;
  }
  warning_enter_scope(void 0);
  var match = List.fold_left((function (param, param$1) {
          var inher = param[3];
          var concr_meths = param[2];
          var val_sig = param[1];
          var fields = param[0];
          var loc = param$1.pctf_loc;
          var mkctf = function (desc) {
            return {
                    ctf_desc: desc,
                    ctf_loc: loc,
                    ctf_attributes: param$1.pctf_attributes
                  };
          };
          var match = param$1.pctf_desc;
          switch (match.tag | 0) {
            case /* Pctf_inherit */0 :
                var sparent = match[0];
                var parent = class_type$3(env, sparent);
                var match$1 = parent.cltyp_type;
                var inher$1;
                switch (match$1.tag | 0) {
                  case /* Cty_constr */0 :
                      inher$1 = /* :: */[
                        /* tuple */[
                          match$1[0],
                          match$1[1]
                        ],
                        inher
                      ];
                      break;
                  case /* Cty_signature */1 :
                  case /* Cty_arrow */2 :
                      inher$1 = inher;
                      break;
                  
                }
                var match$2 = inheritance(self_type, env, void 0, concr_meths, /* Empty */0, sparent.pcty_loc, parent.cltyp_type);
                var partial_arg = sparent.pcty_loc;
                var val_sig$1 = fold((function (param, param$1, param$2) {
                        return add_val(env, partial_arg, param, param$1, param$2);
                      }), match$2[0].csig_vars, val_sig);
                return /* tuple */[
                        /* :: */[
                          mkctf(/* Tctf_inherit */Block.__(0, [parent])),
                          fields
                        ],
                        val_sig$1,
                        match$2[1],
                        inher$1
                      ];
            case /* Pctf_val */1 :
                var match$3 = match[0];
                var virt = match$3[2];
                var mut = match$3[1];
                var lab = match$3[0];
                var cty = transl_simple_type(env, false, match$3[3]);
                var ty = cty.ctyp_type;
                return /* tuple */[
                        /* :: */[
                          mkctf(/* Tctf_val */Block.__(1, [/* tuple */[
                                    lab,
                                    mut,
                                    virt,
                                    cty
                                  ]])),
                          fields
                        ],
                        add_val(env, param$1.pctf_loc, lab, /* tuple */[
                              mut,
                              virt,
                              ty
                            ], val_sig),
                        concr_meths,
                        inher
                      ];
            case /* Pctf_method */2 :
                var match$4 = match[0];
                var virt$1 = match$4[2];
                var priv = match$4[1];
                var lab$1 = match$4[0];
                var cty$1 = declare_method(env, meths, self_type, lab$1, priv, match$4[3], param$1.pctf_loc);
                var concr_meths$1 = virt$1 ? add$2(lab$1, concr_meths) : concr_meths;
                return /* tuple */[
                        /* :: */[
                          mkctf(/* Tctf_method */Block.__(2, [/* tuple */[
                                    lab$1,
                                    priv,
                                    virt$1,
                                    cty$1
                                  ]])),
                          fields
                        ],
                        val_sig,
                        concr_meths$1,
                        inher
                      ];
            case /* Pctf_constraint */3 :
                var match$5 = match[0];
                var match$6 = type_constraint(env, match$5[0], match$5[1], param$1.pctf_loc);
                return /* tuple */[
                        /* :: */[
                          mkctf(/* Tctf_constraint */Block.__(3, [/* tuple */[
                                    match$6[0],
                                    match$6[1]
                                  ]])),
                          fields
                        ],
                        val_sig,
                        concr_meths,
                        inher
                      ];
            case /* Pctf_attribute */4 :
                var x = match[0];
                warning_attribute(/* :: */[
                      x,
                      /* [] */0
                    ]);
                return /* tuple */[
                        /* :: */[
                          mkctf(/* Tctf_attribute */Block.__(4, [x])),
                          fields
                        ],
                        val_sig,
                        concr_meths,
                        inher
                      ];
            case /* Pctf_extension */5 :
                throw [
                      Error_forward$2,
                      error_of_extension(match[0])
                    ];
            
          }
        }), /* tuple */[
        /* [] */0,
        /* Empty */0,
        /* Empty */0,
        /* [] */0
      ], param.pcsig_fields);
  warning_leave_scope(void 0);
  var cty_csig_vars = match[1];
  var cty_csig_concr = match[2];
  var cty_csig_inher = match[3];
  var cty = {
    csig_self: self_type,
    csig_vars: cty_csig_vars,
    csig_concr: cty_csig_concr,
    csig_inher: cty_csig_inher
  };
  return {
          csig_self: self_cty$1,
          csig_fields: List.rev(match[0]),
          csig_type: cty
        };
}

function class_type$3(env, scty) {
  var cltyp = function (desc, typ) {
    return {
            cltyp_desc: desc,
            cltyp_type: typ,
            cltyp_env: env,
            cltyp_loc: scty.pcty_loc,
            cltyp_attributes: scty.pcty_attributes
          };
  };
  var match = scty.pcty_desc;
  switch (match.tag | 0) {
    case /* Pcty_constr */0 :
        var styl = match[1];
        var lid = match[0];
        var match$1 = find_class_type(env, scty.pcty_loc, lid.txt);
        var decl = match$1[1];
        var path = match$1[0];
        if (same(decl.clty_path, unbound_class)) {
          throw [
                $$Error$9,
                scty.pcty_loc,
                env,
                /* Unbound_class_type_2 */Block.__(7, [lid.txt])
              ];
        }
        var match$2 = instance_class(decl.clty_params, decl.clty_type);
        var params = match$2[0];
        if (List.length(params) !== List.length(styl)) {
          throw [
                $$Error$9,
                scty.pcty_loc,
                env,
                /* Parameter_arity_mismatch */Block.__(11, [
                    lid.txt,
                    List.length(params),
                    List.length(styl)
                  ])
              ];
        }
        var ctys = List.map2((function (sty, ty) {
                var cty$prime = transl_simple_type(env, false, sty);
                var ty$prime = cty$prime.ctyp_type;
                try {
                  unify$2(env, ty$prime, ty);
                }
                catch (raw_exn){
                  var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                  if (exn[0] === Unify) {
                    throw [
                          $$Error$9,
                          sty.ptyp_loc,
                          env,
                          /* Parameter_mismatch */Block.__(12, [exn[1]])
                        ];
                  }
                  throw exn;
                }
                return cty$prime;
              }), styl, params);
        var typ_002 = match$2[1];
        var typ = /* Cty_constr */Block.__(0, [
            path,
            params,
            typ_002
          ]);
        return cltyp(/* Tcty_constr */Block.__(0, [
                      path,
                      lid,
                      ctys
                    ]), typ);
    case /* Pcty_signature */1 :
        var clsig = class_signature$1(env, match[0]);
        var typ$1 = /* Cty_signature */Block.__(1, [clsig.csig_type]);
        return cltyp(/* Tcty_signature */Block.__(1, [clsig]), typ$1);
    case /* Pcty_arrow */2 :
        var l = match[0];
        var cty = transl_simple_type(env, false, match[1]);
        var ty = cty.ctyp_type;
        var clty = class_type$3(env, match[2]);
        var typ_002$1 = clty.cltyp_type;
        var typ$2 = /* Cty_arrow */Block.__(2, [
            l,
            ty,
            typ_002$1
          ]);
        return cltyp(/* Tcty_arrow */Block.__(2, [
                      l,
                      cty,
                      clty
                    ]), typ$2);
    case /* Pcty_extension */3 :
        throw [
              Error_forward$2,
              error_of_extension(match[0])
            ];
    
  }
}

function class_type$4(env, scty) {
  delayed_meth_specs.contents = /* [] */0;
  var cty = class_type$3(env, scty);
  List.iter(CamlinternalLazy.force, List.rev(delayed_meth_specs.contents));
  delayed_meth_specs.contents = /* [] */0;
  return cty;
}

function class_structure(cl_num, $$final, val_env, met_env, loc, param) {
  var spat = param.pcstr_self;
  var init = spat.ppat_loc;
  var self_loc_loc_start = init.loc_start;
  var self_loc_loc_end = init.loc_end;
  var self_loc = {
    loc_start: self_loc_loc_start,
    loc_end: self_loc_loc_end,
    loc_ghost: true
  };
  var self_type = newvar(void 0, void 0);
  unify$2(val_env, filter_method(val_env, dummy_method, /* Private */0, self_type), newty2(current_level.contents, /* Ttuple */Block.__(2, [/* [] */0])));
  var private_self = $$final ? newvar(void 0, void 0) : self_type;
  var match = type_self_pattern(cl_num, private_self, val_env, met_env, met_env, spat);
  var val_env$1 = match[3];
  var vars = match[2];
  var meths = match[1];
  var pat = match[0];
  var public_self = pat.pat_type;
  var ty;
  if ($$final) {
    var desc_000 = newvar(void 0, void 0);
    var desc_001 = {
      contents: void 0
    };
    var desc = /* Tobject */Block.__(4, [
        desc_000,
        desc_001
      ]);
    ty = newty2(current_level.contents, desc);
  } else {
    ty = self_type;
  }
  try {
    unify$2(val_env$1, public_self, ty);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === Unify) {
      throw [
            $$Error$9,
            spat.ppat_loc,
            val_env$1,
            /* Pattern_type_clash */Block.__(5, [public_self])
          ];
    }
    throw exn;
  }
  var get_methods = function (ty) {
    return flatten_fields(object_fields(expand_head(val_env$1, ty)))[0];
  };
  if ($$final) {
    List.iter((function (param) {
            var k = field_kind_repr(param[1]) === /* Fpresent */0 ? /* Public */1 : /* Private */0;
            try {
              return unify$2(val_env$1, param[2], filter_method(val_env$1, param[0], k, self_type));
            }
            catch (exn){
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    /* tuple */[
                      "typeclass.ml",
                      760,
                      18
                    ]
                  ];
            }
          }), get_methods(public_self));
  }
  warning_enter_scope(void 0);
  var match$1 = List.fold_left((function (param, param$1) {
          var local_vals = param[8];
          var local_meths = param[7];
          var inher = param[6];
          var warn_vals = param[5];
          var concr_meths = param[4];
          var fields = param[3];
          var par_env = param[2];
          var met_env = param[1];
          var val_env = param[0];
          var loc = param$1.pcf_loc;
          var mkcf = function (desc) {
            return {
                    cf_desc: desc,
                    cf_loc: loc,
                    cf_attributes: param$1.pcf_attributes
                  };
          };
          var match = param$1.pcf_desc;
          switch (match.tag | 0) {
            case /* Pcf_inherit */0 :
                var $$super = match[2];
                var sparent = match[1];
                var ovf = match[0];
                var parent = class_expr(cl_num, val_env, par_env, sparent);
                var match$1 = parent.cl_type;
                var inher$1;
                switch (match$1.tag | 0) {
                  case /* Cty_constr */0 :
                      inher$1 = /* :: */[
                        /* tuple */[
                          match$1[0],
                          match$1[1]
                        ],
                        inher
                      ];
                      break;
                  case /* Cty_signature */1 :
                  case /* Cty_arrow */2 :
                      inher$1 = inher;
                      break;
                  
                }
                var match$2 = inheritance(self_type, val_env, ovf, concr_meths, warn_vals, sparent.pcl_loc, parent.cl_type);
                var cl_sig = match$2[0];
                var match$3 = fold((function (lab, info, param) {
                        var match = enter_val(cl_num, vars, true, lab, info[0], info[1], info[2], param[0], param[1], param[2], sparent.pcl_loc);
                        return /* tuple */[
                                match[1],
                                match[2],
                                match[3],
                                /* :: */[
                                  /* tuple */[
                                    lab,
                                    match[0]
                                  ],
                                  param[3]
                                ]
                              ];
                      }), cl_sig.csig_vars, /* tuple */[
                      val_env,
                      met_env,
                      par_env,
                      /* [] */0
                    ]);
                var inh_vars = match$3[3];
                var par_env$1 = match$3[2];
                var met_env$1 = match$3[1];
                var val_env$1 = match$3[0];
                var inh_meths = fold$1((function (lab, rem) {
                        return /* :: */[
                                /* tuple */[
                                  lab,
                                  create(lab)
                                ],
                                rem
                              ];
                      }), cl_sig.csig_concr, /* [] */0);
                var match$4;
                if ($$super !== void 0) {
                  var match$5 = enter_met_env((function (s) {
                          return /* Unused_ancestor */Block.__(20, [s]);
                        }), sparent.pcl_loc, $$super, /* Val_anc */Block.__(3, [
                          inh_meths,
                          cl_num
                        ]), self_type, val_env$1, met_env$1, par_env$1);
                  match$4 = /* tuple */[
                    match$5[1],
                    match$5[2],
                    match$5[3]
                  ];
                } else {
                  match$4 = /* tuple */[
                    val_env$1,
                    met_env$1,
                    par_env$1
                  ];
                }
                return /* tuple */[
                        match$4[0],
                        match$4[1],
                        match$4[2],
                        /* :: */[
                          Caml_obj.caml_lazy_make((function (param) {
                                  return mkcf(/* Tcf_inherit */Block.__(0, [
                                                ovf,
                                                parent,
                                                $$super,
                                                inh_vars,
                                                inh_meths
                                              ]));
                                })),
                          fields
                        ],
                        match$2[1],
                        match$2[2],
                        inher$1,
                        local_meths,
                        local_vals
                      ];
            case /* Pcf_val */1 :
                var match$6 = match[0];
                var match$7 = match$6[2];
                var mut = match$6[1];
                var lab = match$6[0];
                if (match$7.tag) {
                  var ovf$1 = match$7[0];
                  if (mem$2(lab.txt, local_vals)) {
                    throw [
                          $$Error$9,
                          loc,
                          val_env,
                          /* Duplicate */Block.__(24, [
                              "instance variable",
                              lab.txt
                            ])
                        ];
                  }
                  if (mem$2(lab.txt, warn_vals)) {
                    if (ovf$1 === /* Fresh */1) {
                      prerr_warning(lab.loc, /* Instance_variable_override */Block.__(5, [/* :: */[
                                lab.txt,
                                /* [] */0
                              ]]));
                    }
                    
                  } else if (ovf$1 === /* Override */0) {
                    throw [
                          $$Error$9,
                          loc,
                          val_env,
                          /* No_overriding */Block.__(23, [
                              "instance variable",
                              lab.txt
                            ])
                        ];
                  }
                  if (principal.contents) {
                    begin_def(void 0);
                  }
                  var exp;
                  try {
                    exp = type_exp(val_env, match$7[1]);
                  }
                  catch (raw_exn){
                    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                    if (exn[0] !== Unify) {
                      throw exn;
                    }
                    var match$8 = exn[1];
                    if (!match$8) {
                      throw exn;
                    }
                    if (match$8[1]) {
                      throw exn;
                    }
                    throw [
                          $$Error$9,
                          loc,
                          val_env,
                          /* Make_nongen_seltype */Block.__(17, [match$8[0][0]])
                        ];
                  }
                  if (principal.contents) {
                    end_def(void 0);
                    generalize_structure$1(current_level.contents, exp.exp_type);
                  }
                  var match$9 = enter_val(cl_num, vars, false, lab.txt, mut, /* Concrete */1, exp.exp_type, val_env, met_env, par_env, loc);
                  var met_env$prime = match$9[2];
                  var id = match$9[0];
                  return /* tuple */[
                          match$9[1],
                          met_env$prime,
                          match$9[3],
                          /* :: */[
                            Caml_obj.caml_lazy_make((function (param) {
                                    return mkcf(/* Tcf_val */Block.__(1, [
                                                  lab,
                                                  mut,
                                                  id,
                                                  /* Tcfk_concrete */Block.__(1, [
                                                      ovf$1,
                                                      exp
                                                    ]),
                                                  met_env === met_env$prime
                                                ]));
                                  })),
                            fields
                          ],
                          concr_meths,
                          add$2(lab.txt, warn_vals),
                          inher,
                          local_meths,
                          add$2(lab.txt, local_vals)
                        ];
                } else {
                  if (principal.contents) {
                    begin_def(void 0);
                  }
                  var cty = transl_simple_type(val_env, false, match$7[0]);
                  var ty = cty.ctyp_type;
                  if (principal.contents) {
                    end_def(void 0);
                    generalize_structure$1(current_level.contents, ty);
                  }
                  var match$10 = enter_val(cl_num, vars, false, lab.txt, mut, /* Virtual */0, ty, val_env, met_env, par_env, loc);
                  var met_env$prime$1 = match$10[2];
                  var id$1 = match$10[0];
                  return /* tuple */[
                          match$10[1],
                          met_env$prime$1,
                          match$10[3],
                          /* :: */[
                            Caml_obj.caml_lazy_make((function (param) {
                                    return mkcf(/* Tcf_val */Block.__(1, [
                                                  lab,
                                                  mut,
                                                  id$1,
                                                  /* Tcfk_virtual */Block.__(0, [cty]),
                                                  met_env === met_env$prime$1
                                                ]));
                                  })),
                            fields
                          ],
                          concr_meths,
                          warn_vals,
                          inher,
                          local_meths,
                          local_vals
                        ];
                }
            case /* Pcf_method */2 :
                var match$11 = match[0];
                var match$12 = match$11[2];
                var priv = match$11[1];
                var lab$1 = match$11[0];
                if (match$12.tag) {
                  var expr = match$12[1];
                  var ovf$2 = match$12[0];
                  var match$13 = expr.pexp_desc;
                  var expr$1;
                  expr$1 = match$13.tag === /* Pexp_poly */28 ? expr : Curry._4(Ast_helper_Exp.poly, expr.pexp_loc, void 0, expr, void 0);
                  if (mem$2(lab$1.txt, local_meths)) {
                    throw [
                          $$Error$9,
                          loc,
                          val_env,
                          /* Duplicate */Block.__(24, [
                              "method",
                              lab$1.txt
                            ])
                        ];
                  }
                  if (mem$2(lab$1.txt, concr_meths)) {
                    if (ovf$2 === /* Fresh */1) {
                      prerr_warning(loc, /* Method_override */Block.__(2, [/* :: */[
                                lab$1.txt,
                                /* [] */0
                              ]]));
                    }
                    
                  } else if (ovf$2 === /* Override */0) {
                    throw [
                          $$Error$9,
                          loc,
                          val_env,
                          /* No_overriding */Block.__(23, [
                              "method",
                              lab$1.txt
                            ])
                        ];
                  }
                  var match$14 = filter_self_method(val_env, lab$1.txt, priv, meths, self_type);
                  var ty$1 = match$14[1];
                  try {
                    var match$15 = expr$1.pexp_desc;
                    if (match$15.tag !== /* Pexp_poly */28) {
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            /* tuple */[
                              "typeclass.ml",
                              664,
                              13
                            ]
                          ];
                    }
                    var sty = match$15[1];
                    var sbody = match$15[0];
                    if (sty !== void 0) {
                      var sty$1 = force_poly(sty);
                      var cty$prime = transl_simple_type(val_env, false, sty$1);
                      var ty$prime = cty$prime.ctyp_type;
                      unify$2(val_env, ty$prime, ty$1);
                    }
                    var match$16 = repr(ty$1).desc;
                    if (typeof match$16 === "number") {
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            /* tuple */[
                              "typeclass.ml",
                              662,
                              17
                            ]
                          ];
                    }
                    switch (match$16.tag | 0) {
                      case /* Tvar */0 :
                          var ty$prime$1 = newvar(void 0, void 0);
                          unify$2(val_env, newty2(current_level.contents, /* Tpoly */Block.__(10, [
                                      ty$prime$1,
                                      /* [] */0
                                    ])), ty$1);
                          unify$2(val_env, type_approx(val_env, sbody), ty$prime$1);
                          break;
                      case /* Tpoly */10 :
                          var match$17 = instance_poly(void 0, false, match$16[1], match$16[0]);
                          var ty2 = type_approx(val_env, sbody);
                          unify$2(val_env, ty2, match$17[1]);
                          break;
                      default:
                        throw [
                              Caml_builtin_exceptions.assert_failure,
                              /* tuple */[
                                "typeclass.ml",
                                662,
                                17
                              ]
                            ];
                    }
                  }
                  catch (raw_exn$1){
                    var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
                    if (exn$1[0] === Unify) {
                      throw [
                            $$Error$9,
                            loc,
                            val_env,
                            /* Field_type_mismatch */Block.__(1, [
                                "method",
                                lab$1.txt,
                                exn$1[1]
                              ])
                          ];
                    }
                    throw exn$1;
                  }
                  var meth_expr = make_method(self_loc, cl_num, expr$1);
                  var vars_local = vars.contents;
                  var field = Caml_obj.caml_lazy_make((function (param) {
                          var meth_type = newty2(100000000, /* Tarrow */Block.__(1, [
                                  "",
                                  self_type,
                                  ty$1,
                                  /* Cok */0
                                ]));
                          raise_nongen_level(void 0);
                          vars.contents = vars_local;
                          var texp = type_expect(void 0, met_env, meth_expr, meth_type);
                          end_def(void 0);
                          return mkcf(/* Tcf_method */Block.__(2, [
                                        lab$1,
                                        priv,
                                        /* Tcfk_concrete */Block.__(1, [
                                            ovf$2,
                                            texp
                                          ])
                                      ]));
                        }));
                  return /* tuple */[
                          val_env,
                          met_env,
                          par_env,
                          /* :: */[
                            field,
                            fields
                          ],
                          add$2(lab$1.txt, concr_meths),
                          warn_vals,
                          inher,
                          add$2(lab$1.txt, local_meths),
                          local_vals
                        ];
                } else {
                  var cty$1 = virtual_method(val_env, meths, self_type, lab$1.txt, priv, match$12[0], loc);
                  return /* tuple */[
                          val_env,
                          met_env,
                          par_env,
                          /* :: */[
                            Caml_obj.caml_lazy_make((function (param) {
                                    return mkcf(/* Tcf_method */Block.__(2, [
                                                  lab$1,
                                                  priv,
                                                  /* Tcfk_virtual */Block.__(0, [cty$1])
                                                ]));
                                  })),
                            fields
                          ],
                          concr_meths,
                          warn_vals,
                          inher,
                          local_meths,
                          local_vals
                        ];
                }
            case /* Pcf_constraint */3 :
                var match$18 = match[0];
                var match$19 = type_constraint(val_env, match$18[0], match$18[1], loc);
                var cty$prime$1 = match$19[1];
                var cty$2 = match$19[0];
                return /* tuple */[
                        val_env,
                        met_env,
                        par_env,
                        /* :: */[
                          Caml_obj.caml_lazy_make((function (param) {
                                  return mkcf(/* Tcf_constraint */Block.__(3, [
                                                cty$2,
                                                cty$prime$1
                                              ]));
                                })),
                          fields
                        ],
                        concr_meths,
                        warn_vals,
                        inher,
                        local_meths,
                        local_vals
                      ];
            case /* Pcf_initializer */4 :
                var expr$2 = make_method(self_loc, cl_num, match[0]);
                var vars_local$1 = vars.contents;
                var field$1 = Caml_obj.caml_lazy_make((function (param) {
                        raise_nongen_level(void 0);
                        var desc_002 = instance_def(type_unit);
                        var desc = /* Tarrow */Block.__(1, [
                            "",
                            self_type,
                            desc_002,
                            /* Cok */0
                          ]);
                        var meth_type = newty2(current_level.contents, desc);
                        vars.contents = vars_local$1;
                        var texp = type_expect(void 0, met_env, expr$2, meth_type);
                        end_def(void 0);
                        return mkcf(/* Tcf_initializer */Block.__(4, [texp]));
                      }));
                return /* tuple */[
                        val_env,
                        met_env,
                        par_env,
                        /* :: */[
                          field$1,
                          fields
                        ],
                        concr_meths,
                        warn_vals,
                        inher,
                        local_meths,
                        local_vals
                      ];
            case /* Pcf_attribute */5 :
                var x = match[0];
                warning_attribute(/* :: */[
                      x,
                      /* [] */0
                    ]);
                return /* tuple */[
                        val_env,
                        met_env,
                        par_env,
                        /* :: */[
                          Caml_obj.caml_lazy_make((function (param) {
                                  return mkcf(/* Tcf_attribute */Block.__(5, [x]));
                                })),
                          fields
                        ],
                        concr_meths,
                        warn_vals,
                        inher,
                        local_meths,
                        local_vals
                      ];
            case /* Pcf_extension */6 :
                throw [
                      Error_forward$2,
                      error_of_extension(match[0])
                    ];
            
          }
        }), /* tuple */[
        val_env$1,
        match[4],
        match[5],
        /* [] */0,
        /* Empty */0,
        /* Empty */0,
        /* [] */0,
        /* Empty */0,
        /* Empty */0
      ], param.pcstr_fields);
  var inher = match$1[6];
  var concr_meths = match$1[4];
  warning_leave_scope(void 0);
  unify$2(val_env$1, self_type, newvar(void 0, void 0));
  var sign_csig_vars = map((function (param) {
          return /* tuple */[
                  param[1],
                  param[2],
                  param[3]
                ];
        }), vars.contents);
  var sign = {
    csig_self: public_self,
    csig_vars: sign_csig_vars,
    csig_concr: concr_meths,
    csig_inher: inher
  };
  var methods = get_methods(self_type);
  var priv_meths = List.filter((function (param) {
            return field_kind_repr(param[1]) !== /* Fpresent */0;
          }))(methods);
  if ($$final) {
    close_object(self_type);
    var mets = virtual_methods({
          csig_self: self_type,
          csig_vars: sign_csig_vars,
          csig_concr: concr_meths,
          csig_inher: inher
        });
    var vals = fold((function (name, param, l) {
            if (param[1] === /* Virtual */0) {
              return /* :: */[
                      name,
                      l
                    ];
            } else {
              return l;
            }
          }), sign_csig_vars, /* [] */0);
    if (mets !== /* [] */0 || vals !== /* [] */0) {
      throw [
            $$Error$9,
            loc,
            val_env$1,
            /* Virtual_class */Block.__(10, [
                true,
                $$final,
                mets,
                vals
              ])
          ];
    }
    var self_methods = List.fold_right((function (param, rem) {
            var kind = param[1];
            var lab = param[0];
            if (lab === dummy_method) {
              var match = field_kind_repr(kind);
              if (typeof match === "number") {
                return rem;
              } else {
                set_kind(match[0], /* Fabsent */1);
                return rem;
              }
            } else {
              var desc_001 = copy_kind(kind);
              var desc_002 = param[2];
              var desc = /* Tfield */Block.__(5, [
                  lab,
                  desc_001,
                  desc_002,
                  rem
                ]);
              return newty2(current_level.contents, desc);
            }
          }), methods, newty2(current_level.contents, /* Tnil */0));
    try {
      unify$2(val_env$1, private_self, newty2(current_level.contents, /* Tobject */Block.__(4, [
                  self_methods,
                  {
                    contents: void 0
                  }
                ])));
      unify$2(val_env$1, public_self, self_type);
    }
    catch (raw_exn$1){
      var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
      if (exn$1[0] === Unify) {
        throw [
              $$Error$9,
              loc,
              val_env$1,
              /* Final_self_clash */Block.__(21, [exn$1[1]])
            ];
      }
      throw exn$1;
    }
  }
  if (principal.contents) {
    List.iter((function (param) {
            return generalize_spine(param[2]);
          }), methods);
  }
  var fields = List.map(CamlinternalLazy.force, List.rev(match$1[3]));
  if (principal.contents) {
    List.iter((function (param) {
            return unify$2(val_env$1, param[2], newvar(void 0, void 0));
          }), methods);
  }
  var meths$1 = map((function (param) {
          return param[0];
        }), meths.contents);
  var pub_meths$prime = List.filter((function (param) {
            return field_kind_repr(param[1]) === /* Fpresent */0;
          }))(get_methods(public_self));
  var names = function (param) {
    return List.map((function (param) {
                  return param[0];
                }), param);
  };
  var l1 = names(priv_meths);
  var l2 = names(pub_meths$prime);
  var added = List.filter((function (x) {
            return List.mem(x, l1);
          }))(l2);
  if (added !== /* [] */0) {
    prerr_warning(loc, /* Implicit_public_methods */Block.__(6, [added]));
  }
  var sign$1 = $$final ? sign : ({
        csig_self: expand_head(val_env$1, public_self),
        csig_vars: sign_csig_vars,
        csig_concr: concr_meths,
        csig_inher: inher
      });
  return /* tuple */[
          {
            cstr_self: pat,
            cstr_fields: fields,
            cstr_type: sign$1,
            cstr_meths: meths$1
          },
          sign$1
        ];
}

function class_expr(cl_num, val_env, met_env, _scl) {
  while(true) {
    var scl = _scl;
    var match = scl.pcl_desc;
    switch (match.tag | 0) {
      case /* Pcl_constr */0 :
          var lid = match[0];
          var match$1 = find_class$1(val_env, scl.pcl_loc, lid.txt);
          var decl = match$1[1];
          var path = match$1[0];
          if (same(decl.cty_path, unbound_class)) {
            throw [
                  $$Error$9,
                  scl.pcl_loc,
                  val_env,
                  /* Unbound_class_2 */Block.__(6, [lid.txt])
                ];
          }
          var tyl = List.map((function (sty) {
                  return transl_simple_type(val_env, false, sty);
                }), match[1]);
          var match$2 = instance_class(decl.cty_params, decl.cty_type);
          var clty = match$2[1];
          var params = match$2[0];
          var clty$prime = abbreviate_class_type(path, params, clty);
          if (List.length(params) !== List.length(tyl)) {
            throw [
                  $$Error$9,
                  scl.pcl_loc,
                  val_env,
                  /* Parameter_arity_mismatch */Block.__(11, [
                      lid.txt,
                      List.length(params),
                      List.length(tyl)
                    ])
                ];
          }
          List.iter2((function (cty$prime, ty) {
                  var ty$prime = cty$prime.ctyp_type;
                  try {
                    return unify$2(val_env, ty$prime, ty);
                  }
                  catch (raw_exn){
                    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                    if (exn[0] === Unify) {
                      throw [
                            $$Error$9,
                            cty$prime.ctyp_loc,
                            val_env,
                            /* Parameter_mismatch */Block.__(12, [exn[1]])
                          ];
                    }
                    throw exn;
                  }
                }), tyl, params);
          var cl = rc({
                cl_desc: /* Tcl_ident */Block.__(0, [
                    path,
                    lid,
                    tyl
                  ]),
                cl_loc: scl.pcl_loc,
                cl_type: clty$prime,
                cl_env: val_env,
                cl_attributes: scl.pcl_attributes
              });
          var match$3 = extract_constraints(clty);
          return rc({
                      cl_desc: /* Tcl_constraint */Block.__(5, [
                          cl,
                          void 0,
                          match$3[0],
                          match$3[1],
                          match$3[2]
                        ]),
                      cl_loc: scl.pcl_loc,
                      cl_type: clty$prime,
                      cl_env: val_env,
                      cl_attributes: /* [] */0
                    });
      case /* Pcl_structure */1 :
          var match$4 = class_structure(cl_num, false, val_env, met_env, scl.pcl_loc, match[0]);
          return rc({
                      cl_desc: /* Tcl_structure */Block.__(1, [match$4[0]]),
                      cl_loc: scl.pcl_loc,
                      cl_type: /* Cty_signature */Block.__(1, [match$4[1]]),
                      cl_env: val_env,
                      cl_attributes: scl.pcl_attributes
                    });
      case /* Pcl_fun */2 :
          var match$5 = match[1];
          var l = match[0];
          if (match$5 !== void 0) {
            var $$default = match$5;
            var loc = $$default.pexp_loc;
            var scases_000 = Curry._3(Ast_helper_Exp.$$case, construct(loc, void 0, {
                      txt: /* Ldot */Block.__(1, [
                          /* Lident */Block.__(0, ["*predef*"]),
                          "Some"
                        ]),
                      loc: none
                    }, $$var$1(loc, void 0, {
                          txt: "*sth*",
                          loc: none
                        })), void 0, Curry._3(Ast_helper_Exp.ident, loc, void 0, {
                      txt: /* Lident */Block.__(0, ["*sth*"]),
                      loc: none
                    }));
            var scases_001 = /* :: */[
              Curry._3(Ast_helper_Exp.$$case, construct(loc, void 0, {
                        txt: /* Ldot */Block.__(1, [
                            /* Lident */Block.__(0, ["*predef*"]),
                            "None"
                          ]),
                        loc: none
                      }, void 0), void 0, $$default),
              /* [] */0
            ];
            var scases = /* :: */[
              scases_000,
              scases_001
            ];
            var smatch = Curry._4(Ast_helper_Exp.match_, loc, void 0, Curry._3(Ast_helper_Exp.ident, loc, void 0, {
                      txt: /* Lident */Block.__(0, ["*opt*"]),
                      loc: none
                    }), scases);
            var sfun = fun_$1(scl.pcl_loc, void 0, l, void 0, $$var$1(loc, void 0, {
                      txt: "*opt*",
                      loc: none
                    }), let_$1(scl.pcl_loc, void 0, /* Nonrecursive */0, /* :: */[
                      mk$17(void 0, void 0, void 0, void 0, match[2], smatch),
                      /* [] */0
                    ], match[3]));
            _scl = sfun;
            continue ;
          } else {
            if (principal.contents) {
              begin_def(void 0);
            }
            var match$6 = type_class_arg_pattern(cl_num, val_env, met_env, l, match[2]);
            var val_env$prime = match$6[2];
            var pat = match$6[0];
            if (principal.contents) {
              end_def(void 0);
              iter_pattern((function (param) {
                      return generalize_structure$1(current_level.contents, param.pat_type);
                    }), pat);
            }
            var pv = List.map((function(val_env$prime){
                return function (param) {
                  var id = param[0];
                  var path = /* Pident */Block.__(0, [param[2]]);
                  var vd = find_value(path, val_env$prime);
                  return /* tuple */[
                          id,
                          param[1],
                          {
                            exp_desc: /* Texp_ident */Block.__(0, [
                                path,
                                {
                                  txt: /* Lident */Block.__(0, [id.name]),
                                  loc: none
                                },
                                vd
                              ]),
                            exp_loc: none,
                            exp_extra: /* [] */0,
                            exp_type: instance(void 0, val_env$prime, vd.val_type),
                            exp_env: val_env$prime,
                            exp_attributes: /* [] */0
                          }
                        ];
                }
                }(val_env$prime)), match$6[1]);
            var not_function = function (param) {
              switch (param.tag | 0) {
                case /* Cty_constr */0 :
                case /* Cty_signature */1 :
                    return true;
                case /* Cty_arrow */2 :
                    return false;
                
              }
            };
            var partial = check_partial$1(void 0, val_env, pat.pat_type)(pat.pat_loc, /* :: */[
                  {
                    c_lhs: pat,
                    c_guard: void 0,
                    c_rhs: {
                      exp_desc: /* Texp_constant */Block.__(1, [/* Const_int */Block.__(0, [1])]),
                      exp_loc: none,
                      exp_extra: /* [] */0,
                      exp_type: none$2,
                      exp_env: empty,
                      exp_attributes: /* [] */0
                    }
                  },
                  /* [] */0
                ]);
            raise_nongen_level(void 0);
            var cl$1 = class_expr(cl_num, val_env$prime, match$6[3], match[3]);
            end_def(void 0);
            if (is_optional(l) && not_function(cl$1.cl_type)) {
              prerr_warning(pat.pat_loc, /* Unerasable_optional_argument */8);
            }
            return rc({
                        cl_desc: /* Tcl_fun */Block.__(2, [
                            l,
                            pat,
                            pv,
                            cl$1,
                            partial
                          ]),
                        cl_loc: scl.pcl_loc,
                        cl_type: /* Cty_arrow */Block.__(2, [
                            l,
                            instance_def(pat.pat_type),
                            cl$1.cl_type
                          ]),
                        cl_env: val_env,
                        cl_attributes: scl.pcl_attributes
                      });
          }
      case /* Pcl_apply */3 :
          var sargs = match[1];
          if (sargs === /* [] */0) {
            ill_formed_ast(scl.pcl_loc, "Function application with no argument.");
          }
          if (principal.contents) {
            begin_def(void 0);
          }
          var cl$2 = class_expr(cl_num, val_env, met_env, match[0]);
          if (principal.contents) {
            end_def(void 0);
            ((function (param) {
                    return generalize_class_type(generalize_structure$2, param);
                  })(cl$2.cl_type));
          }
          var nonopt_labels = function (_ls, _ty_fun) {
            while(true) {
              var ty_fun = _ty_fun;
              var ls = _ls;
              switch (ty_fun.tag | 0) {
                case /* Cty_constr */0 :
                case /* Cty_signature */1 :
                    return ls;
                case /* Cty_arrow */2 :
                    var ty_res = ty_fun[2];
                    var l = ty_fun[0];
                    if (is_optional(l)) {
                      _ty_fun = ty_res;
                      continue ;
                    } else {
                      _ty_fun = ty_res;
                      _ls = /* :: */[
                        l,
                        ls
                      ];
                      continue ;
                    }
                
              }
            };
          };
          var ignore_labels = true;
          if (!classic.contents) {
            var labels = nonopt_labels(/* [] */0, cl$2.cl_type);
            ignore_labels = List.length(labels) === List.length(sargs) && List.for_all((function (param) {
                    return param[0] === "";
                  }), sargs) && List.exists((function (l) {
                    return l !== "";
                  }), labels) && (prerr_warning(cl$2.cl_loc, /* Labels_omitted */3), true);
          }
          var type_args = (function(cl$2,ignore_labels){
          return function type_args(_args, _omitted, _ty_fun, _ty_fun0, _sargs, _more_sargs) {
            while(true) {
              var more_sargs = _more_sargs;
              var sargs = _sargs;
              var ty_fun0 = _ty_fun0;
              var ty_fun = _ty_fun;
              var omitted = _omitted;
              var args = _args;
              switch (ty_fun.tag | 0) {
                case /* Cty_constr */0 :
                case /* Cty_signature */1 :
                    break;
                case /* Cty_arrow */2 :
                    var ty = ty_fun[1];
                    var l = ty_fun[0];
                    switch (ty_fun0.tag | 0) {
                      case /* Cty_constr */0 :
                      case /* Cty_signature */1 :
                          break;
                      case /* Cty_arrow */2 :
                          if (sargs !== /* [] */0 || more_sargs !== /* [] */0) {
                            var ty0 = ty_fun0[1];
                            var name = label_name(l);
                            var optional = is_optional(l) ? /* Optional */1 : /* Required */0;
                            var match;
                            if (ignore_labels && !is_optional(l)) {
                              if (sargs) {
                                var match$1 = sargs[0];
                                throw [
                                      $$Error$9,
                                      match$1[1].pexp_loc,
                                      val_env,
                                      /* Apply_wrong_label */Block.__(4, [match$1[0]])
                                    ];
                              } else {
                                if (!more_sargs) {
                                  throw [
                                        Caml_builtin_exceptions.assert_failure,
                                        /* tuple */[
                                          "typeclass.ml",
                                          1017,
                                          20
                                        ]
                                      ];
                                }
                                var match$2 = more_sargs[0];
                                var sarg0 = match$2[1];
                                var l$prime = match$2[0];
                                if (l !== l$prime && l$prime !== "") {
                                  throw [
                                        $$Error$9,
                                        sarg0.pexp_loc,
                                        val_env,
                                        /* Apply_wrong_label */Block.__(4, [l$prime])
                                      ];
                                }
                                match = /* tuple */[
                                  /* [] */0,
                                  more_sargs[1],
                                  type_argument(val_env, sarg0, ty, ty0)
                                ];
                              }
                            } else {
                              try {
                                var match$3;
                                try {
                                  var match$4 = extract_label_aux(/* [] */0, name, sargs);
                                  match$3 = /* tuple */[
                                    match$4[0],
                                    match$4[1],
                                    Pervasives.$at(match$4[2], match$4[3]),
                                    more_sargs
                                  ];
                                }
                                catch (exn){
                                  if (exn !== Caml_builtin_exceptions.not_found) {
                                    throw exn;
                                  }
                                  var match$5 = extract_label_aux(/* [] */0, name, more_sargs);
                                  match$3 = /* tuple */[
                                    match$5[0],
                                    match$5[1],
                                    Pervasives.$at(sargs, match$5[2]),
                                    match$5[3]
                                  ];
                                }
                                var sarg0$1 = match$3[1];
                                var l$prime$1 = match$3[0];
                                if (optional === /* Required */0 && is_optional(l$prime$1)) {
                                  prerr_warning(sarg0$1.pexp_loc, /* Nonoptional_label */Block.__(26, [l]));
                                }
                                var tmp;
                                if (optional === /* Required */0 || is_optional(l$prime$1)) {
                                  tmp = type_argument(val_env, sarg0$1, ty, ty0);
                                } else {
                                  var ty$prime = extract_option_type(val_env, ty);
                                  var ty0$prime = extract_option_type(val_env, ty0);
                                  var arg = type_argument(val_env, sarg0$1, ty$prime, ty0$prime);
                                  tmp = option_some(arg);
                                }
                                match = /* tuple */[
                                  match$3[2],
                                  match$3[3],
                                  tmp
                                ];
                              }
                              catch (exn$1){
                                if (exn$1 !== Caml_builtin_exceptions.not_found) {
                                  throw exn$1;
                                }
                                match = /* tuple */[
                                  sargs,
                                  more_sargs,
                                  is_optional(l) && (List.mem_assoc("", sargs) || List.mem_assoc("", more_sargs)) ? option_none(ty0, none) : void 0
                                ];
                              }
                            }
                            var arg$1 = match[2];
                            var omitted$1 = arg$1 === void 0 ? /* :: */[
                                /* tuple */[
                                  l,
                                  ty0
                                ],
                                omitted
                              ] : omitted;
                            _more_sargs = match[1];
                            _sargs = match[0];
                            _ty_fun0 = ty_fun0[2];
                            _ty_fun = ty_fun[2];
                            _omitted = omitted$1;
                            _args = /* :: */[
                              /* tuple */[
                                l,
                                arg$1,
                                optional
                              ],
                              args
                            ];
                            continue ;
                          }
                          break;
                      
                    }
                    break;
                
              }
              var match$6 = Pervasives.$at(sargs, more_sargs);
              if (!match$6) {
                return /* tuple */[
                        List.rev(args),
                        List.fold_left((function (ty_fun, param) {
                                return /* Cty_arrow */Block.__(2, [
                                          param[0],
                                          param[1],
                                          ty_fun
                                        ]);
                              }), ty_fun0, omitted)
                      ];
              }
              if (omitted === /* [] */0) {
                throw [
                      $$Error$9,
                      cl$2.cl_loc,
                      val_env,
                      /* Cannot_apply */Block.__(3, [cl$2.cl_type])
                    ];
              }
              var match$7 = match$6[0];
              throw [
                    $$Error$9,
                    match$7[1].pexp_loc,
                    val_env,
                    /* Apply_wrong_label */Block.__(4, [match$7[0]])
                  ];
            };
          }
          }(cl$2,ignore_labels));
          var match$7 = instance_class(/* [] */0, cl$2.cl_type);
          var ty_fun0 = match$7[1];
          var match$8 = ignore_labels ? type_args(/* [] */0, /* [] */0, cl$2.cl_type, ty_fun0, /* [] */0, sargs) : type_args(/* [] */0, /* [] */0, cl$2.cl_type, ty_fun0, sargs, /* [] */0);
          return rc({
                      cl_desc: /* Tcl_apply */Block.__(3, [
                          cl$2,
                          match$8[0]
                        ]),
                      cl_loc: scl.pcl_loc,
                      cl_type: match$8[1],
                      cl_env: val_env,
                      cl_attributes: scl.pcl_attributes
                    });
      case /* Pcl_let */4 :
          var rec_flag = match[0];
          var match$9;
          try {
            match$9 = type_let$1(val_env, rec_flag, match[1], void 0);
          }
          catch (raw_exn){
            var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn[0] !== Unify) {
              throw exn;
            }
            var match$10 = exn[1];
            if (!match$10) {
              throw exn;
            }
            if (match$10[1]) {
              throw exn;
            }
            throw [
                  $$Error$9,
                  scl.pcl_loc,
                  val_env,
                  /* Make_nongen_seltype */Block.__(17, [match$10[0][0]])
                ];
          }
          var val_env$1 = match$9[1];
          var defs = match$9[0];
          var match$11 = List.fold_right((function(val_env$1){
              return function (param, param$1) {
                var id = param[0];
                var path = /* Pident */Block.__(0, [id]);
                var vd = find_value(path, val_env$1);
                begin_def(void 0);
                var expr_exp_desc = /* Texp_ident */Block.__(0, [
                    path,
                    {
                      txt: /* Lident */Block.__(0, [id.name]),
                      loc: none
                    },
                    vd
                  ]);
                var expr_exp_type = instance(void 0, val_env$1, vd.val_type);
                var expr = {
                  exp_desc: expr_exp_desc,
                  exp_loc: none,
                  exp_extra: /* [] */0,
                  exp_type: expr_exp_type,
                  exp_env: val_env$1,
                  exp_attributes: /* [] */0
                };
                end_def(void 0);
                iter_generalize$1({
                      contents: /* [] */0
                    }, expr_exp_type);
                var desc_val_type = expr_exp_type;
                var desc_val_kind = /* Val_ivar */Block.__(1, [
                    /* Immutable */0,
                    cl_num
                  ]);
                var desc_val_loc = vd.val_loc;
                var desc = {
                  val_type: desc_val_type,
                  val_kind: desc_val_kind,
                  val_loc: desc_val_loc,
                  val_attributes: /* [] */0
                };
                var id$prime = create(id.name);
                return /* tuple */[
                        /* :: */[
                          /* tuple */[
                            id$prime,
                            param[1],
                            expr
                          ],
                          param$1[0]
                        ],
                        add_value(void 0, id$prime, desc, param$1[1])
                      ];
              }
              }(val_env$1)), List.rev(rev_let_bound_idents_with_loc(defs)), /* tuple */[
                /* [] */0,
                met_env
              ]);
          var cl$3 = class_expr(cl_num, val_env$1, match$11[1], match[2]);
          return rc({
                      cl_desc: /* Tcl_let */Block.__(4, [
                          rec_flag,
                          defs,
                          match$11[0],
                          cl$3
                        ]),
                      cl_loc: scl.pcl_loc,
                      cl_type: cl$3.cl_type,
                      cl_env: val_env$1,
                      cl_attributes: scl.pcl_attributes
                    });
      case /* Pcl_constraint */5 :
          begin_class_def(void 0);
          var context = narrow(void 0);
          var cl$4 = class_expr(cl_num, val_env, met_env, match[0]);
          widen(context);
          var context$1 = narrow(void 0);
          var clty$1 = class_type$4(val_env, match[1]);
          widen(context$1);
          end_def(void 0);
          limited_generalize$1(row_variable(repr(signature_of_class_type(cl$4.cl_type).csig_self)), cl$4.cl_type);
          limited_generalize$1(row_variable(repr(signature_of_class_type(clty$1.cltyp_type).csig_self)), clty$1.cltyp_type);
          var error = class_types(val_env, cl$4.cl_type, clty$1.cltyp_type);
          if (error) {
            throw [
                  $$Error$9,
                  cl$4.cl_loc,
                  val_env,
                  /* Class_match_failure */Block.__(14, [error])
                ];
          }
          var match$12 = extract_constraints(clty$1.cltyp_type);
          return rc({
                      cl_desc: /* Tcl_constraint */Block.__(5, [
                          cl$4,
                          clty$1,
                          match$12[0],
                          match$12[1],
                          match$12[2]
                        ]),
                      cl_loc: scl.pcl_loc,
                      cl_type: instance_class(/* [] */0, clty$1.cltyp_type)[1],
                      cl_env: val_env,
                      cl_attributes: scl.pcl_attributes
                    });
      case /* Pcl_extension */6 :
          throw [
                Error_forward$2,
                error_of_extension(match[0])
              ];
      
    }
  };
}

var var_option = type_option(newty2(100000000, /* Tvar */Block.__(0, [void 0])));

function approx_declaration(_cl) {
  while(true) {
    var cl = _cl;
    var match = cl.pcl_desc;
    switch (match.tag | 0) {
      case /* Pcl_fun */2 :
          var l = match[0];
          var arg = is_optional(l) ? instance_def(var_option) : newvar(void 0, void 0);
          var desc_002 = approx_declaration(match[3]);
          var desc = /* Tarrow */Block.__(1, [
              l,
              arg,
              desc_002,
              /* Cok */0
            ]);
          return newty2(current_level.contents, desc);
      case /* Pcl_let */4 :
          _cl = match[2];
          continue ;
      case /* Pcl_constraint */5 :
          _cl = match[0];
          continue ;
      default:
        return newvar(void 0, void 0);
    }
  };
}

function approx_description(ct) {
  var match = ct.pcty_desc;
  if (match.tag !== /* Pcty_arrow */2) {
    return newvar(void 0, void 0);
  }
  var l = match[0];
  var arg = is_optional(l) ? instance_def(var_option) : newvar(void 0, void 0);
  var desc_002 = approx_description(match[2]);
  var desc = /* Tarrow */Block.__(1, [
      l,
      arg,
      desc_002,
      /* Cok */0
    ]);
  return newty2(current_level.contents, desc);
}

function temp_abbrev(loc, env, id, arity) {
  var params = /* [] */0;
  for(var _i = 1; _i <= arity; ++_i){
    params = /* :: */[
      newvar(void 0, void 0),
      params
    ];
  }
  var ty = newobj(newvar(void 0, void 0));
  var env$1 = add_type$1(true, id, {
        type_params: params,
        type_arity: arity,
        type_kind: /* Type_abstract */0,
        type_private: /* Public */1,
        type_manifest: ty,
        type_variance: replicate_list(Types_Variance.full, arity),
        type_newtype_level: void 0,
        type_loc: loc,
        type_attributes: /* [] */0
      }, env);
  return /* tuple */[
          params,
          ty,
          env$1
        ];
}

function extract_type_decls(param, decls) {
  return /* :: */[
          /* tuple */[
            param[5],
            param[6],
            param[8],
            param[2],
            param[4],
            param[13]
          ],
          decls
        ];
}

function merge_type_decls(param, param$1) {
  return /* tuple */[
          param[0],
          param[1],
          param$1[2],
          param[3],
          param$1[3],
          param[5],
          param$1[0],
          param[7],
          param$1[1],
          param[9],
          param[10],
          param[11],
          param[12],
          param[13]
        ];
}

function type_classes(define_class, approx, kind, env, cls) {
  var cls$1 = List.map((function (cl) {
          return /* tuple */[
                  cl,
                  create(cl.pci_name.txt),
                  create(cl.pci_name.txt),
                  create(cl.pci_name.txt),
                  create("#" + cl.pci_name.txt)
                ];
        }), cls);
  init_def(currentstamp.contents);
  begin_class_def(void 0);
  var match = List.fold_left((function (param, param$1) {
          var cl_id = param$1[4];
          var obj_id = param$1[3];
          var ty_id = param$1[2];
          var id = param$1[1];
          var cl = param$1[0];
          var arity = List.length(cl.pci_params);
          var match = temp_abbrev(cl.pci_loc, param[1], obj_id, arity);
          var match$1 = temp_abbrev(cl.pci_loc, match[2], cl_id, arity);
          var env = match$1[2];
          var constr_type = Curry._1(approx, cl.pci_expr);
          if (principal.contents) {
            generalize_spine(constr_type);
          }
          var dummy_cty = /* Cty_signature */Block.__(1, [{
                csig_self: newvar(void 0, void 0),
                csig_vars: /* Empty */0,
                csig_concr: /* Empty */0,
                csig_inher: /* [] */0
              }]);
          var match$2 = cl.pci_virt;
          var dummy_class = {
            cty_params: /* [] */0,
            cty_type: dummy_cty,
            cty_path: unbound_class,
            cty_new: match$2 ? constr_type : void 0,
            cty_variance: /* [] */0,
            cty_loc: none,
            cty_attributes: /* [] */0
          };
          var env$1 = add_cltype(ty_id, {
                clty_params: /* [] */0,
                clty_type: dummy_cty,
                clty_path: unbound_class,
                clty_variance: /* [] */0,
                clty_loc: none,
                clty_attributes: /* [] */0
              }, define_class ? add_class(id, dummy_class, env) : env);
          return /* tuple */[
                  /* :: */[
                    /* tuple */[
                      cl,
                      id,
                      ty_id,
                      obj_id,
                      match[0],
                      match[1],
                      cl_id,
                      match$1[0],
                      match$1[1],
                      constr_type,
                      dummy_class
                    ],
                    param[0]
                  ],
                  env$1
                ];
        }), /* tuple */[
        /* [] */0,
        env
      ], cls$1);
  var match$1 = List.fold_right((function (param, param$1) {
          var env = param$1[1];
          var constr_type = param[9];
          var cl_ty = param[8];
          var cl_params = param[7];
          var cl_id = param[6];
          var obj_ty = param[5];
          var obj_params = param[4];
          var obj_id = param[3];
          var ty_id = param[2];
          var id = param[1];
          var cl = param[0];
          reset_type_variables(void 0);
          begin_class_def(void 0);
          var make_param = function (param) {
            var sty = param[0];
            try {
              return /* tuple */[
                      transl_type_param(env, sty),
                      param[1]
                    ];
            }
            catch (exn){
              if (exn === Already_bound) {
                throw [
                      $$Error$9,
                      sty.ptyp_loc,
                      env,
                      /* Repeated_parameter */0
                    ];
              }
              throw exn;
            }
          };
          var ci_params = List.map(make_param, cl.pci_params);
          var params = List.map((function (param) {
                  return param[0].ctyp_type;
                }), ci_params);
          var coercion_locs = {
            contents: /* [] */0
          };
          var match;
          try {
            self_coercion.contents = /* :: */[
              /* tuple */[
                /* Pident */Block.__(0, [obj_id]),
                coercion_locs
              ],
              self_coercion.contents
            ];
            var res = Curry._2(kind, env, cl.pci_expr);
            self_coercion.contents = List.tl(self_coercion.contents);
            match = res;
          }
          catch (exn){
            self_coercion.contents = /* [] */0;
            throw exn;
          }
          var typ = match[1];
          end_def(void 0);
          var sty = repr(signature_of_class_type(typ).csig_self);
          var match$1 = flatten_fields(object_fields(sty));
          List.iter((function (param) {
                  if (param[0] === dummy_method) {
                    return iter_generalize$1({
                                contents: /* [] */0
                              }, param[2]);
                  }
                  
                }), match$1[0]);
          var rv = row_variable(sty);
          List.iter((function (param) {
                  return limited_generalize(rv, param);
                }), params);
          limited_generalize$1(rv, typ);
          var match$2 = instance_class(params, typ);
          var obj_type = match$2[1];
          var obj_params$prime = match$2[0];
          var constr = newconstr(/* Pident */Block.__(0, [obj_id]), obj_params);
          var ty = repr(signature_of_class_type(obj_type).csig_self);
          hide_private_methods(ty);
          close_object(ty);
          try {
            List.iter2((function (param, param$1) {
                    return unify$2(env, param, param$1);
                  }), obj_params, obj_params$prime);
          }
          catch (raw_exn){
            var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn$1[0] === Unify) {
              throw [
                    $$Error$9,
                    cl.pci_loc,
                    env,
                    /* Bad_parameters */Block.__(13, [
                        obj_id,
                        constr,
                        newconstr(/* Pident */Block.__(0, [obj_id]), obj_params$prime)
                      ])
                  ];
            }
            throw exn$1;
          }
          try {
            unify$2(env, ty, constr);
          }
          catch (raw_exn$1){
            var exn$2 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
            if (exn$2[0] === Unify) {
              throw [
                    $$Error$9,
                    cl.pci_loc,
                    env,
                    /* Abbrev_type_clash */Block.__(8, [
                        constr,
                        ty,
                        expand_head(env, constr)
                      ])
                  ];
            }
            throw exn$2;
          }
          var match$3 = instance_class(params, typ);
          var cl_params$prime = match$3[0];
          var ty$1 = repr(signature_of_class_type(match$3[1]).csig_self);
          hide_private_methods(ty$1);
          set_object_name(obj_id, row_variable(ty$1), cl_params, ty$1);
          try {
            List.iter2((function (param, param$1) {
                    return unify$2(env, param, param$1);
                  }), cl_params, cl_params$prime);
          }
          catch (raw_exn$2){
            var exn$3 = Caml_js_exceptions.internalToOCamlException(raw_exn$2);
            if (exn$3[0] === Unify) {
              throw [
                    $$Error$9,
                    cl.pci_loc,
                    env,
                    /* Bad_parameters */Block.__(13, [
                        cl_id,
                        newconstr(/* Pident */Block.__(0, [cl_id]), cl_params),
                        newconstr(/* Pident */Block.__(0, [cl_id]), cl_params$prime)
                      ])
                  ];
            }
            throw exn$3;
          }
          try {
            unify$2(env, ty$1, cl_ty);
          }
          catch (raw_exn$3){
            var exn$4 = Caml_js_exceptions.internalToOCamlException(raw_exn$3);
            if (exn$4[0] !== Unify) {
              throw exn$4;
            }
            var constr$1 = newconstr(/* Pident */Block.__(0, [cl_id]), params);
            throw [
                  $$Error$9,
                  cl.pci_loc,
                  env,
                  /* Abbrev_type_clash */Block.__(8, [
                      constr$1,
                      ty$1,
                      cl_ty
                    ])
                ];
          }
          try {
            unify$2(env, constructor_type(constr, obj_type), instance(void 0, env, constr_type));
          }
          catch (raw_exn$4){
            var exn$5 = Caml_js_exceptions.internalToOCamlException(raw_exn$4);
            if (exn$5[0] === Unify) {
              throw [
                    $$Error$9,
                    cl.pci_loc,
                    env,
                    /* Constructor_type_mismatch */Block.__(9, [
                        cl.pci_name.txt,
                        exn$5[1]
                      ])
                  ];
            }
            throw exn$5;
          }
          var cty_variance = List.map((function (param) {
                  return Types_Variance.full;
                }), params);
          var cltydef_clty_type = class_body(typ);
          var cltydef_clty_path = /* Pident */Block.__(0, [obj_id]);
          var cltydef_clty_loc = cl.pci_loc;
          var cltydef_clty_attributes = cl.pci_attributes;
          var cltydef = {
            clty_params: params,
            clty_type: cltydef_clty_type,
            clty_path: cltydef_clty_path,
            clty_variance: cty_variance,
            clty_loc: cltydef_clty_loc,
            clty_attributes: cltydef_clty_attributes
          };
          var match$4 = cl.pci_virt;
          var clty = {
            cty_params: params,
            cty_type: typ,
            cty_path: /* Pident */Block.__(0, [obj_id]),
            cty_new: match$4 ? constr_type : void 0,
            cty_variance: cty_variance,
            cty_loc: cl.pci_loc,
            cty_attributes: cl.pci_attributes
          };
          param[10].cty_type = typ;
          var env$1 = add_cltype(ty_id, cltydef, define_class ? add_class(id, clty, env) : env);
          if (cl.pci_virt === /* Concrete */1) {
            var sign = signature_of_class_type(typ);
            var mets = virtual_methods(sign);
            var vals = fold((function (name, param, l) {
                    if (param[1] === /* Virtual */0) {
                      return /* :: */[
                              name,
                              l
                            ];
                    } else {
                      return l;
                    }
                  }), sign.csig_vars, /* [] */0);
            if (mets !== /* [] */0 || vals !== /* [] */0) {
              throw [
                    $$Error$9,
                    cl.pci_loc,
                    env$1,
                    /* Virtual_class */Block.__(10, [
                        define_class,
                        false,
                        mets,
                        vals
                      ])
                  ];
            }
            
          }
          var arity = class_type_arity(typ);
          var match$5 = flatten_fields(object_fields(expand_head(env$1, obj_ty)));
          var pub_meths = List.map((function (param) {
                  return param[0];
                }), match$5[0]);
          var match$6 = instance_class(params, typ);
          var typ$prime = match$6[1];
          var params$prime = match$6[0];
          var cltydef_clty_type$1 = class_body(typ$prime);
          var cltydef_clty_path$1 = /* Pident */Block.__(0, [obj_id]);
          var cltydef_clty_loc$1 = cl.pci_loc;
          var cltydef_clty_attributes$1 = cl.pci_attributes;
          var cltydef$1 = {
            clty_params: params$prime,
            clty_type: cltydef_clty_type$1,
            clty_path: cltydef_clty_path$1,
            clty_variance: cty_variance,
            clty_loc: cltydef_clty_loc$1,
            clty_attributes: cltydef_clty_attributes$1
          };
          var match$7 = cl.pci_virt;
          var clty$1 = {
            cty_params: params$prime,
            cty_type: typ$prime,
            cty_path: /* Pident */Block.__(0, [obj_id]),
            cty_new: match$7 ? instance(void 0, env$1, constr_type) : void 0,
            cty_variance: cty_variance,
            cty_loc: cl.pci_loc,
            cty_attributes: cl.pci_attributes
          };
          var obj_abbr_type_arity = List.length(obj_params);
          var obj_abbr_type_manifest = obj_ty;
          var obj_abbr_type_variance = List.map((function (param) {
                  return Types_Variance.full;
                }), obj_params);
          var obj_abbr_type_loc = cl.pci_loc;
          var obj_abbr = {
            type_params: obj_params,
            type_arity: obj_abbr_type_arity,
            type_kind: /* Type_abstract */0,
            type_private: /* Public */1,
            type_manifest: obj_abbr_type_manifest,
            type_variance: obj_abbr_type_variance,
            type_newtype_level: void 0,
            type_loc: obj_abbr_type_loc,
            type_attributes: /* [] */0
          };
          var match$8 = instance_parameterized_type(void 0, params, repr(signature_of_class_type(typ).csig_self));
          var cl_ty$1 = match$8[1];
          var cl_params$1 = match$8[0];
          hide_private_methods(cl_ty$1);
          set_object_name(obj_id, row_variable(cl_ty$1), cl_params$1, cl_ty$1);
          var cl_abbr_type_arity = List.length(cl_params$1);
          var cl_abbr_type_manifest = cl_ty$1;
          var cl_abbr_type_variance = List.map((function (param) {
                  return Types_Variance.full;
                }), cl_params$1);
          var cl_abbr_type_loc = cl.pci_loc;
          var cl_abbr = {
            type_params: cl_params$1,
            type_arity: cl_abbr_type_arity,
            type_kind: /* Type_abstract */0,
            type_private: /* Public */1,
            type_manifest: cl_abbr_type_manifest,
            type_variance: cl_abbr_type_variance,
            type_newtype_level: void 0,
            type_loc: cl_abbr_type_loc,
            type_attributes: /* [] */0
          };
          return /* tuple */[
                  /* :: */[
                    /* tuple */[
                      cl,
                      id,
                      clty$1,
                      ty_id,
                      cltydef$1,
                      obj_id,
                      obj_abbr,
                      cl_id,
                      cl_abbr,
                      ci_params,
                      arity,
                      pub_meths,
                      List.rev(coercion_locs.contents),
                      match[0]
                    ],
                    param$1[0]
                  ],
                  env$1
                ];
        }), match[0], /* tuple */[
        /* [] */0,
        match[1]
      ]);
  var env$1 = match$1[1];
  end_def(void 0);
  var res = List.rev_map((function (param) {
          var expr = param[13];
          var cl_abbr = param[8];
          var cl_id = param[7];
          var obj_abbr = param[6];
          var obj_id = param[5];
          var cltydef = param[4];
          var ty_id = param[3];
          var clty = param[2];
          var id = param[1];
          var cl = param[0];
          try {
            collapse_conj_params(env$1, clty.cty_params);
          }
          catch (raw_exn){
            var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn[0] === Unify) {
              throw [
                    $$Error$9,
                    cl.pci_loc,
                    env$1,
                    /* Non_collapsable_conjunction */Block.__(20, [
                        id,
                        clty,
                        exn[1]
                      ])
                  ];
            }
            throw exn;
          }
          List.iter(generalize, clty.cty_params);
          ((function (param) {
                  return generalize_class_type(generalize, param);
                })(clty.cty_type));
          may(generalize, clty.cty_new);
          List.iter(generalize, obj_abbr.type_params);
          may(generalize, obj_abbr.type_manifest);
          List.iter(generalize, cl_abbr.type_params);
          may(generalize, cl_abbr.type_manifest);
          if (!closed_class$1(clty)) {
            throw [
                  $$Error$9,
                  cl.pci_loc,
                  env$1,
                  /* Non_generalizable_class */Block.__(18, [
                      id,
                      clty
                    ])
                ];
          }
          var match = closed_class(clty.cty_params, signature_of_class_type(clty.cty_type));
          if (match !== void 0) {
            var printer = define_class ? (function (ppf) {
                  return class_declaration$1(id, ppf, clty);
                }) : (function (ppf) {
                  return cltype_declaration$1(id, ppf, cltydef);
                });
            throw [
                  $$Error$9,
                  cl.pci_loc,
                  env$1,
                  /* Unbound_type_var */Block.__(16, [
                      printer,
                      match
                    ])
                ];
          }
          return /* tuple */[
                  id,
                  cl.pci_name,
                  clty,
                  ty_id,
                  cltydef,
                  obj_id,
                  obj_abbr,
                  cl_id,
                  cl_abbr,
                  param[10],
                  param[11],
                  param[12],
                  expr,
                  {
                    ci_virt: cl.pci_virt,
                    ci_params: param[9],
                    ci_id_name: cl.pci_name,
                    ci_id_class: id,
                    ci_id_class_type: ty_id,
                    ci_id_object: obj_id,
                    ci_id_typesharp: cl_id,
                    ci_expr: expr,
                    ci_decl: clty,
                    ci_type_decl: cltydef,
                    ci_loc: cl.pci_loc,
                    ci_attributes: cl.pci_attributes
                  }
                ];
        }), match$1[0]);
  var decls = List.fold_right(extract_type_decls, res, /* [] */0);
  var decls$1 = compute_variance_decls(env$1, decls);
  var res$1 = List.map2(merge_type_decls, res, decls$1);
  var env$2 = List.fold_left((function (param, param$1) {
          return add_type$1(true, param$1[5], type_declaration(identity, param$1[6]), add_type$1(true, param$1[7], type_declaration(identity, param$1[8]), add_cltype(param$1[3], cltype_declaration(identity, param$1[4]), define_class ? add_class(param$1[0], class_declaration(identity, param$1[2]), param) : param)));
        }), env$1, res$1);
  var res$2 = List.map((function (param) {
          var coercion_locs = param[11];
          var cl_abbr = param[8];
          var obj_abbr = param[6];
          if (coercion_locs) {
            var loc = coercion_locs[0];
            var match = cl_abbr.type_manifest;
            var match$1 = obj_abbr.type_manifest;
            var match$2;
            if (match === void 0) {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    /* tuple */[
                      "typeclass.ml",
                      1562,
                      15
                    ]
                  ];
            }
            if (match$1 === void 0) {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    /* tuple */[
                      "typeclass.ml",
                      1562,
                      15
                    ]
                  ];
            }
            var match$3 = instance_parameterized_type(void 0, cl_abbr.type_params, match);
            var match$4 = instance_parameterized_type(void 0, obj_abbr.type_params, match$1);
            List.iter2((function (param, param$1) {
                    return unify$2(env$2, param, param$1);
                  }), match$3[0], match$4[0]);
            match$2 = /* tuple */[
              match$3[1],
              match$4[1]
            ];
            var obj_ty = match$2[1];
            var cl_ty = match$2[0];
            try {
              subtype(env$2, cl_ty, obj_ty)(void 0);
            }
            catch (raw_exn){
              var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
              if (exn[0] === Subtype) {
                throw [
                      $$Error$7,
                      loc,
                      env$2,
                      /* Not_subtype */Block.__(23, [
                          exn[1],
                          exn[2]
                        ])
                    ];
              }
              throw exn;
            }
            if (!opened_object(cl_ty)) {
              throw [
                    $$Error$9,
                    loc,
                    env$2,
                    /* Cannot_coerce_self */Block.__(19, [obj_ty])
                  ];
            }
            
          }
          return /* tuple */[
                  param[0],
                  param[1],
                  param[2],
                  param[3],
                  param[4],
                  param[5],
                  obj_abbr,
                  param[7],
                  cl_abbr,
                  param[9],
                  param[10],
                  param[13]
                ];
        }), res$1);
  return /* tuple */[
          res$2,
          env$2
        ];
}

var class_num = {
  contents: 0
};

function class_declaration$2(env, sexpr) {
  class_num.contents = class_num.contents + 1 | 0;
  var expr = class_expr(String(class_num.contents), env, env, sexpr);
  return /* tuple */[
          expr,
          expr.cl_type
        ];
}

function class_description(env, sexpr) {
  var expr = class_type$4(env, sexpr);
  return /* tuple */[
          expr,
          expr.cltyp_type
        ];
}

function class_declarations$2(env, cls) {
  return type_classes(true, approx_declaration, class_declaration$2, env, cls);
}

function class_descriptions(env, cls) {
  return type_classes(true, approx_description, class_description, env, cls);
}

function class_type_declarations$2(env, cls) {
  var match = type_classes(false, approx_description, class_description, env, cls);
  return /* tuple */[
          List.map((function (param) {
                  return /* tuple */[
                          param[3],
                          param[1],
                          param[4],
                          param[5],
                          param[6],
                          param[7],
                          param[8],
                          param[11]
                        ];
                }), match[0]),
          match[1]
        ];
}

function unify_parents_struct(env, ty, st) {
  return List.iter((function (param) {
                var match = param.cf_desc;
                if (match.tag) {
                  return ;
                } else {
                  var _cl = match[1];
                  while(true) {
                    var cl = _cl;
                    var match$1 = cl.cl_desc;
                    switch (match$1.tag | 0) {
                      case /* Tcl_ident */0 :
                          try {
                            var decl = find_class(match$1[0], env);
                            var match$2 = find_cltype_for_path(env, decl.cty_path);
                            return unify$2(env, ty, instance(void 0, env, match$2[1]));
                          }
                          catch (exn){
                            if (exn === Caml_builtin_exceptions.not_found) {
                              return ;
                            }
                            throw [
                                  Caml_builtin_exceptions.assert_failure,
                                  /* tuple */[
                                    "typeclass.ml",
                                    1639,
                                    15
                                  ]
                                ];
                          }
                      case /* Tcl_structure */1 :
                          return unify_parents_struct(env, ty, match$1[0]);
                      case /* Tcl_fun */2 :
                      case /* Tcl_let */4 :
                          _cl = match$1[3];
                          continue ;
                      case /* Tcl_apply */3 :
                      case /* Tcl_constraint */5 :
                          _cl = match$1[0];
                          continue ;
                      
                    }
                  };
                }
              }), st.cstr_fields);
}

function type_object$1(env, loc, s) {
  class_num.contents = class_num.contents + 1 | 0;
  var match = class_structure(String(class_num.contents), true, env, env, loc, s);
  var sign = match[1];
  var desc = match[0];
  var sty = expand_head(env, sign.csig_self);
  hide_private_methods(sty);
  var match$1 = flatten_fields(object_fields(sty));
  var meths = List.map((function (param) {
          return param[0];
        }), match$1[0]);
  unify_parents_struct(env, sign.csig_self, desc);
  return /* tuple */[
          desc,
          sign,
          meths
        ];
}

type_object.contents = type_object$1;

function approx_class(sdecl) {
  var self$prime = mk(void 0, void 0, /* Ptyp_any */0);
  var clty$prime = signature$1(sdecl.pci_expr.pcty_loc, void 0, {
        pcsig_self: self$prime,
        pcsig_fields: /* [] */0
      });
  return {
          pci_virt: sdecl.pci_virt,
          pci_params: sdecl.pci_params,
          pci_name: sdecl.pci_name,
          pci_expr: clty$prime,
          pci_loc: sdecl.pci_loc,
          pci_attributes: sdecl.pci_attributes
        };
}

function approx_class_declarations(env, sdecls) {
  return class_type_declarations$2(env, List.map(approx_class, sdecls))[0];
}

register_error_of_exn((function (param) {
        if (param[0] !== $$Error$9) {
          if (param[0] === Error_forward$2) {
            return param[1];
          } else {
            return ;
          }
        }
        var env = param[2];
        return error_of_printer(param[1], (function (param, param$1) {
                      return wrap_printing_env(env, (function (param$2) {
                                    if (typeof param$1 === "number") {
                                      return Format.fprintf(param, /* Format */[
                                                  /* String_literal */Block.__(11, [
                                                      "A type parameter occurs several times",
                                                      /* End_of_format */0
                                                    ]),
                                                  "A type parameter occurs several times"
                                                ]);
                                    }
                                    switch (param$1.tag | 0) {
                                      case /* Unconsistent_constraint */0 :
                                          Format.fprintf(param, /* Format */[
                                                /* String_literal */Block.__(11, [
                                                    "The class constraints are not consistent.",
                                                    /* Formatting_lit */Block.__(17, [
                                                        /* Flush_newline */4,
                                                        /* End_of_format */0
                                                      ])
                                                  ]),
                                                "The class constraints are not consistent.@."
                                              ]);
                                          return report_unification_error(param, env, void 0, param$1[0], (function (ppf) {
                                                        return Format.fprintf(ppf, /* Format */[
                                                                    /* String_literal */Block.__(11, [
                                                                        "Type",
                                                                        /* End_of_format */0
                                                                      ]),
                                                                    "Type"
                                                                  ]);
                                                      }), (function (ppf) {
                                                        return Format.fprintf(ppf, /* Format */[
                                                                    /* String_literal */Block.__(11, [
                                                                        "is not compatible with type",
                                                                        /* End_of_format */0
                                                                      ]),
                                                                    "is not compatible with type"
                                                                  ]);
                                                      }));
                                      case /* Field_type_mismatch */1 :
                                          var m = param$1[1];
                                          var k = param$1[0];
                                          return report_unification_error(param, env, void 0, param$1[2], (function (ppf) {
                                                        return Curry._2(Format.fprintf(ppf, /* Format */[
                                                                        /* String_literal */Block.__(11, [
                                                                            "The ",
                                                                            /* String */Block.__(2, [
                                                                                /* No_padding */0,
                                                                                /* Char_literal */Block.__(12, [
                                                                                    /* " " */32,
                                                                                    /* String */Block.__(2, [
                                                                                        /* No_padding */0,
                                                                                        /* Formatting_lit */Block.__(17, [
                                                                                            /* Break */Block.__(0, [
                                                                                                "@ ",
                                                                                                1,
                                                                                                0
                                                                                              ]),
                                                                                            /* String_literal */Block.__(11, [
                                                                                                "has type",
                                                                                                /* End_of_format */0
                                                                                              ])
                                                                                          ])
                                                                                      ])
                                                                                  ])
                                                                              ])
                                                                          ]),
                                                                        "The %s %s@ has type"
                                                                      ]), k, m);
                                                      }), (function (ppf) {
                                                        return Format.fprintf(ppf, /* Format */[
                                                                    /* String_literal */Block.__(11, [
                                                                        "but is expected to have type",
                                                                        /* End_of_format */0
                                                                      ]),
                                                                    "but is expected to have type"
                                                                  ]);
                                                      }));
                                      case /* Structure_expected */2 :
                                          return Curry._2(Format.fprintf(param, /* Format */[
                                                          /* Formatting_gen */Block.__(18, [
                                                              /* Open_box */Block.__(1, [/* Format */[
                                                                    /* End_of_format */0,
                                                                    ""
                                                                  ]]),
                                                              /* String_literal */Block.__(11, [
                                                                  "This class expression is not a class structure; it has type",
                                                                  /* Formatting_lit */Block.__(17, [
                                                                      /* Break */Block.__(0, [
                                                                          "@ ",
                                                                          1,
                                                                          0
                                                                        ]),
                                                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                              /* Close_box */0,
                                                                              /* End_of_format */0
                                                                            ])])
                                                                    ])
                                                                ])
                                                            ]),
                                                          "@[This class expression is not a class structure; it has type@ %a@]"
                                                        ]), class_type$2, param$1[0]);
                                      case /* Cannot_apply */3 :
                                          return Format.fprintf(param, /* Format */[
                                                      /* String_literal */Block.__(11, [
                                                          "This class expression is not a class function, it cannot be applied",
                                                          /* End_of_format */0
                                                        ]),
                                                      "This class expression is not a class function, it cannot be applied"
                                                    ]);
                                      case /* Apply_wrong_label */4 :
                                          var mark_label = function (l) {
                                            if (l === "") {
                                              return "out label";
                                            } else {
                                              return Curry._1(Format.sprintf(/* Format */[
                                                              /* String_literal */Block.__(11, [
                                                                  " label ~",
                                                                  /* String */Block.__(2, [
                                                                      /* No_padding */0,
                                                                      /* End_of_format */0
                                                                    ])
                                                                ]),
                                                              " label ~%s"
                                                            ]), l);
                                            }
                                          };
                                          return Curry._1(Format.fprintf(param, /* Format */[
                                                          /* String_literal */Block.__(11, [
                                                              "This argument cannot be applied with",
                                                              /* String */Block.__(2, [
                                                                  /* No_padding */0,
                                                                  /* End_of_format */0
                                                                ])
                                                            ]),
                                                          "This argument cannot be applied with%s"
                                                        ]), mark_label(param$1[0]));
                                      case /* Pattern_type_clash */5 :
                                          var ty = param$1[0];
                                          reset(void 0);
                                          mark_loops(ty);
                                          return Curry._3(Format.fprintf(param, /* Format */[
                                                          /* Formatting_gen */Block.__(18, [
                                                              /* Open_box */Block.__(1, [/* Format */[
                                                                    /* End_of_format */0,
                                                                    ""
                                                                  ]]),
                                                              /* String */Block.__(2, [
                                                                  /* No_padding */0,
                                                                  /* Formatting_lit */Block.__(17, [
                                                                      /* Break */Block.__(0, [
                                                                          "@ ",
                                                                          1,
                                                                          0
                                                                        ]),
                                                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                              /* Close_box */0,
                                                                              /* End_of_format */0
                                                                            ])])
                                                                    ])
                                                                ])
                                                            ]),
                                                          "@[%s@ %a@]"
                                                        ]), "This pattern cannot match self: it only matches values of type", type_expr$1, ty);
                                      case /* Unbound_class_2 */6 :
                                          return Curry._2(Format.fprintf(param, /* Format */[
                                                          /* Formatting_gen */Block.__(18, [
                                                              /* Open_box */Block.__(1, [/* Format */[
                                                                    /* End_of_format */0,
                                                                    ""
                                                                  ]]),
                                                              /* String_literal */Block.__(11, [
                                                                  "The class",
                                                                  /* Formatting_lit */Block.__(17, [
                                                                      /* Break */Block.__(0, [
                                                                          "@ ",
                                                                          1,
                                                                          0
                                                                        ]),
                                                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                              /* Break */Block.__(0, [
                                                                                  "@ ",
                                                                                  1,
                                                                                  0
                                                                                ]),
                                                                              /* String_literal */Block.__(11, [
                                                                                  "is not yet completely defined",
                                                                                  /* Formatting_lit */Block.__(17, [
                                                                                      /* Close_box */0,
                                                                                      /* End_of_format */0
                                                                                    ])
                                                                                ])
                                                                            ])])
                                                                    ])
                                                                ])
                                                            ]),
                                                          "@[The class@ %a@ is not yet completely defined@]"
                                                        ]), longident, param$1[0]);
                                      case /* Unbound_class_type_2 */7 :
                                          return Curry._2(Format.fprintf(param, /* Format */[
                                                          /* Formatting_gen */Block.__(18, [
                                                              /* Open_box */Block.__(1, [/* Format */[
                                                                    /* End_of_format */0,
                                                                    ""
                                                                  ]]),
                                                              /* String_literal */Block.__(11, [
                                                                  "The class type",
                                                                  /* Formatting_lit */Block.__(17, [
                                                                      /* Break */Block.__(0, [
                                                                          "@ ",
                                                                          1,
                                                                          0
                                                                        ]),
                                                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                              /* Break */Block.__(0, [
                                                                                  "@ ",
                                                                                  1,
                                                                                  0
                                                                                ]),
                                                                              /* String_literal */Block.__(11, [
                                                                                  "is not yet completely defined",
                                                                                  /* Formatting_lit */Block.__(17, [
                                                                                      /* Close_box */0,
                                                                                      /* End_of_format */0
                                                                                    ])
                                                                                ])
                                                                            ])])
                                                                    ])
                                                                ])
                                                            ]),
                                                          "@[The class type@ %a@ is not yet completely defined@]"
                                                        ]), longident, param$1[0]);
                                      case /* Abbrev_type_clash */8 :
                                          var expected = param$1[2];
                                          var actual = param$1[1];
                                          var abbrev = param$1[0];
                                          reset_and_mark_loops_list(/* :: */[
                                                abbrev,
                                                /* :: */[
                                                  actual,
                                                  /* :: */[
                                                    expected,
                                                    /* [] */0
                                                  ]
                                                ]
                                              ]);
                                          return Curry._6(Format.fprintf(param, /* Format */[
                                                          /* Formatting_gen */Block.__(18, [
                                                              /* Open_box */Block.__(1, [/* Format */[
                                                                    /* End_of_format */0,
                                                                    ""
                                                                  ]]),
                                                              /* String_literal */Block.__(11, [
                                                                  "The abbreviation",
                                                                  /* Formatting_lit */Block.__(17, [
                                                                      /* Break */Block.__(0, [
                                                                          "@ ",
                                                                          1,
                                                                          0
                                                                        ]),
                                                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                              /* Break */Block.__(0, [
                                                                                  "@ ",
                                                                                  1,
                                                                                  0
                                                                                ]),
                                                                              /* String_literal */Block.__(11, [
                                                                                  "expands to type",
                                                                                  /* Formatting_lit */Block.__(17, [
                                                                                      /* Break */Block.__(0, [
                                                                                          "@ ",
                                                                                          1,
                                                                                          0
                                                                                        ]),
                                                                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                              /* Break */Block.__(0, [
                                                                                                  "@ ",
                                                                                                  1,
                                                                                                  0
                                                                                                ]),
                                                                                              /* String_literal */Block.__(11, [
                                                                                                  "but is used with type",
                                                                                                  /* Formatting_lit */Block.__(17, [
                                                                                                      /* Break */Block.__(0, [
                                                                                                          "@ ",
                                                                                                          1,
                                                                                                          0
                                                                                                        ]),
                                                                                                      /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                                              /* Close_box */0,
                                                                                                              /* End_of_format */0
                                                                                                            ])])
                                                                                                    ])
                                                                                                ])
                                                                                            ])])
                                                                                    ])
                                                                                ])
                                                                            ])])
                                                                    ])
                                                                ])
                                                            ]),
                                                          "@[The abbreviation@ %a@ expands to type@ %a@ but is used with type@ %a@]"
                                                        ]), type_expr$1, abbrev, type_expr$1, actual, type_expr$1, expected);
                                      case /* Constructor_type_mismatch */9 :
                                          var c = param$1[0];
                                          return report_unification_error(param, env, void 0, param$1[1], (function (ppf) {
                                                        return Curry._1(Format.fprintf(ppf, /* Format */[
                                                                        /* String_literal */Block.__(11, [
                                                                            "The expression \"new ",
                                                                            /* String */Block.__(2, [
                                                                                /* No_padding */0,
                                                                                /* String_literal */Block.__(11, [
                                                                                    "\" has type",
                                                                                    /* End_of_format */0
                                                                                  ])
                                                                              ])
                                                                          ]),
                                                                        "The expression \"new %s\" has type"
                                                                      ]), c);
                                                      }), (function (ppf) {
                                                        return Format.fprintf(ppf, /* Format */[
                                                                    /* String_literal */Block.__(11, [
                                                                        "but is used with type",
                                                                        /* End_of_format */0
                                                                      ]),
                                                                    "but is used with type"
                                                                  ]);
                                                      }));
                                      case /* Virtual_class */10 :
                                          var vals = param$1[3];
                                          var mets = param$1[2];
                                          var imm = param$1[1];
                                          var cl = param$1[0];
                                          var print_mets = function (ppf, mets) {
                                            return List.iter((function (met) {
                                                          return Curry._1(Format.fprintf(ppf, /* Format */[
                                                                          /* Formatting_lit */Block.__(17, [
                                                                              /* Break */Block.__(0, [
                                                                                  "@ ",
                                                                                  1,
                                                                                  0
                                                                                ]),
                                                                              /* String */Block.__(2, [
                                                                                  /* No_padding */0,
                                                                                  /* End_of_format */0
                                                                                ])
                                                                            ]),
                                                                          "@ %s"
                                                                        ]), met);
                                                        }), mets);
                                          };
                                          var missings = mets ? (
                                              vals ? "methods and variables" : "methods"
                                            ) : "variables";
                                          var print_msg = function (ppf) {
                                            if (imm) {
                                              return Curry._1(Format.fprintf(ppf, /* Format */[
                                                              /* String_literal */Block.__(11, [
                                                                  "This object has virtual ",
                                                                  /* String */Block.__(2, [
                                                                      /* No_padding */0,
                                                                      /* End_of_format */0
                                                                    ])
                                                                ]),
                                                              "This object has virtual %s"
                                                            ]), missings);
                                            } else if (cl) {
                                              return Format.fprintf(ppf, /* Format */[
                                                          /* String_literal */Block.__(11, [
                                                              "This class should be virtual",
                                                              /* End_of_format */0
                                                            ]),
                                                          "This class should be virtual"
                                                        ]);
                                            } else {
                                              return Format.fprintf(ppf, /* Format */[
                                                          /* String_literal */Block.__(11, [
                                                              "This class type should be virtual",
                                                              /* End_of_format */0
                                                            ]),
                                                          "This class type should be virtual"
                                                        ]);
                                            }
                                          };
                                          return Curry._4(Format.fprintf(param, /* Format */[
                                                          /* Formatting_gen */Block.__(18, [
                                                              /* Open_box */Block.__(1, [/* Format */[
                                                                    /* End_of_format */0,
                                                                    ""
                                                                  ]]),
                                                              /* Theta */Block.__(16, [/* Char_literal */Block.__(12, [
                                                                      /* "." */46,
                                                                      /* Formatting_lit */Block.__(17, [
                                                                          /* Break */Block.__(0, [
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            ]),
                                                                          /* Formatting_gen */Block.__(18, [
                                                                              /* Open_box */Block.__(1, [/* Format */[
                                                                                    /* String_literal */Block.__(11, [
                                                                                        "<2>",
                                                                                        /* End_of_format */0
                                                                                      ]),
                                                                                    "<2>"
                                                                                  ]]),
                                                                              /* String_literal */Block.__(11, [
                                                                                  "The following ",
                                                                                  /* String */Block.__(2, [
                                                                                      /* No_padding */0,
                                                                                      /* String_literal */Block.__(11, [
                                                                                          " are undefined :",
                                                                                          /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                                  /* Close_box */0,
                                                                                                  /* Formatting_lit */Block.__(17, [
                                                                                                      /* Close_box */0,
                                                                                                      /* End_of_format */0
                                                                                                    ])
                                                                                                ])])
                                                                                        ])
                                                                                    ])
                                                                                ])
                                                                            ])
                                                                        ])
                                                                    ])])
                                                            ]),
                                                          "@[%t.@ @[<2>The following %s are undefined :%a@]@]"
                                                        ]), print_msg, missings, print_mets, Pervasives.$at(mets, vals));
                                      case /* Parameter_arity_mismatch */11 :
                                          return Curry._4(Format.fprintf(param, /* Format */[
                                                          /* Formatting_gen */Block.__(18, [
                                                              /* Open_box */Block.__(1, [/* Format */[
                                                                    /* End_of_format */0,
                                                                    ""
                                                                  ]]),
                                                              /* String_literal */Block.__(11, [
                                                                  "The class constructor ",
                                                                  /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                          /* Break */Block.__(0, [
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            ]),
                                                                          /* String_literal */Block.__(11, [
                                                                              "expects ",
                                                                              /* Int */Block.__(4, [
                                                                                  /* Int_i */3,
                                                                                  /* No_padding */0,
                                                                                  /* No_precision */0,
                                                                                  /* String_literal */Block.__(11, [
                                                                                      " type argument(s),",
                                                                                      /* Formatting_lit */Block.__(17, [
                                                                                          /* Break */Block.__(0, [
                                                                                              "@ ",
                                                                                              1,
                                                                                              0
                                                                                            ]),
                                                                                          /* String_literal */Block.__(11, [
                                                                                              "but is here applied to ",
                                                                                              /* Int */Block.__(4, [
                                                                                                  /* Int_i */3,
                                                                                                  /* No_padding */0,
                                                                                                  /* No_precision */0,
                                                                                                  /* String_literal */Block.__(11, [
                                                                                                      " type argument(s)",
                                                                                                      /* Formatting_lit */Block.__(17, [
                                                                                                          /* Close_box */0,
                                                                                                          /* End_of_format */0
                                                                                                        ])
                                                                                                    ])
                                                                                                ])
                                                                                            ])
                                                                                        ])
                                                                                    ])
                                                                                ])
                                                                            ])
                                                                        ])])
                                                                ])
                                                            ]),
                                                          "@[The class constructor %a@ expects %i type argument(s),@ but is here applied to %i type argument(s)@]"
                                                        ]), longident, param$1[0], param$1[1], param$1[2]);
                                      case /* Parameter_mismatch */12 :
                                          return report_unification_error(param, env, void 0, param$1[0], (function (ppf) {
                                                        return Format.fprintf(ppf, /* Format */[
                                                                    /* String_literal */Block.__(11, [
                                                                        "The type parameter",
                                                                        /* End_of_format */0
                                                                      ]),
                                                                    "The type parameter"
                                                                  ]);
                                                      }), (function (ppf) {
                                                        return Format.fprintf(ppf, /* Format */[
                                                                    /* String_literal */Block.__(11, [
                                                                        "does not meet its constraint: it should be",
                                                                        /* End_of_format */0
                                                                      ]),
                                                                    "does not meet its constraint: it should be"
                                                                  ]);
                                                      }));
                                      case /* Bad_parameters */13 :
                                          var cstrs = param$1[2];
                                          var params = param$1[1];
                                          reset_and_mark_loops_list(/* :: */[
                                                params,
                                                /* :: */[
                                                  cstrs,
                                                  /* [] */0
                                                ]
                                              ]);
                                          return Curry._6(Format.fprintf(param, /* Format */[
                                                          /* Formatting_gen */Block.__(18, [
                                                              /* Open_box */Block.__(1, [/* Format */[
                                                                    /* End_of_format */0,
                                                                    ""
                                                                  ]]),
                                                              /* String_literal */Block.__(11, [
                                                                  "The abbreviation ",
                                                                  /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                          /* Break */Block.__(0, [
                                                                              "@ ",
                                                                              1,
                                                                              0
                                                                            ]),
                                                                          /* String_literal */Block.__(11, [
                                                                              "is used with parameters",
                                                                              /* Formatting_lit */Block.__(17, [
                                                                                  /* Break */Block.__(0, [
                                                                                      "@ ",
                                                                                      1,
                                                                                      0
                                                                                    ]),
                                                                                  /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                          /* Break */Block.__(0, [
                                                                                              "@ ",
                                                                                              1,
                                                                                              0
                                                                                            ]),
                                                                                          /* String_literal */Block.__(11, [
                                                                                              "wich are incompatible with constraints",
                                                                                              /* Formatting_lit */Block.__(17, [
                                                                                                  /* Break */Block.__(0, [
                                                                                                      "@ ",
                                                                                                      1,
                                                                                                      0
                                                                                                    ]),
                                                                                                  /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                                          /* Close_box */0,
                                                                                                          /* End_of_format */0
                                                                                                        ])])
                                                                                                ])
                                                                                            ])
                                                                                        ])])
                                                                                ])
                                                                            ])
                                                                        ])])
                                                                ])
                                                            ]),
                                                          "@[The abbreviation %a@ is used with parameters@ %a@ wich are incompatible with constraints@ %a@]"
                                                        ]), ident$3, param$1[0], type_expr$1, params, type_expr$1, cstrs);
                                      case /* Class_match_failure */14 :
                                          return report_error$3(param, param$1[0]);
                                      case /* Unbound_val */15 :
                                          return Curry._1(Format.fprintf(param, /* Format */[
                                                          /* String_literal */Block.__(11, [
                                                              "Unbound instance variable ",
                                                              /* String */Block.__(2, [
                                                                  /* No_padding */0,
                                                                  /* End_of_format */0
                                                                ])
                                                            ]),
                                                          "Unbound instance variable %s"
                                                        ]), param$1[0]);
                                      case /* Unbound_type_var */16 :
                                          var print_common = function (ppf, kind, ty0, real, lab, ty) {
                                            var ty1 = real ? ty0 : newty2(100000000, /* Tobject */Block.__(4, [
                                                      ty0,
                                                      {
                                                        contents: void 0
                                                      }
                                                    ]));
                                            mark_loops(ty1);
                                            return Curry._6(Format.fprintf(ppf, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "The ",
                                                                /* String */Block.__(2, [
                                                                    /* No_padding */0,
                                                                    /* Char_literal */Block.__(12, [
                                                                        /* " " */32,
                                                                        /* String */Block.__(2, [
                                                                            /* No_padding */0,
                                                                            /* Formatting_lit */Block.__(17, [
                                                                                /* Break */Block.__(0, [
                                                                                    "@ ",
                                                                                    1,
                                                                                    0
                                                                                  ]),
                                                                                /* String_literal */Block.__(11, [
                                                                                    "has type",
                                                                                    /* Formatting_lit */Block.__(17, [
                                                                                        /* Break */Block.__(0, [
                                                                                            "@;<1 2>",
                                                                                            1,
                                                                                            2
                                                                                          ]),
                                                                                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                                /* Break */Block.__(0, [
                                                                                                    "@ ",
                                                                                                    1,
                                                                                                    0
                                                                                                  ]),
                                                                                                /* String_literal */Block.__(11, [
                                                                                                    "where",
                                                                                                    /* Formatting_lit */Block.__(17, [
                                                                                                        /* Break */Block.__(0, [
                                                                                                            "@ ",
                                                                                                            1,
                                                                                                            0
                                                                                                          ]),
                                                                                                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                                                /* Break */Block.__(0, [
                                                                                                                    "@ ",
                                                                                                                    1,
                                                                                                                    0
                                                                                                                  ]),
                                                                                                                /* String_literal */Block.__(11, [
                                                                                                                    "is unbound",
                                                                                                                    /* End_of_format */0
                                                                                                                  ])
                                                                                                              ])])
                                                                                                      ])
                                                                                                  ])
                                                                                              ])])
                                                                                      ])
                                                                                  ])
                                                                              ])
                                                                          ])
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "The %s %s@ has type@;<1 2>%a@ where@ %a@ is unbound"
                                                          ]), kind, lab, type_expr$1, ty, type_expr$1, ty0);
                                          };
                                          var print_reason = function (ppf, param) {
                                            if (param.tag) {
                                              return print_common(ppf, "instance variable", param[0], param[1], param[2], param[3]);
                                            } else {
                                              return print_common(ppf, "method", param[0], param[1], param[2], param[3]);
                                            }
                                          };
                                          reset(void 0);
                                          return Curry._3(Format.fprintf(param, /* Format */[
                                                          /* Formatting_gen */Block.__(18, [
                                                              /* Open_box */Block.__(1, [/* Format */[
                                                                    /* String_literal */Block.__(11, [
                                                                        "<v>",
                                                                        /* End_of_format */0
                                                                      ]),
                                                                    "<v>"
                                                                  ]]),
                                                              /* Formatting_gen */Block.__(18, [
                                                                  /* Open_box */Block.__(1, [/* Format */[
                                                                        /* End_of_format */0,
                                                                        ""
                                                                      ]]),
                                                                  /* String_literal */Block.__(11, [
                                                                      "Some type variables are unbound in this type:",
                                                                      /* Formatting_lit */Block.__(17, [
                                                                          /* Break */Block.__(0, [
                                                                              "@;<1 2>",
                                                                              1,
                                                                              2
                                                                            ]),
                                                                          /* Theta */Block.__(16, [/* Formatting_lit */Block.__(17, [
                                                                                  /* Close_box */0,
                                                                                  /* Formatting_lit */Block.__(17, [
                                                                                      /* Break */Block.__(0, [
                                                                                          "@ ",
                                                                                          1,
                                                                                          0
                                                                                        ]),
                                                                                      /* Formatting_gen */Block.__(18, [
                                                                                          /* Open_box */Block.__(1, [/* Format */[
                                                                                                /* End_of_format */0,
                                                                                                ""
                                                                                              ]]),
                                                                                          /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                                  /* Close_box */0,
                                                                                                  /* Formatting_lit */Block.__(17, [
                                                                                                      /* Close_box */0,
                                                                                                      /* End_of_format */0
                                                                                                    ])
                                                                                                ])])
                                                                                        ])
                                                                                    ])
                                                                                ])])
                                                                        ])
                                                                    ])
                                                                ])
                                                            ]),
                                                          "@[<v>@[Some type variables are unbound in this type:@;<1 2>%t@]@ @[%a@]@]"
                                                        ]), param$1[0], print_reason, param$1[1]);
                                      case /* Make_nongen_seltype */17 :
                                          return Curry._2(Format.fprintf(param, /* Format */[
                                                          /* Formatting_gen */Block.__(18, [
                                                              /* Open_box */Block.__(1, [/* Format */[
                                                                    /* String_literal */Block.__(11, [
                                                                        "<v>",
                                                                        /* End_of_format */0
                                                                      ]),
                                                                    "<v>"
                                                                  ]]),
                                                              /* Formatting_gen */Block.__(18, [
                                                                  /* Open_box */Block.__(1, [/* Format */[
                                                                        /* End_of_format */0,
                                                                        ""
                                                                      ]]),
                                                                  /* String_literal */Block.__(11, [
                                                                      "Self type should not occur in the non-generic type",
                                                                      /* Formatting_lit */Block.__(17, [
                                                                          /* Break */Block.__(0, [
                                                                              "@;<1 2>",
                                                                              1,
                                                                              2
                                                                            ]),
                                                                          /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                  /* Close_box */0,
                                                                                  /* Formatting_lit */Block.__(17, [
                                                                                      /* Break */Block.__(0, [
                                                                                          "@,",
                                                                                          0,
                                                                                          0
                                                                                        ]),
                                                                                      /* String_literal */Block.__(11, [
                                                                                          "It would escape the scope of its class",
                                                                                          /* Formatting_lit */Block.__(17, [
                                                                                              /* Close_box */0,
                                                                                              /* End_of_format */0
                                                                                            ])
                                                                                        ])
                                                                                    ])
                                                                                ])])
                                                                        ])
                                                                    ])
                                                                ])
                                                            ]),
                                                          "@[<v>@[Self type should not occur in the non-generic type@;<1 2>%a@]@,It would escape the scope of its class@]"
                                                        ]), type_scheme, param$1[0]);
                                      case /* Non_generalizable_class */18 :
                                          var id = param$1[0];
                                          return Curry._2(Format.fprintf(param, /* Format */[
                                                          /* Formatting_gen */Block.__(18, [
                                                              /* Open_box */Block.__(1, [/* Format */[
                                                                    /* End_of_format */0,
                                                                    ""
                                                                  ]]),
                                                              /* String_literal */Block.__(11, [
                                                                  "The type of this class,",
                                                                  /* Formatting_lit */Block.__(17, [
                                                                      /* Break */Block.__(0, [
                                                                          "@ ",
                                                                          1,
                                                                          0
                                                                        ]),
                                                                      /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                                              /* "," */44,
                                                                              /* Formatting_lit */Block.__(17, [
                                                                                  /* Break */Block.__(0, [
                                                                                      "@ ",
                                                                                      1,
                                                                                      0
                                                                                    ]),
                                                                                  /* String_literal */Block.__(11, [
                                                                                      "contains type variables that cannot be generalized",
                                                                                      /* Formatting_lit */Block.__(17, [
                                                                                          /* Close_box */0,
                                                                                          /* End_of_format */0
                                                                                        ])
                                                                                    ])
                                                                                ])
                                                                            ])])
                                                                    ])
                                                                ])
                                                            ]),
                                                          "@[The type of this class,@ %a,@ contains type variables that cannot be generalized@]"
                                                        ]), (function (param, param$1) {
                                                        return class_declaration$1(id, param, param$1);
                                                      }), param$1[1]);
                                      case /* Cannot_coerce_self */19 :
                                          return Curry._2(Format.fprintf(param, /* Format */[
                                                          /* Formatting_gen */Block.__(18, [
                                                              /* Open_box */Block.__(1, [/* Format */[
                                                                    /* End_of_format */0,
                                                                    ""
                                                                  ]]),
                                                              /* String_literal */Block.__(11, [
                                                                  "The type of self cannot be coerced to",
                                                                  /* Formatting_lit */Block.__(17, [
                                                                      /* Break */Block.__(0, [
                                                                          "@ ",
                                                                          1,
                                                                          0
                                                                        ]),
                                                                      /* String_literal */Block.__(11, [
                                                                          "the type of the current class:",
                                                                          /* Formatting_lit */Block.__(17, [
                                                                              /* Break */Block.__(0, [
                                                                                  "@ ",
                                                                                  1,
                                                                                  0
                                                                                ]),
                                                                              /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                                                      /* "." */46,
                                                                                      /* Formatting_lit */Block.__(17, [
                                                                                          /* Flush_newline */4,
                                                                                          /* String_literal */Block.__(11, [
                                                                                              "Some occurrences are contravariant",
                                                                                              /* Formatting_lit */Block.__(17, [
                                                                                                  /* Close_box */0,
                                                                                                  /* End_of_format */0
                                                                                                ])
                                                                                            ])
                                                                                        ])
                                                                                    ])])
                                                                            ])
                                                                        ])
                                                                    ])
                                                                ])
                                                            ]),
                                                          "@[The type of self cannot be coerced to@ the type of the current class:@ %a.@.Some occurrences are contravariant@]"
                                                        ]), type_scheme, param$1[0]);
                                      case /* Non_collapsable_conjunction */20 :
                                          var id$1 = param$1[0];
                                          Curry._2(Format.fprintf(param, /* Format */[
                                                    /* Formatting_gen */Block.__(18, [
                                                        /* Open_box */Block.__(1, [/* Format */[
                                                              /* End_of_format */0,
                                                              ""
                                                            ]]),
                                                        /* String_literal */Block.__(11, [
                                                            "The type of this class,",
                                                            /* Formatting_lit */Block.__(17, [
                                                                /* Break */Block.__(0, [
                                                                    "@ ",
                                                                    1,
                                                                    0
                                                                  ]),
                                                                /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                                        /* "," */44,
                                                                        /* Formatting_lit */Block.__(17, [
                                                                            /* Break */Block.__(0, [
                                                                                "@ ",
                                                                                1,
                                                                                0
                                                                              ]),
                                                                            /* String_literal */Block.__(11, [
                                                                                "contains non-collapsible conjunctive types in constraints",
                                                                                /* Formatting_lit */Block.__(17, [
                                                                                    /* Close_box */0,
                                                                                    /* End_of_format */0
                                                                                  ])
                                                                              ])
                                                                          ])
                                                                      ])])
                                                              ])
                                                          ])
                                                      ]),
                                                    "@[The type of this class,@ %a,@ contains non-collapsible conjunctive types in constraints@]"
                                                  ]), (function (param, param$1) {
                                                  return class_declaration$1(id$1, param, param$1);
                                                }), param$1[1]);
                                          return report_unification_error(param, env, void 0, param$1[2], (function (ppf) {
                                                        return Format.fprintf(ppf, /* Format */[
                                                                    /* String_literal */Block.__(11, [
                                                                        "Type",
                                                                        /* End_of_format */0
                                                                      ]),
                                                                    "Type"
                                                                  ]);
                                                      }), (function (ppf) {
                                                        return Format.fprintf(ppf, /* Format */[
                                                                    /* String_literal */Block.__(11, [
                                                                        "is not compatible with type",
                                                                        /* End_of_format */0
                                                                      ]),
                                                                    "is not compatible with type"
                                                                  ]);
                                                      }));
                                      case /* Final_self_clash */21 :
                                          return report_unification_error(param, env, void 0, param$1[0], (function (ppf) {
                                                        return Format.fprintf(ppf, /* Format */[
                                                                    /* String_literal */Block.__(11, [
                                                                        "This object is expected to have type",
                                                                        /* End_of_format */0
                                                                      ]),
                                                                    "This object is expected to have type"
                                                                  ]);
                                                      }), (function (ppf) {
                                                        return Format.fprintf(ppf, /* Format */[
                                                                    /* String_literal */Block.__(11, [
                                                                        "but actually has type",
                                                                        /* End_of_format */0
                                                                      ]),
                                                                    "but actually has type"
                                                                  ]);
                                                      }));
                                      case /* Mutability_mismatch */22 :
                                          var match = param$1[1] === /* Immutable */0 ? /* tuple */[
                                              "mutable",
                                              "immutable"
                                            ] : /* tuple */[
                                              "immutable",
                                              "mutable"
                                            ];
                                          return Curry._2(Format.fprintf(param, /* Format */[
                                                          /* Formatting_gen */Block.__(18, [
                                                              /* Open_box */Block.__(1, [/* Format */[
                                                                    /* End_of_format */0,
                                                                    ""
                                                                  ]]),
                                                              /* String_literal */Block.__(11, [
                                                                  "The instance variable is ",
                                                                  /* String */Block.__(2, [
                                                                      /* No_padding */0,
                                                                      /* Char_literal */Block.__(12, [
                                                                          /* ";" */59,
                                                                          /* Formatting_lit */Block.__(17, [
                                                                              /* Break */Block.__(0, [
                                                                                  "@ ",
                                                                                  1,
                                                                                  0
                                                                                ]),
                                                                              /* String_literal */Block.__(11, [
                                                                                  "it cannot be redefined as ",
                                                                                  /* String */Block.__(2, [
                                                                                      /* No_padding */0,
                                                                                      /* Formatting_lit */Block.__(17, [
                                                                                          /* Close_box */0,
                                                                                          /* End_of_format */0
                                                                                        ])
                                                                                    ])
                                                                                ])
                                                                            ])
                                                                        ])
                                                                    ])
                                                                ])
                                                            ]),
                                                          "@[The instance variable is %s;@ it cannot be redefined as %s@]"
                                                        ]), match[0], match[1]);
                                      case /* No_overriding */23 :
                                          var name = param$1[1];
                                          if (name === "") {
                                            return Curry._1(Format.fprintf(param, /* Format */[
                                                            /* Formatting_gen */Block.__(18, [
                                                                /* Open_box */Block.__(1, [/* Format */[
                                                                      /* End_of_format */0,
                                                                      ""
                                                                    ]]),
                                                                /* String_literal */Block.__(11, [
                                                                    "This inheritance does not override any method",
                                                                    /* Formatting_lit */Block.__(17, [
                                                                        /* Break */Block.__(0, [
                                                                            "@ ",
                                                                            1,
                                                                            0
                                                                          ]),
                                                                        /* String */Block.__(2, [
                                                                            /* No_padding */0,
                                                                            /* Formatting_lit */Block.__(17, [
                                                                                /* Close_box */0,
                                                                                /* End_of_format */0
                                                                              ])
                                                                          ])
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "@[This inheritance does not override any method@ %s@]"
                                                          ]), "instance variable");
                                          } else {
                                            return Curry._2(Format.fprintf(param, /* Format */[
                                                            /* Formatting_gen */Block.__(18, [
                                                                /* Open_box */Block.__(1, [/* Format */[
                                                                      /* End_of_format */0,
                                                                      ""
                                                                    ]]),
                                                                /* String_literal */Block.__(11, [
                                                                    "The ",
                                                                    /* String */Block.__(2, [
                                                                        /* No_padding */0,
                                                                        /* String_literal */Block.__(11, [
                                                                            " `",
                                                                            /* String */Block.__(2, [
                                                                                /* No_padding */0,
                                                                                /* Char_literal */Block.__(12, [
                                                                                    /* "'" */39,
                                                                                    /* Formatting_lit */Block.__(17, [
                                                                                        /* Break */Block.__(0, [
                                                                                            "@ ",
                                                                                            1,
                                                                                            0
                                                                                          ]),
                                                                                        /* String_literal */Block.__(11, [
                                                                                            "has no previous definition",
                                                                                            /* Formatting_lit */Block.__(17, [
                                                                                                /* Close_box */0,
                                                                                                /* End_of_format */0
                                                                                              ])
                                                                                          ])
                                                                                      ])
                                                                                  ])
                                                                              ])
                                                                          ])
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "@[The %s `%s'@ has no previous definition@]"
                                                          ]), param$1[0], name);
                                          }
                                      case /* Duplicate */24 :
                                          return Curry._2(Format.fprintf(param, /* Format */[
                                                          /* Formatting_gen */Block.__(18, [
                                                              /* Open_box */Block.__(1, [/* Format */[
                                                                    /* End_of_format */0,
                                                                    ""
                                                                  ]]),
                                                              /* String_literal */Block.__(11, [
                                                                  "The ",
                                                                  /* String */Block.__(2, [
                                                                      /* No_padding */0,
                                                                      /* String_literal */Block.__(11, [
                                                                          " `",
                                                                          /* String */Block.__(2, [
                                                                              /* No_padding */0,
                                                                              /* Char_literal */Block.__(12, [
                                                                                  /* "'" */39,
                                                                                  /* Formatting_lit */Block.__(17, [
                                                                                      /* Break */Block.__(0, [
                                                                                          "@ ",
                                                                                          1,
                                                                                          0
                                                                                        ]),
                                                                                      /* String_literal */Block.__(11, [
                                                                                          "has multiple definitions in this object",
                                                                                          /* Formatting_lit */Block.__(17, [
                                                                                              /* Close_box */0,
                                                                                              /* End_of_format */0
                                                                                            ])
                                                                                        ])
                                                                                    ])
                                                                                ])
                                                                            ])
                                                                        ])
                                                                    ])
                                                                ])
                                                            ]),
                                                          "@[The %s `%s'@ has multiple definitions in this object@]"
                                                        ]), param$1[0], param$1[1]);
                                      
                                    }
                                  }));
                    }), param[3]);
      }));

var $$Error$10 = Caml_exceptions.create("Ocaml_typedtree_test.Typemod.Error");

var Error_forward$3 = Caml_exceptions.create("Ocaml_typedtree_test.Typemod.Error_forward");

function fst3(param) {
  return param[0];
}

function path_concat(head, p) {
  switch (p.tag | 0) {
    case /* Pident */0 :
        return /* Pdot */Block.__(1, [
                  /* Pident */Block.__(0, [head]),
                  p[0].name,
                  0
                ]);
    case /* Pdot */1 :
        return /* Pdot */Block.__(1, [
                  path_concat(head, p[0]),
                  p[1],
                  p[2]
                ]);
    case /* Papply */2 :
        throw [
              Caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "typemod.ml",
                54,
                16
              ]
            ];
    
  }
}

function extract_sig(env, loc, mty) {
  var match = scrape_alias(env, void 0, mty);
  if (match.tag === /* Mty_signature */1) {
    return match[0];
  }
  throw [
        $$Error$10,
        loc,
        env,
        /* Signature_expected */0
      ];
}

function extract_sig_open(env, loc, mty) {
  var match = scrape_alias(env, void 0, mty);
  if (match.tag === /* Mty_signature */1) {
    return match[0];
  }
  throw [
        $$Error$10,
        loc,
        env,
        /* Structure_expected */Block.__(3, [mty])
      ];
}

function type_open_(toplevel, ovf, env, loc, lid) {
  var match = find_module$1(env, lid.loc, lid.txt);
  var path = match[0];
  var sg = extract_sig_open(env, lid.loc, match[1].md_type);
  return /* tuple */[
          path,
          open_signature$1(loc, toplevel, ovf, path, sg, env)
        ];
}

function type_open$1(toplevel, env, sod) {
  var match = type_open_(toplevel, sod.popen_override, env, sod.popen_loc, sod.popen_lid);
  var path = match[0];
  var od_open_txt = sod.popen_lid;
  var od_open_override = sod.popen_override;
  var od_open_loc = sod.popen_loc;
  var od_open_attributes = sod.popen_attributes;
  var od = {
    open_path: path,
    open_txt: od_open_txt,
    open_override: od_open_override,
    open_loc: od_open_loc,
    open_attributes: od_open_attributes
  };
  return /* tuple */[
          path,
          match[1],
          od
        ];
}

var type_module_type_of_fwd = {
  contents: (function (env, m) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "typemod.ml",
              99,
              22
            ]
          ];
    })
};

function add_rec_types(_env, _param) {
  while(true) {
    var param = _param;
    var env = _env;
    if (!param) {
      return env;
    }
    var match = param[0];
    if (match.tag !== /* Sig_type */1) {
      return env;
    }
    if (match[2] < 2) {
      return env;
    }
    _param = param[1];
    _env = add_type$1(true, match[0], match[1], env);
    continue ;
  };
}

function check_type_decl(env, loc, id, row_id, newdecl, decl, rs, rem) {
  var env$1 = add_type$1(true, id, newdecl, env);
  var env$2 = row_id !== void 0 ? add_type$1(true, row_id, newdecl, env$1) : env$1;
  var env$3 = rs === /* Trec_not */0 ? env$2 : add_rec_types(env$2, rem);
  type_declarations$3(env$3, id, newdecl, decl);
  return check_coherence(env$3, loc, id, newdecl);
}

function update_rec_next(rs, rem) {
  if (rs >= 2) {
    return rem;
  }
  if (!rem) {
    return rem;
  }
  var match = rem[0];
  switch (match.tag | 0) {
    case /* Sig_type */1 :
        if (match[2] >= 2) {
          return /* :: */[
                  /* Sig_type */Block.__(1, [
                      match[0],
                      match[1],
                      rs
                    ]),
                  rem[1]
                ];
        } else {
          return rem;
        }
    case /* Sig_module */3 :
        if (match[2] >= 2) {
          return /* :: */[
                  /* Sig_module */Block.__(3, [
                      match[0],
                      match[1],
                      rs
                    ]),
                  rem[1]
                ];
        } else {
          return rem;
        }
    default:
      return rem;
  }
}

function merge_constraint(initial_env, loc, sg, constr) {
  var lid;
  switch (constr.tag | 0) {
    case /* Pwith_type */0 :
    case /* Pwith_module */1 :
        lid = constr[0];
        break;
    case /* Pwith_typesubst */2 :
        var s = constr[0].ptype_name;
        lid = {
          txt: /* Lident */Block.__(0, [s.txt]),
          loc: s.loc
        };
        break;
    case /* Pwith_modsubst */3 :
        var s$1 = constr[0];
        lid = {
          txt: /* Lident */Block.__(0, [s$1.txt]),
          loc: s$1.loc
        };
        break;
    
  }
  var real_id = {
    contents: void 0
  };
  var merge = function (env, _sg, namelist, _row_id) {
    while(true) {
      var row_id = _row_id;
      var sg = _sg;
      if (!sg) {
        throw [
              $$Error$10,
              loc,
              env,
              /* With_no_component */Block.__(4, [lid.txt])
            ];
      }
      var item = sg[0];
      switch (item.tag | 0) {
        case /* Sig_type */1 :
            if (namelist && !namelist[1]) {
              var s = namelist[0];
              var rem = sg[1];
              var rs = item[2];
              var decl = item[1];
              var id = item[0];
              var exit = 0;
              switch (constr.tag | 0) {
                case /* Pwith_type */0 :
                    var sdecl = constr[1];
                    var match = sdecl.ptype_kind;
                    var exit$1 = 0;
                    if (typeof match === "number" && !(match !== 0 || !(id.name === s && is_fixed_type(sdecl)))) {
                      var decl_row_type_params = List.map((function (param) {
                              return newty2(100000000, /* Tvar */Block.__(0, [void 0]));
                            }), sdecl.ptype_params);
                      var decl_row_type_arity = List.length(sdecl.ptype_params);
                      var decl_row_type_variance = List.map((function (param) {
                              var match;
                              switch (param[1]) {
                                case /* Covariant */0 :
                                    match = /* tuple */[
                                      true,
                                      false
                                    ];
                                    break;
                                case /* Contravariant */1 :
                                    match = /* tuple */[
                                      false,
                                      true
                                    ];
                                    break;
                                case /* Invariant */2 :
                                    match = /* tuple */[
                                      false,
                                      false
                                    ];
                                    break;
                                
                              }
                              var p = !match[1];
                              var n = !match[0];
                              var i = false;
                              return Curry._3(Types_Variance.set, /* May_pos */0, p, Curry._3(Types_Variance.set, /* May_neg */1, n, Curry._3(Types_Variance.set, /* May_weak */2, n, Curry._3(Types_Variance.set, /* Inj */3, i, Types_Variance.$$null))));
                            }), sdecl.ptype_params);
                      var decl_row_type_loc = sdecl.ptype_loc;
                      var decl_row = {
                        type_params: decl_row_type_params,
                        type_arity: decl_row_type_arity,
                        type_kind: /* Type_abstract */0,
                        type_private: /* Private */0,
                        type_manifest: void 0,
                        type_variance: decl_row_type_variance,
                        type_newtype_level: void 0,
                        type_loc: decl_row_type_loc,
                        type_attributes: /* [] */0
                      };
                      var id_row = create(s + "#row");
                      var initial_env$1 = add_type$1(true, id_row, decl_row, initial_env);
                      var tdecl = transl_with_constraint(initial_env$1, id, /* Pident */Block.__(0, [id_row]), decl, sdecl);
                      var newdecl = tdecl.typ_type;
                      check_type_decl(env, sdecl.ptype_loc, id, row_id, newdecl, decl, rs, rem);
                      var decl_row_type_params$1 = newdecl.type_params;
                      var decl_row_type_arity$1 = decl_row_type_arity;
                      var decl_row_type_variance$1 = decl_row_type_variance;
                      var decl_row_type_loc$1 = decl_row_type_loc;
                      var decl_row$1 = {
                        type_params: decl_row_type_params$1,
                        type_arity: decl_row_type_arity$1,
                        type_kind: /* Type_abstract */0,
                        type_private: /* Private */0,
                        type_manifest: void 0,
                        type_variance: decl_row_type_variance$1,
                        type_newtype_level: void 0,
                        type_loc: decl_row_type_loc$1,
                        type_attributes: /* [] */0
                      };
                      var rs$prime = rs === /* Trec_first */1 ? /* Trec_not */0 : rs;
                      return /* tuple */[
                              /* tuple */[
                                /* Pident */Block.__(0, [id]),
                                lid,
                                /* Twith_type */Block.__(0, [tdecl])
                              ],
                              /* :: */[
                                /* Sig_type */Block.__(1, [
                                    id_row,
                                    decl_row$1,
                                    rs$prime
                                  ]),
                                /* :: */[
                                  /* Sig_type */Block.__(1, [
                                      id,
                                      newdecl,
                                      rs
                                    ]),
                                  rem
                                ]
                              ]
                            ];
                    } else {
                      exit$1 = 3;
                    }
                    if (exit$1 === 3) {
                      if (id.name === s) {
                        var tdecl$1 = transl_with_constraint(initial_env, id, void 0, decl, sdecl);
                        var newdecl$1 = tdecl$1.typ_type;
                        check_type_decl(env, sdecl.ptype_loc, id, row_id, newdecl$1, decl, rs, rem);
                        return /* tuple */[
                                /* tuple */[
                                  /* Pident */Block.__(0, [id]),
                                  lid,
                                  /* Twith_type */Block.__(0, [tdecl$1])
                                ],
                                /* :: */[
                                  /* Sig_type */Block.__(1, [
                                      id,
                                      newdecl$1,
                                      rs
                                    ]),
                                  rem
                                ]
                              ];
                      } else {
                        exit = 2;
                      }
                    }
                    break;
                case /* Pwith_typesubst */2 :
                    exit = 2;
                    break;
                case /* Pwith_module */1 :
                case /* Pwith_modsubst */3 :
                    break;
                
              }
              if (exit === 2) {
                if (id.name === s + "#row") {
                  _row_id = id;
                  _sg = rem;
                  continue ;
                } else if (constr.tag) {
                  var sdecl$1 = constr[0];
                  if (id.name === s) {
                    var tdecl$2 = transl_with_constraint(initial_env, id, void 0, decl, sdecl$1);
                    var newdecl$2 = tdecl$2.typ_type;
                    check_type_decl(env, sdecl$1.ptype_loc, id, row_id, newdecl$2, decl, rs, rem);
                    real_id.contents = id;
                    return /* tuple */[
                            /* tuple */[
                              /* Pident */Block.__(0, [id]),
                              lid,
                              /* Twith_typesubst */Block.__(2, [tdecl$2])
                            ],
                            update_rec_next(rs, rem)
                          ];
                  }
                  
                }
                
              }
              
            }
            break;
        case /* Sig_module */3 :
            if (namelist) {
              var namelist$1 = namelist[1];
              var s$1 = namelist[0];
              var rem$1 = sg[1];
              var rs$1 = item[2];
              var md = item[1];
              var id$1 = item[0];
              var exit$2 = 0;
              if (namelist$1) {
                exit$2 = 2;
              } else {
                switch (constr.tag | 0) {
                  case /* Pwith_module */1 :
                      var lid$prime = constr[1];
                      if (id$1.name === s$1) {
                        var match$1 = find_module$1(initial_env, loc, lid$prime.txt);
                        var md$prime = match$1[1];
                        var path = match$1[0];
                        var md$prime$prime_md_type = remove_aliases$1(env, md$prime.md_type);
                        var md$prime$prime_md_attributes = md$prime.md_attributes;
                        var md$prime$prime_md_loc = md$prime.md_loc;
                        var md$prime$prime = {
                          md_type: md$prime$prime_md_type,
                          md_attributes: md$prime$prime_md_attributes,
                          md_loc: md$prime$prime_md_loc
                        };
                        var newmd = strengthen_decl(env, md$prime$prime, path);
                        modtypes$1(env, newmd.md_type, md.md_type);
                        return /* tuple */[
                                /* tuple */[
                                  /* Pident */Block.__(0, [id$1]),
                                  lid,
                                  /* Twith_module */Block.__(1, [
                                      path,
                                      lid$prime
                                    ])
                                ],
                                /* :: */[
                                  /* Sig_module */Block.__(3, [
                                      id$1,
                                      newmd,
                                      rs$1
                                    ]),
                                  rem$1
                                ]
                              ];
                      } else {
                        exit$2 = 2;
                      }
                      break;
                  case /* Pwith_type */0 :
                  case /* Pwith_typesubst */2 :
                      exit$2 = 2;
                      break;
                  case /* Pwith_modsubst */3 :
                      var lid$prime$1 = constr[1];
                      if (id$1.name === s$1) {
                        var match$2 = find_module$1(initial_env, loc, lid$prime$1.txt);
                        var path$1 = match$2[0];
                        var newmd$1 = strengthen_decl(env, match$2[1], path$1);
                        modtypes$1(env, newmd$1.md_type, md.md_type);
                        real_id.contents = id$1;
                        return /* tuple */[
                                /* tuple */[
                                  /* Pident */Block.__(0, [id$1]),
                                  lid,
                                  /* Twith_modsubst */Block.__(3, [
                                      path$1,
                                      lid$prime$1
                                    ])
                                ],
                                update_rec_next(rs$1, rem$1)
                              ];
                      } else {
                        exit$2 = 2;
                      }
                      break;
                  
                }
              }
              if (exit$2 === 2 && id$1.name === s$1) {
                var match$3 = merge(env, extract_sig(env, loc, md.md_type), namelist$1, void 0);
                var match$4 = match$3[0];
                return /* tuple */[
                        /* tuple */[
                          path_concat(id$1, match$4[0]),
                          lid,
                          match$4[2]
                        ],
                        /* :: */[
                          /* Sig_module */Block.__(3, [
                              id$1,
                              {
                                md_type: /* Mty_signature */Block.__(1, [match$3[1]]),
                                md_attributes: md.md_attributes,
                                md_loc: md.md_loc
                              },
                              rs$1
                            ]),
                          rem$1
                        ]
                      ];
              }
              
            }
            break;
        default:
          
      }
      var match$5 = merge(add_item(item, env), sg[1], namelist, row_id);
      return /* tuple */[
              match$5[0],
              /* :: */[
                item,
                match$5[1]
              ]
            ];
    };
  };
  try {
    var names = flat(/* [] */0, lid.txt);
    var match = merge(initial_env, sg, names, void 0);
    var sg$1 = match[1];
    var sg$2;
    if (names && !names[1]) {
      switch (constr.tag | 0) {
        case /* Pwith_type */0 :
        case /* Pwith_module */1 :
            sg$2 = sg$1;
            break;
        case /* Pwith_typesubst */2 :
            var sdecl = constr[0];
            var match$1 = real_id.contents;
            var id;
            if (match$1 === void 0) {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    /* tuple */[
                      "typemod.ml",
                      246,
                      38
                    ]
                  ];
            }
            id = match$1;
            var lid$1;
            try {
              var match$2 = sdecl.ptype_manifest;
              if (match$2 === void 0) {
                throw Pervasives.Exit;
              }
              var match$3 = match$2.ptyp_desc;
              if (typeof match$3 === "number") {
                throw Pervasives.Exit;
              }
              if (match$3.tag !== /* Ptyp_constr */3) {
                throw Pervasives.Exit;
              }
              var stl = match$3[1];
              if (List.length(stl) !== List.length(sdecl.ptype_params)) {
                throw Pervasives.Exit;
              }
              List.iter2((function (x, param) {
                      var match = x.ptyp_desc;
                      if (typeof match === "number") {
                        throw Pervasives.Exit;
                      }
                      if (match.tag) {
                        throw Pervasives.Exit;
                      }
                      var match$1 = param[0].ptyp_desc;
                      if (typeof match$1 === "number") {
                        throw Pervasives.Exit;
                      }
                      if (match$1.tag) {
                        throw Pervasives.Exit;
                      }
                      if (match[0] === match$1[0]) {
                        return ;
                      }
                      throw Pervasives.Exit;
                    }), stl, sdecl.ptype_params);
              lid$1 = match$3[0];
            }
            catch (exn){
              if (exn === Pervasives.Exit) {
                throw [
                      $$Error$10,
                      sdecl.ptype_loc,
                      initial_env,
                      /* With_need_typeconstr */2
                    ];
              }
              throw exn;
            }
            var match$4;
            try {
              match$4 = lookup_type$1(lid$1.txt, initial_env);
            }
            catch (exn$1){
              if (exn$1 === Caml_builtin_exceptions.not_found) {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      /* tuple */[
                        "typemod.ml",
                        263,
                        68
                      ]
                    ];
              }
              throw exn$1;
            }
            var sub = add_type(id, match$4[0], identity);
            sg$2 = signature$2(sub, sg$1);
            break;
        case /* Pwith_modsubst */3 :
            var match$5 = real_id.contents;
            var id$1;
            if (match$5 === void 0) {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    /* tuple */[
                      "typemod.ml",
                      269,
                      38
                    ]
                  ];
            }
            id$1 = match$5;
            var path = lookup_module$1(void 0, initial_env, loc, constr[1].txt);
            var sub$1 = add_module(id$1, path, identity);
            sg$2 = signature$2(sub$1, sg$1);
            break;
        
      }
    } else {
      sg$2 = sg$1;
    }
    return /* tuple */[
            match[0],
            sg$2
          ];
  }
  catch (raw_exn){
    var exn$2 = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn$2[0] === $$Error$5) {
      throw [
            $$Error$10,
            loc,
            initial_env,
            /* With_mismatch */Block.__(5, [
                lid.txt,
                exn$2[1]
              ])
          ];
    }
    throw exn$2;
  }
}

function map_rec(fn, decls, rem) {
  if (decls) {
    return /* :: */[
            Curry._2(fn, /* Trec_first */1, decls[0]),
            map_end(Curry._1(fn, /* Trec_next */2), decls[1], rem)
          ];
  } else {
    return rem;
  }
}

function map_rec_type(rec_flag, fn, decls, rem) {
  if (!decls) {
    return rem;
  }
  var first = rec_flag ? /* Trec_first */1 : /* Trec_not */0;
  return /* :: */[
          Curry._2(fn, first, decls[0]),
          map_end(Curry._1(fn, /* Trec_next */2), decls[1], rem)
        ];
}

function map_rec_type_with_row_types(rec_flag, fn, decls, rem) {
  if (!decls) {
    return rem;
  }
  var d1 = decls[0];
  if (is_row_name(d1.typ_id.name)) {
    return /* :: */[
            Curry._2(fn, /* Trec_not */0, d1),
            map_rec_type_with_row_types(rec_flag, fn, decls[1], rem)
          ];
  } else {
    return map_rec_type(rec_flag, fn, decls, rem);
  }
}

function rec_flag_of_ptype_declarations(tds) {
  var is_nonrec = List.exists((function (td) {
          return List.exists((function (param) {
                        return param[0].txt === "nonrec";
                      }), td.ptype_attributes);
        }), tds);
  if (is_nonrec) {
    return /* Nonrecursive */0;
  } else {
    return /* Recursive */1;
  }
}

function map_ext(fn, exts, rem) {
  if (exts) {
    return /* :: */[
            Curry._2(fn, /* Text_first */0, exts[0]),
            map_end(Curry._1(fn, /* Text_next */1), exts[1], rem)
          ];
  } else {
    return rem;
  }
}

function approx_modtype(env, _smty) {
  while(true) {
    var smty = _smty;
    var match = smty.pmty_desc;
    switch (match.tag | 0) {
      case /* Pmty_ident */0 :
          var match$1 = find_modtype$1(env, smty.pmty_loc, match[0].txt);
          return /* Mty_ident */Block.__(0, [match$1[0]]);
      case /* Pmty_signature */1 :
          return /* Mty_signature */Block.__(1, [approx_sig(env, match[0])]);
      case /* Pmty_functor */2 :
          var arg = may_map((function (param) {
                  return approx_modtype(env, param);
                }), match[1]);
          var match$2 = enter_module(true, match[0].txt, default_mty(arg), env);
          var res = approx_modtype(match$2[1], match[2]);
          return /* Mty_functor */Block.__(2, [
                    match$2[0],
                    arg,
                    res
                  ]);
      case /* Pmty_with */3 :
          _smty = match[0];
          continue ;
      case /* Pmty_typeof */4 :
          return Curry._2(type_module_type_of_fwd.contents, env, match[0])[1];
      case /* Pmty_extension */5 :
          throw [
                Error_forward$3,
                error_of_extension(match[0])
              ];
      case /* Pmty_alias */6 :
          var path = lookup_module$1(void 0, env, smty.pmty_loc, match[0].txt);
          return /* Mty_alias */Block.__(3, [path]);
      
    }
  };
}

function approx_module_declaration(env, pmd) {
  return {
          md_type: approx_modtype(env, pmd.pmd_type),
          md_attributes: pmd.pmd_attributes,
          md_loc: pmd.pmd_loc
        };
}

function approx_sig(_env, _ssg) {
  while(true) {
    var ssg = _ssg;
    var env = _env;
    if (!ssg) {
      return /* [] */0;
    }
    var srem = ssg[1];
    var match = ssg[0].psig_desc;
    switch (match.tag | 0) {
      case /* Psig_type */1 :
          var sdecls = match[0];
          var rec_flag = rec_flag_of_ptype_declarations(sdecls);
          var decls = approx_type_decl(env, sdecls);
          var rem = approx_sig(env, srem);
          return map_rec_type(rec_flag, (function (rs, param) {
                        return /* Sig_type */Block.__(1, [
                                  param[0],
                                  param[1],
                                  rs
                                ]);
                      }), decls, rem);
      case /* Psig_module */4 :
          var pmd = match[0];
          var md = approx_module_declaration(env, pmd);
          var match$1 = enter_module_declaration(void 0, pmd.pmd_name.txt, md, env);
          return /* :: */[
                  /* Sig_module */Block.__(3, [
                      match$1[0],
                      md,
                      /* Trec_not */0
                    ]),
                  approx_sig(match$1[1], srem)
                ];
      case /* Psig_recmodule */5 :
          var decls$1 = List.map((function(env){
              return function (pmd) {
                return /* tuple */[
                        create(pmd.pmd_name.txt),
                        approx_module_declaration(env, pmd)
                      ];
              }
              }(env)), match[0]);
          var newenv = List.fold_left((function (env, param) {
                  return add_module_declaration(void 0, param[0], param[1], env);
                }), env, decls$1);
          return map_rec((function (rs, param) {
                        return /* Sig_module */Block.__(3, [
                                  param[0],
                                  param[1],
                                  rs
                                ]);
                      }), decls$1, approx_sig(newenv, srem));
      case /* Psig_modtype */6 :
          var d = match[0];
          var info = approx_modtype_info(env, d);
          var match$2 = enter_modtype(d.pmtd_name.txt, info, env);
          return /* :: */[
                  /* Sig_modtype */Block.__(4, [
                      match$2[0],
                      info
                    ]),
                  approx_sig(match$2[1], srem)
                ];
      case /* Psig_open */7 :
          var match$3 = type_open$1(void 0, env, match[0]);
          _ssg = srem;
          _env = match$3[1];
          continue ;
      case /* Psig_include */8 :
          var smty = match[0].pincl_mod;
          var mty = approx_modtype(env, smty);
          var sg = signature$2(identity, extract_sig(env, smty.pmty_loc, mty));
          var newenv$1 = add_signature(sg, env);
          return Pervasives.$at(sg, approx_sig(newenv$1, srem));
      case /* Psig_class */9 :
      case /* Psig_class_type */10 :
          break;
      default:
        _ssg = srem;
        continue ;
    }
    var decls$2 = approx_class_declarations(env, match[0]);
    var rem$1 = approx_sig(env, srem);
    return List.flatten(map_rec((function (rs, param) {
                      return /* :: */[
                              /* Sig_class_type */Block.__(6, [
                                  param[0],
                                  param[2],
                                  rs
                                ]),
                              /* :: */[
                                /* Sig_type */Block.__(1, [
                                    param[3],
                                    param[4],
                                    rs
                                  ]),
                                /* :: */[
                                  /* Sig_type */Block.__(1, [
                                      param[5],
                                      param[6],
                                      rs
                                    ]),
                                  /* [] */0
                                ]
                              ]
                            ];
                    }), decls$2, /* :: */[
                    rem$1,
                    /* [] */0
                  ]));
  };
}

function approx_modtype_info(env, sinfo) {
  return {
          mtd_type: may_map((function (param) {
                  return approx_modtype(env, param);
                }), sinfo.pmtd_type),
          mtd_attributes: sinfo.pmtd_attributes,
          mtd_loc: sinfo.pmtd_loc
        };
}

function check_recmod_typedecls(env, sdecls, decls) {
  var recmod_ids = List.map(fst3, decls);
  return List.iter2((function (pmd, param) {
                var mty = param[2].mty_type;
                return List.iter((function (path) {
                              var loc = pmd.pmd_type.pmty_loc;
                              var decl = find_type_full(path, env)[0];
                              var to_check = function (path) {
                                return List.exists((function (id) {
                                              return isfree(id, path);
                                            }), recmod_ids);
                              };
                              check_well_founded_decl(env, loc, path, decl, to_check);
                              return check_recursion(env, loc, path, decl, to_check);
                            }), type_paths(env, /* Pident */Block.__(0, [param[0]]), mty));
              }), sdecls, decls);
}

function height$12(param) {
  if (param) {
    return param[/* h */3];
  } else {
    return 0;
  }
}

function create$13(l, v, r) {
  var hl = l ? l[/* h */3] : 0;
  var hr = r ? r[/* h */3] : 0;
  return /* Node */[
          /* l */l,
          /* v */v,
          /* r */r,
          /* h */hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        ];
}

function bal$12(l, v, r) {
  var hl = l ? l[/* h */3] : 0;
  var hr = r ? r[/* h */3] : 0;
  if (hl > (hr + 2 | 0)) {
    if (!l) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          ];
    }
    var lr = l[/* r */2];
    var lv = l[/* v */1];
    var ll = l[/* l */0];
    if (height$12(ll) >= height$12(lr)) {
      return create$13(ll, lv, create$13(lr, v, r));
    }
    if (lr) {
      return create$13(create$13(ll, lv, lr[/* l */0]), lr[/* v */1], create$13(lr[/* r */2], v, r));
    }
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Set.bal"
        ];
  } else {
    if (hr <= (hl + 2 | 0)) {
      return /* Node */[
              /* l */l,
              /* v */v,
              /* r */r,
              /* h */hl >= hr ? hl + 1 | 0 : hr + 1 | 0
            ];
    }
    if (!r) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Set.bal"
          ];
    }
    var rr = r[/* r */2];
    var rv = r[/* v */1];
    var rl = r[/* l */0];
    if (height$12(rr) >= height$12(rl)) {
      return create$13(create$13(l, v, rl), rv, rr);
    }
    if (rl) {
      return create$13(create$13(l, v, rl[/* l */0]), rl[/* v */1], create$13(rl[/* r */2], rv, rr));
    }
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Set.bal"
        ];
  }
}

function add$14(x, t) {
  if (!t) {
    return /* Node */[
            /* l : Empty */0,
            /* v */x,
            /* r : Empty */0,
            /* h */1
          ];
  }
  var r = t[/* r */2];
  var v = t[/* v */1];
  var l = t[/* l */0];
  var c = Caml_primitive.caml_string_compare(x, v);
  if (c === 0) {
    return t;
  }
  if (c < 0) {
    var ll = add$14(x, l);
    if (l === ll) {
      return t;
    } else {
      return bal$12(ll, v, r);
    }
  } else {
    var rr = add$14(x, r);
    if (r === rr) {
      return t;
    } else {
      return bal$12(l, v, rr);
    }
  }
}

function mem$7(x, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return false;
    }
    var c = Caml_primitive.caml_string_compare(x, param[/* v */1]);
    if (c === 0) {
      return true;
    }
    _param = c < 0 ? param[/* l */0] : param[/* r */2];
    continue ;
  };
}

function check(cl, loc, set_ref, name) {
  if (mem$7(name, set_ref.contents)) {
    throw [
          $$Error$10,
          loc,
          empty,
          /* Repeated_name */Block.__(6, [
              cl,
              name
            ])
        ];
  }
  set_ref.contents = add$14(name, set_ref.contents);
  
}

function check_name(cl, set_ref, name) {
  return check(cl, name.loc, set_ref, name.txt);
}

function check_sig_item(type_names, module_names, modtype_names, loc, param) {
  switch (param.tag | 0) {
    case /* Sig_type */1 :
        return check("type", loc, type_names, param[0].name);
    case /* Sig_module */3 :
        return check("module", loc, module_names, param[0].name);
    case /* Sig_modtype */4 :
        return check("module type", loc, modtype_names, param[0].name);
    default:
      return ;
  }
}

function remove_duplicates(val_ids, ext_ids, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return /* [] */0;
    }
    var f = param[0];
    switch (f.tag | 0) {
      case /* Sig_value */0 :
          var id = f[0];
          if (List.exists((function(id){
                return function (param) {
                  return equal(id, param);
                }
                }(id)), val_ids)) {
            _param = param[1];
            continue ;
          }
          break;
      case /* Sig_typext */2 :
          var id$1 = f[0];
          var exit = 0;
          if (f[2] !== 0) {
            exit = 2;
          } else {
            var match = param[1];
            if (match) {
              var match$1 = match[0];
              if (match$1.tag === /* Sig_typext */2 && !(match$1[2] !== 1 || !List.exists((function(id$1){
                      return function (param) {
                        return equal(id$1, param);
                      }
                      }(id$1)), ext_ids))) {
                _param = /* :: */[
                  /* Sig_typext */Block.__(2, [
                      match$1[0],
                      match$1[1],
                      /* Text_first */0
                    ]),
                  match[1]
                ];
                continue ;
              } else {
                exit = 2;
              }
            } else {
              exit = 2;
            }
          }
          if (exit === 2 && List.exists((function(id$1){
                return function (param) {
                  return equal(id$1, param);
                }
                }(id$1)), ext_ids)) {
            _param = param[1];
            continue ;
          }
          break;
      default:
        
    }
    return /* :: */[
            f,
            remove_duplicates(val_ids, ext_ids, param[1])
          ];
  };
}

function get_values(_param) {
  while(true) {
    var param = _param;
    if (!param) {
      return /* [] */0;
    }
    var f = param[0];
    if (!f.tag) {
      return /* :: */[
              f[0],
              get_values(param[1])
            ];
    }
    _param = param[1];
    continue ;
  };
}

function get_extension_constructors(_param) {
  while(true) {
    var param = _param;
    if (!param) {
      return /* [] */0;
    }
    var f = param[0];
    if (f.tag === /* Sig_typext */2) {
      return /* :: */[
              f[0],
              get_extension_constructors(param[1])
            ];
    }
    _param = param[1];
    continue ;
  };
}

function transl_modtype_longident$1(loc, env, lid) {
  return find_modtype$1(env, loc, lid)[0];
}

function transl_module_alias(loc, env, lid) {
  return lookup_module$1(void 0, env, loc, lid);
}

function mkmty$1(desc, typ, env, loc, attrs) {
  var mty = {
    mty_desc: desc,
    mty_type: typ,
    mty_env: env,
    mty_loc: loc,
    mty_attributes: attrs
  };
  add_saved_type(/* Partial_module_type */Block.__(7, [mty]));
  return mty;
}

function mksig$1(desc, env, loc) {
  var sg = {
    sig_desc: desc,
    sig_env: env,
    sig_loc: loc
  };
  add_saved_type(/* Partial_signature_item */Block.__(6, [sg]));
  return sg;
}

function transl_modtype$1(env, smty) {
  var loc = smty.pmty_loc;
  var match = smty.pmty_desc;
  switch (match.tag | 0) {
    case /* Pmty_ident */0 :
        var lid = match[0];
        var path = transl_modtype_longident$1(loc, env, lid.txt);
        return mkmty$1(/* Tmty_ident */Block.__(0, [
                      path,
                      lid
                    ]), /* Mty_ident */Block.__(0, [path]), env, loc, smty.pmty_attributes);
    case /* Pmty_signature */1 :
        var sg = transl_signature(env, match[0]);
        return mkmty$1(/* Tmty_signature */Block.__(1, [sg]), /* Mty_signature */Block.__(1, [sg.sig_type]), env, loc, smty.pmty_attributes);
    case /* Pmty_functor */2 :
        var param = match[0];
        var arg = may_map((function (param) {
                return transl_modtype$1(env, param);
              }), match[1]);
        var ty_arg = may_map((function (m) {
                return m.mty_type;
              }), arg);
        var match$1 = enter_module(true, param.txt, default_mty(ty_arg), env);
        var id = match$1[0];
        init_def(currentstamp.contents);
        var res = transl_modtype$1(match$1[1], match[2]);
        return mkmty$1(/* Tmty_functor */Block.__(2, [
                      id,
                      param,
                      arg,
                      res
                    ]), /* Mty_functor */Block.__(2, [
                      id,
                      ty_arg,
                      res.mty_type
                    ]), env, loc, smty.pmty_attributes);
    case /* Pmty_with */3 :
        var sbody = match[0];
        var body = transl_modtype$1(env, sbody);
        var init_sg = extract_sig(env, sbody.pmty_loc, body.mty_type);
        var match$2 = List.fold_left((function (param, sdecl) {
                var match = merge_constraint(env, smty.pmty_loc, param[1], sdecl);
                return /* tuple */[
                        /* :: */[
                          match[0],
                          param[0]
                        ],
                        match[1]
                      ];
              }), /* tuple */[
              /* [] */0,
              init_sg
            ], match[1]);
        return mkmty$1(/* Tmty_with */Block.__(3, [
                      body,
                      List.rev(match$2[0])
                    ]), modtype(identity, /* Mty_signature */Block.__(1, [match$2[1]])), env, loc, smty.pmty_attributes);
    case /* Pmty_typeof */4 :
        var match$3 = Curry._2(type_module_type_of_fwd.contents, env, match[0]);
        return mkmty$1(/* Tmty_typeof */Block.__(4, [match$3[0]]), match$3[1], env, loc, smty.pmty_attributes);
    case /* Pmty_extension */5 :
        throw [
              Error_forward$3,
              error_of_extension(match[0])
            ];
    case /* Pmty_alias */6 :
        var lid$1 = match[0];
        var path$1 = transl_module_alias(loc, env, lid$1.txt);
        return mkmty$1(/* Tmty_alias */Block.__(5, [
                      path$1,
                      lid$1
                    ]), /* Mty_alias */Block.__(3, [path$1]), env, loc, smty.pmty_attributes);
    
  }
}

function transl_signature(env, sg) {
  var type_names = {
    contents: /* Empty */0
  };
  var module_names = {
    contents: /* Empty */0
  };
  var modtype_names = {
    contents: /* Empty */0
  };
  var transl_sig = function (env, sg) {
    init_def(currentstamp.contents);
    if (!sg) {
      return /* tuple */[
              /* [] */0,
              /* [] */0,
              env
            ];
    }
    var srem = sg[1];
    var item = sg[0];
    var loc = item.psig_loc;
    var match = item.psig_desc;
    switch (match.tag | 0) {
      case /* Psig_value */0 :
          var match$1 = transl_value_decl(env, item.psig_loc, match[0]);
          var tdesc = match$1[0];
          var match$2 = transl_sig(match$1[1], srem);
          var rem = match$2[1];
          var partial_arg = tdesc.val_id;
          return /* tuple */[
                  /* :: */[
                    mksig$1(/* Tsig_value */Block.__(0, [tdesc]), env, loc),
                    match$2[0]
                  ],
                  List.exists((function (param) {
                          return equal(partial_arg, param);
                        }), get_values(rem)) ? rem : /* :: */[
                      /* Sig_value */Block.__(0, [
                          tdesc.val_id,
                          tdesc.val_val
                        ]),
                      rem
                    ],
                  match$2[2]
                ];
      case /* Psig_type */1 :
          var sdecls = match[0];
          var rec_flag = rec_flag_of_ptype_declarations(sdecls);
          List.iter((function (decl) {
                  return check_name("type", type_names, decl.ptype_name);
                }), sdecls);
          var match$3 = transl_type_decl(env, rec_flag, sdecls);
          var decls = match$3[0];
          var match$4 = transl_sig(match$3[1], srem);
          return /* tuple */[
                  /* :: */[
                    mksig$1(/* Tsig_type */Block.__(1, [decls]), env, loc),
                    match$4[0]
                  ],
                  map_rec_type_with_row_types(rec_flag, (function (rs, td) {
                          return /* Sig_type */Block.__(1, [
                                    td.typ_id,
                                    td.typ_type,
                                    rs
                                  ]);
                        }), decls, match$4[1]),
                  match$4[2]
                ];
      case /* Psig_typext */2 :
          var match$5 = transl_type_extension(false, env, item.psig_loc, match[0]);
          var tyext = match$5[0];
          var match$6 = transl_sig(match$5[1], srem);
          var rem$1 = match$6[1];
          var constructors = List.filter((function (ext) {
                    var partial_arg = ext.ext_id;
                    return !List.exists((function (param) {
                                  return equal(partial_arg, param);
                                }), get_extension_constructors(rem$1));
                  }))(tyext.tyext_constructors);
          return /* tuple */[
                  /* :: */[
                    mksig$1(/* Tsig_typext */Block.__(2, [tyext]), env, loc),
                    match$6[0]
                  ],
                  map_ext((function (es, ext) {
                          return /* Sig_typext */Block.__(2, [
                                    ext.ext_id,
                                    ext.ext_type,
                                    es
                                  ]);
                        }), constructors, rem$1),
                  match$6[2]
                ];
      case /* Psig_exception */3 :
          var match$7 = transl_exception(env, match[0]);
          var ext = match$7[0];
          var match$8 = transl_sig(match$7[1], srem);
          var rem$2 = match$8[1];
          var partial_arg$1 = ext.ext_id;
          var shadowed = List.exists((function (param) {
                  return equal(partial_arg$1, param);
                }), get_extension_constructors(rem$2));
          return /* tuple */[
                  /* :: */[
                    mksig$1(/* Tsig_exception */Block.__(3, [ext]), env, loc),
                    match$8[0]
                  ],
                  shadowed ? rem$2 : /* :: */[
                      /* Sig_typext */Block.__(2, [
                          ext.ext_id,
                          ext.ext_type,
                          /* Text_exception */2
                        ]),
                      rem$2
                    ],
                  match$8[2]
                ];
      case /* Psig_module */4 :
          var pmd = match[0];
          check_name("module", module_names, pmd.pmd_name);
          var tmty = transl_modtype$1(env, pmd.pmd_type);
          var md_md_type = tmty.mty_type;
          var md_md_attributes = pmd.pmd_attributes;
          var md_md_loc = pmd.pmd_loc;
          var md = {
            md_type: md_md_type,
            md_attributes: md_md_attributes,
            md_loc: md_md_loc
          };
          var match$9 = enter_module_declaration(void 0, pmd.pmd_name.txt, md, env);
          var id = match$9[0];
          var match$10 = transl_sig(match$9[1], srem);
          return /* tuple */[
                  /* :: */[
                    mksig$1(/* Tsig_module */Block.__(4, [{
                              md_id: id,
                              md_name: pmd.pmd_name,
                              md_type: tmty,
                              md_attributes: pmd.pmd_attributes,
                              md_loc: pmd.pmd_loc
                            }]), env, loc),
                    match$10[0]
                  ],
                  /* :: */[
                    /* Sig_module */Block.__(3, [
                        id,
                        md,
                        /* Trec_not */0
                      ]),
                    match$10[1]
                  ],
                  match$10[2]
                ];
      case /* Psig_recmodule */5 :
          var sdecls$1 = match[0];
          List.iter((function (pmd) {
                  return check_name("module", module_names, pmd.pmd_name);
                }), sdecls$1);
          var match$11 = transl_recmodule_modtypes(item.psig_loc, env, sdecls$1);
          var decls$1 = match$11[0];
          var match$12 = transl_sig(match$11[1], srem);
          return /* tuple */[
                  /* :: */[
                    mksig$1(/* Tsig_recmodule */Block.__(5, [decls$1]), env, loc),
                    match$12[0]
                  ],
                  map_rec((function (rs, md) {
                          var d_md_type = md.md_type.mty_type;
                          var d_md_attributes = md.md_attributes;
                          var d_md_loc = md.md_loc;
                          var d = {
                            md_type: d_md_type,
                            md_attributes: d_md_attributes,
                            md_loc: d_md_loc
                          };
                          return /* Sig_module */Block.__(3, [
                                    md.md_id,
                                    d,
                                    rs
                                  ]);
                        }), decls$1, match$12[1]),
                  match$12[2]
                ];
      case /* Psig_modtype */6 :
          var match$13 = transl_modtype_decl(modtype_names, env, item.psig_loc, match[0]);
          var match$14 = transl_sig(match$13[0], srem);
          return /* tuple */[
                  /* :: */[
                    mksig$1(/* Tsig_modtype */Block.__(6, [match$13[1]]), env, loc),
                    match$14[0]
                  ],
                  /* :: */[
                    match$13[2],
                    match$14[1]
                  ],
                  match$14[2]
                ];
      case /* Psig_open */7 :
          var match$15 = type_open$1(void 0, env, match[0]);
          var match$16 = transl_sig(match$15[1], srem);
          return /* tuple */[
                  /* :: */[
                    mksig$1(/* Tsig_open */Block.__(7, [match$15[2]]), env, loc),
                    match$16[0]
                  ],
                  match$16[1],
                  match$16[2]
                ];
      case /* Psig_include */8 :
          var sincl = match[0];
          var smty = sincl.pincl_mod;
          var tmty$1 = transl_modtype$1(env, smty);
          var mty = tmty$1.mty_type;
          var sg$1 = signature$2(identity, extract_sig(env, smty.pmty_loc, mty));
          var partial_arg$2 = item.psig_loc;
          List.iter((function (param) {
                  return check_sig_item(type_names, module_names, modtype_names, partial_arg$2, param);
                }), sg$1);
          var newenv = add_signature(sg$1, env);
          var incl_incl_loc = sincl.pincl_loc;
          var incl_incl_attributes = sincl.pincl_attributes;
          var incl = {
            incl_mod: tmty$1,
            incl_type: sg$1,
            incl_loc: incl_incl_loc,
            incl_attributes: incl_incl_attributes
          };
          var match$17 = transl_sig(newenv, srem);
          var rem$3 = match$17[1];
          return /* tuple */[
                  /* :: */[
                    mksig$1(/* Tsig_include */Block.__(8, [incl]), env, loc),
                    match$17[0]
                  ],
                  Pervasives.$at(remove_duplicates(get_values(rem$3), get_extension_constructors(rem$3), sg$1), rem$3),
                  match$17[2]
                ];
      case /* Psig_class */9 :
          var cl = match[0];
          List.iter((function (param) {
                  return check_name("type", type_names, param.pci_name);
                }), cl);
          var match$18 = class_descriptions(env, cl);
          var classes = match$18[0];
          var match$19 = transl_sig(match$18[1], srem);
          return /* tuple */[
                  /* :: */[
                    mksig$1(/* Tsig_class */Block.__(9, [List.map2((function (pcl, tcl) {
                                    return tcl[11];
                                  }), cl, classes)]), env, loc),
                    match$19[0]
                  ],
                  List.flatten(map_rec((function (rs, param) {
                              return /* :: */[
                                      /* Sig_class */Block.__(5, [
                                          param[0],
                                          param[2],
                                          rs
                                        ]),
                                      /* :: */[
                                        /* Sig_class_type */Block.__(6, [
                                            param[3],
                                            param[4],
                                            rs
                                          ]),
                                        /* :: */[
                                          /* Sig_type */Block.__(1, [
                                              param[5],
                                              param[6],
                                              rs
                                            ]),
                                          /* :: */[
                                            /* Sig_type */Block.__(1, [
                                                param[7],
                                                param[8],
                                                rs
                                              ]),
                                            /* [] */0
                                          ]
                                        ]
                                      ]
                                    ];
                            }), classes, /* :: */[
                            match$19[1],
                            /* [] */0
                          ])),
                  match$19[2]
                ];
      case /* Psig_class_type */10 :
          var cl$1 = match[0];
          List.iter((function (param) {
                  return check_name("type", type_names, param.pci_name);
                }), cl$1);
          var match$20 = class_type_declarations$2(env, cl$1);
          var classes$1 = match$20[0];
          var match$21 = transl_sig(match$20[1], srem);
          return /* tuple */[
                  /* :: */[
                    mksig$1(/* Tsig_class_type */Block.__(10, [List.map2((function (pcl, tcl) {
                                    return tcl[7];
                                  }), cl$1, classes$1)]), env, loc),
                    match$21[0]
                  ],
                  List.flatten(map_rec((function (rs, param) {
                              return /* :: */[
                                      /* Sig_class_type */Block.__(6, [
                                          param[0],
                                          param[2],
                                          rs
                                        ]),
                                      /* :: */[
                                        /* Sig_type */Block.__(1, [
                                            param[3],
                                            param[4],
                                            rs
                                          ]),
                                        /* :: */[
                                          /* Sig_type */Block.__(1, [
                                              param[5],
                                              param[6],
                                              rs
                                            ]),
                                          /* [] */0
                                        ]
                                      ]
                                    ];
                            }), classes$1, /* :: */[
                            match$21[1],
                            /* [] */0
                          ])),
                  match$21[2]
                ];
      case /* Psig_attribute */11 :
          var x = match[0];
          warning_attribute(/* :: */[
                x,
                /* [] */0
              ]);
          var match$22 = transl_sig(env, srem);
          return /* tuple */[
                  /* :: */[
                    mksig$1(/* Tsig_attribute */Block.__(11, [x]), env, loc),
                    match$22[0]
                  ],
                  match$22[1],
                  match$22[2]
                ];
      case /* Psig_extension */12 :
          throw [
                Error_forward$3,
                error_of_extension(match[0])
              ];
      
    }
  };
  var previous_saved_types = saved_types.contents;
  warning_enter_scope(void 0);
  var match = transl_sig(in_signature(env), sg);
  var sg_sig_items = match[0];
  var sg_sig_type = match[1];
  var sg_sig_final_env = match[2];
  var sg$1 = {
    sig_items: sg_sig_items,
    sig_type: sg_sig_type,
    sig_final_env: sg_sig_final_env
  };
  warning_leave_scope(void 0);
  saved_types.contents = /* :: */[
    /* Partial_signature */Block.__(5, [sg$1]),
    previous_saved_types
  ];
  return sg$1;
}

function transl_modtype_decl(modtype_names, env, loc, param) {
  var pmtd_loc = param.pmtd_loc;
  var pmtd_attributes = param.pmtd_attributes;
  var pmtd_name = param.pmtd_name;
  check_name("module type", modtype_names, pmtd_name);
  var tmty = may_map((function (param) {
          return transl_modtype$1(env, param);
        }), param.pmtd_type);
  var decl_mtd_type = may_map((function (t) {
          return t.mty_type;
        }), tmty);
  var decl = {
    mtd_type: decl_mtd_type,
    mtd_attributes: pmtd_attributes,
    mtd_loc: pmtd_loc
  };
  var match = enter_modtype(pmtd_name.txt, decl, env);
  var id = match[0];
  var mtd = {
    mtd_id: id,
    mtd_name: pmtd_name,
    mtd_type: tmty,
    mtd_attributes: pmtd_attributes,
    mtd_loc: pmtd_loc
  };
  return /* tuple */[
          match[1],
          mtd,
          /* Sig_modtype */Block.__(4, [
              id,
              decl
            ])
        ];
}

function transl_recmodule_modtypes(loc, env, sdecls) {
  var make_env = function (curr) {
    return List.fold_left((function (env, param) {
                  return add_module$1(true, param[0], param[2], env);
                }), env, curr);
  };
  var make_env2 = function (curr) {
    return List.fold_left((function (env, param) {
                  return add_module$1(true, param[0], param[2].mty_type, env);
                }), env, curr);
  };
  var transition = function (env_c, curr) {
    return List.map2((function (pmd, param) {
                  return /* tuple */[
                          param[0],
                          param[1],
                          transl_modtype$1(env_c, pmd.pmd_type)
                        ];
                }), sdecls, curr);
  };
  var ids = List.map((function (x) {
          return create(x.pmd_name.txt);
        }), sdecls);
  var approx_env = List.fold_left((function (env, id) {
          var dummy = /* Mty_ident */Block.__(0, [/* Pident */Block.__(0, [create("#recmod#")])]);
          return add_module$1(true, id, dummy, env);
        }), env, ids);
  var init = List.map2((function (id, pmd) {
          return /* tuple */[
                  id,
                  pmd.pmd_name,
                  approx_modtype(approx_env, pmd.pmd_type)
                ];
        }), ids, sdecls);
  var env0 = make_env(init);
  var dcl1 = transition(env0, init);
  var env1 = make_env2(dcl1);
  check_recmod_typedecls(env1, sdecls, dcl1);
  var dcl2 = transition(env1, dcl1);
  var env2 = make_env2(dcl2);
  check_recmod_typedecls(env2, sdecls, dcl2);
  var dcl2$1 = List.map2((function (pmd, param) {
          return {
                  md_id: param[0],
                  md_name: param[1],
                  md_type: param[2],
                  md_attributes: pmd.pmd_attributes,
                  md_loc: pmd.pmd_loc
                };
        }), sdecls, dcl2);
  return /* tuple */[
          dcl2$1,
          env2
        ];
}

function simplify_signature(sg) {
  var aux = function (param) {
    if (!param) {
      return /* tuple */[
              /* [] */0,
              /* Empty */0,
              /* Empty */0
            ];
    }
    var component = param[0];
    switch (component.tag | 0) {
      case /* Sig_value */0 :
          var k = aux(param[1]);
          var val_names = k[1];
          var name = component[0].name;
          if (mem$7(name, val_names)) {
            return k;
          } else {
            return /* tuple */[
                    /* :: */[
                      component,
                      k[0]
                    ],
                    add$14(name, val_names),
                    k[2]
                  ];
          }
      case /* Sig_typext */2 :
          var k$1 = aux(param[1]);
          var ext_names = k$1[2];
          var val_names$1 = k$1[1];
          var sg = k$1[0];
          var name$1 = component[0].name;
          if (!mem$7(name$1, ext_names)) {
            return /* tuple */[
                    /* :: */[
                      component,
                      sg
                    ],
                    val_names$1,
                    add$14(name$1, ext_names)
                  ];
          }
          if (component[2] !== 0) {
            return k$1;
          }
          if (!sg) {
            return k$1;
          }
          var match = sg[0];
          if (match.tag === /* Sig_typext */2 && match[2] === 1) {
            return /* tuple */[
                    /* :: */[
                      /* Sig_typext */Block.__(2, [
                          match[0],
                          match[1],
                          /* Text_first */0
                        ]),
                      sg[1]
                    ],
                    val_names$1,
                    ext_names
                  ];
          } else {
            return k$1;
          }
      default:
        var match$1 = aux(param[1]);
        return /* tuple */[
                /* :: */[
                  component,
                  match$1[0]
                ],
                match$1[1],
                match$1[2]
              ];
    }
  };
  return aux(sg)[0];
}

var Not_a_path = Caml_exceptions.create("Ocaml_typedtree_test.Typemod.Not_a_path");

function path_of_module(_mexp) {
  while(true) {
    var mexp = _mexp;
    var match = mexp.mod_desc;
    switch (match.tag | 0) {
      case /* Tmod_ident */0 :
          return match[0];
      case /* Tmod_apply */3 :
          if (applicative_functors.contents) {
            return /* Papply */Block.__(2, [
                      path_of_module(match[0]),
                      path_of_module(match[1])
                    ]);
          }
          throw Not_a_path;
      case /* Tmod_constraint */4 :
          _mexp = match[0];
          continue ;
      default:
        throw Not_a_path;
    }
  };
}

function path_of_module$1(mexp) {
  try {
    return path_of_module(mexp);
  }
  catch (exn){
    if (exn === Not_a_path) {
      return ;
    }
    throw exn;
  }
}

function closed_modtype(_param) {
  while(true) {
    var param = _param;
    switch (param.tag | 0) {
      case /* Mty_signature */1 :
          return List.for_all(closed_signature_item, param[0]);
      case /* Mty_functor */2 :
          _param = param[2];
          continue ;
      case /* Mty_ident */0 :
      case /* Mty_alias */3 :
          return true;
      
    }
  };
}

function closed_signature_item(param) {
  switch (param.tag | 0) {
    case /* Sig_value */0 :
        return closed_schema(param[1].val_type);
    case /* Sig_module */3 :
        return closed_modtype(param[1].md_type);
    default:
      return true;
  }
}

function anchor_submodule(name, anchor) {
  if (anchor !== void 0) {
    return /* Pdot */Block.__(1, [
              anchor,
              name,
              -1
            ]);
  }
  
}

function enrich_type_decls(anchor, decls, oldenv, newenv) {
  if (anchor === void 0) {
    return newenv;
  }
  var p = anchor;
  return List.fold_left((function (e, info) {
                var id = info.typ_id;
                var info$prime = enrich_typedecl(oldenv, /* Pdot */Block.__(1, [
                        p,
                        id.name,
                        -1
                      ]), info.typ_type);
                return add_type$1(true, id, info$prime, e);
              }), oldenv, decls);
}

function enrich_module_type(anchor, name, mty, env) {
  if (anchor !== void 0) {
    return enrich_modtype(env, /* Pdot */Block.__(1, [
                  anchor,
                  name,
                  -1
                ]), mty);
  } else {
    return mty;
  }
}

function check_recmodule_inclusion(env, bindings) {
  var subst_and_strengthen = function (env, s, id, mty) {
    return strengthen$1(env, modtype(s, mty), module_path(s, /* Pident */Block.__(0, [id])));
  };
  var _first_time = true;
  var _n = List.length(bindings);
  var _env = env;
  var _s = identity;
  while(true) {
    var s = _s;
    var env$1 = _env;
    var n = _n;
    var first_time = _first_time;
    if (n > 0) {
      var bindings1 = List.map((function (param) {
              var id = param[0];
              return /* tuple */[
                      id,
                      rename(id),
                      param[4]
                    ];
            }), bindings);
      var env$prime = List.fold_left((function(first_time,s){
          return function (env, param) {
            var mty_actual = param[2];
            var mty_actual$prime = first_time ? mty_actual : subst_and_strengthen(env, s, param[0], mty_actual);
            return add_module$1(false, param[1], mty_actual$prime, env);
          }
          }(first_time,s)), env$1, bindings1);
      var s$prime = List.fold_left((function (s, param) {
              return add_module(param[0], /* Pident */Block.__(0, [param[1]]), s);
            }), identity, bindings1);
      _s = s$prime;
      _env = env$prime;
      _n = n - 1 | 0;
      _first_time = false;
      continue ;
    } else {
      var check_inclusion = (function(env$1,s){
      return function check_inclusion(param) {
        var modl = param[3];
        var mty_decl = param[2];
        var id = param[0];
        var mty_decl$prime = modtype(s, mty_decl.mty_type);
        var mty_actual$prime = subst_and_strengthen(env$1, s, id, param[4]);
        var coercion;
        try {
          coercion = modtypes$1(env$1, mty_actual$prime, mty_decl$prime);
        }
        catch (raw_exn){
          var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn[0] === $$Error$5) {
            throw [
                  $$Error$10,
                  modl.mod_loc,
                  env$1,
                  /* Not_included */Block.__(1, [exn[1]])
                ];
          }
          throw exn;
        }
        var modl$prime_mod_desc = /* Tmod_constraint */Block.__(4, [
            modl,
            mty_decl.mty_type,
            /* Tmodtype_explicit */[mty_decl],
            coercion
          ]);
        var modl$prime_mod_loc = modl.mod_loc;
        var modl$prime_mod_type = mty_decl.mty_type;
        var modl$prime = {
          mod_desc: modl$prime_mod_desc,
          mod_loc: modl$prime_mod_loc,
          mod_type: modl$prime_mod_type,
          mod_env: env$1,
          mod_attributes: /* [] */0
        };
        return {
                mb_id: id,
                mb_name: param[1],
                mb_expr: modl$prime,
                mb_attributes: param[5],
                mb_loc: param[6]
              };
      }
      }(env$1,s));
      return List.map(check_inclusion, bindings);
    }
  };
}

function package_constraints(env, loc, mty, constrs) {
  if (constrs === /* [] */0) {
    return mty;
  }
  var sg = extract_sig(env, loc, mty);
  var sg$prime = List.map((function (item) {
          switch (item.tag | 0) {
            case /* Sig_type */1 :
                var td = item[1];
                if (td.type_params) {
                  return item;
                }
                var id = item[0];
                if (!List.mem_assoc(/* :: */[
                        id.name,
                        /* [] */0
                      ], constrs)) {
                  return item;
                }
                var ty = List.assoc(/* :: */[
                      id.name,
                      /* [] */0
                    ], constrs);
                return /* Sig_type */Block.__(1, [
                          id,
                          {
                            type_params: td.type_params,
                            type_arity: td.type_arity,
                            type_kind: td.type_kind,
                            type_private: td.type_private,
                            type_manifest: ty,
                            type_variance: td.type_variance,
                            type_newtype_level: td.type_newtype_level,
                            type_loc: td.type_loc,
                            type_attributes: td.type_attributes
                          },
                          item[2]
                        ]);
            case /* Sig_module */3 :
                var md = item[1];
                var id$1 = item[0];
                var aux = function (_param) {
                  while(true) {
                    var param = _param;
                    if (!param) {
                      return /* [] */0;
                    }
                    var match = param[0];
                    var match$1 = match[0];
                    if (match$1) {
                      var l = match$1[1];
                      if (l) {
                        if (match$1[0] === id$1.name) {
                          return /* :: */[
                                  /* tuple */[
                                    l,
                                    match[1]
                                  ],
                                  aux(param[1])
                                ];
                        }
                        _param = param[1];
                        continue ;
                      } else {
                        _param = param[1];
                        continue ;
                      }
                    } else {
                      _param = param[1];
                      continue ;
                    }
                  };
                };
                var md_md_type = package_constraints(env, loc, md.md_type, aux(constrs));
                var md_md_attributes = md.md_attributes;
                var md_md_loc = md.md_loc;
                var md$1 = {
                  md_type: md_md_type,
                  md_attributes: md_md_attributes,
                  md_loc: md_md_loc
                };
                return /* Sig_module */Block.__(3, [
                          id$1,
                          md$1,
                          item[2]
                        ]);
            default:
              return item;
          }
        }), sg);
  return /* Mty_signature */Block.__(1, [sg$prime]);
}

function modtype_of_package(env, loc, p, nl, tl) {
  try {
    var match = find_modtype(p, env).mtd_type;
    var exit = 0;
    if (match !== void 0) {
      if (nl !== /* [] */0) {
        return package_constraints(env, loc, match, List.combine(List.map(flatten, nl), tl));
      }
      exit = 1;
    } else {
      exit = 1;
    }
    if (exit === 1) {
      if (nl === /* [] */0) {
        return /* Mty_ident */Block.__(0, [p]);
      }
      throw [
            $$Error$10,
            loc,
            env,
            /* Signature_expected */0
          ];
    }
    
  }
  catch (exn){
    if (exn !== Caml_builtin_exceptions.not_found) {
      throw exn;
    }
    var error = /* Unbound_modtype */Block.__(22, [lid_of_path(void 0, p)]);
    throw [
          $$Error$6,
          loc,
          env,
          error
        ];
  }
}

function package_subtype$1(env, p1, nl1, tl1, p2, nl2, tl2) {
  var mkmty = function (p, nl, tl) {
    var ntl = List.filter((function (param) {
              return free_variables$1(void 0, param[1]) === /* [] */0;
            }))(List.combine(nl, tl));
    var match = List.split(ntl);
    return modtype_of_package(env, none, p, match[0], match[1]);
  };
  var mty1 = mkmty(p1, nl1, tl1);
  var mty2 = mkmty(p2, nl2, tl2);
  try {
    return modtypes$1(env, mty1, mty2) === /* Tcoerce_none */0;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === $$Error$5) {
      return false;
    }
    throw exn;
  }
}

package_subtype.contents = package_subtype$1;

function wrap_constraint(env, arg, mty, explicit) {
  var coercion;
  try {
    coercion = modtypes$1(env, arg.mod_type, mty);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === $$Error$5) {
      throw [
            $$Error$10,
            arg.mod_loc,
            env,
            /* Not_included */Block.__(1, [exn[1]])
          ];
    }
    throw exn;
  }
  return {
          mod_desc: /* Tmod_constraint */Block.__(4, [
              arg,
              mty,
              explicit,
              coercion
            ]),
          mod_loc: arg.mod_loc,
          mod_type: mty,
          mod_env: env,
          mod_attributes: /* [] */0
        };
}

function type_module$1(aliasOpt, sttn, funct_body, anchor, env, smod) {
  var alias = aliasOpt !== void 0 ? aliasOpt : false;
  var match = smod.pmod_desc;
  switch (match.tag | 0) {
    case /* Pmod_ident */0 :
        var lid = match[0];
        var path = lookup_module$1(!alias, env, smod.pmod_loc, lid.txt);
        var md_mod_desc = /* Tmod_ident */Block.__(0, [
            path,
            lid
          ]);
        var md_mod_loc = smod.pmod_loc;
        var md_mod_type = /* Mty_alias */Block.__(3, [path]);
        var md_mod_attributes = smod.pmod_attributes;
        var md = {
          mod_desc: md_mod_desc,
          mod_loc: md_mod_loc,
          mod_type: md_mod_type,
          mod_env: env,
          mod_attributes: md_mod_attributes
        };
        var node;
        if (alias && !is_functor_arg(path, env)) {
          add_required_global(head(path));
          node = md;
        } else {
          var mty = find_module(false, path, env).md_type;
          var exit = 0;
          if (mty.tag === /* Mty_alias */3 && !alias) {
            var p1 = normalize_path$1(smod.pmod_loc, env, mty[0]);
            var mty$1 = expand_module_alias(env, /* [] */0, p1);
            node = {
              mod_desc: /* Tmod_constraint */Block.__(4, [
                  md,
                  mty$1,
                  /* Tmodtype_implicit */0,
                  /* Tcoerce_alias */Block.__(3, [
                      p1,
                      /* Tcoerce_none */0
                    ])
                ]),
              mod_loc: md_mod_loc,
              mod_type: sttn ? strengthen$1(env, mty$1, p1) : mty$1,
              mod_env: env,
              mod_attributes: md_mod_attributes
            };
          } else {
            exit = 1;
          }
          if (exit === 1) {
            var mty$2 = sttn ? strengthen$1(env, mty, path) : mty;
            node = {
              mod_desc: md_mod_desc,
              mod_loc: md_mod_loc,
              mod_type: mty$2,
              mod_env: env,
              mod_attributes: md_mod_attributes
            };
          }
          
        }
        record$2(/* Ti_mod */Block.__(3, [node]));
        return node;
    case /* Pmod_structure */1 :
        var match$1 = type_structure(void 0, funct_body, anchor, env, match[0], smod.pmod_loc);
        var sg = match$1[1];
        var node_mod_desc = /* Tmod_structure */Block.__(1, [match$1[0]]);
        var node_mod_loc = smod.pmod_loc;
        var node_mod_type = /* Mty_signature */Block.__(1, [sg]);
        var node_mod_attributes = smod.pmod_attributes;
        var node$1 = {
          mod_desc: node_mod_desc,
          mod_loc: node_mod_loc,
          mod_type: node_mod_type,
          mod_env: env,
          mod_attributes: node_mod_attributes
        };
        record$2(/* Ti_mod */Block.__(3, [node$1]));
        var sg$prime = simplify_signature(sg);
        if (List.length(sg$prime) === List.length(sg)) {
          return node$1;
        } else {
          return wrap_constraint(implicit_coercion(env), node$1, /* Mty_signature */Block.__(1, [sg$prime]), /* Tmodtype_implicit */0);
        }
    case /* Pmod_functor */2 :
        var name = match[0];
        var mty$3 = may_map((function (param) {
                return transl_modtype$1(env, param);
              }), match[1]);
        var ty_arg = may_map((function (m) {
                return m.mty_type;
              }), mty$3);
        var match$2 = ty_arg !== void 0 ? /* tuple */[
            enter_module(true, name.txt, ty_arg, env),
            true
          ] : /* tuple */[
            /* tuple */[
              create("*"),
              env
            ],
            false
          ];
        var match$3 = match$2[0];
        var id = match$3[0];
        var body = type_module$1(void 0, sttn, match$2[1], void 0, match$3[1], match[2]);
        var node_mod_desc$1 = /* Tmod_functor */Block.__(2, [
            id,
            name,
            mty$3,
            body
          ]);
        var node_mod_loc$1 = smod.pmod_loc;
        var node_mod_type$1 = /* Mty_functor */Block.__(2, [
            id,
            ty_arg,
            body.mod_type
          ]);
        var node_mod_attributes$1 = smod.pmod_attributes;
        var node$2 = {
          mod_desc: node_mod_desc$1,
          mod_loc: node_mod_loc$1,
          mod_type: node_mod_type$1,
          mod_env: env,
          mod_attributes: node_mod_attributes$1
        };
        record$2(/* Ti_mod */Block.__(3, [node$2]));
        return node$2;
    case /* Pmod_apply */3 :
        var sarg = match[1];
        var sfunct = match[0];
        var arg = type_module$1(void 0, true, funct_body, void 0, env, sarg);
        var path$1 = path_of_module$1(arg);
        var funct = type_module$1(void 0, sttn && path$1 !== void 0, funct_body, void 0, env, sfunct);
        var mty_functor = scrape_alias(env, void 0, funct.mod_type);
        if (mty_functor.tag !== /* Mty_functor */2) {
          throw [
                $$Error$10,
                sfunct.pmod_loc,
                env,
                /* Cannot_apply */Block.__(0, [funct.mod_type])
              ];
        }
        var mty_res = mty_functor[2];
        var mty_param = mty_functor[1];
        var param = mty_functor[0];
        var generative = mty_param === void 0;
        var mty_param$1 = default_mty(mty_param);
        if (generative) {
          if (Caml_obj.caml_notequal(sarg.pmod_desc, /* Pmod_structure */Block.__(1, [/* [] */0]))) {
            throw [
                  $$Error$10,
                  sfunct.pmod_loc,
                  env,
                  /* Apply_generative */4
                ];
          }
          if (funct_body && contains_type$1(env, funct.mod_type)) {
            throw [
                  $$Error$10,
                  smod.pmod_loc,
                  env,
                  /* Not_allowed_in_functor_body */1
                ];
          }
          
        }
        var coercion;
        try {
          coercion = modtypes$1(env, arg.mod_type, mty_param$1);
        }
        catch (raw_exn){
          var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn[0] === $$Error$5) {
            throw [
                  $$Error$10,
                  sarg.pmod_loc,
                  env,
                  /* Not_included */Block.__(1, [exn[1]])
                ];
          }
          throw exn;
        }
        var mty_appl;
        if (path$1 !== void 0) {
          mty_appl = modtype(add_module(param, path$1, identity), mty_res);
        } else if (generative) {
          mty_appl = mty_res;
        } else {
          try {
            mty_appl = nondep_supertype(add_module$1(true, param, arg.mod_type, env), param, mty_res);
          }
          catch (exn$1){
            if (exn$1 === Caml_builtin_exceptions.not_found) {
              throw [
                    $$Error$10,
                    smod.pmod_loc,
                    env,
                    /* Cannot_eliminate_dependency */Block.__(2, [mty_functor])
                  ];
            }
            throw exn$1;
          }
        }
        var node_mod_desc$2 = /* Tmod_apply */Block.__(3, [
            funct,
            arg,
            coercion
          ]);
        var node_mod_loc$2 = smod.pmod_loc;
        var node_mod_attributes$2 = smod.pmod_attributes;
        var node$3 = {
          mod_desc: node_mod_desc$2,
          mod_loc: node_mod_loc$2,
          mod_type: mty_appl,
          mod_env: env,
          mod_attributes: node_mod_attributes$2
        };
        record$2(/* Ti_mod */Block.__(3, [node$3]));
        return node$3;
    case /* Pmod_constraint */4 :
        var arg$1 = type_module$1(alias, true, funct_body, anchor, env, match[0]);
        var mty$4 = transl_modtype$1(env, match[1]);
        var init = wrap_constraint(env, arg$1, mty$4.mty_type, /* Tmodtype_explicit */[mty$4]);
        var node_mod_desc$3 = init.mod_desc;
        var node_mod_loc$3 = smod.pmod_loc;
        var node_mod_type$2 = init.mod_type;
        var node_mod_env = init.mod_env;
        var node_mod_attributes$3 = smod.pmod_attributes;
        var node$4 = {
          mod_desc: node_mod_desc$3,
          mod_loc: node_mod_loc$3,
          mod_type: node_mod_type$2,
          mod_env: node_mod_env,
          mod_attributes: node_mod_attributes$3
        };
        record$2(/* Ti_mod */Block.__(3, [node$4]));
        return node$4;
    case /* Pmod_unpack */5 :
        if (principal.contents) {
          begin_def(void 0);
        }
        var exp = type_exp(env, match[0]);
        if (principal.contents) {
          end_def(void 0);
          generalize_structure$1(current_level.contents, exp.exp_type);
        }
        var match$4 = expand_head(env, exp.exp_type);
        var match$5 = match$4.desc;
        var mty$5;
        var exit$1 = 0;
        if (typeof match$5 === "number") {
          exit$1 = 1;
        } else {
          switch (match$5.tag | 0) {
            case /* Tvar */0 :
                throw [
                      $$Error$7,
                      smod.pmod_loc,
                      env,
                      /* Cannot_infer_signature */3
                    ];
            case /* Tpackage */11 :
                var tl = match$5[2];
                if (List.exists((function (t) {
                          return free_variables$1(void 0, t) !== /* [] */0;
                        }), tl)) {
                  throw [
                        $$Error$10,
                        smod.pmod_loc,
                        env,
                        /* Incomplete_packed_module */Block.__(13, [exp.exp_type])
                      ];
                }
                if (principal.contents && !generalizable(99999999, exp.exp_type)) {
                  prerr_warning(smod.pmod_loc, /* Not_principal */Block.__(8, ["this module unpacking"]));
                }
                mty$5 = modtype_of_package(env, smod.pmod_loc, match$5[0], match$5[1], tl);
                break;
            default:
              exit$1 = 1;
          }
        }
        if (exit$1 === 1) {
          throw [
                $$Error$10,
                smod.pmod_loc,
                env,
                /* Not_a_packed_module */Block.__(12, [exp.exp_type])
              ];
        }
        if (funct_body && contains_type$1(env, mty$5)) {
          throw [
                $$Error$10,
                smod.pmod_loc,
                env,
                /* Not_allowed_in_functor_body */1
              ];
        }
        var node_mod_desc$4 = /* Tmod_unpack */Block.__(5, [
            exp,
            mty$5
          ]);
        var node_mod_loc$4 = smod.pmod_loc;
        var node_mod_attributes$4 = smod.pmod_attributes;
        var node$5 = {
          mod_desc: node_mod_desc$4,
          mod_loc: node_mod_loc$4,
          mod_type: mty$5,
          mod_env: env,
          mod_attributes: node_mod_attributes$4
        };
        record$2(/* Ti_mod */Block.__(3, [node$5]));
        return node$5;
    case /* Pmod_extension */6 :
        throw [
              Error_forward$3,
              error_of_extension(match[0])
            ];
    
  }
}

function type_structure(toplevelOpt, funct_body, anchor, env, sstr, scope) {
  var toplevel = toplevelOpt !== void 0 ? toplevelOpt : false;
  var type_names = {
    contents: /* Empty */0
  };
  var module_names = {
    contents: /* Empty */0
  };
  var modtype_names = {
    contents: /* Empty */0
  };
  var type_str_item = function (env, srem, param) {
    var loc = param.pstr_loc;
    var desc = param.pstr_desc;
    switch (desc.tag | 0) {
      case /* Pstr_eval */0 :
          var expr = type_expression(env, desc[0]);
          return /* tuple */[
                  /* Tstr_eval */Block.__(0, [
                      expr,
                      desc[1]
                    ]),
                  /* [] */0,
                  env
                ];
      case /* Pstr_value */1 :
          var rec_flag = desc[0];
          var scope$1;
          if (rec_flag) {
            scope$1 = /* Idef */Block.__(1, [{
                  loc_start: loc.loc_start,
                  loc_end: scope.loc_end,
                  loc_ghost: scope.loc_ghost
                }]);
          } else {
            var start = srem ? srem[0].pstr_loc.loc_start : loc.loc_end;
            scope$1 = /* Idef */Block.__(1, [{
                  loc_start: start,
                  loc_end: scope.loc_end,
                  loc_ghost: scope.loc_ghost
                }]);
          }
          var match = type_binding(env, rec_flag, desc[1], scope$1);
          var newenv = match[1];
          var defs = match[0];
          return /* tuple */[
                  /* Tstr_value */Block.__(1, [
                      rec_flag,
                      defs
                    ]),
                  List.map((function (id) {
                          return /* Sig_value */Block.__(0, [
                                    id,
                                    find_value(/* Pident */Block.__(0, [id]), newenv)
                                  ]);
                        }), let_bound_idents(defs)),
                  newenv
                ];
      case /* Pstr_primitive */2 :
          var match$1 = transl_value_decl(env, loc, desc[0]);
          var desc$1 = match$1[0];
          return /* tuple */[
                  /* Tstr_primitive */Block.__(2, [desc$1]),
                  /* :: */[
                    /* Sig_value */Block.__(0, [
                        desc$1.val_id,
                        desc$1.val_val
                      ]),
                    /* [] */0
                  ],
                  match$1[1]
                ];
      case /* Pstr_type */3 :
          var sdecls = desc[0];
          var rec_flag$1 = rec_flag_of_ptype_declarations(sdecls);
          List.iter((function (decl) {
                  return check_name("type", type_names, decl.ptype_name);
                }), sdecls);
          var match$2 = transl_type_decl(env, rec_flag$1, sdecls);
          var decls = match$2[0];
          return /* tuple */[
                  /* Tstr_type */Block.__(3, [decls]),
                  map_rec_type_with_row_types(rec_flag$1, (function (rs, info) {
                          return /* Sig_type */Block.__(1, [
                                    info.typ_id,
                                    info.typ_type,
                                    rs
                                  ]);
                        }), decls, /* [] */0),
                  enrich_type_decls(anchor, decls, env, match$2[1])
                ];
      case /* Pstr_typext */4 :
          var match$3 = transl_type_extension(true, env, loc, desc[0]);
          var tyext = match$3[0];
          return /* tuple */[
                  /* Tstr_typext */Block.__(4, [tyext]),
                  map_ext((function (es, ext) {
                          return /* Sig_typext */Block.__(2, [
                                    ext.ext_id,
                                    ext.ext_type,
                                    es
                                  ]);
                        }), tyext.tyext_constructors, /* [] */0),
                  match$3[1]
                ];
      case /* Pstr_exception */5 :
          var match$4 = transl_exception(env, desc[0]);
          var ext = match$4[0];
          return /* tuple */[
                  /* Tstr_exception */Block.__(5, [ext]),
                  /* :: */[
                    /* Sig_typext */Block.__(2, [
                        ext.ext_id,
                        ext.ext_type,
                        /* Text_exception */2
                      ]),
                    /* [] */0
                  ],
                  match$4[1]
                ];
      case /* Pstr_module */6 :
          var match$5 = desc[0];
          var pmb_loc = match$5.pmb_loc;
          var attrs = match$5.pmb_attributes;
          var name = match$5.pmb_name;
          check_name("module", module_names, name);
          var modl = type_module$1(true, true, funct_body, anchor_submodule(name.txt, anchor), env, match$5.pmb_expr);
          var md_md_type = enrich_module_type(anchor, name.txt, modl.mod_type, env);
          var md = {
            md_type: md_md_type,
            md_attributes: attrs,
            md_loc: pmb_loc
          };
          var match$6 = enter_module_declaration(void 0, name.txt, md, env);
          var id = match$6[0];
          return /* tuple */[
                  /* Tstr_module */Block.__(6, [{
                        mb_id: id,
                        mb_name: name,
                        mb_expr: modl,
                        mb_attributes: attrs,
                        mb_loc: pmb_loc
                      }]),
                  /* :: */[
                    /* Sig_module */Block.__(3, [
                        id,
                        {
                          md_type: modl.mod_type,
                          md_attributes: attrs,
                          md_loc: pmb_loc
                        },
                        /* Trec_not */0
                      ]),
                    /* [] */0
                  ],
                  match$6[1]
                ];
      case /* Pstr_recmodule */7 :
          var sbind = List.map((function (mb) {
                  var match = mb.pmb_expr.pmod_desc;
                  if (match.tag === /* Pmod_constraint */4) {
                    return /* tuple */[
                            mb.pmb_name,
                            match[1],
                            match[0],
                            mb.pmb_attributes,
                            mb.pmb_loc
                          ];
                  }
                  throw [
                        $$Error$10,
                        mb.pmb_expr.pmod_loc,
                        env,
                        /* Recursive_module_require_explicit_type */3
                      ];
                }), desc[0]);
          List.iter((function (param) {
                  return check_name("module", module_names, param[0]);
                }), sbind);
          var match$7 = transl_recmodule_modtypes(loc, env, List.map((function (param) {
                      return {
                              pmd_name: param[0],
                              pmd_type: param[1],
                              pmd_attributes: param[3],
                              pmd_loc: param[4]
                            };
                    }), sbind));
          var newenv$1 = match$7[1];
          var decls$1 = match$7[0];
          var bindings1 = List.map2((function (param, param$1) {
                  var id = param.md_id;
                  var modl = type_module$1(void 0, true, funct_body, /* Pident */Block.__(0, [id]), newenv$1, param$1[2]);
                  var mty$prime = enrich_module_type(anchor, id.name, modl.mod_type, newenv$1);
                  return /* tuple */[
                          id,
                          param$1[0],
                          param.md_type,
                          modl,
                          mty$prime,
                          param$1[3],
                          param$1[4]
                        ];
                }), decls$1, sbind);
          var newenv$2 = List.fold_left((function (env, md) {
                  var mdecl_md_type = md.md_type.mty_type;
                  var mdecl_md_attributes = md.md_attributes;
                  var mdecl_md_loc = md.md_loc;
                  var mdecl = {
                    md_type: mdecl_md_type,
                    md_attributes: mdecl_md_attributes,
                    md_loc: mdecl_md_loc
                  };
                  return add_module_declaration(void 0, md.md_id, mdecl, env);
                }), env, decls$1);
          var bindings2 = check_recmodule_inclusion(newenv$2, bindings1);
          return /* tuple */[
                  /* Tstr_recmodule */Block.__(7, [bindings2]),
                  map_rec((function (rs, mb) {
                          return /* Sig_module */Block.__(3, [
                                    mb.mb_id,
                                    {
                                      md_type: mb.mb_expr.mod_type,
                                      md_attributes: mb.mb_attributes,
                                      md_loc: mb.mb_loc
                                    },
                                    rs
                                  ]);
                        }), bindings2, /* [] */0),
                  newenv$2
                ];
      case /* Pstr_modtype */8 :
          var match$8 = transl_modtype_decl(modtype_names, env, loc, desc[0]);
          return /* tuple */[
                  /* Tstr_modtype */Block.__(8, [match$8[1]]),
                  /* :: */[
                    match$8[2],
                    /* [] */0
                  ],
                  match$8[0]
                ];
      case /* Pstr_open */9 :
          var match$9 = type_open$1(toplevel, env, desc[0]);
          return /* tuple */[
                  /* Tstr_open */Block.__(9, [match$9[2]]),
                  /* [] */0,
                  match$9[1]
                ];
      case /* Pstr_class */10 :
          var cl = desc[0];
          List.iter((function (param) {
                  return check_name("type", type_names, param.pci_name);
                }), cl);
          var match$10 = class_declarations$2(env, cl);
          var classes = match$10[0];
          return /* tuple */[
                  /* Tstr_class */Block.__(10, [List.map((function (param) {
                              var vf = param[2].cty_new === void 0 ? /* Virtual */0 : /* Concrete */1;
                              return /* tuple */[
                                      param[11],
                                      param[10],
                                      vf
                                    ];
                            }), classes)]),
                  List.flatten(map_rec((function (rs, param) {
                              return /* :: */[
                                      /* Sig_class */Block.__(5, [
                                          param[0],
                                          param[2],
                                          rs
                                        ]),
                                      /* :: */[
                                        /* Sig_class_type */Block.__(6, [
                                            param[3],
                                            param[4],
                                            rs
                                          ]),
                                        /* :: */[
                                          /* Sig_type */Block.__(1, [
                                              param[5],
                                              param[6],
                                              rs
                                            ]),
                                          /* :: */[
                                            /* Sig_type */Block.__(1, [
                                                param[7],
                                                param[8],
                                                rs
                                              ]),
                                            /* [] */0
                                          ]
                                        ]
                                      ]
                                    ];
                            }), classes, /* [] */0)),
                  match$10[1]
                ];
      case /* Pstr_class_type */11 :
          var cl$1 = desc[0];
          List.iter((function (param) {
                  return check_name("type", type_names, param.pci_name);
                }), cl$1);
          var match$11 = class_type_declarations$2(env, cl$1);
          var classes$1 = match$11[0];
          return /* tuple */[
                  /* Tstr_class_type */Block.__(11, [List.map((function (param) {
                              return /* tuple */[
                                      param[0],
                                      param[1],
                                      param[7]
                                    ];
                            }), classes$1)]),
                  List.flatten(map_rec((function (rs, param) {
                              return /* :: */[
                                      /* Sig_class_type */Block.__(6, [
                                          param[0],
                                          param[2],
                                          rs
                                        ]),
                                      /* :: */[
                                        /* Sig_type */Block.__(1, [
                                            param[3],
                                            param[4],
                                            rs
                                          ]),
                                        /* :: */[
                                          /* Sig_type */Block.__(1, [
                                              param[5],
                                              param[6],
                                              rs
                                            ]),
                                          /* [] */0
                                        ]
                                      ]
                                    ];
                            }), classes$1, /* [] */0)),
                  match$11[1]
                ];
      case /* Pstr_include */12 :
          var sincl = desc[0];
          var smodl = sincl.pincl_mod;
          var modl$1 = type_module$1(void 0, true, funct_body, void 0, env, smodl);
          var sg = signature$2(identity, extract_sig_open(env, smodl.pmod_loc, modl$1.mod_type));
          var match$12 = modl$1.mod_desc;
          var sg$1;
          if (match$12.tag) {
            sg$1 = sg;
          } else {
            var p = match$12[0];
            if (is_functor_arg(p, env)) {
              sg$1 = sg;
            } else {
              add_required_global(head(p));
              var pos = {
                contents: 0
              };
              sg$1 = List.map((function (it) {
                      switch (it.tag | 0) {
                        case /* Sig_value */0 :
                            var match = it[1].val_kind;
                            if (typeof match === "number" && match === 0) {
                              pos.contents = pos.contents + 1 | 0;
                              return it;
                            } else {
                              return it;
                            }
                        case /* Sig_module */3 :
                            var md = it[1];
                            var id = it[0];
                            var n = pos.contents;
                            pos.contents = pos.contents + 1 | 0;
                            return /* Sig_module */Block.__(3, [
                                      id,
                                      {
                                        md_type: /* Mty_alias */Block.__(3, [/* Pdot */Block.__(1, [
                                                p,
                                                id.name,
                                                n
                                              ])]),
                                        md_attributes: md.md_attributes,
                                        md_loc: md.md_loc
                                      },
                                      it[2]
                                    ]);
                        case /* Sig_typext */2 :
                        case /* Sig_class */5 :
                            pos.contents = pos.contents + 1 | 0;
                            return it;
                        default:
                          return it;
                      }
                    }), sg);
            }
          }
          List.iter((function (param) {
                  return check_sig_item(type_names, module_names, modtype_names, loc, param);
                }), sg$1);
          var new_env = add_signature(sg$1, env);
          var incl_incl_loc = sincl.pincl_loc;
          var incl_incl_attributes = sincl.pincl_attributes;
          var incl = {
            incl_mod: modl$1,
            incl_type: sg$1,
            incl_loc: incl_incl_loc,
            incl_attributes: incl_incl_attributes
          };
          return /* tuple */[
                  /* Tstr_include */Block.__(12, [incl]),
                  sg$1,
                  new_env
                ];
      case /* Pstr_attribute */13 :
          var x = desc[0];
          warning_attribute(/* :: */[
                x,
                /* [] */0
              ]);
          return /* tuple */[
                  /* Tstr_attribute */Block.__(13, [x]),
                  /* [] */0,
                  env
                ];
      case /* Pstr_extension */14 :
          throw [
                Error_forward$3,
                error_of_extension(desc[0])
              ];
      
    }
  };
  var type_struct = function (env, sstr) {
    init_def(currentstamp.contents);
    if (!sstr) {
      return /* tuple */[
              /* [] */0,
              /* [] */0,
              env
            ];
    }
    var srem = sstr[1];
    var pstr = sstr[0];
    var previous_saved_types = saved_types.contents;
    var match = type_str_item(env, srem, pstr);
    var str_str_desc = match[0];
    var str_str_loc = pstr.pstr_loc;
    var str = {
      str_desc: str_str_desc,
      str_loc: str_str_loc,
      str_env: env
    };
    saved_types.contents = /* :: */[
      /* Partial_structure_item */Block.__(1, [str]),
      previous_saved_types
    ];
    var match$1 = type_struct(match[2], srem);
    return /* tuple */[
            /* :: */[
              str,
              match$1[0]
            ],
            Pervasives.$at(match[1], match$1[1]),
            match$1[2]
          ];
  };
  if (annotations.contents) {
    List.iter((function (param) {
            var loc = param.pstr_loc;
            if (annotations.contents) {
              phrases.contents = /* :: */[
                loc,
                phrases.contents
              ];
              return ;
            }
            
          }), sstr);
  }
  var previous_saved_types = saved_types.contents;
  warning_enter_scope(void 0);
  var match = type_struct(env, sstr);
  var final_env = match[2];
  var sg = match[1];
  var str_str_items = match[0];
  var str = {
    str_items: str_str_items,
    str_type: sg,
    str_final_env: final_env
  };
  warning_leave_scope(void 0);
  saved_types.contents = /* :: */[
    /* Partial_structure */Block.__(0, [str]),
    previous_saved_types
  ];
  return /* tuple */[
          str,
          sg,
          final_env
        ];
}

function type_module$2(param, param$1) {
  return type_module$1(void 0, true, false, void 0, param, param$1);
}

function type_structure$1(param, param$1, param$2) {
  return type_structure(void 0, false, void 0, param, param$1, param$2);
}

function normalize_signature(env) {
  return (function (param) {
      return List.iter((function (param) {
                    switch (param.tag | 0) {
                      case /* Sig_value */0 :
                          return normalize_type(env, param[1].val_type);
                      case /* Sig_module */3 :
                          var _param = param[1].md_type;
                          while(true) {
                            var param$1 = _param;
                            switch (param$1.tag | 0) {
                              case /* Mty_signature */1 :
                                  return normalize_signature(env)(param$1[0]);
                              case /* Mty_functor */2 :
                                  _param = param$1[2];
                                  continue ;
                              case /* Mty_ident */0 :
                              case /* Mty_alias */3 :
                                  return ;
                              
                            }
                          };
                      default:
                        return ;
                    }
                  }), param);
    });
}

function type_module_type_of(env, smod) {
  var match = smod.pmod_desc;
  var tmty;
  if (match.tag) {
    tmty = type_module$2(env, smod);
  } else {
    var lid = match[0];
    var match$1 = find_module$1(env, smod.pmod_loc, lid.txt);
    var node_mod_desc = /* Tmod_ident */Block.__(0, [
        match$1[0],
        lid
      ]);
    var node_mod_loc = smod.pmod_loc;
    var node_mod_type = match$1[1].md_type;
    var node_mod_attributes = smod.pmod_attributes;
    var node = {
      mod_desc: node_mod_desc,
      mod_loc: node_mod_loc,
      mod_type: node_mod_type,
      mod_env: env,
      mod_attributes: node_mod_attributes
    };
    record$2(/* Ti_mod */Block.__(3, [node]));
    tmty = node;
  }
  var mty = tmty.mod_type;
  var mty$1 = remove_aliases$1(env, mty);
  if (!closed_modtype(mty$1)) {
    throw [
          $$Error$10,
          smod.pmod_loc,
          env,
          /* Non_generalizable_module */Block.__(9, [mty$1])
        ];
  }
  return /* tuple */[
          tmty,
          mty$1
        ];
}

function type_package$1(env, m, p, nl, tl) {
  var lv = current_level.contents;
  begin_def(void 0);
  set_current_time(lv);
  var context = narrow(void 0);
  var modl = type_module$2(env, m);
  init_def(currentstamp.contents);
  widen(context);
  var match = modl.mod_desc;
  var match$1;
  if (match.tag) {
    var match$2 = enter_module(true, "%M", modl.mod_type, env);
    match$1 = /* tuple */[
      /* Pident */Block.__(0, [match$2[0]]),
      match$2[1]
    ];
  } else {
    match$1 = /* tuple */[
      match[0],
      env
    ];
  }
  var env$1 = match$1[1];
  var mp = match$1[0];
  var mkpath = function (mp, param) {
    switch (param.tag | 0) {
      case /* Lident */0 :
          return /* Pdot */Block.__(1, [
                    mp,
                    param[0],
                    -1
                  ]);
      case /* Ldot */1 :
          return /* Pdot */Block.__(1, [
                    mkpath(mp, param[0]),
                    param[1],
                    -1
                  ]);
      case /* Lapply */2 :
          throw [
                Caml_builtin_exceptions.assert_failure,
                /* tuple */[
                  "typemod.ml",
                  1565,
                  11
                ]
              ];
      
    }
  };
  var tl$prime = List.map((function (name) {
          return newty2(100000000, /* Tconstr */Block.__(3, [
                        mkpath(mp, name),
                        /* [] */0,
                        {
                          contents: /* Mnil */0
                        }
                      ]));
        }), nl);
  end_def(void 0);
  if (nl === /* [] */0) {
    return /* tuple */[
            wrap_constraint(env$1, modl, /* Mty_ident */Block.__(0, [p]), /* Tmodtype_implicit */0),
            /* [] */0
          ];
  }
  var mty = modtype_of_package(env$1, modl.mod_loc, p, nl, tl$prime);
  List.iter2((function (n, ty) {
          try {
            return unify$2(env$1, ty, newvar(void 0, void 0));
          }
          catch (raw_exn){
            var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn[0] === Unify) {
              throw [
                    $$Error$10,
                    m.pmod_loc,
                    env$1,
                    /* Scoping_pack */Block.__(14, [
                        n,
                        ty
                      ])
                  ];
            }
            throw exn;
          }
        }), nl, tl$prime);
  return /* tuple */[
          wrap_constraint(env$1, modl, mty, /* Tmodtype_implicit */0),
          tl$prime
        ];
}

type_module.contents = type_module$2;

transl_modtype_longident.contents = transl_modtype_longident$1;

transl_modtype.contents = transl_modtype$1;

type_open.contents = (function (param, param$1, param$2, param$3) {
    return type_open_(void 0, param, param$1, param$2, param$3);
  });

type_package.contents = type_package$1;

type_module_type_of_fwd.contents = type_module_type_of;

function type_implementation_more(sourcefile, outputprefix, modulename, initial_env, ast) {
  clear(void 0);
  try {
    delayed_checks.contents = /* [] */0;
    required_globals.contents = /* [] */0;
    Curry._2(newrecord$1.structure, newrecord$1, ast);
    var match = type_structure$1(initial_env, ast, in_file(sourcefile));
    var finalenv = match[2];
    var sg = match[1];
    var str = match[0];
    var simple_sg = simplify_signature(sg);
    if (print_types.contents) {
      wrap_printing_env(initial_env, (function (param) {
              return Curry._2(Format.fprintf(Format.std_formatter, /* Format */[
                              /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                      /* Flush_newline */4,
                                      /* End_of_format */0
                                    ])]),
                              "%a@."
                            ]), signature$3, simple_sg);
            }));
      return /* tuple */[
              str,
              /* Tcoerce_none */0,
              finalenv,
              simple_sg
            ];
    } else {
      var sourceintf = chop_extension_if_any(sourcefile) + interface_suffix.contents;
      var mli_status = assume_no_mli.contents;
      if (mli_status === /* Mli_na */0 && Caml_external_polyfill.resolve("caml_sys_file_exists")(sourceintf) || mli_status === /* Mli_exists */1) {
        var intf_file;
        try {
          intf_file = find_in_path_uncap(load_path.contents, modulename + ".cmi");
        }
        catch (exn){
          if (exn === Caml_builtin_exceptions.not_found) {
            throw [
                  $$Error$10,
                  in_file(sourcefile),
                  empty,
                  /* Interface_not_compiled */Block.__(11, [sourceintf])
                ];
          }
          throw exn;
        }
        var dclsig = read_signature(modulename, intf_file);
        var coercion = compunit(initial_env, sourcefile, sg, intf_file, dclsig);
        force_delayed_checks(void 0);
        save_cmt(outputprefix + ".cmt", modulename, /* Implementation */Block.__(1, [str]), sourcefile, initial_env, void 0);
        return /* tuple */[
                str,
                coercion,
                finalenv,
                dclsig
              ];
      } else {
        List.iter((function (param) {
                var match = param.str_desc;
                switch (match.tag | 0) {
                  case /* Tstr_value */1 :
                      return List.iter((function (param) {
                                    var exp = param.vb_expr;
                                    if (closed_schema(exp.exp_type)) {
                                      return ;
                                    }
                                    throw [
                                          $$Error$10,
                                          exp.exp_loc,
                                          finalenv,
                                          /* Non_generalizable */Block.__(7, [exp.exp_type])
                                        ];
                                  }), match[1]);
                  case /* Tstr_module */6 :
                      var md = match[0].mb_expr;
                      if (closed_modtype(md.mod_type)) {
                        return ;
                      }
                      throw [
                            $$Error$10,
                            md.mod_loc,
                            finalenv,
                            /* Non_generalizable_module */Block.__(9, [md.mod_type])
                          ];
                  default:
                    return ;
                }
              }), str.str_items);
        normalize_signature(finalenv)(simple_sg);
        var coercion$1 = compunit(initial_env, sourcefile, sg, "(inferred signature)", simple_sg);
        force_delayed_checks(void 0);
        if (!dont_write_files.contents) {
          var sg$1 = save_signature(simple_sg, modulename, outputprefix + ".cmi");
          save_cmt(outputprefix + ".cmt", modulename, /* Implementation */Block.__(1, [str]), sourcefile, initial_env, sg$1);
        }
        return /* tuple */[
                str,
                coercion$1,
                finalenv,
                simple_sg
              ];
      }
    }
  }
  catch (e){
    save_cmt(outputprefix + ".cmt", modulename, /* Partial_implementation */Block.__(3, [$$Array.of_list(saved_types.contents)]), sourcefile, initial_env, void 0);
    throw e;
  }
}

function type_implementation(sourcefile, outputprefix, modulename, initial_env, ast) {
  var match = type_implementation_more(sourcefile, outputprefix, modulename, initial_env, ast);
  return /* tuple */[
          match[0],
          match[1]
        ];
}

register_error_of_exn((function (param) {
        if (param[0] !== $$Error$10) {
          if (param[0] === Error_forward$3) {
            return param[1];
          } else {
            return ;
          }
        }
        var env = param[2];
        return error_of_printer(param[1], (function (param, param$1) {
                      return wrap_printing_env(env, (function (param$2) {
                                    if (typeof param$1 === "number") {
                                      switch (param$1) {
                                        case /* Signature_expected */0 :
                                            return Format.fprintf(param, /* Format */[
                                                        /* String_literal */Block.__(11, [
                                                            "This module type is not a signature",
                                                            /* End_of_format */0
                                                          ]),
                                                        "This module type is not a signature"
                                                      ]);
                                        case /* Not_allowed_in_functor_body */1 :
                                            return Curry._1(Format.fprintf(param, /* Format */[
                                                            /* Formatting_gen */Block.__(18, [
                                                                /* Open_box */Block.__(1, [/* Format */[
                                                                      /* End_of_format */0,
                                                                      ""
                                                                    ]]),
                                                                /* String_literal */Block.__(11, [
                                                                    "This expression creates fresh types.",
                                                                    /* Formatting_lit */Block.__(17, [
                                                                        /* Break */Block.__(0, [
                                                                            "@ ",
                                                                            1,
                                                                            0
                                                                          ]),
                                                                        /* String */Block.__(2, [
                                                                            /* No_padding */0,
                                                                            /* Formatting_lit */Block.__(17, [
                                                                                /* Close_box */0,
                                                                                /* End_of_format */0
                                                                              ])
                                                                          ])
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "@[This expression creates fresh types.@ %s@]"
                                                          ]), "It is not allowed inside applicative functors.");
                                        case /* With_need_typeconstr */2 :
                                            return Format.fprintf(param, /* Format */[
                                                        /* String_literal */Block.__(11, [
                                                            "Only type constructors with identical parameters can be substituted.",
                                                            /* End_of_format */0
                                                          ]),
                                                        "Only type constructors with identical parameters can be substituted."
                                                      ]);
                                        case /* Recursive_module_require_explicit_type */3 :
                                            return Format.fprintf(param, /* Format */[
                                                        /* String_literal */Block.__(11, [
                                                            "Recursive modules require an explicit module type.",
                                                            /* End_of_format */0
                                                          ]),
                                                        "Recursive modules require an explicit module type."
                                                      ]);
                                        case /* Apply_generative */4 :
                                            return Format.fprintf(param, /* Format */[
                                                        /* String_literal */Block.__(11, [
                                                            "This is a generative functor. It can only be applied to ()",
                                                            /* End_of_format */0
                                                          ]),
                                                        "This is a generative functor. It can only be applied to ()"
                                                      ]);
                                        
                                      }
                                    } else {
                                      switch (param$1.tag | 0) {
                                        case /* Cannot_apply */0 :
                                            return Curry._2(Format.fprintf(param, /* Format */[
                                                            /* Formatting_gen */Block.__(18, [
                                                                /* Open_box */Block.__(1, [/* Format */[
                                                                      /* End_of_format */0,
                                                                      ""
                                                                    ]]),
                                                                /* String_literal */Block.__(11, [
                                                                    "This module is not a functor; it has type",
                                                                    /* Formatting_lit */Block.__(17, [
                                                                        /* Break */Block.__(0, [
                                                                            "@ ",
                                                                            1,
                                                                            0
                                                                          ]),
                                                                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                /* Close_box */0,
                                                                                /* End_of_format */0
                                                                              ])])
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "@[This module is not a functor; it has type@ %a@]"
                                                          ]), modtype$1, param$1[0]);
                                        case /* Not_included */1 :
                                            return Curry._2(Format.fprintf(param, /* Format */[
                                                            /* Formatting_gen */Block.__(18, [
                                                                /* Open_box */Block.__(1, [/* Format */[
                                                                      /* String_literal */Block.__(11, [
                                                                          "<v>",
                                                                          /* End_of_format */0
                                                                        ]),
                                                                      "<v>"
                                                                    ]]),
                                                                /* String_literal */Block.__(11, [
                                                                    "Signature mismatch:",
                                                                    /* Formatting_lit */Block.__(17, [
                                                                        /* Break */Block.__(0, [
                                                                            "@ ",
                                                                            1,
                                                                            0
                                                                          ]),
                                                                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                /* Close_box */0,
                                                                                /* End_of_format */0
                                                                              ])])
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "@[<v>Signature mismatch:@ %a@]"
                                                          ]), report_error$4, param$1[0]);
                                        case /* Cannot_eliminate_dependency */2 :
                                            return Curry._2(Format.fprintf(param, /* Format */[
                                                            /* Formatting_gen */Block.__(18, [
                                                                /* Open_box */Block.__(1, [/* Format */[
                                                                      /* End_of_format */0,
                                                                      ""
                                                                    ]]),
                                                                /* String_literal */Block.__(11, [
                                                                    "This functor has type",
                                                                    /* Formatting_lit */Block.__(17, [
                                                                        /* Break */Block.__(0, [
                                                                            "@ ",
                                                                            1,
                                                                            0
                                                                          ]),
                                                                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                /* Break */Block.__(0, [
                                                                                    "@ ",
                                                                                    1,
                                                                                    0
                                                                                  ]),
                                                                                /* String_literal */Block.__(11, [
                                                                                    "The parameter cannot be eliminated in the result type.",
                                                                                    /* Formatting_lit */Block.__(17, [
                                                                                        /* Break */Block.__(0, [
                                                                                            "@ ",
                                                                                            1,
                                                                                            0
                                                                                          ]),
                                                                                        /* String_literal */Block.__(11, [
                                                                                            " Please bind the argument to a module identifier.",
                                                                                            /* Formatting_lit */Block.__(17, [
                                                                                                /* Close_box */0,
                                                                                                /* End_of_format */0
                                                                                              ])
                                                                                          ])
                                                                                      ])
                                                                                  ])
                                                                              ])])
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "@[This functor has type@ %a@ The parameter cannot be eliminated in the result type.@  Please bind the argument to a module identifier.@]"
                                                          ]), modtype$1, param$1[0]);
                                        case /* Structure_expected */3 :
                                            return Curry._2(Format.fprintf(param, /* Format */[
                                                            /* Formatting_gen */Block.__(18, [
                                                                /* Open_box */Block.__(1, [/* Format */[
                                                                      /* End_of_format */0,
                                                                      ""
                                                                    ]]),
                                                                /* String_literal */Block.__(11, [
                                                                    "This module is not a structure; it has type",
                                                                    /* Formatting_lit */Block.__(17, [
                                                                        /* Break */Block.__(0, [
                                                                            "@ ",
                                                                            1,
                                                                            0
                                                                          ]),
                                                                        /* Alpha */Block.__(15, [/* End_of_format */0])
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "@[This module is not a structure; it has type@ %a"
                                                          ]), modtype$1, param$1[0]);
                                        case /* With_no_component */4 :
                                            return Curry._2(Format.fprintf(param, /* Format */[
                                                            /* Formatting_gen */Block.__(18, [
                                                                /* Open_box */Block.__(1, [/* Format */[
                                                                      /* End_of_format */0,
                                                                      ""
                                                                    ]]),
                                                                /* String_literal */Block.__(11, [
                                                                    "The signature constrained by `with' has no component named ",
                                                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                            /* Close_box */0,
                                                                            /* End_of_format */0
                                                                          ])])
                                                                  ])
                                                              ]),
                                                            "@[The signature constrained by `with' has no component named %a@]"
                                                          ]), longident, param$1[0]);
                                        case /* With_mismatch */5 :
                                            return Curry._4(Format.fprintf(param, /* Format */[
                                                            /* Formatting_gen */Block.__(18, [
                                                                /* Open_box */Block.__(1, [/* Format */[
                                                                      /* String_literal */Block.__(11, [
                                                                          "<v>",
                                                                          /* End_of_format */0
                                                                        ]),
                                                                      "<v>"
                                                                    ]]),
                                                                /* Formatting_gen */Block.__(18, [
                                                                    /* Open_box */Block.__(1, [/* Format */[
                                                                          /* End_of_format */0,
                                                                          ""
                                                                        ]]),
                                                                    /* String_literal */Block.__(11, [
                                                                        "In this `with' constraint, the new definition of ",
                                                                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                /* Break */Block.__(0, [
                                                                                    "@ ",
                                                                                    1,
                                                                                    0
                                                                                  ]),
                                                                                /* String_literal */Block.__(11, [
                                                                                    "does not match its original definition",
                                                                                    /* Formatting_lit */Block.__(17, [
                                                                                        /* Break */Block.__(0, [
                                                                                            "@ ",
                                                                                            1,
                                                                                            0
                                                                                          ]),
                                                                                        /* String_literal */Block.__(11, [
                                                                                            "in the constrained signature:",
                                                                                            /* Formatting_lit */Block.__(17, [
                                                                                                /* Close_box */0,
                                                                                                /* Formatting_lit */Block.__(17, [
                                                                                                    /* Break */Block.__(0, [
                                                                                                        "@ ",
                                                                                                        1,
                                                                                                        0
                                                                                                      ]),
                                                                                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                                                            /* Close_box */0,
                                                                                                            /* End_of_format */0
                                                                                                          ])])
                                                                                                  ])
                                                                                              ])
                                                                                          ])
                                                                                      ])
                                                                                  ])
                                                                              ])])
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "@[<v>@[In this `with' constraint, the new definition of %a@ does not match its original definition@ in the constrained signature:@]@ %a@]"
                                                          ]), longident, param$1[0], report_error$4, param$1[1]);
                                        case /* Repeated_name */6 :
                                            return Curry._2(Format.fprintf(param, /* Format */[
                                                            /* Formatting_gen */Block.__(18, [
                                                                /* Open_box */Block.__(1, [/* Format */[
                                                                      /* End_of_format */0,
                                                                      ""
                                                                    ]]),
                                                                /* String_literal */Block.__(11, [
                                                                    "Multiple definition of the ",
                                                                    /* String */Block.__(2, [
                                                                        /* No_padding */0,
                                                                        /* String_literal */Block.__(11, [
                                                                            " name ",
                                                                            /* String */Block.__(2, [
                                                                                /* No_padding */0,
                                                                                /* Char_literal */Block.__(12, [
                                                                                    /* "." */46,
                                                                                    /* Formatting_lit */Block.__(17, [
                                                                                        /* Break */Block.__(0, [
                                                                                            "@ ",
                                                                                            1,
                                                                                            0
                                                                                          ]),
                                                                                        /* String_literal */Block.__(11, [
                                                                                            "Names must be unique in a given structure or signature.",
                                                                                            /* Formatting_lit */Block.__(17, [
                                                                                                /* Close_box */0,
                                                                                                /* End_of_format */0
                                                                                              ])
                                                                                          ])
                                                                                      ])
                                                                                  ])
                                                                              ])
                                                                          ])
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "@[Multiple definition of the %s name %s.@ Names must be unique in a given structure or signature.@]"
                                                          ]), param$1[0], param$1[1]);
                                        case /* Non_generalizable */7 :
                                            return Curry._2(Format.fprintf(param, /* Format */[
                                                            /* Formatting_gen */Block.__(18, [
                                                                /* Open_box */Block.__(1, [/* Format */[
                                                                      /* End_of_format */0,
                                                                      ""
                                                                    ]]),
                                                                /* String_literal */Block.__(11, [
                                                                    "The type of this expression,",
                                                                    /* Formatting_lit */Block.__(17, [
                                                                        /* Break */Block.__(0, [
                                                                            "@ ",
                                                                            1,
                                                                            0
                                                                          ]),
                                                                        /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                                                /* "," */44,
                                                                                /* Formatting_lit */Block.__(17, [
                                                                                    /* Break */Block.__(0, [
                                                                                        "@ ",
                                                                                        1,
                                                                                        0
                                                                                      ]),
                                                                                    /* String_literal */Block.__(11, [
                                                                                        "contains type variables that cannot be generalized",
                                                                                        /* Formatting_lit */Block.__(17, [
                                                                                            /* Close_box */0,
                                                                                            /* End_of_format */0
                                                                                          ])
                                                                                      ])
                                                                                  ])
                                                                              ])])
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "@[The type of this expression,@ %a,@ contains type variables that cannot be generalized@]"
                                                          ]), type_scheme, param$1[0]);
                                        case /* Non_generalizable_class */8 :
                                            var id = param$1[0];
                                            return Curry._2(Format.fprintf(param, /* Format */[
                                                            /* Formatting_gen */Block.__(18, [
                                                                /* Open_box */Block.__(1, [/* Format */[
                                                                      /* End_of_format */0,
                                                                      ""
                                                                    ]]),
                                                                /* String_literal */Block.__(11, [
                                                                    "The type of this class,",
                                                                    /* Formatting_lit */Block.__(17, [
                                                                        /* Break */Block.__(0, [
                                                                            "@ ",
                                                                            1,
                                                                            0
                                                                          ]),
                                                                        /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                                                /* "," */44,
                                                                                /* Formatting_lit */Block.__(17, [
                                                                                    /* Break */Block.__(0, [
                                                                                        "@ ",
                                                                                        1,
                                                                                        0
                                                                                      ]),
                                                                                    /* String_literal */Block.__(11, [
                                                                                        "contains type variables that cannot be generalized",
                                                                                        /* Formatting_lit */Block.__(17, [
                                                                                            /* Close_box */0,
                                                                                            /* End_of_format */0
                                                                                          ])
                                                                                      ])
                                                                                  ])
                                                                              ])])
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "@[The type of this class,@ %a,@ contains type variables that cannot be generalized@]"
                                                          ]), (function (param, param$1) {
                                                          return class_declaration$1(id, param, param$1);
                                                        }), param$1[1]);
                                        case /* Non_generalizable_module */9 :
                                            return Curry._2(Format.fprintf(param, /* Format */[
                                                            /* Formatting_gen */Block.__(18, [
                                                                /* Open_box */Block.__(1, [/* Format */[
                                                                      /* End_of_format */0,
                                                                      ""
                                                                    ]]),
                                                                /* String_literal */Block.__(11, [
                                                                    "The type of this module,",
                                                                    /* Formatting_lit */Block.__(17, [
                                                                        /* Break */Block.__(0, [
                                                                            "@ ",
                                                                            1,
                                                                            0
                                                                          ]),
                                                                        /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                                                /* "," */44,
                                                                                /* Formatting_lit */Block.__(17, [
                                                                                    /* Break */Block.__(0, [
                                                                                        "@ ",
                                                                                        1,
                                                                                        0
                                                                                      ]),
                                                                                    /* String_literal */Block.__(11, [
                                                                                        "contains type variables that cannot be generalized",
                                                                                        /* Formatting_lit */Block.__(17, [
                                                                                            /* Close_box */0,
                                                                                            /* End_of_format */0
                                                                                          ])
                                                                                      ])
                                                                                  ])
                                                                              ])])
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "@[The type of this module,@ %a,@ contains type variables that cannot be generalized@]"
                                                          ]), modtype$1, param$1[0]);
                                        case /* Implementation_is_required */10 :
                                            return Curry._2(Format.fprintf(param, /* Format */[
                                                            /* Formatting_gen */Block.__(18, [
                                                                /* Open_box */Block.__(1, [/* Format */[
                                                                      /* End_of_format */0,
                                                                      ""
                                                                    ]]),
                                                                /* String_literal */Block.__(11, [
                                                                    "The interface ",
                                                                    /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                                            /* Break */Block.__(0, [
                                                                                "@ ",
                                                                                1,
                                                                                0
                                                                              ]),
                                                                            /* String_literal */Block.__(11, [
                                                                                "declares values, not just types.",
                                                                                /* Formatting_lit */Block.__(17, [
                                                                                    /* Break */Block.__(0, [
                                                                                        "@ ",
                                                                                        1,
                                                                                        0
                                                                                      ]),
                                                                                    /* String_literal */Block.__(11, [
                                                                                        "An implementation must be provided.",
                                                                                        /* Formatting_lit */Block.__(17, [
                                                                                            /* Close_box */0,
                                                                                            /* End_of_format */0
                                                                                          ])
                                                                                      ])
                                                                                  ])
                                                                              ])
                                                                          ])])
                                                                  ])
                                                              ]),
                                                            "@[The interface %a@ declares values, not just types.@ An implementation must be provided.@]"
                                                          ]), print_filename, param$1[0]);
                                        case /* Interface_not_compiled */11 :
                                            return Curry._2(Format.fprintf(param, /* Format */[
                                                            /* Formatting_gen */Block.__(18, [
                                                                /* Open_box */Block.__(1, [/* Format */[
                                                                      /* End_of_format */0,
                                                                      ""
                                                                    ]]),
                                                                /* String_literal */Block.__(11, [
                                                                    "Could not find the .cmi file for interface",
                                                                    /* Formatting_lit */Block.__(17, [
                                                                        /* Break */Block.__(0, [
                                                                            "@ ",
                                                                            1,
                                                                            0
                                                                          ]),
                                                                        /* Alpha */Block.__(15, [/* Char_literal */Block.__(12, [
                                                                                /* "." */46,
                                                                                /* Formatting_lit */Block.__(17, [
                                                                                    /* Close_box */0,
                                                                                    /* End_of_format */0
                                                                                  ])
                                                                              ])])
                                                                      ])
                                                                  ])
                                                              ]),
                                                            "@[Could not find the .cmi file for interface@ %a.@]"
                                                          ]), print_filename, param$1[0]);
                                        case /* Not_a_packed_module */12 :
                                            return Curry._2(Format.fprintf(param, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "This expression is not a packed module. It has type",
                                                                /* Formatting_lit */Block.__(17, [
                                                                    /* Break */Block.__(0, [
                                                                        "@ ",
                                                                        1,
                                                                        0
                                                                      ]),
                                                                    /* Alpha */Block.__(15, [/* End_of_format */0])
                                                                  ])
                                                              ]),
                                                            "This expression is not a packed module. It has type@ %a"
                                                          ]), type_expr$1, param$1[0]);
                                        case /* Incomplete_packed_module */13 :
                                            return Curry._2(Format.fprintf(param, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "The type of this packed module contains variables:",
                                                                /* Formatting_lit */Block.__(17, [
                                                                    /* Break */Block.__(0, [
                                                                        "@ ",
                                                                        1,
                                                                        0
                                                                      ]),
                                                                    /* Alpha */Block.__(15, [/* End_of_format */0])
                                                                  ])
                                                              ]),
                                                            "The type of this packed module contains variables:@ %a"
                                                          ]), type_expr$1, param$1[0]);
                                        case /* Scoping_pack */14 :
                                            Curry._2(Format.fprintf(param, /* Format */[
                                                      /* String_literal */Block.__(11, [
                                                          "The type ",
                                                          /* Alpha */Block.__(15, [/* String_literal */Block.__(11, [
                                                                  " in this module cannot be exported.",
                                                                  /* Formatting_lit */Block.__(17, [
                                                                      /* Break */Block.__(0, [
                                                                          "@ ",
                                                                          1,
                                                                          0
                                                                        ]),
                                                                      /* End_of_format */0
                                                                    ])
                                                                ])])
                                                        ]),
                                                      "The type %a in this module cannot be exported.@ "
                                                    ]), longident, param$1[0]);
                                            return Curry._2(Format.fprintf(param, /* Format */[
                                                            /* String_literal */Block.__(11, [
                                                                "Its type contains local dependencies:",
                                                                /* Formatting_lit */Block.__(17, [
                                                                    /* Break */Block.__(0, [
                                                                        "@ ",
                                                                        1,
                                                                        0
                                                                      ]),
                                                                    /* Alpha */Block.__(15, [/* End_of_format */0])
                                                                  ])
                                                              ]),
                                                            "Its type contains local dependencies:@ %a"
                                                          ]), type_expr$1, param$1[1]);
                                        
                                      }
                                    }
                                  }));
                    }), param[3]);
      }));

var suites = {
  contents: /* [] */0
};

var test_id = {
  contents: 0
};

function eq(loc, x, y) {
  test_id.contents = test_id.contents + 1 | 0;
  suites.contents = /* :: */[
    /* tuple */[
      loc + (" id " + String(test_id.contents)),
      (function (param) {
          return /* Eq */Block.__(0, [
                    x,
                    y
                  ]);
        })
    ],
    suites.contents
  ];
  
}

dont_write_files.contents = true;

unsafe_string = false;

debug = true;

record_event_when_debug = false;

binary_annotations.contents = false;

nopervasives = true;

assume_no_mli.contents = /* Mli_non_exists */2;

var modulename = "Test";

var x = type_implementation(modulename, modulename, modulename, empty, wrap$1(implementation, Lexing.from_string("\ntype int\nexternal ( ~- ) : int -> int = \"%negint\"\nexternal ( ~+ ) : int -> int = \"%identity\"\nexternal succ : int -> int = \"%succint\"\nexternal pred : int -> int = \"%predint\"\nexternal ( + ) : int -> int -> int = \"%addint\"\nexternal ( - ) : int -> int -> int = \"%subint\"\nexternal ( * ) : int -> int -> int = \"%mulint\"\nexternal ( / ) : int -> int -> int = \"%divint\"\nexternal ( mod ) : int -> int -> int = \"%modint\"\n let f x y = x + y")));

var match$1 = x[0].str_items;

if (match$1) {
  var match$2 = match$1[0];
  var match$3 = match$2.str_desc;
  if (match$3.tag === /* Tstr_type */3) {
    var match$4 = match$3[0];
    if (match$4) {
      var match$5 = match$4[0];
      var match$6 = match$5.typ_id;
      if (match$6.name === "int") {
        var match$7 = match$6.flags;
        if (match$7 !== 0) {
          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
        } else {
          var match$8 = match$5.typ_name;
          if (match$8.txt === "int") {
            var match$9 = match$8.loc;
            var match$10 = match$9.loc_start;
            if (match$10.pos_fname === "" && !(match$10.pos_lnum !== 2 || match$10.pos_bol !== 1 || match$10.pos_cnum !== 6)) {
              var match$11 = match$9.loc_end;
              if (match$11.pos_fname === "" && !(match$11.pos_lnum !== 2 || match$11.pos_bol !== 1 || match$11.pos_cnum !== 9 || match$9.loc_ghost || match$5.typ_params)) {
                var match$12 = match$5.typ_type;
                if (match$12.type_params || match$12.type_arity !== 0) {
                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                } else {
                  var match$13 = match$12.type_kind;
                  if (typeof match$13 === "number" && !(match$13 !== 0 || !(match$12.type_private && !(match$12.type_manifest !== void 0 || match$12.type_variance || match$12.type_newtype_level !== void 0)))) {
                    var match$14 = match$12.type_loc;
                    var match$15 = match$14.loc_start;
                    if (match$15.pos_fname === "" && !(match$15.pos_lnum !== 2 || match$15.pos_bol !== 1 || match$15.pos_cnum !== 1)) {
                      var match$16 = match$14.loc_end;
                      if (match$16.pos_fname === "" && !(match$16.pos_lnum !== 2 || match$16.pos_bol !== 1 || match$16.pos_cnum !== 9 || match$14.loc_ghost || match$12.type_attributes || match$5.typ_cstrs)) {
                        var match$17 = match$5.typ_kind;
                        if (typeof match$17 === "number" && !(match$17 !== 0 || !(match$5.typ_private && match$5.typ_manifest === void 0))) {
                          var match$18 = match$5.typ_loc;
                          var match$19 = match$18.loc_start;
                          if (match$19.pos_fname === "" && !(match$19.pos_lnum !== 2 || match$19.pos_bol !== 1 || match$19.pos_cnum !== 1)) {
                            var match$20 = match$18.loc_end;
                            if (match$20.pos_fname === "" && !(match$20.pos_lnum !== 2 || match$20.pos_bol !== 1 || match$20.pos_cnum !== 9 || match$18.loc_ghost || match$5.typ_attributes || match$4[1])) {
                              var match$21 = match$2.str_loc;
                              var match$22 = match$21.loc_start;
                              if (match$22.pos_fname === "" && !(match$22.pos_lnum !== 2 || match$22.pos_bol !== 1 || match$22.pos_cnum !== 1)) {
                                var match$23 = match$21.loc_end;
                                if (match$23.pos_fname === "" && !(match$23.pos_lnum !== 2 || match$23.pos_bol !== 1 || match$23.pos_cnum !== 9 || match$21.loc_ghost)) {
                                  var match$24 = match$1[1];
                                  if (match$24) {
                                    var match$25 = match$24[0].str_desc;
                                    if (match$25.tag === /* Tstr_primitive */2) {
                                      var match$26 = match$25[0];
                                      var match$27 = match$26.val_id;
                                      if (match$27.name === "~-") {
                                        var match$28 = match$27.flags;
                                        if (match$28 !== 0) {
                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                        } else {
                                          var match$29 = match$26.val_name;
                                          if (match$29.txt === "~-") {
                                            var match$30 = match$29.loc;
                                            var match$31 = match$30.loc_start;
                                            if (match$31.pos_fname === "" && !(match$31.pos_lnum !== 3 || match$31.pos_bol !== 10 || match$31.pos_cnum !== 19)) {
                                              var match$32 = match$30.loc_end;
                                              if (match$32.pos_fname === "" && !(match$32.pos_lnum !== 3 || match$32.pos_bol !== 10 || match$32.pos_cnum !== 25 || match$30.loc_ghost)) {
                                                var match$33 = match$26.val_desc;
                                                var match$34 = match$33.ctyp_desc;
                                                if (typeof match$34 === "number" || !(match$34.tag === /* Ttyp_arrow */1 && match$34[0] === "")) {
                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                } else {
                                                  var match$35 = match$34[1];
                                                  var match$36 = match$35.ctyp_desc;
                                                  if (typeof match$36 === "number" || match$36.tag !== /* Ttyp_constr */3) {
                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                  } else {
                                                    var match$37 = match$36[0];
                                                    switch (match$37.tag | 0) {
                                                      case /* Pident */0 :
                                                          var match$38 = match$37[0];
                                                          if (match$38.name === "int") {
                                                            var match$39 = match$38.flags;
                                                            if (match$39 !== 0) {
                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                            } else {
                                                              var match$40 = match$36[1];
                                                              var match$41 = match$40.txt;
                                                              switch (match$41.tag | 0) {
                                                                case /* Lident */0 :
                                                                    if (match$41[0] === "int") {
                                                                      var match$42 = match$40.loc;
                                                                      var match$43 = match$42.loc_start;
                                                                      if (match$43.pos_fname === "" && !(match$43.pos_lnum !== 3 || match$43.pos_bol !== 10 || match$43.pos_cnum !== 28)) {
                                                                        var match$44 = match$42.loc_end;
                                                                        if (match$44.pos_fname === "" && !(match$44.pos_lnum !== 3 || match$44.pos_bol !== 10 || match$44.pos_cnum !== 31 || match$42.loc_ghost || match$36[2])) {
                                                                          var match$45 = match$35.ctyp_type;
                                                                          var match$46 = match$45.desc;
                                                                          if (typeof match$46 === "number" || match$46.tag !== /* Tconstr */3) {
                                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                          } else {
                                                                            var match$47 = match$46[0];
                                                                            switch (match$47.tag | 0) {
                                                                              case /* Pident */0 :
                                                                                  var match$48 = match$47[0];
                                                                                  if (match$48.name === "int") {
                                                                                    var match$49 = match$48.flags;
                                                                                    if (match$49 !== 0 || match$46[1]) {
                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                    } else {
                                                                                      var match$50 = match$46[2].contents;
                                                                                      if (typeof match$50 === "number") {
                                                                                        var match$51 = match$35.ctyp_loc;
                                                                                        var match$52 = match$51.loc_start;
                                                                                        if (match$52.pos_fname === "" && !(match$52.pos_lnum !== 3 || match$52.pos_bol !== 10 || match$52.pos_cnum !== 28)) {
                                                                                          var match$53 = match$51.loc_end;
                                                                                          if (match$53.pos_fname === "" && !(match$53.pos_lnum !== 3 || match$53.pos_bol !== 10 || match$53.pos_cnum !== 31 || match$51.loc_ghost || match$35.ctyp_attributes)) {
                                                                                            var match$54 = match$34[2];
                                                                                            var match$55 = match$54.ctyp_desc;
                                                                                            if (typeof match$55 === "number" || match$55.tag !== /* Ttyp_constr */3) {
                                                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                            } else {
                                                                                              var match$56 = match$55[0];
                                                                                              switch (match$56.tag | 0) {
                                                                                                case /* Pident */0 :
                                                                                                    var match$57 = match$56[0];
                                                                                                    if (match$57.name === "int") {
                                                                                                      var match$58 = match$57.flags;
                                                                                                      if (match$58 !== 0) {
                                                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                      } else {
                                                                                                        var match$59 = match$55[1];
                                                                                                        var match$60 = match$59.txt;
                                                                                                        switch (match$60.tag | 0) {
                                                                                                          case /* Lident */0 :
                                                                                                              if (match$60[0] === "int") {
                                                                                                                var match$61 = match$59.loc;
                                                                                                                var match$62 = match$61.loc_start;
                                                                                                                if (match$62.pos_fname === "" && !(match$62.pos_lnum !== 3 || match$62.pos_bol !== 10 || match$62.pos_cnum !== 35)) {
                                                                                                                  var match$63 = match$61.loc_end;
                                                                                                                  if (match$63.pos_fname === "" && !(match$63.pos_lnum !== 3 || match$63.pos_bol !== 10 || match$63.pos_cnum !== 38 || match$61.loc_ghost || match$55[2])) {
                                                                                                                    var match$64 = match$54.ctyp_type;
                                                                                                                    var match$65 = match$64.desc;
                                                                                                                    if (typeof match$65 === "number" || match$65.tag !== /* Tconstr */3) {
                                                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                    } else {
                                                                                                                      var match$66 = match$65[0];
                                                                                                                      switch (match$66.tag | 0) {
                                                                                                                        case /* Pident */0 :
                                                                                                                            var match$67 = match$66[0];
                                                                                                                            if (match$67.name === "int") {
                                                                                                                              var match$68 = match$67.flags;
                                                                                                                              if (match$68 !== 0 || match$65[1]) {
                                                                                                                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                              } else {
                                                                                                                                var match$69 = match$65[2].contents;
                                                                                                                                if (typeof match$69 === "number") {
                                                                                                                                  var match$70 = match$54.ctyp_loc;
                                                                                                                                  var match$71 = match$70.loc_start;
                                                                                                                                  if (match$71.pos_fname === "" && !(match$71.pos_lnum !== 3 || match$71.pos_bol !== 10 || match$71.pos_cnum !== 35)) {
                                                                                                                                    var match$72 = match$70.loc_end;
                                                                                                                                    if (match$72.pos_fname === "" && !(match$72.pos_lnum !== 3 || match$72.pos_bol !== 10 || match$72.pos_cnum !== 38 || match$70.loc_ghost || match$54.ctyp_attributes)) {
                                                                                                                                      var match$73 = match$33.ctyp_type;
                                                                                                                                      var match$74 = match$73.desc;
                                                                                                                                      if (typeof match$74 === "number" || !(match$74.tag === /* Tarrow */1 && match$74[0] === "")) {
                                                                                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                      } else {
                                                                                                                                        var match$75 = match$74[1].desc;
                                                                                                                                        if (typeof match$75 === "number" || match$75.tag !== /* Tconstr */3) {
                                                                                                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                        } else {
                                                                                                                                          var match$76 = match$75[0];
                                                                                                                                          switch (match$76.tag | 0) {
                                                                                                                                            case /* Pident */0 :
                                                                                                                                                var match$77 = match$76[0];
                                                                                                                                                if (match$77.name === "int") {
                                                                                                                                                  var match$78 = match$77.flags;
                                                                                                                                                  if (match$78 !== 0 || match$75[1]) {
                                                                                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                  } else {
                                                                                                                                                    var match$79 = match$75[2].contents;
                                                                                                                                                    if (typeof match$79 === "number") {
                                                                                                                                                      var match$80 = match$74[2].desc;
                                                                                                                                                      if (typeof match$80 === "number" || match$80.tag !== /* Tconstr */3) {
                                                                                                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                      } else {
                                                                                                                                                        var match$81 = match$80[0];
                                                                                                                                                        switch (match$81.tag | 0) {
                                                                                                                                                          case /* Pident */0 :
                                                                                                                                                              var match$82 = match$81[0];
                                                                                                                                                              if (match$82.name === "int") {
                                                                                                                                                                var match$83 = match$82.flags;
                                                                                                                                                                if (match$83 !== 0 || match$80[1]) {
                                                                                                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                } else {
                                                                                                                                                                  var match$84 = match$80[2].contents;
                                                                                                                                                                  if (typeof match$84 === "number") {
                                                                                                                                                                    var match$85 = match$74[3];
                                                                                                                                                                    if (typeof match$85 === "number" && match$85 === 0) {
                                                                                                                                                                      var match$86 = match$33.ctyp_loc;
                                                                                                                                                                      var match$87 = match$86.loc_start;
                                                                                                                                                                      if (match$87.pos_fname === "" && !(match$87.pos_lnum !== 3 || match$87.pos_bol !== 10 || match$87.pos_cnum !== 28)) {
                                                                                                                                                                        var match$88 = match$86.loc_end;
                                                                                                                                                                        if (match$88.pos_fname === "" && !(match$88.pos_lnum !== 3 || match$88.pos_bol !== 10 || match$88.pos_cnum !== 38 || match$86.loc_ghost || match$33.ctyp_attributes)) {
                                                                                                                                                                          var match$89 = match$26.val_val;
                                                                                                                                                                          var match$90 = match$89.val_type.desc;
                                                                                                                                                                          if (typeof match$90 === "number" || !(match$90.tag === /* Tarrow */1 && match$90[0] === "")) {
                                                                                                                                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                          } else {
                                                                                                                                                                            var match$91 = match$90[1].desc;
                                                                                                                                                                            if (typeof match$91 === "number" || match$91.tag !== /* Tconstr */3) {
                                                                                                                                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                            } else {
                                                                                                                                                                              var match$92 = match$91[0];
                                                                                                                                                                              switch (match$92.tag | 0) {
                                                                                                                                                                                case /* Pident */0 :
                                                                                                                                                                                    var match$93 = match$92[0];
                                                                                                                                                                                    if (match$93.name === "int") {
                                                                                                                                                                                      var match$94 = match$93.flags;
                                                                                                                                                                                      if (match$94 !== 0 || match$91[1]) {
                                                                                                                                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                                      } else {
                                                                                                                                                                                        var match$95 = match$91[2].contents;
                                                                                                                                                                                        if (typeof match$95 === "number") {
                                                                                                                                                                                          var match$96 = match$90[2].desc;
                                                                                                                                                                                          if (typeof match$96 === "number" || match$96.tag !== /* Tconstr */3) {
                                                                                                                                                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                                          } else {
                                                                                                                                                                                            var match$97 = match$96[0];
                                                                                                                                                                                            switch (match$97.tag | 0) {
                                                                                                                                                                                              case /* Pident */0 :
                                                                                                                                                                                                  var match$98 = match$97[0];
                                                                                                                                                                                                  if (match$98.name === "int") {
                                                                                                                                                                                                    var match$99 = match$98.flags;
                                                                                                                                                                                                    if (match$99 !== 0 || match$96[1]) {
                                                                                                                                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                                                    } else {
                                                                                                                                                                                                      var match$100 = match$96[2].contents;
                                                                                                                                                                                                      if (typeof match$100 === "number") {
                                                                                                                                                                                                        var match$101 = match$90[3];
                                                                                                                                                                                                        if (typeof match$101 === "number" && match$101 === 0) {
                                                                                                                                                                                                          var match$102 = match$89.val_kind;
                                                                                                                                                                                                          if (typeof match$102 === "number" || match$102.tag) {
                                                                                                                                                                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                                                          } else {
                                                                                                                                                                                                            var match$103 = match$102[0];
                                                                                                                                                                                                            if (match$103.prim_name === "%negint" && !(match$103.prim_arity !== 1 || !(match$103.prim_alloc && match$103.prim_native_name === "" && !match$103.prim_native_float))) {
                                                                                                                                                                                                              var match$104 = match$89.val_loc;
                                                                                                                                                                                                              var match$105 = match$104.loc_start;
                                                                                                                                                                                                              if (match$105.pos_fname === "" && !(match$105.pos_lnum !== 3 || match$105.pos_bol !== 10 || match$105.pos_cnum !== 10)) {
                                                                                                                                                                                                                var match$106 = match$104.loc_end;
                                                                                                                                                                                                                if (match$106.pos_fname === "" && !(match$106.pos_lnum !== 3 || match$106.pos_bol !== 10 || match$106.pos_cnum !== 50 || match$104.loc_ghost || match$89.val_attributes)) {
                                                                                                                                                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 220, characters 14-21", true, true);
                                                                                                                                                                                                                } else {
                                                                                                                                                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                                                                }
                                                                                                                                                                                                              } else {
                                                                                                                                                                                                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                                                              }
                                                                                                                                                                                                            } else {
                                                                                                                                                                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                                                            }
                                                                                                                                                                                                          }
                                                                                                                                                                                                        } else {
                                                                                                                                                                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                                                        }
                                                                                                                                                                                                      } else {
                                                                                                                                                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                                                      }
                                                                                                                                                                                                    }
                                                                                                                                                                                                  } else {
                                                                                                                                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                                                  }
                                                                                                                                                                                                  break;
                                                                                                                                                                                              case /* Pdot */1 :
                                                                                                                                                                                              case /* Papply */2 :
                                                                                                                                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                                                  break;
                                                                                                                                                                                              
                                                                                                                                                                                            }
                                                                                                                                                                                          }
                                                                                                                                                                                        } else {
                                                                                                                                                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                                        }
                                                                                                                                                                                      }
                                                                                                                                                                                    } else {
                                                                                                                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                                    }
                                                                                                                                                                                    break;
                                                                                                                                                                                case /* Pdot */1 :
                                                                                                                                                                                case /* Papply */2 :
                                                                                                                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                                    break;
                                                                                                                                                                                
                                                                                                                                                                              }
                                                                                                                                                                            }
                                                                                                                                                                          }
                                                                                                                                                                        } else {
                                                                                                                                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                        }
                                                                                                                                                                      } else {
                                                                                                                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                      }
                                                                                                                                                                    } else {
                                                                                                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                    }
                                                                                                                                                                  } else {
                                                                                                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                                  }
                                                                                                                                                                }
                                                                                                                                                              } else {
                                                                                                                                                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                              }
                                                                                                                                                              break;
                                                                                                                                                          case /* Pdot */1 :
                                                                                                                                                          case /* Papply */2 :
                                                                                                                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                              break;
                                                                                                                                                          
                                                                                                                                                        }
                                                                                                                                                      }
                                                                                                                                                    } else {
                                                                                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                    }
                                                                                                                                                  }
                                                                                                                                                } else {
                                                                                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                }
                                                                                                                                                break;
                                                                                                                                            case /* Pdot */1 :
                                                                                                                                            case /* Papply */2 :
                                                                                                                                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                                break;
                                                                                                                                            
                                                                                                                                          }
                                                                                                                                        }
                                                                                                                                      }
                                                                                                                                    } else {
                                                                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                    }
                                                                                                                                  } else {
                                                                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                  }
                                                                                                                                } else {
                                                                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                                }
                                                                                                                              }
                                                                                                                            } else {
                                                                                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                            }
                                                                                                                            break;
                                                                                                                        case /* Pdot */1 :
                                                                                                                        case /* Papply */2 :
                                                                                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                            break;
                                                                                                                        
                                                                                                                      }
                                                                                                                    }
                                                                                                                  } else {
                                                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                  }
                                                                                                                } else {
                                                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                                }
                                                                                                              } else {
                                                                                                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                              }
                                                                                                              break;
                                                                                                          case /* Ldot */1 :
                                                                                                          case /* Lapply */2 :
                                                                                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                              break;
                                                                                                          
                                                                                                        }
                                                                                                      }
                                                                                                    } else {
                                                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                    }
                                                                                                    break;
                                                                                                case /* Pdot */1 :
                                                                                                case /* Papply */2 :
                                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                                    break;
                                                                                                
                                                                                              }
                                                                                            }
                                                                                          } else {
                                                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                          }
                                                                                        } else {
                                                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                        }
                                                                                      } else {
                                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                      }
                                                                                    }
                                                                                  } else {
                                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                  }
                                                                                  break;
                                                                              case /* Pdot */1 :
                                                                              case /* Papply */2 :
                                                                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                                  break;
                                                                              
                                                                            }
                                                                          }
                                                                        } else {
                                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                        }
                                                                      } else {
                                                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                      }
                                                                    } else {
                                                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                    }
                                                                    break;
                                                                case /* Ldot */1 :
                                                                case /* Lapply */2 :
                                                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                                    break;
                                                                
                                                              }
                                                            }
                                                          } else {
                                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                          }
                                                          break;
                                                      case /* Pdot */1 :
                                                      case /* Papply */2 :
                                                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                                          break;
                                                      
                                                    }
                                                  }
                                                }
                                              } else {
                                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                              }
                                            } else {
                                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                            }
                                          } else {
                                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                          }
                                        }
                                      } else {
                                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                      }
                                    } else {
                                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                    }
                                  } else {
                                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                  }
                                } else {
                                  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                                }
                              } else {
                                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                              }
                            } else {
                              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                            }
                          } else {
                            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                          }
                        } else {
                          eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                        }
                      } else {
                        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                      }
                    } else {
                      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                    }
                  } else {
                    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
                  }
                }
              } else {
                eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
              }
            } else {
              eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
            }
          } else {
            eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
          }
        }
      } else {
        eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
      }
    } else {
      eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
    }
  } else {
    eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
  }
} else {
  eq("File \"ocaml_typed_tree_main.ml\", line 221, characters 12-19", true, false);
}

from_pair_suites("Ocaml_typedtree_test", suites.contents);

/*  Not a pure module */
