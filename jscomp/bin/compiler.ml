module Ext_pervasives : sig 
#1 "ext_pervasives.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Extension to standard library [Pervavives] module, safe to open 
  *)

external reraise: exn -> 'a = "%reraise"

val finally : 'a -> ('a -> 'c) -> ('a -> 'b) -> 'b

val with_file_as_chan : string -> (out_channel -> 'a) -> 'a

val with_file_as_pp : string -> (Format.formatter -> 'a) -> 'a

val is_pos_pow : Int32.t -> int

val failwithf : loc:string -> ('a, unit, string, 'b) format4 -> 'a

val invalid_argf : ('a, unit, string, 'b) format4 -> 'a

val bad_argf : ('a, unit, string, 'b) format4 -> 'a



val dump : 'a -> string 

external id : 'a -> 'a = "%identity"

(** Copied from {!Btype.hash_variant}:
    need sync up and add test case
 *)
val hash_variant : string -> int

end = struct
#1 "ext_pervasives.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






external reraise: exn -> 'a = "%reraise"

let finally v action f   = 
  match f v with
  | exception e -> 
      action v ;
      reraise e 
  | e ->  action v ; e 

let with_file_as_chan filename f = 
  finally (open_out filename) close_out f 

let with_file_as_pp filename f = 
  finally (open_out filename) close_out
    (fun chan -> 
      let fmt = Format.formatter_of_out_channel chan in
      let v = f  fmt in
      Format.pp_print_flush fmt ();
      v
    ) 


let  is_pos_pow n = 
  let module M = struct exception E end in 
  let rec aux c (n : Int32.t) = 
    if n <= 0l then -2 
    else if n = 1l then c 
    else if Int32.logand n 1l =  0l then   
      aux (c + 1) (Int32.shift_right n 1 )
    else raise M.E in 
  try aux 0 n  with M.E -> -1

let failwithf ~loc fmt = Format.ksprintf (fun s -> failwith (loc ^ s))
    fmt
    
let invalid_argf fmt = Format.ksprintf invalid_arg fmt

let bad_argf fmt = Format.ksprintf (fun x -> raise (Arg.Bad x ) ) fmt


let rec dump r =
  if Obj.is_int r then
    string_of_int (Obj.magic r : int)
  else (* Block. *)
    let rec get_fields acc = function
      | 0 -> acc
      | n -> let n = n-1 in get_fields (Obj.field r n :: acc) n
    in
    let rec is_list r =
      if Obj.is_int r then
        r = Obj.repr 0 (* [] *)
      else
        let s = Obj.size r and t = Obj.tag r in
        t = 0 && s = 2 && is_list (Obj.field r 1) (* h :: t *)
    in
    let rec get_list r =
      if Obj.is_int r then
        []
      else
        let h = Obj.field r 0 and t = get_list (Obj.field r 1) in
        h :: t
    in
    let opaque name =
      (* XXX In future, print the address of value 'r'.  Not possible
       * in pure OCaml at the moment.  *)
      "<" ^ name ^ ">"
    in
    let s = Obj.size r and t = Obj.tag r in
    (* From the tag, determine the type of block. *)
    match t with
    | _ when is_list r ->
      let fields = get_list r in
      "[" ^ String.concat "; " (List.map dump fields) ^ "]"
    | 0 ->
      let fields = get_fields [] s in
      "(" ^ String.concat ", " (List.map dump fields) ^ ")"
    | x when x = Obj.lazy_tag ->
      (* Note that [lazy_tag .. forward_tag] are < no_scan_tag.  Not
         * clear if very large constructed values could have the same
         * tag. XXX *)
      opaque "lazy"
    | x when x = Obj.closure_tag ->
      opaque "closure"
    | x when x = Obj.object_tag ->
      let fields = get_fields [] s in
      let _clasz, id, slots =
        match fields with
        | h::h'::t -> h, h', t
        | _ -> assert false
      in
      (* No information on decoding the class (first field).  So just print
         * out the ID and the slots. *)
      "Object #" ^ dump id ^ " (" ^ String.concat ", " (List.map dump slots) ^ ")"
    | x when x = Obj.infix_tag ->
      opaque "infix"
    | x when x = Obj.forward_tag ->
      opaque "forward"
    | x when x < Obj.no_scan_tag ->
      let fields = get_fields [] s in
      "Tag" ^ string_of_int t ^
      " (" ^ String.concat ", " (List.map dump fields) ^ ")"
    | x when x = Obj.string_tag ->
      "\"" ^ String.escaped (Obj.magic r : string) ^ "\""
    | x when x = Obj.double_tag ->
      string_of_float (Obj.magic r : float)
    | x when x = Obj.abstract_tag ->
      opaque "abstract"
    | x when x = Obj.custom_tag ->
      opaque "custom"
    | x when x = Obj.custom_tag ->
      opaque "final"
    | x when x = Obj.double_array_tag ->
      "[|"^
      String.concat ";"
        (Array.to_list (Array.map string_of_float (Obj.magic r : float array))) ^
      "|]"
    | _ ->
      opaque (Printf.sprintf "unknown: tag %d size %d" t s)

let dump v = dump (Obj.repr v)

external id : 'a -> 'a = "%identity"


let hash_variant s =
  let accu = ref 0 in
  for i = 0 to String.length s - 1 do
    accu := 223 * !accu + Char.code s.[i]
  done;
  (* reduce to 31 bits *)
  accu := !accu land (1 lsl 31 - 1);
  (* make it signed for 64 bits architectures *)
  if !accu > 0x3FFFFFFF then !accu - (1 lsl 31) else !accu


end
module Ext_bytes : sig 
#1 "ext_bytes.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)







(** Port the {!Bytes.escaped} from trunk to make it not locale sensitive *)

val escaped : bytes -> bytes

end = struct
#1 "ext_bytes.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








external char_code: char -> int = "%identity"
external char_chr: int -> char = "%identity"

let escaped s =
  let n = ref 0 in
  for i = 0 to Bytes.length s - 1 do
    n := !n +
      (match Bytes.unsafe_get s i with
       | '"' | '\\' | '\n' | '\t' | '\r' | '\b' -> 2
       | ' ' .. '~' -> 1
       | _ -> 4)
  done;
  if !n = Bytes.length s then Bytes.copy s else begin
    let s' = Bytes.create !n in
    n := 0;
    for i = 0 to Bytes.length s - 1 do
      begin match Bytes.unsafe_get s i with
      | ('"' | '\\') as c ->
          Bytes.unsafe_set s' !n '\\'; incr n; Bytes.unsafe_set s' !n c
      | '\n' ->
          Bytes.unsafe_set s' !n '\\'; incr n; Bytes.unsafe_set s' !n 'n'
      | '\t' ->
          Bytes.unsafe_set s' !n '\\'; incr n; Bytes.unsafe_set s' !n 't'
      | '\r' ->
          Bytes.unsafe_set s' !n '\\'; incr n; Bytes.unsafe_set s' !n 'r'
      | '\b' ->
          Bytes.unsafe_set s' !n '\\'; incr n; Bytes.unsafe_set s' !n 'b'
      | (' ' .. '~') as c -> Bytes.unsafe_set s' !n c
      | c ->
          let a = char_code c in
          Bytes.unsafe_set s' !n '\\';
          incr n;
          Bytes.unsafe_set s' !n (char_chr (48 + a / 100));
          incr n;
          Bytes.unsafe_set s' !n (char_chr (48 + (a / 10) mod 10));
          incr n;
          Bytes.unsafe_set s' !n (char_chr (48 + a mod 10));
      end;
      incr n
    done;
    s'
  end

end
module Ext_string : sig 
#1 "ext_string.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Extension to the standard library [String] module, avoid locale sensitivity *) 


val trim : string -> string 

val split_by : ?keep_empty:bool -> (char -> bool) -> string -> string list
(** default is false *)

val split : ?keep_empty:bool -> string -> char -> string list
(** default is false *)

val starts_with : string -> string -> bool

(**
   return [-1] when not found, the returned index is useful 
   see [ends_with_then_chop]
*)
val ends_with_index : string -> string -> int

val ends_with : string -> string -> bool

(**
   {[
     ends_with_then_chop "a.cmj" ".cmj"
     "a"
   ]}
   This is useful in controlled or file case sensitve system
*)
val ends_with_then_chop : string -> string -> string option


val escaped : string -> string

val for_all : (char -> bool) -> string -> bool

val is_empty : string -> bool

val repeat : int -> string -> string 

val equal : string -> string -> bool

val find : ?start:int -> sub:string -> string -> int

val rfind : sub:string -> string -> int

val tail_from : string -> int -> string

val digits_of_str : string -> offset:int -> int -> int

val starts_with_and_number : string -> offset:int -> string -> int

val unsafe_concat_with_length : int -> string -> string list -> string

end = struct
#1 "ext_string.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








let split_by ?(keep_empty=false) is_delim str =
  let len = String.length str in
  let rec loop acc last_pos pos =
    if pos = -1 then
      if last_pos = 0 && not keep_empty then
        (*
           {[ split " test_unsafe_obj_ffi_ppx.cmi" ~keep_empty:false ' ']}
        *)
        acc
      else 
        String.sub str 0 last_pos :: acc
    else
      if is_delim str.[pos] then
        let new_len = (last_pos - pos - 1) in
        if new_len <> 0 || keep_empty then 
          let v = String.sub str (pos + 1) new_len in
          loop ( v :: acc)
            pos (pos - 1)
        else loop acc pos (pos - 1)
    else loop acc last_pos (pos - 1)
  in
  loop [] len (len - 1)

let trim s = 
  let i = ref 0  in
  let j = String.length s in 
  while !i < j &&  let u = s.[!i] in u = '\t' || u = '\n' || u = ' ' do 
    incr i;
  done;
  let k = ref (j - 1)  in 
  while !k >= !i && let u = s.[!k] in u = '\t' || u = '\n' || u = ' ' do 
    decr k ;
  done;
  String.sub s !i (!k - !i + 1)

let split ?keep_empty  str on = 
  if str = "" then [] else 
  split_by ?keep_empty (fun x -> (x : char) = on) str  ;;

let starts_with s beg = 
  let beg_len = String.length beg in
  let s_len = String.length s in
   beg_len <=  s_len &&
  (let i = ref 0 in
    while !i <  beg_len 
          && String.unsafe_get s !i =
             String.unsafe_get beg !i do 
      incr i 
    done;
    !i = beg_len
  )



let ends_with_index s beg = 
  let s_finish = String.length s - 1 in
  let s_beg = String.length beg - 1 in
  if s_beg > s_finish then -1
  else
    let rec aux j k = 
      if k < 0 then (j + 1)
      else if String.unsafe_get s j = String.unsafe_get beg k then 
        aux (j - 1) (k - 1)
      else  -1 in 
    aux s_finish s_beg

let ends_with s beg = ends_with_index s beg >= 0 


let ends_with_then_chop s beg = 
  let i =  ends_with_index s beg in 
  if i >= 0 then Some (String.sub s 0 i) 
  else None

(**  In OCaml 4.02.3, {!String.escaped} is locale senstive, 
     this version try to make it not locale senstive, this bug is fixed
     in the compiler trunk     
*)
let escaped s =
  let rec needs_escape i =
    if i >= String.length s then false else
      match String.unsafe_get s i with
      | '"' | '\\' | '\n' | '\t' | '\r' | '\b' -> true
      | ' ' .. '~' -> needs_escape (i+1)
      | _ -> true
  in
  if needs_escape 0 then
    Bytes.unsafe_to_string (Ext_bytes.escaped (Bytes.unsafe_of_string s))
  else
    s


let for_all (p : char -> bool) s = 
  let len = String.length s in
  let rec aux i = 
    if i >= len then true 
    else  p (String.unsafe_get s i) && aux (i + 1)
  in aux 0 

let is_empty s = String.length s = 0


let repeat n s  =
  let len = String.length s in
  let res = Bytes.create(n * len) in
  for i = 0 to pred n do
    String.blit s 0 res (i * len) len
  done;
  Bytes.to_string res

let equal (x : string) y  = x = y



let _is_sub ~sub i s j ~len =
  let rec check k =
    if k = len
    then true
    else 
      String.unsafe_get sub (i+k) = 
      String.unsafe_get s (j+k) && check (k+1)
  in
  j+len <= String.length s && check 0



let find ?(start=0) ~sub s =
  let n = String.length sub in
  let i = ref start in
  let module M = struct exception Exit end  in
  try
    while !i + n <= String.length s do
      if _is_sub ~sub 0 s !i ~len:n then raise M.Exit;
      incr i
    done;
    -1
  with M.Exit ->
    !i


let rfind ~sub s =
  let n = String.length sub in
  let i = ref (String.length s - n) in
  let module M = struct exception Exit end in 
  try
    while !i >= 0 do
      if _is_sub ~sub 0 s !i ~len:n then raise M.Exit;
      decr i
    done;
    -1
  with M.Exit ->
    !i

let tail_from s x = 
  let len = String.length s  in 
  if  x > len then invalid_arg ("Ext_string.tail_from " ^s ^ " : "^ string_of_int x )
  else String.sub s x (len - x)


(**
   {[ 
     digits_of_str "11_js" 2 == 11     
   ]}
*)
let digits_of_str s ~offset x = 
  let rec aux i acc s x  = 
    if i >= x then acc 
    else aux (i + 1) (10 * acc + Char.code s.[offset + i] - 48 (* Char.code '0' *)) s x in 
  aux 0 0 s x 



(*
   {[
     starts_with_and_number "js_fn_mk_01" 0 "js_fn_mk_" = 1 ;;
     starts_with_and_number "js_fn_run_02" 0 "js_fn_mk_" = -1 ;;
     starts_with_and_number "js_fn_mk_03" 6 "mk_" = 3 ;;
     starts_with_and_number "js_fn_mk_04" 6 "run_" = -1;;
     starts_with_and_number "js_fn_run_04" 6 "run_" = 4;;
     (starts_with_and_number "js_fn_run_04" 6 "run_" = 3) = false ;;
   ]}
*)
let starts_with_and_number s ~offset beg =
  let beg_len = String.length beg in
  let s_len = String.length s in
  let finish_delim = offset + beg_len in 

   if finish_delim >  s_len  then -1 
   else 
     let i = ref offset  in
      while !i <  finish_delim
            && String.unsafe_get s !i =
               String.unsafe_get beg (!i - offset) do 
        incr i 
      done;
      if !i = finish_delim then 
        digits_of_str ~offset:finish_delim s 2 
      else 
        -1 

let equal (x : string) y  = x = y

let unsafe_concat_with_length len sep l =
  match l with 
  | [] -> ""
  | hd :: tl -> (* num is positive *)
  let r = Bytes.create len in
  let hd_len = String.length hd in 
  let sep_len = String.length sep in 
  String.unsafe_blit hd 0 r 0 hd_len;
  let pos = ref hd_len in
  List.iter
    (fun s ->
       let s_len = String.length s in
       String.unsafe_blit sep 0 r !pos sep_len;
       pos := !pos +  sep_len;
       String.unsafe_blit s 0 r !pos s_len;
       pos := !pos + s_len)
    tl;
  Bytes.unsafe_to_string r

end
module Literals : sig 
#1 "literals.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






val js_array_ctor : string 
val js_type_number : string
val js_type_string : string
val js_type_object : string
val js_undefined : string
val js_prop_length : string

val param : string
val partial_arg : string
val prim : string

(**temporary varaible used in {!Js_ast_util} *)
val tmp : string 

val create : string 

val app : string
val app_array : string

val runtime : string
val stdlib : string
val imul : string

val setter_suffix : string
val setter_suffix_len : int


val js_debugger : string
val js_pure_expr : string
val js_pure_stmt : string
val js_unsafe_downgrade : string
val js_fn_run : string
val js_method_run : string
val js_fn_method : string
val js_fn_mk : string

(** callback actually, not exposed to user yet *)
val js_fn_runmethod : string 

val bs_deriving : string
val bs_deriving_dot : string
val bs_type : string

(** nodejs *)

val node_modules : string
val node_modules_length : int
val package_json : string  

val suffix_cmj : string
val suffix_cmi : string
val suffix_ml : string
val suffix_mlast : string 
val suffix_mliast : string
val suffix_mll : string
val suffix_d : string
val suffix_mlastd : string
val suffix_mliastd : string

end = struct
#1 "literals.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)







let js_array_ctor = "Array"
let js_type_number = "number"
let js_type_string = "string"
let js_type_object = "object" 
let js_undefined = "undefined"
let js_prop_length = "length"

let prim = "prim"
let param = "param"
let partial_arg = "partial_arg"
let tmp = "tmp"

let create = "create" (* {!Caml_exceptions.create}*)

let app = "_"
let app_array = "app" (* arguments are an array*)

let runtime = "runtime" (* runtime directory *)

let stdlib = "stdlib"

let imul = "imul" (* signed int32 mul *)

let setter_suffix = "#="
let setter_suffix_len = String.length setter_suffix

let js_debugger = "js_debugger"
let js_pure_expr = "js_pure_expr"
let js_pure_stmt = "js_pure_stmt"
let js_unsafe_downgrade = "js_unsafe_downgrade"
let js_fn_run = "js_fn_run"
let js_method_run = "js_method_run"

let js_fn_method = "js_fn_method"
let js_fn_mk = "js_fn_mk"
let js_fn_runmethod = "js_fn_runmethod"

let bs_deriving = "bs.deriving"
let bs_deriving_dot = "bs.deriving."
let bs_type = "bs.type"


(** nodejs *)
let node_modules = "node_modules"
let node_modules_length = String.length "node_modules"
let package_json = "package.json"


let suffix_cmj = ".cmj"
let suffix_cmi = ".cmi"
let suffix_mll = ".mll"
let suffix_ml = ".ml"
let suffix_mlast = ".mlast"
let suffix_mliast = ".mliast"
let suffix_d = ".d"
let suffix_mlastd = ".mlast.d"
let suffix_mliastd = ".mliast.d"



end
module Ext_filename : sig 
#1 "ext_filename.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)





(* TODO:
   Change the module name, this code is not really an extension of the standard 
    library but rather specific to JS Module name convention. 
*)

type t = 
  [ `File of string 
  | `Dir of string ]

val combine : string -> string -> string 
val path_as_directory : string -> string

(** An extension module to calculate relative path follow node/npm style. 
    TODO : this short name will have to change upon renaming the file.
 *)

(** Js_output is node style, which means 
    separator is only '/'

    if the path contains 'node_modules', 
    [node_relative_path] will discard its prefix and 
    just treat it as a library instead
 *)

val node_relative_path : t -> [`File of string] -> string

val chop_extension : ?loc:string -> string -> string






val cwd : string Lazy.t
val package_dir : string Lazy.t

val replace_backward_slash : string -> string

val module_name_of_file : string -> string

val chop_extension_if_any : string -> string

val absolute_path : string -> string

val module_name_of_file_if_any : string -> string

end = struct
#1 "ext_filename.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Used when produce node compatible paths *)
let node_sep = "/"
let node_parent = ".."
let node_current = "."

type t = 
  [ `File of string 
  | `Dir of string ]

let cwd = lazy (Sys.getcwd ())

let (//) = Filename.concat 

let combine path1 path2 =
  if path1 = "" then
    path2
  else if path2 = "" then path1
  else 
  if Filename.is_relative path2 then
     path1// path2 
  else
    path2

(* Note that [.//] is the same as [./] *)
let path_as_directory x =
  if x = "" then x
  else
  if Ext_string.ends_with x  Filename.dir_sep then
    x 
  else 
    x ^ Filename.dir_sep

let absolute_path s = 
  let process s = 
    let s = 
      if Filename.is_relative s then
        Lazy.force cwd // s 
      else s in
    (* Now simplify . and .. components *)
    let rec aux s =
      let base,dir  = Filename.basename s, Filename.dirname s  in
      if dir = s then dir
      else if base = Filename.current_dir_name then aux dir
      else if base = Filename.parent_dir_name then Filename.dirname (aux dir)
      else aux dir // base
    in aux s  in 
  process s 


let chop_extension ?(loc="") name =
  try Filename.chop_extension name 
  with Invalid_argument _ -> 
    Ext_pervasives.invalid_argf 
      "Filename.chop_extension ( %s : %s )"  loc name

let chop_extension_if_any fname =
  try Filename.chop_extension fname with Invalid_argument _ -> fname



(** example
    {[
    "/bb/mbigc/mbig2899/bgit/bucklescript/jscomp/stdlib/external/pervasives.cmj"
    "/bb/mbigc/mbig2899/bgit/bucklescript/jscomp/stdlib/ocaml_array.ml"
    ]}

    The other way
    {[
    
    "/bb/mbigc/mbig2899/bgit/bucklescript/jscomp/stdlib/ocaml_array.ml"
    "/bb/mbigc/mbig2899/bgit/bucklescript/jscomp/stdlib/external/pervasives.cmj"
    ]}
    {[
    "/bb/mbigc/mbig2899/bgit/bucklescript/jscomp/stdlib//ocaml_array.ml"
    ]}
    {[
    /a/b
    /c/d
    ]}
 *)
let relative_path file_or_dir_1 file_or_dir_2 = 
  let sep_char = Filename.dir_sep.[0] in
  let relevant_dir1 = 
    (match file_or_dir_1 with 
    | `Dir x -> x 
    | `File file1 ->  Filename.dirname file1) in
  let relevant_dir2 = 
    (match file_or_dir_2 with 
    |`Dir x -> x 
    |`File file2 -> Filename.dirname file2 ) in
  let dir1 = Ext_string.split relevant_dir1 sep_char   in
  let dir2 = Ext_string.split relevant_dir2 sep_char  in
  let rec go (dir1 : string list) (dir2 : string list) = 
    match dir1, dir2 with 
    | x::xs , y :: ys when x = y
      -> go xs ys 
    | _, _
      -> 
        List.map (fun _ -> node_parent) dir2 @ dir1 
  in
  match go dir1 dir2 with
  | (x :: _ ) as ys when x = node_parent -> 
      String.concat node_sep ys
  | ys -> 
      String.concat node_sep  @@ node_current :: ys





let os_path_separator_char = String.unsafe_get Filename.dir_sep 0 

(** path2: a/b 
    path1: a 
    result:  ./b 
    TODO: [Filename.concat] with care

    [file1] is currently compilation file 
    [file2] is the dependency
 *)
let node_relative_path (file1 : t) 
    (`File file2 as dep_file : [`File of string]) = 
  let v = Ext_string.find  file2 ~sub:Literals.node_modules in 
  let len = String.length file2 in 
  if v >= 0 then
    let rec skip  i =       
      if i >= len then
        Ext_pervasives.failwithf ~loc:__LOC__ "invalid path: %s"  file2
      else 
        (* https://en.wikipedia.org/wiki/Path_(computing))
           most path separator are a single char 
        *)
        let curr_char = String.unsafe_get file2 i  in 
        if curr_char = os_path_separator_char || curr_char = '.' then 
          skip (i + 1) 
        else i
        (*
          TODO: we need do more than this suppose user 
          input can be
           {[
           "xxxghsoghos/ghsoghso/node_modules/../buckle-stdlib/list.js"
           ]}
           This seems weird though
        *)
    in 
    Ext_string.tail_from file2
      (skip (v + Literals.node_modules_length)) 
  else 
    relative_path 
      (  match dep_file with 
         | `File x -> `File (absolute_path x)
         | `Dir x -> `Dir (absolute_path x))

       (match file1 with 
         | `File x -> `File (absolute_path x)
         | `Dir x -> `Dir(absolute_path x))
     ^ node_sep ^
    chop_extension_if_any (Filename.basename file2)





let find_package_json_dir cwd  = 
  let rec aux cwd  = 
    if Sys.file_exists (cwd // Literals.package_json) then cwd
    else 
      let cwd' = Filename.dirname cwd in 
      if String.length cwd' < String.length cwd then  
        aux cwd'
      else 
        Ext_pervasives.failwithf 
          ~loc:__LOC__
            "package.json not found from %s" cwd
  in
  aux cwd 

let package_dir = lazy (find_package_json_dir (Lazy.force cwd))

let replace_backward_slash (x : string)= 
  String.map (function 
    |'\\'-> '/'
    | x -> x) x  

let module_name_of_file file =
    String.capitalize 
      (Filename.chop_extension @@ Filename.basename file)  

let module_name_of_file_if_any file = 
    String.capitalize 
      (chop_extension_if_any @@ Filename.basename file)  


(** For win32 or case insensitve OS 
    [".cmj"] is the same as [".CMJ"]
  *)
(* let has_exact_suffix_then_chop fname suf =  *)
  

end
module Js_config : sig 
#1 "js_config.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


type module_system = 
  [ `NodeJS | `AmdJS | `Goog ] (* This will be serliazed *)


type package_info = 
 (module_system * string )

type package_name  = string
type packages_info =
  | Empty 
  | NonBrowser of (package_name * package_info  list)



val cmj_ext : string 


(* val is_browser : unit -> bool  *)
(* val set_browser : unit -> unit *)


val get_ext : unit -> string

(** depends on [package_infos], used in {!Js_program_loader} *)
val get_output_dir : module_system -> string -> string


(** used by command line option *)
val set_npm_package_path : string -> unit 
val get_packages_info : unit -> packages_info

type info_query = 
  [ `Empty 
  | `Package_script of string
  | `Found of package_name * string
  | `NotFound 
  ]

val query_package_infos : 
  packages_info ->
  module_system ->
  info_query



(** set/get header *)
val no_version_header : bool ref 


(** return [package_name] and [path] 
    when in script mode: 
*)

val get_current_package_name_and_path : 
  module_system -> info_query


val set_package_name : string -> unit 
val get_package_name : unit -> string option

(** corss module inline option *)
val cross_module_inline : bool ref
val set_cross_module_inline : bool -> unit
val get_cross_module_inline : unit -> bool
  
(** diagnose option *)
val diagnose : bool ref 
val get_diagnose : unit -> bool 
val set_diagnose : bool -> unit 


(** generate tds option *)
val default_gen_tds : bool ref

(** options for builtion ppx *)
val no_builtin_ppx_ml : bool ref 
val no_builtin_ppx_mli : bool ref 
val no_warn_ffi_type : bool ref 
val no_warn_unused_bs_attribute : bool ref 

(** check-div-by-zero option *)
val check_div_by_zero : bool ref 
val get_check_div_by_zero : unit -> bool 

(* It will imply [-noassert] be set too, note from the implmentation point of view, 
   in the lambda layer, it is impossible to tell whehther it is [assert (3 <> 2)] or 
   [if (3<>2) then assert false]
 *)
val no_any_assert : bool ref 
val set_no_any_assert : unit -> unit
val get_no_any_assert : unit -> bool 


val block : string
val int32 : string
val gc : string 
val backtrace : string
val version : string
val builtin_exceptions : string
val exceptions : string
val io : string
val oo : string
val sys : string
val lexer : string 
val parser : string
val obj_runtime : string
val array : string
val format : string
val string : string
val bytes : string  
val float : string 
val curry : string 
(* val bigarray : string *)
(* val unix : string *)
val int64 : string
val md5 : string
val hash : string
val weak : string
val js_primitive : string
val module_ : string

(** Debugging utilies *)
val set_current_file : string -> unit 
val get_current_file : unit -> string
val get_module_name : unit -> string

val iset_debug_file : string -> unit
val set_debug_file : string -> unit
val get_debug_file : unit -> string

val is_same_file : unit -> bool 

val tool_name : string

val is_windows : bool 

val better_errors : bool ref
val sort_imports : bool ref 
val dump_js : bool ref
val syntax_only  : bool ref
val binary_ast : bool ref

end = struct
#1 "js_config.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)







type env =
  | NodeJS
  | AmdJS
  | Goog (* of string option *)



type path = string
type module_system =
  [ `NodeJS | `AmdJS | `Goog ]
type package_info =
 ( module_system * string )

type package_name  = string
type packages_info =
  | Empty (* No set *)
  | NonBrowser of (package_name * package_info  list)
(** we don't force people to use package *)



let ext = ref ".js"
let cmj_ext = ".cmj"



let get_ext () = !ext


let packages_info : packages_info ref = ref Empty


let get_package_name () =
  match !packages_info with
  | Empty  -> None
  | NonBrowser(n,_) -> Some n

let no_version_header = ref false

let set_package_name name =
  match !packages_info with
  | Empty -> packages_info := NonBrowser(name,  [])
  |  _ ->
    Ext_pervasives.bad_argf "duplicated flag for -bs-package-name"


let set_npm_package_path s =
  match !packages_info  with
  | Empty ->
    Ext_pervasives.bad_argf "please set package name first using -bs-package-name ";
  | NonBrowser(name,  envs) ->
    let env, path =
      match Ext_string.split ~keep_empty:false s ':' with
      | [ package_name; path]  ->
        (match package_name with
         | "commonjs" -> `NodeJS
         | "amdjs" -> `AmdJS
         | "goog" -> `Goog
         | _ ->
           Ext_pervasives.bad_argf "invalid module system %s" package_name), path
      | [path] ->
        `NodeJS, path
      | _ ->
        Ext_pervasives.bad_argf "invalid npm package path: %s" s
    in
    packages_info := NonBrowser (name,  ((env,path) :: envs))
   (** Browser is not set via command line only for internal use *)




let cross_module_inline = ref false

let get_cross_module_inline () = !cross_module_inline
let set_cross_module_inline b =
  cross_module_inline := b


let diagnose = ref false
let get_diagnose () = !diagnose
let set_diagnose b = diagnose := b

let (//) = Filename.concat

let get_packages_info () = !packages_info

type info_query =
  [ `Empty
  | `Package_script of string
  | `Found of package_name * string
  | `NotFound ]
let query_package_infos package_infos module_system =
  match package_infos with
  | Empty -> `Empty
  | NonBrowser (name, []) -> `Package_script name
  | NonBrowser (name, paths) ->
    begin match List.find (fun (k, _) -> k = module_system) paths with
      | (_, x) -> `Found (name, x)
      | exception _ -> `NotFound
    end

let get_current_package_name_and_path   module_system =
  query_package_infos !packages_info module_system


(* for a single pass compilation, [output_dir]
   can be cached
*)
let get_output_dir module_system filename =
  match !packages_info with
  | Empty | NonBrowser (_, [])->
    if Filename.is_relative filename then
      Lazy.force Ext_filename.cwd //
      Filename.dirname filename
    else
      Filename.dirname filename
  | NonBrowser (_,  modules) ->
    begin match List.find (fun (k,_) -> k = module_system) modules with
      | (_, _path) -> Lazy.force Ext_filename.package_dir // _path
      |  exception _ -> assert false
    end




let default_gen_tds = ref false

let no_builtin_ppx_ml = ref false
let no_builtin_ppx_mli = ref false
let no_warn_ffi_type = ref false

(** TODO: will flip the option when it is ready *)
let no_warn_unused_bs_attribute = ref false


let builtin_exceptions = "Caml_builtin_exceptions"
let exceptions = "Caml_exceptions"
let io = "Caml_io"
let sys = "Caml_sys"
let lexer = "Caml_lexer"
let parser = "Caml_parser"
let obj_runtime = "Caml_obj"
let array = "Caml_array"
let format = "Caml_format"
let string = "Caml_string"
let bytes = "Caml_bytes"
let float = "Caml_float"
let hash = "Caml_hash"
let oo = "Caml_oo"
let curry = "Curry"
let int64 = "Caml_int64"
let md5 = "Caml_md5"
let weak = "Caml_weak"
let backtrace = "Caml_backtrace"
let gc = "Caml_gc"
let int32 = "Caml_int32"
let block = "Block"
let js_primitive = "Js_primitive"
let module_ = "Caml_module"
let version = "1.2.2"
let current_file = ref ""
let debug_file = ref ""

let set_current_file f  = current_file := f
let get_current_file () = !current_file
let get_module_name () =
  Filename.chop_extension
    (Filename.basename (String.uncapitalize !current_file))

let iset_debug_file _ = ()
let set_debug_file  f = debug_file := f
let get_debug_file  () = !debug_file


let is_same_file () =
  !debug_file <> "" &&  !debug_file = !current_file

let tool_name = "BuckleScript"

let check_div_by_zero = ref true
let get_check_div_by_zero () = !check_div_by_zero

let no_any_assert = ref false

let set_no_any_assert () = no_any_assert := true
let get_no_any_assert () = !no_any_assert

let better_errors = ref false
let sort_imports = ref false
let dump_js = ref false

let is_windows =
  match Sys.os_type with
  | "Win32"
  | "Cygwin"-> true
  | _ -> false

let syntax_only = ref false
let binary_ast = ref false

end
module Bs_conditional_initial : sig 
#1 "bs_conditional_initial.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

val setup_env : unit -> unit

end = struct
#1 "bs_conditional_initial.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


let setup_env () = 
  Lexer.replace_directive_built_in_value "BS" (Dir_bool true);
  Lexer.replace_directive_built_in_value "BS_VERSION" (Dir_string Js_config.version)

end
module Bs_exception : sig 
#1 "bs_exception.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type error =
  | Cmj_not_found of string
  | Bs_cyclic_depends of string  list
  | Bs_duplicated_module of string * string
  | Bs_package_not_found of string                                                        
  | Bs_main_not_exist of string 
  | Bs_invalid_path of string
      
val error : error -> 'a 

end = struct
#1 "bs_exception.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


type error =
  | Cmj_not_found of string
  | Bs_cyclic_depends of string  list
  | Bs_duplicated_module of string * string
  | Bs_package_not_found of string                            
  | Bs_main_not_exist of string 
  | Bs_invalid_path of string
      
exception Error of error

let error err = raise (Error err)

let report_error ppf = function
  | Cmj_not_found s ->
    Format.fprintf ppf "%s not found, cmj format is generated by BuckleScript" s
  | Bs_cyclic_depends  str
    ->
    Format.fprintf ppf "Cyclic depends : @[%a@]"
      (Format.pp_print_list ~pp_sep:Format.pp_print_space
         Format.pp_print_string)
      str
  | Bs_duplicated_module (a,b)
    ->
    Format.fprintf ppf "The build system does not support two files with same names yet %s, %s" a b
  | Bs_main_not_exist main
    ->
    Format.fprintf ppf "File %s not found " main

  | Bs_package_not_found package
    ->
    Format.fprintf ppf "Package %s not found or %s/lib/ocaml does not exist"
      package package
  | Bs_invalid_path path
    ->  Format.pp_print_string ppf ("Invalid path: " ^ path )
let () =
  Location.register_error_of_exn
    (function
      | Error err
        -> Some (Location.error_of_printer_file report_error err)
      | _ -> None
    )



end
module Ext_sys : sig 
#1 "ext_sys.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

val is_directory_no_exn : string -> bool

end = struct
#1 "ext_sys.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


let is_directory_no_exn f = 
  try Sys.is_directory f with _ -> false 

end
module Binary_ast : sig 
#1 "binary_ast.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type _ kind = 
  | Ml : Parsetree.structure kind 
  | Mli : Parsetree.signature kind 

val read_ast : 'a kind -> string -> 'a 

(**
   The [.ml] file can be recognized as an ast directly, the format
   is
   {
   magic number;
   filename;
   ast
   }
   when [fname] is "-" it means the file is from an standard input or pipe.
   An empty name would marshallized.

   Use case cat - | fan -printer -impl -
   redirect the standard input to fan
 *)
val write_ast : fname:string -> output:string -> 'a kind -> 'a -> unit


end = struct
#1 "binary_ast.ml"

(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


type _ kind = 
  | Ml : Parsetree.structure kind 
  | Mli : Parsetree.signature kind 


let read_ast (type t ) (kind : t kind) fn : t  =
  let magic =
    match kind with 
    | Ml -> Config.ast_impl_magic_number
    | Mli -> Config.ast_intf_magic_number in 
  let ic = open_in_bin fn in
  try
    let buffer = really_input_string ic (String.length magic) in
    assert(buffer = magic); (* already checked by apply_rewriter *)
    Location.input_name := input_value ic;
    let ast = input_value ic in
    close_in ic;
    ast
  with exn ->
    close_in ic;
    raise exn


let write_ast (type t) ~(fname : string) ~output (kind : t kind) ( pt : t) : unit =
  let magic = 
    match kind with 
    | Ml -> Config.ast_impl_magic_number
    | Mli -> Config.ast_intf_magic_number in
  let oc = open_out output in 
  output_string oc magic ;
  output_value oc fname;
  output_value oc pt;
  close_out oc 


end
module Bs_ast_iterator : sig 
#1 "bs_ast_iterator.mli"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*                      Nicolas Ojeda Bar, LexiFi                         *)
(*                                                                        *)
(*   Copyright 2012 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(** {!iterator} allows to implement AST inspection using open recursion.  A
    typical mapper would be based on {!default_iterator}, a trivial iterator,
    and will fall back on it for handling the syntax it does not modify. *)

open Parsetree

(** {2 A generic Parsetree iterator} *)

type iterator = {
  attribute: iterator -> attribute -> unit;
  attributes: iterator -> attribute list -> unit;
  case: iterator -> case -> unit;
  cases: iterator -> case list -> unit;
  class_declaration: iterator -> class_declaration -> unit;
  class_description: iterator -> class_description -> unit;
  class_expr: iterator -> class_expr -> unit;
  class_field: iterator -> class_field -> unit;
  class_signature: iterator -> class_signature -> unit;
  class_structure: iterator -> class_structure -> unit;
  class_type: iterator -> class_type -> unit;
  class_type_declaration: iterator -> class_type_declaration -> unit;
  class_type_field: iterator -> class_type_field -> unit;
  constructor_declaration: iterator -> constructor_declaration -> unit;
  expr: iterator -> expression -> unit;
  extension: iterator -> extension -> unit;
  extension_constructor: iterator -> extension_constructor -> unit;
  include_declaration: iterator -> include_declaration -> unit;
  include_description: iterator -> include_description -> unit;
  label_declaration: iterator -> label_declaration -> unit;
  location: iterator -> Location.t -> unit;
  module_binding: iterator -> module_binding -> unit;
  module_declaration: iterator -> module_declaration -> unit;
  module_expr: iterator -> module_expr -> unit;
  module_type: iterator -> module_type -> unit;
  module_type_declaration: iterator -> module_type_declaration -> unit;
  open_description: iterator -> open_description -> unit;
  pat: iterator -> pattern -> unit;
  payload: iterator -> payload -> unit;
  signature: iterator -> signature -> unit;
  signature_item: iterator -> signature_item -> unit;
  structure: iterator -> structure -> unit;
  structure_item: iterator -> structure_item -> unit;
  typ: iterator -> core_type -> unit;
  type_declaration: iterator -> type_declaration -> unit;
  type_extension: iterator -> type_extension -> unit;
  type_kind: iterator -> type_kind -> unit;
  value_binding: iterator -> value_binding -> unit;
  value_description: iterator -> value_description -> unit;
  with_constraint: iterator -> with_constraint -> unit;
}
(** A [iterator] record implements one "method" per syntactic category,
    using an open recursion style: each method takes as its first
    argument the iterator to be applied to children in the syntax
    tree. *)

val default_iterator: iterator
(** A default iterator, which implements a "do not do anything" mapping. *)

end = struct
#1 "bs_ast_iterator.ml"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*                      Nicolas Ojeda Bar, LexiFi                         *)
(*                                                                        *)
(*   Copyright 2012 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)
[@@@ocaml.warning "+9"]
(* A generic Parsetree mapping class *)
(* Back-ported from 4.04 By Hongbo ZHang, after grading to 4.04, we will remove this file  *)
(*

  (* Ensure that record patterns don't miss any field. *)
*)


open Parsetree
open Location

type iterator = {
  attribute: iterator -> attribute -> unit;
  attributes: iterator -> attribute list -> unit;
  case: iterator -> case -> unit;
  cases: iterator -> case list -> unit;
  class_declaration: iterator -> class_declaration -> unit;
  class_description: iterator -> class_description -> unit;
  class_expr: iterator -> class_expr -> unit;
  class_field: iterator -> class_field -> unit;
  class_signature: iterator -> class_signature -> unit;
  class_structure: iterator -> class_structure -> unit;
  class_type: iterator -> class_type -> unit;
  class_type_declaration: iterator -> class_type_declaration -> unit;
  class_type_field: iterator -> class_type_field -> unit;
  constructor_declaration: iterator -> constructor_declaration -> unit;
  expr: iterator -> expression -> unit;
  extension: iterator -> extension -> unit;
  extension_constructor: iterator -> extension_constructor -> unit;
  include_declaration: iterator -> include_declaration -> unit;
  include_description: iterator -> include_description -> unit;
  label_declaration: iterator -> label_declaration -> unit;
  location: iterator -> Location.t -> unit;
  module_binding: iterator -> module_binding -> unit;
  module_declaration: iterator -> module_declaration -> unit;
  module_expr: iterator -> module_expr -> unit;
  module_type: iterator -> module_type -> unit;
  module_type_declaration: iterator -> module_type_declaration -> unit;
  open_description: iterator -> open_description -> unit;
  pat: iterator -> pattern -> unit;
  payload: iterator -> payload -> unit;
  signature: iterator -> signature -> unit;
  signature_item: iterator -> signature_item -> unit;
  structure: iterator -> structure -> unit;
  structure_item: iterator -> structure_item -> unit;
  typ: iterator -> core_type -> unit;
  type_declaration: iterator -> type_declaration -> unit;
  type_extension: iterator -> type_extension -> unit;
  type_kind: iterator -> type_kind -> unit;
  value_binding: iterator -> value_binding -> unit;
  value_description: iterator -> value_description -> unit;
  with_constraint: iterator -> with_constraint -> unit;
}
(** A [iterator] record implements one "method" per syntactic category,
    using an open recursion style: each method takes as its first
    argument the iterator to be applied to children in the syntax
    tree. *)

let iter_fst f (x, _) = f x
let iter_snd f (_, y) = f y
let iter_tuple f1 f2 (x, y) = f1 x; f2 y
let iter_tuple3 f1 f2 f3 (x, y, z) = f1 x; f2 y; f3 z
let iter_opt f = function None -> () | Some x -> f x

let iter_loc sub {loc; txt = _} = sub.location sub loc

module T = struct
  (* Type expressions for the core language *)

  let row_field sub = function
    | Rtag (_, attrs, _, tl) ->
        sub.attributes sub attrs; List.iter (sub.typ sub) tl
    | Rinherit t -> sub.typ sub t

  let iter sub {ptyp_desc = desc; ptyp_loc = loc; ptyp_attributes = attrs} =
    sub.location sub loc;
    sub.attributes sub attrs;
    match desc with
    | Ptyp_any
    | Ptyp_var _ -> ()
    | Ptyp_arrow (_lab, t1, t2) ->
        sub.typ sub t1; sub.typ sub t2
    | Ptyp_tuple tyl -> List.iter (sub.typ sub) tyl
    | Ptyp_constr (lid, tl) ->
        iter_loc sub lid; List.iter (sub.typ sub) tl
    | Ptyp_object (l, _o) ->
        let f (_, a, t) = sub.attributes sub a; sub.typ sub t in
        List.iter f l
    | Ptyp_class (lid, tl) ->
        iter_loc sub lid; List.iter (sub.typ sub) tl
    | Ptyp_alias (t, _) -> sub.typ sub t
    | Ptyp_variant (rl, _b, _ll) ->
        List.iter (row_field sub) rl
    | Ptyp_poly (_, t) -> sub.typ sub t
    | Ptyp_package (lid, l) ->
        iter_loc sub lid;
        List.iter (iter_tuple (iter_loc sub) (sub.typ sub)) l
    | Ptyp_extension x -> sub.extension sub x

  let iter_type_declaration sub
      {ptype_name; ptype_params; ptype_cstrs;
       ptype_kind;
       ptype_private = _;
       ptype_manifest;
       ptype_attributes;
       ptype_loc} =
    iter_loc sub ptype_name;
    List.iter (iter_fst (sub.typ sub)) ptype_params;
    List.iter
      (iter_tuple3 (sub.typ sub) (sub.typ sub) (sub.location sub))
      ptype_cstrs;
    sub.type_kind sub ptype_kind;
    iter_opt (sub.typ sub) ptype_manifest;
    sub.location sub ptype_loc;
    sub.attributes sub ptype_attributes

  let iter_type_kind sub = function
    | Ptype_abstract -> ()
    | Ptype_variant l ->
        List.iter (sub.constructor_declaration sub) l
    | Ptype_record l -> List.iter (sub.label_declaration sub) l
    | Ptype_open -> ()

  let iter_constructor_arguments sub l = List.iter (sub.typ sub) l
      (*# no inline record in 4.02.3*)
  let iter_type_extension sub
      {ptyext_path; ptyext_params;
       ptyext_constructors;
       ptyext_private = _;
       ptyext_attributes} =
    iter_loc sub ptyext_path;
    List.iter (sub.extension_constructor sub) ptyext_constructors;
    List.iter (iter_fst (sub.typ sub)) ptyext_params;
    sub.attributes sub ptyext_attributes

  let iter_extension_constructor_kind sub = function
      Pext_decl(ctl, cto) ->
        iter_constructor_arguments sub ctl; iter_opt (sub.typ sub) cto
    | Pext_rebind li ->
        iter_loc sub li

  let iter_extension_constructor sub
      {pext_name;
       pext_kind;
       pext_loc;
       pext_attributes} =
    iter_loc sub pext_name;
    iter_extension_constructor_kind sub pext_kind;
    sub.location sub pext_loc;
    sub.attributes sub pext_attributes

end

module CT = struct
  (* Type expressions for the class language *)

  let iter sub {pcty_loc = loc; pcty_desc = desc; pcty_attributes = attrs} =
    sub.location sub loc;
    sub.attributes sub attrs;
    match desc with
    | Pcty_constr (lid, tys) ->
        iter_loc sub lid; List.iter (sub.typ sub) tys
    | Pcty_signature x -> sub.class_signature sub x
    | Pcty_arrow (_lab, t, ct) ->
        sub.typ sub t; sub.class_type sub ct
    | Pcty_extension x -> sub.extension sub x

  let iter_field sub {pctf_desc = desc; pctf_loc = loc; pctf_attributes = attrs}
    =
    sub.location sub loc;
    sub.attributes sub attrs;
    match desc with
    | Pctf_inherit ct -> sub.class_type sub ct
    | Pctf_val (_s, _m, _v, t) -> sub.typ sub t
    | Pctf_method (_s, _p, _v, t) -> sub.typ sub t
    | Pctf_constraint (t1, t2) ->
        sub.typ sub t1; sub.typ sub t2
    | Pctf_attribute x -> sub.attribute sub x
    | Pctf_extension x -> sub.extension sub x

  let iter_signature sub {pcsig_self; pcsig_fields} =
    sub.typ sub pcsig_self;
    List.iter (sub.class_type_field sub) pcsig_fields
end

module MT = struct
  (* Type expressions for the module language *)

  let iter sub {pmty_desc = desc; pmty_loc = loc; pmty_attributes = attrs} =
    sub.location sub loc;
    sub.attributes sub attrs;
    match desc with
    | Pmty_ident s -> iter_loc sub s
    | Pmty_alias s -> iter_loc sub s
    | Pmty_signature sg -> sub.signature sub sg
    | Pmty_functor (s, mt1, mt2) ->
        iter_loc sub s;
        iter_opt (sub.module_type sub) mt1;
        sub.module_type sub mt2
    | Pmty_with (mt, l) ->
        sub.module_type sub mt;
        List.iter (sub.with_constraint sub) l
    | Pmty_typeof me -> sub.module_expr sub me
    | Pmty_extension x -> sub.extension sub x

  let iter_with_constraint sub = function
    | Pwith_type (lid, d) ->
        iter_loc sub lid; sub.type_declaration sub d
    | Pwith_module (lid, lid2) ->
        iter_loc sub lid; iter_loc sub lid2
    | Pwith_typesubst d -> sub.type_declaration sub d
    | Pwith_modsubst (s, lid) ->
        iter_loc sub s; iter_loc sub lid

  let iter_signature_item sub {psig_desc = desc; psig_loc = loc} =
    sub.location sub loc;
    match desc with
    | Psig_value vd -> sub.value_description sub vd
    | Psig_type ( l) -> List.iter (sub.type_declaration sub) l
    (*#2 no rec_flag in 4.02.3*)
    | Psig_typext te -> sub.type_extension sub te
    | Psig_exception ed -> sub.extension_constructor sub ed
    | Psig_module x -> sub.module_declaration sub x
    | Psig_recmodule l ->
        List.iter (sub.module_declaration sub) l
    | Psig_modtype x -> sub.module_type_declaration sub x
    | Psig_open x -> sub.open_description sub x
    | Psig_include x -> sub.include_description sub x
    | Psig_class l -> List.iter (sub.class_description sub) l
    | Psig_class_type l ->
        List.iter (sub.class_type_declaration sub) l
    | Psig_extension (x, attrs) ->
        sub.extension sub x; sub.attributes sub attrs
    | Psig_attribute x -> sub.attribute sub x
end


module M = struct
  (* Value expressions for the module language *)

  let iter sub {pmod_loc = loc; pmod_desc = desc; pmod_attributes = attrs} =
    sub.location sub loc;
    sub.attributes sub attrs;
    match desc with
    | Pmod_ident x -> iter_loc sub x
    | Pmod_structure str -> sub.structure sub str
    | Pmod_functor (arg, arg_ty, body) ->
        iter_loc sub arg;
        iter_opt (sub.module_type sub) arg_ty;
        sub.module_expr sub body
    | Pmod_apply (m1, m2) ->
        sub.module_expr sub m1; sub.module_expr sub m2
    | Pmod_constraint (m, mty) ->
        sub.module_expr sub m; sub.module_type sub mty
    | Pmod_unpack e -> sub.expr sub e
    | Pmod_extension x -> sub.extension sub x

  let iter_structure_item sub {pstr_loc = loc; pstr_desc = desc} =
    sub.location sub loc;
    match desc with
    | Pstr_eval (x, attrs) ->
        sub.expr sub x; sub.attributes sub attrs
    | Pstr_value (_r, vbs) -> List.iter (sub.value_binding sub) vbs
    | Pstr_primitive vd -> sub.value_description sub vd
    | Pstr_type ( l) -> List.iter (sub.type_declaration sub) l
    (*#3 no rec flag in 4.02.3*)
    | Pstr_typext te -> sub.type_extension sub te
    | Pstr_exception ed -> sub.extension_constructor sub ed
    | Pstr_module x -> sub.module_binding sub x
    | Pstr_recmodule l -> List.iter (sub.module_binding sub) l
    | Pstr_modtype x -> sub.module_type_declaration sub x
    | Pstr_open x -> sub.open_description sub x
    | Pstr_class l -> List.iter (sub.class_declaration sub) l
    | Pstr_class_type l ->
        List.iter (sub.class_type_declaration sub) l
    | Pstr_include x -> sub.include_declaration sub x
    | Pstr_extension (x, attrs) ->
        sub.extension sub x; sub.attributes sub attrs
    | Pstr_attribute x -> sub.attribute sub x
end

module E = struct
  (* Value expressions for the core language *)

  let iter sub {pexp_loc = loc; pexp_desc = desc; pexp_attributes = attrs} =
    sub.location sub loc;
    sub.attributes sub attrs;
    match desc with
    | Pexp_ident x -> iter_loc sub x
    | Pexp_constant _ -> ()
    | Pexp_let (_r, vbs, e) ->
        List.iter (sub.value_binding sub) vbs;
        sub.expr sub e
    | Pexp_fun (_lab, def, p, e) ->
        iter_opt (sub.expr sub) def;
        sub.pat sub p;
        sub.expr sub e
    | Pexp_function pel -> sub.cases sub pel
    | Pexp_apply (e, l) ->
        sub.expr sub e; List.iter (iter_snd (sub.expr sub)) l
    | Pexp_match (e, pel) ->
        sub.expr sub e; sub.cases sub pel
    | Pexp_try (e, pel) -> sub.expr sub e; sub.cases sub pel
    | Pexp_tuple el -> List.iter (sub.expr sub) el
    | Pexp_construct (lid, arg) ->
        iter_loc sub lid; iter_opt (sub.expr sub) arg
    | Pexp_variant (_lab, eo) ->
        iter_opt (sub.expr sub) eo
    | Pexp_record (l, eo) ->
        List.iter (iter_tuple (iter_loc sub) (sub.expr sub)) l;
        iter_opt (sub.expr sub) eo
    | Pexp_field (e, lid) ->
        sub.expr sub e; iter_loc sub lid
    | Pexp_setfield (e1, lid, e2) ->
        sub.expr sub e1; iter_loc sub lid;
        sub.expr sub e2
    | Pexp_array el -> List.iter (sub.expr sub) el
    | Pexp_ifthenelse (e1, e2, e3) ->
        sub.expr sub e1; sub.expr sub e2;
        iter_opt (sub.expr sub) e3
    | Pexp_sequence (e1, e2) ->
        sub.expr sub e1; sub.expr sub e2
    | Pexp_while (e1, e2) ->
        sub.expr sub e1; sub.expr sub e2
    | Pexp_for (p, e1, e2, _d, e3) ->
        sub.pat sub p; sub.expr sub e1; sub.expr sub e2;
        sub.expr sub e3
    | Pexp_coerce (e, t1, t2) ->
        sub.expr sub e; iter_opt (sub.typ sub) t1;
        sub.typ sub t2
    | Pexp_constraint (e, t) ->
        sub.expr sub e; sub.typ sub t
    | Pexp_send (e, _s) -> sub.expr sub e
    | Pexp_new lid -> iter_loc sub lid
    | Pexp_setinstvar (s, e) ->
        iter_loc sub s; sub.expr sub e
    | Pexp_override sel ->
        List.iter (iter_tuple (iter_loc sub) (sub.expr sub)) sel
    | Pexp_letmodule (s, me, e) ->
        iter_loc sub s; sub.module_expr sub me;
        sub.expr sub e
    (* | Pexp_letexception (cd, e) -> *)
    (*     sub.extension_constructor sub cd; *)
    (*     sub.expr sub e *)
    (* no local exception *)
    | Pexp_assert e -> sub.expr sub e
    | Pexp_lazy e -> sub.expr sub e
    | Pexp_poly (e, t) ->
        sub.expr sub e; iter_opt (sub.typ sub) t
    | Pexp_object cls -> sub.class_structure sub cls
    | Pexp_newtype (_s, e) -> sub.expr sub e
    | Pexp_pack me -> sub.module_expr sub me
    | Pexp_open (_ovf, lid, e) ->
        iter_loc sub lid; sub.expr sub e
    | Pexp_extension x -> sub.extension sub x
    (* | Pexp_unreachable -> () *)
end

module P = struct
  (* Patterns *)

  let iter sub {ppat_desc = desc; ppat_loc = loc; ppat_attributes = attrs} =
    sub.location sub loc;
    sub.attributes sub attrs;
    match desc with
    | Ppat_any -> ()
    | Ppat_var s -> iter_loc sub s
    | Ppat_alias (p, s) -> sub.pat sub p; iter_loc sub s
    | Ppat_constant _ -> ()
    | Ppat_interval _ -> ()
    | Ppat_tuple pl -> List.iter (sub.pat sub) pl
    | Ppat_construct (l, p) ->
        iter_loc sub l; iter_opt (sub.pat sub) p
    | Ppat_variant (_l, p) -> iter_opt (sub.pat sub) p
    | Ppat_record (lpl, _cf) ->
        List.iter (iter_tuple (iter_loc sub) (sub.pat sub)) lpl
    | Ppat_array pl -> List.iter (sub.pat sub) pl
    | Ppat_or (p1, p2) -> sub.pat sub p1; sub.pat sub p2
    | Ppat_constraint (p, t) ->
        sub.pat sub p; sub.typ sub t
    | Ppat_type s -> iter_loc sub s
    | Ppat_lazy p -> sub.pat sub p
    | Ppat_unpack s -> iter_loc sub s
    | Ppat_exception p -> sub.pat sub p
    | Ppat_extension x -> sub.extension sub x
    (* | Ppat_open (lid, p) -> *)
    (*     iter_loc sub lid; sub.pat sub p *)

end

module CE = struct
  (* Value expressions for the class language *)

  let iter sub {pcl_loc = loc; pcl_desc = desc; pcl_attributes = attrs} =
    sub.location sub loc;
    sub.attributes sub attrs;
    match desc with
    | Pcl_constr (lid, tys) ->
        iter_loc sub lid; List.iter (sub.typ sub) tys
    | Pcl_structure s ->
        sub.class_structure sub s
    | Pcl_fun (_lab, e, p, ce) ->
        iter_opt (sub.expr sub) e;
        sub.pat sub p;
        sub.class_expr sub ce
    | Pcl_apply (ce, l) ->
        sub.class_expr sub ce;
        List.iter (iter_snd (sub.expr sub)) l
    | Pcl_let (_r, vbs, ce) ->
        List.iter (sub.value_binding sub) vbs;
        sub.class_expr sub ce
    | Pcl_constraint (ce, ct) ->
        sub.class_expr sub ce; sub.class_type sub ct
    | Pcl_extension x -> sub.extension sub x

  let iter_kind sub = function
    | Cfk_concrete (_o, e) -> sub.expr sub e
    | Cfk_virtual t -> sub.typ sub t

  let iter_field sub {pcf_desc = desc; pcf_loc = loc; pcf_attributes = attrs} =
    sub.location sub loc;
    sub.attributes sub attrs;
    match desc with
    | Pcf_inherit (_o, ce, _s) -> sub.class_expr sub ce
    | Pcf_val (s, _m, k) -> iter_loc sub s; iter_kind sub k
    | Pcf_method (s, _p, k) ->
        iter_loc sub s; iter_kind sub k
    | Pcf_constraint (t1, t2) ->
        sub.typ sub t1; sub.typ sub t2
    | Pcf_initializer e -> sub.expr sub e
    | Pcf_attribute x -> sub.attribute sub x
    | Pcf_extension x -> sub.extension sub x

  let iter_structure sub {pcstr_self; pcstr_fields} =
    sub.pat sub pcstr_self;
    List.iter (sub.class_field sub) pcstr_fields

  let class_infos sub f {pci_virt = _; pci_params = pl; pci_name; pci_expr;
                         pci_loc; pci_attributes} =
    List.iter (iter_fst (sub.typ sub)) pl;
    iter_loc sub pci_name;
    f pci_expr;
    sub.location sub pci_loc;
    sub.attributes sub pci_attributes
end

(* Now, a generic AST mapper, to be extended to cover all kinds and
   cases of the OCaml grammar.  The default behavior of the mapper is
   the identity. *)

let default_iterator =
  {
    structure = (fun this l -> List.iter (this.structure_item this) l);
    structure_item = M.iter_structure_item;
    module_expr = M.iter;
    signature = (fun this l -> List.iter (this.signature_item this) l);
    signature_item = MT.iter_signature_item;
    module_type = MT.iter;
    with_constraint = MT.iter_with_constraint;
    class_declaration =
      (fun this -> CE.class_infos this (this.class_expr this));
    class_expr = CE.iter;
    class_field = CE.iter_field;
    class_structure = CE.iter_structure;
    class_type = CT.iter;
    class_type_field = CT.iter_field;
    class_signature = CT.iter_signature;
    class_type_declaration =
      (fun this -> CE.class_infos this (this.class_type this));
    class_description =
      (fun this -> CE.class_infos this (this.class_type this));
    type_declaration = T.iter_type_declaration;
    type_kind = T.iter_type_kind;
    typ = T.iter;
    type_extension = T.iter_type_extension;
    extension_constructor = T.iter_extension_constructor;
    value_description =
      (fun this {pval_name; pval_type; pval_prim = _; pval_loc;
                 pval_attributes} ->
        iter_loc this pval_name;
        this.typ this pval_type;
        this.attributes this pval_attributes;
        this.location this pval_loc
      );

    pat = P.iter;
    expr = E.iter;

    module_declaration =
      (fun this {pmd_name; pmd_type; pmd_attributes; pmd_loc} ->
         iter_loc this pmd_name;
         this.module_type this pmd_type;
         this.attributes this pmd_attributes;
         this.location this pmd_loc
      );

    module_type_declaration =
      (fun this {pmtd_name; pmtd_type; pmtd_attributes; pmtd_loc} ->
         iter_loc this pmtd_name;
         iter_opt (this.module_type this) pmtd_type;
         this.attributes this pmtd_attributes;
         this.location this pmtd_loc
      );

    module_binding =
      (fun this {pmb_name; pmb_expr; pmb_attributes; pmb_loc} ->
         iter_loc this pmb_name; this.module_expr this pmb_expr;
         this.attributes this pmb_attributes;
         this.location this pmb_loc
      );


    open_description =
      (fun this {popen_lid; popen_override = _; popen_attributes; popen_loc} ->
         iter_loc this popen_lid;
         this.location this popen_loc;
         this.attributes this popen_attributes
      );


    include_description =
      (fun this {pincl_mod; pincl_attributes; pincl_loc} ->
         this.module_type this pincl_mod;
         this.location this pincl_loc;
         this.attributes this pincl_attributes
      );

    include_declaration =
      (fun this {pincl_mod; pincl_attributes; pincl_loc} ->
         this.module_expr this pincl_mod;
         this.location this pincl_loc;
         this.attributes this pincl_attributes
      );


    value_binding =
      (fun this {pvb_pat; pvb_expr; pvb_attributes; pvb_loc} ->
         this.pat this pvb_pat;
         this.expr this pvb_expr;
         this.location this pvb_loc;
         this.attributes this pvb_attributes
      );


    constructor_declaration =
      (fun this {pcd_name; pcd_args; pcd_res; pcd_loc; pcd_attributes} ->
         iter_loc this pcd_name;
         T.iter_constructor_arguments this pcd_args;
         iter_opt (this.typ this) pcd_res;
         this.location this pcd_loc;
         this.attributes this pcd_attributes
      );

    label_declaration =
      (fun this {pld_name; pld_type; pld_loc; pld_mutable = _; pld_attributes}->
         iter_loc this pld_name;
         this.typ this pld_type;
         this.location this pld_loc;
         this.attributes this pld_attributes
      );

    cases = (fun this l -> List.iter (this.case this) l);
    case =
      (fun this {pc_lhs; pc_guard; pc_rhs} ->
         this.pat this pc_lhs;
         iter_opt (this.expr this) pc_guard;
         this.expr this pc_rhs
      );

    location = (fun _this _l -> ());

    extension = (fun this (s, e) -> iter_loc this s; this.payload this e);
    attribute = (fun this (s, e) -> iter_loc this s; this.payload this e);
    attributes = (fun this l -> List.iter (this.attribute this) l);
    payload =
      (fun this -> function
         | PStr x -> this.structure this x
         (* | PSig x -> this.signature this x *)
         | PTyp x -> this.typ this x
         | PPat (x, g) -> this.pat this x; iter_opt (this.expr this) g
      );
  }

end
module Bs_warnings : sig 
#1 "bs_warnings.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


type t = 
  | Unsafe_ffi_bool_type
  | Unsafe_poly_variant_type

(* val print_string_warning : Location.t -> string -> unit *)

val prerr_warning : Location.t -> t -> unit

(**It will always warn not relevant to whether {!Js_config.warn_unused_attribute} set or not
   User should check it first. 
   The reason is that we will do a global check first, then start warning later
*)
val warn_unused_attribute : Location.t -> string -> unit

end = struct
#1 "bs_warnings.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)



type t = 
  | Unsafe_ffi_bool_type

  | Unsafe_poly_variant_type
  (* for users write code like this:
     {[ external f : [`a of int ] -> string = ""]}
     Here users forget about `[@bs.string]` or `[@bs.int]`
  *)    



let to_string t =
  match t with
  | Unsafe_ffi_bool_type
    ->   
    "You are passing a OCaml bool type into JS, probabaly you want to pass Js.boolean"
  | Unsafe_poly_variant_type 
    -> 
    "Here a OCaml polymorphic variant type passed into JS, probably you forgot annotations like `[@bs.int]` or `[@bs.string]`  "

let warning_formatter = Format.err_formatter

let print_string_warning loc x = 
  Location.print warning_formatter loc ; 
  Format.pp_print_string warning_formatter "Warning: ";
  Format.pp_print_string warning_formatter x

let prerr_warning loc x =
  if not (!Js_config.no_warn_ffi_type ) then
    print_string_warning loc (to_string x) 

let warn_unused_attribute loc txt =
  print_string_warning loc ("Unused attribute " ^ txt ^ " \n" )

end
module Bs_ast_invariant
= struct
#1 "bs_ast_invariant.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


let is_bs_attribute txt = 
  let len = String.length txt  in
  len >= 2 &&
  (*TODO: check the stringing padding rule, this preciate may not be needed *)
  String.unsafe_get txt 0 = 'b'&& 
  String.unsafe_get txt 1 = 's' &&
  (len = 2 ||
   String.unsafe_get txt 2 = '.'
  )
  
let emit_external_warnings : Bs_ast_iterator .iterator=
  {
    Bs_ast_iterator.default_iterator with
    attribute = (fun _ a ->
        match a with
        | {txt ; loc}, _ ->
          if is_bs_attribute txt  then
            Bs_warnings.warn_unused_attribute loc txt 
      )
  }

end
module Ext_log : sig 
#1 "ext_log.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** A Poor man's logging utility
    
    Example:
    {[ 
    err __LOC__ "xx"
    ]}
 *)



type 'a logging =  ('a, Format.formatter, unit, unit, unit, unit) format6 -> 'a


val err : string -> 'a logging
val ierr : bool -> string -> 'a logging 
val warn : string -> 'a logging
val iwarn : bool -> string -> 'a logging 
val dwarn : string -> 'a logging 
val info : string -> 'a logging
val iinfo : bool -> string -> 'a logging

end = struct
#1 "ext_log.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)










type 'a logging =  ('a, Format.formatter, unit, unit, unit, unit) format6 -> 'a

let err str f  =
  Format.fprintf Format.err_formatter ("%s " ^^ f ^^ "@.") str  

let ierr b str f  =
  if b then 
    Format.fprintf Format.err_formatter ("%s " ^^ f) str  
  else
    Format.ifprintf Format.err_formatter ("%s " ^^ f) str  

let warn str f  =
  Format.fprintf Format.err_formatter ("WARN: %s " ^^ f ^^ "@.") str  



let iwarn b str f  = 
  if b then 
    Format.fprintf Format.err_formatter ("WARN: %s " ^^ f) str  
  else 
    Format.ifprintf Format.err_formatter ("WARN: %s " ^^ f) str 

(* TODO: add {[@.]} later for all *)
let dwarn str f  = 
  if Js_config.is_same_file () then   
    Format.fprintf Format.err_formatter ("WARN: %s " ^^ f ^^ "@.") str  
  else 
    Format.ifprintf Format.err_formatter ("WARN: %s " ^^ f ^^ "@.") str  

let info str f  =
  Format.fprintf Format.err_formatter ("INFO: %s " ^^ f) str  

let iinfo b str f  =
  if b then 
    Format.fprintf Format.err_formatter ("INFO: %s " ^^ f) str  
  else
    Format.fprintf Format.err_formatter ("INFO: %s " ^^ f) str  


end
module String_set : sig 
#1 "string_set.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








include Set.S with type elt = string

end = struct
#1 "string_set.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








include Set.Make(String)

end
module Ext_ident : sig 
#1 "ext_ident.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** A wrapper around [Ident] module in compiler-libs*)

val is_js : Ident.t -> bool

val is_js_object : Ident.t -> bool

(** create identifiers for predefined [js] global variables *)
val create_js : string -> Ident.t

val create : string -> Ident.t

val create_js_module : string -> Ident.t 

val make_js_object : Ident.t -> unit

val reset : unit -> unit

val gen_js :  ?name:string -> unit -> Ident.t

val make_unused : unit -> Ident.t

val is_unused_ident : Ident.t -> bool 

(**
   if name is not converted, the reference should be equal
*)
val convert : bool -> string -> string
val property_no_need_convert : string -> bool 

val undefined : Ident.t 
val is_js_or_global : Ident.t -> bool
val nil : Ident.t

end = struct
#1 "ext_ident.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








let js_flag = 0b1000 (* check with ocaml compiler *)

let js_module_flag = 0b1_0000 (* javascript external modules *)
(* TODO:
    check name conflicts with javascript conventions
    {[
    Ext_ident.convert "^";;
    - : string = "$caret"
    ]}
 *)
let js_object_flag = 0b10_0000 (* javascript object flags *)

let is_js (i : Ident.t) = 
  i.flags land js_flag <> 0 

let is_js_or_global (i : Ident.t) = 
  i.flags land (8 lor 1) <> 0 

let is_js_module (i : Ident.t) =
  i.flags land js_module_flag <> 0 

let is_js_object (i : Ident.t) = 
  i.flags land js_object_flag <> 0 

let make_js_object (i : Ident.t) = 
  i.flags <- i.flags lor js_object_flag 
      
(* It's a js function hard coded by js api, so when printing,
   it should preserve the name 
 *)
let create_js (name : string) : Ident.t  = 
  { name = name; flags = js_flag ; stamp = 0}

let js_module_table = Hashtbl.create 31 

(* This is for a js exeternal module, we can change it when printing
   for example
   {[
   var React$1 = require('react');
   React$1.render(..)
   ]}

   Given a name, if duplicated, they should  have the same id
 *)
let create_js_module (name : string) : Ident.t = 
  let name = 
    String.concat "" @@ List.map (String.capitalize ) @@ 
    Ext_string.split name '-' in
  (* TODO: if we do such transformation, we should avoid 
      collision for example:
      react-dom 
      react--dom
      check collision later
   *)
  match Hashtbl.find js_module_table name  with 
  | exception Not_found -> 
      let v = Ident.create name in
      let ans = { v with flags = js_module_flag} in 
      Hashtbl.add js_module_table name ans;
      ans
  | v -> v 

let create = Ident.create

let gen_js ?(name="$js") () = create name 

let reserved_words = 
  [
    (* keywork *)
    "break";
    "case"; "catch"; "continue";
    "debugger";"default";"delete";"do";
    "else";
    "finally";"for";"function";
    "if"; "then"; "in";"instanceof";
    "new";
    "return";
    "switch";
    "this"; "throw"; "try"; "typeof";
    "var"; "void"; "while"; "with";

    (* reserved in ECMAScript 5 *)
    "class"; "enum"; "export"; "extends"; "import"; "super";

    "implements";"interface";
    "let";
    "package";"private";"protected";"public";
    "static";
    "yield";

    (* other *)
    "null";
    "true";
    "false";
    "NaN";


    "undefined";
    "this";

    (* also reserved in ECMAScript 3 *)
    "abstract"; "boolean"; "byte"; "char"; "const"; "double";
    "final"; "float"; "goto"; "int"; "long"; "native"; "short";
    "synchronized"; 
    (* "throws";  *)
    (* seems to be fine, like nodejs [assert.throws] *)
    "transient"; "volatile";

    (* also reserved in ECMAScript 6 *)
    "await";
   
   "event";
   "location";
   "window";
   "document";
   "eval";
   "navigator";
   (* "self"; *)
   
   "Array";
   "Date";
   "Math";
   "JSON";
   "Object";
   "RegExp";
   "String";
   "Boolean";
   "Number";

   "Map"; (* es6*)
   "Set";

   "Infinity";
   "isFinite";
   
   "ActiveXObject";
   "XMLHttpRequest";
   "XDomainRequest";
   
   "DOMException";
   "Error";
   "SyntaxError";
   "arguments";
   
   "decodeURI";
   "decodeURIComponent";
   "encodeURI";
   "encodeURIComponent";
   "escape";
   "unescape";

   "isNaN";
   "parseFloat";
   "parseInt";
   
   (** reserved for commonjs *)   
   "require";
   "exports";
   "module"
]

let reserved_map = 
  List.fold_left (fun acc x -> String_set.add x acc) String_set.empty 
    reserved_words





(* TODO:
    check name conflicts with javascript conventions
    {[
    Ext_ident.convert "^";;
    - : string = "$caret"
    ]}
 *)
let convert keyword (name : string) = 
   if keyword && String_set.mem name reserved_map then "$$" ^ name 
   else 
     let module E = struct exception Not_normal_letter of int end in
     let len = String.length name  in
     try
       for i  = 0 to len - 1 do 
         match String.unsafe_get name i with 
         | 'a' .. 'z' | 'A' .. 'Z'
         | '0' .. '9' | '_' | '$' -> ()
         | _ -> raise (E.Not_normal_letter i)
       done;
       name
     with E.Not_normal_letter i ->
       String.sub name 0 i ^ 
       (let buffer = Buffer.create len in 
        for j = i to  len - 1 do 
          let c = String.unsafe_get name j in
          match c with 
          | '*' -> Buffer.add_string buffer "$star"
          | '\'' -> Buffer.add_string buffer "$prime"
          | '!' -> Buffer.add_string buffer "$bang"
          | '>' -> Buffer.add_string buffer "$great"
          | '<' -> Buffer.add_string buffer "$less"
          | '=' -> Buffer.add_string buffer "$eq"
          | '+' -> Buffer.add_string buffer "$plus"
          | '-' -> Buffer.add_string buffer "$neg"
          | '@' -> Buffer.add_string buffer "$at"
          | '^' -> Buffer.add_string buffer "$caret"
          | '/' -> Buffer.add_string buffer "$slash"
          | '|' -> Buffer.add_string buffer "$pipe"
          | '.' -> Buffer.add_string buffer "$dot"
          | '%' -> Buffer.add_string buffer "$percent"
          | '~' -> Buffer.add_string buffer "$tilde"
          | 'a'..'z' | 'A'..'Z'| '_'|'$' |'0'..'9'-> Buffer.add_char buffer  c
          | _ -> Buffer.add_string buffer "$unknown"
        done; Buffer.contents buffer)

let property_no_need_convert s = 
  s == convert false s 

(* It is currently made a persistent ident to avoid fresh ids 
    which would result in different signature files
    - other solution: use lazy values
*)
let make_unused () = create "_"

let is_unused_ident i = Ident.name i = "_"

let reset () = 
  begin
    Hashtbl.clear js_module_table
  end

let undefined = create_js "undefined"
let nil = create_js "null"

end
module Ext_list : sig 
#1 "ext_list.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Extension to the standard library [List] module *)
    
(** TODO some function are no efficiently implemented. *) 

val filter_map : ('a -> 'b option) -> 'a list -> 'b list 

val excludes : ('a -> bool) -> 'a list -> bool * 'a list
val exclude_with_fact : ('a -> bool) -> 'a list -> 'a option * 'a list
val exclude_with_fact2 : 
  ('a -> bool) -> ('a -> bool) -> 'a list -> 'a option * 'a option * 'a list
val same_length : 'a list -> 'b list -> bool

val init : int -> (int -> 'a) -> 'a list

val take : int -> 'a list -> 'a list * 'a list
val try_take : int -> 'a list -> 'a list * int * 'a list 

val exclude_tail : 'a list -> 'a * 'a list

val filter_map2 : ('a -> 'b -> 'c option) -> 'a list -> 'b list -> 'c list

val filter_map2i : (int -> 'a -> 'b -> 'c option) -> 'a list -> 'b list -> 'c list

val filter_mapi : (int -> 'a -> 'b option) -> 'a list -> 'b list

val flat_map2 : ('a -> 'b -> 'c list) -> 'a list -> 'b list -> 'c list

val flat_map : ('a -> 'b list) -> 'a list -> 'b list 

(** for the last element the first element will be passed [true] *)

val fold_right2_last : (bool -> 'a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'c

val map_last : (bool -> 'a -> 'b) -> 'a list -> 'b list

val stable_group : ('a -> 'a -> bool) -> 'a list -> 'a list list

val drop : int -> 'a list -> 'a list 

val for_all_ret : ('a -> bool) -> 'a list -> 'a option

val for_all_opt : ('a -> 'b option) -> 'a list -> 'b option
(** [for_all_opt f l] returns [None] if all return [None],  
    otherwise returns the first one. 
 *)

val fold : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b
(** same as [List.fold_left]. 
    Provide an api so that list can be easily swapped by other containers  
 *)

val rev_map_append : ('a -> 'b) -> 'a list -> 'b list -> 'b list

val rev_map_acc : 'a list -> ('b -> 'a) -> 'b list -> 'a list

val rev_iter : ('a -> unit) -> 'a list -> unit

val for_all2_no_exn : ('a -> 'b -> bool) -> 'a list -> 'b list -> bool

val find_opt : ('a -> 'b option) -> 'a list -> 'b option

(** [f] is applied follow the list order *)
val split_map : ('a -> 'b * 'c) -> 'a list -> 'b list * 'c list       


val reduce_from_right : ('a -> 'a -> 'a) -> 'a list -> 'a

(** [fn] is applied from left to right *)
val reduce_from_left : ('a -> 'a -> 'a) -> 'a list -> 'a


type 'a t = 'a list ref

val create_ref_empty : unit -> 'a t

val ref_top : 'a t -> 'a 

val ref_empty : 'a t -> bool

val ref_push : 'a -> 'a t -> unit

val ref_pop : 'a t -> 'a

val rev_except_last : 'a list -> 'a list * 'a

val sort_via_array :
  ('a -> 'a -> int) -> 'a list -> 'a list

val last : 'a list -> 'a

end = struct
#1 "ext_list.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








let rec filter_map (f: 'a -> 'b option) xs = 
  match xs with 
  | [] -> []
  | y :: ys -> 
      begin match f y with 
      | None -> filter_map f ys
      | Some z -> z :: filter_map f ys
      end

let excludes (p : 'a -> bool ) l : bool * 'a list=
  let excluded = ref false in 
  let rec aux accu = function
  | [] -> List.rev accu
  | x :: l -> 
    if p x then 
      begin 
        excluded := true ;
        aux accu l
      end
    else aux (x :: accu) l in
  let v = aux [] l in 
  if !excluded then true, v else false,l

let exclude_with_fact p l =
  let excluded = ref None in 
  let rec aux accu = function
  | [] -> List.rev accu
  | x :: l -> 
    if p x then 
      begin 
        excluded := Some x ;
        aux accu l
      end
    else aux (x :: accu) l in
  let v = aux [] l in 
  !excluded , if !excluded <> None then v else l 


(** Make sure [p2 x] and [p1 x] will not hold at the same time *)
let exclude_with_fact2 p1 p2 l =
  let excluded1 = ref None in 
  let excluded2 = ref None in 
  let rec aux accu = function
  | [] -> List.rev accu
  | x :: l -> 
    if p1 x then 
      begin 
        excluded1 := Some x ;
        aux accu l
      end
    else if p2 x then 
      begin 
        excluded2 := Some x ; 
        aux accu l 
      end
    else aux (x :: accu) l in
  let v = aux [] l in 
  !excluded1, !excluded2 , if !excluded1 <> None && !excluded2 <> None then v else l 



let rec same_length xs ys = 
  match xs, ys with 
  | [], [] -> true
  | _::xs, _::ys -> same_length xs ys 
  | _, _ -> false 

let  filter_mapi (f: int -> 'a -> 'b option) xs = 
  let rec aux i xs = 
    match xs with 
    | [] -> []
    | y :: ys -> 
        begin match f i y with 
        | None -> aux (i + 1) ys
        | Some z -> z :: aux (i + 1) ys
        end in
  aux 0 xs 

let rec filter_map2 (f: 'a -> 'b -> 'c option) xs ys = 
  match xs,ys with 
  | [],[] -> []
  | u::us, v :: vs -> 
      begin match f u v with 
      | None -> filter_map2 f us vs (* idea: rec f us vs instead? *)
      | Some z -> z :: filter_map2 f us vs
      end
  | _ -> invalid_arg "Ext_list.filter_map2"

let filter_map2i (f: int ->  'a -> 'b -> 'c option) xs ys = 
  let rec aux i xs ys = 
  match xs,ys with 
  | [],[] -> []
  | u::us, v :: vs -> 
      begin match f i u v with 
      | None -> aux (i + 1) us vs (* idea: rec f us vs instead? *)
      | Some z -> z :: aux (i + 1) us vs
      end
  | _ -> invalid_arg "Ext_list.filter_map2i" in
  aux 0 xs ys

let rec rev_map_append  f l1 l2 =
  match l1 with
  | [] -> l2
  | a :: l -> rev_map_append f l (f a :: l2)

let flat_map2 f lx ly = 
  let rec aux acc lx ly = 
    match lx, ly with 
    | [], [] 
      -> List.rev acc
    | x::xs, y::ys 
      ->  aux (List.rev_append (f x y) acc) xs ys
    | _, _ -> invalid_arg "Ext_list.flat_map2" in
  aux [] lx ly
        
let flat_map f lx =
  let rec aux acc lx =
    match lx with
    | [] -> List.rev acc
    | y::ys -> aux (List.rev_append ( f y)  acc ) ys in
  aux [] lx

let rec map2_last f l1 l2 =
  match (l1, l2) with
  | ([], []) -> []
  | [u], [v] -> [f true u v ]
  | (a1::l1, a2::l2) -> let r = f false  a1 a2 in r :: map2_last f l1 l2
  | (_, _) -> invalid_arg "List.map2_last"

let rec map_last f l1 =
  match l1 with
  | [] -> []
  | [u]-> [f true u ]
  | a1::l1 -> let r = f false  a1 in r :: map_last f l1


let rec fold_right2_last f l1 l2 accu  = 
  match (l1, l2) with
  | ([], []) -> accu
  | [last1], [last2] -> f true  last1 last2 accu
  | (a1::l1, a2::l2) -> f false a1 a2 (fold_right2_last f l1 l2 accu)
  | (_, _) -> invalid_arg "List.fold_right2"


let init n f = 
  Array.to_list (Array.init n f)

let take n l = 
  let arr = Array.of_list l in 
  let arr_length =  Array.length arr in
  if arr_length  < n then invalid_arg "Ext_list.take"
  else (Array.to_list (Array.sub arr 0 n ), 
        Array.to_list (Array.sub arr n (arr_length - n)))

let try_take n l = 
  let arr = Array.of_list l in 
  let arr_length =  Array.length arr in
  if arr_length  <= n then 
    l,  arr_length, []
  else Array.to_list (Array.sub arr 0 n ), n, (Array.to_list (Array.sub arr n (arr_length - n)))

let exclude_tail (x : 'a list) = 
  let rec aux acc x = 
    match x with 
    | [] -> invalid_arg "Ext_list.exclude_tail"
    | [ x ] ->  x, List.rev acc
    | y0::ys -> aux (y0::acc) ys in
  aux [] x

(* For small list, only need partial equality 
   {[
   group (=) [1;2;3;4;3]
   ;;
   - : int list list = [[3; 3]; [4]; [2]; [1]]
   # group (=) [];;
   - : 'a list list = []
   ]}
 *)
let rec group (cmp : 'a -> 'a -> bool) (lst : 'a list) : 'a list list =
  match lst with 
  | [] -> []
  | x::xs -> 
      aux cmp x (group cmp xs )

and aux cmp (x : 'a)  (xss : 'a list list) : 'a list list = 
  match xss with 
  | [] -> [[x]]
  | y::ys -> 
      if cmp x (List.hd y) (* cannot be null*) then
        (x::y) :: ys 
      else
        y :: aux cmp x ys                                 
  
let stable_group cmp lst =  group cmp lst |> List.rev 

let rec drop n h = 
  if n < 0 then invalid_arg "Ext_list.drop"
  else if n = 0 then h 
  else if h = [] then invalid_arg "Ext_list.drop"
  else 
    drop (n - 1) (List.tl h)

let rec for_all_ret  p = function
  | [] -> None
  | a::l -> 
      if p a 
      then for_all_ret p l
      else Some a 

let rec for_all_opt  p = function
  | [] -> None
  | a::l -> 
      match p a with
      | None -> for_all_opt p l
      | v -> v 

let fold f l init = 
  List.fold_left (fun acc i -> f  i init) init l 

let rev_map_acc  acc f l = 
  let rec rmap_f accu = function
    | [] -> accu
    | a::l -> rmap_f (f a :: accu) l
  in
  rmap_f acc l

let rec rev_iter f xs =
    match xs with    
    | [] -> ()
    | y :: ys -> 
      rev_iter f ys ;
      f y      
      
let rec for_all2_no_exn p l1 l2 = 
  match (l1, l2) with
  | ([], []) -> true
  | (a1::l1, a2::l2) -> p a1 a2 && for_all2_no_exn p l1 l2
  | (_, _) -> false


let rec find_no_exn p = function
  | [] -> None
  | x :: l -> if p x then Some x else find_no_exn p l


let rec find_opt p = function
  | [] -> None
  | x :: l -> 
    match  p x with 
    | Some _ as v  ->  v
    | None -> find_opt p l


let split_map 
    ( f : 'a -> ('b * 'c)) (xs : 'a list ) : 'b list  * 'c list = 
  let rec aux bs cs xs =
    match xs with 
    | [] -> List.rev bs, List.rev cs 
    | u::us -> 
      let b,c =  f u in aux (b::bs) (c ::cs) us in 

  aux [] [] xs 


(*
   {[
     reduce_from_right (-) [1;2;3];;
     - : int = 2
               # reduce_from_right (-) [1;2;3; 4];;
     - : int = -2
                # reduce_from_right (-) [1];;
     - : int = 1
               # reduce_from_right (-) [1;2;3; 4; 5];;
     - : int = 3
   ]} 
*)
let reduce_from_right fn lst = 
  begin match List.rev lst with
    | last :: rest -> 
      List.fold_left  (fun x y -> fn y x) last rest 
    | _ -> invalid_arg "Ext_list.reduce" 
  end
let reduce_from_left fn lst = 
  match lst with 
  | first :: rest ->  List.fold_left fn first rest 
  | _ -> invalid_arg "Ext_list.reduce_from_left"


type 'a t = 'a list ref

let create_ref_empty () = ref []

let ref_top x = 
  match !x with 
  | y::_ -> y 
  | _ -> invalid_arg "Ext_list.ref_top"

let ref_empty x = 
  match !x with [] -> true | _ -> false 

let ref_push x refs = 
  refs := x :: !refs

let ref_pop refs = 
  match !refs with 
  | [] -> invalid_arg "Ext_list.ref_pop"
  | x::rest -> 
    refs := rest ; 
    x     

let rev_except_last xs =
  let rec aux acc xs =
    match xs with
    | [ ] -> invalid_arg "Ext_list.rev_except_last"
    | [ x ] -> acc ,x
    | x :: xs -> aux (x::acc) xs in
  aux [] xs   

let sort_via_array cmp lst =
  let arr = Array.of_list lst  in
  Array.sort cmp arr;
  Array.to_list arr

let rec last xs =
  match xs with 
  | [x] -> x 
  | _ :: tl -> last tl 
  | [] -> invalid_arg "Ext_list.last"

end
module Ident_map : sig 
#1 "ident_map.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

include Map.S with type key = Ident.t 

val of_list  : (key * 'a) list -> 'a t

val keys : 'a t -> key list

val add_if_not_exist : key -> 'a -> 'a t -> 'a t

val merge_disjoint : 'a t -> 'a t -> 'a t

end = struct
#1 "ident_map.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Map with key specialized as [Ident] type, enhanced with some utilities *)

include Map.Make(struct 
  type t = Ident.t 

  let compare (x : t) (y : t) =
    (* Can not overflow *)
    let u = x.stamp - y.stamp in
    if u = 0 then 
      let u = String.compare x.name y.name in 
      if u = 0 then 
        x.flags - y.flags 
      else  u 
    else u 
end)

let of_list lst = 
  List.fold_left (fun acc (k,v) -> add k v acc) empty lst

let keys map = fold (fun k _ acc -> k::acc  ) map []

(* TODO: have this in stdlib/map to save some time *)
let add_if_not_exist key v m = 
  if mem key m then m else add key v m

let merge_disjoint m1 m2 = 
  merge 
    (fun k x0 y0 -> 
       match x0, y0 with 
         None, None -> None
       | None, Some v | Some v, None -> Some v
       | _, _ -> invalid_arg "merge_disjoint: maps are not disjoint")
    m1 m2

end
module Ext_format : sig 
#1 "ext_format.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Simplified wrapper module for the standard library [Format] module. 
  *) 

type t = private Format.formatter

val string : t -> string -> unit

val break : t -> unit

val break1 : t -> unit

val space :  t -> unit

val group : t -> int -> (unit -> 'a) -> 'a
(** [group] will record current indentation 
    and indent futher
 *)

val vgroup : t -> int -> (unit -> 'a) -> 'a

val paren : t -> (unit -> 'a) -> 'a

val paren_group : t -> int -> (unit -> 'a) -> 'a

val brace_group : t -> int -> (unit -> 'a) -> 'a

val brace_vgroup : t -> int -> (unit -> 'a) -> 'a

val bracket_group : t -> int -> (unit -> 'a) -> 'a

val newline : t -> unit

val to_out_channel : out_channel -> t

val flush : t -> unit -> unit

val pp_print_queue :
  ?pp_sep:(Format.formatter -> unit -> unit) ->
  (Format.formatter -> 'a -> unit) -> Format.formatter -> 'a Queue.t -> unit

end = struct
#1 "ext_format.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








open Format

type t = formatter

let string = pp_print_string

let break = fun fmt -> pp_print_break fmt 0 0

let break1 =
  fun fmt -> pp_print_break fmt 0 1 

let space  fmt  = 
  pp_print_break fmt 1 0

let vgroup fmt indent u = 
  pp_open_vbox fmt indent; 
  let v = u () in
  pp_close_box fmt ();
  v

let group fmt indent u = 
  pp_open_hovbox fmt indent; 
  let v = u () in
  pp_close_box fmt ();
  v
  
let paren fmt u = 
  string fmt "(";
  let v = u () in
  string fmt ")";
  v

let brace fmt u = 
  string fmt "{";
  (* break1 fmt ; *)
  let v = u () in
  string fmt "}";
  v 

let bracket fmt u = 
  string fmt "[";
  let v = u () in
  string fmt "]";
  v 

let paren_group st n action = 
  group st n (fun _ -> paren st action)

let brace_group st n action = 
  group st n (fun _ -> brace st action )

let brace_vgroup st n action = 
  vgroup st n (fun _ -> 
    string st "{";
    pp_print_break st 0 2;
    let v = vgroup st 0 action in
    pp_print_break st 0 0;
    string st "}";
    v
              )
let bracket_group st n action = 
  group st n (fun _ -> bracket st action)

let newline fmt = pp_print_newline fmt ()

let to_out_channel = formatter_of_out_channel

(* let non_breaking_space  fmt = string fmt " " *)
(* let set_needed_space_function _ _ = () *)
let flush = pp_print_flush

let list = pp_print_list

let rec pp_print_queue ?(pp_sep = pp_print_cut) pp_v ppf q =
  Queue.iter (fun q -> pp_v ppf q ;  pp_sep ppf ()) q 

end
module Ident_set : sig 
#1 "ident_set.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Set with key specialized as [Ident.t] type
 *)

(** Original set module enhanced with some utilities, 
    note that it's incompatible with [Lambda.IdentSet] 
 *)

include Set.S with type elt = Ident.t

val print : Ext_format.t -> t -> unit

end = struct
#1 "ident_set.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)









(* TODO: 
    when we do the union, it would be nice that 
    we know which [delta] is there
 *)
include Set.Make(struct 
  type t = Ident.t 
  let compare  = Pervasives.compare (* TODO: fix me *)
end)

let print ppf v =
  Ext_format.(brace_vgroup ppf 0 (fun _ ->
  iter (fun v -> 
    string ppf  (Printf.sprintf "%s/%d" v.Ident.name v.stamp) ; Ext_format.space ppf  ) v ))

end
module Js_call_info : sig 
#1 "js_call_info.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Type for collecting call site information, used in JS IR *) 

type arity = 
  | Full 
  | NA 


type call_info = 
  | Call_ml (* called by plain ocaml expression *)
  | Call_builtin_runtime (* built-in externals *)
  | Call_na 
  (* either from [@@bs.val] or not available, 
     such calls does not follow such rules
     {[ fun x y -> f x y === f ]} when [f] is an atom     
  *) 


type t = { 
  call_info : call_info;
  arity : arity;

}

val dummy : t
val builtin_runtime_call : t

val ml_full_call : t 

end = struct
#1 "js_call_info.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








type arity = 
  | Full 
  | NA 

type call_info = 
  | Call_ml (* called by plain ocaml expression *)
  | Call_builtin_runtime (* built-in externals *)
  | Call_na 
  (* either from [@@bs.val] or not available, 
     such calls does not follow such rules
     {[ fun x y -> (f x y) === f ]} when [f] is an atom     

  *) 

type t = { 
  call_info : call_info;
  arity : arity
}

let dummy = { arity = NA; call_info = Call_na }

let builtin_runtime_call = {arity = Full; call_info = Call_builtin_runtime}

let ml_full_call = {arity = Full; call_info = Call_ml}

end
module Js_closure : sig 
#1 "js_closure.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Define a type used in JS IR to help convert lexical scope to JS [var] 
    based scope convention
 *)

type t = {
  mutable outer_loop_mutable_values :  Ident_set.t 
}

val empty : unit -> t

val get_lexical_scope : t -> Ident_set.t

val set_lexical_scope : t -> Ident_set.t -> unit

end = struct
#1 "js_closure.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








type t = {
  mutable outer_loop_mutable_values :  Ident_set.t ;
}

let empty () = {
  outer_loop_mutable_values  = Ident_set.empty
}

let set_lexical_scope t v = t.outer_loop_mutable_values <- v 

let get_lexical_scope t = t.outer_loop_mutable_values 

end
module Js_fun_env : sig 
#1 "js_fun_env.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Define type t used in JS IR to collect some meta data for a function, like its closures, etc 
  *)

type t 

val empty :  ?immutable_mask:bool array  -> int -> t

val is_tailcalled : t -> bool

val is_empty : t -> bool 

val set_unbounded :  t -> Ident_set.t -> unit



val set_lexical_scope : t -> Ident_set.t -> unit

val get_lexical_scope : t -> Ident_set.t

val to_string : t -> string

val mark_unused : t -> int -> unit 

val get_unused : t -> int -> bool

val get_mutable_params : Ident.t list -> t -> Ident.t list

val get_unbounded : t -> Ident_set.t

val get_length : t -> int

end = struct
#1 "js_fun_env.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(* Make it mutable so that we can do
   in-place change without constructing a new one
  -- however, it's a design choice -- to be reviewed later
*)

type immutable_mask = 
  | All_immutable_and_no_tail_call 
     (** iff not tailcalled 
         if tailcalled, in theory, it does not need change params, 
         for example
         {[
         let rec f  (n : int ref) = 
            if !n > 0 then decr n; print_endline "hi"
            else  f n
         ]}
         in this case, we still create [Immutable_mask], 
         since the inline behavior is slightly different
      *)
  | Immutable_mask of bool array

type t = { 
  mutable unbounded : Ident_set.t;
  mutable bound_loop_mutable_values : Ident_set.t; 
  used_mask : bool array;
  immutable_mask : immutable_mask; 
}
(** Invariant: unused param has to be immutable *)

let empty ?immutable_mask n = { 
  unbounded =  Ident_set.empty ;
  used_mask = Array.make n false;
  immutable_mask = 
    (match immutable_mask with 
     | Some x -> Immutable_mask x 
     | None -> All_immutable_and_no_tail_call
    );
  bound_loop_mutable_values =Ident_set.empty;
}

let is_tailcalled x = x.immutable_mask <> All_immutable_and_no_tail_call

let mark_unused  t i = 
  t.used_mask.(i) <- true

let get_unused t i = 
  t.used_mask.(i)

let get_length t = Array.length t.used_mask

let to_string env =  
  String.concat "," 
    (List.map (fun (id : Ident.t) -> Printf.sprintf "%s/%d" id.name id.stamp)
       (Ident_set.elements  env.unbounded ))

let get_mutable_params (params : Ident.t list) (x : t ) = 
  match x.immutable_mask with 
  | All_immutable_and_no_tail_call -> []
  | Immutable_mask xs -> 
      Ext_list.filter_mapi 
        (fun i p -> if not xs.(i) then Some p else None)  params


let get_unbounded t = t.unbounded

let set_unbounded env v = 
  (* Ext_log.err "%s -- set @." (to_string env); *)
  (* if Ident_set.is_empty env.bound then *)
  env.unbounded <- v 
 (* else assert false *)

let set_lexical_scope env bound_loop_mutable_values = 
  env.bound_loop_mutable_values <- bound_loop_mutable_values

let get_lexical_scope env =  
  env.bound_loop_mutable_values

(* TODO:  can be refined if it 
    only enclose toplevel variables 
 *)
let is_empty t = Ident_set.is_empty t.unbounded

end
module Js_op
= struct
#1 "js_op.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)










(** Define some basic types used in JS IR *)

type binop =
  | Eq  
  (* acutally assignment ..
     TODO: move it into statement, so that all expressions 
     are side efffect free (except function calls)
   *)

  | Or
  | And
  | EqEqEq
  | NotEqEq
  | InstanceOf

  | Lt
  | Le
  | Gt
  | Ge

  | Bor
  | Bxor
  | Band
  | Lsl
  | Lsr
  | Asr

  | Plus
  | Minus
  | Mul
  | Div
  | Mod

(**
note that we don't need raise [Div_by_zero] in BuckleScript

{[
let add x y = x + y  (* | 0 *)
let minus x y = x - y (* | 0 *)
let mul x y = x * y   (* caml_mul | Math.imul *)
let div x y = x / y (* caml_div (x/y|0)*)
let imod x y = x mod y  (* caml_mod (x%y) (zero_divide)*)

let bor x y = x lor y   (* x  | y *)
let bxor x y = x lxor y (* x ^ y *)
let band x y = x land y (* x & y *)
let ilnot  y  = lnot y (* let lnot x = x lxor (-1) *)
let ilsl x y = x lsl y (* x << y*)
let ilsr x y = x lsr y  (* x >>> y | 0 *)
let iasr  x y = x asr y (* x >> y *)
]}


Note that js treat unsigned shift 0 bits in a special way
   Unsigned shifts convert their left-hand side to Uint32, 
   signed shifts convert it to Int32.
   Shifting by 0 digits returns the converted value.
   {[
    function ToUint32(x) {
        return x >>> 0;
    }
    function ToInt32(x) {
        return x >> 0;
    }
   ]}
   So in Js, [-1 >>>0] will be the largest Uint32, while [-1>>0] will remain [-1]
   and [-1 >>> 0 >> 0 ] will be [-1]
*)
type int_op = 
    
  | Bor
  | Bxor
  | Band
  | Lsl
  | Lsr
  | Asr

  | Plus
      (* for [+], given two numbers 
         x + y | 0
       *)
  | Minus
      (* x - y | 0 *)
  | Mul
      (* *)
  | Div
      (* x / y | 0 *)
  | Mod
      (* x  % y *)

(* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Bitwise_operators
    {[
    ~
    ]}
    ~0xff -> -256
    design; make sure each operation type is consistent
 *)
type level = 
  | Log 
  | Info
  | Warn
  | Error

type kind = 
  | Ml
  | Runtime 
  | External of string

type property = Lambda.let_kind = 
  | Strict
  | Alias
  | StrictOpt 
  | Variable


type property_name = (* private *)
  (* TODO: FIXME [caml_uninitialized_obj] seems to be a bug*)
  | Key of string
  | Int_key of int 
  | Tag 
  | Length

type 'a access = 
  | Getter
  | Setter
type jsint = Int32.t

type int_or_char = 
    { i : jsint; 
      (* we can not use [int] on 32 bit platform, if we dont use 
          [Int32.t], we need a configuration step          
      *)
      c : char option
    }

 (* literal char *)
type float_lit = { f :  string }
type number = 
  | Float of float_lit 
  | Int of int_or_char
  | Uint of int32
  | Nint of nativeint
  (* becareful when constant folding +/-, 
     since we treat it as js nativeint, bitwise operators:
     https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators
     The operands of all bitwise operators are converted to signed 32-bit integers in two's complement format.'
  *)      

type mutable_flag = 
  | Mutable
  | Immutable
  | NA

(* 
    {[
    let rec x = 1 :: y 
    and y = 1 :: x
    ]}
 *)
type recursive_info = 
  | SingleRecursive 
  | NonRecursie
  | NA

type used_stats = 
  | Dead_pure 
        (* only [Dead] should be taken serious, 
            other status can be converted during
            inlining
            -- all exported symbols can not be dead
            -- once a symbole is called Dead_pure, 
            it can not be alive anymore, we should avoid iterating it
            
          *)
  | Dead_non_pure 
      (* we still need iterating it, 
         just its bindings does not make sense any more *)
  | Exported (* Once it's exported, shall we change its status anymore? *)
      (* In general, we should count in one pass, and eliminate code in another 
         pass, you can not do it in a single pass, however, some simple 
         dead code can be detected in a single pass
       *)
  | Once_pure (* used only once so that, if we do the inlining, it will be [Dead] *)
  | Used (**)
  | Scanning_pure
  | Scanning_non_pure
  | NA


type ident_info = {
    (* mutable recursive_info : recursive_info; *)
    mutable used_stats : used_stats;
  }

type exports = Ident.t list 

type module_id = { id : Ident.t; kind  : kind}

type required_modules = module_id list


type tag_info = Lambda.tag_info = 
  | Blk_constructor of string * int
  | Blk_tuple
  | Blk_array
  | Blk_variant of string 
  | Blk_record of string array
  | Blk_module of string list option
  | Blk_na

type length_object = 
  | Array 
  | String
  | Bytes
  | Function
  | Caml_block

type code_info = 
  | Exp (* of int option *)
  | Stmt
(** TODO: define constant - for better constant folding  *)
(* type constant =  *)
(*   | Const_int of int *)
(*   | Const_ *)

end
module J
= struct
#1 "j.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Javascript IR
  
    It's a subset of Javascript AST specialized for OCaml lambda backend

    Note it's not exactly the same as Javascript, the AST itself follows lexical
    convention and [Block] is just a sequence of statements, which means it does 
    not introduce new scope
*)

type label = string

and binop = Js_op.binop

and int_op = Js_op.int_op
 
and kind = Js_op.kind

and property = Js_op.property

and number = Js_op.number 

and mutable_flag = Js_op.mutable_flag 

and ident_info = Js_op.ident_info

and exports = Js_op.exports

and tag_info = Js_op.tag_info 
 
and required_modules = Js_op.required_modules

and code_info = Js_op.code_info 
(** object literal, if key is ident, in this case, it might be renamed by 
    Google Closure  optimizer,
    currently we always use quote
 *)
and property_name =  Js_op.property_name
and jsint = Js_op.jsint
and ident = Ident.t 

and vident = 
  | Id of ident
  | Qualified of ident * kind * string option
    (* Since camldot is only available for toplevel module accessors,
       we don't need print  `A.length$2`
       just print `A.length` - it's guarateed to be unique
       
       when the third one is None, it means the whole module 

       TODO: 
       invariant, when [kind] is [Runtime], then we can ignore [ident], 
       since all [runtime] functions are unique, when do the 
       pattern match we can ignore the first one for simplicity
       for example       
       {[
         Qualified (_, Runtime, Some "caml_int_compare")         
       ]}       
     *)

and exception_ident = ident 

and for_ident = ident 

and for_direction = Asttypes.direction_flag

and property_map = 
    (property_name * expression) list
and length_object = Js_op.length_object
and expression_desc =
  | Math of string * expression list
  | Length of expression * length_object
  | Char_of_int of expression
  | Char_to_int of expression 
  | Array_of_size of expression 
    (* used in [js_create_array] primitive, note having
       uninitilized array is not as bad as in ocaml, 
       since GC does not rely on it
     *)
  | Array_copy of expression (* shallow copy, like [x.slice] *)
  | Array_append of expression * expression (* For [caml_array_append]*)
  (* | Tag_ml_obj of expression *)
  | String_append of expression * expression 

  | Int_of_boolean of expression 
  | Anything_to_number of expression
  | Bool of bool (* js true/false*)
  (* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence 
     [typeof] is an operator     
  *)
  | Typeof of expression
  | Not of expression (* !v *)
  | String_of_small_int_array of expression 
    (* String.fromCharCode.apply(null, args) *)
    (* Convert JS boolean into OCaml boolean 
       like [+true], note this ast talks using js
       terminnology unless explicity stated                       
     *)
  | Json_stringify of expression 
  (* TODO: in the future, it might make sense to group primitivie by type,
     which makes optimizations easier
     {[ JSON.stringify(value, replacer[, space]) ]}
  *)
  | Anything_to_string of expression
  (* for debugging utitlites, 
     TODO:  [Dump] is not necessary with this primitive 
     Note that the semantics is slightly different from [JSON.stringify]     
     {[
       JSON.stringify("x")       
     ]}
     {[
       ""x""       
     ]}     
     {[
       JSON.stringify(undefined)       
     ]}     
     {[
       undefined       
     ]}
     {[ '' + undefined
     ]}     
     {[ 'undefined'
     ]}     
  *)      
  | Dump of Js_op.level * expression list
  (* TODO: 
     add 
     {[ Assert of bool * expression ]}     
  *)              
    (* to support 
       val log1 : 'a -> unit
       val log2 : 'a -> 'b -> unit 
       val log3 : 'a -> 'b -> 'c -> unit 
     *)

  (* TODO: Add some primitives so that [js inliner] can do a better job *)  
  | Seq of expression * expression
  | Cond of expression * expression * expression
  | Bin of binop * expression * expression

  (* [int_op] will guarantee return [int32] bits 
     https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators  *)
  (* | Int32_bin of int_op * expression * expression *)
  | FlatCall of expression * expression 
    (* f.apply(null,args) -- Fully applied guaranteed 
       TODO: once we know args's shape --
       if it's know at compile time, we can turn it into
       f(args[0], args[1], ... )
     *)
  | Bind of expression * expression
  (* {[ Bind (a,b) ]}
     is literally
     {[ a.bind(b) ]}
  *)
  | Call of expression * expression list * Js_call_info.t
    (* Analysze over J expression is hard since, 
        some primitive  call is translated 
        into a plain call, it's better to keep them
    *) 
  | String_access of expression * expression 
  | Access of expression * expression 
    (* Invariant: 
       The second argument has to be type of [int],
       This can be constructed either in a static way [E.index] or a dynamic way 
       [E.access]
     *)
  | Dot of expression * string * bool
    (* The third argument bool indicates whether we should 
       print it as 
       a["idd"] -- false
       or 
       a.idd  -- true
       There are several kinds of properties
       1. OCaml module dot (need to be escaped or not)
          All exported declarations have to be OCaml identifiers
       2. Javascript dot (need to be preserved/or using quote)
     *)
  | New of expression * expression list option (* TODO: option remove *)
  | Var of vident
  | Fun of bool * ident list  * block * Js_fun_env.t
  (* The first parameter by default is false, 
     it will be true when it's a method
  *)
  | Str of bool * string 
    (* A string is UTF-8 encoded, the string may contain
       escape sequences.
       The first argument is used to mark it is non-pure, please
       don't optimize it, since it does have side effec, 
       examples like "use asm;" and our compiler may generate "error;..." 
       which is better to leave it alone
     *)
  | Raw_js_code of string * code_info
  (* literally raw JS code 
  *)
  | Array of expression list * mutable_flag
  | Caml_block of expression list * mutable_flag * expression * tag_info 
  (* The third argument is [tag] , forth is [tag_info] *)
  | Caml_uninitialized_obj of expression * expression
  (* [tag] and [size] tailed  for [Obj.new_block] *)

  (* For setter, it still return the value of expression, 
     we can not use 
     {[
       type 'a access = Get | Set of 'a
     ]}
     in another module, since it will break our code generator
     [Caml_block_tag] can return [undefined], 
     you have to use [E.tag] in a safe way     
  *)
  | Caml_block_tag of expression
  | Caml_block_set_tag of expression * expression
  | Caml_block_set_length of expression * expression
  (* It will just fetch tag, to make it safe, when creating it, 
     we need apply "|0", we don't do it in the 
     last step since "|0" can potentially be optimized
  *)      
  | Number of number
  | Object of property_map

and for_ident_expression = expression (* pure*)

and finish_ident_expression = expression (* pure *)
(* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block
   block can be nested, specified in ES3 
 *)

(* Delay some units like [primitive] into JS layer ,
   benefit: better cross module inlining, and smaller IR size?
 *)

(* 
  [closure] captured loop mutable values in the outer loop

  check if it contains loop mutable values, happens in nested loop
  when closured, it's no longer loop mutable value. 
  which means the outer loop mutable value can not peek into the inner loop
  {[
  var i = f ();
  for(var finish = 32; i < finish; ++i){
  }
  ]}
  when [for_ident_expression] is [None], [var i] has to 
  be initialized outside, so 

  {[
  var i = f ()
  (function (xxx){
  for(var finish = 32; i < finish; ++i)
  }(..i))
  ]}
  This happens rare it's okay

  this is because [i] has to be initialized outside, if [j] 
  contains a block side effect
  TODO: create such example
*)

(* Since in OCaml, 
   
  [for i = 0 to k end do done ]
  k is only evaluated once , to encode this invariant in JS IR,
  make sure [ident] is defined in the first b

  TODO: currently we guarantee that [bound] was only 
  excecuted once, should encode this in AST level
*)

(* Can be simplified to keep the semantics of OCaml
   For (var i, e, ...){
     let  j = ... 
   }

   if [i] or [j] is captured inside closure

   for (var i , e, ...){
     (function (){
     })(i)
   }
*)

(* Single return is good for ininling..
   However, when you do tail-call optmization
   you loose the expression oriented semantics
   Block is useful for implementing goto
   {[
   xx:{
   break xx;
   }
   ]}
*)


and statement_desc =
  | Block of block
  | Variable of variable_declaration
        (* Function declaration and Variable declaration  *)
  | Exp of expression
  | If of expression * block * block option
  | While of label option *  expression * block 
        * Js_closure.t (* check if it contains loop mutable values, happens in nested loop *)
  | ForRange of for_ident_expression option * finish_ident_expression * 
        for_ident  *  for_direction * block
        * Js_closure.t  
  | Continue of label 
  | Break (* only used when inline a fucntion *)
  | Return of return_expression   (* Here we need track back a bit ?, move Return to Function ...
                              Then we can only have one Return, which is not good *)
  | Int_switch of expression * int case_clause list * block option 
  | String_switch of expression * string case_clause list * block option 
  | Throw of expression
  | Try of block * (exception_ident * block) option * block option
  | Debugger
and return_expression = {
 (* since in ocaml, it's expression oriented langauge, [return] in
    general has no jumps, it only happens when we do 
    tailcall conversion, in that case there is a jump.
    However, currently  a single [break] is good to cover
    our compilation strategy 

    Attention: we should not insert [break] arbitrarily, otherwise 
    it would break the semantics
    A more robust signature would be 
    {[ goto : label option ; ]}
  *)
  return_value : expression
}   

and expression = {
  expression_desc : expression_desc; 
  comment : string option;
} 

and statement = { 
  statement_desc :  statement_desc; 
  comment : string option;
}

and variable_declaration = { 
  ident : ident ;
  value : expression  option;
  property : property;
  ident_info : ident_info;
}

and 'a case_clause = { 
  case : 'a ; 
  body : block * bool ;  (* true means break *)
}

(* TODO: For efficency: block should not be a list, it should be able to 
   be concatenated in both ways 
 *)
and block =  statement list

and program = {
  name :  string;

  block : block ;
  exports : exports ;
  export_set : Ident_set.t ;

}
and deps_program = 
  {
    program : program ; 
    modules : required_modules ;
    side_effect : string option (* None: no, Some reason  *)
  }

end
module Ocaml_stdlib_slots
= struct
#1 "ocaml_stdlib_slots.ml"

(* Generated by scripts/gen_slots.ml, should be updated everytime when we upgrade the compiler *)
let pervasives = [| "invalid_arg";"failwith";"Exit";"min";"max";"abs";"max_int";"min_int";"lnot";"infinity";"neg_infinity";"nan";"max_float";"min_float";"epsilon_float";"^";"char_of_int";"string_of_bool";"bool_of_string";"string_of_int";"string_of_float";"@";"stdin";"stdout";"stderr";"print_char";"print_string";"print_bytes";"print_int";"print_float";"print_endline";"print_newline";"prerr_char";"prerr_string";"prerr_bytes";"prerr_int";"prerr_float";"prerr_endline";"prerr_newline";"read_line";"read_int";"read_float";"open_out";"open_out_bin";"open_out_gen";"flush";"flush_all";"output_char";"output_string";"output_bytes";"output";"output_substring";"output_byte";"output_binary_int";"output_value";"seek_out";"pos_out";"out_channel_length";"close_out";"close_out_noerr";"set_binary_mode_out";"open_in";"open_in_bin";"open_in_gen";"input_char";"input_line";"input";"really_input";"really_input_string";"input_byte";"input_binary_int";"input_value";"seek_in";"pos_in";"in_channel_length";"close_in";"close_in_noerr";"set_binary_mode_in";"LargeFile";"string_of_format";"^^";"exit";"at_exit";"valid_float_lexem";"unsafe_really_input";"do_at_exit" |]
let camlinternalOO = [| "public_method_label";"new_method";"new_variable";"new_methods_variables";"get_variable";"get_variables";"get_method_label";"get_method_labels";"get_method";"set_method";"set_methods";"narrow";"widen";"add_initializer";"dummy_table";"create_table";"init_class";"inherits";"make_class";"make_class_store";"dummy_class";"copy";"create_object";"create_object_opt";"run_initializers";"run_initializers_opt";"create_object_and_run_initializers";"lookup_tables";"params";"stats" |]
let camlinternalMod = [| "init_mod";"update_mod" |]
let string = [| "make";"init";"copy";"sub";"fill";"blit";"concat";"iter";"iteri";"map";"mapi";"trim";"escaped";"index";"rindex";"index_from";"rindex_from";"contains";"contains_from";"rcontains_from";"uppercase";"lowercase";"capitalize";"uncapitalize";"compare" |]
let array = [| "init";"make_matrix";"create_matrix";"append";"concat";"sub";"copy";"fill";"blit";"to_list";"of_list";"iter";"map";"iteri";"mapi";"fold_left";"fold_right";"sort";"stable_sort";"fast_sort" |]
let list = [| "length";"hd";"tl";"nth";"rev";"append";"rev_append";"concat";"flatten";"iter";"iteri";"map";"mapi";"rev_map";"fold_left";"fold_right";"iter2";"map2";"rev_map2";"fold_left2";"fold_right2";"for_all";"exists";"for_all2";"exists2";"mem";"memq";"find";"filter";"find_all";"partition";"assoc";"assq";"mem_assoc";"mem_assq";"remove_assoc";"remove_assq";"split";"combine";"sort";"stable_sort";"fast_sort";"sort_uniq";"merge" |]
    

end
module Lam : sig 
#1 "lam.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type array_kind = Lambda.array_kind
type boxed_integer = Lambda.boxed_integer
type comparison = Lambda.comparison 
type bigarray_kind = Lambda.bigarray_kind
type bigarray_layout = Lambda.bigarray_layout
type compile_time_constant = Lambda.compile_time_constant

type tag_info = Lambda.tag_info
type mutable_flag = Asttypes.mutable_flag
type field_dbg_info = Lambda.field_dbg_info 
type set_field_dbg_info = Lambda.set_field_dbg_info

type ident = Ident.t

type function_arities = 
  | Determin of bool * (int * Ident.t list option) list  * bool
  (** when the first argument is true, it is for sure 

      approximation sound but not complete 
      the last one means it can take any params later, 
      for an exception: it is (Determin (true,[], true))
   *)
  | NA 

type primitive = 
  | Pbytes_to_string
  | Pbytes_of_string
  | Pgetglobal of ident
  | Psetglobal of ident
  | Pglobal_exception of ident             
  | Pmakeblock of int * Lambda.tag_info * Asttypes.mutable_flag
  | Pfield of int * Lambda.field_dbg_info
  | Psetfield of int * bool * Lambda.set_field_dbg_info
  | Pfloatfield of int * Lambda.field_dbg_info
  | Psetfloatfield of int * Lambda.set_field_dbg_info
  | Pduprecord of Types.record_representation * int
  | Plazyforce
  | Pccall of  Primitive.description
  | Praise 
  | Psequand | Psequor | Pnot
  | Pnegint | Paddint | Psubint | Pmulint | Pdivint | Pmodint
  | Pandint | Porint | Pxorint
  | Plslint | Plsrint | Pasrint
  | Pintcomp of Lambda.comparison
  | Poffsetint of int
  | Poffsetref of int
  | Pintoffloat | Pfloatofint
  | Pnegfloat | Pabsfloat
  | Paddfloat | Psubfloat | Pmulfloat | Pdivfloat
  | Pfloatcomp of Lambda.comparison
  | Pstringlength 
  | Pstringrefu 
  | Pstringrefs
  | Pstringadd    
  | Pbyteslength
  | Pbytesrefu
  | Pbytessetu 
  | Pbytesrefs
  | Pbytessets
  (* Array operations *)
  | Pmakearray of array_kind
  | Parraylength of array_kind
  | Parrayrefu of array_kind
  | Parraysetu of array_kind
  | Parrayrefs of array_kind
  | Parraysets of array_kind
  (* Test if the argument is a block or an immediate integer *)
  | Pisint
  (* Test if the (integer) argument is outside an interval *)
  | Pisout
  (* Bitvect operations *)
  | Pbittest
  (* Operations on boxed integers (Nativeint.t, Int32.t, Int64.t) *)
  | Pbintofint of boxed_integer
  | Pintofbint of boxed_integer
  | Pcvtbint of boxed_integer (*source*) * boxed_integer (*destination*)
  | Pnegbint of boxed_integer
  | Paddbint of boxed_integer
  | Psubbint of boxed_integer
  | Pmulbint of boxed_integer
  | Pdivbint of boxed_integer
  | Pmodbint of boxed_integer
  | Pandbint of boxed_integer
  | Porbint of boxed_integer
  | Pxorbint of boxed_integer
  | Plslbint of boxed_integer
  | Plsrbint of boxed_integer
  | Pasrbint of boxed_integer
  | Pbintcomp of boxed_integer * comparison
  (* Operations on big arrays: (unsafe, #dimensions, kind, layout) *)
  | Pbigarrayref of bool * int * bigarray_kind * bigarray_layout
  | Pbigarrayset of bool * int * bigarray_kind * bigarray_layout
  (* size of the nth dimension of a big array *)
  | Pbigarraydim of int
  (* load/set 16,32,64 bits from a string: (unsafe)*)
  | Pstring_load_16 of bool
  | Pstring_load_32 of bool
  | Pstring_load_64 of bool
  | Pstring_set_16 of bool
  | Pstring_set_32 of bool
  | Pstring_set_64 of bool
  (* load/set 16,32,64 bits from a
     (char, int8_unsigned_elt, c_layout) Bigarray.Array1.t : (unsafe) *)
  | Pbigstring_load_16 of bool
  | Pbigstring_load_32 of bool
  | Pbigstring_load_64 of bool
  | Pbigstring_set_16 of bool
  | Pbigstring_set_32 of bool
  | Pbigstring_set_64 of bool
  (* Compile time constants *)
  | Pctconst of compile_time_constant
  (* byte swap *)
  | Pbswap16
  | Pbbswap of boxed_integer
  (* Integer to external pointer *)

  | Pdebugger
  | Pjs_unsafe_downgrade of string * Location.t
  | Pinit_mod
  | Pupdate_mod
  | Pjs_fn_make of int 
  | Pjs_fn_run of int 
  | Pjs_fn_method of int 
  | Pjs_fn_runmethod of int 

type switch  =
  { sw_numconsts: int;
    sw_consts: (int * t) list;
    sw_numblocks: int;
    sw_blocks: (int * t) list;
    sw_failaction : t option}
and apply_status =
  | App_na
  | App_ml_full
  | App_js_full      
and apply_info = private
  { fn : t ; 
    args : t list ; 
    loc : Location.t;
    status : apply_status
  }

and prim_info = private
  { primitive : primitive ; 
    args : t list ; 
    loc : Location.t 
  }
and function_info = private
  { arity : int ; 
   kind : Lambda.function_kind ; 
   params : ident list ;
   body : t 
  }
and  t =  private
  | Lvar of ident
  | Lconst of Lambda.structured_constant
  | Lapply of apply_info
  | Lfunction of function_info
  | Llet of Lambda.let_kind * ident * t * t
  | Lletrec of (ident * t) list * t
  | Lprim of prim_info
  | Lswitch of t * switch
  | Lstringswitch of t * (string * t) list * t option
  | Lstaticraise of int * t list
  | Lstaticcatch of t * (int * ident list) * t
  | Ltrywith of t * ident * t
  | Lifthenelse of t * t * t
  | Lsequence of t * t
  | Lwhile of t * t
  | Lfor of ident * t * t * Asttypes.direction_flag * t
  | Lassign of ident * t
  | Lsend of Lambda.meth_kind * t * t * t list * Location.t
  | Lifused of ident * t
  (* | Levent of t * Lambda.lambda_event 
     [Levent] in the branch hurt pattern match, 
     we should use record for trivial debugger info
  *)


module Prim : sig 
  type t = primitive
  val js_is_nil : t
  val js_is_undef : t 
  val js_is_nil_undef : t 
end


type binop = t -> t -> t 

type triop = t -> t -> t -> t 

type unop = t ->  t

val var : ident -> t
val const : Lambda.structured_constant -> t

val apply : t -> t list -> Location.t -> apply_status -> t
val function_ : 
  arity:int ->
  kind:Lambda.function_kind -> params:ident list -> body:t -> t

val let_ : Lambda.let_kind -> ident -> t -> t -> t
val letrec : (ident * t) list -> t -> t
val if_ : triop
val switch : t -> switch  -> t 
val stringswitch : t -> (string * t) list -> t option -> t 

val true_ : t 
val false_ : t 
val unit : t 

val sequor : binop
val sequand : binop
val not_ : Location.t ->  unop
val seq : binop
val while_ : binop
val event : t -> Lambda.lambda_event -> t  
val try_ : t -> ident -> t  -> t 
val ifused : ident -> t -> t
val assign : ident -> t -> t 

val send : 
  Lambda.meth_kind ->
  t -> t -> t list -> 
  Location.t -> t 

val prim : primitive:primitive -> args:t list -> Location.t  ->  t

val staticcatch : 
  t -> int * ident list -> t -> t

val staticraise : 
  int -> t list -> t

val for_ : 
  ident ->
  t  ->
  t -> Asttypes.direction_flag -> t -> t 





val convert : Lambda.lambda -> t 

end = struct
#1 "lam.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type array_kind = Lambda.array_kind
type boxed_integer = Lambda.boxed_integer
type comparison = Lambda.comparison 
type bigarray_kind = Lambda.bigarray_kind
type bigarray_layout = Lambda.bigarray_layout
type compile_time_constant = Lambda.compile_time_constant

type tag_info = Lambda.tag_info
type mutable_flag = Asttypes.mutable_flag
type field_dbg_info = Lambda.field_dbg_info 
type set_field_dbg_info = Lambda.set_field_dbg_info

type ident = Ident.t

type function_arities = 
  | Determin of bool * (int * Ident.t list option) list  * bool
  | NA 
               
type primitive = 
  | Pbytes_to_string
  | Pbytes_of_string
  (* Globals *)
  | Pgetglobal of ident
  | Psetglobal of ident
  | Pglobal_exception of ident       
  (* Operations on heap blocks *)
  | Pmakeblock of int * tag_info * mutable_flag
  | Pfield of int * field_dbg_info
  | Psetfield of int * bool * set_field_dbg_info
  (* could have field info at least for record *)
  | Pfloatfield of int * field_dbg_info
  | Psetfloatfield of int * set_field_dbg_info
  | Pduprecord of Types.record_representation * int
  (* Force lazy values *)
  | Plazyforce
  (* External call *)
  | Pccall of  Primitive.description
  (* Exceptions *)
  | Praise
  (* Boolean operations *)
  | Psequand | Psequor | Pnot
  (* Integer operations *)
  | Pnegint | Paddint | Psubint | Pmulint | Pdivint | Pmodint
  | Pandint | Porint | Pxorint
  | Plslint | Plsrint | Pasrint
  | Pintcomp of comparison
  | Poffsetint of int
  | Poffsetref of int
  (* Float operations *)
  | Pintoffloat | Pfloatofint
  | Pnegfloat | Pabsfloat
  | Paddfloat | Psubfloat | Pmulfloat | Pdivfloat
  | Pfloatcomp of comparison
  (* String operations *)
  | Pstringlength 
  | Pstringrefu 
  | Pstringrefs
  | Pstringadd  
  | Pbyteslength
  | Pbytesrefu
  | Pbytessetu 
  | Pbytesrefs
  | Pbytessets
  (* Array operations *)
  | Pmakearray of array_kind
  | Parraylength of array_kind
  | Parrayrefu of array_kind
  | Parraysetu of array_kind
  | Parrayrefs of array_kind
  | Parraysets of array_kind
  (* Test if the argument is a block or an immediate integer *)
  | Pisint
  (* Test if the (integer) argument is outside an interval *)
  | Pisout
  (* Bitvect operations *)
  | Pbittest
  (* Operations on boxed integers (Nativeint.t, Int32.t, Int64.t) *)
  | Pbintofint of boxed_integer
  | Pintofbint of boxed_integer
  | Pcvtbint of boxed_integer (*source*) * boxed_integer (*destination*)
  | Pnegbint of boxed_integer
  | Paddbint of boxed_integer
  | Psubbint of boxed_integer
  | Pmulbint of boxed_integer
  | Pdivbint of boxed_integer
  | Pmodbint of boxed_integer
  | Pandbint of boxed_integer
  | Porbint of boxed_integer
  | Pxorbint of boxed_integer
  | Plslbint of boxed_integer
  | Plsrbint of boxed_integer
  | Pasrbint of boxed_integer
  | Pbintcomp of boxed_integer * comparison
  (* Operations on big arrays: (unsafe, #dimensions, kind, layout) *)
  | Pbigarrayref of bool * int * bigarray_kind * bigarray_layout
  | Pbigarrayset of bool * int * bigarray_kind * bigarray_layout
  (* size of the nth dimension of a big array *)
  | Pbigarraydim of int
  (* load/set 16,32,64 bits from a string: (unsafe)*)
  | Pstring_load_16 of bool
  | Pstring_load_32 of bool
  | Pstring_load_64 of bool
  | Pstring_set_16 of bool
  | Pstring_set_32 of bool
  | Pstring_set_64 of bool
  (* load/set 16,32,64 bits from a
     (char, int8_unsigned_elt, c_layout) Bigarray.Array1.t : (unsafe) *)
  | Pbigstring_load_16 of bool
  | Pbigstring_load_32 of bool
  | Pbigstring_load_64 of bool
  | Pbigstring_set_16 of bool
  | Pbigstring_set_32 of bool
  | Pbigstring_set_64 of bool
  (* Compile time constants *)
  | Pctconst of compile_time_constant
  (* byte swap *)
  | Pbswap16
  | Pbbswap of boxed_integer
  (* Integer to external pointer *)

  | Pdebugger 
  | Pjs_unsafe_downgrade of string * Location.t
  | Pinit_mod
  | Pupdate_mod
  | Pjs_fn_make of int 
  | Pjs_fn_run of int 
  | Pjs_fn_method of int 
  | Pjs_fn_runmethod of int

type switch = 
  { sw_numconsts: int;
    sw_consts: (int * t) list;
    sw_numblocks: int;
    sw_blocks: (int * t) list;
    sw_failaction : t option}
and prim_info = 
  { primitive : primitive ; 
    args : t list ;
    loc : Location.t;
  }
and apply_status =
  | App_na
  | App_ml_full
  | App_js_full    
and apply_info = 
  { fn : t ; 
    args : t list ; 
    loc : Location.t;
    status : apply_status
  }
and function_info = 
  { arity : int ; 
   kind : Lambda.function_kind ; 
   params : ident list ;
   body : t 
  }
and t = 
  | Lvar of ident
  | Lconst of Lambda.structured_constant
  | Lapply of apply_info
  | Lfunction of function_info
  | Llet of Lambda.let_kind * ident * t * t
  | Lletrec of (ident * t) list * t
  | Lprim of prim_info
  | Lswitch of t * switch
  | Lstringswitch of t * (string * t) list * t option
  | Lstaticraise of int * t list
  | Lstaticcatch of t * (int * ident list) * t
  | Ltrywith of t * ident * t
  | Lifthenelse of t * t * t
  | Lsequence of t * t
  | Lwhile of t * t
  | Lfor of ident * t * t * Asttypes.direction_flag * t
  | Lassign of ident * t
  | Lsend of Lambda.meth_kind * t * t * t list * Location.t
  | Lifused of ident * t
  (* | Levent of t * Lambda.lambda_event 
     [Levent] in the branch hurt pattern match, 
     we should use record for trivial debugger info
  *)



module Prim = struct 
  type t = primitive
  let mk name arity = 
    Pccall {prim_name = name ; 
            prim_native_name = "" ;
            prim_alloc = false;
            prim_native_float = false;
            prim_arity = arity;

           }
  let js_is_nil : t = 
    mk "js_is_nil" 1 
  let js_is_undef : t = 
    mk "js_is_undef" 1 
  let js_is_nil_undef : t  = 
    mk "js_is_nil_undef" 1 
end





type binop = t -> t -> t 

type triop = t -> t -> t -> t 

type unop = t -> t 


let var id : t = Lvar id
let const ct : t = Lconst ct 
let apply fn args loc status : t = 
  Lapply { fn; args;  loc  ;
           status }
let function_ ~arity ~kind ~params ~body : t = 
  Lfunction { arity; kind; params ; body}

let let_ kind id e body :  t 
  = Llet (kind,id,e,body)
let letrec bindings body : t = 
  Lletrec(bindings,body)

let if_ (a : t) (b : t) c = 
  match a with
  | Lconst v ->
    begin match v with
    | Const_pointer (x, _)  | Const_base(Const_int x)
      ->
      if x <> 0 then b else c
    | Const_base (Const_char x) ->
      if Char.code x <> 0 then b else c
    | Const_base (Const_int32 x) ->
      if x <> 0l then b else c
    | Const_base (Const_int64 x) ->
      if x <> 0L then b else c
    | Const_base (Const_nativeint x) ->
      if x <> 0n then b else c
    | Const_base (Const_string _ | Const_float _ ) -> b
    | Const_block _
    | Const_float_array _
    | Const_immstring _ -> b
    end
  | _ ->  Lifthenelse (a,b,c)

let switch lam (lam_switch : switch) : t =
  match lam with
  | Lconst ((Const_pointer (i,_) | Const_base (Const_int i)))
    ->
    begin try List.assoc i lam_switch.sw_consts
      with  Not_found ->
      match lam_switch.sw_failaction with
      | Some x -> x
      | None -> assert false
    end
  | Lconst (Const_block (i,_,_)) ->
    begin try List.assoc i lam_switch.sw_blocks
      with  Not_found ->
      match lam_switch.sw_failaction with
      | Some x -> x
      | None -> assert false
    end
  | _ -> 
    Lswitch(lam,lam_switch)

let stringswitch (lam : t) cases default : t = 
  match lam with
  | Lconst (Const_base (Const_string (a,_))) ->
    begin
      try List.assoc a cases with Not_found ->
        begin
          match default with
          | Some x -> x
          | None -> assert false
        end
    end
  | _ -> Lstringswitch(lam, cases, default)


let true_ : t =
  Lconst (Const_pointer ( 1, Pt_constructor "true")) 

let false_ : t =
  Lconst (Const_pointer( 0, Pt_constructor "false"))

let unit : t = 
  Lconst (Const_pointer( 0, Pt_constructor "()"))

let assert_false_unit : t = 
  Lconst (Const_pointer( 0, Pt_constructor "impossible branch"))

(** [l || r ] *)
let sequor l r = if_ l true_ r 

(** [l && r ] *)
let sequand l r = if_ l r false_

let seq a b : t = 
  Lsequence (a, b)

let while_ a b : t  = 
  Lwhile(a,b)

let try_  body id  handler : t = 
  Ltrywith(body,id,handler)

let for_ v e1 e2 dir e3 : t  = 
  Lfor(v,e1,e2,dir,e3)

let event l (_event : Lambda.lambda_event) = l 

let ifused v l : t  = 
  Lifused (v,l)

let assign v l : t = Lassign(v,l)

let send u m o ll v : t = 
  Lsend(u, m, o, ll, v)

let staticcatch  a b c : t = Lstaticcatch(a,b,c)

let staticraise a b : t = Lstaticraise(a,b)

let comparison (cmp : Lambda.comparison) a b : bool = 
  match cmp with 
  | Ceq -> a = b 
  | Cneq -> a <> b 
  | Cgt -> a > b 
  | Cle -> a <= b 
  | Clt -> a < b 
  | Cge -> a >= b 

module Lift = struct 
  let int i : t =
    Lconst (Const_base (Const_int i))


  let int32 i : t =
    Lconst (Const_base (Const_int32 i))

  let bool b = if b then true_ else false_

  (* ATTENTION: [float, nativeint] constant propogaton is not done
     yet , due to cross platform problem
  *) 
  let float b  : t = 
    Lconst (Const_base (Const_float b))

  let nativeint b : t = 
    Lconst (Const_base (Const_nativeint b))

  let int32 b : t = 
    Lconst (Const_base (Const_int32 b))

  let int64 b : t =
    Lconst (Const_base (Const_int64 b))
  let string b : t =
    Lconst (Const_base (Const_string (b, None)))
  let char b : t =
    Lconst (Const_base (Const_char b))    
end

let prim ~primitive:(prim : Prim.t) ~args:(ll : t list) loc  : t = 
  let default () : t = Lprim { primitive = prim ;args =  ll ; loc} in 
  match ll with 
  | [Lconst a] -> 
    begin match prim, a  with 
      | Pnegint, (Const_base (Const_int a))
        -> Lift.int (- a)
      (* | Pfloatofint, (Const_base (Const_int a)) *)
      (*   -> Lift.float (float_of_int a) *)
      | Pintoffloat, (Const_base (Const_float a))
        -> 
        Lift.int (int_of_float (float_of_string a))
        (* | Pnegfloat -> Lift.float (-. a) *)
        (* | Pabsfloat -> Lift.float (abs_float a) *)
      | Pstringlength, (Const_base (Const_string (a,_)) ) 
        -> 
        Lift.int (String.length a)
      (* | Pnegbint Pnativeint, (Const_base (Const_nativeint i)) *)
      (*   ->   *)
      (*   Lift.nativeint (Nativeint.neg i) *)
      | Pnegbint Pint32, (Const_base (Const_int32 a))
        -> 
        Lift.int32 (Int32.neg a)
      | Pnegbint Pint64, (Const_base (Const_int64 a))
        -> 
        Lift.int64 (Int64.neg a)
      | Pnot , Const_pointer (a,_) 
        -> Lift.bool (a = 0 )
      | _ -> default ()
    end


  | [Lconst a ; Lconst b] -> 
    begin match prim, a, b  with 
      | Pbintcomp(_, cmp), Const_base (Const_int32 a), Const_base (Const_int32 b)
        -> Lift.bool (comparison cmp a b)
      | Pbintcomp(_, cmp), Const_base (Const_int64 a), Const_base (Const_int64 b)
        -> Lift.bool (comparison cmp a b)
      | Pbintcomp(_, cmp), Const_base (Const_nativeint a), Const_base (Const_nativeint b)
        -> Lift.bool (comparison cmp a b)
      | Pfloatcomp  cmp, Const_base (Const_nativeint a), Const_base (Const_nativeint b)
        -> Lift.bool (comparison cmp a b)
      | Pintcomp cmp ,
        (Const_base (Const_int a) | Const_pointer (a,_)),
        (Const_base (Const_int b) | Const_pointer (b,_))
        -> Lift.bool (comparison cmp a b)
      | (Paddint
        | Psubint
        | Pmulint
        | Pdivint
        | Pmodint
        | Pandint
        | Porint
        | Pxorint
        | Plslint
        | Plsrint
        | Pasrint),Const_base (Const_int a),  Const_base (Const_int b)
        ->
            (* WE SHOULD keep it as [int], to preserve types *)
            let aa,bb = Int32.of_int a, Int32.of_int  b in 
            let int_ v = Lift.int (Int32.to_int v ) in 
            begin match prim with 
              | Paddint -> int_ (Int32.add aa bb)
              | Psubint -> int_ (Int32.sub aa bb)
              | Pmulint -> int_ (Int32.mul aa  bb)
              | Pdivint -> 
                if bb = 0l then default ()
                else int_ (Int32.div aa bb)
              | Pmodint ->
                if bb = 0l then default ()
                else int_ (Int32.rem aa bb)
              | Pandint -> int_ (Int32.logand aa bb)
              | Porint -> int_ (Int32.logor aa bb)
              | Pxorint -> int_ (Int32.logxor aa bb)
              | Plslint -> int_ (Int32.shift_left  aa b )
              | Plsrint -> int_ (Int32.shift_right_logical aa  b)
              | Pasrint -> int_ (Int32.shift_right aa b)
              | _ -> default ()
            end
      | (Paddbint Pint32
        | Psubbint Pint32
        | Pmulbint Pint32
        | Pdivbint Pint32
        | Pmodbint Pint32
        | Pandbint Pint32
        | Porbint Pint32
        | Pxorbint Pint32
        ), Const_base (Const_int32 aa),  Const_base (Const_int32 bb)
        -> 
        begin match prim with 
          | Paddbint _  -> Lift.int32 (Int32.add aa bb)
          | Psubbint _  -> Lift.int32 (Int32.sub aa bb)
          | Pmulbint _ -> Lift.int32 (Int32.mul aa  bb)
          | Pdivbint _ ->  (try Lift.int32 (Int32.div aa  bb) with _  -> default ())
          | Pmodbint _ -> (try Lift.int32 (Int32.rem aa  bb) with _ -> default ())
          | Pandbint _ -> Lift.int32 (Int32.logand aa bb)
          | Porbint _ -> Lift.int32 (Int32.logor aa bb)
          | Pxorbint _ -> Lift.int32 (Int32.logxor aa bb)
          | _ -> default ()
        end
      | Plslbint Pint32, Const_base (Const_int32 aa), Const_base (Const_int b)
        -> Lift.int32 (Int32.shift_left  aa b )
      | Plsrbint Pint32, Const_base (Const_int32 aa), Const_base (Const_int b)
        -> Lift.int32 (Int32.shift_right_logical  aa b )
      | Pasrbint Pint32, Const_base (Const_int32 aa), Const_base (Const_int b)
        -> Lift.int32 (Int32.shift_right  aa b )

      | (Paddbint Pint64
        | Psubbint Pint64
        | Pmulbint Pint64
        | Pdivbint Pint64
        | Pmodbint Pint64
        | Pandbint Pint64
        | Porbint Pint64
        | Pxorbint Pint64
        ), Const_base (Const_int64 aa),  Const_base (Const_int64 bb)
        -> 
        begin match prim with 
          | Paddbint _  -> Lift.int64 (Int64.add aa bb)
          | Psubbint _  -> Lift.int64 (Int64.sub aa bb)
          | Pmulbint _ -> Lift.int64 (Int64.mul aa  bb)
          | Pdivbint _ -> (try Lift.int64 (Int64.div aa  bb) with _ -> default ())
          | Pmodbint _ -> (try Lift.int64 (Int64.rem aa  bb) with _ -> default ())
          | Pandbint _ -> Lift.int64 (Int64.logand aa bb)
          | Porbint _ -> Lift.int64 (Int64.logor aa bb)
          | Pxorbint _ -> Lift.int64 (Int64.logxor aa bb)
          | _ -> default ()
        end
      | Plslbint Pint64, Const_base (Const_int64 aa), Const_base (Const_int b)
        -> Lift.int64 (Int64.shift_left  aa b )
      | Plsrbint Pint64, Const_base (Const_int64 aa), Const_base (Const_int b)
        -> Lift.int64 (Int64.shift_right_logical  aa b )
      | Pasrbint Pint64, Const_base (Const_int64 aa), Const_base (Const_int b)
        -> Lift.int64 (Int64.shift_right  aa b )
      | Psequand, Const_pointer (a, _), Const_pointer( b, _)
        -> 
        Lift.bool (a = 1 && b = 1)
      | Psequor, Const_pointer (a, _), Const_pointer( b, _)
        -> 
        Lift.bool (a = 1 || b = 1)
      | Pstringadd, Const_base(Const_string (a, None)),
        Const_base (Const_string (b,None))
        ->
        Lift.string (a ^ b)
      | (Pstringrefs | Pstringrefu), Const_base(Const_string(a,None)),
        (Const_base(Const_int b)| Const_pointer (b,_))
        ->
        begin try Lift.char (String.get a b)
          with  _ -> default ()
        end                       
      | _ -> default ()
    end

  | _ -> default ()


let not_ loc x  : t = 
  prim Pnot [x] loc

let lam_prim ~primitive:( p : Lambda.primitive) ~args loc  : t = 
  match p with 
  | Pint_as_pointer 
  | Pidentity ->  
    begin match args with [x] -> x | _ -> assert false end
  | Pbytes_to_string 
    -> prim ~primitive:Pbytes_to_string ~args loc
  | Pbytes_of_string -> prim ~primitive:Pbytes_of_string ~args loc
  | Pignore -> (* Pignore means return unit, it is not an nop *)
    begin match args with [x] -> seq x unit | _ -> assert false end
  | Prevapply 
    -> 
    begin match args with 
    | [x ; Lapply{fn; args}]
      -> apply fn (args @[x]) loc App_na
    | [x; f] ->  apply f [x] loc App_na
    | _ -> assert false 
    end

  | Pdirapply ->
    begin match args with 
    | [Lapply{fn ; args }; x ] 
      -> 
        apply fn (args @ [x]) loc App_na
    | [f;x] -> apply f [x] loc App_na
    | _ -> assert false 
    end
  | Ploc loc -> assert false (* already compiled away here*)
  | Pgetglobal id ->
    if Ident.is_predef_exn id then
      prim ~primitive:(Pglobal_exception id) ~args loc       
    else       
      prim ~primitive:(Pgetglobal id) ~args loc
  | Psetglobal id -> prim ~primitive:(Psetglobal id) ~args loc
  | Pmakeblock (tag,info, mutable_flag) 
    -> prim ~primitive:(Pmakeblock (tag,info,mutable_flag)) ~args loc
  | Pfield (id,info) 
    -> prim ~primitive:(Pfield (id,info)) ~args loc

  | Psetfield (id,b,info)
    -> prim ~primitive:(Psetfield (id,b,info)) ~args loc

  | Pfloatfield (id,info)
    -> prim ~primitive:(Pfloatfield (id,info)) ~args loc
  | Psetfloatfield (id,info) 
    -> prim ~primitive:(Psetfloatfield (id,info)) ~args loc
  | Pduprecord (repr,i) 
    -> prim ~primitive:(Pduprecord(repr,i)) ~args loc
  | Plazyforce -> prim ~primitive:Plazyforce ~args loc

  | Pccall a -> 
    let prim_name = a.prim_name in
    if Pervasives.not @@ Ext_string.starts_with prim_name "js_" then 
      prim ~primitive:(Pccall a ) ~args loc else 
    if prim_name =  Literals.js_debugger then 
      prim ~primitive:Pdebugger ~args loc else 
    if prim_name =  Literals.js_fn_run || prim_name = Literals.js_method_run then
      prim ~primitive:(Pjs_fn_run (int_of_string a.prim_native_name)) ~args loc else 
    if prim_name = Literals.js_fn_mk then 
      prim ~primitive:(Pjs_fn_make (int_of_string a.prim_native_name)) ~args loc else                
    if prim_name = Literals.js_fn_method then 
      prim ~primitive:(Pjs_fn_method (int_of_string a.prim_native_name)) ~args loc else
    if prim_name = Literals.js_fn_runmethod then 
      prim ~primitive:(Pjs_fn_runmethod (int_of_string a.prim_native_name)) ~args loc 
    else
      prim ~primitive:(Pccall a) ~args loc
  | Praise _ ->
    if Js_config.get_no_any_assert () then 
      begin match args with 
        | [Lprim {primitive = Pmakeblock (0, _, _) ; 
                  args = [ 
                    Lprim {primitive = Pglobal_exception ({name = "Assert_failure"} as id); args =  []}; 
                    _
                  ]
                 } ] when Ident.global id
          -> assert_false_unit
        | _ -> prim ~primitive:Praise ~args loc 
      end
    else prim ~primitive:Praise ~args loc 
  | Psequand -> prim ~primitive:Psequand ~args loc
  | Psequor -> prim ~primitive:Psequor ~args loc
  | Pnot -> prim ~primitive:Pnot ~args loc 
  | Pnegint -> prim ~primitive:Pnegint ~args  loc 
  | Paddint -> prim ~primitive:Paddint ~args loc 
  | Psubint -> prim ~primitive:Psubint ~args loc 
  | Pmulint -> prim ~primitive:Pmulint ~args loc 
  | Pdivint -> prim ~primitive:Pdivint ~args loc 
  | Pmodint -> prim ~primitive:Pmodint ~args loc 
  | Pandint -> prim ~primitive:Pandint ~args loc 
  | Porint -> prim ~primitive:Porint ~args loc 
  | Pxorint -> prim ~primitive:Pxorint ~args loc 
  | Plslint -> prim ~primitive:Plslint ~args loc 
  | Plsrint -> prim ~primitive:Plsrint ~args loc 
  | Pasrint -> prim ~primitive:Pasrint ~args loc 
  | Pstringlength -> prim ~primitive:Pstringlength ~args loc 
  | Pstringrefu -> prim ~primitive:Pstringrefu ~args loc 
  | Pstringsetu 
  | Pstringsets -> assert false
  | Pstringrefs -> prim ~primitive:Pstringrefs ~args loc 

  | Pbyteslength -> prim ~primitive:Pbyteslength ~args loc 
  | Pbytesrefu -> prim ~primitive:Pbytesrefu ~args loc
  | Pbytessetu -> prim ~primitive:Pbytessetu ~args  loc 
  | Pbytesrefs -> prim ~primitive:Pbytesrefs ~args loc 
  | Pbytessets -> prim ~primitive:Pbytessets ~args loc 
  | Pisint -> prim ~primitive:Pisint ~args loc 
  | Pisout -> prim ~primitive:Pisout ~args loc 
  | Pbittest -> prim ~primitive:Pbittest ~args loc 
  | Pintoffloat -> prim ~primitive:Pintoffloat ~args loc
  | Pfloatofint -> prim ~primitive:Pfloatofint ~args loc 
  | Pnegfloat -> prim ~primitive:Pnegfloat ~args loc 
  | Pabsfloat -> prim ~primitive:Pabsfloat ~args loc 
  | Paddfloat -> prim ~primitive:Paddfloat ~args loc 
  | Psubfloat -> prim ~primitive:Psubfloat ~args loc 
  | Pmulfloat -> prim ~primitive:Pmulfloat ~args loc 
  | Pdivfloat -> prim ~primitive:Pdivfloat ~args loc 

  | Pbswap16 -> prim ~primitive:Pbswap16 ~args loc 
  | Pintcomp x -> prim ~primitive:(Pintcomp x)  ~args loc 
  | Poffsetint x -> prim ~primitive:(Poffsetint x) ~args loc 
  | Poffsetref x -> prim ~primitive:(Poffsetref x) ~args  loc
  | Pfloatcomp x -> prim ~primitive:(Pfloatcomp x) ~args loc 
  | Pmakearray x -> prim ~primitive:(Pmakearray x) ~args  loc 
  | Parraylength x -> prim ~primitive:(Parraylength x) ~args loc
  | Parrayrefu x -> prim ~primitive:(Parrayrefu x) ~args loc
  | Parraysetu x -> prim ~primitive:(Parraysetu x) ~args loc 
  | Parrayrefs x -> prim ~primitive:(Parrayrefs x) ~args loc 
  | Parraysets x -> prim ~primitive:(Parraysets x) ~args loc 
  | Pbintofint x -> prim ~primitive:(Pbintofint x) ~args loc 
  | Pintofbint x -> prim ~primitive:(Pintofbint x) ~args loc 
  | Pnegbint x -> prim ~primitive:(Pnegbint x) ~args loc 
  | Paddbint x -> prim ~primitive:(Paddbint x) ~args loc 
  | Psubbint x -> prim ~primitive:(Psubbint x) ~args loc 
  | Pmulbint x -> prim ~primitive:(Pmulbint x) ~args loc 
  | Pdivbint x -> prim ~primitive:(Pdivbint x) ~args loc 
  | Pmodbint x -> prim ~primitive:(Pmodbint x) ~args loc 
  | Pandbint x -> prim ~primitive:(Pandbint x) ~args loc 
  | Porbint x -> prim ~primitive:(Porbint x) ~args loc 
  | Pxorbint x -> prim ~primitive:(Pxorbint x) ~args loc 
  | Plslbint x -> prim ~primitive:(Plslbint x) ~args loc 
  | Plsrbint x -> prim ~primitive:(Plsrbint x) ~args loc 
  | Pasrbint x -> prim ~primitive:(Pasrbint x) ~args loc 
  | Pbigarraydim x -> prim ~primitive:(Pbigarraydim x) ~args loc 
  | Pstring_load_16 x -> prim ~primitive:(Pstring_load_16 x) ~args loc 
  | Pstring_load_32 x -> prim ~primitive:(Pstring_load_32 x) ~args loc 
  | Pstring_load_64 x -> prim ~primitive:(Pstring_load_64 x) ~args loc 
  | Pstring_set_16 x -> prim ~primitive:(Pstring_set_16 x) ~args loc 
  | Pstring_set_32 x -> prim ~primitive:(Pstring_set_32 x) ~args loc 
  | Pstring_set_64 x -> prim ~primitive:(Pstring_set_64 x) ~args loc 
  | Pbigstring_load_16 x -> prim ~primitive:(Pbigstring_load_16 x) ~args loc 
  | Pbigstring_load_32 x -> prim ~primitive:(Pbigstring_load_32 x) ~args loc 
  | Pbigstring_load_64 x -> prim ~primitive:(Pbigstring_load_64 x) ~args loc 
  | Pbigstring_set_16 x -> prim ~primitive:(Pbigstring_set_16 x) ~args loc 
  | Pbigstring_set_32 x -> prim ~primitive:(Pbigstring_set_32 x) ~args loc 
  | Pbigstring_set_64 x -> prim ~primitive:(Pbigstring_set_64 x) ~args loc 
  | Pctconst x ->
    begin match x with
      | Word_size ->
        Lift.int 32 (* TODO: documentation*)        
      | _ -> prim ~primitive:(Pctconst x) ~args loc          
    end

  | Pbbswap x -> prim ~primitive:(Pbbswap x) ~args loc 
  | Pcvtbint (a,b) -> prim ~primitive:(Pcvtbint (a,b)) ~args loc 
  | Pbintcomp (a,b) -> prim ~primitive:(Pbintcomp (a,b)) ~args loc 
  | Pbigarrayref (a,b,c,d) -> prim ~primitive:(Pbigarrayref (a,b,c,d)) ~args loc 
  | Pbigarrayset (a,b,c,d) -> prim ~primitive:(Pbigarrayset (a,b,c,d)) ~args loc 


let rec convert (lam : Lambda.lambda) : t = 
  match lam with 
  | Lvar x -> Lvar x 
  | Lconst x -> 
    Lconst x 
  | Lapply (fn,args,loc) 
    ->  
    begin match fn with 
    | Lprim (
         Pfield (id, _),
         [
          Lprim (
            Pgetglobal { name = "CamlinternalMod" },
            _,_
          )
        ],loc
      ) -> (* replace all {!CamlinternalMod} function *)
      let args = List.map convert args in
      begin match Ocaml_stdlib_slots.camlinternalMod.(id), args  with
      | "init_mod" ,  [_loc ; shape]  -> 
          begin match shape with 
            | Lconst (Const_block (0, _, [Const_block (0, _, [])])) 
              -> unit  (* see {!Translmod.init_shape}*)
            | _ ->  prim ~primitive:Pinit_mod ~args loc 
          end
      | "update_mod", [shape ;  _obj1; _obj2] -> 
            (* here array access will have side effect .. *)
            begin match shape with 
            | Lconst (Const_block (0, _, [Const_block (0, _, [])]))
              -> unit (* see {!Translmod.init_shape}*)
            | _ -> prim ~primitive:Pupdate_mod ~args loc
            end
      | _ -> assert false
      end

    | Lprim ( Pfield (id, _),
              [Lprim (Pgetglobal ({name  = "Pervasives"} ), _,_)],loc              
            )
      ->
      let args = List.map convert args in
      begin match Ocaml_stdlib_slots.pervasives.(id) , args  with
        | "^", [ l; r ] 
          ->
          prim ~primitive:Pstringadd ~args:[l;r] loc 
        | _ ->  apply (convert fn) args loc  App_na
      end
    | _ -> 
        apply (convert fn) (List.map convert args) 
          loc App_na
    end
  | Lfunction (kind,  params,body)
    ->  function_ 
          ~arity:(List.length params) ~kind ~params 
          ~body:(convert body)
  | Llet (kind,id,e,body) 
    -> Llet(kind,id,convert e, convert body)
  | Lletrec (bindings,body)
    -> 
    Lletrec (List.map (fun (id, e) -> id, convert e) bindings, convert body)
  | Lprim (primitive,args, loc) 
    -> convert_primitive loc primitive args 
    (* Lprim {primitive ; args = List.map convert args } *)
  | Lswitch (e,s) -> 
    Lswitch (convert e, convert_switch s)
  | Lstringswitch (e, cases, default,_) -> 
    Lstringswitch (convert e, List.map (fun (x, b) -> x, convert b ) cases, 
                   match default with 
                   | None -> None
                   | Some x -> Some (convert x)
                  )    

  | Lstaticraise (id, args) -> 
    Lstaticraise (id, List.map convert args)
  | Lstaticcatch (b, (i, ids), handler) -> 
    Lstaticcatch (convert b, (i,ids), convert handler)
  | Ltrywith (b, id, handler) -> 
    Ltrywith (convert b, id, convert handler)
  | Lifthenelse (b,then_,else_) -> 
    Lifthenelse (convert b, convert then_, convert else_)
  | Lsequence (a,b) 
    -> Lsequence (convert a, convert b)
  | Lwhile (b,body) -> 
    Lwhile (convert b, convert body)
  | Lfor (id, from_, to_, dir, loop) -> 
    Lfor (id, convert from_, convert to_, dir, convert loop)
  | Lassign (id, body) -> 
    Lassign (id, convert body)    
  | Lsend (kind, a,b,ls, loc) -> 
    (* Format.fprintf Format.err_formatter "%a@." Printlambda.lambda b ; *)
    begin match convert b with 
      | Lprim {primitive =  Pccall {prim_name };  args; loc}
        when prim_name = Literals.js_unsafe_downgrade
        -> 
        begin match kind, ls with 
          | Public (Some name), [] -> 
            prim ~primitive:(Pjs_unsafe_downgrade (name,loc)) 
              ~args loc 
          | _ -> assert false 
        end
      | b ->     
        (* Format.fprintf Format.err_formatter "weird: %d@." (Obj.tag (Obj.repr b));  *)
        Lsend(kind, convert a,  b, List.map convert ls, loc )
    end
  | Levent (e, event) -> convert e 
  | Lifused (id, e) -> 
    Lifused(id, convert e) (* TODO: remove it ASAP *)
and convert_primitive loc (primitive : Lambda.primitive) args = 
  lam_prim ~primitive ~args:(List.map convert args) loc
and convert_switch (s : Lambda.lambda_switch) : switch = 
  { sw_numconsts = s.sw_numconsts ; 
    sw_consts = List.map (fun (i, lam) -> i, convert lam) s.sw_consts;
    sw_numblocks = s.sw_numblocks;
    sw_blocks = List.map (fun (i,lam) -> i, convert lam ) s.sw_blocks;
    sw_failaction = 
      match s.sw_failaction with 
      | None -> None 
      | Some a -> Some (convert a)
  }  

end
module String_map : sig 
#1 "string_map.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








include Map.S with type key = string 

val of_list : (string * 'a) list -> 'a t

val add_list : (string * 'b) list -> 'b t -> 'b t

val find_opt : string -> 'a t -> 'a option

val find_default : string -> 'a -> 'a t -> 'a

val print :  (Format.formatter -> 'a -> unit) -> Format.formatter ->  'a t -> unit

end = struct
#1 "string_map.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








include Map.Make(String)

let of_list (xs : ('a * 'b) list ) = 
  List.fold_left (fun acc (k,v) -> add k v acc) empty xs 

let add_list (xs : ('a * 'b) list ) init = 
  List.fold_left (fun acc (k,v) -> add k v acc) init xs 


let find_opt k m =
  match find k m with 
  | exception v -> None
  | u -> Some u

let find_default k default m =
  match find k m with 
  | exception v -> default 
  | u -> u

let print p_v fmt  m =
  iter (fun k v -> 
      Format.fprintf fmt "@[%s@ ->@ %a@]@." k p_v v 
    ) m



end
module Js_cmj_format : sig 
#1 "js_cmj_format.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Define intemediate format to be serialized for cross module optimization
 *)

(** In this module, 
    currently only arity information is  exported, 

    Short term: constant literals are also exported 

    Long term:
    Benefit? since Google Closure Compiler already did such huge amount of work
    TODO: simple expression, literal small function  can be stored, 
    but what would happen if small function captures other environment
    for example 

    {[
      let f  = fun x -> g x 
    ]}

    {[
      let f = g 
    ]}
*)

type cmj_value = {
  arity : Lam.function_arities ;
  closed_lambda : Lam.t option ; 
  (* Either constant or closed functor *)
}

type effect = string option



type t = {
  values : cmj_value String_map.t;
  effect : effect;
  (* goog_package : string option; *)
  npm_package_path : Js_config.packages_info;
}

val pure_dummy : t
val no_pure_dummy : t


val from_file : string -> t
val from_string : string -> t

val to_file : string -> t -> unit

end = struct
#1 "js_cmj_format.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(* TODO: add a magic number *)
type cmj_value = {
  arity : Lam.function_arities ;
  closed_lambda : Lam.t option ; 
  (** Either constant or closed functor *)
}

type effect = string option



(** we don't force people to use package *)

type t = {
  values : cmj_value String_map.t;
  effect : effect;
  npm_package_path : Js_config.packages_info ;
}

let cmj_magic_number =  "BUCKLE20160510"
let cmj_magic_number_length = 
  String.length cmj_magic_number

let pure_dummy = 
  {
    values = String_map.empty;
    effect = None;
    npm_package_path = Empty;
  }

let no_pure_dummy = 
  {
    values = String_map.empty;
    effect = Some "";
    npm_package_path = Empty;  
  }



let from_file name : t =
  let ic = open_in_bin name in 
  let buffer = really_input_string ic cmj_magic_number_length in 
  if buffer <> cmj_magic_number then
    Ext_pervasives.failwithf ~loc:__LOC__ 
      "cmj files have incompatible versions, please rebuilt using the new compiler : %s" 
        __LOC__
  else 
    let v  : t = input_value ic in 
    close_in ic ;
    v 


let from_string s : t = 
  let magic_number = String.sub s 0 cmj_magic_number_length in 
  if magic_number = cmj_magic_number then 
    Marshal.from_string s  cmj_magic_number_length
  else 
    Ext_pervasives.failwithf ~loc:__LOC__ 
      "cmj files have incompatible versions, please rebuilt using the new compiler : %s"
        __LOC__

let to_file name (v : t) = 
  let oc = open_out_bin name in 
  output_string oc cmj_magic_number;
  output_value oc v;
  close_out oc 

end
module Ext_pp : sig 
#1 "ext_pp.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** A simple pretty printer
    
    Advantage compared with [Format], 
    [P.newline] does not screw the layout, have better control when do a newline (sicne JS has ASI)
    Easy to tweak

    {ul 
    {- be a little smarter}
    {- buffer the last line, so that  we can do a smart newline, when it's really safe to do so}
    }
*)
type t

val indent_length : int 

val string : t -> string -> unit

val space :  t -> unit

val nspace : t -> int ->  unit

val group : t -> int -> (unit -> 'a) -> 'a
(** [group] will record current indentation 
    and indent futher
 *)

val vgroup : t -> int -> (unit -> 'a) -> 'a

val paren : t -> (unit -> 'a) -> 'a

val brace : t -> (unit -> 'a) -> 'a

val paren_group : t -> int -> (unit -> 'a) -> 'a

val paren_vgroup : t -> int -> (unit -> 'a) -> 'a

val brace_group : t -> int -> (unit -> 'a) -> 'a

val brace_vgroup : t -> int -> (unit -> 'a) -> 'a

val bracket_group : t -> int -> (unit -> 'a) -> 'a

val bracket_vgroup : t -> int -> (unit -> 'a) -> 'a

val newline : t -> unit

val force_newline : t -> unit
(** [force_newline] Always print a newline *)

val from_channel : out_channel -> t

val from_buffer : Buffer.t -> t

val flush : t -> unit -> unit

end = struct
#1 "ext_pp.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








module L = struct 
  let space = " "
  let indent_str = "  "
end

let indent_length = String.length L.indent_str 

type t = {
  output_string : string -> unit;
  output_char : char -> unit; 
  flush : unit -> unit;
  mutable indent_level : int;
  mutable last_new_line : bool; 
  (* only when we print newline, we print the indent *)
}

let from_channel chan = { 
  output_string = (fun  s -> output_string chan s); 
  output_char = (fun c -> output_char chan c);
  flush = (fun _ -> flush chan);
  indent_level = 0 ;
  last_new_line = false;
}


let from_buffer buf = {
  output_string = (fun s -> Buffer.add_string buf s);
  output_char = (fun  c -> Buffer.add_char buf c);
  flush = (fun _ -> ());
  indent_level = 0;
  last_new_line = false;
}

(* If we have [newline] in [s], 
   all indentations will be broken 
   in the future, we can detect this in [s]
 *)
let string t s = 
  t.output_string  s ;
  t.last_new_line <- false

let newline t = 
  if not t.last_new_line then 
    begin
      t.output_char  '\n';
      for i = 0 to t.indent_level - 1 do 
        t.output_string  L.indent_str;
      done;
      t.last_new_line <- true
    end

let force_newline t = 
  t.output_char  '\n';
  for i = 0 to t.indent_level - 1 do 
    t.output_string  L.indent_str;
  done

let space t  = 
  string t L.space

let nspace  t n  = 
  string  t (String.make n ' ')

let group t i action = 
  if i = 0 then action ()
  else 
    let old = t.indent_level in
    t.indent_level <- t.indent_level + i;
    Ext_pervasives.finally () (fun _ -> t.indent_level <- old) action 

let vgroup = group

let paren t action = 
  string t "(";
  let v = action () in
  string t ")";
  v 

let brace fmt u = 
  string fmt "{";
  (* break1 fmt ; *)
  let v = u () in
  string fmt "}";
  v 

let bracket fmt u = 
  string fmt "[";
  let v = u () in
  string fmt "]";
  v 

let brace_vgroup st n action = 
  string st "{";
  let v = vgroup st n (fun _ -> 
    newline st; 
    let v =  action () in
    v
              ) in
  force_newline st;
  string st "}";
  v

let bracket_vgroup st n action = 
  string st "[";
  let v = vgroup st n (fun _ -> 
    newline st; 
    let v =  action () in
    v
              ) in
  force_newline st;
  string st "]";
  v

let bracket_group st n action = 
  group st n (fun _ -> bracket st action)

let paren_vgroup st n action = 
  string st "(";
  let v = group st n (fun _ -> 
    newline st; 
    let v = action () in
    v
                     ) in
  newline st;
  string st ")";
  v 
let paren_group st n action = group st n (fun _ -> paren st action)

let brace_group st n action = 
  group st n (fun _ -> brace st action )

let indent t n = 
  t.indent_level <- t.indent_level + n 

let flush t () = t.flush ()

end
module Int_map : sig 
#1 "int_map.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








include Map.S with type key = int

end = struct
#1 "int_map.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








include  Map.Make(struct 
  type t = int
  let compare (x : int) y  = Pervasives.compare x y
end)

end
module Ext_pp_scope : sig 
#1 "ext_pp_scope.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Scope type to improve identifier name printing
 *) 

(** Defines scope type [t], so that the pretty printer would print more beautiful code: 
    
    print [identifer] instead of [identifier$1234] when it can
 *)

type t 

val empty : t 

val add_ident : Ident.t -> t -> int * t

val sub_scope : t -> Ident_set.t -> t

val merge : Ident_set.t -> t -> t

val print : Format.formatter -> t -> unit

end = struct
#1 "ext_pp_scope.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








type t =  
    int  Int_map.t String_map.t

let empty = 
  String_map.empty 

let rec print fmt v = 
  Format.fprintf fmt "@[<v>{"  ;
  String_map.iter (fun k m -> 
      Format.fprintf fmt "%s: @[%a@],@ " k print_int_map m       
    )  v;
  Format.fprintf fmt "}@]"  
and print_int_map fmt m = 
  Int_map.iter (fun k v -> 
      Format.fprintf fmt "%d - %d" k v       
    ) m    

let add_ident (id : Ident.t) (cxt : t) : int * t = 
  match String_map.find id.name cxt with 
  | exception Not_found -> (0, String_map.add id.name Int_map.(add id.stamp 0  empty) cxt )
  | imap -> (
    match Int_map.find id.stamp imap with
    | exception Not_found ->
      let v = Int_map.cardinal imap in
      v, String_map.add id.name (Int_map.add id.stamp v imap) cxt
    | i -> i, cxt
  )

let of_list lst cxt = 
  List.fold_left (fun scope i -> snd (add_ident i scope)) cxt lst 

let merge set cxt  = 
  Ident_set.fold (fun ident acc -> snd (add_ident ident acc)) set  cxt 

(* Assume that all idents are already in the scope
   so both [param/0] and [param/1] are in idents, we don't need 
   update twice,  once is enough
 *)
let sub_scope (scope : t) ident_collection : t =
  let cxt = empty in
  Ident_set.fold (fun (i : Ident.t) acc -> 
    match String_map.find i.name scope with 
    | exception Not_found -> assert false 
    | imap -> ( 
      (* They are the same if already there*)
      match String_map.find i.name acc with 
      | exception Not_found -> String_map.add i.name imap acc
      | _ -> acc  (* TODO: optimization *) 
    )
  ) ident_collection cxt 





end
module Js_fold
= struct
#1 "js_fold.ml"
(* BuckleScript compiler
 * Copyright (C) 2015-2016 Bloomberg Finance L.P.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, with linking exception;
 * either version 2.1 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 *)
(* Author: Hongbo Zhang  *)
(** GENERATED CODE for fold visitor patten of JS IR  *)
open J
  
class virtual fold =
  object ((o : 'self_type))
    method string : string -> 'self_type = o#unknown
    method option :
      'a. ('self_type -> 'a -> 'self_type) -> 'a option -> 'self_type =
      fun _f_a -> function | None -> o | Some _x -> let o = _f_a o _x in o
    method list :
      'a. ('self_type -> 'a -> 'self_type) -> 'a list -> 'self_type =
      fun _f_a ->
        function
        | [] -> o
        | _x :: _x_i1 -> let o = _f_a o _x in let o = o#list _f_a _x_i1 in o
    method int : int -> 'self_type = o#unknown
    method bool : bool -> 'self_type = function | false -> o | true -> o
    method vident : vident -> 'self_type =
      function
      | Id _x -> let o = o#ident _x in o
      | Qualified (_x, _x_i1, _x_i2) ->
          let o = o#ident _x in
          let o = o#kind _x_i1 in
          let o = o#option (fun o -> o#string) _x_i2 in o
    method variable_declaration : variable_declaration -> 'self_type =
      fun { ident = _x; value = _x_i1; property = _x_i2; ident_info = _x_i3 }
        ->
        let o = o#ident _x in
        let o = o#option (fun o -> o#expression) _x_i1 in
        let o = o#property _x_i2 in let o = o#ident_info _x_i3 in o
    method tag_info : tag_info -> 'self_type = o#unknown
    method statement_desc : statement_desc -> 'self_type =
      function
      | Block _x -> let o = o#block _x in o
      | Variable _x -> let o = o#variable_declaration _x in o
      | Exp _x -> let o = o#expression _x in o
      | If (_x, _x_i1, _x_i2) ->
          let o = o#expression _x in
          let o = o#block _x_i1 in
          let o = o#option (fun o -> o#block) _x_i2 in o
      | While (_x, _x_i1, _x_i2, _x_i3) ->
          let o = o#option (fun o -> o#label) _x in
          let o = o#expression _x_i1 in
          let o = o#block _x_i2 in let o = o#unknown _x_i3 in o
      | ForRange (_x, _x_i1, _x_i2, _x_i3, _x_i4, _x_i5) ->
          let o = o#option (fun o -> o#for_ident_expression) _x in
          let o = o#finish_ident_expression _x_i1 in
          let o = o#for_ident _x_i2 in
          let o = o#for_direction _x_i3 in
          let o = o#block _x_i4 in let o = o#unknown _x_i5 in o
      | Continue _x -> let o = o#label _x in o
      | Break -> o
      | Return _x -> let o = o#return_expression _x in o
      | Int_switch (_x, _x_i1, _x_i2) ->
          let o = o#expression _x in
          let o =
            o#list
              (fun o ->
                 (* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)
                 (** Javascript IR
  
    It's a subset of Javascript AST specialized for OCaml lambda backend

    Note it's not exactly the same as Javascript, the AST itself follows lexical
    convention and [Block] is just a sequence of statements, which means it does 
    not introduce new scope
*)
                 (** object literal, if key is ident, in this case, it might be renamed by 
    Google Closure  optimizer,
    currently we always use quote
 *)
                 (* Since camldot is only available for toplevel module accessors,
       we don't need print  `A.length$2`
       just print `A.length` - it's guarateed to be unique
       
       when the third one is None, it means the whole module 

       TODO: 
       invariant, when [kind] is [Runtime], then we can ignore [ident], 
       since all [runtime] functions are unique, when do the 
       pattern match we can ignore the first one for simplicity
       for example       
       {[
         Qualified (_, Runtime, Some "caml_int_compare")         
       ]}       
     *)
                 (* used in [js_create_array] primitive, note having
       uninitilized array is not as bad as in ocaml, 
       since GC does not rely on it
     *)
                 (* shallow copy, like [x.slice] *)
                 (* For [caml_array_append]*)
                 (* | Tag_ml_obj of expression *) (* js true/false*)
                 (* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence 
     [typeof] is an operator     
  *)
                 (* !v *) (* String.fromCharCode.apply(null, args) *)
                 (* Convert JS boolean into OCaml boolean 
       like [+true], note this ast talks using js
       terminnology unless explicity stated                       
     *)
                 (* TODO: in the future, it might make sense to group primitivie by type,
     which makes optimizations easier
     {[ JSON.stringify(value, replacer[, space]) ]}
  *)
                 (* for debugging utitlites, 
     TODO:  [Dump] is not necessary with this primitive 
     Note that the semantics is slightly different from [JSON.stringify]     
     {[
       JSON.stringify("x")       
     ]}
     {[
       ""x""       
     ]}     
     {[
       JSON.stringify(undefined)       
     ]}     
     {[
       undefined       
     ]}
     {[ '' + undefined
     ]}     
     {[ 'undefined'
     ]}     
  *)
                 (* TODO: 
     add 
     {[ Assert of bool * expression ]}     
  *)
                 (* to support 
       val log1 : 'a -> unit
       val log2 : 'a -> 'b -> unit 
       val log3 : 'a -> 'b -> 'c -> unit 
     *)
                 (* TODO: Add some primitives so that [js inliner] can do a better job *)
                 (* [int_op] will guarantee return [int32] bits 
     https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators  *)
                 (* | Int32_bin of int_op * expression * expression *)
                 (* f.apply(null,args) -- Fully applied guaranteed 
       TODO: once we know args's shape --
       if it's know at compile time, we can turn it into
       f(args[0], args[1], ... )
     *)
                 (* {[ Bind (a,b) ]}
     is literally
     {[ a.bind(b) ]}
  *)
                 (* Analysze over J expression is hard since, 
        some primitive  call is translated 
        into a plain call, it's better to keep them
    *)
                 (* Invariant: 
       The second argument has to be type of [int],
       This can be constructed either in a static way [E.index] or a dynamic way 
       [E.access]
     *)
                 (* The third argument bool indicates whether we should 
       print it as 
       a["idd"] -- false
       or 
       a.idd  -- true
       There are several kinds of properties
       1. OCaml module dot (need to be escaped or not)
          All exported declarations have to be OCaml identifiers
       2. Javascript dot (need to be preserved/or using quote)
     *)
                 (* TODO: option remove *)
                 (* The first parameter by default is false, 
     it will be true when it's a method
  *)
                 (* A string is UTF-8 encoded, the string may contain
       escape sequences.
       The first argument is used to mark it is non-pure, please
       don't optimize it, since it does have side effec, 
       examples like "use asm;" and our compiler may generate "error;..." 
       which is better to leave it alone
     *)
                 (* literally raw JS code 
  *)
                 (* The third argument is [tag] , forth is [tag_info] *)
                 (* [tag] and [size] tailed  for [Obj.new_block] *)
                 (* For setter, it still return the value of expression, 
     we can not use 
     {[
       type 'a access = Get | Set of 'a
     ]}
     in another module, since it will break our code generator
     [Caml_block_tag] can return [undefined], 
     you have to use [E.tag] in a safe way     
  *)
                 (* It will just fetch tag, to make it safe, when creating it, 
     we need apply "|0", we don't do it in the 
     last step since "|0" can potentially be optimized
  *)
                 (* pure*) (* pure *)
                 (* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block
   block can be nested, specified in ES3 
 *)
                 (* Delay some units like [primitive] into JS layer ,
   benefit: better cross module inlining, and smaller IR size?
 *)
                 (* 
  [closure] captured loop mutable values in the outer loop

  check if it contains loop mutable values, happens in nested loop
  when closured, it's no longer loop mutable value. 
  which means the outer loop mutable value can not peek into the inner loop
  {[
  var i = f ();
  for(var finish = 32; i < finish; ++i){
  }
  ]}
  when [for_ident_expression] is [None], [var i] has to 
  be initialized outside, so 

  {[
  var i = f ()
  (function (xxx){
  for(var finish = 32; i < finish; ++i)
  }(..i))
  ]}
  This happens rare it's okay

  this is because [i] has to be initialized outside, if [j] 
  contains a block side effect
  TODO: create such example
*)
                 (* Since in OCaml, 
   
  [for i = 0 to k end do done ]
  k is only evaluated once , to encode this invariant in JS IR,
  make sure [ident] is defined in the first b

  TODO: currently we guarantee that [bound] was only 
  excecuted once, should encode this in AST level
*)
                 (* Can be simplified to keep the semantics of OCaml
   For (var i, e, ...){
     let  j = ... 
   }

   if [i] or [j] is captured inside closure

   for (var i , e, ...){
     (function (){
     })(i)
   }
*)
                 (* Single return is good for ininling..
   However, when you do tail-call optmization
   you loose the expression oriented semantics
   Block is useful for implementing goto
   {[
   xx:{
   break xx;
   }
   ]}
*)
                 (* Function declaration and Variable declaration  *)
                 (* check if it contains loop mutable values, happens in nested loop *)
                 (* only used when inline a fucntion *)
                 (* Here we need track back a bit ?, move Return to Function ...
                              Then we can only have one Return, which is not good *)
                 o#case_clause (fun o -> o#int))
              _x_i1 in
          let o = o#option (fun o -> o#block) _x_i2 in o
      | String_switch (_x, _x_i1, _x_i2) ->
          let o = o#expression _x in
          let o =
            o#list (fun o -> o#case_clause (fun o -> o#string)) _x_i1 in
          let o = o#option (fun o -> o#block) _x_i2 in o
      | Throw _x -> let o = o#expression _x in o
      | Try (_x, _x_i1, _x_i2) ->
          let o = o#block _x in
          let o =
            o#option
              (fun o (_x, _x_i1) ->
                 let o = o#exception_ident _x in let o = o#block _x_i1 in o)
              _x_i1 in
          let o = o#option (fun o -> o#block) _x_i2 in o
      | Debugger -> o
    method statement : statement -> 'self_type =
      fun { statement_desc = _x; comment = _x_i1 } ->
        let o = o#statement_desc _x in
        let o = o#option (fun o -> o#string) _x_i1 in o
    method return_expression : return_expression -> 'self_type =
      fun { return_value = _x } -> let o = o#expression _x in o
    method required_modules : required_modules -> 'self_type = o#unknown
    method property_name : property_name -> 'self_type = o#unknown
    method property_map : property_map -> 'self_type =
      o#list
        (fun o (_x, _x_i1) ->
           let o = o#property_name _x in let o = o#expression _x_i1 in o)
    method property : property -> 'self_type = o#unknown
    method program : program -> 'self_type =
      fun { name = _x; block = _x_i1; exports = _x_i2; export_set = _x_i3 }
        ->
        let o = o#string _x in
        let o = o#block _x_i1 in
        let o = o#exports _x_i2 in let o = o#unknown _x_i3 in o
    method number : number -> 'self_type = o#unknown
    method mutable_flag : mutable_flag -> 'self_type = o#unknown
    method length_object : length_object -> 'self_type = o#unknown
    method label : label -> 'self_type = o#string
    method kind : kind -> 'self_type = o#unknown
    method jsint : jsint -> 'self_type = o#unknown
    method int_op : int_op -> 'self_type = o#unknown
    method ident_info : ident_info -> 'self_type = o#unknown
    method ident : ident -> 'self_type = o#unknown
    method for_ident_expression : for_ident_expression -> 'self_type =
      o#expression
    method for_ident : for_ident -> 'self_type = o#ident
    method for_direction : for_direction -> 'self_type = o#unknown
    method finish_ident_expression : finish_ident_expression -> 'self_type =
      o#expression
    method expression_desc : expression_desc -> 'self_type =
      function
      | Math (_x, _x_i1) ->
          let o = o#string _x in
          let o = o#list (fun o -> o#expression) _x_i1 in o
      | Length (_x, _x_i1) ->
          let o = o#expression _x in let o = o#length_object _x_i1 in o
      | Char_of_int _x -> let o = o#expression _x in o
      | Char_to_int _x -> let o = o#expression _x in o
      | Array_of_size _x -> let o = o#expression _x in o
      | Array_copy _x -> let o = o#expression _x in o
      | Array_append (_x, _x_i1) ->
          let o = o#expression _x in let o = o#expression _x_i1 in o
      | String_append (_x, _x_i1) ->
          let o = o#expression _x in let o = o#expression _x_i1 in o
      | Int_of_boolean _x -> let o = o#expression _x in o
      | Anything_to_number _x -> let o = o#expression _x in o
      | Bool _x -> let o = o#bool _x in o
      | Typeof _x -> let o = o#expression _x in o
      | Not _x -> let o = o#expression _x in o
      | String_of_small_int_array _x -> let o = o#expression _x in o
      | Json_stringify _x -> let o = o#expression _x in o
      | Anything_to_string _x -> let o = o#expression _x in o
      | Dump (_x, _x_i1) ->
          let o = o#unknown _x in
          let o = o#list (fun o -> o#expression) _x_i1 in o
      | Seq (_x, _x_i1) ->
          let o = o#expression _x in let o = o#expression _x_i1 in o
      | Cond (_x, _x_i1, _x_i2) ->
          let o = o#expression _x in
          let o = o#expression _x_i1 in let o = o#expression _x_i2 in o
      | Bin (_x, _x_i1, _x_i2) ->
          let o = o#binop _x in
          let o = o#expression _x_i1 in let o = o#expression _x_i2 in o
      | FlatCall (_x, _x_i1) ->
          let o = o#expression _x in let o = o#expression _x_i1 in o
      | Bind (_x, _x_i1) ->
          let o = o#expression _x in let o = o#expression _x_i1 in o
      | Call (_x, _x_i1, _x_i2) ->
          let o = o#expression _x in
          let o = o#list (fun o -> o#expression) _x_i1 in
          let o = o#unknown _x_i2 in o
      | String_access (_x, _x_i1) ->
          let o = o#expression _x in let o = o#expression _x_i1 in o
      | Access (_x, _x_i1) ->
          let o = o#expression _x in let o = o#expression _x_i1 in o
      | Dot (_x, _x_i1, _x_i2) ->
          let o = o#expression _x in
          let o = o#string _x_i1 in let o = o#bool _x_i2 in o
      | New (_x, _x_i1) ->
          let o = o#expression _x in
          let o = o#option (fun o -> o#list (fun o -> o#expression)) _x_i1
          in o
      | Var _x -> let o = o#vident _x in o
      | Fun (_x, _x_i1, _x_i2, _x_i3) ->
          let o = o#bool _x in
          let o = o#list (fun o -> o#ident) _x_i1 in
          let o = o#block _x_i2 in let o = o#unknown _x_i3 in o
      | Str (_x, _x_i1) -> let o = o#bool _x in let o = o#string _x_i1 in o
      | Raw_js_code (_x, _x_i1) ->
          let o = o#string _x in let o = o#code_info _x_i1 in o
      | Array (_x, _x_i1) ->
          let o = o#list (fun o -> o#expression) _x in
          let o = o#mutable_flag _x_i1 in o
      | Caml_block (_x, _x_i1, _x_i2, _x_i3) ->
          let o = o#list (fun o -> o#expression) _x in
          let o = o#mutable_flag _x_i1 in
          let o = o#expression _x_i2 in let o = o#tag_info _x_i3 in o
      | Caml_uninitialized_obj (_x, _x_i1) ->
          let o = o#expression _x in let o = o#expression _x_i1 in o
      | Caml_block_tag _x -> let o = o#expression _x in o
      | Caml_block_set_tag (_x, _x_i1) ->
          let o = o#expression _x in let o = o#expression _x_i1 in o
      | Caml_block_set_length (_x, _x_i1) ->
          let o = o#expression _x in let o = o#expression _x_i1 in o
      | Number _x -> let o = o#number _x in o
      | Object _x -> let o = o#property_map _x in o
    method expression : expression -> 'self_type =
      fun { expression_desc = _x; comment = _x_i1 } ->
        let o = o#expression_desc _x in
        let o = o#option (fun o -> o#string) _x_i1 in o
    method exports : exports -> 'self_type = o#unknown
    method exception_ident : exception_ident -> 'self_type = o#ident
    method deps_program : deps_program -> 'self_type =
      fun { program = _x; modules = _x_i1; side_effect = _x_i2 } ->
        let o = o#program _x in
        let o = o#required_modules _x_i1 in
        let o = o#option (fun o -> o#string) _x_i2 in o
    method code_info : code_info -> 'self_type = o#unknown
    method case_clause :
      (* since in ocaml, it's expression oriented langauge, [return] in
    general has no jumps, it only happens when we do 
    tailcall conversion, in that case there is a jump.
    However, currently  a single [break] is good to cover
    our compilation strategy 

    Attention: we should not insert [break] arbitrarily, otherwise 
    it would break the semantics
    A more robust signature would be 
    {[ goto : label option ; ]}
  *)
        'a. ('self_type -> 'a -> 'self_type) -> 'a case_clause -> 'self_type =
      fun _f_a { case = _x; body = _x_i1 } ->
        let o = _f_a o _x in
        let o =
          (fun (_x, _x_i1) -> let o = o#block _x in let o = o#bool _x_i1 in o)
            _x_i1
        in o
    method block : block -> 'self_type = (* true means break *)
      (* TODO: For efficency: block should not be a list, it should be able to 
   be concatenated in both ways 
 *)
      o#list (fun o -> o#statement)
    method binop : binop -> 'self_type = o#unknown
    method unknown : 'a. 'a -> 'self_type = fun _ -> o
  end
  


end
module Js_analyzer : sig 
#1 "js_analyzer.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Analyzing utilities for [J] module *) 

(** for example, whether it has side effect or not.
 *)

val free_variables_of_statement : 
    Ident_set.t -> Ident_set.t -> J.statement -> Ident_set.t

val free_variables_of_expression : 
    Ident_set.t -> Ident_set.t -> J.finish_ident_expression -> Ident_set.t

val no_side_effect_expression_desc :
  J.expression_desc -> bool   
val no_side_effect_expression : 
  J.expression -> bool
(** [no_side_effect] means this expression has no side effect, 
    but it might *depend on value store*, so you can not just move it around,

    for example,
    when you want to do a deep copy, the expression passed to you is pure
    but you still have to call the function to make a copy, 
    since it maybe changed later
 *)

val no_side_effect_statement : 
    J.statement -> bool
(** 
    here we say 
    {[ var x = no_side_effect_expression ]}
    is [no side effect], but it is actually side effect, 
    since  we are defining a variable, however, if it is not exported or used, 
    then it's fine, so we delay this check later
 *)

val eq_expression : J.expression -> J.expression -> bool

val eq_statement : J.statement -> J.statement -> bool

val rev_flatten_seq : J.expression -> J.block 

val rev_toplevel_flatten : J.block -> J.block
(** return the block in reverse order *)

val is_constant : J.expression -> bool

end = struct
#1 "js_analyzer.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)










(* Assume that functions already calculated closure correctly 
   Maybe in the future, we should add a dirty flag, to mark the calcuated 
   closure is correct or not

   Note such shaking is done in the toplevel, so that it requires us to 
   flatten the statement first 
 *)
let free_variables used_idents defined_idents = 
  object (self)
    inherit Js_fold.fold as super
    val defined_idents = defined_idents
    val used_idents = used_idents 
    method! variable_declaration st = 
      match st with 
      | { ident; value = None}
        -> 
        {< defined_idents = Ident_set.add ident defined_idents >}
      | { ident; value = Some v}
        -> 
        {< defined_idents = Ident_set.add ident defined_idents >} # expression v
    method! ident id = 
      if Ident_set.mem id defined_idents then self
      else {<used_idents = Ident_set.add id used_idents >}
    method! expression exp = 

      match exp.expression_desc with
      | Fun(_, _,_, env)
      (** a optimization to avoid walking into funciton again
          if it's already comuted
      *)
        ->
        {< used_idents = 
             Ident_set.union (Js_fun_env.get_unbounded env) used_idents  >}

      | _
        ->
        super#expression exp

    method get_depenencies = 
      Ident_set.diff used_idents defined_idents
    method get_used_idents = used_idents
    method get_defined_idents = defined_idents 
  end 

let free_variables_of_statement used_idents defined_idents st = 
  ((free_variables used_idents defined_idents)#statement st) # get_depenencies

let free_variables_of_expression used_idents defined_idents st = 
  ((free_variables used_idents defined_idents)#expression st) # get_depenencies

let rec no_side_effect_expression_desc (x : J.expression_desc)  = 
  match x with 
  | Bool _ -> true 
  | Var _ -> true 
  | Access (a,b) -> no_side_effect a && no_side_effect b 
  | Str (b,_) -> b
  | Fun _ -> true
  | Number _ -> true (* Can be refined later *)
  | Array (xs,_mutable_flag)  
  | Caml_block (xs, _mutable_flag, _, _)
    ->
      (** create [immutable] block,
          does not really mean that this opreation itself is [pure].
          
          the block is mutable does not mean this operation is non-pure
       *)
      List.for_all no_side_effect  xs 
  | Bind(fn, obj) -> no_side_effect fn && no_side_effect obj
  | Object kvs -> 
    List.for_all (fun (_property_name, y) -> no_side_effect y ) kvs 
  | Array_append (a,b) 
  | String_append (a,b)
  | Seq (a,b) -> no_side_effect a && no_side_effect b 
  | Length (e, _)
  | Char_of_int e 
  | Char_to_int e 
  | Caml_block_tag e 
  | Typeof e
    -> no_side_effect e 
  | Bin (op, a, b) -> 
    op <> Eq && no_side_effect a && no_side_effect b     
  | Math _ 
  | Array_of_size _
  | Array_copy _ 
  (* | Tag_ml_obj _ *)
  | Int_of_boolean _ 
  | J.Anything_to_number _
  | Not _ 
  | String_of_small_int_array _ 
  | Json_stringify _ 
  | Anything_to_string _ 
  | Dump _ 
  | Cond _ 

  | FlatCall _ 
  | Call _ 
  | Dot _ 
  | New _ 
  | Caml_uninitialized_obj _
  | String_access _
  | Raw_js_code _ 
  | Caml_block_set_tag _ 
  | Caml_block_set_length _ (* actually true? *)
    -> false 
and no_side_effect (x : J.expression)  = 
  no_side_effect_expression_desc x.expression_desc

let no_side_effect_expression (x : J.expression) = no_side_effect x 

let no_side_effect init = 
  object (self)
    inherit Js_fold.fold as super
    val no_side_effect = init
    method get_no_side_effect = no_side_effect

    method! statement s = 
      if not no_side_effect then self else 
      match s.statement_desc with 
      | Throw _ 
      | Debugger 
      | Break 
      | Variable _ 
      | Continue _ ->  
        {< no_side_effect = false>}
      | Exp e -> self#expression e 
      | Int_switch _ | String_switch _ | ForRange _ 
      | If _ | While _   | Block _ | Return _ | Try _  -> super#statement s 
    method! list f x = 
      if not self#get_no_side_effect then self else super#list f x 
    method! expression s = 
      if not no_side_effect then self
      else  {< no_side_effect = no_side_effect_expression s >}

        (** only expression would cause side effec *)
  end
let no_side_effect_statement st = ((no_side_effect true)#statement st)#get_no_side_effect

(* TODO: generate [fold2] 
   This make sense, for example:
   {[
   let string_of_formatting_gen : type a b c d e f .
   (a, b, c, d, e, f) formatting_gen -> string =
   fun formatting_gen -> match formatting_gen with
   | Open_tag (Format (_, str)) -> str
   | Open_box (Format (_, str)) -> str

   ]}
 *)
let rec eq_expression (x : J.expression) (y : J.expression) = 
  match x.expression_desc, y.expression_desc with 
  | Number (Int i) , Number (Int j)   -> i = j 
  | Number (Float i), Number (Float j) -> false (* TODO *)
  | Math  (name00,args00), Math(name10,args10) -> 
    name00 = name10 && eq_expression_list args00 args10 
  | Access (a0,a1), Access(b0,b1) -> 
    eq_expression a0 b0 && eq_expression a1 b1
  | Call (a0,args00,_), Call(b0,args10,_) ->
    eq_expression a0 b0 &&  eq_expression_list args00 args10
  | Var (Id i), Var (Id j) ->
    Ident.same i j
  | Bin (op0, a0,b0) , Bin(op1,a1,b1) -> 
    op0 = op1 && eq_expression a0 a1 && eq_expression b0 b1
  | _, _ -> false 

and eq_expression_list xs ys =
  let rec aux xs ys =
    match xs,ys with
    | [], [] -> true
    | [], _  -> false 
    | _ , [] -> false
    | x::xs, y::ys -> eq_expression x y && aux xs ys 
  in
  aux xs ys

and eq_statement (x : J.statement) (y : J.statement) = 
  match x.statement_desc, y.statement_desc with 
  | Exp a, Exp b 
  | Return { return_value = a ; _} , Return { return_value = b; _} ->
    eq_expression a b
  | _, _ ->
    false 

let rev_flatten_seq (x : J.expression) = 
  let rec aux acc (x : J.expression) : J.block = 
    match x.expression_desc with
    | Seq(a,b) -> aux (aux acc a) b 
    | _ -> { statement_desc = Exp x; comment = None} :: acc in
  aux [] x 

(* TODO: optimization, 
    counter the number to know if needed do a loop gain instead of doing a diff 
 *)

let rev_toplevel_flatten block = 
  let rec aux  acc (xs : J.block) : J.block  = 
    match xs with 
    | [] -> acc
    | {statement_desc =
       Variable (
       {ident_info = {used_stats = Dead_pure } ; _} 
       | {ident_info = {used_stats = Dead_non_pure}; value = None })
     } :: xs -> aux acc xs 
    | {statement_desc = Block b; _ } ::xs -> aux (aux acc b ) xs 

    | x :: xs -> aux (x :: acc) xs  in
  aux [] block

let rec is_constant (x : J.expression)  = 
  match x.expression_desc with 
  | Access (a,b) -> is_constant a && is_constant b 
  | Str (b,_) -> b
  | Number _ -> true (* Can be refined later *)
  | Array (xs,_mutable_flag)  -> List.for_all is_constant  xs 
  | Caml_block(xs, Immutable, tag, _) 
    -> List.for_all is_constant xs && is_constant tag 
  | Bin (op, a, b) -> 
    is_constant a && is_constant b     
  | _ -> false 

end
module Js_op_util : sig 
#1 "js_op_util.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Some basic utilties around {!Js_op} module *)

val op_prec : Js_op.binop -> int * int * int

val op_str : Js_op.binop -> string

val op_int_prec : Js_op.int_op -> int * int * int

val op_int_str : Js_op.int_op -> string

val str_of_used_stats : Js_op.used_stats -> string

val update_used_stats : J.ident_info -> Js_op.used_stats -> unit

val same_vident : J.vident -> J.vident -> bool

val of_lam_mutable_flag : Asttypes.mutable_flag -> Js_op.mutable_flag 

end = struct
#1 "js_op_util.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)









(* Refer https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence
  for precedence   
*)

let op_prec (op : Js_op.binop ) =
  match op with
  | Eq -> 1, 13, 1
  | Or -> 3, 3, 3
  | And -> 4, 4, 4
  | EqEqEq | NotEqEq -> 8, 8, 9
  | Gt | Ge | Lt | Le | InstanceOf -> 9, 9, 10
  | Bor -> 5, 5, 5
  | Bxor -> 6, 6, 6
  | Band -> 7, 7, 7
  | Lsl | Lsr | Asr -> 10, 10, 11
  | Plus | Minus -> 11, 11, 12
  | Mul | Div | Mod -> 12, 12, 13

let op_int_prec (op : Js_op.int_op) = 
  match op with
  | Bor -> 5, 5, 5
  | Bxor -> 6, 6, 6
  | Band -> 7, 7, 7
  | Lsl | Lsr | Asr -> 10, 10, 11
  | Plus | Minus -> 11, 11, 12
  | Mul | Div | Mod -> 12, 12, 13


let op_str (op : Js_op.binop) =
  match op with
  | Bor     -> "|"
  | Bxor    -> "^"
  | Band    -> "&"
  | Lsl     -> "<<"
  | Lsr     -> ">>>"
  | Asr     -> ">>"
  | Plus    -> "+"
  | Minus   -> "-"
  | Mul     -> "*"
  | Div     -> "/"
  | Mod     -> "%"

  | Eq      -> "="
  | Or      -> "||"
  | And     -> "&&"
  | EqEqEq  -> "==="
  | NotEqEq -> "!=="
  | Lt      -> "<"
  | Le      -> "<="
  | Gt      -> ">"
  | Ge      -> ">="
  | InstanceOf -> "instanceof"

let op_int_str (op : Js_op.int_op) = 
  match op with
  | Bor     -> "|"
  | Bxor    -> "^"
  | Band    -> "&"
  | Lsl     -> "<<"
  | Lsr     -> ">>>"
  | Asr     -> ">>"
  | Plus    -> "+"
  | Minus   -> "-"
  | Mul     -> "*"
  | Div     -> "/"
  | Mod     -> "%"
  
let str_of_used_stats x = 
  match (x : Js_op.used_stats) with
  | Js_op.Dead_pure ->  "Dead_pure"
  | Dead_non_pure -> "Dead_non_pure"
  | Exported -> "Exported" 
  | Once_pure -> "Once_pure"
  | Used -> "Used"
  | Scanning_pure -> "Scanning_pure"
  | Scanning_non_pure -> "Scanning_non_pure"
  | NA -> "NA"

let update_used_stats (ident_info : J.ident_info) used_stats = 
  match ident_info.used_stats with 
  | Dead_pure | Dead_non_pure | Exported  -> ()
  | Scanning_pure 
  | Scanning_non_pure
  | Used
  | Once_pure
  | NA  -> 
    ident_info.used_stats <- used_stats

let same_kind (x : Js_op.kind) (y : Js_op.kind)  =
  match x , y with
  | Ml, Ml
  | Runtime, Runtime -> true
  | External (u : string), External v ->  u = v 
  | _, _ -> false

let same_str_opt ( x : string option  ) (y : string option) = 
  match x ,y with
  | None, None -> true
  | Some x0, Some y0 -> x0 = y0
  | None, Some _ 
  | Some _ , None 
    -> false 
  
let same_vident (x : J.vident) (y : J.vident) = 
  match x, y with 
  | Id x0, Id y0 -> Ident.same x0 y0
  | Qualified(x0,k0,str_opt0), Qualified(y0,k1,str_opt1) -> 
      Ident.same x0 y0 && same_kind k0 k1 && same_str_opt str_opt0 str_opt1
  | Id _, Qualified _ 
  | Qualified _, Id _ -> false

let of_lam_mutable_flag (x : Asttypes.mutable_flag)  : Js_op.mutable_flag = 
  match x with 
  | Immutable -> Immutable
  | Mutable -> Mutable

end
module Lam_compile_util : sig 
#1 "lam_compile_util.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)









(** Some utilities for lambda compilation*)

val jsop_of_comp : Lambda.comparison -> Js_op.binop

val comment_of_tag_info : Lambda.tag_info -> string option

val comment_of_pointer_info : Lambda.pointer_info -> string option

end = struct
#1 "lam_compile_util.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)










let jsop_of_comp (cmp : Lambda.comparison) : Js_op.binop = 
  match cmp with 
  | Ceq -> EqEqEq (* comparison*)
  | Cneq -> NotEqEq
  | Clt -> Lt 
  | Cgt  -> Gt 
  | Cle -> Le 
  | Cge  -> Ge

let comment_of_tag_info  (x : Lambda.tag_info) = 
  match x with 
  | Blk_constructor (n, _) -> Some n 
  | Blk_tuple -> Some "tuple"
  | Blk_variant x -> Some ("`" ^  x)
  | Blk_record _ -> Some "record"

  | Blk_array -> Some "array"
  | Blk_module _ ->  
     (* Turn it on next time to save some noise diff*)
    Some "module"
  | Blk_na -> None 
let comment_of_pointer_info (x :  Lambda.pointer_info)= 
  match x with 
  | Pt_constructor x -> Some x 
  | Pt_variant x -> Some x 
  | Lambda.Pt_module_alias -> None (* FIXME *)
  | Pt_na -> None

end
module Js_exp_make : sig 
#1 "js_exp_make.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Creator utilities for the [J] module *) 






(** check if a javascript ast is constant 

    The better signature might be 
    {[
      J.expresssion -> Js_output.t
    ]}
    for exmaple
    {[
      e ?print_int(3) :  0
                         --->
                         if(e){print_int(3)}
    ]}
*)
type t = J.expression 
val extract_non_pure : t -> t option

type binary_op =   ?comment:string -> t -> t -> t 

type unary_op =  ?comment:string -> t -> t





val bin : ?comment:string -> J.binop -> t -> t -> t
val mk :
  ?comment:string -> J.expression_desc -> t

val access : binary_op

val string_access : binary_op

val var : ?comment:string  -> J.ident -> t 

val runtime_var_dot : ?comment:string -> string -> string -> t

val runtime_var_vid : string -> string -> J.vident

val ml_var_dot : ?comment:string -> Ident.t -> string -> t

val external_var_dot : ?comment:string -> Ident.t -> string -> string option -> t



val ml_var : ?comment:string -> Ident.t -> t

val runtime_call : ?comment:string -> string -> string -> t list -> t
val public_method_call : string -> t -> t -> Int32.t -> t list -> t
val runtime_ref : string -> string -> t

val str : ?pure:bool -> ?comment:string -> string -> t 

val ocaml_fun : ?comment:string ->
  ?immutable_mask:bool array -> J.ident list -> J.block -> t

val method_ : ?comment:string ->
  ?immutable_mask:bool array -> J.ident list -> J.block -> t

val econd : ?comment:string -> t -> t -> t -> t

val int : ?comment:string -> ?c:char ->  int32 -> t 
val nint : ?comment:string -> nativeint -> t 
val small_int : int -> t
val float : ?comment:string -> string -> t

(* TODO: we can do hash consing for small integers *)
val zero_int_literal : t
val one_int_literal : t
val zero_float_lit : t 
val obj_int_tag_literal : t

(** [is_out e range] is equivalent to [e > range or e <0]

*)
val is_out : binary_op
val dot : ?comment:string -> t -> string -> t

val array_length : unary_op

val string_length : unary_op

val string_of_small_int_array : unary_op

val bytes_length :  unary_op

val function_length : unary_op

val char_of_int : unary_op

val char_to_int : unary_op

val array_append : binary_op

val array_copy : unary_op
val string_append : binary_op
(**
   When in ES6 mode, we can use Symbol to guarantee its uniquess,
   we can not tag [js] object, since it can be frozen 
*)



val var_dot : ?comment:string -> Ident.t -> string -> t
val bind_var_call : ?comment:string -> Ident.t -> string -> t list -> t 
val bind_call : ?comment:string -> J.expression -> string -> J.expression list -> t
val js_global_dot : ?comment:string -> string -> string -> t

val index : ?comment:string -> t -> Int32.t -> t

(** if the expression is a temporay block which has no side effect,
    write to it does not really make sense, optimize it away *)
val index_addr : ?comment:string -> yes:(t -> t) -> no:t -> t -> Js_op.jsint -> t

val assign :  binary_op

val triple_equal : binary_op
(* TODO: reduce [triple_equal] use *)    

val float_equal : binary_op
val int_equal : binary_op
val string_equal : binary_op    
val is_type_number : unary_op
val typeof : unary_op

val to_int32 : unary_op
val to_uint32 : unary_op

val unchecked_int32_add : binary_op
val int32_add : binary_op
val unchecked_int32_minus : binary_op
val int32_minus : binary_op
val int32_mul : binary_op
val unchecked_int32_mul : binary_op

val int32_div : checked:bool -> binary_op
val int32_mod : checked:bool -> binary_op

val int32_lsl : binary_op
val int32_lsr : binary_op
val int32_asr : binary_op

val int32_bxor : binary_op
val int32_band : binary_op
val int32_bor : binary_op

val float_add : binary_op
val float_minus : binary_op
val float_mul : binary_op
val float_div : binary_op
val float_notequal : binary_op
val float_mod : binary_op  

val int_comp : Lambda.comparison -> binary_op
val string_comp : Js_op.binop -> binary_op
val float_comp :  Lambda.comparison -> binary_op



val not : t -> t

val call : ?comment:string  -> info:Js_call_info.t -> t -> t list -> t 

val flat_call : binary_op

val dump : ?comment:string -> Js_op.level -> t list -> t

val anything_to_string : unary_op

(** see {!https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Unary_plus}*)
val to_number : unary_op
val int_to_string : unary_op
val to_json_string : unary_op

val new_ : ?comment:string -> J.expression -> J.expression list -> t

val arr : ?comment:string -> J.mutable_flag -> J.expression list -> t

val make_block : 
  ?comment:string ->
  J.expression -> J.tag_info -> J.expression list -> J.mutable_flag -> t

val uninitialized_object : 
  ?comment:string -> J.expression -> J.expression -> t

val uninitialized_array : unary_op

val seq : binary_op

val obj : ?comment:string -> J.property_map -> t 

val caml_true : t 

val caml_false : t

val bool : bool -> t



val unit :   t
(** [unit] in ocaml will be compiled into [0]  in js *)

val js_var : ?comment:string -> string -> t

val js_global : ?comment:string -> string -> t

val undefined : t
val is_caml_block : ?comment:string -> t -> t
val math : ?comment:string -> string -> t list -> t
(** [math "abs"] --> Math["abs"] *)    





val tag : ?comment:string -> J.expression -> t
val set_tag : ?comment:string -> J.expression -> J.expression -> t

(** Note that this is coupled with how we encode block, if we use the 
    `Object.defineProperty(..)` since the array already hold the length,
    this should be a nop 
*)

val set_length : ?comment:string -> J.expression -> J.expression -> t
val obj_length : ?comment:string -> J.expression -> t
val to_ocaml_boolean : unary_op

val and_ : binary_op
val or_ : binary_op

(** we don't expose a general interface, since a general interface is generally not safe *)
val is_instance_array  : unary_op
(** used combined with [caml_update_dummy]*)
val dummy_obj : ?comment:string ->  unit -> t 

(** convert a block to expresion by using IIFE *)    
val of_block : ?comment:string -> ?e:J.expression -> J.statement list -> t

val bind : binary_op

val raw_js_code : ?comment:string -> J.code_info ->  string -> t

val nil : t 
val is_nil : unary_op

val js_bool :  ?comment:string -> bool -> t 
val is_undef : unary_op

val not_implemented : ?comment:string -> string -> t

end = struct
#1 "js_exp_make.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






let no_side_effect = Js_analyzer.no_side_effect_expression

type binary_op =   ?comment:string -> J.expression -> J.expression -> J.expression 
type unary_op =  ?comment:string -> J.expression -> J.expression
(*
  remove pure part of the expression
  and keep the non-pure part while preserve the semantics 
  (modulo return value)
 *)
let rec extract_non_pure (x : J.expression)  = 
  match x.expression_desc with 
  | Var _
  | Str _
  | Number _ -> None (* Can be refined later *)
  | Access (a,b) -> 
    begin match extract_non_pure a , extract_non_pure b with 
      | None, None -> None
      | _, _ -> Some x 
    end
  | Array (xs,_mutable_flag)  ->
    if List.for_all (fun x -> extract_non_pure x = None)  xs then
      None 
    else Some x 
  | Seq (a,b) -> 
    begin match extract_non_pure a , extract_non_pure b with 
      | None, None  ->  None
      | Some u, Some v ->  
        Some { x with expression_desc =  Seq(u,v)}
      (* may still have some simplification*)
      | None, (Some _ as v) ->  v
      | (Some _ as u), None -> u 
    end
  | _ -> Some x 

type t = J.expression 

let mk ?comment exp : t = 
  {expression_desc = exp ; comment  }

let var ?comment  id  : t = 
  {expression_desc = Var (Id id); comment }

let runtime_var_dot ?comment (x : string)  (e1 : string) : J.expression = 
  {expression_desc = 
     Var (Qualified(Ext_ident.create_js x,Runtime, Some e1)); comment }

let runtime_var_vid  x  e1 : J.vident = 
  Qualified(Ext_ident.create_js x,Runtime, Some e1)

let ml_var_dot ?comment ( id  : Ident.t) e : J.expression =     
  {expression_desc = Var (Qualified(id, Ml, Some e)); comment }

let external_var_dot ?comment (id : Ident.t) name fn : t = 
  {expression_desc = Var (Qualified(id, External name,  fn)); comment }

(** 
  module as a value 
   {[
     var http = require("http")
   ]}
*)
let external_module_as_var ?comment (id : Ident.t) name : t = 
  {expression_desc = Var (Qualified(id, External name, None)); comment }

let ml_var ?comment (id : Ident.t) : t  = 
  {expression_desc = Var (Qualified (id, Ml, None)); comment}

let str ?(pure=true) ?comment s : t =  {expression_desc = Str (pure,s); comment}

let raw_js_code ?comment info s : t =
  {expression_desc = Raw_js_code (s,info) ; comment }

let anything_to_string ?comment (e : t) : t =  
  match e.expression_desc with 
  | Str _ -> e 
  | _ -> {expression_desc = Anything_to_string e ; comment}

let arr ?comment mt es : t  = 
  {expression_desc = Array (es,mt) ; comment}

let sep = " : "
let merge_outer_comment comment (e : t )  = 
  match e.comment with
  | None -> {e with comment = Some comment}
  | Some s -> { e with 
                comment 
                = Some (comment ^ sep ^ s)} 

let make_block ?comment tag tag_info es mutable_flag : t = 
  let comment = 
    match comment with 
    | None -> Lam_compile_util.comment_of_tag_info tag_info 
    | _ -> comment in
  let es = 
    match tag_info with 
    | Blk_record des 
      when Array.length des <> 0 
      -> 
      List.mapi (fun i (e : t) -> merge_outer_comment des.(i) e) es
    (* TODO: may overriden its previous comments *)
    | Blk_module (Some des) 
      ->  List.map2  merge_outer_comment 
            des es
    | _ -> es 
  in
  {
    expression_desc = Caml_block( es, mutable_flag, tag,tag_info) ;
    comment 
  }    

let uninitialized_object ?comment tag size : t = 
  { expression_desc = Caml_uninitialized_obj(tag,size); comment }

let uninitialized_array ?comment (e : t) : t  = 
  match e.expression_desc with 
  | Number (Int {i = 0l; _}) -> arr ?comment NA []
  | _ -> {comment; expression_desc = Array_of_size e}


module L = Literals
(* Invariant: this is relevant to how we encode string
*)           
let typeof ?comment (e : t) : t = 
  match e.expression_desc with 
  | Number _ 
  | Length _ 
    -> str ?comment L.js_type_number
  | Str _ 
    -> str ?comment L.js_type_string
  | Array _
    -> str ?comment L.js_type_object
  | _ -> {expression_desc = Typeof e ; comment }




let new_ ?comment e0 args : t = 
  { expression_desc = New (e0,  Some args ); comment}


let unit   : t = 
  {expression_desc = Number (Int {i = 0l; c = None}) ; comment = Some "()" }



let math ?comment v args  : t = 
  {comment ; expression_desc = Math(v,args)}

(* we can do constant folding here, but need to make sure the result is consistent
   {[
     let f x = string_of_int x        
     ;; f 3            
   ]}     
   {[
     string_of_int 3
   ]}
*)
let int_to_string ?comment (e : t) : t = 
  anything_to_string ?comment e 

(* Attention: Shared *mutable state* is evil, [Js_fun_env.empty] is a mutable state ..
*)    

let ocaml_fun 
    ?comment  
    ?immutable_mask
    params block  : t = 
  let len = List.length params in
  {
    expression_desc = 
      Fun (false, params,block, Js_fun_env.empty ?immutable_mask len ); 
    comment
  }

let method_
    ?comment  
    ?immutable_mask
    params block  : t = 
  let len = List.length params in
  {
    expression_desc = 
      Fun (true, params,block, Js_fun_env.empty ?immutable_mask len ); 
    comment
  }


let dummy_obj ?comment ()  : t = 
  {comment  ; expression_desc = Object []}

let is_instance_array ?comment e : t = 
  {comment; expression_desc = Bin(InstanceOf, e , str L.js_array_ctor) }

(* TODO: complete 
    pure ...
*)        
let rec seq ?comment (e0 : t) (e1 : t) : t = 
  match e0.expression_desc, e1.expression_desc with 
  | (Seq( a, {expression_desc = Number _ ;  })
    | Seq( {expression_desc = Number _ ;  },a)), _
    -> 
    seq ?comment a e1
  | _, ( Seq( {expression_desc = Number _ ;  }, a)) -> 
    (* Return value could not be changed*)
    seq ?comment e0 a
  | _, ( Seq(a,( {expression_desc = Number _ ;  } as v ) ))-> 
    (* Return value could not be changed*)
    seq ?comment (seq  e0 a) v

  | _ -> 
    {expression_desc = Seq(e0,e1); comment}


let zero_int_literal : t =   
  {expression_desc = Number (Int {i = 0l; c = None}) ; comment = None}
let one_int_literal : t = 
  {expression_desc = Number (Int {i = 1l; c = None}) ; comment = None}
let two_int_literal : t = 
  {expression_desc = Number (Int {i = 2l; c = None}) ; comment = None}
let three_int_literal : t = 
  {expression_desc = Number (Int {i = 3l; c = None}) ; comment = None}
let four_int_literal : t =   
  {expression_desc = Number (Int {i = 4l; c = None}) ; comment = None}
let five_int_literal : t = 
  {expression_desc = Number (Int {i = 5l; c = None}) ; comment = None}
let six_int_literal : t = 
  {expression_desc = Number (Int {i = 6l; c = None}) ; comment = None}
let seven_int_literal : t = 
  {expression_desc = Number (Int {i = 7l; c = None}) ; comment = None}
let eight_int_literal : t = 
  {expression_desc = Number (Int {i = 8l; c = None}) ; comment = None}
let nine_int_literal : t = 
  {expression_desc = Number (Int {i = 9l; c = None}) ; comment = None}

let obj_int_tag_literal : t =
  {expression_desc = Number (Int {i = 248l; c = None}) ; comment = None}

(* let small_int_array = Array.create 100  None *)


let int ?comment ?c  i : t = 
  {expression_desc = Number (Int {i; c}) ; comment}

let small_int i : t = 
  match i with 
  | 0 -> zero_int_literal
  | 1 -> one_int_literal
  | 2 -> two_int_literal
  | 3 -> three_int_literal
  | 4 -> four_int_literal
  | 5 -> five_int_literal
  | 6 -> six_int_literal
  | 7 -> seven_int_literal
  | 8 -> eight_int_literal
  | 9 -> nine_int_literal
  | 248 -> obj_int_tag_literal
  | i -> int (Int32.of_int i) 


let access ?comment (e0 : t)  (e1 : t) : t = 
  match e0.expression_desc, e1.expression_desc with
  | Array (l,_mutable_flag) , Number (Int {i; _}) when no_side_effect e0-> 
    List.nth l  (Int32.to_int i)  (* Float i -- should not appear here *)
  | _ ->
    { expression_desc = Access (e0,e1); comment} 

let string_access ?comment (e0 : t)  (e1 : t) : t = 
  match e0.expression_desc, e1.expression_desc with
  | Str (_,s) , Number (Int {i; _}) 
    -> 
    let i = Int32.to_int i  in
    if i >= 0 && i < String.length s then 
      (* TODO: check exception when i is out of range..
         RangeError?
      *)
      str (String.make 1 s.[i])
    else     { expression_desc = String_access (e0,e1); comment} 
  | _ ->
    { expression_desc = String_access (e0,e1); comment} 

let index ?comment (e0 : t)  e1 : t = 
  match e0.expression_desc with
  | Array (l,_mutable_flag)  when no_side_effect e0 -> 
    List.nth l  (Int32.to_int e1)  (* Float i -- should not appear here *)
  | Caml_block (l,_mutable_flag, _, _)  when no_side_effect e0 -> 
    List.nth l  (Int32.to_int e1)  (* Float i -- should not appear here *)
  | _ -> { expression_desc = Access (e0, int ?comment e1); comment = None} 


let index_addr ?comment ~yes ~no (e0 : t)  e1 : t = 
  match e0.expression_desc with
  | Array (l,_mutable_flag)  when no_side_effect e0 -> 
    no
  | Caml_block (l,_mutable_flag, _, _)  when no_side_effect e0 -> 
    no
  | _ ->
    yes ({ expression_desc = Access (e0, int ?comment e1); comment = None} : t) 

let call ?comment ~info e0 args : t = 
  {expression_desc = Call(e0,args,info); comment }

let flat_call ?comment e0 es : t = 
  (* TODO: optimization when es is known at compile time
      to be an array
  *)
  {expression_desc = FlatCall (e0,es); comment }

(* Dot .....................**)        
let runtime_call ?comment module_name fn_name args = 
  call ?comment 
    ~info:Js_call_info.builtin_runtime_call
    (runtime_var_dot  module_name fn_name) args

let runtime_ref module_name fn_name = 
  runtime_var_dot  module_name fn_name


(* only used in property access, 
    Invariant: it should not call an external module .. *)
let js_var ?comment  (v : string) =
  var ?comment (Ext_ident.create_js v )

let js_global ?comment  (v : string) =
  var ?comment (Ext_ident.create_js v )

(** used in normal property
    like [e.length], no dependency introduced
*)
let dot ?comment (e0 : t)  (e1 : string) : t = 
  { expression_desc = Dot (e0,  e1, true); comment} 


let undefined  = var Ext_ident.undefined
let nil = var Ext_ident.nil

(** coupled with the runtime *)
let is_caml_block ?comment (e : t) : t = 
  {expression_desc = Bin ( NotEqEq, dot e L.js_prop_length , undefined); 
   comment}

(* This is a property access not external module *)

let array_length ?comment (e : t) : t = 
  match e.expression_desc with 
  (* TODO: use array instead? *)
  | (Array (l, _) | Caml_block(l,_,_,_)) when no_side_effect e 
    -> int ?comment (Int32.of_int (List.length l))
  | _ -> { expression_desc = Length (e, Array) ; comment }

let string_length ?comment (e : t) : t =
  match e.expression_desc with 
  | Str(_,v) -> int ?comment (Int32.of_int (String.length v))
  | _ -> { expression_desc = Length (e, String) ; comment }

let bytes_length ?comment (e : t) : t = 
  match e.expression_desc with 
  (* TODO: use array instead? *)
  | Array (l, _) -> int ?comment (Int32.of_int (List.length l))
  | Str(_,v) -> int ?comment (Int32.of_int @@ String.length v)
  | _ -> { expression_desc = Length (e, Bytes) ; comment }

let function_length ?comment (e : t) : t = 
  match e.expression_desc with 
  | Fun(b, params, _, _) -> 
    let params_length = 
      List.length params in
    int ?comment 
      (Int32.of_int 
         (if b then params_length - 1 
          else params_length))
  (* TODO: optimize if [e] is know at compile time *)
  | _ -> { expression_desc = Length (e, Function) ; comment }

(** no dependency introduced *)
let js_global_dot ?comment (x : string)  (e1 : string) : t = 
  { expression_desc = Dot (js_var x,  e1, true); comment} 

let char_of_int ?comment (v : t) : t = 
  match v.expression_desc with
  | Number (Int {i; _}) ->
    str  (String.make 1(Char.chr (Int32.to_int i)))
  | Char_to_int v -> v 
  | _ ->  {comment ; expression_desc = Char_of_int v}

let char_to_int ?comment (v : t) : t = 
  match v.expression_desc with 
  | Str (_, x) ->
    assert (String.length x = 1) ;
    int ~comment:(Printf.sprintf "%S"  x )  
      (Int32.of_int @@ Char.code x.[0])
  | Char_of_int v -> v 
  | _ -> {comment; expression_desc = Char_to_int v }

let array_append ?comment e el : t = 
  { comment ; expression_desc = Array_append (e, el)}

let array_copy ?comment e : t = 
  { comment ; expression_desc = Array_copy e}

(* Note that this return [undefined] in JS, 
    it should be wrapped to avoid leak [undefined] into 
    OCaml
*)    
let dump ?comment level el : t = 
  {comment ; expression_desc = Dump(level,el)}

let to_json_string ?comment e : t = 
  { comment; expression_desc = Json_stringify e }

let rec string_append ?comment (e : t) (el : t) : t = 
  match e.expression_desc , el.expression_desc  with 
  | Str(_,a), String_append ({expression_desc = Str(_,b)}, c) ->
    string_append ?comment (str (a ^ b)) c 
  | String_append (c,{expression_desc = Str(_,b)}), Str(_,a) ->
    string_append ?comment c (str (b ^ a))
  | String_append (a,{expression_desc = Str(_,b)}),
    String_append ({expression_desc = Str(_,c)} ,d) ->
    string_append ?comment (string_append a (str (b ^ c))) d 
  | Str (_,a), Str (_,b) -> str ?comment (a ^ b)
  | _, Anything_to_string b -> string_append ?comment e b 
  | Anything_to_string b, _ -> string_append ?comment b el
  | _, _ -> {comment ; expression_desc = String_append(e,el)}


let obj ?comment properties : t = 
  {expression_desc = Object properties; comment }

(* currently only in method call, no dependency introduced
*)
let var_dot ?comment (x : Ident.t)  (e1 : string) : t = 
  {expression_desc = Dot (var x,  e1, true); comment} 


let bind_call ?comment obj  (e1 : string) args  : t = 
  call ~info:Js_call_info.dummy {expression_desc = 
     Bind ({expression_desc = Dot (obj,  e1, true); comment} , obj);
   comment = None } args 

let bind_var_call ?comment (x : Ident.t)  (e1 : string) args  : t = 
  let obj =  var x in 
  call ~info:Js_call_info.dummy {expression_desc = 
     Bind ({expression_desc = Dot (obj,  e1, true); comment} , obj);
   comment = None } args 


(* Dot .....................**)        




let assign ?comment e0 e1 : t = {expression_desc = Bin(Eq, e0,e1); comment}


(** Convert a javascript boolean to ocaml boolean
    It's necessary for return value
     this should be optmized away for [if] ,[cond] to produce 
    more readable code
*)         
let to_ocaml_boolean ?comment (e : t) : t = 
  match e.expression_desc with 
  | Int_of_boolean _
  | Number _ -> e 
  | _ -> {comment ; expression_desc = Int_of_boolean e}

let to_number ?comment (e : t) : t = 
  match e.expression_desc with 
  | Int_of_boolean _
  | Anything_to_number _
  | Number _ -> e 
  | _ -> {comment ; expression_desc = Anything_to_number e}

let caml_true  = int ~comment:"true" 1l (* var (Jident.create_js "true") *)

let caml_false  = int ~comment:"false" 0l

let bool v = if  v then caml_true else caml_false

let rec triple_equal ?comment (e0 : t) (e1 : t ) : t = 
  match e0.expression_desc, e1.expression_desc with
  | Var (Id ({name = "undefined"|"null"; } as id)), 
    (Char_of_int _ | Char_to_int _ 
    | Bool _ | Number _ | Typeof _ | Int_of_boolean _ 
    | Fun _ | Array _ | Caml_block _ )
    when Ext_ident.is_js id && no_side_effect e1 -> 
    caml_false (* TODO: rename it as [caml_false] *)
  | 
    (Char_of_int _ | Char_to_int _ 
    | Bool _ | Number _ | Typeof _ | Int_of_boolean _ 
    | Fun _ | Array _ | Caml_block _ ),  Var (Id ({name = "undefined"|"null"; } as id))
    when Ext_ident.is_js id && no_side_effect e0 -> 
    caml_false
  | Str (_,x), Str (_,y) ->  (* CF*)
    bool (Ext_string.equal x y)
  | Char_to_int a , Char_to_int b -> 
    triple_equal ?comment a b 
  | Char_to_int a , Number (Int {i; c = Some v}) 
  | Number (Int {i; c = Some v}), Char_to_int a  -> 
    triple_equal ?comment a (str (String.make 1 v))
  | Number (Int {i = i0; _}), Number (Int {i = i1; _}) 
    -> 
    bool (i0 = i1)      
  | Char_of_int a , Char_of_int b -> 
    triple_equal ?comment a b 
  | _ -> 
    to_ocaml_boolean  {expression_desc = Bin(EqEqEq, e0,e1); comment}


(** Arith operators *)
(* Dot .....................**)        

let float ?comment f : t = 
  {expression_desc = Number (Float {f}); comment}

let zero_float_lit : t = 
  {expression_desc = Number (Float {f = "0." }); comment = None}


let float_mod ?comment e1 e2 : J.expression = 
  { comment ; 
    expression_desc = Bin (Mod, e1,e2)
  }

let bin ?comment (op : J.binop) e0 e1 : t =
  match op with
  | EqEqEq -> triple_equal ?comment e0 e1
  | _ -> {expression_desc = Bin(op,e0,e1); comment}

(* TODO: Constant folding, Google Closure will do that?,
   Even if Google Clsoure can do that, we will see how it interact with other
   optimizations
   We wrap all boolean functions here, since OCaml boolean is a 
   bit different from Javascript, so that we can change it in the future
*)
let rec and_ ?comment (e1 : t) (e2 : t) = 
  match e1.expression_desc, e2.expression_desc with 
  (* | (Bin (NotEqEq, e1,  *)
  (*         {expression_desc = Var (Id ({name = "undefined"; _} as id))}) *)
  (*   | Bin (NotEqEq,  *)
  (*          {expression_desc = Var (Id ({name = "undefined"; _} as id))},  *)
  (*          e1) *)
  (*   ),  *)
  (*   _ when Ext_ident.is_js id ->  *)
  (*   and_ e1 e2 *)
  |  Int_of_boolean e1 , Int_of_boolean e2 -> 
    and_ ?comment e1 e2
  |  Int_of_boolean e1 , _ -> and_ ?comment e1 e2
  | _,  Int_of_boolean e2
    -> and_ ?comment e1 e2
  (* optimization if [e1 = e2], then and_ e1 e2 -> e2
     be careful for side effect        
  *)
  | Var i, Var j when Js_op_util.same_vident  i j 
    -> 
    to_ocaml_boolean e1
  | Var i, 
    (Bin (And,   {expression_desc = Var j ; _}, _) 
    | Bin (And ,  _, {expression_desc = Var j ; _}))
    when Js_op_util.same_vident  i j 
    ->
    to_ocaml_boolean e2          
  | _, _ ->     
    to_ocaml_boolean { expression_desc = Bin(And, e1,e2) ; comment }
    (* to_ocaml_boolean @@ bin ?comment And e1 e2  *)

let rec or_ ?comment (e1 : t) (e2 : t) = 
  match e1.expression_desc, e2.expression_desc with 
  | Int_of_boolean e1 , Int_of_boolean e2
    -> 
    or_ ?comment e1 e2
  | Int_of_boolean e1 , _  -> or_ ?comment e1 e2
  | _,  Int_of_boolean e2
    -> or_ ?comment e1 e2
  | Var i, Var j when Js_op_util.same_vident  i j 
    -> 
    to_ocaml_boolean e1
  | Var i, 
    (Bin (Or,   {expression_desc = Var j ; _}, _) 
    | Bin (Or ,  _, {expression_desc = Var j ; _}))
    when Js_op_util.same_vident  i j 
    -> to_ocaml_boolean e2          
  | _, _ ->     
    to_ocaml_boolean {expression_desc = Bin(Or, e1,e2); comment }
    (* to_ocaml_boolean @@ bin ?comment Or e1 e2  *)

(* return a value of type boolean *)
(* TODO: 
     when comparison with Int
     it is right that !(x > 3 ) -> x <= 3 *)
let rec not ({expression_desc; comment} as e : t) : t =
  match expression_desc with 
  | Bin(EqEqEq , e0,e1)
    -> {expression_desc = Bin(NotEqEq, e0,e1); comment}
  | Bin(NotEqEq , e0,e1) -> {expression_desc = Bin(EqEqEq, e0,e1); comment}

  (* Note here the compiled js use primtive comparison only 
     for *primitive types*, so it is safe to do such optimization,
     for generic comparison, this does not hold        
  *)
  | Bin(Lt, a, b) -> {e with expression_desc = Bin (Ge,a,b)}
  | Bin(Ge,a,b) -> {e with expression_desc = Bin (Lt,a,b)}          
  | Bin(Le,a,b) -> {e with expression_desc = Bin (Gt,a,b)}
  | Bin(Gt,a,b) -> {e with expression_desc = Bin (Le,a,b)}

  | Number (Int {i; _}) -> 
    if i <> 0l then caml_false else caml_true
  | Int_of_boolean  e -> not e
  | Not e -> e 
  | x -> {expression_desc = Not e ; comment = None}

let rec econd ?comment (b : t) (t : t) (f : t) : t = 
  match b.expression_desc , t.expression_desc, f.expression_desc with

  | Number ((Int { i = 0l; _}) ), _, _ 
    -> f  (* TODO: constant folding: could be refined *)
  | (Number _ | Array _ | Caml_block _), _, _ when no_side_effect b 
    -> t  (* a block can not be false in OCAML, CF - relies on flow inference*)

  | Bool true, _, _ -> t 
  | Bool false,  _, _ -> f
  | (Bin (Bor, v , {expression_desc = Number (Int {i = 0l ; _})})), _, _
    -> econd v t f 
  (* TODO: could be more non undefined cases 
     check [caml_obj_is_block]
     acutally we should avoid introducing undefined
     as much as we can, this kind of inlining and mirco-optimization
     can be done after we can inline runtime in the future 
  *)
  (* | Bin (NotEqEq, ({expression_desc = Length _; _} as e1) , *)
  (*        {expression_desc = Var (Id ({name = "undefined"; _} as id))}), *)
  (*   _, _  *)
  (*   when Ext_ident.is_js id -> *)
  (*   econd e1 t f *)

  | ((Bin ((EqEqEq, {expression_desc = Number (Int { i = 0l; _}); _},x)) 
     | Bin (EqEqEq, x,{expression_desc = Number (Int { i = 0l; _});_}))), _, _ 
    -> 
    econd ?comment x f t 

  | (Bin (Ge, 
          ({expression_desc = Length _ ;
            _}), {expression_desc = Number (Int { i = 0l ; _})})), _, _ 
    -> f

  | (Bin (Gt, 
          ({expression_desc = Length _;
            _} as pred ), {expression_desc = Number (Int {i = 0l; })})), _, _
    ->
    (** Add comment when simplified *)
    econd ?comment pred t f 

  | _, (Cond (p1, branch_code0, branch_code1)), _
    when Js_analyzer.eq_expression branch_code1 f
    ->
    (* {[
         if b then (if p1 then branch_code0 else branch_code1)
         else branch_code1         
       ]}
       is equivalent to         
       {[
         if b && p1 then branch_code0 else branch_code1           
       ]}         
    *)      
    econd (and_ b p1) branch_code0 f
  | _, (Cond (p1, branch_code0, branch_code1)), _
    when Js_analyzer.eq_expression branch_code0 f
    ->
    (* the same as above except we revert the [cond] expression *)      
    econd (and_ b (not p1)) branch_code1 f

  | _, _, (Cond (p1', branch_code0, branch_code1))
    when Js_analyzer.eq_expression t branch_code0 
    (*
       {[
         if b then branch_code0 else (if p1' then branch_code0 else branch_code1)           
       ]}         
       is equivalent to         
       {[
         if b or p1' then branch_code0 else branch_code1           
       ]}         
    *)
    ->
    econd (or_ b p1') t branch_code1
  | _, _, (Cond (p1', branch_code0, branch_code1))
    when Js_analyzer.eq_expression t branch_code1
    ->
    (* the same as above except we revert the [cond] expression *)      
    econd (or_ b (not p1')) t branch_code0

  | Not e, _, _ -> econd ?comment e f t 
  | Int_of_boolean  b, _, _  -> econd ?comment  b t f

  | _ -> 
    if Js_analyzer.eq_expression t f then
      if no_side_effect b then t else seq  ?comment b t
    else
      {expression_desc = Cond(b,t,f); comment}


let rec float_equal ?comment (e0 : t) (e1 : t) : t = 
  match e0.expression_desc, e1.expression_desc with     
  | Number (Int {i = i0 ; _}), Number (Int {i = i1; }) -> 
    bool (i0 = i1)
  | (Bin(Bor, 
         {expression_desc = Number(Int {i = 0l; _})}, 
         ({expression_desc = Caml_block_tag _; _} as a ))
    |
      Bin(Bor, 
          ({expression_desc = Caml_block_tag _; _} as a),
          {expression_desc = Number (Int {i = 0l; _})})), 
    Number (Int {i = 0l; _})
    ->  (** (x.tag | 0) === 0  *)
    not  a     
  | (Bin(Bor, 
         {expression_desc = Number(Int {i = 0l; _})}, 
         ({expression_desc = Caml_block_tag _; _} as a ))
    |
      Bin(Bor, 
          ({expression_desc = Caml_block_tag _; _} as a),
          {expression_desc = Number (Int {i = 0l; _})}))
  , Number _  ->  (* for sure [i <> 0 ]*)
    (* since a is integer, if we guarantee there is no overflow 
       of a
       then [a | 0] is a nop unless a is undefined
       (which is applicable when applied to tag),
       obviously tag can not be overflowed. 
       if a is undefined, then [ a|0===0 ] is true 
       while [a === 0 ] is not true
       [a|0 === non_zero] is false and [a===non_zero] is false
       so we can not eliminate when the tag is zero          
    *)
    float_equal ?comment a e1
  | Number (Float {f = f0; _}), Number (Float {f = f1 ; }) when f0 = f1 -> 
    caml_true

  | Char_to_int a , Char_to_int b ->
    float_equal ?comment a b
  | Char_to_int a , Number (Int {i; c = Some v})
  | Number (Int {i; c = Some v}), Char_to_int a  ->
    float_equal ?comment a (str (String.make 1 v))
  | Char_of_int a , Char_of_int b ->
    float_equal ?comment a b

  | _ ->  
    to_ocaml_boolean {expression_desc = Bin(EqEqEq, e0,e1); comment}


let int_equal = float_equal 
let rec string_equal ?comment (e0 : t) (e1 : t) : t = 
  match e0.expression_desc, e1.expression_desc with     
  | Str (_, a0), Str(_, b0) 
    -> bool  (Ext_string.equal a0 b0)
  | _ , _ 
    ->
    to_ocaml_boolean {expression_desc = Bin(EqEqEq, e0,e1); comment}     


let is_type_number ?comment (e : t) : t = 
  string_equal ?comment (typeof e) (str "number")    


let string_of_small_int_array ?comment xs : t = 
  {expression_desc = String_of_small_int_array xs; comment}



(* we are calling [Caml_primitive.primitive_name], since it's under our
   control, we should make it follow the javascript name convention, and
   call plain [dot]
*)          

let null ?comment () =     
  js_global ?comment "null"

let tag ?comment e : t = 
  {expression_desc = 
     Bin (Bor, {expression_desc = Caml_block_tag e; comment }, zero_int_literal );
   comment = None }    


let bind ?comment fn obj  : t = 
  {expression_desc = Bind (fn, obj) ; comment }


(* according to the compiler, [Btype.hash_variant], 
   it's reduced to 31 bits for hash
*)

let public_method_call meth_name obj label cache args = 
  let len = List.length args in 
  (* econd (int_equal (tag obj ) obj_int_tag_literal) *)
  if len <= 7 then          
    runtime_call Js_config.curry 
      ("js" ^ string_of_int (len + 1) )
      (label:: ( int cache) :: obj::args)
  else 
    runtime_call Js_config.curry "js"
      [label; 
       int cache;
       obj ;  
       arr NA (obj::args)
      ]

    (* TODO: handle arbitrary length of args .. 
       we can reduce part of the overhead by using
       `__js` -- a easy ppx {{ x ##.hh }} 
       the downside is that no way to swap ocaml/js implementation 
       for object part, also need encode arity..
       how about x#|getElementById|2|
    *)
    (* ( *)
    (*   let fn = bind (dot obj meth_name) obj in *)
    (*   if len = 0 then  *)
    (*     dot obj meth_name *)
    (*     (\* Note that when no args supplied,  *)
    (*        it is not necessarily a function, [bind] *)
    (*        is dangerous *)
    (*        so if user write such code *)
    (*        {[ *)
    (*          let  u = x # say in *)
    (*          u 3               *)
    (*        ]}     *)
    (*        It's reasonable to drop [this] support        *)
    (*     *\) *)
    (*   else if len <=8 then  *)
    (*     let len_str = string_of_int len in *)
    (*     runtime_call Js_config.curry (Literals.app ^len_str)  *)
    (*       (fn ::  args) *)
    (*   else  *)
    (*     runtime_call Js_config.curry Literals.app_array            *)
    (*       [fn  ; arr NA args ]             *)
    (* ) *)

let set_tag ?comment e tag : t = 
  seq {expression_desc = Caml_block_set_tag (e,tag); comment } unit 

let set_length ?comment e tag : t = 
  seq {expression_desc = Caml_block_set_length (e,tag); comment } unit 
let obj_length ?comment e : t = 
  {expression_desc = Length (e, Caml_block); comment }

(* Note that [lsr] or [bor] are js semantics *)
let rec int32_bor ?comment (e1 : J.expression) (e2 : J.expression) : J.expression = 
  match e1.expression_desc, e2.expression_desc with 
  | Number (Int {i = i1} | Uint i1), Number (Int {i = i2})
    -> int ?comment (Int32.logor i1 i2)

  | _, (Bin(Lsr,e2, {expression_desc = Number(Int{i=0l} | Uint 0l | Nint 0n) ; _})) ->
    int32_bor  e1 e2
  | (Bin(Lsr,e1, {expression_desc = Number(Int{i=0l} | Uint 0l | Nint 0n) ; _})), _ ->
    int32_bor  e1 e2
  | (Bin(Lsr,_, {expression_desc = Number(Int{i} | Uint i ) ; _})),
    Number(Int{i=0l} | Uint 0l | Nint 0n)
    when i > 0l  -> (* a >>> 3 | 0 -> a >>> 3 *)
    e1

  | Bin (Bor, e1, {expression_desc = Number(Int{i=0l} | Uint 0l | Nint 0n) ; _} ), 
    Number(Int{i=0l} | Uint 0l | Nint 0n) ->
    int32_bor e1 e2  
  | _ -> 
    { comment ; 
      expression_desc = Bin (Bor, e1,e2)
    }

(* Arithmatic operations
   TODO: distinguish between int and float
   TODO: Note that we have to use Int64 to avoid integer overflow, this is fine
   since Js only have .

   like code below 
   {[
     MAX_INT_VALUE - (MAX_INT_VALUE - 100) + 20
   ]}

   {[
     MAX_INT_VALUE - x + 30
   ]}

   check: Re-association: avoid integer overflow
*) 
let  to_int32  ?comment (e : J.expression)  : J.expression = 
  int32_bor ?comment e zero_int_literal
(* TODO: if we already know the input is int32, [x|0] can be reduced into [x] *)
let nint ?comment n : J.expression =
  {expression_desc = Number (Nint n); comment }

let uint32 ?comment n : J.expression =
  {expression_desc = Number (Uint n); comment }



let string_comp cmp ?comment  e0 e1 = 
  to_ocaml_boolean @@ bin ?comment cmp e0 e1


let rec int_comp (cmp : Lambda.comparison) ?comment  (e0 : t) (e1 : t) = 
  match cmp, e0.expression_desc, e1.expression_desc with
  | _, Call ({
      expression_desc = 
        Var (Qualified 
               (_, Runtime, 
                Some ("caml_int_compare" | "caml_int32_compare"))); _}, 
      [l;r], _), 
    Number (Int {i = 0l})
    -> int_comp cmp l r (* = 0 > 0 < 0 *)
  | Ceq, _, _ -> int_equal e0 e1 
  | _ ->          
    to_ocaml_boolean @@ bin ?comment (Lam_compile_util.jsop_of_comp cmp) e0 e1

let float_comp cmp ?comment  e0 e1 = 
  to_ocaml_boolean @@ bin ?comment (Lam_compile_util.jsop_of_comp cmp) e0 e1



let rec int32_lsr ?comment
    (e1 : J.expression) 
    (e2 : J.expression) : J.expression =
  let aux i1 i =
    uint32 (Int32.shift_right_logical i1 i) in    
  match e1.expression_desc, e2.expression_desc with
  | Number (Int { i = i1} | Uint i1 ), Number( Int {i = i2} | Uint i2)
    -> aux i1 (Int32.to_int i2)
  | Number (Nint i1), Number( Int {i = i2} | Uint i2)
    ->
    aux (Nativeint.to_int32 i1) (Int32.to_int i2)    
  | Number (Nint i1), Number (Nint i2)
    ->
    aux (Nativeint.to_int32 i1) (Nativeint.to_int i2)
  | (Bin(Lsr, _, _)), Number (Int {i = 0l} | Uint 0l | Nint 0n) 
    ->  e1 (* TODO: more opportunities here *)
  | Bin(Bor, e1, {expression_desc = Number (Int {i=0l;_} | Uint 0l | Nint 0n) ; _}),
    Number (Int {i = 0l} | Uint 0l | Nint 0n) 
    -> int32_lsr ?comment e1 e2
  | _, _ ->
     { comment ; 
       expression_desc = Bin (Lsr, e1,e2) (* uint32 *)
     }

let to_uint32 ?comment (e : J.expression)  : J.expression =
  int32_lsr ?comment e zero_int_literal


(* TODO: 
   we can apply a more general optimization here, 
   do some algebraic rewerite rules to rewrite [triple_equal]           
*)        
let rec is_out ?comment (e : t) (range : t) : t  = 
  begin match range.expression_desc, e.expression_desc with 

    | Number (Int {i = 1l}), Var _ 
      ->         
      not (or_ (triple_equal e zero_int_literal) (triple_equal e one_int_literal))                  
    | Number (Int {i = 1l}), 
      (
        Bin (Plus , {expression_desc = Number (Int {i ; _}) }, {expression_desc = Var _; _})
      | Bin (Plus, {expression_desc = Var _; _}, {expression_desc = Number (Int {i ; _}) }))
     
      ->
      not (or_ (triple_equal e (int (Int32.neg i ))) (triple_equal e (int (Int32.sub Int32.one  i))))        
    | Number (Int {i = 1l}), 
      Bin (Minus ,  ({expression_desc = Var _; _} as x), {expression_desc = Number (Int {i ; _}) })        
      ->           
      not (or_ (triple_equal x (int (Int32.add i  1l ))) (triple_equal x (int i)))        
    (* (x - i >>> 0 ) > k *)          
    | Number (Int {i = k}), 
      Bin (Minus ,  ({expression_desc = Var _; _} as x), 
           {expression_desc = Number (Int {i ; _}) })        
      ->           
      (or_ (int_comp Cgt x (int (Int32.add i  k)))  (int_comp Clt x  (int i)))
    | Number (Int {i = k}), Var _  
      -> 
      (* Note that js support [ 1 < x < 3], 
         we can optimize it into [ not ( 0<= x <=  k)]           
      *)        
      or_ (int_comp Cgt e (int ( k)))  (int_comp Clt e  zero_int_literal)

    | _, Bin (Bor ,
             ({expression_desc =
                (Bin((Plus | Minus ) ,
                    {expression_desc = Number (Int {i ; _}) }, {expression_desc = Var _; _})
                |Bin((Plus | Minus ) ,
                    {expression_desc = Var _; _}, {expression_desc = Number (Int {i ; _}) } ))
                } as e), {expression_desc = Number (Int {i=0l} | Uint 0l | Nint 0n); _})
      ->  
      (* TODO: check correctness *)
      is_out ?comment e range 
    | _, _ ->
      int_comp ?comment Cgt (to_uint32 e)  range 
  end

let rec float_add ?comment (e1 : t) (e2 : t) = 
  match e1.expression_desc, e2.expression_desc with 
  | Number (Int {i;_}), Number (Int {i = j;_}) -> 
    int ?comment (Int32.add i  j)
  | _, Number (Int {i = j; c}) when j < 0l -> 
    float_minus ?comment e1 
      {e2 with expression_desc = Number (Int {i = Int32.neg j; c})}       

  | Bin(Plus, a1 , ({expression_desc = Number (Int {i = k; _})}  )), 
    Number (Int { i =j; _}) -> 
    {comment ; expression_desc = Bin(Plus, a1,  (int (Int32.add k  j)))}
    (* bin ?comment Plus a1 (int (k + j)) *)

  (* TODO remove commented code  ?? *)
  (* | Bin(Plus, a0 , ({expression_desc = Number (Int a1)}  )), *)
  (*     Bin(Plus, b0 , ({expression_desc = Number (Int b1)}  )) *)
  (*   ->  *)
  (*   bin ?comment Plus a1 (int (a1 + b1)) *)

  (* | _, Bin(Plus,  b0, ({expression_desc = Number _}  as v)) *)
  (*   -> *)
  (*     bin ?comment Plus (bin ?comment Plus e1 b0) v *)
  (* | Bin(Plus, a1 , ({expression_desc = Number _}  as v)), _ *)
  (* | Bin(Plus, ({expression_desc = Number _}  as v),a1), _ *)
  (*   ->  *)
  (*     bin ?comment Plus (bin ?comment Plus a1 e2 ) v  *)
  (* | Number _, _ *)
  (*   ->  *)
  (*     bin ?comment Plus  e2 e1 *)
  | _ -> {comment ; expression_desc = Bin(Plus, e1,e2)}
    (* bin ?comment Plus e1 e2 *)
(* associative is error prone due to overflow *)
and float_minus ?comment  (e1 : t) (e2 : t) : t = 
  match e1.expression_desc, e2.expression_desc with 
  | Number (Int {i;_}), Number (Int {i = j;_}) -> 
    int ?comment (Int32.sub i  j)
  | _ ->  {comment ; expression_desc = Bin(Minus, e1,e2)}
    (* bin ?comment Minus e1 e2 *)



let unchecked_int32_add ?comment e1 e2 = 
  float_add ?comment e1 e2

let int32_add ?comment e1 e2 = 
  to_int32 @@ float_add ?comment e1 e2


let int32_minus ?comment e1 e2 : J.expression = 
  to_int32 @@  float_minus ?comment e1 e2

let unchecked_int32_minus ?comment e1 e2 : J.expression = 
  float_minus ?comment e1 e2



let float_div ?comment e1 e2 = 
  bin ?comment Div e1 e2 
let float_notequal ?comment e1 e2 = 
  bin ?comment NotEqEq e1 e2


let int32_asr ?comment e1 e2 : J.expression = 
  { comment ; 
    expression_desc = Bin (Asr, e1,e2)
  }

(** Division by zero is undefined behavior*)
let int32_div ~checked ?comment 
    (e1 : t) (e2 : t) : t = 
  match e1.expression_desc, e2.expression_desc with 
  | Length _ , Number (Int {i = 2l} | Uint 2l | Nint 2n)
    -> int32_asr e1 one_int_literal 
  | e1_desc , Number (Int {i = i1} ) when i1 <> 0l
    -> 
    begin match e1_desc with 
    | Number(Int {i = i0})
      -> 
      int (Int32.div i0 i1)
    | _ -> to_int32 (float_div ?comment e1 e2)
    end
  | _, _ -> 
    if checked  then 
      runtime_call Js_config.int32 "div" [e1; e2]
    else to_int32 (float_div ?comment e1 e2)


let int32_mod ~checked ?comment e1 (e2 : t) : J.expression = 
  match e2.expression_desc with 
  | Number (Int {i }) when i <> 0l 
    -> 
    { comment ; 
      expression_desc = Bin (Mod, e1,e2)
    }

  | _ -> 
    if checked then 
      runtime_call Js_config.int32 "mod_" [e1;e2]
    else 
      { comment ; 
        expression_desc = Bin (Mod, e1,e2)
      }


let float_mul ?comment e1 e2 = 
  bin ?comment Mul e1 e2 




let int32_lsl ?comment (e1 : J.expression) (e2 : J.expression) : J.expression = 
  match e1, e2  with 
  | {expression_desc = Number (Int {i = i0} | Uint i0)}, 
    {expression_desc = Number (Int {i = i1} | Uint i1)}
    -> int ?comment (Int32.shift_left i0 (Int32.to_int i1))
  | _ -> 
    { comment ; 
      expression_desc = Bin (Lsl, e1,e2)
    }


let int32_mul ?comment 
    (e1 : J.expression) 
    (e2 : J.expression) : J.expression = 
  match e1, e2 with 
  | {expression_desc = Number (Int {i = 0l}|  Uint 0l | Nint 0n); _}, x
  | x, {expression_desc = Number (Int {i = 0l}|  Uint 0l | Nint 0n); _} 
    when Js_analyzer.no_side_effect_expression x 
    -> zero_int_literal
  | {expression_desc = Number (Int{i = i0}); _}, {expression_desc = Number (Int {i = i1}); _}
    -> int (Int32.mul i0 i1)
  | e , {expression_desc = Number (Int {i = i0} | Uint i0 ); _}
  | {expression_desc = Number (Int {i = i0} | Uint i0 ); _}, e 
    -> 
    let i =  Ext_pervasives.is_pos_pow i0  in 
    if i >= 0 then 
      int32_lsl e (small_int i)
    else 
      runtime_call ?comment Js_config.int32 Literals.imul [e1;e2]
  | _ -> 
    runtime_call ?comment Js_config.int32 Literals.imul [e1;e2]

let unchecked_int32_mul ?comment e1 e2 : J.expression = 
  { comment ; 
    expression_desc = Bin (Mul, e1,e2)
  }



let rec int32_bxor ?comment (e1 : t) (e2 : t) : J.expression = 
  match e1.expression_desc, e2.expression_desc with 
  | Number (Int {i = i1}), Number (Int {i = i2})
    -> int ?comment (Int32.logxor i1 i2)
  | _, (Bin(Lsr,e2, {expression_desc = Number(Int{i=0l} | Uint 0l | Nint 0n) ; _})) ->
    int32_bxor  e1 e2
  | (Bin(Lsr,e1, {expression_desc = Number(Int{i=0l} | Uint 0l | Nint 0n) ; _})), _ ->
    int32_bxor  e1 e2

  | _ -> 
    { comment ; 
      expression_desc = Bin (Bxor, e1,e2)
    }

let rec int32_band ?comment (e1 : J.expression) (e2 : J.expression) : J.expression = 
  match e1.expression_desc with 
  | Bin (Bor ,a, {expression_desc = Number (Int {i = 0l})})
    -> 
    (* Note that in JS
       {[ -1 >>> 0 & 0xffffffff = -1]} is the same as 
       {[ (-1 >>> 0 | 0 ) & 0xffffff ]}
    *)
    int32_band a e2
  | _  ->
    { comment ; 
      expression_desc = Bin (Band, e1,e2)
    }


(* let int32_bin ?comment op e1 e2 : J.expression =  *)
(*   {expression_desc = Int32_bin(op,e1, e2); comment} *)


(* TODO -- alpha conversion 
    remember to add parens..
*)
let of_block ?comment ?e block : t = 
  call ~info:Js_call_info.ml_full_call
    {
      comment ;
      expression_desc = 
        Fun (false, [], 
             begin match e with 
               | None -> block 
               | Some e -> 
                 block @ [{J.statement_desc = Return {return_value = e } ;
                           comment}]
             end
            , Js_fun_env.empty 0)
    } []

let is_nil ?comment x = triple_equal ?comment x nil 

let js_bool ?comment x : t = 
  { comment; 
    expression_desc = Bool x
  }

let is_undef ?comment x = triple_equal ?comment x undefined


let not_implemented ?comment (s : string) =  
  call ~info:Js_call_info.ml_full_call
    {
      comment ;
      expression_desc = 
        Fun (false,[], (
            [{J.statement_desc =
                Throw (str ?comment 
                         (s ^ " not implemented by bucklescript yet\n")) ;
              comment}]) ,
             Js_fun_env.empty 0)
    } []

end
module Js_number : sig 
#1 "js_number.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)







type t  = float 


val to_string : t -> string


val caml_float_literal_to_js_string : string -> string

end = struct
#1 "js_number.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






type t = float 


(* http://www.ecma-international.org/ecma-262/5.1/#sec-7.8.3 
   http://caml.inria.fr/pub/docs/manual-ocaml/lex.html
   {[
     float-literal ::= [-](0...9){0...9|_}[.{0...9|_}][(e|E)][(e|E)[+|-](0...9){0...9|_}]     
   ]}   
   In ocaml, the interpretation of floating-point literals that
   fall outside the range of representable floating-point values is undefined.
   Also, (_) are accepted   

   see https://github.com/ocaml/ocaml/pull/268 that ocaml will have HEXADECIMAL notation 
   support in 4.3

   The Hex part is quite different   
 *)



let to_string v =
  if v = infinity
  then "Infinity"
  else if v = neg_infinity
  then "-Infinity"
  else if v <> v
  then "NaN"
  else
    let vint = (int_of_float v)
    (* TODO: check if 32-bits will loose some precision *)               
    in
    if float_of_int  vint = v
    then
      string_of_int vint
    else
      let s1 = Printf.sprintf "%.12g" v in
      if v = float_of_string s1
      then s1
      else
        let s2 = Printf.sprintf "%.15g" v in
        if v = float_of_string s2
        then s2
        else  Printf.sprintf "%.18g" v



let caml_float_literal_to_js_string v = 
  let len = String.length v in
  if len >= 2 && 
    v.[0] = '0' &&
    (v.[1] = 'x' || v.[1] = 'X') then  
    assert false 
   (* TODO: catchup when upgraded to 4.3 
      it does not make sense too much since js dos not 
      support it natively
    *)    
  else    

    let rec aux buf i = 
      if i >= len then buf
      else 
        let x = v.[i] in
        if x = '_' then
          aux buf (i + 1)
        else if   x  = '.' && i = len - 1  then
          buf
        else 
          begin
            Buffer.add_char buf x ;
            aux buf ( i + 1) 
          end in
    Buffer.contents (aux  (Buffer.create len) 0)


end
module Config_util : sig 
#1 "config_util.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** A simple wrapper around [Config] module in compiler-libs, so that the search path
    is the same
*)


val find : string -> string
(** [find filename] Input is a file name, output is absolute path *)


val find_cmj : string -> Js_cmj_format.t

end = struct
#1 "config_util.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)









(* ATTENTION: lazy to wait [Config.load_path] populated *)
let find file =  Misc.find_in_path_uncap !Config.load_path file 



(* strategy:
   If not installed, use the distributed [cmj] files, 
   make sure that the distributed files are platform independent
*)
let find_cmj file = 
  match find file with
  | f
    -> 
    Js_cmj_format.from_file f             
  | exception Not_found -> 
    (* ONLY read the stored cmj data in browser environment *)

      Bs_exception.error (Cmj_not_found file)
        



end
module Hash_set : sig 
#1 "hash_set.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** A naive hashset implementation on top of [hashtbl], the value is [unit]*)

type   'a hashset 

val create : ?random: bool -> int -> 'a hashset

val clear : 'a hashset -> unit

val reset : 'a hashset -> unit

val copy : 'a hashset -> 'a hashset

val add : 'a hashset -> 'a  -> unit

val mem : 'a hashset -> 'a -> bool

val iter : ('a -> unit) -> 'a hashset -> unit

val elements : 'a hashset -> 'a list

val length : 'a hashset -> int 

end = struct
#1 "hash_set.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








include Hashtbl 

(* type nonrec t = unit t  *)

type  'a hashset = ('a,unit) Hashtbl.t

let add tbl k  = replace tbl k ()
(* use [Hashtbl.replace] instead  *)

(* let replace tbl k  = replace tbl k () *)
let iter f = iter (fun k _ -> f k )

let elements set = 
  fold  (fun k _ acc ->  k :: acc) set []

end
module Lam_module_ident : sig 
#1 "lam_module_ident.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)











(** A type for qualified identifiers in Lambda IR 
 *)

type t = Js_op.module_id = private { id : Ident.t ; kind : Js_op.kind }

type system = Js_config.module_system 

val id : t -> Ident.t 

val name : t -> string

val mk : J.kind -> Ident.t -> t

val of_ml : Ident.t -> t

val of_external : Ident.t -> string -> t

val of_runtime : Ident.t -> t 

end = struct
#1 "lam_module_ident.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)









type t = Js_op.module_id = 
  { id : Ident.t ; kind : Js_op.kind }

type system = Js_config.module_system 

let id x = x.id 

let of_ml id = { id ; kind =  Ml}

let of_external id name =  {id ; kind = External name}

let of_runtime id = { id ; kind = Runtime }

let mk kind id = {id; kind}

let name  x : string  = 
  match (x.kind : J.kind) with 
  | Ml  | Runtime ->  x.id.name
  | External v -> v  
  
(* OCaml runtime written in JS *)
type module_property = bool 

end
module Js_fold_basic : sig 
#1 "js_fold_basic.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** A module to calculate hard dependency based on JS IR in module [J] *)

val depends_j : J.expression -> Ident_set.t -> Ident_set.t

val calculate_hard_dependencies : J.block -> Lam_module_ident.t Hash_set.hashset

end = struct
#1 "js_fold_basic.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)









class count_deps (add : Ident.t -> unit )  = 
  object(self)
    inherit  Js_fold.fold as super
    method! expression lam = 
      match lam.expression_desc with 
      | Fun (_, _, block, _) -> self#block block
      (** Call 
          actually depends on parameter, 
          since closure 
          {[
            n = n - 1
                    acc = () => n 
          ]}
          should be 

          {[
            acc = (function (n) {() => n} (n))
              n = n - 1
          ]}
      *)
      | _ -> super#expression lam
    method! ident x = add x ; self
  end

class count_hard_dependencies = 
  object(self)
    inherit  Js_fold.fold as super
    val hard_dependencies = Hash_set.create 17
    method! vident vid = 
      match vid with 
      | Qualified (id,kind,_) ->
          Hash_set.add  hard_dependencies (Lam_module_ident.mk kind id); self
      | Id id -> self
    method! expression x = 
      match  x with
      | {expression_desc = Call (_,_, {arity = NA}); _}
        (* see [Js_exp_make.runtime_var_dot] *)
        -> 
        Hash_set.add hard_dependencies 
          (Lam_module_ident.of_runtime (Ext_ident.create_js Js_config.curry));
        super#expression x             
      | {expression_desc = Caml_block(_,_, tag, tag_info); _}
        -> 
        begin match tag.expression_desc, tag_info with 
          | Number (Int { i = 0l ; _})  , 
            (Blk_tuple | Blk_array | Blk_variant _ | Blk_record _ | Blk_na | Blk_module _
            |  Blk_constructor (_, 1)
            )  (*Sync up with {!Js_dump}*)
            -> ()
          | _, _
            -> 
            Hash_set.add hard_dependencies 
              (Lam_module_ident.of_runtime (Ext_ident.create_js Js_config.block));
        end;
        super#expression x 
      | _ -> super#expression x
    method get_hard_dependencies = hard_dependencies
  end

let calculate_hard_dependencies block = 
  ((new count_hard_dependencies)#block block) # get_hard_dependencies

(*
   Given a set of [variables], count which variables  [lam] will depend on
   Invariant:
   [variables] are parameters which means immutable so that [Call] 
   will not depend [variables]

*)
let depends_j (lam : J.expression) (variables : Ident_set.t) = 
  let v = ref Ident_set.empty in
  let add id = 
    if Ident_set.mem id variables then 
      v := Ident_set.add id !v 
  in
  ignore @@ (new count_deps add ) # expression lam ;
  !v


end
module Lam_analysis : sig 
#1 "lam_analysis.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






(** A module which provides some basic analysis over lambda expression *)

(** No side effect, but it might depend on data store *)
val no_side_effects : Lam.t -> bool 

val size : Lam.t -> int

val ok_to_inline : body:Lam.t -> Lam.ident list -> Lam.t list -> bool
  
val eq_lambda : Lam.t -> Lam.t -> bool 
(** a conservative version of comparing two lambdas, mostly 
    for looking for similar cases in switch
 *)

(** [is_closed_by map lam]
    return [true] if all unbound variables
    belongs to the given [map] *)
val is_closed_by : (* Lambda. *) Ident_set.t -> Lam.t -> bool

val is_closed : Lam.t -> bool





type stats = 
  { 
    mutable top : bool ; 
    (* all appearances are in the top,  substitution is fine 
       whether it is pure or not
       {[
         (fun x y          
           ->  x + y + (f x )) (32) (console.log('hi'), 33)
       ]}       
       since in ocaml, the application order is intentionally undefined, 
       note if [times] is not one, this field does not make sense       
    *)    
    mutable times : int ; 
  }

val is_closed_with_map : 
  Ident_set.t ->
  Ident.t list -> Lam.t -> bool * stats Ident_map.t

val param_map_of_list : Ident.t list -> stats Ident_map.t

val free_variables : Ident_set.t -> stats Ident_map.t -> Lam.t -> stats Ident_map.t

val small_inline_size : int 
val exit_inline_size : int 


val safe_to_inline : Lam.t -> bool

end = struct
#1 "lam_analysis.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






let rec no_side_effects (lam : Lam.t) : bool = 
  match lam with 
  | Lvar _ 
  | Lconst _ 
  | Lfunction _ -> true
  | Lprim {primitive;  args; _} -> 
    List.for_all no_side_effects args && 
    (
      match primitive with 
      | Pccall {prim_name ; _} ->
        begin 
          match prim_name,args with 
          | ("caml_register_named_value"
            (* register to c runtime does not make sense  in ocaml *)
            | "caml_set_oo_id" 
            | "caml_is_js"
            | "caml_int64_float_of_bits"
             (* more safe to check if arguments are constant *)
            (* non-observable side effect *)    
            | "caml_sys_get_config"
            | "caml_sys_get_argv" (* should be fine *)

            | "caml_create_string" (* TODO: add more *)
            | "caml_make_vect"
            | "caml_obj_dup"
            | "caml_obj_block"
            | "js_from_nullable"
            | "js_from_def"
            | "js_from_nullable_def"
            ), _  -> true 
          | "caml_ml_open_descriptor_in", [Lconst (Const_base (Const_int 0))] -> true 
          | "caml_ml_open_descriptor_out", 
            [Lconst (Const_base (Const_int (1|2))) ]
            -> true
          (* we can not mark it pure
             only when we guarantee this exception is caught...
           *)
          | _ , _-> false
        end 

      | Pbytes_to_string 
      | Pbytes_of_string 
      


      | Pgetglobal _
      | Pglobal_exception _
      | Pmakeblock _  (* whether it's mutable or not *)
      | Pfield _
      | Pfloatfield _ 
      | Pduprecord _ 
      (* Boolean operations *)
      | Psequand | Psequor | Pnot
      (* Integer operations *)
      | Pnegint | Paddint | Psubint | Pmulint | Pdivint | Pmodint
      | Pandint | Porint | Pxorint
      | Plslint | Plsrint | Pasrint
      | Pintcomp _ 
      (* Float operations *)
      | Pintoffloat | Pfloatofint
      | Pnegfloat | Pabsfloat
      | Paddfloat | Psubfloat | Pmulfloat | Pdivfloat
      | Pfloatcomp _ 
      (* String operations *)
      | Pstringlength 
      | Pstringrefu 
      | Pstringrefs
      | Pbyteslength
      | Pbytesrefu
      | Pbytesrefs
      | Pmakearray _ 
      | Parraylength _ 
      | Parrayrefu _
      | Parrayrefs _ 
      (* Test if the argument is a block or an immediate integer *)
      | Pisint
      (* Test if the (integer) argument is outside an interval *)
      | Pisout
      | Pbintofint _
      | Pintofbint _
      | Pcvtbint _
      | Pnegbint _
      | Paddbint _
      | Psubbint _
      | Pmulbint _
      | Pdivbint _
      | Pmodbint _
      | Pandbint _
      | Porbint _
      | Pxorbint _
      | Plslbint _
      | Plsrbint _
      | Pasrbint _
      | Pbintcomp _
      (* Operations on big arrays: (unsafe, #dimensions, kind, layout) *)
      | Pbigarrayref _ (* TODO it may raise an exception....*)
      (* Compile time constants *)
      | Pctconst _
      (* Integer to external pointer *)

      | Poffsetint _
      | Pstringadd 
        -> true
      | Pinit_mod
      | Pupdate_mod
      | Pjs_unsafe_downgrade _
      | Pdebugger 
      | Pjs_fn_run _ | Pjs_fn_make _
      | Pjs_fn_method _ | Pjs_fn_runmethod _
      (* TODO *)

      | Pbytessetu 
      | Pbytessets
      (* Bitvect operations *)
      | Pbittest
      (* Operations on boxed integers (Nativeint.t, Int32.t, Int64.t) *)
      | Parraysets _
      | Pbigarrayset _
      (* size of the nth dimension of a big array *)
      | Pbigarraydim _
      (* load/set 16,32,64 bits from a string: (unsafe)*)
      | Pstring_load_16 _
      | Pstring_load_32 _
      | Pstring_load_64 _
      | Pstring_set_16 _
      | Pstring_set_32 _
      | Pstring_set_64 _
      (* load/set 16,32,64 bits from a
         (char, int8_unsigned_elt, c_layout) Bigarray.Array1.t : (unsafe) *)
      | Pbigstring_load_16 _
      | Pbigstring_load_32 _
      | Pbigstring_load_64 _
      | Pbigstring_set_16 _
      | Pbigstring_set_32 _
      | Pbigstring_set_64 _
      (* byte swap *)
      | Pbswap16
      | Pbbswap _
      | Parraysetu _ 
      | Poffsetref _ 
      | Praise
      | Plazyforce 
      | Psetfield _ 
      | Psetfloatfield _
      | Psetglobal _ -> false 
    )
  | Llet (_,_, arg,body) -> no_side_effects arg && no_side_effects body 
  | Lswitch (_,_) -> false 
  | Lstringswitch (_,_,_) -> false
  | Lstaticraise _ -> false
  | Lstaticcatch _ -> false 

  (* | "caml_sys_getenv" , [Lconst(Const_base(Const_string _))] *)
  (*         -> true *)
  (** not enough, we need know that 
      if it [Not_found], there are no other exceptions 
      can be thrown
  *)
  | Ltrywith (Lprim { primitive = Pccall{prim_name = "caml_sys_getenv"};
                    args = [Lconst _]; _},exn,
              Lifthenelse(Lprim{args =  
                                  [Lvar exn1; 
                                   Lprim {primitive = Pglobal_exception ({name="Not_found"}); args = []; _}]
                               ; _},
                          then_, _)) when Ident.same exn1 exn
    (** we might put this in an optimization pass 
        also make sure when we wrap this in [js] we 
        should follow the same patten, raise [Not_found] 
    *)
    -> no_side_effects then_
  (** It would be nice that we can also analysis some small functions 
      for example [String.contains], 
      [Format.make_queue_elem]
  *)
  | Ltrywith (body,exn,handler) 
    -> no_side_effects body && no_side_effects handler

  | Lifthenelse  (a,b,c) -> 
    no_side_effects a && no_side_effects b && no_side_effects c
  | Lsequence (e0,e1) -> no_side_effects e0 && no_side_effects e1 
  | Lwhile (a,b) -> no_side_effects a && no_side_effects b 
  | Lfor _ -> false 
  | Lassign _ -> false (* actually it depends ... *)
  | Lsend _ -> false 
  | Lifused _ -> false 
  | Lapply _ -> false (* we need purity analysis .. *)
  | Lletrec (bindings, body) ->
    List.for_all (fun (_,b) -> no_side_effects b) bindings && no_side_effects body


(* 
    Estimate the size of lambda for better inlining 
    threshold is 1000 - so that we 
 *)
exception Too_big_to_inline

let really_big () = raise Too_big_to_inline

let big_lambda = 1000

let rec size (lam : Lam.t) = 
  try 
    match lam with 
    | Lvar _ ->  1
    | Lconst c -> size_constant c
    | Llet(_, _, l1, l2) -> 1 + size l1 + size l2 
    | Lletrec _ -> really_big ()
    | Lprim{primitive = Pfield _; 
            args =  [Lprim { primitive = Pgetglobal _; args =  [  ];  _}]
           ;  _}
      -> 1
    | Lprim {primitive = Praise ; args =  [l ];  _} 
      -> size l
    | Lprim {args = ll; _} -> size_lams 1 ll

    (** complicated 
        1. inline this function
        2. ...
        exports.Make=
        function(funarg)
        {var $$let=Make(funarg);
        return [0, $$let[5],... $$let[16]]}
     *)      
    | Lapply{ fn;
             args; _} -> size_lams (size fn) args
    (* | Lfunction(_, params, l) -> really_big () *)
    | Lfunction {body} -> size body 
    | Lswitch(_, _) -> really_big ()
    | Lstringswitch(_,_,_) -> really_big ()
    | Lstaticraise (i,ls) -> 
        List.fold_left (fun acc x -> size x + acc) 1 ls 
    | Lstaticcatch(l1, (i,x), l2) -> really_big () 
    | Ltrywith(l1, v, l2) -> really_big ()
    | Lifthenelse(l1, l2, l3) -> 1 + size  l1 + size  l2 +  size  l3
    | Lsequence(l1, l2) -> size  l1  +  size  l2
    | Lwhile(l1, l2) -> really_big ()
    | Lfor(flag, l1, l2, dir, l3) -> really_big () 
    | Lassign (_,v) -> 1 + size v  (* This is side effectful,  be careful *)
    | Lsend _  ->  really_big ()
    | Lifused(v, l) -> size l 
  with Too_big_to_inline ->  1000 
and size_constant x = 
  match x with 
  | Const_base _
  | Const_immstring _
  | Const_pointer _ 
    -> 1 
  | Const_block (_, _, str) 
    ->  List.fold_left (fun acc x -> acc + size_constant x ) 0 str
  | Const_float_array xs  -> List.length xs

and size_lams acc (lams : Lam.t list) = 
  List.fold_left (fun acc l -> acc  + size l ) acc lams
let args_all_const args =
  List.for_all (fun x -> match x with Lam.Lconst _ -> true | _ -> false) args
    
let exit_inline_size = 7 
let small_inline_size = 5

(** destruct pattern will work better 
    if it is closed lambda, otherwise
    you can not do full evaluation

    We still should avoid inline too big code, 

    ideally we should also evaluate its size after inlining, 
    since after partial evaluation, it might still be *very big*
*)
let destruct_pattern (body : Lam.t) params args =
  let rec aux v params args =
    match params, args with
    | x::xs, b::bs ->
      if Ident.same x v then Some b
      else aux v xs bs
    | [] , _ -> None
    | x::xs, [] -> assert false                  
  in   
  match body with
  | Lswitch (Lvar v , switch)
    ->
    begin match aux v params args with
      | Some (Lam.Lconst _ as lam) ->
        size (Lam.switch lam switch) < small_inline_size
      | Some _ | None -> false
    end        
  | Lifthenelse(Lvar v, then_, else_)
    ->
    begin match aux v params args with
      | Some (Lconst _ as lam) ->
        size (Lam.if_ lam then_ else_) < small_inline_size
      | Some _ | None -> false          
    end      
  | _ -> false
    
(** Hints to inlining *)
let ok_to_inline ~body params args =
  let s = size body in
  s < small_inline_size ||
  (destruct_pattern body params args) ||  
  (args_all_const args &&
   (s < 10 && no_side_effects body )) 


(* compared two lambdas in case analysis, note that we only compare some small lambdas
    Actually this patten is quite common in GADT, people have to write duplicated code 
    due to the type system restriction
*)
let rec eq_lambda (l1 : Lam.t) (l2 : Lam.t) =
  match (l1, l2) with
  | Lvar i1, Lvar i2 -> Ident.same i1 i2
  | Lconst c1, Lconst c2 -> c1 = c2 (* *)
  | Lapply {fn = l1; args = args1; _}, Lapply {fn = l2; args = args2; _} ->
    eq_lambda l1 l2  && List.for_all2 eq_lambda args1 args2
  | Lfunction _ , Lfunction _ -> false (* TODO -- simple functions ?*)
  | Lassign(v0,l0), Lassign(v1,l1) -> Ident.same v0 v1 && eq_lambda l0 l1
  | Lstaticraise(id,ls), Lstaticraise(id1,ls1) -> 
    id = id1 && List.for_all2 eq_lambda ls ls1 
  | Llet (_,_,_,_), Llet (_,_,_,_) -> false 
  | Lletrec _, Lletrec _ -> false 
  | Lprim {primitive = p; args = ls; } ,
    Lprim {primitive = p1; args = ls1} -> 
    eq_primitive p p1 && List.for_all2 eq_lambda ls ls1
  | Lswitch _, Lswitch _ -> false  
  | Lstringswitch _ , Lstringswitch _ -> false 
  | Lstaticcatch _, Lstaticcatch _ -> false 
  | Ltrywith _, Ltrywith _ -> false 
  | Lifthenelse (a,b,c), Lifthenelse (a0,b0,c0) ->
    eq_lambda a a0 && eq_lambda b b0 && eq_lambda c c0
  | Lsequence (a,b), Lsequence (a0,b0) ->
    eq_lambda a a0 && eq_lambda b b0
  | Lwhile (p,b) , Lwhile (p0,b0) -> eq_lambda p p0 && eq_lambda b b0
  | Lfor (_,_,_,_,_), Lfor (_,_,_,_,_) -> false
  | Lsend _, Lsend _ -> false
  | Lifused _, Lifused _ -> false 
  |  _,  _ -> false 
and eq_primitive (p : Lam.primitive) (p1 : Lam.primitive) = 
  match p, p1 with 
  | Pccall {prim_name = n0 ; 
            prim_native_name = nn0;
           },  
    Pccall {prim_name = n1; 
            prim_native_name = nn1;

           } -> 
    n0 = n1 && nn0 = nn1 (* No attributes, should be class api, comparison by name is good *)
  | Pfield (n0, _dbg_info0),  Pfield (n1, _dbg_info1) 
    -> n0 = n1
  | Psetfield(i0, b0, _dbg_info0), Psetfield(i1, b1, _dbg_info1)
    -> i0 = i1 && b0 = b1 
  | _ , _ -> 
    (* FIXME: relies on structure equality
    *) 
    try p = p1 with _ -> false



type stats = 
  { 
    mutable top : bool ; 
    (* all appearances are in the top,  substitution is fine 
       whether it is pure or not
       {[
         (fun x y          
           ->  x + y + (f x )) (32) (console.log('hi'), 33)
       ]}       
       since in ocaml, the application order is intentionally undefined, 
       note if [times] is not one, this field does not make sense       
    *)    
    mutable times : int ; 
  }
type env = 
  { top  : bool ; 
    loop : bool 
  }

let no_substitute = { top = false; loop = true }
let fresh_env = {top = true; loop = false }
let fresh_stats () = { top = true; times = 0 }

let param_map_of_list lst = 
  List.fold_left  (fun acc l -> Ident_map.add l (fresh_stats ()) acc) Ident_map.empty  lst 

(** Sanity check, remove all varaibles in [local_set] in the last pass *)  

let free_variables (export_idents : Ident_set.t ) (params : stats Ident_map.t ) lam = 
  let fv = ref params in
  let local_set = ref export_idents in

  let local_add k =
    local_set := Ident_set.add k !local_set in
  let local_add_list ks = 
    local_set :=  
      List.fold_left (fun acc k -> Ident_set.add k acc) !local_set ks 
  in    
  let loop_use = 100 in
  let map_use {top; loop} v = 
    (* relies on [identifier] uniquely bound *)    
    let times = if loop then loop_use else 1 in
    if Ident_set.mem v !local_set then ()    
    else begin match Ident_map.find v !fv with 
      | exception Not_found
        -> fv := Ident_map.add v { top ; times } !fv
      | v ->
        v.times <- v.times + times ; 
        v.top <- v.top && top          
    end
  in
  let new_env lam (env : env) = 
    if env.top then 
      if no_side_effects lam 
      then env 
      else { env with top = false}
    else env      
  in    
  let rec iter (top : env) (lam : Lam.t) =
    match lam with 
    | Lvar v -> map_use top v 
    | Lconst _ -> ()
    | Lapply {fn; args; _} ->
      iter top  fn; 
      let top = new_env fn top in
      List.iter (iter top ) args  
    | Lprim {args ; _} -> 
      (* Check: can top be propoaged for all primitives *)
      List.iter (iter top) args
    | Lfunction{ params; body} ->
      local_add_list params;
      iter no_substitute body 
    | Llet(_let_kind, id, arg, body) ->
      local_add id ;  
      iter top  arg; iter no_substitute body
    | Lletrec(decl, body) ->
      local_set := List.fold_left (fun acc (id, _) -> 
          Ident_set.add id acc) !local_set decl;        
      List.iter (fun (_, exp) -> iter no_substitute exp) decl;
      iter no_substitute body
    | Lswitch(arg, sw) ->
      iter top arg; 
      let top = new_env arg top  in       
      List.iter (fun (key, case) -> iter top case) sw.sw_consts;
      List.iter (fun (key, case) -> iter top  case) sw.sw_blocks;
  
      begin match sw.sw_failaction with 
        | None -> ()
        | Some x ->
          let nconsts = List.length sw.sw_consts in
          let nblocks = List.length sw.sw_blocks in

          if nconsts < sw.sw_numconsts  && nblocks < sw.sw_numblocks then
            iter no_substitute x
          else
            iter top x
      end

    | Lstringswitch (arg,cases,default) ->
      iter top arg ;
      let top = new_env arg top  in       
      List.iter (fun (_,act) -> iter top  act) cases ;
      begin match default with 
      | None -> ()
      | Some x -> iter top x 
      end
    | Lstaticraise (_,args) ->
      List.iter (iter no_substitute ) args
    | Lstaticcatch(e1, (_,vars), e2) ->
      iter no_substitute  e1; 
      local_add_list vars;       
      iter no_substitute e2
    | Ltrywith(e1, exn, e2) ->
      iter top  e1; iter no_substitute  e2
    | Lifthenelse(e1, e2, e3) ->
      iter top e1; 
      let top = new_env e1 top  in
      iter top e2; iter top e3
    | Lsequence(e1, e2) ->
      iter top e1; iter no_substitute e2
    | Lwhile(e1, e2) ->
      iter no_substitute e1; iter no_substitute e2 (* in the loop, no substitution any way *)
    | Lfor(v, e1, e2, dir, e3) ->
      local_add v ; 
      iter no_substitute e1; iter no_substitute e2; iter no_substitute e3
    | Lassign(id, e) ->
      map_use top  id ; 
      iter top e
    | Lsend (_k, met, obj, args, _) ->
      iter no_substitute met ; 
      iter no_substitute obj;
      List.iter (iter no_substitute) args
    | Lifused (v, e) ->
      iter no_substitute e in
  iter fresh_env  lam ; !fv 


let is_closed_by set lam = 
  Ident_map.is_empty (free_variables set (Ident_map.empty ) lam   )


(** A bit consverative , it should be empty *)
let is_closed  lam = 
  Ident_map.for_all (fun k _ -> Ident.global k)
    (free_variables Ident_set.empty Ident_map.empty lam)  


let is_closed_with_map exports params body = 
  let param_map = free_variables exports (param_map_of_list params) body in
  let old_count = List.length params in
  let new_count = Ident_map.cardinal param_map in
  (old_count  = new_count, param_map)


  
(* TODO:  We can relax this a bit later,
    but decide whether to inline it later in the call site
 *)
let safe_to_inline (lam : Lam.t) = 
  match lam with 
  | Lfunction _ ->  true
  | Lconst (Const_pointer _  | Const_immstring _ ) -> true
  | _ -> false

end
module Lam_iter : sig 
#1 "lam_iter.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

val inner_iter : (Lam.t -> unit) -> Lam.t -> unit

end = struct
#1 "lam_iter.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


let inner_iter f l = 
  match (l : Lam.t) with 
    Lvar _
  | Lconst _ -> ()
  | Lapply{fn; args; _} ->
      f fn; List.iter f args
  | Lfunction{body;_} ->
      f body
  | Llet(str, id, arg, body) ->
      f arg; f body
  | Lletrec(decl, body) ->
      f body;
      List.iter (fun (id, exp) -> f exp) decl
  | Lprim {args; _} ->
      List.iter f args
  | Lswitch(arg, sw) ->
      f arg;
      List.iter (fun (key, case) -> f case) sw.sw_consts;
      List.iter (fun (key, case) -> f case) sw.sw_blocks;
      begin match sw.sw_failaction with 
      | None -> ()
      | Some a -> f a 
      end
  | Lstringswitch (arg,cases,default) ->
      f arg ;
      List.iter (fun (_,act) -> f act) cases ;
      begin match default with 
      | None -> ()
      | Some a -> f a 
      end
  | Lstaticraise (_,args) ->
      List.iter f args
  | Lstaticcatch(e1, (_,vars), e2) ->
      f e1; f e2
  | Ltrywith(e1, exn, e2) ->
      f e1; f e2
  | Lifthenelse(e1, e2, e3) ->
      f e1; f e2; f e3
  | Lsequence(e1, e2) ->
      f e1; f e2
  | Lwhile(e1, e2) ->
      f e1; f e2
  | Lfor(v, e1, e2, dir, e3) ->
      f e1; f e2; f e3
  | Lassign(id, e) ->
      f e
  | Lsend (k, met, obj, args, _) ->
      List.iter f (met::obj::args)
  | Lifused (v, e) ->
      f e


end
module Lam_print : sig 
#1 "lam_print.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

val lambda : Format.formatter -> Lam.t -> unit

val primitive: Format.formatter -> Lam.Prim.t -> unit

val seriaize : 'a -> string -> Lam.t -> unit

val env_lambda : Env.t -> Format.formatter -> Lam.t -> unit

end = struct
#1 "lam_print.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)
[@@@ocaml.warning "-40"]
open Format
open Asttypes
open Primitive
open Types



let rec struct_const ppf (cst : Lambda.structured_constant) =
  match cst with 
  | Const_base(Const_int n) -> fprintf ppf "%i" n
  | Const_base(Const_char c) -> fprintf ppf "%C" c
  | Const_base(Const_string (s, _)) -> fprintf ppf "%S" s
  | Const_immstring s -> fprintf ppf "#%S" s
  | Const_base(Const_float f) -> fprintf ppf "%s" f
  | Const_base(Const_int32 n) -> fprintf ppf "%lil" n
  | Const_base(Const_int64 n) -> fprintf ppf "%LiL" n
  | Const_base(Const_nativeint n) -> fprintf ppf "%nin" n
  | Const_pointer (n,_) -> fprintf ppf "%ia" n
  | Const_block(tag,_, []) ->
      fprintf ppf "[%i]" tag
  | Const_block(tag,_, sc1::scl) ->
      let sconsts ppf scl =
        List.iter (fun sc -> fprintf ppf "@ %a" struct_const sc) scl in
      fprintf ppf "@[<1>[%i:@ @[%a%a@]]@]" tag struct_const sc1 sconsts scl
  | Const_float_array [] ->
      fprintf ppf "[| |]"
  | Const_float_array (f1 :: fl) ->
      let floats ppf fl =
        List.iter (fun f -> fprintf ppf "@ %s" f) fl in
      fprintf ppf "@[<1>[|@[%s%a@]|]@]" f1 floats fl

let boxed_integer_name (i : Lambda.boxed_integer) =
  match i with 
  | Pnativeint -> "nativeint"
  | Pint32 -> "int32"
  | Pint64 -> "int64"

let print_boxed_integer name ppf bi =
  fprintf ppf "%s_%s" (boxed_integer_name bi) name

let print_boxed_integer_conversion ppf bi1 bi2 =
  fprintf ppf "%s_of_%s" (boxed_integer_name bi2) (boxed_integer_name bi1)

let boxed_integer_mark name (i : Lambda.boxed_integer) = 
  match i with 
  | Pnativeint -> Printf.sprintf "Nativeint.%s" name
  | Pint32 -> Printf.sprintf "Int32.%s" name
  | Pint64 -> Printf.sprintf "Int64.%s" name

let print_boxed_integer name ppf bi =
  fprintf ppf "%s" (boxed_integer_mark name bi);;

let print_bigarray name unsafe (kind : Lambda.bigarray_kind) ppf 
    (layout : Lambda.bigarray_layout) =
  fprintf ppf "Bigarray.%s[%s,%s]"
    (if unsafe then "unsafe_"^ name else name)
    (match kind with
     | Lambda.Pbigarray_unknown -> "generic"
     | Pbigarray_float32 -> "float32"
     | Pbigarray_float64 -> "float64"
     | Pbigarray_sint8 -> "sint8"
     | Pbigarray_uint8 -> "uint8"
     | Pbigarray_sint16 -> "sint16"
     | Pbigarray_uint16 -> "uint16"
     | Pbigarray_int32 -> "int32"
     | Pbigarray_int64 -> "int64"
     | Pbigarray_caml_int -> "camlint"
     | Pbigarray_native_int -> "nativeint"
     | Pbigarray_complex32 -> "complex32"
     | Pbigarray_complex64 -> "complex64")
    (match layout with
     | Lambda.Pbigarray_unknown_layout -> "unknown"
     | Pbigarray_c_layout -> "C"
     | Pbigarray_fortran_layout -> "Fortran")

let record_rep ppf r =
  match r with
  | Record_regular -> fprintf ppf "regular"
  | Record_float -> fprintf ppf "float"
;;

let string_of_loc_kind (loc : Lambda.loc_kind) =
  match loc with 
  | Loc_FILE -> "loc_FILE"
  | Loc_LINE -> "loc_LINE"
  | Loc_MODULE -> "loc_MODULE"
  | Loc_POS -> "loc_POS"
  | Loc_LOC -> "loc_LOC"

let primitive ppf (prim : Lam.primitive) = match prim with 
  | Pinit_mod -> fprintf ppf "init_mod!"
  | Pupdate_mod -> fprintf ppf "update_mod!"
  | Pbytes_to_string -> fprintf ppf "bytes_to_string"
  | Pbytes_of_string -> fprintf ppf "bytes_of_string"
  | Pjs_unsafe_downgrade (s,_loc) -> fprintf ppf "##%s" s 
  | Pjs_fn_run i -> fprintf ppf "js_fn_run_%i" i 
  | Pjs_fn_make i -> fprintf ppf "js_fn_make_%i" i
  | Pjs_fn_method i -> fprintf ppf "js_fn_method_%i" i 
  | Pjs_fn_runmethod i -> fprintf ppf "js_fn_runmethod_%i" i 
  | Pdebugger -> fprintf ppf "debugger"
  | Pgetglobal id -> fprintf ppf "global %a" Ident.print id
  | Pglobal_exception id ->
    fprintf ppf "global exception %a" Ident.print id                       
  | Psetglobal id -> fprintf ppf "setglobal %a" Ident.print id
  | Pmakeblock(tag, _, Immutable) -> fprintf ppf "makeblock %i" tag
  | Pmakeblock(tag, _, Mutable) -> fprintf ppf "makemutable %i" tag
  | Pfield (n,_) -> fprintf ppf "field %i" n
  | Psetfield(n, ptr, _) ->
      let instr = if ptr then "setfield_ptr " else "setfield_imm " in
      fprintf ppf "%s%i" instr n
  | Pfloatfield (n,_) -> fprintf ppf "floatfield %i" n
  | Psetfloatfield (n,_) -> fprintf ppf "setfloatfield %i" n
  | Pduprecord (rep, size) -> fprintf ppf "duprecord %a %i" record_rep rep size
  | Plazyforce -> fprintf ppf "force"
  | Pccall p -> fprintf ppf "%s" p.prim_name
  | Praise  -> fprintf ppf "raise"
  | Psequand -> fprintf ppf "&&"
  | Psequor -> fprintf ppf "||"
  | Pnot -> fprintf ppf "not"
  | Pnegint -> fprintf ppf "~"
  | Paddint -> fprintf ppf "+"
  | Pstringadd -> fprintf ppf "+*"                 
  | Psubint -> fprintf ppf "-"
  | Pmulint -> fprintf ppf "*"
  | Pdivint -> fprintf ppf "/"
  | Pmodint -> fprintf ppf "mod"
  | Pandint -> fprintf ppf "and"
  | Porint -> fprintf ppf "or"
  | Pxorint -> fprintf ppf "xor"
  | Plslint -> fprintf ppf "lsl"
  | Plsrint -> fprintf ppf "lsr"
  | Pasrint -> fprintf ppf "asr"
  | Pintcomp(Ceq) -> fprintf ppf "=="
  | Pintcomp(Cneq) -> fprintf ppf "!="
  | Pintcomp(Clt) -> fprintf ppf "<"
  | Pintcomp(Cle) -> fprintf ppf "<="
  | Pintcomp(Cgt) -> fprintf ppf ">"
  | Pintcomp(Cge) -> fprintf ppf ">="
  | Poffsetint n -> fprintf ppf "%i+" n
  | Poffsetref n -> fprintf ppf "+:=%i"n
  | Pintoffloat -> fprintf ppf "int_of_float"
  | Pfloatofint -> fprintf ppf "float_of_int"
  | Pnegfloat -> fprintf ppf "~."
  | Pabsfloat -> fprintf ppf "abs."
  | Paddfloat -> fprintf ppf "+."
  | Psubfloat -> fprintf ppf "-."
  | Pmulfloat -> fprintf ppf "*."
  | Pdivfloat -> fprintf ppf "/."
  | Pfloatcomp(Ceq) -> fprintf ppf "==."
  | Pfloatcomp(Cneq) -> fprintf ppf "!=."
  | Pfloatcomp(Clt) -> fprintf ppf "<."
  | Pfloatcomp(Cle) -> fprintf ppf "<=."
  | Pfloatcomp(Cgt) -> fprintf ppf ">."
  | Pfloatcomp(Cge) -> fprintf ppf ">=."
  | Pstringlength -> fprintf ppf "string.length"
  | Pstringrefu -> fprintf ppf "string.unsafe_get"
  | Pstringrefs -> fprintf ppf "string.get"
  | Pbyteslength -> fprintf ppf "bytes.length"
  | Pbytesrefu -> fprintf ppf "bytes.unsafe_get"
  | Pbytessetu -> fprintf ppf "bytes.unsafe_set"
  | Pbytesrefs -> fprintf ppf "bytes.get"
  | Pbytessets -> fprintf ppf "bytes.set"

  | Parraylength _ -> fprintf ppf "array.length"
  | Pmakearray _ -> fprintf ppf "makearray "
  | Parrayrefu _ -> fprintf ppf "array.unsafe_get"
  | Parraysetu _ -> fprintf ppf "array.unsafe_set"
  | Parrayrefs _ -> fprintf ppf "array.get"
  | Parraysets _ -> fprintf ppf "array.set"
  | Pctconst c ->
     let const_name = match c with
       | Big_endian -> "big_endian"
       | Word_size -> "word_size"
       | Ostype_unix -> "ostype_unix"
       | Ostype_win32 -> "ostype_win32"
       | Ostype_cygwin -> "ostype_cygwin" in
     fprintf ppf "sys.constant_%s" const_name
  | Pisint -> fprintf ppf "isint"
  | Pisout -> fprintf ppf "isout"
  | Pbittest -> fprintf ppf "testbit"
  | Pbintofint bi -> print_boxed_integer "of_int" ppf bi
  | Pintofbint bi -> print_boxed_integer "to_int" ppf bi
  | Pcvtbint (bi1, bi2) -> print_boxed_integer_conversion ppf bi1 bi2
  | Pnegbint bi -> print_boxed_integer "neg" ppf bi
  | Paddbint bi -> print_boxed_integer "add" ppf bi
  | Psubbint bi -> print_boxed_integer "sub" ppf bi
  | Pmulbint bi -> print_boxed_integer "mul" ppf bi
  | Pdivbint bi -> print_boxed_integer "div" ppf bi
  | Pmodbint bi -> print_boxed_integer "mod" ppf bi
  | Pandbint bi -> print_boxed_integer "and" ppf bi
  | Porbint bi -> print_boxed_integer "or" ppf bi
  | Pxorbint bi -> print_boxed_integer "xor" ppf bi
  | Plslbint bi -> print_boxed_integer "lsl" ppf bi
  | Plsrbint bi -> print_boxed_integer "lsr" ppf bi
  | Pasrbint bi -> print_boxed_integer "asr" ppf bi
  | Pbintcomp(bi, Ceq) -> print_boxed_integer "==" ppf bi
  | Pbintcomp(bi, Cneq) -> print_boxed_integer "!=" ppf bi
  | Pbintcomp(bi, Clt) -> print_boxed_integer "<" ppf bi
  | Pbintcomp(bi, Cgt) -> print_boxed_integer ">" ppf bi
  | Pbintcomp(bi, Cle) -> print_boxed_integer "<=" ppf bi
  | Pbintcomp(bi, Cge) -> print_boxed_integer ">=" ppf bi
  | Pbigarrayref(unsafe, n, kind, layout) ->
      print_bigarray "get" unsafe kind ppf layout
  | Pbigarrayset(unsafe, n, kind, layout) ->
      print_bigarray "set" unsafe kind ppf layout
  | Pbigarraydim(n) -> fprintf ppf "Bigarray.dim_%i" n
  | Pstring_load_16(unsafe) ->
     if unsafe then fprintf ppf "string.unsafe_get16"
     else fprintf ppf "string.get16"
  | Pstring_load_32(unsafe) ->
     if unsafe then fprintf ppf "string.unsafe_get32"
     else fprintf ppf "string.get32"
  | Pstring_load_64(unsafe) ->
     if unsafe then fprintf ppf "string.unsafe_get64"
     else fprintf ppf "string.get64"
  | Pstring_set_16(unsafe) ->
     if unsafe then fprintf ppf "string.unsafe_set16"
     else fprintf ppf "string.set16"
  | Pstring_set_32(unsafe) ->
     if unsafe then fprintf ppf "string.unsafe_set32"
     else fprintf ppf "string.set32"
  | Pstring_set_64(unsafe) ->
     if unsafe then fprintf ppf "string.unsafe_set64"
     else fprintf ppf "string.set64"
  | Pbigstring_load_16(unsafe) ->
     if unsafe then fprintf ppf "bigarray.array1.unsafe_get16"
     else fprintf ppf "bigarray.array1.get16"
  | Pbigstring_load_32(unsafe) ->
     if unsafe then fprintf ppf "bigarray.array1.unsafe_get32"
     else fprintf ppf "bigarray.array1.get32"
  | Pbigstring_load_64(unsafe) ->
     if unsafe then fprintf ppf "bigarray.array1.unsafe_get64"
     else fprintf ppf "bigarray.array1.get64"
  | Pbigstring_set_16(unsafe) ->
     if unsafe then fprintf ppf "bigarray.array1.unsafe_set16"
     else fprintf ppf "bigarray.array1.set16"
  | Pbigstring_set_32(unsafe) ->
     if unsafe then fprintf ppf "bigarray.array1.unsafe_set32"
     else fprintf ppf "bigarray.array1.set32"
  | Pbigstring_set_64(unsafe) ->
     if unsafe then fprintf ppf "bigarray.array1.unsafe_set64"
     else fprintf ppf "bigarray.array1.set64"
  | Pbswap16 -> fprintf ppf "bswap16"
  | Pbbswap(bi) -> print_boxed_integer "bswap" ppf bi
  

type print_kind = 
  | Alias 
  | Strict 
  | StrictOpt 
  | Variable 
  | Recursive 

let kind = function
  | Alias -> "a"
  | Strict -> ""
  | StrictOpt -> "o"
  | Variable -> "v" 
  | Recursive -> "r"

let to_print_kind (k : Lambda.let_kind) : print_kind = 
  match k with 
  | Alias -> Alias 
  | Strict -> Strict
  | StrictOpt -> StrictOpt
  | Variable -> Variable
  
let rec aux (acc : (print_kind * Ident.t * Lam.t ) list) (lam : Lam.t) = 
  match lam with 
  | Llet (str3, id3, arg3, body3) ->
      aux ((to_print_kind str3,id3, arg3)::acc) body3
  | Lletrec (bind_args, body) ->
      aux 
        (List.map (fun (id,l) -> (Recursive,id,l)) bind_args 
         @ acc) body
  | e ->  (acc , e) 

type left_var = 
    {
     kind : print_kind ;
     id : Ident.t
   }

type left = 
  | Id of left_var
  | Nop




let  flatten (lam : Lam.t) : (print_kind * Ident.t * Lam.t ) list * Lam.t = 
  match lam with 
  | Llet(str,id, arg, body) ->
      aux [to_print_kind str, id, arg] body
  | Lletrec(bind_args, body) ->
      aux 
        (List.map (fun (id,l) -> (Recursive, id,l)) bind_args) 
        body
  | _ -> assert false

        
let get_string ((id : Ident.t), (pos : int)) (env : Env.t) : string = 
  match  Env.find_module (Pident id) env with 
  | {md_type = Mty_signature signature  ; _ } -> 
      (* Env.prefix_idents, could be cached  *)
      let serializable_sigs = 
        List.filter (fun x ->
            match x with 
            | Sig_typext _ 
            | Sig_module _
            | Sig_class _ -> true
            | Sig_value(_, {val_kind = Val_prim _}) -> false
            | Sig_value _ -> true
            | _ -> false
                    ) signature  in
      (begin match List.nth  serializable_sigs  pos  with 
      | Sig_value (i,_) 
      | Sig_module (i,_,_) -> i 
      | Sig_typext (i,_,_) -> i 
      | Sig_modtype(i,_) -> i 
      | Sig_class (i,_,_) -> i 
      | Sig_class_type(i,_,_) -> i 
      | Sig_type(i,_,_) -> i 
      end).name
  | _ -> assert false



let lambda use_env env ppf v  =
  let rec lam ppf (l : Lam.t) = match l with 
  | Lvar id ->
      Ident.print ppf id
  | Lconst cst ->
      struct_const ppf cst
  | Lapply { fn; args; } ->
      let lams ppf args =
        List.iter (fun l -> fprintf ppf "@ %a" lam l) args in
      fprintf ppf "@[<2>(apply@ %a%a)@]" lam fn lams args
  | Lfunction{ kind; params; body; _} ->
      let pr_params ppf params =
        match kind with
        | Curried ->
            List.iter (fun param -> fprintf ppf "@ %a" Ident.print param) params
        | Tupled ->
            fprintf ppf " (";
            let first = ref true in
            List.iter
              (fun param ->
                if !first then first := false else fprintf ppf ",@ ";
                Ident.print ppf param)
              params;
            fprintf ppf ")" in
      fprintf ppf "@[<2>(function%a@ %a)@]" pr_params params lam body
  | Llet _ | Lletrec _ as x ->
      let args, body =   flatten x  in
      let bindings ppf id_arg_list =
        let spc = ref false in
        List.iter
          (fun (k, id, l) ->
            if !spc then fprintf ppf "@ " else spc := true;
            fprintf ppf "@[<2>%a =%s@ %a@]" Ident.print id (kind k) lam l)
          id_arg_list in
      fprintf ppf
        "@[<2>(let@ (@[<hv 1>%a@]" bindings (List.rev args);
      fprintf ppf ")@ %a)@]"  lam body
  | Lprim { 
      primitive = Pfield (n,_); 
      args = [ Lprim { primitive = Pgetglobal id; args = [] ; _}]
      ;  _} when use_env ->
      fprintf ppf "%s.%s/%d" id.name (get_string (id,n) env) n

  | Lprim { 
      primitive  = Psetfield (n,_,_); 
      args = [ Lprim { primitive = Pgetglobal id; args = [];  _} ;
               e ]
      ;  _} when use_env  ->
      fprintf ppf "@[<2>(%s.%s/%d <- %a)@]" id.name (get_string (id,n) env) n
        lam e
  | Lprim{primitive = prim; args = largs;  _} ->
      let lams ppf largs =
        List.iter (fun l -> fprintf ppf "@ %a" lam l) largs in
      fprintf ppf "@[<2>(%a%a)@]" primitive prim lams largs
  | Lswitch(larg, sw) ->
      let switch ppf (sw : Lam.switch) =
        let spc = ref false in
        List.iter
         (fun (n, l) ->
           if !spc then fprintf ppf "@ " else spc := true;
           fprintf ppf "@[<hv 1>case int %i:@ %a@]" n lam l)
         sw.sw_consts;
        List.iter
          (fun (n, l) ->
            if !spc then fprintf ppf "@ " else spc := true;
            fprintf ppf "@[<hv 1>case tag %i:@ %a@]" n lam l)
          sw.sw_blocks ;
        begin match sw.sw_failaction with
        | None  -> ()
        | Some l ->
            if !spc then fprintf ppf "@ " else spc := true;
            fprintf ppf "@[<hv 1>default:@ %a@]" lam l
        end in
      fprintf ppf
       "@[<1>(%s %a@ @[<v 0>%a@])@]"
       (match sw.sw_failaction with None -> "switch*" | _ -> "switch")
       lam larg switch sw
  | Lstringswitch(arg, cases, default) ->
      let switch ppf cases =
        let spc = ref false in
        List.iter
         (fun (s, l) ->
           if !spc then fprintf ppf "@ " else spc := true;
           fprintf ppf "@[<hv 1>case \"%s\":@ %a@]" (String.escaped s) lam l)
          cases;
        begin match default with
        | Some default ->
            if !spc then fprintf ppf "@ " else spc := true;
            fprintf ppf "@[<hv 1>default:@ %a@]" lam default
        | None -> ()
        end in
      fprintf ppf
       "@[<1>(stringswitch %a@ @[<v 0>%a@])@]" lam arg switch cases
  | Lstaticraise (i, ls)  ->
      let lams ppf largs =
        List.iter (fun l -> fprintf ppf "@ %a" lam l) largs in
      fprintf ppf "@[<2>(exit@ %d%a)@]" i lams ls;
  | Lstaticcatch(lbody, (i, vars), lhandler) ->
      fprintf ppf "@[<2>(catch@ %a@;<1 -1>with (%d%a)@ %a)@]"
        lam lbody i
        (fun ppf vars -> match vars with
          | [] -> ()
          | _ ->
              List.iter
                (fun x -> fprintf ppf " %a" Ident.print x)
                vars)
        vars
        lam lhandler
  | Ltrywith(lbody, param, lhandler) ->
      fprintf ppf "@[<2>(try@ %a@;<1 -1>with %a@ %a)@]"
        lam lbody Ident.print param lam lhandler
  | Lifthenelse(lcond, lif, lelse) ->
      fprintf ppf "@[<2>(if@ %a@ %a@ %a)@]" lam lcond lam lif lam lelse
  | Lsequence(l1, l2) ->
      fprintf ppf "@[<2>(seq@ %a@ %a)@]" lam l1 sequence l2
  | Lwhile(lcond, lbody) ->
      fprintf ppf "@[<2>(while@ %a@ %a)@]" lam lcond lam lbody
  | Lfor(param, lo, hi, dir, body) ->
      fprintf ppf "@[<2>(for %a@ %a@ %s@ %a@ %a)@]"
       Ident.print param lam lo
       (match dir with Upto -> "to" | Downto -> "downto")
       lam hi lam body
  | Lassign(id, expr) ->
      fprintf ppf "@[<2>(assign@ %a@ %a)@]" Ident.print id lam expr
  | Lsend (k, met, obj, largs, _) ->
      let args ppf largs =
        List.iter (fun l -> fprintf ppf "@ %a" lam l) largs in
      let kind =
        if k = Self then "self" else if k = Cached then "cache" else "" in
      fprintf ppf "@[<2>(send%s@ %a@ %a%a)@]" kind lam obj lam met args largs
  | Lifused(id, expr) ->
      fprintf ppf "@[<2>(ifused@ %a@ %a)@]" Ident.print id lam expr

and sequence ppf = function
  | Lsequence(l1, l2) ->
      fprintf ppf "%a@ %a" sequence l1 sequence l2
  | l ->
      lam ppf l
  in 
  lam ppf v

let structured_constant = struct_const

let env_lambda = lambda true 
let lambda = lambda false Env.empty

let rec flatten_seq acc (lam : Lam.t) =
  match lam with 
  | Lsequence(l1,l2) -> 
      flatten_seq (flatten_seq acc l1) l2
  | x -> x :: acc 

exception Not_a_module

let rec flat (acc : (left * Lam.t) list ) (lam : Lam.t) = 
  match lam with 
  | Llet (str,id,arg,body) ->
      flat ( (Id {kind = to_print_kind str;  id}, arg) :: acc) body 
  | Lletrec (bind_args, body) ->
      flat ( List.map (fun (id, arg ) -> (Id {kind = Recursive;  id}, arg)) bind_args @ acc) body 
  | Lsequence (l,r) -> 
      flat (flat acc l) r
  | x -> (Nop, x) :: acc 

let lambda_as_module env  ppf (lam : Lam.t) = 
  try
  match lam with
  | Lprim {primitive = Psetglobal id ; args =  [biglambda]; _}
  (* might be wrong in toplevel *) ->
      
      begin match flat [] biglambda  with 
      | (Nop, Lprim {primitive = Pmakeblock (_, _, _); args =  toplevels; _})
        :: rest ->
          (* let spc = ref false in *)
          List.iter
            (fun (left, l) ->
              match left with 
              | Id { kind = k; id } ->
                  fprintf ppf "@[<2>%a =%s@ %a@]@." Ident.print id (kind k) (env_lambda env) l
              | Nop -> 

                  fprintf ppf "@[<2>%a@]@."   (env_lambda env) l
            )

            @@ List.rev rest
          
          
      | _ -> raise Not_a_module
      end
  | _ -> raise Not_a_module
  with _ -> 
    env_lambda env ppf lam;
    fprintf ppf "; lambda-failure"
let seriaize env (filename : string) (lam : Lam.t) : unit =
  let ou = open_out filename  in
  let old = Format.get_margin () in
  let () = Format.set_margin 10000 in
  let fmt = Format.formatter_of_out_channel ou in
  begin
    (* lambda_as_module env fmt lambda; *)
    lambda fmt lam;
    Format.pp_print_flush fmt ();
    close_out ou;
    Format.set_margin old
  end

end
module Lam_stats : sig 
#1 "lam_stats.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Types defined for lambda analysis *)


type alias_tbl =  (Ident.t, Ident.t) Hashtbl.t
(** Keep track of which identifiers are aliased
  *)

type state = 
  | Live (** Globals are always live *)
  | Dead  (** removed after elimination *)
  | NA

type function_kind = 
  | Functor 
  | Function
  | NA

type rec_flag = 
  | Rec 
  | Non_rec

type function_id = {
  kind : function_kind ; 
  mutable arity : Lam.function_arities;
  lambda  : Lam.t ;
  (* TODO: This may contain some closure environment,
     check how it will interact with dead code elimination
  *)
  rec_flag : rec_flag
}

type element = 
  | NA 
  | SimpleForm of Lam.t 

type boxed_nullable
  = 
  | Undefined 
  | Null 
  | Null_undefined
  | Normal 

type kind = 
  | ImmutableBlock of element array * boxed_nullable
  | MutableBlock of element array
  | Constant of Lambda.structured_constant
  | Module of Ident.t
        (** TODO: static module vs first class module *)
  | Function of function_id 
  | Exception 
  | Parameter
      (** For this case, it can help us determine whether it should be inlined or not *)

  | NA (** Not such information is associated with an identifier, it is immutable, 
           if you only associate a property to an identifier 
           we should consider [Lassign]
        *)

type ident_tbl = (Ident.t, kind) Hashtbl.t 

type ident_info = {
  kind : kind ; 
  state : state
}

type meta = {
  env : Env.t;
  filename : string ;
  export_idents : Ident_set.t ;
  exports : Ident.t list ;
  alias_tbl : alias_tbl; 
  exit_codes : int Hash_set.hashset;

  ident_tbl : ident_tbl;
  (** we don't need count arities for all identifiers, for identifiers
      for sure it's not a function, there is no need to count them
   *)

  mutable required_modules : Lam_module_ident.t list ;
}

end = struct
#1 "lam_stats.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(* It can be useful for common sub expression elimination ? 
    if two lambdas are not equal, it should return false, other wise, 
    it might return true , this is only used as a way of optimizaton

    Use case :
    1. switch case -- common fall through
 *)

(* lambda pass for alpha conversion 
    and alias
    we need think about the order of the pass, might be the alias pass can be done 
    in the  beginning, when we do alpha conversion, we can instrument the table 
 *)

type function_arities = Lam.function_arities

type alias_tbl =  (Ident.t, Ident.t) Hashtbl.t

type function_kind = 
  | Functor 
  | Function
  | NA

type rec_flag = 
  | Rec 
  | Non_rec

type function_id = {
  kind : function_kind ; 
  mutable arity : function_arities ;
  lambda  : Lam.t ;
  rec_flag : rec_flag
}

type element = 
  | NA 
  | SimpleForm of Lam.t

type boxed_nullable
  = 
  | Undefined 
  | Null 
  | Null_undefined
  | Normal 

type kind = 
  | ImmutableBlock of element array * boxed_nullable
  | MutableBlock of element array 
  | Constant of Lambda.structured_constant
  | Module of Ident.t
        (** Global module, local module is treated as an array
         *)
  | Function of function_id (** True then functor *)
  | Exception 
  | Parameter
      (** For this case, it can help us determine whether it should be inlined or not *)
  | NA 
  (* | Boxed_nullable of Ident.t  *)
    (** 
       {[ let v/2 =  js_from_nullable u]} 

       {[ let v/2 = js_from_nullable exp]}
       can be translated into 
       {[
         let v/1 = exp in 
         let v/2 =a js_from_nullable exp 
       ]}
       so that [Pfield v/2 0] will be replaced by [v/1], 
       [Lif(v/1)] will be translated into [Lif (v/2 === undefined )]
    *)
type ident_tbl = (Ident.t, kind) Hashtbl.t 

type state = 
  | Live (** Globals are always live *)
  | Dead  (** removed after elimination *)
  | NA

type ident_info = {
  kind : kind ; 
  state : state
}

type meta = {
  env : Env.t;
  filename : string ;
  export_idents : Ident_set.t ;
  exports : Ident.t list ;

  alias_tbl : alias_tbl; 
  exit_codes : int Hash_set.hashset;

  ident_tbl : ident_tbl;
  (** we don't need count arities for all identifiers, for identifiers
      for sure it's not a function, there is no need to count them
  *)
  (** required modules completed by [alias_pass] *)
  mutable required_modules : Lam_module_ident.t list ;
}


end
module Lam_util : sig 
#1 "lam_util.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








val string_of_lambda : Lam.t -> string 

val string_of_primitive : Lam.primitive -> string

val kind_of_lambda_block : Lam_stats.boxed_nullable -> Lam.t list -> Lam_stats.kind

val get : Lam.t -> Ident.t -> int -> Lam_stats.ident_tbl -> Lam.t

val add_required_module : Ident.t -> Lam_stats.meta -> unit

val add_required_modules : Ident.t list -> Lam_stats.meta -> unit

val alias : Lam_stats.meta ->
  Ident.t -> Ident.t -> Lam_stats.kind -> Lambda.let_kind -> unit 


val refine_let : 
    ?kind:Lambda.let_kind ->
      Ident.t -> Lam.t -> Lam.t -> Lam.t


val generate_label : ?name:string -> unit -> J.label

val sort_dag_args : J.expression Ident_map.t -> Ident.t list option
(** if [a] depends on [b] a is ahead of [b] as [a::b]

    TODO: make it a stable sort 
 *)


(** [dump] when {!Js_config.is_same_file}*)
val dump : Env.t   -> string -> Lam.t -> Lam.t

val ident_set_of_list : Ident.t list -> Ident_set.t

val print_ident_set : Format.formatter -> Ident_set.t -> unit



val not_function : Lam.t -> bool 
val is_function : Lam.t -> bool 


val eta_conversion : 
  int ->
  Location.t -> Lam.apply_status -> Lam.t -> Lam.t list -> Lam.t



val subst_lambda : Lam.t Ident_map.t -> Lam.t -> Lam.t


(* TODO; check {!Lam_analysis.free_variables} *)
val free_variables : Lam.t -> Ident_set.t

end = struct
#1 "lam_util.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








let string_of_lambda = Format.asprintf "%a" Lam_print.lambda 

let string_of_primitive = Format.asprintf "%a" Lam_print.primitive


(* TODO: not very efficient .. *)
exception Cyclic 
      
let toplogical (get_deps : Ident.t -> Ident_set.t) (libs : Ident.t list) : Ident.t list =
  let rec aux acc later todo round_progress =
    match todo, later with
    | [], [] ->  acc
    | [], _ ->
        if round_progress
        then aux acc todo later false
        else raise Cyclic
    | x::xs, _ ->
        if Ident_set.for_all (fun dep -> x == dep || List.mem dep acc) (get_deps x)
        then aux (x::acc) later xs true
        else aux acc (x::later) xs round_progress
  in
  let starts, todo = List.partition (fun lib -> Ident_set.is_empty @@ get_deps lib) libs in
  aux starts [] todo false

let sort_dag_args  param_args =
  let todos = Ident_map.keys param_args  in
  let idents = Ident_set.of_list  todos in
  let dependencies  : Ident_set.t Ident_map.t = 
    Ident_map.mapi (fun param arg -> Js_fold_basic.depends_j arg idents) param_args in
  try  
    Some (toplogical (fun k -> Ident_map.find k dependencies) todos)
  with Cyclic -> None 



let add_required_module (x : Ident.t) (meta : Lam_stats.meta) = 
  meta.required_modules <- Lam_module_ident.of_ml x :: meta.required_modules 

let add_required_modules ( x : Ident.t list) (meta : Lam_stats.meta) = 
  let required_modules = 
    List.map 
      (fun x -> Lam_module_ident.of_ml x)  x
    @ meta.required_modules in
  meta.required_modules <- required_modules

(* Apply a substitution to a lambda-term.
   Assumes that the bound variables of the lambda-term do not
   belong to the domain of the substitution.
   Assumes that the image of the substitution is out of reach
   of the bound variables of the lambda-term (no capture). *)

let subst_lambda (s : Lam.t Ident_map.t) lam =
  let rec subst (x : Lam.t) : Lam.t =
    match x with 
    | Lvar id as l ->
      begin 
        try Ident_map.find id s with Not_found -> l 
      end
    | Lconst sc as l -> l
    | Lapply{fn; args; loc; status} -> 
      Lam.apply (subst fn) (List.map subst args) loc status
    | Lfunction {arity; kind; params; body} -> 
      Lam.function_ ~arity ~kind  ~params ~body:(subst body)
    | Llet(str, id, arg, body) -> 
      Lam.let_ str id (subst arg) (subst body)
    | Lletrec(decl, body) -> 
      Lam.letrec (List.map subst_decl decl) (subst body)
    | Lprim { primitive ; args; loc} -> 
      Lam.prim ~primitive ~args:(List.map subst args) loc
    | Lswitch(arg, sw) ->
      Lam.switch (subst arg)
        {sw with sw_consts = List.map subst_case sw.sw_consts;
                 sw_blocks = List.map subst_case sw.sw_blocks;
                 sw_failaction = subst_opt  sw.sw_failaction; }
    | Lstringswitch (arg,cases,default) ->
      Lam.stringswitch
        (subst arg) (List.map subst_strcase cases) (subst_opt default)
    | Lstaticraise (i,args)
      ->  Lam.staticraise i (List.map subst args)
    | Lstaticcatch(e1, io, e2)
      -> Lam.staticcatch (subst e1) io (subst e2)
    | Ltrywith(e1, exn, e2)
      -> Lam.try_ (subst e1) exn (subst e2)
    | Lifthenelse(e1, e2, e3)
      -> Lam.if_ (subst e1) (subst e2) (subst e3)
    | Lsequence(e1, e2)
      -> Lam.seq (subst e1) (subst e2)
    | Lwhile(e1, e2) 
      -> Lam.while_ (subst e1) (subst e2)
    | Lfor(v, e1, e2, dir, e3) 
      -> Lam.for_ v (subst e1) (subst e2) dir (subst e3)
    | Lassign(id, e) -> 
      Lam.assign id (subst e)
    | Lsend (k, met, obj, args, loc) ->
      Lam.send k (subst met) (subst obj) (List.map subst args) loc
    | Lifused (v, e) -> Lam.ifused v (subst e)
  and subst_decl (id, exp) = (id, subst exp)
  and subst_case (key, case) = (key, subst case)
  and subst_strcase (key, case) = (key, subst case)
  and subst_opt = function
    | None -> None
    | Some e -> Some (subst e)
  in subst lam

(* 
    It's impossible to have a case like below:
   {[
     (let export_f = ... in export_f)
   ]}
    Even so, it's still correct
*)
let refine_let
    ?kind param
    (arg : Lam.t) (l : Lam.t)  : Lam.t =

  match (kind : Lambda.let_kind option), arg, l  with 
  | _, _, Lvar w when Ident.same w param (* let k = xx in k *)
    -> arg (* TODO: optimize here -- it's safe to do substitution here *)
  | _, _, Lprim {primitive ; args =  [Lvar w]; loc ; _} when Ident.same w param 
                                 &&  (function | Lam.Pmakeblock _ -> false | _ ->  true) primitive
    (* don't inline inside a block *)
    ->  Lam.prim ~primitive ~args:[arg]  loc 
  (* we can not do this substitution when capttured *)
  (* | _, Lvar _, _ -> (\** let u = h in xxx*\) *)
  (*     (\* assert false *\) *)
  (*     Ext_log.err "@[substitution >> @]@."; *)
  (*     let v= subst_lambda (Ident_map.singleton param arg ) l in *)
  (*     Ext_log.err "@[substitution << @]@."; *)
  (* v *)
  | _, _, Lapply {fn; args = [Lvar w]; loc; status} when Ident.same w param -> 
    (** does not work for multiple args since 
        evaluation order unspecified, does not apply 
        for [js] in general, since the scope of js ir is loosen

        here we remove the definition of [param]
    *)
    Lam.apply fn [arg] loc status
  | (Some (Strict | StrictOpt ) | None ),
    ( Lvar _    | Lconst  _ | 
      Lprim {primitive = Pfield _ ;  
             args = [Lprim {primitive = Pgetglobal _ ; args =  []; _}]; _}) , _ ->
    (* (match arg with  *)
    (* | Lconst _ ->  *)
    (*     Ext_log.err "@[%a %s@]@."  *)
    (*       Ident.print param (string_of_lambda arg) *)
    (* | _ -> ()); *)
    (* No side effect and does not depend on store,
        since function evaluation is always delayed
    *)
    Lam.let_ Alias param arg l
  | (Some (Strict | StrictOpt ) | None ), (Lfunction _ ), _ ->
    (*It can be promoted to [Alias], however, 
        we don't want to do this, since we don't want the 
        function to be inlined to a block, for example
        {[
          let f = fun _ -> 1 in
          [0, f]
        ]}
        TODO: punish inliner to inline functions 
        into a block 
    *)
    Lam.let_ StrictOpt  param arg l
  (* Not the case, the block itself can have side effects 
      we can apply [no_side_effects] pass 
      | Some Strict, Lprim(Pmakeblock (_,_,Immutable),_) ->  
        Llet(StrictOpt, param, arg, l) 
  *)      
  | Some Strict, _ ,_  when Lam_analysis.no_side_effects arg ->
    Lam.let_ StrictOpt param arg l
  | Some Variable, _, _ -> 
    Lam.let_ Variable  param arg l
  | Some kind, _, _ -> 
    Lam.let_ kind  param arg l
  | None , _, _ -> 
    Lam.let_ Strict param arg  l

let alias (meta : Lam_stats.meta) (k:Ident.t) (v:Ident.t) 
    (v_kind : Lam_stats.kind) (let_kind : Lambda.let_kind) =
  (** treat rec as Strict, k is assigned to v 
      {[ let k = v ]}
  *)
  begin 
    match v_kind with 
    | NA ->
      begin 
        match Hashtbl.find meta.ident_tbl v  with 
        | exception Not_found -> ()
        | ident_info -> Hashtbl.add meta.ident_tbl k ident_info
      end
    | ident_info -> Hashtbl.add meta.ident_tbl k ident_info
  end ;
  (* share -- it is safe to share most properties,
      for arity, we might be careful, only [Alias] can share,
      since two values have same type, can have different arities
      TODO: check with reference pass, it might break 
      since it will create new identifier, we can avoid such issue??

      actually arity is a dynamic property, for a reference, it can 
      be changed across 
      we should treat
      reference specially. or maybe we should track any 
      mutable reference
  *)
  begin match let_kind with 
    | Alias -> 
      if not @@ Ident_set.mem k meta.export_idents 
      then
        Hashtbl.add meta.alias_tbl k v 
    (** For [export_idents], we don't want to do such simplification
        if we do substitution, then it will affect exports...
    *)
    | Strict | StrictOpt(*can discard but not be substitued *) | Variable  -> ()
  end




(* How we destruct the immutable block 
   depend on the block name itself, 
   good hints to do aggressive destructing
   1. the variable is not exported
      like [matched] -- these are blocks constructed temporary
   2. how the variable is used 
      if it is guarateed to be 
      - non export 
      - and non escaped (there is no place it is used as a whole)
      then we can always destruct it 
      if some fields are used in multiple places, we can create 
      a temporary field 

   3. It would be nice that when the block is mutable, its 
       mutable fields are explicit
*)

let element_of_lambda (lam : Lam.t) : Lam_stats.element = 
  match lam with 
  | Lvar _ 
  | Lconst _ 
  | Lprim {primitive = Pfield _ ; 
           args =  [ Lprim { primitive = Pgetglobal _; args =  []; _}];
           _} -> SimpleForm lam
  (* | Lfunction _  *)
  | _ -> NA 

let kind_of_lambda_block kind (xs : Lam.t list) : Lam_stats.kind = 
  xs 
  |> List.map element_of_lambda 
  |> (fun ls -> Lam_stats.ImmutableBlock (Array.of_list  ls, kind))

let get lam v i tbl : Lam.t =
  match (Hashtbl.find tbl v  : Lam_stats.kind) with 
  | Module g -> 
    Lam.prim ~primitive:(Pfield (i, Lambda.Fld_na)) 
      ~args:[Lam.prim ~primitive:(Pgetglobal g) ~args:[] Location.none] Location.none
  | ImmutableBlock (arr, _) -> 
    begin match arr.(i) with 
      | NA -> lam 
      | SimpleForm l -> l
    end
  | Constant (Const_block (_,_,ls)) -> 
    Lam.const (List.nth  ls i)
  | _ -> lam
  | exception Not_found -> lam 


(* TODO: check that if label belongs to a different 
    namesape
*)
let count = ref 0 

let generate_label ?(name="") ()  = 
  incr count; 
  Printf.sprintf "%s_tailcall_%04d" name !count

let log_counter = ref 0


let dump env ext  lam = 
    
  if Js_config.is_same_file ()
  then 
    (* ATTENTION: easy to introduce a bug during refactoring when forgeting `begin` `end`*)
    begin 
      incr log_counter;
      Lam_print.seriaize env 
        (Ext_filename.chop_extension 
           ~loc:__LOC__ 
           (Js_config.get_current_file ()) ^ 
         (Printf.sprintf ".%02d%s.lam" !log_counter ext)
        ) lam;
    end;
  lam


let ident_set_of_list ls = 
  List.fold_left
    (fun acc k -> Ident_set.add k acc ) 
    Ident_set.empty ls 

let print_ident_set fmt s = 
  Format.fprintf fmt   "@[<v>{%a}@]@."
    (fun fmt s   -> 
       Ident_set.iter 
         (fun e -> Format.fprintf fmt "@[<v>%a@],@ " Ident.print e) s
    )
    s     




let is_function (lam : Lam.t) = 
  match lam with 
  | Lfunction _ -> true | _ -> false

let not_function (lam : Lam.t) = 
  match lam with 
  | Lfunction _ -> false | _ -> true 

(* TODO: we need create 
   1. a smart [let] combinator, reusable beta-reduction 
   2. [lapply fn args info] 
   here [fn] should get the last tail
   for example 
   {[
     lapply (let a = 3 in let b = 4 in fun x y -> x + y) 2 3 
   ]}   
*)

(*
  let f x y =  x + y 
  Invariant: there is no currying 
  here since f's arity is 2, no side effect 
  f 3 --> function(y) -> f 3 y 
*)
let eta_conversion n loc status fn args = 
  let extra_args = Ext_list.init n
      (fun _ ->   (Ident.create Literals.param)) in
  let extra_lambdas = List.map (fun x -> Lam.var x) extra_args in
  begin match List.fold_right (fun (lam : Lam.t) (acc, bind) ->
      match lam with
      | Lvar _
      | Lconst (Const_base _ | Const_pointer _ | Const_immstring _ ) 
      | Lprim {primitive = Pfield _;
               args =  [Lprim {primitive = Pgetglobal _; _}]; _ }
      | Lfunction _ 
        ->
        (lam :: acc, bind)
      | _ ->
        let v = Ident.create Literals.partial_arg in
        (Lam.var v :: acc),  ((v, lam) :: bind)
    ) (fn::args) ([],[])   with 
  | fn::args , bindings ->

    let rest : Lam.t = 
      Lam.function_ ~arity:n ~kind:Curried ~params:extra_args
                ~body:(Lam.apply fn (args @ extra_lambdas) 
                   loc 
                   status
                ) in
    List.fold_left (fun lam (id,x) ->
        Lam.let_ Strict id x lam
      ) rest bindings
  | _, _ -> assert false
  end




let free_variables l =
  let fv = ref Ident_set.empty in
  let rec free (l : Lam.t) =
    Lam_iter.inner_iter free l;
    match l with
    | Lvar id -> fv := Ident_set.add id !fv
    | Lfunction{ params;} -> 
      List.iter (fun param -> fv := Ident_set.remove param !fv) params
    | Llet(str, id, arg, body) ->
      fv := Ident_set.remove id !fv
    | Lletrec(decl, body) ->
      List.iter (fun (id, exp) -> fv := Ident_set.remove id !fv) decl
    | Lstaticcatch(e1, (_,vars), e2) ->
      List.iter (fun id -> fv := Ident_set.remove id !fv) vars
    | Ltrywith(e1, exn, e2) ->
      fv := Ident_set.remove exn !fv
    | Lfor(v, e1, e2, dir, e3) ->
      fv := Ident_set.remove v !fv
    | Lassign(id, e) ->
      fv := Ident_set.add id !fv
    | Lconst _ | Lapply _
    | Lprim _ | Lswitch _ | Lstringswitch _ | Lstaticraise _
    | Lifthenelse _ | Lsequence _ | Lwhile _
    | Lsend _  | Lifused _ -> ()
  in free l; !fv

end
module Js_stmt_make : sig 
#1 "js_stmt_make.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Creator utilities for the [J] module *) 


type t = J.statement 

val mk :  ?comment:string  -> J.statement_desc -> t

val empty : ?comment:string  ->  unit -> t

val throw : ?comment:string  -> J.expression -> t

val if_ : 
  ?comment:string  ->
  ?declaration: Lambda.let_kind * Ident.t ->
  (* when it's not None, we also need make a variable declaration in the
     begininnig, however, we can optmize such case
  *)
  ?else_:J.block ->  
  J.expression -> 
  J.block -> 
  t

val block : ?comment:string  -> J.block -> t

val int_switch :
  ?comment:string -> ?declaration:Lambda.let_kind * Ident.t -> 
  ?default:J.block -> J.expression -> int J.case_clause list -> t 

val string_switch : ?comment:string -> ?declaration:Lambda.let_kind * Ident.t -> 
  ?default:J.block -> J.expression -> string J.case_clause list -> t

val declare_variable : ?comment:string ->
  ?ident_info:J.ident_info 
  -> kind:Lambda.let_kind -> Ident.t -> t

val define : 
  ?comment:string ->
  ?ident_info:J.ident_info ->
  kind:Lambda.let_kind -> Ident.t -> J.expression  -> t

val alias_variable :
  ?comment:string -> ?exp:J.expression -> Ident.t -> t
val assign : ?comment:string  -> J.ident -> J.expression -> t

val assign_unit : ?comment:string  -> J.ident -> t

val declare_unit : ?comment:string  -> J.ident -> t

val while_ : ?comment:string ->
  ?label:J.label -> ?env:Js_closure.t -> J.expression -> J.block -> t

val for_ : 
  ?comment:string ->
  ?env:Js_closure.t ->
  J.for_ident_expression option ->
  J.finish_ident_expression ->
  J.for_ident  -> J.for_direction -> J.block -> t

val try_ :
  ?comment:string  ->
  ?with_:J.ident * J.block -> ?finally:J.block -> J.block -> t

val exp : ?comment:string  -> J.expression -> t

val return : ?comment:string  -> J.expression -> t

val unknown_lambda : ?comment:string  -> Lam.t -> t

val return_unit : ?comment:string -> unit -> t
(** for ocaml function which returns unit 
    it will be compiled into [return 0] in js *)

val break : ?comment:string  -> unit -> t

(** if [label] is not set, it will default to empty *)  
val continue : ?comment:string  -> ?label:J.label -> unit  -> t

val debugger :  t

end = struct
#1 "js_stmt_make.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






module E = Js_exp_make 

type t = J.statement 

let return ?comment e : t = 
  {statement_desc = Return {return_value = e; } ; comment}

let return_unit ?comment () : t =              
  return ?comment  E.unit 

let break ?comment () : t = 
  {comment ; statement_desc = Break }

let mk ?comment  statement_desc : t = 
  {statement_desc; comment}

let empty ?comment  () : t = { statement_desc = Block []; comment}

let throw ?comment v : t = { statement_desc = J.Throw v; comment}

(* avoid nested block *)
let  rec block ?comment  (b : J.block)   : t =  
  match b with 
  | [{statement_desc = Block bs }  ] -> block bs
  | [b] -> b
  | [] -> empty ?comment ()
  | _ -> {statement_desc = Block b  ; comment}

(* It's a statement, we can discard some values *)       
let rec exp ?comment (e : E.t) : t = 
  match e.expression_desc with 
  | (Seq( {expression_desc = Number _}, b) 
    | Seq( b, {expression_desc = Number _})) -> exp ?comment b 
  | Number _ -> block []
  (* TODO: we can do more *)      
  (* | _ when is_pure e ->  block [] *)
  |  _ -> 
    { statement_desc = Exp e; comment}

let declare_variable ?comment  ?ident_info  ~kind (v:Ident.t)  : t=
  let property : J.property =  kind in
  let ident_info  : J.ident_info  = 
    match ident_info with
    | None ->  {used_stats = NA}
    | Some x -> x in
  {statement_desc = 
     Variable { ident = v; value = None; property ; 
                ident_info ;};
   comment}

let define ?comment  ?ident_info ~kind (v:Ident.t) exp    : t=
  let property : J.property =  kind in
  let ident_info  : J.ident_info  = 
    match ident_info with
    | None ->  {used_stats = NA}
    | Some x -> x in
  {statement_desc = 
     Variable { ident = v; value =  Some exp; property ; 
                ident_info ;};
   comment}

let int_switch ?comment   ?declaration ?default (e : J.expression)  clauses : t = 
  match e.expression_desc with 
  | Number (Int {i; _}) -> 
    let continuation =  
      begin match List.find (fun (x : _ J.case_clause) -> x.case = (Int32.to_int i)) clauses
        with 
        | case -> fst case.body
        | exception Not_found -> 
          begin match default with
            | Some x ->  x 
            | None -> assert false
          end 
      end in
    begin match declaration, continuation with 
      | Some (kind, did), 
        [ {statement_desc = Exp {expression_desc = Bin(Eq,  {expression_desc = Var (Id id) ; _}, e0); _}; _}]
        when Ident.same did id 
        -> 
        define ?comment ~kind id e0
      | Some(kind,did), _ 
        -> 
        block (declare_variable ?comment ~kind did :: continuation)
      | None, _ -> block continuation
    end

  | _ -> 
    match declaration with 
    | Some (kind, did) -> 
      block [declare_variable ?comment ~kind did ;
             { statement_desc = J.Int_switch (e,clauses, default); comment}]
    | None ->  { statement_desc = J.Int_switch (e,clauses, default); comment}

let string_switch ?comment ?declaration  ?default (e : J.expression)  clauses : t= 
  match e.expression_desc with 
  | Str (_,s) -> 
    let continuation = 
      begin match List.find 
                    (fun  (x : string J.case_clause) -> x.case = s) clauses
        with 
        | case ->  (fst case.body)
        | exception Not_found -> 
          begin match default with 
            | Some x -> x 
            | None -> assert false 
          end
      end in
    begin match declaration, continuation with 
      | Some (kind, did),
        [ {statement_desc = Exp {expression_desc = Bin(Eq,  {expression_desc = Var (Id id); _}, e0);_} ; _}]
        when Ident.same did id 
        -> 
        define ?comment ~kind id e0
      | Some(kind,did), _ 
        -> 
        block @@ declare_variable ?comment ~kind did :: continuation
      | None, _ -> block continuation
    end
  | _  -> 
    match declaration with 
    | Some (kind,did) -> 
      block [declare_variable ?comment ~kind did ;
             { statement_desc = String_switch (e,clauses, default); comment}]
    | None -> { statement_desc = String_switch (e,clauses, default); comment}


(* TODO: it also make sense  to extract some common statements 
    between those two branches, it does happen since in OCaml you 
    have to write some duplicated code due to the types system restriction
    example:
   {[
     | Format_subst (pad_opt, fmtty, rest) ->
       buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;
       bprint_pad_opt buf pad_opt; buffer_add_char buf '(';
       bprint_fmtty buf fmtty; buffer_add_char buf '%'; buffer_add_char buf ')';
       fmtiter rest false;

       | Scan_char_set (width_opt, char_set, rest) ->
       buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;
       bprint_pad_opt buf width_opt; bprint_char_set buf char_set;
       fmtiter rest false;
   ]}
*)
let rec if_ ?comment  ?declaration ?else_ (e : J.expression) (then_ : J.block)   : t = 
  let declared = ref false in
  let rec aux ?comment (e : J.expression) (then_ : J.block) (else_ : J.block ) acc   =
    match e.expression_desc, then_, (else_ : J.block ) with 
    | _, [ {statement_desc = Return {return_value = b; _}; _}], 
      [ {statement_desc = Return {return_value = a; _}; _}]
      ->
      return (E.econd e b a ) :: acc 
    | _,  [ {statement_desc = 
               Exp {expression_desc = Bin(Eq, ({expression_desc = Var (Id id0); _} as l0), a0); _}; _}], 
      [ {statement_desc = 
           Exp ({ expression_desc = Bin(Eq, 
                                        {expression_desc = Var (Id id1); _}, b0); _}); _}]
      when Ident.same id0 id1 -> 
      begin match declaration with 
        | Some (kind,did)  when Ident.same did id0 -> 
          declared := true;
          define ~kind id0 (E.econd e a0 b0) :: acc 
        (* To hit this branch, we also need [declaration] passed down 
           TODO: check how we compile [Lifthenelse]
        *)
        | _ -> 
          exp (E.assign l0 (E.econd e a0 b0)) :: acc 
      end

    | _,  _,  
      [ {statement_desc = Exp {expression_desc = Number _}; _}]
      ->
      aux ?comment e then_ [] acc 
    | _, [ {statement_desc = Exp {expression_desc = Number _}; _}], _
      ->
      aux ?comment e [] else_ acc 

    | _,  [ {statement_desc = Exp b; _}],  [ {statement_desc = Exp a; _}]
      ->
      exp (E.econd e b a) :: acc 
    | _, [], []                                   
      -> exp e :: acc 

    | Not e, _ , _ :: _
      -> aux ?comment e else_ then_ acc
    | _, [], _
      ->
      aux ?comment (E.not e) else_ [] acc
    (* Be careful that this re-write may result in non-terminating effect *)
    | _, (y::ys),  (x::xs)
      when Js_analyzer.(eq_statement x y && no_side_effect_expression e)
      ->
      (** here we do agressive optimization, because it can help optimization later,
          move code outside of branch is generally helpful later
      *)
      aux ?comment e ys xs (y::acc)

    |  Number ( Int { i = 0l; _}) , _,  _
      ->  
      begin match else_ with 
        | [] -> acc 
        | _ -> block else_ ::acc
      end
    |  (Number _ , _, _
       | (Bin (Ge, 
               ({expression_desc = Length _;
                 _}), {expression_desc = Number (Int { i = 0l; _})})), _ , _)
      (* TODO: always 
          turn [Le] -> into [Ge]
      *)
      -> block then_ :: acc 
    | Bin (Bor , a, {expression_desc = Number (Int { i = 0l ; _})}), _, _ 
    | Bin (Bor , {expression_desc = Number (Int { i = 0l ; _})}, a), _, _ 
      -> 
      aux ?comment a  then_ else_ acc

    | (
      (Bin (((EqEqEq ), {expression_desc = Number (Int {i = 0l; _}); _},e)) |
       Bin ((EqEqEq ), e,{expression_desc = Number (Int {i = 0l; _});_}))
    ),  _,  else_ 
      (* TODO: optimize in general of preciate information based on type system 
          like: [if_], [econd]
      *)
      ->
      aux ?comment e else_  then_ acc 

    (* | Bin (NotEqEq, e1,  *)
    (*        {expression_desc = Var (Id ({name = "undefined"; _} as id))}), *)
    (*   _, _ *)
    (*   when Ext_ident.is_js id ->  *)
    (*   aux ?comment e1 then_ else_ acc  *)

    | ((Bin (Gt, 
             ({expression_desc = 
                 Length _;
               _} as e ), {expression_desc = Number (Int { i = 0l; _})}))

      | Int_of_boolean e), _ , _
      ->
      (** Add comment when simplified *)
      aux ?comment e then_ else_ acc 

    | _ -> 
      { statement_desc = If (e, 
                             then_,
                             (match else_ with 
                              | [] -> None
                              |  v -> Some  v)); 
        comment } :: acc in
  let if_block = 
    aux ?comment e then_ (match else_ with None -> [] | Some v -> v) [] in

  match !declared, declaration with 
  | true , _ 
  | _    , None  ->  block (List.rev if_block)
  | false, Some (kind, did) -> block (declare_variable ~kind did :: List.rev if_block )



let alias_variable ?comment  ?exp (v:Ident.t)  : t=
  {statement_desc = 
     Variable {
       ident = v; value = exp; property = Alias;
       ident_info = {used_stats = NA }   };
   comment}

let assign ?comment  id e : t = 
  {
    statement_desc = J.Exp ( E.assign (E.var id) e ) ;
    comment
  }
let assign_unit ?comment  id :  t = 
  {
    statement_desc = J.Exp( E.assign (E.var id) E.unit);
    comment
  }
let declare_unit ?comment  id :  t = 
  {
    statement_desc = 
      J.Variable { ident =  id; 
                   value = Some E.unit;
                   property = Variable;
                   ident_info = {used_stats = NA}
                 };
    comment
  }

let rec while_  ?comment  ?label ?env (e : E.t) (st : J.block) : t = 
  match e with 
  | {expression_desc = Int_of_boolean e; _} -> 
    while_ ?comment  ?label  e st
  | _ -> 
    let env = 
      match env with 
      | None -> Js_closure.empty ()
      | Some x -> x in
    {
      statement_desc = While (label, e, st, env);
      comment
    }

let for_ ?comment   ?env 
    for_ident_expression
    finish_ident_expression id direction (b : J.block) : t =
  let env = 
    match env with 
    | None -> Js_closure.empty ()
    | Some x -> x 
  in
  {
    statement_desc = 
      ForRange (for_ident_expression, finish_ident_expression, id, direction, b, env);
    comment
  }

let try_ ?comment   ?with_ ?finally body : t = 
  {
    statement_desc = Try (body, with_, finally) ;
    comment
  }

let unknown_lambda ?(comment="unknown")  (lam : Lam.t ) : t = 
  exp @@ E.str ~comment ~pure:false (Lam_util.string_of_lambda lam) 

(* TODO: 
    actually, only loops can be labelled
*)    
let continue  ?comment   ?(label="") unit  : t = 
  { 
    statement_desc = J.Continue  label;
    comment;
  }

let debugger : t = 
  { statement_desc = J.Debugger ; 
    comment = None 
  }

end
module Type_int_to_string
= struct
#1 "type_int_to_string.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

let name_of_signature_item (x : Types.signature_item )=
  match x with 
  | Sig_value (i,_) 
  | Sig_module (i,_,_) -> i 
  | Sig_typext (i,_,_) -> i 
  | Sig_modtype(i,_) -> i 
  | Sig_class (i,_,_) -> i 
  | Sig_class_type(i,_,_) -> i 
  | Sig_type(i,_,_) -> i  


(** It should be safe to replace Pervasives[], 
    we should test cases  like module Pervasives = List *)
let serializable_signature =
  (fun x ->
     match (x : Types.signature_item) with 
     | Sig_value(_, {val_kind = Val_prim _}) -> false
     | Sig_typext _ 
     | Sig_module _
     | Sig_class _ 
     | Sig_value _ -> true
     | _ -> false)
  
let filter_serializable_signatures (signature : Types.signature)
  : Types.signature = 
  List.filter serializable_signature signature

end
module Type_util : sig 
#1 "type_util.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Utilities for quering typing inforaation from {!Env.t}, this part relies
    on compiler API
*)


val get_name : Types.signature -> int -> string


(* Input path is a global module 
    TODO: it should be fine for local module*)
val find_serializable_signatures_by_path :
  Ident.t -> Env.t -> Types.signature option


(* val find_name : *)
(*   Ident.t -> int -> Env.t -> string option *)




end = struct
#1 "type_util.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)



(* Input path is a global module 
    TODO: it should be fine for local module
*)
let find_serializable_signatures_by_path v (env : Env.t) 
  : Types.signature option = 
  match Env.find_module (Pident v) env with 
  | exception Not_found -> None 
  | {md_type = Mty_signature signature; _} -> 
    Some (Type_int_to_string.filter_serializable_signatures signature)
  (** TODO: refine *)
  | _ -> Ext_log.err __LOC__  "@[impossible path %s@]@."
           (Ident.name v) ; assert false 

let rec dump_summary fmt (x : Env.summary) = 
  match x with 
  | Env_empty -> ()
  | Env_value(s,id,value_description) -> 
    dump_summary fmt s ;
    Printtyp.value_description id fmt value_description
  | _ -> ()

(** Used in [Pgetglobal] *)
let get_name  (serializable_sigs : Types.signature) (pos : int) = 
  Ident.name @@ Type_int_to_string.name_of_signature_item @@ List.nth  serializable_sigs  pos

(* let find_name id pos env = *)
(*   match find_serializable_signatures_by_path id env with *)
(*   | Some signatures -> *)
(*     Some (get_name signatures pos) *)
(*   | None -> None       *)



    


end
module Lam_compile_env : sig 
#1 "lam_compile_env.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Helper for global Ocaml module index into meaningful names  *) 

type primitive_description =  Primitive.description

type key = 
  Ident.t * Env.t * bool 
  (** the boolean is expand or not
      when it's passed as module, it should be expanded, 
      otherwise for alias, [include Array], it's okay to return an identifier
      TODO: be more clear about its concept
  *)
  (** we need register which global variable is an dependency *)


type ident_info = {
  id : Ident.t;
  name : string;
  signatures : Types.signature;
  arity : Lam.function_arities; 
  closed_lambda : Lam.t option 
}

type module_info = {
  signature :  Types.signature ;
  pure : bool 
}

type _ t = 
  | No_env :  Js_cmj_format.t t 
  | Has_env : Env.t  -> module_info t 

val find_and_add_if_not_exist : 
  Ident.t * int -> 
  Env.t -> 
  not_found:(Ident.t -> 'a) -> 
  found:(ident_info -> 'a) -> 'a

val query_and_add_if_not_exist : 
  Lam_module_ident.t ->
  'a t -> not_found:(unit -> 'b) ->
  found:('a -> 'b) -> 'b

val add_js_module : ?id:Ident.t -> string  -> Ident.t 
(** add third party dependency *)

(* The other dependencies are captured by querying 
   either when [access] or when expansion, 
   however such dependency can be removed after inlining etc.

   When we register such compile time dependency we classified 
   it as 
   Visit (ml), Builtin(built in js), External()

   For external, we never remove, we only consider 
   remove dependency for Runtime and Visit, so 
   when compile OCaml to Javascript, we only need 
   pay attention to for those modules are actually used or not
*)

val reset : unit -> unit 

val is_pure : Lam_module_ident.t -> bool

val get_package_path_from_cmj : 
  Lam_module_ident.system -> Lam_module_ident.t -> 
  Js_config.info_query


(* The second argument is mostly from [runtime] modules 
    will change the input [hard_dependencies]
*)
val get_requried_modules : 
  Env.t ->
  Lam_module_ident.t list ->
  Lam_module_ident.t Hash_set.hashset -> 
  Lam_module_ident.t list

end = struct
#1 "lam_compile_env.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








module E = Js_exp_make  
module S = Js_stmt_make

type module_id = Lam_module_ident.t

type ml_module_info = { 
  signatures : Types.signature ;
  cmj_table : Js_cmj_format.t
}

type env_value = 
  | Visit of ml_module_info
  | Runtime  of bool * Js_cmj_format.t
  (** A built in module probably from our runtime primitives, 
      so it does not have any [signature]
  *)
  | External  
  (** Also a js file, but this belong to third party 
  *)

type module_info = {
  signature :  Types.signature ;
  pure : bool 
}

type primitive_description =  Primitive.description

type key = 
  Ident.t * Env.t  * bool (** we need register which global variable is an dependency *)


type ident_info = {
  id : Ident.t;
  name : string;
  signatures : Types.signature;
  arity : Lam.function_arities; 
  closed_lambda : Lam.t option 
}

(*
   refer: [Env.find_pers_struct]
   [ find_in_path_uncap !load_path (name ^ ".cmi")]
*)



let cached_tbl : (module_id , env_value) Hashtbl.t = Hashtbl.create 31

(* For each compilation we need reset to make it re-entrant *)
let reset () = 
  Hashtbl.clear cached_tbl 

(* FIXME: JS external instead *)
let add_js_module ?id module_name = 
  let id = 
    match id with
    | None -> Ext_ident.create_js_module module_name 
    | Some id -> id in
  Hashtbl.replace cached_tbl (Lam_module_ident.of_external id module_name) External;
  id  



let add_cached_tbl = Hashtbl.add cached_tbl

let find_and_add_if_not_exist (id, pos) env ~not_found ~found =
  let oid  = Lam_module_ident.of_ml id in
  begin match Hashtbl.find cached_tbl oid with 
    | exception Not_found -> 
      let cmj_table = Config_util.find_cmj (id.name ^ Js_config.cmj_ext) in
      begin match
          Type_util.find_serializable_signatures_by_path
            ( id) env with 
      | None -> not_found id 
      | Some signature -> 
        add_cached_tbl oid (Visit {signatures = signature; 
                                   cmj_table ;  } ) ;
        let name =  (Type_util.get_name signature pos ) in
        let arity, closed_lambda =        
          begin match String_map.find name cmj_table.values with
            | exception Not_found -> NA, None ;
            | {arity; closed_lambda} -> arity, closed_lambda 
          end in
        found {id; 
               name ;
               signatures = signature ;
               arity ;
               closed_lambda = 
                 if Js_config.get_cross_module_inline () then
                   closed_lambda
                 else None
              }
      end
    | Visit { signatures = serializable_sigs ; cmj_table = { values ; _} }  -> 
      let name = (Type_util.get_name serializable_sigs pos ) in
      let arity , closed_lambda =  (
        match  String_map.find name values with
        | exception  Not_found -> (NA, None)
        | {arity; closed_lambda;_} -> 
          arity, closed_lambda 
      ) in
      found { id;
              name; 
              signatures = serializable_sigs;
              arity;
              closed_lambda = 
                if Js_config.get_cross_module_inline () then
                  closed_lambda
                else None
              (* TODO shall we cache the arity ?*) 
            } 
    | Runtime _ -> assert false
    | External  -> assert false
  end


(* TODO: it does not make sense to cache
   [Runtime] 
   and [externals]*)
type _ t = 
  | No_env :  Js_cmj_format.t t 
  | Has_env : Env.t  -> module_info t 


let query_and_add_if_not_exist (type u)
    (oid : Lam_module_ident.t) 
    (env : u t) ~not_found ~found:(found : u -> _) =
  match Hashtbl.find cached_tbl oid with 
  | exception Not_found -> 
    begin match oid.kind with
      | Runtime  -> 
        let cmj_table = 
          Config_util.find_cmj (Lam_module_ident.name oid ^ Js_config.cmj_ext) in           
        add_cached_tbl oid (Runtime (true,cmj_table)) ; 
        begin match env with 
        | Has_env _ -> 
          found {signature = []; pure = true}
        | No_env -> 
          found cmj_table
        end
      | Ml 
        -> 
        let cmj_table = 
          Config_util.find_cmj (Lam_module_ident.name oid ^ Js_config.cmj_ext) in           
        begin match env with 
          | Has_env env -> 
            begin match 
                Type_util.find_serializable_signatures_by_path ( oid.id) env with 
            | None -> not_found () (* actually when [not_found] in the call site, we throw... *)
            | Some signature -> 
              add_cached_tbl oid (Visit {signatures = signature; cmj_table }) ;
              found  { signature ; pure = cmj_table.effect = None} 
            end
          | No_env -> 
            found cmj_table
        end

      | External _  -> 
        add_cached_tbl oid External;
        (** This might be wrong, if we happen to expand  an js module
            we should assert false (but this in general should not happen)
        *)
        begin match env with 
        | Has_env _ 
          -> 
          found {signature = []; pure = false}
        | No_env -> 
          found (Js_cmj_format.no_pure_dummy)
        end

    end
  | Visit {signatures  ; cmj_table =  cmj_table; _} -> 
    begin match env with 
      | Has_env _ -> 
        found   { signature =  signatures  ; pure = (cmj_table.effect = None)} 
      | No_env  -> found cmj_table
    end

  | Runtime (pure, cmj_table) -> 
    begin match env with 
      | Has_env _ -> 
        found {signature = []  ; pure }
      | No_env -> 
        found cmj_table
    end
  | External -> 
    begin match env with 
    | Has_env _ -> 
      found {signature = []  ; pure  = false}
    | No_env -> found Js_cmj_format.no_pure_dummy
    end

(* Conservative interface *)
let is_pure id  = 
  query_and_add_if_not_exist id No_env
    ~not_found:(fun _ -> false) 
    ~found:(fun x -> x.effect = None)


    

let get_package_path_from_cmj module_system ( id : Lam_module_ident.t) = 
  query_and_add_if_not_exist id No_env
    ~not_found:(fun _ -> `NotFound) 
    ~found:(fun x -> Js_config.query_package_infos x.npm_package_path module_system)


(* TODO: [env] is not hard dependency *)

let get_requried_modules env (extras : module_id list ) (hard_dependencies 
  : _ Hash_set.hashset) : module_id list =  

  let mem (x : Lam_module_ident.t) = 
    not (is_pure x ) || Hash_set.mem hard_dependencies  x 
  in
  Hashtbl.iter (fun (id : module_id)  _  ->
      if mem id 
      then Hash_set.add hard_dependencies id) cached_tbl ;
  List.iter (fun id -> 
      if mem id 
      then Hash_set.add hard_dependencies id
    ) extras;
  Hash_set.elements hard_dependencies

end
module Js_program_loader : sig 
#1 "js_program_loader.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** A module to create the whole JS program IR with [requires] and [exports] *)

(* TODO: 
   1. support es6 modle
   2. make sure exported have its origin name, 
      this makes it easier to read code 
 *)

val make_program : 
    string -> 
    Ident.t list -> J.block -> J.program

val decorate_deps : 
  J.required_modules ->
  string option ->
  J.program -> J.deps_program

val string_of_module_id :
  output_prefix:string ->
  Lam_module_ident.system -> Lam_module_ident.t -> string

end = struct
#1 "js_program_loader.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








module E = Js_exp_make
module S = Js_stmt_make



(** Design guides:
    1. We don't want to force user to have 
       [-bs-package-name] and [-bs-package-output] set

       [bsc.exe -c hello.ml] should just work 
       by producing a [hello.js] file in the same directory

    Some designs due to legacy reasons that we don't have all runtime
    written in OCaml, so it might only have js files (no cmjs) for Runtime kind
    {[
      begin match Config_util.find file with   
        (* maybe from third party library*)
        (* Check: be consistent when generating js files
           A.ml -> a.js
           a.ml -> a.js
           check generated [js] file if it's capital or not
           Actually, we can not tell its original name just from [id], 
           so we just always general litte_case.js
        *)
        | file ->
          rebase (`File file)
        (* for some primitive files, no cmj support *)
        | exception Not_found ->
          Ext_pervasives.failwithf ~loc:__LOC__ 
            "@[%s not found in search path - while compiling %s @] "
            file !Location.input_name 
      end

    ]}

*)

let (//) = Filename.concat 

let string_of_module_id ~output_prefix
    (module_system : Lam_module_ident.system)
    (x : Lam_module_ident.t) : string =

    let result = 
      match x.kind  with 
      | Runtime  
      | Ml  -> 
        let id = x.id in
        let file = Printf.sprintf "%s.js" id.name in
        let modulename = String.uncapitalize id.name in
        let current_unit_dir =
          `Dir (Js_config.get_output_dir module_system output_prefix) in
        let rebase dep =
          Ext_filename.node_relative_path  current_unit_dir dep 
        in 
        let dependency_pkg_info = 
          Lam_compile_env.get_package_path_from_cmj module_system x 
        in
        let current_pkg_info = 
          Js_config.get_current_package_name_and_path module_system  
        in
        begin match module_system,  dependency_pkg_info, current_pkg_info with
          | _, `NotFound , _ -> 
            Ext_pervasives.failwithf ~loc:__LOC__ 
              " @[%s not found in search path - while compiling %s @] "
              file !Location.input_name 
          | `Goog , `Found (package_name, x), _  -> 
            package_name  ^ "." ^  String.uncapitalize id.name
          | `Goog, (`Empty | `Package_script _), _ 
            -> 
            Ext_pervasives.failwithf ~loc:__LOC__ 
              " @[%s was not compiled with goog support  in search path - while compiling %s @] "
              file !Location.input_name 
          | (`AmdJS | `NodeJS),
            ( `Empty | `Package_script _) ,
            `Found _  -> 
            Ext_pervasives.failwithf ~loc:__LOC__
              "@[dependency %s was compiled in script mode - while compiling %s in package mode @]"
              file !Location.input_name
          | _ , _, `NotFound -> assert false 
          | (`AmdJS | `NodeJS), 
            `Found(package_name, x),
            `Found(current_package, path) -> 
            if  current_package = package_name then 
              rebase (`File (
                  Lazy.force Ext_filename.package_dir // x // modulename)) 
            else 
              package_name // x // modulename
          | (`AmdJS | `NodeJS), `Found(package_name, x), 
            `Package_script(current_package)
            ->    
            if current_package = package_name then 
              rebase (`File (
                  Lazy.force Ext_filename.package_dir // x // modulename)) 
            else 
              package_name // x // modulename
          | (`AmdJS | `NodeJS), `Found(package_name, x), `Empty 
            ->    package_name // x // modulename
          |  (`AmdJS | `NodeJS), 
             (`Empty | `Package_script _) , 
             (`Empty  | `Package_script _)
            -> 
            begin match Config_util.find file with 
              | file -> 
                rebase (`File file) 
              | exception Not_found -> 
                Ext_pervasives.failwithf ~loc:__LOC__ 
                  "@[%s was not found  in search path - while compiling %s @] "
                  file !Location.input_name 
            end
        end
      | External name -> name in 
    if Js_config.is_windows then Ext_filename.replace_backward_slash result 
    else result 



(* support es6 modules instead
   TODO: enrich ast to support import export 
   http://www.ecma-international.org/ecma-262/6.0/#sec-imports
   For every module, we need [Ident.t] for accessing and [filename] for import, 
   they are not necessarily the same.

   Es6 modules is not the same with commonjs, we use commonjs currently
   (play better with node)

   FIXME: the module order matters?
*)

let make_program name  export_idents block : J.program = 

  {
    name;

    exports = export_idents ; 
    export_set = Ident_set.of_list export_idents;
    block = block;

  }
let decorate_deps modules side_effect program : J.deps_program = 

  { program ; modules ; side_effect }


end
module Js_dump : sig 
#1 "js_dump.mli"
(* BuckleScript compiler
 * Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * http://www.ocsigen.org/js_of_ocaml/
 * Copyright (C) 2010 Jrme Vouillon
 * Laboratoire PPS - CNRS Universit Paris Diderot
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, with linking exception;
 * either version 2.1 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 *)
(* Authors: Jrme Vouillon, Hongbo Zhang  *)



(** Print JS IR to vanilla Javascript code *)



val pp_deps_program :
  output_prefix:string ->
  Lam_module_ident.system -> J.deps_program -> Ext_pp.t -> unit

val dump_deps_program :
  output_prefix:string ->
  Lam_module_ident.system  -> J.deps_program -> out_channel -> unit

(** 2 functions Only used for debugging *)
val string_of_block : J.block -> string

val dump_program : J.program -> out_channel -> unit

val string_of_expression : J.expression -> string

end = struct
#1 "js_dump.ml"
(* BuckleScript compiler
 * Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * http://www.ocsigen.org/js_of_ocaml/
 * Copyright (C) 2010 Jrme Vouillon
 * Laboratoire PPS - CNRS Universit Paris Diderot
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, with linking exception;
 * either version 2.1 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 *)
(* Authors: Jrme Vouillon, Hongbo Zhang  *)



(*
  http://stackoverflow.com/questions/2846283/what-are-the-rules-for-javascripts-automatic-semicolon-insertion-asi
  ASI catch up
  {[
  a=b
  ++c
  ---
  a=b ++c
  ====================
  a ++
  ---
  a 
  ++
  ====================
  a --
  ---
  a 
  --
  ====================
  (continue/break/return/throw) a
  ---
  (continue/break/return/throw)
  a
  ====================
  ]}

*)

(* module P = Ext_format *)
module P = Ext_pp
module E = Js_exp_make 
module S = Js_stmt_make 

module L = struct
  let function_ = "function"
  let var = "var" (* should be able to switch to [let] easily*)
  let return = "return"
  let eq = "="
  let require = "require"
  let goog_require = "goog.require" 
  let goog_module = "goog.module"
  let lparen = "("
  let rparen = ")"
  let exports = "exports"
  let dot = "."
  let comma = ","
  let colon = ":"
  let throw = "throw"
  let default = "default"
  let length = "length"
  let char_code_at = "charCodeAt"
  let new_ = "new"
  let array = "Array"
  let question = "?"      
  let plusplus = "++"
  let minusminus = "--"
  let semi = ";"
  let else_ = "else"
  let if_ = "if"
  let this = "this"
  let while_ = "while"
  let empty_block = "empty_block"
  let start_block = "start_block"
  let end_block = "end_block"
  let json = "JSON"
  let stringify = "stringify"
  let console = "console"
  let define = "define"
  let break = "break"
  let continue = "continue"
  let switch = "switch"
  let strict_directive = "'use strict';"
  let true_ = "true"
  let false_ = "false"
  let app = Literals.app (* curry arbitrary args *)
  let app_array = Literals.app_array
  let debugger = "debugger"
  let tag = "tag"
  let bind = "bind"
  let math = "Math"
  let apply = "apply"
  let null = "null"
  let string_cap = "String"
  let fromCharcode = "fromCharCode"
  let eq = "="
  let le = "<="
  let ge = ">="
  let plus_plus = "++" (* FIXME: use (i = i + 1 | 0) instead *)
  let minus_minus = "--"
  let caml_block = "Block"
  let caml_block_create = "__"
end
let return_indent = (String.length L.return / Ext_pp.indent_length) 

let throw_indent = (String.length L.throw / Ext_pp.indent_length) 


let semi f = P.string f L.semi

let op_prec, op_str  =
  Js_op_util.(op_prec, op_str)

let best_string_quote s =
  let simple = ref 0 in
  let double = ref 0 in
  for i = 0 to String.length s - 1 do
    match s.[i] with
    | '\'' -> incr simple
    | '"' -> incr double
    | _ -> ()
  done;
  if !simple < !double
  then '\''
  else '"'


(**
   same as {!Js_dump.ident} except it generates a string instead of doing the printing
*)
let str_of_ident (cxt : Ext_pp_scope.t) (id : Ident.t)   =
  if Ext_ident.is_js id then (* reserved by compiler *)
     ( id.name , cxt) 
  else 
    (* For fast/debug mode, we can generate the name as 
       [Printf.sprintf "%s$%d" name id.stamp] which is 
       not relevant to the context       
    *)    
    let name = Ext_ident.convert true id.name in
    let i,new_cxt = Ext_pp_scope.add_ident  id cxt in
    (* Attention: 
       $$Array.length, due to the fact that global module is 
       always printed in the begining(via imports), so you get a gurantee, 
       (global modules will not be printed as [List$1]) 

       However, this means we loose the ability of dynamic loading, is it a big 
       deal? we can fix this by a scanning first, since we already know which 
       modules are global

       check [test/test_global_print.ml] for regression

    *)
    (if i == 0 then 
       name 
     else
       Printf.sprintf"%s$%d" name i), new_cxt 


let ident (cxt : Ext_pp_scope.t) f (id : Ident.t) : Ext_pp_scope.t  =
  let str, cxt = str_of_ident cxt id in
  P.string f str; 
  cxt   

(** Avoid to allocate single char string too many times*)
let array_str1 =
  Array.init 256 (fun i -> String.make 1 (Char.chr i)) 

(** For conveting 
 
*)
let array_conv =
  [|"0"; "1"; "2"; "3"; "4"; "5"; "6"; "7"; "8"; "9"; "a"; "b"; "c"; "d";
    "e"; "f"|]



(* https://mathiasbynens.be/notes/javascript-escapes *)
let pp_string f ?(quote='"') ?(utf=false) s =
  let pp_raw_string f ?(utf=false) s = 
    let l = String.length s in
    for i = 0 to l - 1 do
      let c = String.unsafe_get s i in
      match c with
      | '\b' -> P.string f "\\b"
      | '\012' -> P.string f "\\f"
      | '\n' -> P.string f "\\n"
      | '\r' -> P.string f "\\r"
      | '\t' -> P.string f "\\t"
      (* This escape sequence is not supported by IE < 9
               | '\011' -> "\\v"
         IE < 9 treats '\v' as 'v' instead of a vertical tab ('\x0B'). 
         If cross-browser compatibility is a concern, use \x0B instead of \v.

         Another thing to note is that the \v and \0 escapes are not allowed in JSON strings.
      *)
      | '\000' when i = l - 1 || (let next = String.unsafe_get s (i + 1) in (next < '0' || next > '9'))
        -> P.string f "\\0"

      | '\\' when not utf -> P.string f "\\\\"


      | '\000' .. '\031'  | '\127'->
        let c = Char.code c in
        P.string f "\\x";
        P.string f (Array.unsafe_get array_conv (c lsr 4));
        P.string f (Array.unsafe_get array_conv (c land 0xf))
      | '\128' .. '\255' when not utf ->
        let c = Char.code c in
        P.string f "\\x";
        P.string f (Array.unsafe_get array_conv (c lsr 4));
        P.string f (Array.unsafe_get array_conv (c land 0xf))
      (* | '\'' -> P.string f "\\'" *)
      (* | '\"' -> P.string f "\\\"" *)
      | _ ->
        begin 
          (if c = quote  then
             P.string f "\\");           
          P.string f (Array.unsafe_get array_str1 (Char.code c))
        end
    done
  in
  let quote_s = String.make 1 quote in
  P.string f quote_s;
  pp_raw_string f ~utf s ;
  P.string f quote_s
;;

let property_string f s = 
  if Ext_ident.property_no_need_convert s  then 
    P.string f s
  else 
    pp_string f ~utf:true ~quote:(best_string_quote s) s

(* TODO: check utf's correct semantics *)
let pp_quote_string f s = 
  pp_string f ~utf:false ~quote:(best_string_quote s ) s 

let rec comma_idents  cxt f (ls : Ident.t list)  =
  match ls with
  | [] -> cxt
  | [x] -> ident cxt f x
  | y :: ys ->
    let cxt = ident cxt f y in
    P.string f L.comma;
    comma_idents cxt f ys  
let ipp_ident cxt f id un_used = 
  if un_used then 
    ident cxt f (Ext_ident.make_unused ())
  else 
    ident cxt f id  
let rec formal_parameter_list cxt (f : P.t) method_ l env =
  let offset = if method_ then 1 else 0 in   
  let rec aux i cxt l = 
    match l with
    | []     -> cxt
    | [id]    -> ipp_ident cxt f id (Js_fun_env.get_unused env i)
    | id :: r -> 
      let cxt = ipp_ident cxt f id (Js_fun_env.get_unused env i) in
      P.string f L.comma; P.space f;
      aux (i + 1) cxt  r
  in
  match l with 
  | [] -> cxt 
  | [i] -> 
    (** necessary, since some js libraries like [mocha]...*)
    if Js_fun_env.get_unused env offset then cxt else ident cxt f i 
  | _ -> 
    aux offset cxt l  


(* IdentMap *)
(*
f/122 --> 
  f/122 is in the map 
  if in, use the old mapping
  else 
    check  f,
     if in last bumped id
     else 
        use "f", register it 

  check "f"       
         if not , use "f", register stamp -> 0 
         else 
           check stamp 
             if in  use it 
             else check last bumped id, increase it and register
*)

let rec pp_function method_
    cxt (f : P.t) ?name  return 
    (l : Ident.t list) (b : J.block) (env : Js_fun_env.t ) =  
  match b, (name,  return)  with 
  | [ {statement_desc =
         Return {return_value = 
                   {expression_desc = 
                      Call(({expression_desc = Var v ; _} as function_), 
                           ls , 
                           {arity = ( Full | NA as arity(* see #234*)); 
                            (* TODO: need a case to justify it*)
                            call_info = 
                              (Call_builtin_runtime | Call_ml )})}}}],
    ((_, false) | (None, true))  
    when
      not method_ && 
      Ext_list.for_all2_no_exn (fun a b -> 
          match b.J.expression_desc with 
          | Var (Id i) -> Ident.same a i 
          | _ -> false) l ls ->
    let optimize  len p cxt f v =
      if p then
        begin           
          P.string f Js_config.curry;
          P.string f L.dot;
          P.string f "__";
          P.string f (Printf.sprintf "%d" len);
          P.paren_group f 1 (fun _ -> arguments cxt f [function_])            
        end              
      else
        vident cxt f v
    in
    let len = List.length l in (* length *)           
    begin match name with 
      | Some i -> 
        P.string f L.var; 
        P.space f ; 
        let cxt = ident cxt f i in
        P.space f ;
        P.string f L.eq;
        P.space f ;

        optimize len (arity = NA && len <= 8) cxt f v 
      | None ->
        if return then 
          begin 
            P.string f L.return ;
            P.space f;
          end;
        optimize len (arity = NA && len <=8) cxt f v 
    end
  | _, _  -> 

    let set_env : Ident_set.t = (** identifiers will be printed following*)
      match name with 
      | None ->
        Js_fun_env.get_unbounded env 
      | Some id -> Ident_set.add id (Js_fun_env.get_unbounded env )
    in
    (* the context will be continued after this function *)
    let outer_cxt = Ext_pp_scope.merge set_env cxt in  

    (* the context used to be printed inside this function

       when printing a function, 
       only the enclosed variables and function name matters, 
       if the function does not capture any variable, then the context is empty     
    *)
    let inner_cxt = Ext_pp_scope.sub_scope outer_cxt set_env in


    (* (if not @@ Js_fun_env.is_empty env then *)
    (* pp_comment  f (Some (Js_fun_env.to_string env))) ; *)
    let action return = 
      if return then 
        begin 
          P.string f L.return ;
          P.space f
        end ;
      P.string f L.function_;
      P.space f ;
      (match name with 
      | None  -> () 
      | Some x -> ignore (ident inner_cxt f x));
      if method_ then begin
        let cxt = P.paren_group f 1 (fun _ -> 
            formal_parameter_list inner_cxt  f method_ (List.tl l) env )
        in
        P.space f ;
        ignore @@ P.brace_vgroup f 1 (fun _ ->
            let cxt =
              if not (Js_fun_env.get_unused env 0) then
                begin               
                  P.string f L.var ; 
                  P.space f; 
                  let cxt = ident cxt f (List.hd l) in 
                  P.space f ; 
                  P.string f L.eq ; 
                  P.space f ;
                  P.string f L.this;
                  P.space f ; 
                  semi f ;
                  P.newline f ;
                  cxt ;                
                end
              else
                cxt
            in
            statement_list false cxt f b 
          );

      end
      else begin  
        let cxt = P.paren_group f 1 (fun _ -> 
            formal_parameter_list inner_cxt  f method_ l env )
        in
        P.space f ;
        ignore @@ P.brace_vgroup f 1 (fun _ -> statement_list false cxt f b );
      end
    in
    let lexical = Js_fun_env.get_lexical_scope env in

    let enclose action lexical  return = 
      if  Ident_set.is_empty lexical  
      then 
        action return 
      else
        (* print as 
           {[(function(x,y){...} (x,y))]}           
        *)
        let lexical = Ident_set.elements lexical in
        if return then
          begin 
            P.string f L.return ; 
            P.space f
          end ;
        P.string f L.lparen;
        P.string f L.function_; 
        P.string f L.lparen;
        ignore @@ comma_idents inner_cxt f lexical;
        P.string f L.rparen;
        P.brace_vgroup f 0  (fun _ -> action true);
        P.string f L.lparen;
        ignore @@ comma_idents inner_cxt f lexical;
        P.string f L.rparen;
        P.string f L.rparen
    in
    enclose action lexical return 
    ;
    outer_cxt


(* Assume the cond would not change the context, 
    since it can be either [int] or [string]
 *)
and output_one : 'a . 
    _ -> P.t -> (P.t -> 'a -> unit) -> 'a J.case_clause -> _
    = fun cxt f  pp_cond
    ({case = e; body = (sl,break)} : _ J.case_clause) -> 
  let cxt = 
    P.group f 1 @@ fun _ -> 
      P.group f 1 @@ (fun _ -> 
        P.string f "case ";
        pp_cond  f e;
        P.space f ;
        P.string f L.colon  );
      
      P.space f;
      P.group f 1 @@ fun _ ->
        let cxt =
          match sl with 
          | [] -> cxt 
          | _ ->
              P.newline f ;
              statement_list false cxt  f sl
        in
        (if break then 
          begin
            P.newline f ;
            P.string f L.break;
            semi f;
          end) ;
        cxt
  in
  P.newline f;
  cxt 

and loop  :  'a . Ext_pp_scope.t ->
  P.t -> (P.t -> 'a -> unit) -> 'a J.case_clause list -> Ext_pp_scope.t
      = fun  cxt  f pp_cond cases ->
  match cases with 
  | [] -> cxt 
  | [x] -> output_one cxt f pp_cond x
  | x::xs ->
      let cxt = output_one cxt f pp_cond x 
      in loop  cxt f pp_cond  xs 

and vident cxt f  (v : J.vident) =
  begin match v with 
  | Id v | Qualified(v, _, None) ->  
      ident cxt f v
  | Qualified (id,_, Some name) ->
      let cxt = ident cxt f id in
      P.string f L.dot;
      P.string f (Ext_ident.convert true name);
      cxt
  end

and expression l cxt  f (exp : J.expression) : Ext_pp_scope.t = 
  pp_comment_option f exp.comment ;
  expression_desc cxt l f exp.expression_desc

and
  expression_desc cxt (l:int) f x : Ext_pp_scope.t  =
  match x with
  | Var v ->
    vident cxt f v 
  | Bool b -> 
    (if  b then P.string f L.true_ else P.string f L.false_ ) ; cxt 
  | Seq (e1, e2) ->
    let action () = 
      let cxt = expression 0 cxt f e1 in
      P.string f L.comma ;
      P.space f ;
      expression 0 cxt f e2  in
    if l > 0 then 
      P.paren_group f 1 action
    else action ()

  | Fun (method_, l, b, env) ->  (* TODO: dump for comments *)
      pp_function method_ cxt f false  l b env
  (* TODO: 
     when [e] is [Js_raw_code] with arity
     print it in a more precise way
     It seems the optimizer already did work to make sure
     {[
       Call (Raw_js_code (s, Exp i), el, {Full})
         when List.length el = i
     ]}
  *)

  | Call (e, el, info) ->
    let action () = 
      P.group f 1 (fun _ -> 
          match info, el  with
          | {arity  = Full }, _ 
          | _, [] -> 
            let cxt = expression 15 cxt f e in 
            P.paren_group f 1 (fun _ -> arguments cxt  f el )  

          | _ , _ -> 
            (* ipp_comment f (Some "!") *)
            P.string f  Js_config.curry; 
            P.string f L.dot;
            let len = List.length el in
            if 1 <= len && len <= 8 then  
              begin
                P.string f L.app;
                P.string f (Printf.sprintf "%d" len);
                P.paren_group f 1 (fun _ -> arguments cxt f (e::el))
              end
            else 
              begin 
                P.string f  L.app_array;                
                P.paren_group f 1 (fun _ -> arguments cxt f [ e ; E.arr Mutable el])
              end)
    in
    if l > 15 then P.paren_group f 1 action   
    else action ()
  | Bind (a,b) -> 
    (* a.bind(b)
       {[ fun b -> a.bind(b) ==? a.bind ]}
    *)
    begin
      expression_desc cxt l f  
        (Call ({expression_desc = Dot(a,L.bind, true); comment = None }, [b], 
               {arity = Full; call_info = Call_na}))
    end    

  | FlatCall(e,el) -> 
    P.group f 1 (fun _ -> 
        let cxt = expression 15 cxt f e in
        P.string f L.dot; 
        P.string f L.apply;
        P.paren_group f 1 (fun _ ->
            P.string f L.null;
            P.string f L.comma;
            P.space f ; 
            expression 1 cxt f el
          )
      )
  | String_of_small_int_array ({expression_desc = desc } as e) -> 
    let action () = 
      P.group f 1 (fun _ -> 
          P.string f L.string_cap; 
          P.string f L.dot ;
          P.string f L.fromCharcode;
          begin match desc with 
            | Array (el, _mutable)
              ->
              P.paren_group f 1 (fun _ -> arguments cxt f el)
            | _ -> 
              P.string f L.dot ;
              P.string f L.apply; 
              P.paren_group f 1 (fun _ -> 
                  P.string f L.null;
                  P.string f L.comma;
                  expression 1 cxt  f e  )
          end ) 
    in
      if l > 15 then P.paren_group f 1 action   
      else action ()


  | Array_append (e, el) -> 
    P.group f 1 (fun _ -> 
        let cxt = expression 15 cxt f e in
        P.string f ".concat";
        P.paren_group f 1 (fun _ -> arguments cxt f [el]))

  | Array_copy e -> 
    P.group f 1 (fun _ -> 
        let cxt = expression 15 cxt f e in
        P.string f ".slice";
        P.string f "()" ;
        cxt 
      )

  | Dump (level, el) -> 
    let obj = 
      match level with 
      | Log -> "log"
      | Info -> "info"
      | Warn -> "warn"
      | Error -> "error" in
    P.group f 1 (fun _ -> 
        P.string f L.console;
        P.string f L.dot;
        P.string f obj ;
        P.paren_group f 1 (fun _ -> arguments cxt f el))
  | Json_stringify e 
    -> 
    P.group f 1 (fun _ -> 
        P.string f L.json ;
        P.string f L.dot;
        P.string f L.stringify; 
        P.paren_group f 1 (fun _ -> expression 0 cxt f e )        
      )    
  | Char_to_int e -> 
    begin match e.expression_desc with 
      | String_access (a,b) -> 
        P.group f 1 (fun _ -> 
            let cxt = expression 15 cxt f a in
            P.string f L.dot;
            P.string f L.char_code_at;
            P.paren_group f 1 (fun _ -> expression 0 cxt f b);
          )
      | _ -> 
        P.group f 1 (fun _ -> 
            let cxt = expression 15 cxt f e in
            P.string f L.dot;
            P.string f L.char_code_at;
            P.string f "(0)";
            cxt)
    end

  | Char_of_int e -> 
    P.group f 1 (fun _ -> 
        P.string f L.string_cap;
        P.string f L.dot;
        P.string f L.fromCharcode;
        P.paren_group f 1 (fun _ -> arguments cxt f [e])
      )


  | Math (name, el) -> 
    P.group f 1 (fun _ ->
        P.string f L.math;
        P.string f L.dot;
        P.string f name;
        P.paren_group f 1 (fun _ -> arguments cxt f el)
      )

  | Str (_, s) ->
    (*TODO --
       when utf8-> it will not escape '\\' which is definitely not we want
     *)
    let quote = best_string_quote s in 
    pp_string f (* ~utf:(kind = `Utf8) *) ~quote s; cxt 
  | Raw_js_code (s,info) -> 
    begin match info with 
    | Exp -> 
      P.string f "("; 
      P.string f s ; 
      P.string f ")";
      cxt 
    | Stmt -> 
      P.newline f  ;
      P.string f s ;
      P.newline f ;
      cxt 
    end
  | Number v ->
    let s = 
      match v with 
      | Float {f = v} -> 
        Js_number.caml_float_literal_to_js_string v 
       (* attach string here for float constant folding?*)
      | Int { i = v; _} 
        -> Int32.to_string v (* check , js convention with ocaml lexical convention *)
      | Uint i
        -> Format.asprintf "%lu" i              
      | Nint i -> Nativeint.to_string i 
    in
    let need_paren =
      if s.[0] = '-'
      then l > 13  (* Negative numbers may need to be parenthesized. *)
      else l = 15  (* Parenthesize as well when followed by a dot. *)
           && s.[0] <> 'I' (* Infinity *)
           && s.[0] <> 'N' (* NaN *)
    in
    let action = fun _ -> P.string f s  in
    (
      if need_paren 
      then P.paren f  action
      else action ()
    ); 
    cxt 
  | J.Anything_to_number e 
  | Int_of_boolean e -> 
    let action () = 
      P.group f 0 @@ fun _ -> 
        P.string f "+" ;
        expression 13 cxt f e 
    in
    (* need to tweak precedence carefully 
       here [++x --> +(+x)]
    *)
    if l > 12 
    then P.paren_group f 1 action 
    else action ()

  | Not e ->
    let action () = 
      P.string f "!" ;
      expression 13 cxt f e 
    in
    if l > 13 
    then P.paren_group f 1 action 
    else action ()
  | Typeof e 
    -> 
    P.string f "typeof"; 
    P.space f;
    expression 13 cxt f e     
  | Caml_block_set_tag(a,b) -> 
    expression_desc cxt l f 
      (Bin(Eq, 
           {expression_desc = Caml_block_tag a; comment = None},
           b
          ))
  | Caml_block_set_length(a,b) -> 
    expression_desc cxt l f 
      (Bin(Eq, 
           {expression_desc = Length (a,Caml_block); comment = None},
           b
          ))
  | Bin (Eq, {expression_desc = Var i },
         {expression_desc = 
            (
              Bin(
                (Plus as op), {expression_desc = Var j}, delta)
            | Bin(
                (Plus as op), delta, {expression_desc = Var j})
            | Bin(
                (Minus as op), {expression_desc = Var j}, delta)
            )
         })
    when Js_op_util.same_vident i j -> 
    (* TODO: parenthesize when necessary *)
    begin match delta, op with 
      | {expression_desc = Number (Int { i =  1l; _})}, Plus
        (* TODO: float 1. instead, 
             since in JS, ++ is a float operation           
        *)        
      | {expression_desc = Number (Int { i =  -1l; _})}, Minus
        ->
        P.string f L.plusplus;
        P.space f ; 
        vident cxt f i

      | {expression_desc = Number (Int { i =  -1l; _})}, Plus
      | {expression_desc = Number (Int { i =  1l; _})}, Minus
        -> 
        P.string f L.minusminus; 
        P.space f ; 
        vident cxt f i;
      | _, _ -> 
        let cxt = vident cxt f i in
        P.space f ;
        if op = Plus then P.string f "+=" 
        else P.string f "-=";
        P.space f ; 
        expression 13 cxt  f delta
    end
  | Bin (Eq, {expression_desc = Access({expression_desc = Var i; _},
                                       {expression_desc = Number (Int {i = k0 })}
                                      ) },
         {expression_desc = 
            (Bin((Plus as op), 
                 {expression_desc = Access(
                      {expression_desc = Var j; _},
                      {expression_desc = Number (Int {i = k1; })}
                    ); _}, delta)
            | Bin((Plus as op), delta,
                  {expression_desc = Access(
                       {expression_desc = Var j; _},
                       {expression_desc = Number (Int {i = k1; })}
                     ); _})
            | Bin((Minus as op), 
                  {expression_desc = Access(
                       {expression_desc = Var j; _},
                       {expression_desc = Number (Int {i = k1; })}
                     ); _}, delta)

            )})
    when  k0 = k1 && Js_op_util.same_vident i j 
    (* Note that 
       {[x = x + 1]}
       is exactly the same  (side effect, and return value)
       as {[ ++ x]}
       same to 
       {[ x = x + a]}
       {[ x += a ]}
       they both return the modified value too
    *)
    (* TODO:
       handle parens..
    *)
    ->
    let aux cxt f vid i = 
      let cxt = vident cxt f vid in
      P.string f "[";
      P.string f (Int32.to_string  i);
      P.string f"]"; 
      cxt in
    (** TODO: parenthesize when necessary *)

    begin match delta, op with 
      | {expression_desc = Number (Int { i =  1l; _})}, Plus
      | {expression_desc = Number (Int { i =  -1l; _})}, Minus
        ->
        P.string f L.plusplus;
        P.space f ; 
        aux cxt f i k0
      | {expression_desc = Number (Int { i =  -1l; _})}, Plus
      | {expression_desc = Number (Int { i =  1l; _})}, Minus
        -> 
        P.string f L.minusminus; 
        P.space f ; 
        aux cxt f  i k0
      | _, _ -> 
        let cxt = aux cxt f i k0 in
        P.space f ;
        if op = Plus then P.string f "+=" 
        else P.string f "-=";
        P.space f ; 
        expression 13 cxt  f delta
    end
  | Anything_to_string e -> 
    (* Note that we should not apply any smart construtor here, 
       it's purely  a convenice for pretty-printing
    *)    
    expression_desc cxt l f (Bin (Plus, {expression_desc = Str (true,""); comment = None}, e))    

  | Bin (Minus, {expression_desc = Number (Int {i=0l;_} | Float {f = "0."})}, e) 
      (* TODO:
         Handle multiple cases like
         {[ 0. - x ]}
         {[ 0.00 - x ]}
         {[ 0.000 - x ]}
       *)
    ->
    let action () = 
      P.string f "-" ;
      expression 13 cxt f e 
    in
    if l > 13 then P.paren_group f 1 action 
    else action ()

  | Bin (op, e1, e2) ->
    let (out, lft, rght) = op_prec op in
    let need_paren =
      l > out || (match op with Lsl | Lsr | Asr -> true | _ -> false) in

    let action () = 
      (* We are more conservative here, to make the generated code more readable
          to the user
       *)

      let cxt = expression lft cxt  f e1 in
      P.space f; 
      P.string f (op_str op);
      P.space f;
      expression rght cxt   f e2 
    in
    if need_paren 
    then P.paren_group f 1 action 
    else action ()

  | String_append (e1, e2) -> 
    let op : Js_op.binop = Plus in
    let (out, lft, rght) = op_prec op in
    let need_paren =
      l > out || (match op with Lsl | Lsr | Asr -> true | _ -> false) in

    let action () = 
      let cxt = expression  lft cxt f e1 in
      P.space f ;
      P.string f "+";
      P.space f;
      expression rght  cxt   f e2 
    in
    if need_paren then P.paren_group f 1 action else action ()

  | Array (el,_) ->
    (** TODO: simplify for singleton list *)
    begin match el with 
      | []| [ _ ] -> P.bracket_group f 1 @@ fun _ -> array_element_list  cxt f el 
      | _ -> P.bracket_vgroup f 1 @@ fun _ -> array_element_list  cxt f el 
    end
  | Caml_uninitialized_obj (tag, size) 
    ->  (* FIXME *)
    expression_desc cxt l f (Object [Length, size ; Tag, tag])    
  | Caml_block( el, mutable_flag, tag, tag_info) 
    -> 
    (* Note that, if we ignore more than tag [0] we loose some information 
       with regard tag  *)
    begin match tag.expression_desc, tag_info with 

    | Number (Int { i = 0l ; _})  , 
      (Blk_tuple | Blk_array | Blk_variant _ | Blk_record _ | Blk_na | Blk_module _
      |  Blk_constructor (_, 1) (* Sync up with {!Js_dump}*)
      ) 
      -> expression_desc cxt l f  (Array (el, mutable_flag))
    (* TODO: for numbers like 248, 255 we can reverse engineer to make it 
       [Obj.xx_flag], but we can not do this in runtime libraries
    *)

    | _, _
      -> 
      P.string f L.caml_block; 
      P.string f L.dot ;
      P.string f L.caml_block_create;
      P.paren_group f 1 (fun _ -> arguments cxt f [tag; E.arr mutable_flag el])
    end
  | Caml_block_tag e ->
    P.group f 1 (fun _ ->  
        let cxt = expression 15 cxt f  e in
        P.string f L.dot ;
        P.string f L.tag ;
        cxt)
  | Access (e, e') 

  | String_access (e,e')
    ->
    let action () = 
      P.group f 1 @@ fun _ -> 
        let cxt = expression 15 cxt f e in
        P.bracket_group f 1 @@ fun _ -> 
          expression 0 cxt f e' 
    in
    if l > 15 then P.paren_group f 1 action else action ()

  | Length (e, _) -> 
    let action () =  (** Todo: check parens *)
      let cxt = expression 15 cxt f e in
      P.string f L.dot;
      P.string f L.length;
      cxt  in
    if l > 15 then P.paren_group f 1 action else action ()

  | Dot (e, s,normal) ->
    let action () = 
      let cxt = expression 15 cxt f e in
      if Ext_ident.property_no_need_convert s  then
        begin 
          P.string f L.dot;
          P.string f s; 
        end
      else
        begin 
          P.bracket_group f 1 @@ fun _ ->
          pp_string f (* ~utf:(kind = `Utf8) *) ~quote:( best_string_quote s) s
        end;
      (* See [Js_program_loader.obj_of_exports] 
         maybe in the ast level we should have 
         refer and export
      *)
      cxt in
    if l > 15 then P.paren_group f 1 action else action ()

  | New (e,  el) ->
    let action () = 
      P.group f 1 @@ fun _ -> 
        P.string f L.new_;
        P.space f;
        let cxt = expression 16 cxt f e in
        P.paren_group f 1 @@ fun _ -> 
          match el with 
          | Some el  -> arguments cxt f el  
          | None -> cxt
    in
    if l > 15 then P.paren_group f 1 action else action ()

  | Array_of_size e ->
    let action () = 
      P.group f 1 @@ fun _ -> 
        P.string f L.new_;
        P.space f;
        P.string f L.array;
        P.paren_group f 1 @@ fun _ -> expression 0 cxt f e
    in
    if l > 15 then P.paren_group f 1 action else action ()

  | Cond (e, e1, e2) ->
    let action () = 
      (* P.group f 1 @@ fun _ ->  *)
      let cxt =  expression 3 cxt f e in
      P.space f;
      P.string f L.question; 
      P.space f;
      (* 
            [level 1] is correct, however
            to make nice indentation , force nested conditional to be parenthesized
          *)
      let cxt = (P.group f 1 @@ fun _ -> expression 3 cxt f e1) in
      (* let cxt = (P.group f 1 @@ fun _ -> expression 1 cxt f e1) in *)
      P.space f;
      P.string f L.colon;
      P.space f ; 

      (* idem *)
      P.group f 1 @@ fun _ -> expression 3 cxt f e2
      (* P.group f 1 @@ fun _ -> expression 1 cxt f e2 *)
    in
    if l > 2 then P.paren_vgroup f 1 action else action ()

  | Object lst ->
    begin
      match lst with 
      | [] -> P.string f "{ }" ; cxt 
      | _ -> 
        P.brace_vgroup f 1 @@ fun _ -> 
        property_name_and_value_list cxt f lst
    end

and property_name cxt f (s : J.property_name) : unit =
  match s with
  | Tag -> P.string f L.tag
  | Length -> P.string f L.length
  | Key s -> 
    property_string  f s 
  | Int_key i -> P.string f (string_of_int i)

and property_name_and_value_list cxt f l : Ext_pp_scope.t =
  match l with
  | [] -> cxt
  | [(pn, e)] ->
    property_name cxt  f pn ;
    P.string f L.colon;
    P.space f;
    expression 1 cxt f e 
  | (pn, e) :: r ->
    property_name cxt f pn ; 
    P.string f L.colon;
    P.space f;
    let cxt = expression 1 cxt f e in
    P.string f L.comma;
    P.newline f;
    property_name_and_value_list cxt f r

and array_element_list cxt f el : Ext_pp_scope.t =
  match el with
  | []     -> cxt 
  | [e]    ->  expression 1 cxt f e
  | e :: r ->
    let cxt =  expression 1 cxt f e 
    in
    P.string f L.comma; P.newline f; array_element_list cxt f r

and arguments cxt f l : Ext_pp_scope.t =
  match l with
  | []     -> cxt 
  | [e]    ->   expression 1 cxt f e
  | e :: r -> 
    let cxt =   expression 1 cxt f e in
    P.string f L.comma; P.space f; arguments cxt f r

and variable_declaration top cxt f 
    (variable : J.variable_declaration) : Ext_pp_scope.t = 
  (* TODO: print [const/var] for different backends  *)
  match variable with
  | {ident = i; value =  None; ident_info ; _} -> 
    if ident_info.used_stats = Dead_pure 
    then cxt
    else 
      begin
        P.string f L.var;
        P.space f;
        let cxt = ident cxt  f i in
        semi f ; 
        cxt
      end 
  | { ident = name; value =  Some e; ident_info = {used_stats; _}} ->
    begin match used_stats with
      | Dead_pure -> 
        cxt 
      | Dead_non_pure -> 
        (* Make sure parens are added correctly *)
        statement_desc top cxt f (J.Exp e)
      | _ -> 
        begin match e, top  with 
          | {expression_desc = Fun (method_, params, b, env ); comment = _}, true -> 
            pp_function method_ cxt f ~name false params b env 
          | _, _ -> 
              P.string f L.var;
              P.space f;
              let cxt = ident cxt f name in
              P.space f ;
              P.string f L.eq;
              P.space f ;
              let cxt = expression 1 cxt f e in
              semi f;
              cxt 
        end
    end
and ipp_comment : 'a . P.t -> 'a  -> unit = fun   f comment -> 
  ()


(** don't print a new line -- ASI 
    FIXME: this still does not work in some cases...
    {[
    return /* ... */
    [... ]
    ]}
*)

and pp_comment f comment = 
  if String.length comment > 0 then 
    P.string f "/* "; P.string f comment ; P.string f " */" 

and pp_comment_option f comment  = 
    match comment with 
    | None -> ()
    | Some x -> pp_comment f x
and statement top cxt f 
    ({statement_desc = s;  comment ; _} : J.statement)  : Ext_pp_scope.t =

  pp_comment_option f comment ;
  statement_desc top cxt f s 

and statement_desc top cxt f (s : J.statement_desc) : Ext_pp_scope.t = 
  match s with
  | Block [] -> 
      ipp_comment f  L.empty_block; (* debugging*)
      cxt
  | Exp {expression_desc = Var _;}
    -> (* Does it make sense to optimize here? *)
      semi f; cxt 

  | Block b -> (* No braces needed here *)
      ipp_comment f L.start_block;
      let cxt = statement_list top cxt  f b in
      ipp_comment f  L.end_block;
      cxt
  | Variable l ->
      variable_declaration top cxt  f l
  | Exp e ->
    (* Parentheses are required when the expression
       starts syntactically with "{" or "function" 
       TODO:  be more conservative, since Google Closure will handle
       the precedence correctly, we also need people read the code..
       Here we force parens for some alien operators

       If we move assign into a statement, will be less?
       TODO: construct a test case that do need parenthesisze for expression
       IIE does not apply (will be inlined?)
    *)

    let rec need_paren  (e : J.expression) =
      match e.expression_desc with
      | Call ({expression_desc = Fun _; },_,_) -> true
      | Caml_uninitialized_obj _ 
      | Raw_js_code (_, Exp) 
      | Fun _ | Object _ -> true
      | Raw_js_code (_,Stmt)
      | Caml_block_set_tag _ 
      | Length _ 
      | Caml_block_set_length _ 
      | Anything_to_string _ 
      | String_of_small_int_array _
      | Call _ 
      | Array_append _ 
      | Array_copy _ 
      | Caml_block_tag _ 
      | Seq _
      | Dot _
      | Cond _
      | Bin _ 
      | String_access _ 
      | Access _
      | Array_of_size _ 
      | String_append _ 
      | Char_of_int _ 
      | Char_to_int _
      | Dump _
      | Json_stringify _ 
      | Math _
      | Var _ 
      | Str _ 
      | Array _ 
      | Caml_block  _ 
      | FlatCall _ 
      | Typeof _
      | Bind _ 
      | Number _
      | Not _ 
      | Bool _
      | New _ 
      | J.Anything_to_number _ 
      | Int_of_boolean _ -> false
      (* e = function(x){...}(x);  is good
       *)
    in
    let cxt = 
      (
        if need_paren  e 
        then (P.paren_group f 1)
        else (P.group f 0)
      ) (fun _ -> expression 0 cxt f e ) in
    semi f;
    cxt 

  | If (e, s1,  s2) -> (* TODO: always brace those statements *)
    P.string f L.if_;
    P.space f;
    let cxt = P.paren_group f 1 @@ fun _ -> expression 0 cxt f e in
    P.space f;
    let cxt =
      block cxt f s1
    in
    begin match s2 with 
     | None | (Some []) 
     | Some [{statement_desc = (Block [] | Exp {expression_desc = Var _;} ); }]
       -> P.newline f; cxt
     | Some [{statement_desc = If _} as nest]
     | Some [{statement_desc = Block [ {statement_desc = If _ ; _} as nest] ; _}]
       ->
       P.newline f;
       P.string f L.else_;
       P.space f;
       statement false cxt f nest 
     | Some s2 -> 
       P.newline f;
       P.string f L.else_;
       P.space f ;
       block  cxt f s2 
    end

  | While (label, e, s, _env) ->  (*  FIXME: print scope as well *)
      begin 
        (match label with 
        | Some i ->
            P.string f i ; 
            P.string f L.colon;
            P.newline f ;
        | None -> ());
        let cxt = 
          match e.expression_desc with
          | Number (Int {i = 1l}) ->
              P.string f L.while_;
              P.string f "(";
              P.string f L.true_;
              P.string f ")"; 
              P.space f ;
              cxt 
          | _ -> 
              P.string f L.while_;
              let cxt = P.paren_group f 1 @@ fun _ ->  expression 0 cxt f e in
              P.space f ; 
              cxt 
        in
        let cxt = block cxt f s in
        semi f;
        cxt
      end
  | ForRange (for_ident_expression, finish, id, direction, s, env) -> 
    let action cxt  = 
      P.vgroup f 0 @@ fun _ -> 
        let cxt = P.group f 0 @@ fun _ -> 
            (* The only place that [semi] may have semantics here *)
            P.string f "for";
            P.paren_group f 1 @@ fun _ -> 
              let cxt, new_id = 
                (match for_ident_expression, finish.expression_desc with 
                 | Some ident_expression , (Number _ | Var _ ) -> 
                   P.string f L.var;
                   P.space f;
                   let cxt  =  ident cxt f id in
                   P.space f; 
                   P.string f L.eq;
                   P.space f;
                   expression 0 cxt f ident_expression, None
                 | Some ident_expression, _ -> 
                   P.string f L.var;
                   P.space f;
                   let cxt  =  ident cxt f id in
                   P.space f;
                   P.string f L.eq;
                   P.space f; 
                   let cxt = expression 1 cxt f ident_expression in
                   P.space f ; 
                   P.string f L.comma;
                   let id = Ext_ident.create (Ident.name id ^ "_finish") in
                   let cxt = ident cxt f id in
                   P.space f ; 
                   P.string f L.eq;
                   P.space f;
                   expression 1 cxt f finish, Some id
                 | None, (Number _ | Var _) -> 
                   cxt, None 
                 | None , _ -> 
                   P.string f L.var;
                   P.space f ;
                   let id = Ext_ident.create (Ident.name id ^ "_finish") in
                   let cxt = ident cxt f id in
                   P.space f ; 
                   P.string f L.eq ; 
                   P.space f ; 
                   expression 15 cxt f finish, Some id
                ) in

              semi f ; 
              P.space f;
              let cxt = ident cxt f id in
              P.space f;
              let right_prec  = 

                match direction with 
                | Upto -> 
                  let (_,_,right) = op_prec Le  in
                  P.string f L.le;
                  right
                | Downto -> 
                  let (_,_,right) = op_prec Ge in
                  P.string f L.ge ;
                  right
              in
              P.space f ; 
              let cxt  = 
                match new_id with 
                | Some i -> expression   right_prec cxt  f (E.var i)
                | None -> expression  right_prec cxt  f finish
              in
              semi f; 
              P.space f;
              let ()  = 
                match direction with 
                | Upto -> P.string f L.plus_plus
                | Downto -> P.string f L.minus_minus in
              ident cxt f id
        in
        block  cxt f s  in
    let lexical = Js_closure.get_lexical_scope env in
    if Ident_set.is_empty lexical 
    then action cxt
    else 
      (* unlike function, 
         [print for loop] has side effect, 
         we should take it out
      *)
      let inner_cxt = Ext_pp_scope.merge lexical cxt in
      let lexical = Ident_set.elements lexical in
      let _enclose action inner_cxt lexical   = 
        let rec aux  cxt f ls  =
          match ls with
          | [] -> cxt
          | [x] -> ident cxt f x
          | y :: ys ->
            let cxt = ident cxt f y in
            P.string f L.comma;
            aux cxt f ys  in
        P.vgroup f 0
          (fun _ ->
             (
               P.string f "(function(";
               ignore @@ aux inner_cxt f lexical;
               P.string f ")";
               let cxt = P.brace_vgroup f 0  (fun _ -> action inner_cxt) in
               P.string f "(";
               ignore @@ aux inner_cxt f lexical;
               P.string f ")";
               P.string f ")";
               semi f;
               cxt
             )) 
      in
      _enclose action inner_cxt lexical

  | Continue s ->
    P.string f L.continue;
    P.space f ;
    P.string f s;
    semi f;
    P.newline f;
    cxt
  | Debugger
    -> 
    P.newline f ;
    P.string f L.debugger;
    semi f ;
    P.newline f;
    cxt 
  | Break
    ->
    P.string f L.break;
    P.space f ;
    semi f;
    P.newline f; 
    cxt

  | Return {return_value = e} ->
    begin match e with
      | {expression_desc = Fun (method_,  l, b, env); _} ->
        let cxt =
          pp_function method_ cxt f true l b env in
        semi f ; cxt 
      | e ->
        P.string f L.return ;
        P.space f ;

        (* P.string f "return ";(\* ASI -- when there is a comment*\) *)
        P.group f return_indent @@ fun _ -> 
          let cxt =  expression 0 cxt f e in
          semi f;
          cxt 
          (* There MUST be a space between the return and its
             argument. A line return will not work *)
    end
  | Int_switch (e, cc, def) ->
    P.string f L.switch;  
    P.space f;
    let cxt = P.paren_group f 1 @@ fun _ ->  expression 0 cxt f e 
    in
    P.space f;
    P.brace_vgroup f 1 @@ fun _ -> 
      let cxt = loop cxt f (fun f i -> P.string f (string_of_int i) ) cc in
      (match def with
       | None -> cxt
       | Some def ->
         P.group f 1 @@ fun _ -> 
           P.string f L.default;
           P.string f L.colon;
           P.newline f;
           statement_list  false cxt  f def 
      )

  | String_switch (e, cc, def) ->
    P.string f L.switch;
    P.space f;
    let cxt = P.paren_group f 1 @@ fun _ ->  expression 0 cxt f e 
    in
    P.space f;
    P.brace_vgroup f 1 @@ fun _ -> 
      let cxt = loop cxt f (fun f i -> pp_quote_string f i ) cc in
      (match def with
       | None -> cxt
       | Some def ->
         P.group f 1 @@ fun _ -> 
           P.string f L.default;
           P.string f L.colon;
           P.newline f;
           statement_list  false cxt  f def )

  | Throw e ->
    P.string f L.throw;
    P.space f ;
    P.group f throw_indent @@ fun _ -> 

      let cxt = expression 0 cxt f e in
      semi f ; cxt 

  (* There must be a space between the return and its
     argument. A line return would not work *)
  | Try (b, ctch, fin) ->
    P.vgroup f 0 @@ fun _-> 
      P.string f "try";
      P.space f ; 
      let cxt = block cxt f b in
      let cxt = 
        match ctch with
        | None ->
          cxt
        | Some (i, b) ->
          P.newline f;
          P.string f "catch (";
          let cxt = ident cxt f i in
          P.string f ")";
          block cxt f b
      in 
      begin match fin with
        | None -> cxt
        | Some b ->
          P.group f 1 @@ fun _ -> 
            P.string f "finally";
            P.space f;
            block cxt f b 
      end
(* similar to [block] but no braces *)
and statement_list top cxt f  b =
  match b with
  | []     -> cxt
  | [s]    -> statement top  cxt f  s
  | s :: r -> 
    let cxt = statement top cxt f s in
    P.newline f;
    (if top then P.force_newline f);
    statement_list top cxt f  r

and block cxt f b =
  (* This one is for '{' *)
  P.brace_vgroup f 1 (fun _ -> statement_list false cxt   f b )


let exports cxt f (idents : Ident.t list) = 
  let outer_cxt, reversed_list, margin = 
    List.fold_left (fun (cxt, acc, len ) (id : Ident.t) -> 
        let s = Ext_ident.convert true id.name in        
        let str,cxt  = str_of_ident cxt id in         
        cxt, ( (s,str) :: acc ) , max len (String.length s)   )
      (cxt, [], 0)  idents in    
  P.newline f ;
  Ext_list.rev_iter (fun (s,export) -> 
      P.group f 0 @@ (fun _ ->  
          P.string f L.exports;
          P.string f L.dot;
          P.string f s; 
          P.nspace f (margin - String.length s +  1) ;
          P.string f L.eq;
          P.space f;
          P.string f export;          
          semi f;);
      P.newline f;
    ) reversed_list;
  outer_cxt  


(* Node style *)
let requires require_lit cxt f (modules : (Ident.t * string) list ) =
  P.newline f ; 
  (* the context used to print the following program *)  
  let outer_cxt, reversed_list, margin  =
    List.fold_left
      (fun (cxt, acc, len) (id,s) ->
         let str, cxt = str_of_ident cxt id  in
         cxt, ((str,s) :: acc), (max len (String.length str))
      )
      (cxt, [], 0)  modules in
  P.force_newline f ;    
  Ext_list.rev_iter (fun (s,file) ->
      P.string f L.var;
      P.space f ;
      P.string f s ;
      P.nspace f (margin - String.length s + 1) ;
      P.string f L.eq;
      P.space f;
      P.string f require_lit;
      P.paren_group f 0 @@ (fun _ ->
          pp_string f ~utf:true ~quote:(best_string_quote s) file  );
      semi f ;
      P.newline f ;
    ) reversed_list;
  outer_cxt

let program f cxt   ( x : J.program ) = 
  let () = P.force_newline f in
  let cxt =  statement_list true cxt f x.block  in
  let () = P.force_newline f in
  exports cxt f x.exports

let goog_program ~output_prefix f goog_package (x : J.deps_program)  = 
  P.newline f ;
  P.string f L.goog_module;
  P.string f "(";
  P.string f (Printf.sprintf "%S" goog_package);
  P.string f ")";
  semi f ;
  let cxt = 
    requires
      L.goog_require
      Ext_pp_scope.empty
      f 
      (List.map 
         (fun x -> 
            Lam_module_ident.id x,
            Js_program_loader.string_of_module_id
              ~output_prefix `Goog x)
         x.modules) 
  in
  program f cxt x.program  

let node_program ~output_prefix f ( x : J.deps_program) = 
  let cxt = 
    requires 
      L.require
      Ext_pp_scope.empty
      f
      (List.map 
         (fun x -> 
            Lam_module_ident.id x,
            Js_program_loader.string_of_module_id
              ~output_prefix
              `NodeJS x)
         x.modules)
  in
  program f cxt x.program  


let amd_program ~output_prefix f (  x : J.deps_program) = 
  P.newline f ; 
  let cxt = Ext_pp_scope.empty in
  P.vgroup f 1 @@ fun _ -> 
  P.string f L.define;
  P.string f "([";
  P.string f (Printf.sprintf "%S" L.exports);

  List.iter (fun x ->
      let s = Js_program_loader.string_of_module_id ~output_prefix `AmdJS x in
      P.string f L.comma ;
      P.space f; 
      pp_string f ~utf:true ~quote:(best_string_quote s) s;
    ) x.modules ;
  P.string f "]";
  P.string f L.comma;
  P.newline f;
  P.string f L.function_;
  P.string f "(";
  P.string f L.exports;

  let cxt = 
    List.fold_left (fun cxt x ->         
        let id = Lam_module_ident.id x in
        P.string f L.comma;
        P.space f ; 
        ident cxt f id
      ) cxt x.modules     
  in
  P.string f ")";
  let v = P.brace_vgroup f 1 @@ (fun _ -> 
      let () = P.string f L.strict_directive in 
      program f cxt x.program
    ) in
  P.string f ")";
  v

(** Make sure github linguist happy
    {[
      require('Linguist')
      Linguist::FileBlob.new('jscomp/test/test_u.js').generated?
    ]}
*)
let bs_header = 
  "// Generated by BUCKLESCRIPT VERSION " ^
  Js_config.version ^
  " , PLEASE EDIT WITH CARE"

let pp_deps_program
    ~output_prefix
    (kind : Lam_module_ident.system )
    (program  : J.deps_program) (f : Ext_pp.t) = 
  begin
    if not !Js_config.no_version_header then 
      begin 
        P.string f bs_header;
        P.newline f
      end ; 
    P.string f L.strict_directive; 
    P.newline f ;    
    ignore (match kind with 
     | `AmdJS -> 
       amd_program ~output_prefix f program
     | `NodeJS -> 
       node_program ~output_prefix f program
     | `Goog  -> 
       let goog_package = 
         let v = Js_config.get_module_name () in
         match Js_config.get_package_name () with 
         | None 
           -> v 
         | Some x -> x ^ "." ^ v 
       in 
       goog_program ~output_prefix f goog_package  program
      ) ;
    P.newline f ;
    P.string f (
      match program.side_effect with
      | None -> "/* No side effect */"
      | Some v -> Printf.sprintf "/* %s Not a pure module */" v );
    P.newline f;
    P.flush f ()
  end

let dump_program (x : J.program) oc = 
  ignore (program (P.from_channel oc)  Ext_pp_scope.empty  x )

let dump_deps_program
    ~output_prefix
    kind
    x 
    (oc : out_channel) = 
  pp_deps_program ~output_prefix  kind x (P.from_channel oc)

let string_of_block  block  
  = 
  let buffer  = Buffer.create 50 in
  begin
    let f = P.from_buffer buffer in
    let _scope =  statement_list true Ext_pp_scope.empty  f block in
    P.flush  f ();
    Buffer.contents buffer     
  end


let string_of_expression e =
  let buffer  = Buffer.create 50 in
  begin
    let f = P.from_buffer buffer in
    let _scope =  expression 0  Ext_pp_scope.empty  f e in
    P.flush  f ();
    Buffer.contents buffer     
  end

 

end
module Lam_compile_defs : sig 
#1 "lam_compile_defs.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Type defintion to keep track of compilation state 
  *)

(** Some types are defined in this module to help avoiding generating unnecessary symbols 
    (generating too many symbols will make the output code unreadable)
*)

type jbl_label = int 



type value = {
    exit_id : Ident.t ; 
    args : Ident.t list ;
    order_id : int
  }

type let_kind = Lambda.let_kind

type st = 
  | EffectCall
  | Declare of let_kind * J.ident (* bound value *)
  | NeedValue 
  | Assign of J.ident 
  (** when use [Assign], var is not needed, since it's already declared 
      make sure all [Assign] are declared first, otherwise you are creating global variables
   *)

type return_label = {
  id : Ident.t;
  label : J.label;
  params : Ident.t list;
  immutable_mask : bool array;
  mutable new_params : Ident.t Ident_map.t ;
  mutable triggered : bool
}

type return_type = 
  | False 
  | True of return_label option (* anonoymous function does not have identifier *)

(* delegate to the callee to generate expression 
      Invariant: [output] should return a trailing expression
  *)

module HandlerMap : Map.S with type key = jbl_label

type cxt = {
  st : st ;
  should_return : return_type;
  jmp_table : value  HandlerMap.t ;
  meta : Lam_stats.meta ;
}

val empty_handler_map : value HandlerMap.t 

val add_jmps :
    Ident.t * (HandlerMap.key * 'a * Ident.t list) list ->
    value HandlerMap.t -> value HandlerMap.t * (int * 'a) list


end = struct
#1 "lam_compile_defs.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








type jbl_label = int 

module HandlerMap = Map.Make(struct 
  type t = jbl_label
  let compare x y= compare (x:t) y 
end )

type value = {
    exit_id : Ident.t ;
    args : Ident.t list ;
    order_id : int
  }

(* delegate to the callee to generate expression 
      Invariant: [output] should return a trailing expression
 *)
type return_label = {
  id : Ident.t;
  label : J.label;
  params : Ident.t list;
  immutable_mask : bool array; 
  mutable new_params : Ident.t Ident_map.t;  
  mutable triggered : bool
}

type return_type = 
  | False 
  | True of return_label option 
   (* have a mutable field to notifiy it's actually triggered *)
   (* anonoymous function does not have identifier *)

type let_kind = Lambda.let_kind

type st = 
  | EffectCall
  | Declare of let_kind * J.ident (* bound value *)
  | NeedValue 
  | Assign of J.ident (* when use [Assign], var is not needed, since it's already declared  *)

type cxt = {
  st : st ;
  should_return : return_type;
  jmp_table : value  HandlerMap.t ;
  meta : Lam_stats.meta ;
  (* include_alias :  *)
  (*   (\** It's correct to add more, we can do this in lambda optimization pass *)
  (*    *\) *)
  (*   (Ident.t , Ident.t) Hashtbl.t *)
  (* Used when compiling [Lstaticraise]  *)
}

let empty_handler_map = HandlerMap.empty


let add_jmps (exit_id, code_table)   
    (m : value HandlerMap.t) = 
  (* always keep key id positive, specifically no [0] generated
   *)
  let map, _, handlers = 
    List.fold_left 
           (fun (acc,prev_order_id, handlers) 
               (l,lam, args)   -> 
                 let order_id = prev_order_id + 1 in
                 (HandlerMap.add l {exit_id ; args; order_id } acc, 
                  order_id ,
                  (order_id, lam) :: handlers))
      (m,
       HandlerMap.cardinal m,
       []
      )
      code_table in
  map, List.rev handlers

end
module Js_output : sig 
#1 "js_output.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** The intemediate output when compiling lambda into JS IR *)

(* Hongbo Should we rename this module js_of_lambda since it looks like it's 
   containing that step
 *)

type st = Lam_compile_defs.st 

type finished = 
  | True 
  | False 
  | Dummy (* Have no idea, so that when [++] is applied, always use the other *)

type t  =  { 
  block : J.block ;
  value : J.expression option;
  finished : finished
}

val make : ?value: J.expression -> ?finished:finished -> J.block -> t

val of_stmt : ?value: J.expression -> ?finished:finished -> J.statement -> t

val of_block : ?value:J.expression -> ?finished:finished -> J.block -> t

val to_block : t -> J.block

val to_break_block : t -> J.block * bool 

module Ops : sig 
  val (++) : t -> t -> t 
end

val dummy : t 


val handle_name_tail :
    Lam_compile_defs.st ->
    Lam_compile_defs.return_type ->
    Lam.t ->  J.expression -> t

val handle_block_return : 
    Lam_compile_defs.st ->
    Lam_compile_defs.return_type ->
    Lam.t ->
    J.block -> J.expression -> t

val concat : t list -> t

val to_string : t -> string

end = struct
#1 "js_output.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








module E = Js_exp_make 
module S = Js_stmt_make 

type finished = 
  | True 
  | False 
  | Dummy (* Have no idea, so that when [++] is applied, always use the other *)

type t  =  { 
  block : J.block ;
  value : J.expression option;
  finished : finished ; 
    (** When [finished] is true the block is already terminated, value does not make sense
        default is false, false is  an conservative approach 
     *)
}

type st = Lam_compile_defs.st 

let make ?value ?(finished=False) block = {block ; value ; finished }

let of_stmt ?value ?(finished = False) stmt = {block = [stmt] ; value ; finished }

let of_block ?value ?(finished = False) block = 
  {block  ; value ; finished }

let dummy = {value = None; block = []; finished = Dummy }

let handle_name_tail 
    (name : st)
    (should_return : Lam_compile_defs.return_type)
    lam (exp : J.expression) : t =
  begin match name, should_return with 
  | EffectCall, False -> 
      if Lam_analysis.no_side_effects lam 
      then dummy
      else {block = []; value  = Some exp ; finished = False}
  | EffectCall, True _ ->
      make [S.return  exp] ~finished:True
  | Declare (kind, n), False -> 
      make [ S.define ~kind n  exp]
  | Assign n ,False -> 
      make [S.assign n exp ]
  | (Declare _ | Assign _ ), True _ -> 
      make [S.unknown_lambda lam] ~finished:True
  | NeedValue, _ -> {block = []; value = Some exp; finished = False }
  end

let handle_block_return 
    (st : st) 
    (should_return : Lam_compile_defs.return_type)
    (lam : Lam.t) (block : J.block) exp : t = 
  match st, should_return with 
  | Declare (kind,n), False -> 
    make (block @ [ S.define ~kind  n exp])
  | Assign n, False -> make (block @ [S.assign n exp])
  | (Declare _ | Assign _), True _ -> make [S.unknown_lambda lam] ~finished:True
  | EffectCall, False -> make block ~value:exp
  | EffectCall, True _ -> make (block @ [S.return exp]) ~finished:True
  | NeedValue, _ ->  make block ~value:exp

let statement_of_opt_expr (x : J.expression option) : J.statement =
  match x with 
  | None -> S.empty ()
  | Some x when Js_analyzer.no_side_effect_expression x -> S.empty ()
        (* TODO, pure analysis in lambda instead *)
  | Some x -> S.exp x 

let rec unroll_block (block : J.block) = 
  match block with 
  | [{statement_desc = Block block}] -> unroll_block block 
  |  _ -> block 

let to_block ( x : t)  : J.block = 
  match x with 
  | {block; value = opt; finished} ->
      let block = unroll_block block in
      if finished = True  then block
      else 
        begin match opt with 
        | None -> block (* TODO, pure analysis in lambda instead *)
        | Some x when Js_analyzer.no_side_effect_expression x -> block
        | Some x -> block @ [S.exp x ]
        end

let to_break_block (x : t) : J.block * bool = 
    match x with 
    | {finished = True; block ; _ } -> 
        unroll_block block, false 
       (* value does not matter when [finished] is true
           TODO: check if it has side efects
        *)
    | {block; value =  None; finished } -> 
        let block = unroll_block block in 
        block, (match finished with | True -> false | (False | Dummy)  -> true  )

    | {block; value = opt; _} -> 
        let block = unroll_block block in
        block @ [statement_of_opt_expr opt], true

let rec append  (x : t ) (y : t ) : t =  
    match x , y with (* ATTTENTION: should not optimize [opt_e2], it has to conform to [NeedValue]*)
    | {finished = True; _ }, _ -> x  
    | _, {block = []; value= None; finished = Dummy } -> x 
          (* finished = true --> value = E.undefined otherwise would throw*)
    | {block = []; value= None; _ }, y  -> y 
    | {block = []; value= Some _; _}, {block = []; value= None; _ } -> x 
    | {block = []; value =  Some e1; _}, ({block = []; value = Some e2; finished } as z) -> 
        if Js_analyzer.no_side_effect_expression e1 
        then z
            (* It would optimize cases like [module aliases]
                Bigarray, List 
             *)
        else
          {block = []; value = Some (E.seq e1 e2); finished}
          (* {block = [S.exp e1]; value =  Some e2(\* (E.seq e1 e2) *\); finished} *)

       (** TODO: make everything expression make inlining hard, and code not readable?

           1. readability pends on how we print the expression 
           2. inlining needs generate symbols, which are statements, type mismatch
              we need capture [Exp e]

           can we call them all [statement]? statement has no value 
        *)
    (* | {block = [{statement_desc = Exp e }]; value = None ; _}, _ *)
    (*   -> *)
    (*     append { x with block = []; value = Some e} y *)
    (* |  _ , {block = [{statement_desc = Exp e }]; value = None ; _} *)
    (*   -> *)
    (*     append x { y with block = []; value = Some e} *)

    | {block = block1; value = opt_e1; _},  {block = block2; value = opt_e2; finished} -> 
        let block1 = unroll_block block1 in
        make (block1 @ (statement_of_opt_expr opt_e1  :: unroll_block block2))
          ?value:opt_e2 ~finished


module Ops = struct 
  let (++)  (x : t ) (y : t ) : t =  append x y 
end

(* Fold right is more efficient *)
let concat (xs : t list) : t = 
  List.fold_right (fun x acc -> append x  acc) xs dummy

let to_string x   = 
  Js_dump.string_of_block (to_block x)

end
module Js_pass_debug : sig 
#1 "js_pass_debug.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






val dump : string  -> J.program -> J.program 

end = struct
#1 "js_pass_debug.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






let log_counter = ref 0 

let dump name (prog : J.program) =
    
  begin
    let () = 
      if Js_config.is_same_file ()
      then 
        begin
          incr log_counter ; 
          Ext_pervasives.with_file_as_chan       
            (Ext_filename.chop_extension ~loc:__LOC__ (Js_config.get_current_file()) ^
             (Printf.sprintf ".%02d.%s.jsx"  !log_counter name)
            ) (fun chan -> Js_dump.dump_program prog chan )
        end in
    prog    
  end

 

end
module Js_map
= struct
#1 "js_map.ml"
(* BuckleScript compiler
 * Copyright (C) 2015-2016 Bloomberg Finance L.P.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, with linking exception;
 * either version 2.1 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 *)
(* Author: Hongbo Zhang  *)
(** GENERATED CODE, map visitor for JS IR  *)
open J
  
class virtual map =
  object ((o : 'self_type))
    method string : string -> string = o#unknown
    method option :
      'a 'a_out. ('self_type -> 'a -> 'a_out) -> 'a option -> 'a_out option =
      fun _f_a ->
        function | None -> None | Some _x -> let _x = _f_a o _x in Some _x
    method list :
      'a 'a_out. ('self_type -> 'a -> 'a_out) -> 'a list -> 'a_out list =
      fun _f_a ->
        function
        | [] -> []
        | _x :: _x_i1 ->
            let _x = _f_a o _x in
            let _x_i1 = o#list _f_a _x_i1 in _x :: _x_i1
    method int : int -> int = o#unknown
    method bool : bool -> bool = function | false -> false | true -> true
    method vident : vident -> vident =
      function
      | Id _x -> let _x = o#ident _x in Id _x
      | Qualified (_x, _x_i1, _x_i2) ->
          let _x = o#ident _x in
          let _x_i1 = o#kind _x_i1 in
          let _x_i2 = o#option (fun o -> o#string) _x_i2
          in Qualified (_x, _x_i1, _x_i2)
    method variable_declaration :
      variable_declaration -> variable_declaration =
      fun { ident = _x; value = _x_i1; property = _x_i2; ident_info = _x_i3 }
        ->
        let _x = o#ident _x in
        let _x_i1 = o#option (fun o -> o#expression) _x_i1 in
        let _x_i2 = o#property _x_i2 in
        let _x_i3 = o#ident_info _x_i3
        in
          { ident = _x; value = _x_i1; property = _x_i2; ident_info = _x_i3;
          }
    method tag_info : tag_info -> tag_info = o#unknown
    method statement_desc : statement_desc -> statement_desc =
      function
      | Block _x -> let _x = o#block _x in Block _x
      | Variable _x -> let _x = o#variable_declaration _x in Variable _x
      | Exp _x -> let _x = o#expression _x in Exp _x
      | If (_x, _x_i1, _x_i2) ->
          let _x = o#expression _x in
          let _x_i1 = o#block _x_i1 in
          let _x_i2 = o#option (fun o -> o#block) _x_i2
          in If (_x, _x_i1, _x_i2)
      | While (_x, _x_i1, _x_i2, _x_i3) ->
          let _x = o#option (fun o -> o#label) _x in
          let _x_i1 = o#expression _x_i1 in
          let _x_i2 = o#block _x_i2 in
          let _x_i3 = o#unknown _x_i3 in While (_x, _x_i1, _x_i2, _x_i3)
      | ForRange (_x, _x_i1, _x_i2, _x_i3, _x_i4, _x_i5) ->
          let _x = o#option (fun o -> o#for_ident_expression) _x in
          let _x_i1 = o#finish_ident_expression _x_i1 in
          let _x_i2 = o#for_ident _x_i2 in
          let _x_i3 = o#for_direction _x_i3 in
          let _x_i4 = o#block _x_i4 in
          let _x_i5 = o#unknown _x_i5
          in ForRange (_x, _x_i1, _x_i2, _x_i3, _x_i4, _x_i5)
      | Continue _x -> let _x = o#label _x in Continue _x
      | Break -> Break
      | Return _x -> let _x = o#return_expression _x in Return _x
      | Int_switch (_x, _x_i1, _x_i2) ->
          let _x = o#expression _x in
          let _x_i1 =
            o#list
              (fun o ->
                 (* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)
                 (** Javascript IR
  
    It's a subset of Javascript AST specialized for OCaml lambda backend

    Note it's not exactly the same as Javascript, the AST itself follows lexical
    convention and [Block] is just a sequence of statements, which means it does 
    not introduce new scope
*)
                 (** object literal, if key is ident, in this case, it might be renamed by 
    Google Closure  optimizer,
    currently we always use quote
 *)
                 (* Since camldot is only available for toplevel module accessors,
       we don't need print  `A.length$2`
       just print `A.length` - it's guarateed to be unique
       
       when the third one is None, it means the whole module 

       TODO: 
       invariant, when [kind] is [Runtime], then we can ignore [ident], 
       since all [runtime] functions are unique, when do the 
       pattern match we can ignore the first one for simplicity
       for example       
       {[
         Qualified (_, Runtime, Some "caml_int_compare")         
       ]}       
     *)
                 (* used in [js_create_array] primitive, note having
       uninitilized array is not as bad as in ocaml, 
       since GC does not rely on it
     *)
                 (* shallow copy, like [x.slice] *)
                 (* For [caml_array_append]*)
                 (* | Tag_ml_obj of expression *) (* js true/false*)
                 (* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence 
     [typeof] is an operator     
  *)
                 (* !v *) (* String.fromCharCode.apply(null, args) *)
                 (* Convert JS boolean into OCaml boolean 
       like [+true], note this ast talks using js
       terminnology unless explicity stated                       
     *)
                 (* TODO: in the future, it might make sense to group primitivie by type,
     which makes optimizations easier
     {[ JSON.stringify(value, replacer[, space]) ]}
  *)
                 (* for debugging utitlites, 
     TODO:  [Dump] is not necessary with this primitive 
     Note that the semantics is slightly different from [JSON.stringify]     
     {[
       JSON.stringify("x")       
     ]}
     {[
       ""x""       
     ]}     
     {[
       JSON.stringify(undefined)       
     ]}     
     {[
       undefined       
     ]}
     {[ '' + undefined
     ]}     
     {[ 'undefined'
     ]}     
  *)
                 (* TODO: 
     add 
     {[ Assert of bool * expression ]}     
  *)
                 (* to support 
       val log1 : 'a -> unit
       val log2 : 'a -> 'b -> unit 
       val log3 : 'a -> 'b -> 'c -> unit 
     *)
                 (* TODO: Add some primitives so that [js inliner] can do a better job *)
                 (* [int_op] will guarantee return [int32] bits 
     https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators  *)
                 (* | Int32_bin of int_op * expression * expression *)
                 (* f.apply(null,args) -- Fully applied guaranteed 
       TODO: once we know args's shape --
       if it's know at compile time, we can turn it into
       f(args[0], args[1], ... )
     *)
                 (* {[ Bind (a,b) ]}
     is literally
     {[ a.bind(b) ]}
  *)
                 (* Analysze over J expression is hard since, 
        some primitive  call is translated 
        into a plain call, it's better to keep them
    *)
                 (* Invariant: 
       The second argument has to be type of [int],
       This can be constructed either in a static way [E.index] or a dynamic way 
       [E.access]
     *)
                 (* The third argument bool indicates whether we should 
       print it as 
       a["idd"] -- false
       or 
       a.idd  -- true
       There are several kinds of properties
       1. OCaml module dot (need to be escaped or not)
          All exported declarations have to be OCaml identifiers
       2. Javascript dot (need to be preserved/or using quote)
     *)
                 (* TODO: option remove *)
                 (* The first parameter by default is false, 
     it will be true when it's a method
  *)
                 (* A string is UTF-8 encoded, the string may contain
       escape sequences.
       The first argument is used to mark it is non-pure, please
       don't optimize it, since it does have side effec, 
       examples like "use asm;" and our compiler may generate "error;..." 
       which is better to leave it alone
     *)
                 (* literally raw JS code 
  *)
                 (* The third argument is [tag] , forth is [tag_info] *)
                 (* [tag] and [size] tailed  for [Obj.new_block] *)
                 (* For setter, it still return the value of expression, 
     we can not use 
     {[
       type 'a access = Get | Set of 'a
     ]}
     in another module, since it will break our code generator
     [Caml_block_tag] can return [undefined], 
     you have to use [E.tag] in a safe way     
  *)
                 (* It will just fetch tag, to make it safe, when creating it, 
     we need apply "|0", we don't do it in the 
     last step since "|0" can potentially be optimized
  *)
                 (* pure*) (* pure *)
                 (* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block
   block can be nested, specified in ES3 
 *)
                 (* Delay some units like [primitive] into JS layer ,
   benefit: better cross module inlining, and smaller IR size?
 *)
                 (* 
  [closure] captured loop mutable values in the outer loop

  check if it contains loop mutable values, happens in nested loop
  when closured, it's no longer loop mutable value. 
  which means the outer loop mutable value can not peek into the inner loop
  {[
  var i = f ();
  for(var finish = 32; i < finish; ++i){
  }
  ]}
  when [for_ident_expression] is [None], [var i] has to 
  be initialized outside, so 

  {[
  var i = f ()
  (function (xxx){
  for(var finish = 32; i < finish; ++i)
  }(..i))
  ]}
  This happens rare it's okay

  this is because [i] has to be initialized outside, if [j] 
  contains a block side effect
  TODO: create such example
*)
                 (* Since in OCaml, 
   
  [for i = 0 to k end do done ]
  k is only evaluated once , to encode this invariant in JS IR,
  make sure [ident] is defined in the first b

  TODO: currently we guarantee that [bound] was only 
  excecuted once, should encode this in AST level
*)
                 (* Can be simplified to keep the semantics of OCaml
   For (var i, e, ...){
     let  j = ... 
   }

   if [i] or [j] is captured inside closure

   for (var i , e, ...){
     (function (){
     })(i)
   }
*)
                 (* Single return is good for ininling..
   However, when you do tail-call optmization
   you loose the expression oriented semantics
   Block is useful for implementing goto
   {[
   xx:{
   break xx;
   }
   ]}
*)
                 (* Function declaration and Variable declaration  *)
                 (* check if it contains loop mutable values, happens in nested loop *)
                 (* only used when inline a fucntion *)
                 (* Here we need track back a bit ?, move Return to Function ...
                              Then we can only have one Return, which is not good *)
                 o#case_clause (fun o -> o#int))
              _x_i1 in
          let _x_i2 = o#option (fun o -> o#block) _x_i2
          in Int_switch (_x, _x_i1, _x_i2)
      | String_switch (_x, _x_i1, _x_i2) ->
          let _x = o#expression _x in
          let _x_i1 =
            o#list (fun o -> o#case_clause (fun o -> o#string)) _x_i1 in
          let _x_i2 = o#option (fun o -> o#block) _x_i2
          in String_switch (_x, _x_i1, _x_i2)
      | Throw _x -> let _x = o#expression _x in Throw _x
      | Try (_x, _x_i1, _x_i2) ->
          let _x = o#block _x in
          let _x_i1 =
            o#option
              (fun o (_x, _x_i1) ->
                 let _x = o#exception_ident _x in
                 let _x_i1 = o#block _x_i1 in (_x, _x_i1))
              _x_i1 in
          let _x_i2 = o#option (fun o -> o#block) _x_i2
          in Try (_x, _x_i1, _x_i2)
      | Debugger -> Debugger
    method statement : statement -> statement =
      fun { statement_desc = _x; comment = _x_i1 } ->
        let _x = o#statement_desc _x in
        let _x_i1 = o#option (fun o -> o#string) _x_i1
        in { statement_desc = _x; comment = _x_i1; }
    method return_expression : return_expression -> return_expression =
      fun { return_value = _x } ->
        let _x = o#expression _x in { return_value = _x; }
    method required_modules : required_modules -> required_modules =
      o#unknown
    method property_name : property_name -> property_name = o#unknown
    method property_map : property_map -> property_map =
      o#list
        (fun o (_x, _x_i1) ->
           let _x = o#property_name _x in
           let _x_i1 = o#expression _x_i1 in (_x, _x_i1))
    method property : property -> property = o#unknown
    method program : program -> program =
      fun { name = _x; block = _x_i1; exports = _x_i2; export_set = _x_i3 }
        ->
        let _x = o#string _x in
        let _x_i1 = o#block _x_i1 in
        let _x_i2 = o#exports _x_i2 in
        let _x_i3 = o#unknown _x_i3
        in { name = _x; block = _x_i1; exports = _x_i2; export_set = _x_i3; }
    method number : number -> number = o#unknown
    method mutable_flag : mutable_flag -> mutable_flag = o#unknown
    method length_object : length_object -> length_object = o#unknown
    method label : label -> label = o#string
    method kind : kind -> kind = o#unknown
    method jsint : jsint -> jsint = o#unknown
    method int_op : int_op -> int_op = o#unknown
    method ident_info : ident_info -> ident_info = o#unknown
    method ident : ident -> ident = o#unknown
    method for_ident_expression :
      for_ident_expression -> for_ident_expression = o#expression
    method for_ident : for_ident -> for_ident = o#ident
    method for_direction : for_direction -> for_direction = o#unknown
    method finish_ident_expression :
      finish_ident_expression -> finish_ident_expression = o#expression
    method expression_desc : expression_desc -> expression_desc =
      function
      | Math (_x, _x_i1) ->
          let _x = o#string _x in
          let _x_i1 = o#list (fun o -> o#expression) _x_i1
          in Math (_x, _x_i1)
      | Length (_x, _x_i1) ->
          let _x = o#expression _x in
          let _x_i1 = o#length_object _x_i1 in Length (_x, _x_i1)
      | Char_of_int _x -> let _x = o#expression _x in Char_of_int _x
      | Char_to_int _x -> let _x = o#expression _x in Char_to_int _x
      | Array_of_size _x -> let _x = o#expression _x in Array_of_size _x
      | Array_copy _x -> let _x = o#expression _x in Array_copy _x
      | Array_append (_x, _x_i1) ->
          let _x = o#expression _x in
          let _x_i1 = o#expression _x_i1 in Array_append (_x, _x_i1)
      | String_append (_x, _x_i1) ->
          let _x = o#expression _x in
          let _x_i1 = o#expression _x_i1 in String_append (_x, _x_i1)
      | Int_of_boolean _x -> let _x = o#expression _x in Int_of_boolean _x
      | Anything_to_number _x ->
          let _x = o#expression _x in Anything_to_number _x
      | Bool _x -> let _x = o#bool _x in Bool _x
      | Typeof _x -> let _x = o#expression _x in Typeof _x
      | Not _x -> let _x = o#expression _x in Not _x
      | String_of_small_int_array _x ->
          let _x = o#expression _x in String_of_small_int_array _x
      | Json_stringify _x -> let _x = o#expression _x in Json_stringify _x
      | Anything_to_string _x ->
          let _x = o#expression _x in Anything_to_string _x
      | Dump (_x, _x_i1) ->
          let _x = o#unknown _x in
          let _x_i1 = o#list (fun o -> o#expression) _x_i1
          in Dump (_x, _x_i1)
      | Seq (_x, _x_i1) ->
          let _x = o#expression _x in
          let _x_i1 = o#expression _x_i1 in Seq (_x, _x_i1)
      | Cond (_x, _x_i1, _x_i2) ->
          let _x = o#expression _x in
          let _x_i1 = o#expression _x_i1 in
          let _x_i2 = o#expression _x_i2 in Cond (_x, _x_i1, _x_i2)
      | Bin (_x, _x_i1, _x_i2) ->
          let _x = o#binop _x in
          let _x_i1 = o#expression _x_i1 in
          let _x_i2 = o#expression _x_i2 in Bin (_x, _x_i1, _x_i2)
      | FlatCall (_x, _x_i1) ->
          let _x = o#expression _x in
          let _x_i1 = o#expression _x_i1 in FlatCall (_x, _x_i1)
      | Bind (_x, _x_i1) ->
          let _x = o#expression _x in
          let _x_i1 = o#expression _x_i1 in Bind (_x, _x_i1)
      | Call (_x, _x_i1, _x_i2) ->
          let _x = o#expression _x in
          let _x_i1 = o#list (fun o -> o#expression) _x_i1 in
          let _x_i2 = o#unknown _x_i2 in Call (_x, _x_i1, _x_i2)
      | String_access (_x, _x_i1) ->
          let _x = o#expression _x in
          let _x_i1 = o#expression _x_i1 in String_access (_x, _x_i1)
      | Access (_x, _x_i1) ->
          let _x = o#expression _x in
          let _x_i1 = o#expression _x_i1 in Access (_x, _x_i1)
      | Dot (_x, _x_i1, _x_i2) ->
          let _x = o#expression _x in
          let _x_i1 = o#string _x_i1 in
          let _x_i2 = o#bool _x_i2 in Dot (_x, _x_i1, _x_i2)
      | New (_x, _x_i1) ->
          let _x = o#expression _x in
          let _x_i1 =
            o#option (fun o -> o#list (fun o -> o#expression)) _x_i1
          in New (_x, _x_i1)
      | Var _x -> let _x = o#vident _x in Var _x
      | Fun (_x, _x_i1, _x_i2, _x_i3) ->
          let _x = o#bool _x in
          let _x_i1 = o#list (fun o -> o#ident) _x_i1 in
          let _x_i2 = o#block _x_i2 in
          let _x_i3 = o#unknown _x_i3 in Fun (_x, _x_i1, _x_i2, _x_i3)
      | Str (_x, _x_i1) ->
          let _x = o#bool _x in let _x_i1 = o#string _x_i1 in Str (_x, _x_i1)
      | Raw_js_code (_x, _x_i1) ->
          let _x = o#string _x in
          let _x_i1 = o#code_info _x_i1 in Raw_js_code (_x, _x_i1)
      | Array (_x, _x_i1) ->
          let _x = o#list (fun o -> o#expression) _x in
          let _x_i1 = o#mutable_flag _x_i1 in Array (_x, _x_i1)
      | Caml_block (_x, _x_i1, _x_i2, _x_i3) ->
          let _x = o#list (fun o -> o#expression) _x in
          let _x_i1 = o#mutable_flag _x_i1 in
          let _x_i2 = o#expression _x_i2 in
          let _x_i3 = o#tag_info _x_i3
          in Caml_block (_x, _x_i1, _x_i2, _x_i3)
      | Caml_uninitialized_obj (_x, _x_i1) ->
          let _x = o#expression _x in
          let _x_i1 = o#expression _x_i1
          in Caml_uninitialized_obj (_x, _x_i1)
      | Caml_block_tag _x -> let _x = o#expression _x in Caml_block_tag _x
      | Caml_block_set_tag (_x, _x_i1) ->
          let _x = o#expression _x in
          let _x_i1 = o#expression _x_i1 in Caml_block_set_tag (_x, _x_i1)
      | Caml_block_set_length (_x, _x_i1) ->
          let _x = o#expression _x in
          let _x_i1 = o#expression _x_i1 in Caml_block_set_length (_x, _x_i1)
      | Number _x -> let _x = o#number _x in Number _x
      | Object _x -> let _x = o#property_map _x in Object _x
    method expression : expression -> expression =
      fun { expression_desc = _x; comment = _x_i1 } ->
        let _x = o#expression_desc _x in
        let _x_i1 = o#option (fun o -> o#string) _x_i1
        in { expression_desc = _x; comment = _x_i1; }
    method exports : exports -> exports = o#unknown
    method exception_ident : exception_ident -> exception_ident = o#ident
    method deps_program : deps_program -> deps_program =
      fun { program = _x; modules = _x_i1; side_effect = _x_i2 } ->
        let _x = o#program _x in
        let _x_i1 = o#required_modules _x_i1 in
        let _x_i2 = o#option (fun o -> o#string) _x_i2
        in { program = _x; modules = _x_i1; side_effect = _x_i2; }
    method code_info : code_info -> code_info = o#unknown
    method case_clause :
      (* since in ocaml, it's expression oriented langauge, [return] in
    general has no jumps, it only happens when we do 
    tailcall conversion, in that case there is a jump.
    However, currently  a single [break] is good to cover
    our compilation strategy 

    Attention: we should not insert [break] arbitrarily, otherwise 
    it would break the semantics
    A more robust signature would be 
    {[ goto : label option ; ]}
  *)
        'a 'a_out.
        ('self_type -> 'a -> 'a_out) -> 'a case_clause -> 'a_out case_clause =
      fun _f_a { case = _x; body = _x_i1 } ->
        let _x = _f_a o _x in
        let _x_i1 =
          (fun (_x, _x_i1) ->
             let _x = o#block _x in let _x_i1 = o#bool _x_i1 in (_x, _x_i1))
            _x_i1
        in { case = _x; body = _x_i1; }
    method block : block -> block = (* true means break *)
      (* TODO: For efficency: block should not be a list, it should be able to 
   be concatenated in both ways 
 *)
      o#list (fun o -> o#statement)
    method binop : binop -> binop = o#unknown
    method unknown : 'a. 'a -> 'a = fun x -> x
  end
  


end
module Js_pass_flatten : sig 
#1 "js_pass_flatten.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** A pass converting nested js statement into a flatten visual appearance 

    Note this module is used to convert some nested expressions to flat statements, 
    in general, it's more human readable, and since it generate flat statements, we can spot
    some inline opportunities for the produced statemetns, 
    (inline) expressions inside a nested expression would generate ugly code.

    Since we are aiming to flatten expressions, we should avoid some smart constructors in {!Js_helper}, 
    it  tries to spit out expression istead of statements if it can
*)

val program : J.program -> J.program

end = struct
#1 "js_pass_flatten.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








module E = Js_exp_make
module S = Js_stmt_make 

let flatten_map = 
  object(self)
    inherit Js_map.map as super
    method! statement x = 
      match x.statement_desc with 
      |  Exp ({expression_desc = Seq _; _} as v) ->
          (S.block ( List.rev_map (self#statement) (Js_analyzer.rev_flatten_seq v )))
      |  Exp ({expression_desc = Cond(a,b,c); comment} ) -> 
          (* Note that we need apply [self#statement] recursively *)
          { statement_desc = If (a, [ self#statement (S.exp b)],  
                                 Some [ self#statement (S.exp c)]); comment}
          (* CHECK? Trick semantics difference *)
          (* super#statement (S.if_ a ([ (\* self#statement *\) (S.exp b) ]) *)
          (*     ~else_:([self#statement (S.exp c)]) *)
          (*                 ) *)

      |  Exp ({expression_desc = Bin(Eq, a, ({expression_desc = Seq _; _ } as v)); _} )
        ->
          let block = Js_analyzer.rev_flatten_seq v in
          begin match block with
          | {statement_desc = Exp last_one ; _} :: rest_rev
            ->  
              S.block (Ext_list.rev_map_append (self#statement) rest_rev 
                [self#statement @@ S.exp (E.assign a  last_one)])
                (* TODO: here we introduce a block, should avoid it *)
              (* super#statement *)
              (*   (S.block (List.rev_append rest_rev [S.exp (E.assign a  last_one)])) *)
          | _ ->
              assert false
          end
      | Return ( {return_value = {expression_desc = Cond (a,b,c);  comment}}) 
        -> 
          { statement_desc = If (a, [self#statement (S.return b)],  
                                 Some [ self#statement (S.return c)]); comment}

      | Return ({return_value = {expression_desc = Seq _; _} as v}) ->
          let block = Js_analyzer.rev_flatten_seq v  in
          begin match block with
          | {statement_desc = Exp last_one ; _} :: rest_rev
            ->  
              super#statement 
                (S.block (Ext_list.rev_map_append (self#statement) rest_rev [S.return last_one]))
          | _ -> assert false
          end
      | Block [x]
          -> 
            self#statement x 
      | _ -> super#statement x 

    method! block b =
      match b with
      | {statement_desc = Block bs } :: rest ->
          self#block ( bs @  rest)
      | x::rest  
        -> 
          self#statement x :: self#block rest
      | [] -> []
  end

let program ( x : J.program) = flatten_map # program x 

end
module Js_pass_flatten_and_mark_dead : sig 
#1 "js_pass_flatten_and_mark_dead.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** A pass to mark some declarations in JS IR as dead code *)

val program :  J.program -> J.program

end = struct
#1 "js_pass_flatten_and_mark_dead.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








module E = Js_exp_make
module S = Js_stmt_make

class count  var = object (self : 'self)
  val mutable appears = 0
  inherit Js_fold.fold as super
  method! ident  x =
    (if Ident.same x var then
      appears <- appears + 1); 
    self
  method get_appears = appears 
end

(* rewrite return for current block, but don't go into
   inner function, mostly for inlinning
 *)
class rewrite_return ?return_value ()=
  let mk_return  = 
    match return_value with 
    | None -> fun e -> S.exp e 
    | Some ident -> fun e -> S.define ~kind:Variable ident e in
  object (self : 'self)
    inherit Js_map.map as super
    method! statement x =
      match x.statement_desc with 
      | Return {return_value = e} -> 
          mk_return e 
      | _ -> super#statement x 
    method! expression x = x (* don't go inside *)
  end  

(* 
    HERE we are using an object , so make sure to clean it up, 
    remove stale cache
 *)
let mark_dead = object (self)
  inherit Js_fold.fold as super

  val mutable name = ""

  val mutable ident_use_stats : (Ident.t , [`Info of J.ident_info | `Recursive]) Hashtbl.t
      = Hashtbl.create 17
  
  val mutable export_set : Ident_set.t = Ident_set.empty    

  method mark_not_dead ident =
    match Hashtbl.find ident_use_stats ident with
    | exception Not_found -> (* First time *)
        Hashtbl.add ident_use_stats ident `Recursive 
        (* recursive identifiers *)
    | `Recursive
      -> ()
    | `Info x ->  Js_op_util.update_used_stats x Used 

  method scan b ident (ident_info : J.ident_info) = 
    let is_export = Ident_set.mem ident export_set in
    let () = 
      if is_export (* && false *) then 
        Js_op_util.update_used_stats ident_info Exported 
    in
    match Hashtbl.find ident_use_stats ident with
    | `Recursive -> 
        Js_op_util.update_used_stats ident_info Used; 
        Hashtbl.replace ident_use_stats ident (`Info ident_info)
    | `Info _ ->  
        (** check [camlinternlFormat,box_type] inlined twice 
            FIXME: seems we have redeclared identifiers
         *)
      if Js_config.get_diagnose () then 
        Ext_log.warn __LOC__ "@[%s$%d in %s@]" ident.name ident.stamp name
        (* assert false *)
    | exception Not_found ->  (* First time *)
        Hashtbl.add ident_use_stats ident (`Info ident_info);
        Js_op_util.update_used_stats ident_info 
          (if b then Scanning_pure else Scanning_non_pure)
  method promote_dead = 
    Hashtbl.iter (fun _id (info : [`Info of J.ident_info  | `Recursive]) ->
      match info  with 
      | `Info ({used_stats = Scanning_pure} as info) -> 
          Js_op_util.update_used_stats info Dead_pure
      | `Info ({used_stats = Scanning_non_pure} as info) -> 
          Js_op_util.update_used_stats info Dead_non_pure
      | _ -> ())
      ident_use_stats;
    Hashtbl.clear ident_use_stats (* clear to make it re-entrant *)

  method! program x = 
    export_set <- x.export_set ; 
    name <- x.name;
    super#program x 

  method! ident x = 
    self#mark_not_dead x ; self 

  method! variable_declaration vd =  
    match vd with 
    | { ident_info = {used_stats = Dead_pure } ; _}
      -> self
    | { ident_info = {used_stats = Dead_non_pure } ; value } -> 
      begin match value with
      | None -> self
      | Some x -> self#expression x 
      end
    | {ident; ident_info ; value ; _} -> 
      let pure = 
        match value with 
        | None  -> false 
        | Some x -> ignore (self#expression x); Js_analyzer.no_side_effect_expression x in
      self#scan pure ident ident_info; self
end

let mark_dead_code js = 
  let _ =  (mark_dead#program js) in 
  mark_dead#promote_dead;
  js
        
(*
   when we do optmizations, we might need track it will break invariant 
   of other optimizations, especially for [mutable] meta data, 
   for example, this pass will break [closure] information, 
   it should be done before closure pass (even it does not use closure information)

   Take away, it is really hard to change the code while collecting some information..
   we should always collect info in a single pass

   Note that, we should avoid reuse object, i.e,
   {[
     let v = 
       object 
       end      
   ]}   
   Since user may use `bsc.exe -c xx.ml xy.ml xz.ml` and we need clean up state
 *)
let subst_map name = object (self)
  inherit Js_map.map as super

  val mutable substitution = Hashtbl.create 17 

  method get_substitution = substitution

  method add_substitue (ident : Ident.t) (e:J.expression) = 
    Hashtbl.replace  substitution ident e

  method! statement v = 
    match v.statement_desc with 
    | Variable ({ident; ident_info = {used_stats = Dead_pure } ; _}) -> 
      {v with statement_desc = Block []}
    | Variable ({ident; ident_info = {used_stats = Dead_non_pure } ; value = None}) -> 
      {v with statement_desc = Block []}
    | Variable ({ident; ident_info = {used_stats = Dead_non_pure } ; value = Some x}) -> 
      {v with statement_desc =  (Exp x)}

    | Variable ({ ident ; 
                  property = (Strict | StrictOpt | Alias);
                  value = Some (
                      {expression_desc = (Caml_block ( _:: _ :: _ as ls, Immutable, tag, tag_info) 
                                         )} as block)
                } as variable) -> 
      (** If we do this, we should prevent incorrect inlning to inline it into an array :) 
          do it only when block size is larger than one
      *)

      let (_, e, bindings) = 
        List.fold_left 
          (fun  (i,e,  acc) (x : J.expression) -> 
             match x.expression_desc with 
             | J.Var _ | Number _ | Str _ 
               -> 
               (i + 1, x :: e, acc)
             | _ ->                
               (* tradeoff, 
                   when the block is small, it does not make 
                   sense too much -- 
                   bottomline, when the block size is one, no need to do 
                   this
               *)
               let v' = self#expression x in 
               let match_id =
                 Ext_ident.create
                   (Printf.sprintf "%s_%03d"
                      ident.name i) in
               (i + 1, E.var match_id :: e, (match_id, v') :: acc)               
          ) (0, [], []) ls  in
      let e = 
        {block with 
         expression_desc = 
           Caml_block(List.rev e, Immutable, tag, tag_info)
        } in
      let () = self#add_substitue ident e in
      (* let bindings =  !bindings in *)
      let original_statement = 
        { v with 
          statement_desc = Variable {variable with value =  Some   e }
        } in
      begin match bindings with 
        | [] -> 
          original_statement
        | _ ->  
          (* self#add_substitue ident e ; *)
          S.block @@
          (Ext_list.rev_map_acc [original_statement] (fun (id,v) -> 
               S.define ~kind:Strict id v)  bindings  )
      end
    | _ -> super#statement v 

  method! expression x =
    match x.expression_desc with 
    | Access ({expression_desc = Var (Id (id))}, 
              {expression_desc = Number (Int {i; _})}) -> 
      begin match Hashtbl.find self#get_substitution id with 
        | {expression_desc = Caml_block (ls, Immutable, _, _) } 
          -> 
          (* user program can be wrong, we should not 
             turn a runtime crash into compile time crash : )
          *)          
          begin match List.nth ls (Int32.to_int i) with 
            | {expression_desc = J.Var _ | Number _ | Str _ } as x 
              -> x 
            | exception _ ->
              begin
                Ext_log.err __LOC__ "suspcious code %s when compiling %s@."
                  (Printf.sprintf "%s/%d" id.name id.stamp)
                  name  ;
                super#expression x ;
              end
            | _ -> 
              (** we can do here, however, we should 
                  be careful that it can only be done 
                  when it's accessed once and the array is not escaped,
                  otherwise, we redo the computation,
                  or even better, we re-order

                  {[
                    var match = [/* tuple */0,Pervasives.string_of_int(f(1,2,3)),f3(2),arr];

                        var a = match[1];

                          var b = match[2];

                  ]}

                  --->

                  {[
                    var match$1 = Pervasives.string_of_int(f(1,2,3));
                        var match$2 = f3(2);
                            var match = [/* tuple */0,match$1,match$2,arr];
                                var a = match$1;
                                  var b = match$2;
                                    var arr = arr; 
                  ]}

                  --> 
                  since match$1 (after match is eliminated) is only called once 
                  {[
                    var a = Pervasives.string_of_int(f(1,2,3));
                    var b = f3(2);
                    var arr = arr; 
                  ]}

              *)
              super#expression x 
          end
        | _ -> super#expression x 
        | exception Not_found -> super#expression x 
      end
    | _ -> super#expression x
end 

(* Top down or bottom up ?*)
(* A pass to support nullary argument in JS 
    Nullary information can be done in one pass, 
    there is no need to add another pass
 *)

let program  (js : J.program) = 
  js 
  |> (subst_map js.name )#program
  |> mark_dead_code
  (* |> mark_dead_code *)
  (* mark dead code twice does have effect in some cases, however, we disabled it 
    since the benefit is not obvious
   *)

end
module Js_pass_scope : sig 
#1 "js_pass_scope.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** A module to do scope analysis over JS IR *)

val program : J.program ->  Ident_set.t

end = struct
#1 "js_pass_scope.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








let _l idents = 
  Ext_log.err __LOC__ "hey .. %s@." 
    (String.concat "," @@ List.map (fun  i -> i.Ident.name ) idents) 

(* 

    Base line 
    {[
     for i = 1 to n do (function (i){...}(i))
     done
       (* This is okay, since all ocaml follow the lexical scope, 
          for generrated code too (* TODO: check *)
        *)
    ]}

  For nested loops 
  {[
   for i = 0 to n do 
     for j = 0 to n do 
       arrr.(j)<- ()=>{ i}
     done
   done
 ]}
    Three kind of variables  (defined in the loop scope)
    1. loop mutable variables 
       As long as variables change per iteration, defined in a loop (in the same loop)
        and captured by a closure
       the loop, iff  be lexically scoped 
       Tailcall parameters are considered defined inside the loop
    - unless it's defined 
       outside all the loops - note that for nested loops, if it's defined 
       in the outerloop and captured by the inner loop, 
       it still has to be lexically scoped. 

       How do we detect whether it is loop invariant or not 
       - depend on loop variant 
       - depend on mutuable valuse
       - non pure (function call)

       so we need collect mutable variables 
       1. from lambda + loop (for/i) + tailcall params
       2. defined in the loop and can not determine it is invariant  
          in such cases we can determine it's immutable
          1. const 
          2. only depend on immutable values and no function call?

    ## The following would take advantage of nested loops 
    2. loop invariant observable varaibles 
        {[ 
         var x = (console.log(3), 32)
        ]}
    3. loop invariant non-observable variables 

    Invariant: 
    loop invariant (observable or not) variables can not depend on 
    loop mutable values so that once we detect loop Invariant variables 
    all its dependency are loop invariant as well, so we can do loop 
    Invariant code motion.
    
    TODO:
    loop invariant can be layered, it will be loop invariant 
    in the inner layer while loop variant in the outer layer.
    {[
    for i = 0 to 10 do 
      for j  = 10 do 
        let  k0 = param * 100 in (* loop invariant *)
        let  k1 = i * i in (* inner loop invariant, loop variant *)
        let  k2 = j * i in (* variant *)
        ..
      done 
    done 
    ]}
*)

let scope_pass  = 
  object(self)
    inherit Js_fold.fold as super

    val  defined_idents = Ident_set.empty 
        
    (** [used_idents] 
        does not contain locally defined idents *)
    val  used_idents = Ident_set.empty 
    (** we need collect mutable values and loop defined varaibles *)    
    val loop_mutable_values = Ident_set.empty 

    val mutable_values = Ident_set.empty      

    val closured_idents = Ident_set.empty 

    (** check if in loop or not *)    
    val in_loop = false 

    method get_in_loop = in_loop

    method get_defined_idents = defined_idents

    method get_used_idents = used_idents

    method get_loop_mutable_values = loop_mutable_values 

    method get_mutable_values = mutable_values 

    method get_closured_idents = closured_idents 

    method with_in_loop b = 
      if b = self#get_in_loop then self
      else {< in_loop = b >}
     (* Since it's loop mutable variable, for sure
         it is mutable variable
         *)       
    method with_loop_mutable_values b = 
      {< loop_mutable_values =  b >}

    method add_loop_mutable_variable id = 
      {< loop_mutable_values = Ident_set.add id loop_mutable_values;
         mutable_values = Ident_set.add id mutable_values
         >}

    method add_mutable_variable id = 
      {< mutable_values = Ident_set.add id mutable_values >}

    method add_defined_ident ident = 
      {< defined_idents = Ident_set.add ident defined_idents >} 

    method! expression x = 
      match x.expression_desc with 
      | Fun (_method_, params, block , env) -> 
        (* Function is the only place to introduce a new scope in 
            ES5
            TODO: check 
            {[ try .. catch(exn) {.. }]}
            what's the scope of exn
        *)
        (* Note that [used_idents] is not complete
            it ignores some locally defined idents *)
        let param_set = Ident_set.of_list params in
        let obj =  {<defined_idents = Ident_set.empty;
                     (** pass [empty]
                         so that we can check which parameter was actually used *)
                     used_idents = Ident_set.empty ;
                     in_loop = false;
                     loop_mutable_values = Ident_set.empty;
                     mutable_values = Ident_set.of_list (Js_fun_env.get_mutable_params params env) ; 
                     closured_idents = Ident_set.empty; (* think about nested function*)
                   >} # block block in
        let defined_idents', used_idents' = 
          obj#get_defined_idents, obj#get_used_idents  in
        (* mark which param is used *)
        params |> List.iteri 
          (fun i v -> 
             if not (Ident_set.mem v used_idents') then 
               Js_fun_env.mark_unused env i) ;
        let closured_idents' =  (* pass param_set down *)
          Ident_set.(diff used_idents' (union defined_idents' param_set )) in

        (* Noe that we don't know which variables are exactly mutable yet ..
           due to the recursive thing
         *)
        Js_fun_env.set_unbounded env closured_idents'   ; 
        let lexical_scopes = Ident_set.(inter closured_idents' self#get_loop_mutable_values) in
        Js_fun_env.set_lexical_scope env lexical_scopes;
        (* tailcall , note that these varibles are used in another pass *)
        {< used_idents = 
             Ident_set.union used_idents closured_idents' ;
           (* There is a bug in ocaml -dsource*)           
           closured_idents = Ident_set.union closured_idents closured_idents'
        >}
      | _ -> super#expression x 
            (* TODO: most variables are immutable *)

    method! variable_declaration x = 
      match x with
      | { ident ; value; property  }  -> 
        let obj = 
          (match self#get_in_loop, property with 
           | true, Variable 
             -> 
             self#add_loop_mutable_variable ident 
           | true, (Strict | StrictOpt | Alias)
           (* Not real true immutable in javascript 
               since it's in the loop 

               TODO: we should also 
           *)
             -> 
             begin match value with 
               | None -> self#add_loop_mutable_variable ident
               (* TODO: Check why assertion failure *)
               (* self#add_loop_mutable_variable ident *) (* assert false *)
               | Some x
                 ->
                 (** 
                     when x is an immediate immutable value, 
                     (like integer .. )
                     not a reference, it should be Immutable
                     or string, 
                     type system might help here
                     TODO:
                 *)
                 match x.expression_desc with
                 | Fun _  | Number _ | Str _ 
                   -> self 
                 | _ -> 
                   (* if Ident_set.(is_empty @@ *)
                   (*   inter self#get_mutable_values  *)
                   (*     ( ({<  *)
                   (*         defined_idents = Ident_set.empty;  *)
                   (*         used_idents = Ident_set.empty; *)
                   (*         >} # expression x) # get_used_idents)) then *)
                   (*   (\* FIXME: still need to check expression is pure or not*\) *)
                   (*   self *)
                   (* else  *)
                   self#add_loop_mutable_variable ident
             end
           | false, Variable
             -> 
             self#add_mutable_variable ident      
           | false, (Strict | StrictOpt | Alias)
             -> self
          )#add_defined_ident ident
        in
        begin match value with 
          | None -> obj 
          | Some x -> obj # expression x  
        end 

        
    method! statement x = 
      match x.statement_desc with 
      | ForRange  (_,_, loop_id, _,_,a_env) as y -> (* TODO: simplify definition of For *)
          let obj = 
            {< in_loop = true ;
               loop_mutable_values = Ident_set.singleton loop_id ;
               used_idents = Ident_set.empty; (* TODO: if unused, can we generate better code? *)
               defined_idents = Ident_set.singleton loop_id ;
               closured_idents = Ident_set.empty (* Think about nested for blocks *)
                 (* Invariant: Finish id is never used *)
                 >}
              # statement_desc y in

          let defined_idents', used_idents', closured_idents' = 
            obj#get_defined_idents, obj#get_used_idents, obj#get_closured_idents in


          let lexical_scope =  Ident_set.(inter (diff closured_idents' defined_idents') self#get_loop_mutable_values) in
          let () = Js_closure.set_lexical_scope a_env lexical_scope in
          (* set scope *)
          {< used_idents = Ident_set.union used_idents used_idents';
             (* walk around ocaml -dsource bug 
                {[ 
                  Ident_set.(union used_idents used_idents)                  
                ]}                
             *)             
             defined_idents = Ident_set.union defined_idents defined_idents';
             (* TODO: if we our generated code also follow lexical scope,
                this is not necessary ;
                [varaibles] are mutable or not is known at definition
              *)
             closured_idents = Ident_set.union closured_idents lexical_scope
             >}

      | While (_label,pred,body, _env) ->  
          (((self#expression pred)#with_in_loop true) # block  body )
            #with_in_loop (self#get_in_loop)
      | _ -> 
          super#statement x 

    method! exception_ident x = 
      (* we can not simply skip it, since it can be used 
          TODO: check loop exception
          (loop {
          excption(i){
          () => {i}
          } 
          })
       *)
      {< used_idents = Ident_set.add x used_idents;
         defined_idents = Ident_set.add x defined_idents
         >}
    method! for_ident x = {< loop_mutable_values = Ident_set.add x loop_mutable_values >}

    method! ident x = 
      if Ident_set.mem x defined_idents then 
        self
      else {< used_idents = Ident_set.add x used_idents >}
  end

let program js = 
  (scope_pass # program js ) # get_loop_mutable_values

end
module Js_pass_tailcall_inline : sig 
#1 "js_pass_tailcall_inline.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** This pass detect functions used once and if it is used in used
    in the tail position, it will get inlined, this will help 
    remove some common use cases like This
    {[
      let length x = 
        let rec aux n x = 
          match x with 
          | [] -> n 
          | _ :: rest -> aux (n + 1) rest in
        aux 0 x         
    ]} 
*)

val tailcall_inline : J.program -> J.program 

end = struct
#1 "js_pass_tailcall_inline.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






(* When we inline a function call, if we don't do a beta-reduction immediately, there is 
   a chance that it is ignored, (we can not assume that each pass is robust enough)

   After we do inlining, it makes sense to do another constant folding and propogation 
 *)

(* Check: shall we inline functions with while loop? if it is used only once, 
   it makes sense to inline it
*)

module S = Js_stmt_make
module E = Js_exp_make


(** Update ident info use cases, it is a non pure function, 
    it will annotate [program] with some meta data
    TODO: Ident Hashtbl could be improved, 
    since in this case it can not be global?  

 *)
let count_collects () = 
  object (self)
    inherit Js_fold.fold as super
    (* collect used status*)
    val stats : (Ident.t , int ref ) Hashtbl.t = Hashtbl.create 83
    (* collect all def sites *)
    val defined_idents : (Ident.t, J.variable_declaration) Hashtbl.t = Hashtbl.create 83

    val mutable export_set  : Ident_set.t = Ident_set.empty
    val mutable name : string = ""

    method add_use id = 
      match Hashtbl.find stats id with
      | exception Not_found -> Hashtbl.add stats id (ref 1)
      | v -> incr v 
    method! program x = 
      export_set <- x.export_set ; 
      name <- x.name;
      super#program x
    method! variable_declaration 
        ({ident; value ; property  ; ident_info }  as v)
      =  
        Hashtbl.add defined_idents ident v; 
        match value with 
        | None
          -> 
          self
        | Some x
          -> self#expression x 
    method! ident id = self#add_use id; self
    method get_stats = 
      Hashtbl.iter (fun ident (v : J.variable_declaration) -> 
          if Ident_set.mem ident export_set then 
            Js_op_util.update_used_stats v.ident_info Exported
          else 
            let pure = 
              match v.value  with 
              | None -> false  (* can not happen *)
              | Some x -> Js_analyzer.no_side_effect_expression x  
            in
            match Hashtbl.find stats ident with 
              | exception Not_found -> 
                Js_op_util.update_used_stats v.ident_info 
                  (if pure then Dead_pure else Dead_non_pure)
              | num -> 
                if !num = 1 then 
                  Js_op_util.update_used_stats v.ident_info 
                    (if pure then Once_pure else Used) 
        ) defined_idents; defined_idents
  end


let get_stats program
  =  ((count_collects ()) #program program) #get_stats


(* 1. recursive value ? let rec x = 1 :: x
    non-terminating
    2. duplicative identifiers ..
    remove it at the same time is a bit unsafe,
    since we have to guarantee that the one use
    case is substituted
    we already have this? in [defined_idents]
*)

(** There is a side effect when traversing dead code, since 
   we assume that substitue a node would mark a node as dead node,
  
    so if we traverse a dead node, this would get a wrong result.
   it does happen in such scenario
   {[
     let generic_basename is_dir_sep current_dir_name name =
       let rec find_end n =
         if n < 0 then String.sub name 0 1
         else if is_dir_sep name n then find_end (n - 1)
         else find_beg n (n + 1)
       and find_beg n p =
         if n < 0 then String.sub name 0 p
         else if is_dir_sep name n then String.sub name (n + 1) (p - n - 1)
         else find_beg (n - 1) p
       in
       if name = ""
       then current_dir_name
       else find_end (String.length name - 1)
   ]}
   [find_beg] can potentially be expanded in [find_end] and in [find_end]'s expansion, 
   if the order is not correct, or even worse, only the wrong one [find_beg] in [find_end] get expanded 
   (when we forget to recursive apply), then some code non-dead [find_beg] will be marked as dead, 
   while it is still called 
*)
let subst name export_set stats  = 
  object (self)
    inherit Js_map.map as super
    method! statement st = 
      match st with 
      | {statement_desc =
           Variable 
             {value = _ ;
              ident_info = {used_stats = Dead_pure}
             } 
        ; comment = _}
        ->
        S.block []
      | {statement_desc = 
           Variable { ident_info = {used_stats = Dead_non_pure} ;
                      value = Some v  ; _ } 
        ; _}
        -> S.exp v
      | _ -> super#statement st 
    method! variable_declaration 
        ({ident; value ; property  ; ident_info }  as v)
      =  
      (* TODO: replacement is a bit shaky, the problem is the lambda we stored is
         not consistent after we did some subsititution, and the dead code removal
         does rely on this (otherwise, when you do beta-reduction you have to regenerate names)
      *)
      let v = super # variable_declaration v in
      Hashtbl.add stats ident v; (* see #278 before changes *)
      v
    method! block bs = 
      match bs with
      | ({statement_desc = 
            Variable ({value =
                         Some ({expression_desc = Fun _; _ } as v )
                      } as vd) ; comment = _} as st) :: rest  -> 
        let is_export = Ident_set.mem vd.ident export_set in
        if is_export then 
          self#statement st :: self#block rest 
        else 
          begin 
            match (Hashtbl.find stats vd.ident : J.variable_declaration) with
            | exception Not_found -> 
              if Js_analyzer.no_side_effect_expression v 
              then S.exp v  :: self#block rest 
              else self#block rest 

            | _ -> self#statement st  :: self#block rest 
          end

      | {statement_desc = 
           Return {return_value = 
                     {expression_desc = 
                        Call({expression_desc = Var (Id id)},args,_info)}} }
        as st 
           :: rest 
        -> 
        begin match Hashtbl.find stats id with 
          | exception Not_found 
            ->  self#statement st :: self#block rest 

          | { value = 
                Some {expression_desc = Fun (false, params, block, _env) ; comment = _}; 
              (*TODO: don't inline method tail call yet, 
                [this] semantics are weird 
              *)              
              property = (Alias | StrictOpt | Strict);
              ident_info = {used_stats = Once_pure };
              ident = _
            } as v
            when Ext_list.same_length params args 
            -> 
            (* Ext_log.dwarn  __LOC__ "%s is dead \n %s " id.name  *)
            (*   (Js_dump.string_of_block [st]); *)
            Js_op_util.update_used_stats v.ident_info Dead_pure;
            let block  = 
              List.fold_right2 (fun param arg acc ->  S.define ~kind:Variable param arg :: acc)
                params args  ( self#block block) (* see #278 before changes*)
                                
            in
            (* Mark a function as dead means it will never be scanned, 
               here we inline the function
            *)
            block @ self#block rest

          | _ ->
            self#statement st :: self#block rest
        end
      | x :: xs 
        ->
        self#statement x :: self#block xs
      | [] 
        -> 
        []

  end


let tailcall_inline (program : J.program) = 
  let _stats = get_stats program in
  let _export_set = program.export_set in
  program
  |> (subst program.name _export_set _stats )# program
  (* |> pass_beta #program *)
    

end
module Js_shake : sig 
#1 "js_shake.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** A module to shake JS IR
   
    Tree shaking is not going to change the closure 
 *)

val shake_program : J.program -> J.program

end = struct
#1 "js_shake.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** we also need make it complete 
 *)
let get_initial_exports 
    count_non_variable_declaration_statement 
    (export_set : Ident_set.t) (block : J.block ) = 
  let result = List.fold_left 
    (fun acc (st : J.statement) -> 
      match st.statement_desc with
      | Variable {ident ; value; _} ->
          if Ident_set.mem ident acc then 
            begin match value with
            | None -> acc  
            | Some x -> 
              (* If not a function, we have to calcuate again and again 
                  TODO: add hashtbl for a cache
               *)
                Ident_set.(
                union (Js_analyzer.free_variables_of_expression empty empty x) acc)
            end
          else 
            begin match value with
            | None -> acc 
            | Some x -> 
                if Js_analyzer.no_side_effect_expression x then acc 
                else 
                  Ident_set.(
                  union (Js_analyzer.free_variables_of_expression empty empty x) 
                    (add ident acc))
            end
      | _ -> 
          (* recalcuate again and again ... *)
          if Js_analyzer.no_side_effect_statement st || (not count_non_variable_declaration_statement)
          then acc
          else Ident_set.(union (Js_analyzer.free_variables_of_statement empty empty st) acc)
    ) export_set block  in result, Ident_set.(diff result export_set)

let shake_program (program : J.program) = 
  let debug_file = "pervasives.ml" in

  let _d () = 
    if Ext_string.ends_with program.name  debug_file then 
      Ext_log.err __LOC__ "@[%s@]@." program.name 
  in
  let shake_block block export_set = 
    let block = List.rev @@ Js_analyzer.rev_toplevel_flatten block in 
    let  loop block export_set : Ident_set.t = 
      let rec aux acc block = 
        let result, diff = get_initial_exports false acc block   in
        (* let _d ()  =  *)
        (*   if Ext_string.ends_with program.name  debug_file then  *)
        (*     begin *)
        (*       Ext_log.err "@[%a@]@." Ident_set.print result  ; *)
        (*     end *)
        (* in *)
        if Ident_set.is_empty diff then 
          result
        else 
          aux result block in
      let first_iteration, delta  = get_initial_exports true export_set block  in
      (* let _d ()  =  *)
      (*   if Ext_string.ends_with program.name  debug_file then  *)
      (*   begin   *)
      (*     Ext_log.err "@[<v>%a@ %a@]@." *)
      (*       Ident_set.print first_iteration   *)
      (*       Ident_set.print delta (\* TODO: optimization, don't add persistent variables *\) *)
      (*       ; *)
      (*     Ext_log.err "init ---- @." *)
      (*   end *)
      (* in *)

      if not @@ Ident_set.is_empty delta then
        aux first_iteration block 
      else first_iteration in

    let really_set = loop block export_set in 
    List.fold_right
      (fun  (st : J.statement) acc -> 
        match st.statement_desc with
        | Variable {ident; value ; _} -> 
            if Ident_set.mem ident really_set  then st:: acc 
            else 
              begin match value with 
              | None -> acc 
              | Some x -> 
                  if Js_analyzer.no_side_effect_expression x then acc
                  else st::acc
              end
        | _ -> if Js_analyzer.no_side_effect_statement st then acc else st::acc
      ) block []
  in

  {program with block = shake_block program.block program.export_set}

end
module Js_arr : sig 
#1 "js_arr.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)







val set_array : J.expression -> J.expression -> J.expression -> J.expression

val ref_array : J.expression -> J.expression -> J.expression

end = struct
#1 "js_arr.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






module E = Js_exp_make
 
let set_array  e e0 e1 = 
  E.assign (E.access e e0)  e1

let ref_array  e e0 = 
  E.access  e  e0

end
module Js_ast_util : sig 
#1 "js_ast_util.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


(** Simple expression, 
    no computation involved so that  it is okay to be duplicated
*)
val is_simple_expression : J.expression -> bool 



val named_expression : 
  J.expression -> (J.statement * Ident.t) option

end = struct
#1 "js_ast_util.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






module E = Js_exp_make 

module S = Js_stmt_make  

let rec is_simple_expression (e : J.expression) = 
  match e.expression_desc with  
  | Var _ 
  | Bool _ 
  | Str _ 
  | Number _ -> true
  | Dot (e, _, _) -> is_simple_expression e 
  | _ -> false 

let rec named_expression (e : J.expression)
  :  (J.statement  * Ident.t) option = 
  if is_simple_expression e then 
    None 
  else 
    let obj = Ext_ident.create Literals.tmp in
    let obj_code = 
      S.define
        ~kind:Strict obj e in 

    Some (obj_code, obj)

end
module Js_of_lam_array : sig 
#1 "js_of_lam_array.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Utilities for creating Array of JS IR *)

val make_array : J.mutable_flag -> Lambda.array_kind -> J.expression list -> J.expression
(** create an array *)

val set_array : J.expression -> J.expression -> J.expression -> J.expression
(** Here we don't care about [array_kind],  
    In the future, we might used TypedArray for FloatArray
 *)

val ref_array :  J.expression -> J.expression -> J.expression

end = struct
#1 "js_of_lam_array.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(*
   construct array,
   set array,
   ref array,

   Also make sure, don't call any primitive array method, i.e [E.index] 

   We also need check primitive [caml_make_vect], i.e, 
   [Caml_primitive['caml_make_vect']] see if it's correct 

   [caml_make_vect]
   [caml_array_sub]
   [caml_array_append]
   [caml_array_concat]
   [caml_make_float_vect]
   [caml_array_blit]

   research: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays


 *)

module E  = Js_exp_make


(* Parrayref(u|s) *)
let make_array mt (kind : Lambda.array_kind) args = 
  match kind with 
  | Pgenarray
  | Paddrarray -> E.arr ~comment:"array" mt args 
  | Pintarray  -> E.arr ~comment:"int array" mt args 
  | Pfloatarray -> E.arr ~comment:"float array" mt args

let set_array  e e0 e1 = 
  E.assign (E.access e e0)  e1

let ref_array  e e0 = 
  E.access  e  e0

end
module Js_of_lam_record : sig 
#1 "js_of_lam_record.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






(** Utilities for compiling lambda record into JS IR *)

(* val make : J.mutable_flag -> (string * J.expression) list -> J.expression *)


val field : Lambda.field_dbg_info -> J.expression -> J.jsint ->J.expression

val copy : Js_exp_make.unary_op

end = struct
#1 "js_of_lam_record.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








module E = Js_exp_make 

let empty_record_info = Lambda.Blk_record [||] (* careful to share*)


(* TODO: add label to the comment *)
(* let make  mutable_flag (args : (string * J.expression) list) = *)
(*   E.make_block ~comment:"record"  *)
(*     E.zero_int_literal empty_record_info (List.map snd args) mutable_flag *)



let field field_info  e i =
  match field_info with 
  | Lambda.Fld_na -> 
    E.index e i 
  | Lambda.Fld_record s 
  | Lambda.Fld_module s 
    -> E.index ~comment:s e i

(**
   used in [Pduprecord]
   this is due to we encode record as an array, it is going to change
   if we have another encoding       
*)    
let copy  = E.array_copy


end
module Ext_hashtbl : sig 
#1 "ext_hashtbl.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)







val of_list : ('a * 'b) list -> ('a, 'b) Hashtbl.t

val of_list2 : 'a list -> 'b list -> ('a, 'b) Hashtbl.t

val add_list : ('a, 'b) Hashtbl.t -> ('a * 'b) list -> unit

val add_list2 :  ('a, 'b) Hashtbl.t -> 'a list -> 'b list -> unit

end = struct
#1 "ext_hashtbl.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






let of_list kvs = 
  let map = Hashtbl.create 51 in 
  List.iter (fun (k, v) -> Hashtbl.add map k v) kvs ; 
  map


let of_list2 ks vs = 
  let map = Hashtbl.create 51 in 
  List.iter2 (fun k v -> Hashtbl.add map k v) ks vs ; 
  map

let add_list map kvs =    
  List.iter (fun (k, v) ->   Hashtbl.add map  k v) kvs 

let add_list2 map ks vs = 
  List.iter2 (fun k v -> Hashtbl.add map k v) ks vs ; 

end
module Lam_beta_reduce_util : sig 
#1 "lam_beta_reduce_util.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)







val simple_beta_reduce : 
  Ident.t list -> Lam.t -> Lam.t list -> Lam.t option

end = struct
#1 "lam_beta_reduce_util.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






(* 
   Principle: since in ocaml, the apply order is not specified 
   rules:
   1. each argument it is only used once, (avoid eval duplication)
   2. it's actually used, if not (Lsequence)
   3. no nested  compuation, 
      other wise the evaluation order is tricky (make sure eval order is correct)
*)

type value = 
  { mutable used : bool ; 
    lambda  : Lam.t
  }
let param_hash : (Ident.t , value) Hashtbl.t = Hashtbl.create 20
let simple_beta_reduce params body args = 
  let module E = struct exception Not_simple_apply end in
  let rec find_param v  opt = 
    match Hashtbl.find param_hash v with 
    | exp ->  
      if exp.used then raise E.Not_simple_apply
      else exp.used <- true; exp.lambda
    | exception Not_found -> opt
  in  
  let rec aux acc (us : Lam.t list) = 
    match us with 
    | [] -> List.rev acc
    | (Lvar x as a ) :: rest 
      -> 
      aux  (find_param x a  :: acc) rest 
    | (Lconst  _  as u) :: rest 
      -> aux (u :: acc) rest 
    | _ :: _ -> raise E.Not_simple_apply 
  in 
  match (body : Lam.t) with 
  | Lprim { primitive ; args =  args' ; loc}  (* There is no lambda in primitive *)
    -> (* catch a special case of primitives *)
    (* Note in a very special case we can avoid any allocation
       {[
         when Ext_list.for_all2_no_exn
             (fun p a ->
                match (a : Lam.t) with
                | Lvar a -> Ident.same p a
                | _ -> false ) params args'
       ]}*)
    let () = 
      List.iter2 (fun p a -> Hashtbl.add param_hash p {lambda = a; used = false }) params args  
    in 
    begin match aux [] args' with 
    | args -> 
      let result = 
        Hashtbl.fold (fun _param {lambda; used} code -> 
            if not used then
              Lam.seq lambda code
            else code) param_hash (Lam.prim ~primitive ~args loc) in 
      Hashtbl.clear param_hash;
      Some result 
    | exception _ -> 
      Hashtbl.clear param_hash ;
      None
    end
  | Lapply { fn = Lvar fn_name as f ; args =  args';  loc; status}
    ->  
    let () = 
      List.iter2 (fun p a -> Hashtbl.add param_hash p {lambda = a; used = false }) params args  
    in 
    (*since we adde each param only once, 
      iff it is removed once, no exception, 
      if it is removed twice there will be exception.
      if it is never removed, we have it as rest keys 
    *)
    begin match aux [] args' with 
      | us -> 
        let f = find_param fn_name  f in
        let result = 
          Hashtbl.fold 
            (fun _param {lambda; used} code -> 
               if not used then 
                 Lam.seq lambda code
               else code )
            param_hash (Lam.apply  f us  loc status) in
        Hashtbl.clear param_hash;
        Some result 
      | exception _ -> 
        Hashtbl.clear param_hash; 
        None
    end
  | _ -> None

end
module Js_of_lam_module : sig 
#1 "js_of_lam_module.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






val make :
  ?comment:string ->
  J.expression list -> J.expression


end = struct
#1 "js_of_lam_module.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






module E = Js_exp_make 

let make ?comment (args : J.expression list) =
  E.make_block
    ?comment E.zero_int_literal
    (Blk_module None) args Immutable


end
module Lam_compile_global : sig 
#1 "lam_compile_global.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Compile ocaml external module call , e.g [List.length] to  JS IR *)

val get_exp : Lam_compile_env.key  -> J.expression



val query_lambda : Ident.t -> Env.t -> Lam.t

end = struct
#1 "lam_compile_global.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








module E = Js_exp_make  
module S = Js_stmt_make

open Js_output.Ops

(* TODO: used in functor inlining, so that it can not be an exception
   Make(S), S can not be an exception
 *)



let query_lambda id env = 
  Lam_compile_env.query_and_add_if_not_exist (Lam_module_ident.of_ml id) 
    (Has_env env)
    ~not_found:(fun id -> assert false)
    ~found:(fun {signature = sigs; _} 
             -> 
               Lam.prim
                 ~primitive:(Pmakeblock(0, Blk_module None, Immutable))  
                 ~args:(
                   List.mapi (fun i _ -> 
                       Lam.prim
                         ~primitive:(Pfield (i, Lambda.Fld_na)) 
                         ~args:[
                           Lam.prim 
                             ~primitive:(Pgetglobal id)
                             ~args:[] Location.none (* FIXME*)] Location.none)
                     sigs) Location.none (* FIXME*))


(* Given an module name and position, find its corresponding name  *)  
let get_exp (key : Lam_compile_env.key) : J.expression = 
  match key with 
   (id, env, expand) -> 
    Lam_compile_env.query_and_add_if_not_exist 
        (Lam_module_ident.of_ml id) 
        (Has_env env)
        ~not_found:(fun id -> assert false)
        ~found:(fun   {signature = sigs; _} -> 
            if expand 
            then 
              (** TODO: add module into taginfo*)
              let len = List.length sigs in (** TODO: could be optimized *) 
              Js_of_lam_module.make ~comment:id.name 
                (Ext_list.init len (fun i -> 
                     E.ml_var_dot id
                       (Type_util.get_name sigs i )))
                               

            else 
              E.ml_var id)

  


end
module Lam_beta_reduce : sig 
#1 "lam_beta_reduce.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Beta reduction of lambda IR *)


val beta_reduce : Ident.t list -> Lam.t -> Lam.t list -> Lam.t
(* Compile-time beta-reduction of functions immediately applied:
      Lapply(Lfunction(Curried, params, body), args, loc) ->
        let paramN = argN in ... let param1 = arg1 in body
      Lapply(Lfunction(Tupled, params, body), [Lprim(Pmakeblock(args))], loc) ->
        let paramN = argN in ... let param1 = arg1 in body
   Assumes |args| = |params|.
*)

(*
   Refresh all the identifiers, 
   otherwise the identifier property can not be preserved, 
   the obvious example is parameter
 *)

val propogate_beta_reduce : 
  Lam_stats.meta -> 
  Ident.t list -> 
  Lam.t -> 
  Lam.t list -> 
  Lam.t


val refresh : 
  Lam.t -> 
  Lam.t 

(** 
   {[ Lam_beta_reduce.propogate_beta_reduce_with_map 
       meta param_map
       params body args]}

   [param_map] collect the usage of parameters, it's readonly
   it can be  produced by 

   {[!Lam_analysis.free_variables meta.export_idents 
       (Lam_analysis.param_map_of_list params) body]}

   TODO:
   replace [propogate_beta_reduce] with such implementation 
   {[
     let propogate_beta_reduce meta params body args = 
       let (_, param_map) = 
         Lam_analysis.is_closed_with_map Ident_set.empty params body in 
       propogate_beta_reduce_with_map meta param_map params body args  
   ]}
*)
val propogate_beta_reduce_with_map : 
  Lam_stats.meta ->
  Lam_analysis.stats Ident_map.t ->
  Ident.t list ->
  Lam.t -> Lam.t list -> Lam.t

end = struct
#1 "lam_beta_reduce.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(*
   Given an [map], rewrite all let bound variables into new variables, 
   note that the [map] is changed
   example    
   {[
     let a/112 = 3 in a/112      
   ]}
   would be converted into 
   {[
     let a/113 = 3 in a/113     
   ]}   

   ATTENTION: [let] bound idents have to be renamed, 
   Note we rely on an invariant that parameter could not be rebound 
 *)

(* 
  Small function inline heuristics:
  Even if a function is small, it does not mean it is good for inlining,
  for example, in list.ml
   {[
     let rec length_aux len = function
         [] -> len
       | a::l -> length_aux (len + 1) l

     let length l = length_aux 0 l
   ]}   
   if we inline [length], it will expose [length_aux] to the user, first, it make 
   the code not very friendly, also since [length_aux] is used everywhere now, it 
   may affect that we will not do the inlining of [length_aux] in [length]

   Criteior for sure to inline   
   1. small size, does not introduce extra symbols, non-exported and non-recursive   
      non-recursive is required if we re-apply the strategy

   Other Factors:   
   2. number of invoked times
   3. arguments are const or not   
*)
let rewrite (map :   (Ident.t, _) Hashtbl.t) 
    (lam : Lam.t) : Lam.t = 

  let rebind i = 
    let i' = Ident.rename i in 
    Hashtbl.add map i (Lam.var i');
    i' in
  (* order matters, especially for let bindings *)
  let rec 
    option_map op = 
    match op with 
    | None -> None 
    | Some x -> Some (aux x)
  and aux (lam : Lam.t) : Lam.t = 
    match lam with 
    | Lvar v -> 
      begin 
        try (* Lvar *) (Hashtbl.find map v) 
        with Not_found -> lam 
      end
    | Llet(str, v, l1, l2) ->
      let v = rebind v in
      let l1 = aux l1 in      
      let l2 = aux l2 in
      Lam.let_ str v  l1  l2 
    | Lletrec(bindings, body) ->
      (*order matters see GPR #405*)
      let vars = List.map (fun (k, _) -> rebind k) bindings in 
      let bindings = List.map2 (fun var (_,l) -> var, aux l) vars bindings in 
      let body = aux body in       
      Lam.letrec bindings body
    | Lfunction{arity; kind; params; body} -> 
      let params =  List.map rebind params in
      let body = aux body in      
      Lam.function_ ~arity ~kind ~params ~body
    | Lstaticcatch(l1, (i,xs), l2) -> 
      let l1 = aux l1 in
      let xs = List.map rebind xs in
      let l2 = aux l2 in
      Lam.staticcatch l1 (i,xs) l2
    | Lfor(ident, l1, l2, dir, l3) ->
      let ident = rebind ident in 
      let l1 = aux l1 in
      let l2 = aux l2 in
      let l3 = aux l3 in
      Lam.for_ ident (aux  l1)  l2 dir  l3
    | Lconst _ -> lam
    | Lprim {primitive; args ; loc} ->
      (* here it makes sure that global vars are not rebound *)      
      Lam.prim ~primitive ~args:(List.map aux  args) loc
    | Lapply {fn;  args; loc;  status } ->
      let fn = aux fn in       
      let args = List.map aux  args in 
      Lam.apply fn  args loc status
    | Lswitch(l, {sw_failaction; 
                  sw_consts; 
                  sw_blocks;
                  sw_numblocks;
                  sw_numconsts;
                 }) ->
      let l = aux l in
      Lam.switch l
              {sw_consts = 
                 List.map (fun (v, l) -> v, aux  l) sw_consts;
               sw_blocks = List.map (fun (v, l) -> v, aux  l) sw_blocks;
               sw_numconsts = sw_numconsts;
               sw_numblocks = sw_numblocks;
               sw_failaction =  option_map sw_failaction
              }
    | Lstringswitch(l, sw, d) ->
      let l = aux  l in
      Lam.stringswitch l 
                     (List.map (fun (i, l) -> i,aux  l) sw)
                     (option_map d)
    | Lstaticraise (i,ls) 
      -> Lam.staticraise i (List.map aux  ls)
    | Ltrywith(l1, v, l2) -> 
      let l1 = aux l1 in
      let v = rebind v in
      let l2 = aux l2 in
      Lam.try_ l1 v l2
    | Lifthenelse(l1, l2, l3) -> 
      let l1 = aux l1 in
      let l2 = aux l2 in
      let l3 = aux l3 in
      Lam.if_ l1  l2   l3
    | Lsequence(l1, l2) -> 
      let l1 = aux l1 in
      let l2 = aux l2 in
      Lam.seq l1 l2
    | Lwhile(l1, l2) -> 
      let l1 = aux l1 in
      let l2 = aux l2 in
      Lam.while_  l1  l2
    | Lassign(v, l) 
      -> Lam.assign v (aux  l)
    | Lsend(u, m, o, ll, v) ->
      let m = aux m in 
      let o = aux o in 
      let ll = List.map aux ll in
      Lam.send u  m  o  ll v
    | Lifused(v, l) -> 
      let l = aux l in 
      Lam.ifused v  l
  in 
  aux lam


let refresh lam = rewrite (Hashtbl.create 17 ) lam




(* 
    A naive beta reduce would break the invariants of the optmization.


    The sane but slowest  way:
      when we do a beta reduction, we need rename all variables inlcuding 
      let-bound ones

    A conservative one:
      - for internal one 
        rename params and let bound variables
      - for external one (seriaized)
        if it's enclosed environment should be good enough
        so far, we only inline enclosed lambdas
    TODO: rename 

   Optimizations:   
   {[
     (fun x y -> ...     ) 100 3 
   ]}   
   we can bound [x] to [100] in a single step     
 *)
let propogate_beta_reduce 
    (meta : Lam_stats.meta) params body args =
  match Lam_beta_reduce_util.simple_beta_reduce params body  args with 
  | Some x -> x 
  | None -> 
  let rest_bindings, rev_new_params  = 
    List.fold_left2 
      (fun (rest_bindings, acc) old_param (arg : Lam.t) -> 
         match arg with          
         | Lconst _
         | Lvar _  -> rest_bindings , arg :: acc 
         | _ -> 
           let p = Ident.rename old_param in 
           (p,arg) :: rest_bindings , (Lam.var p) :: acc 
      )  ([],[]) params args in
  let new_body = rewrite (Ext_hashtbl.of_list2 (List.rev params) (rev_new_params)) body in
  List.fold_right
    (fun (param, (arg : Lam.t)) l -> 
       let arg = 
         match arg with 
         | Lvar v -> 
           begin 
             match Hashtbl.find meta.ident_tbl v with 
             | exception Not_found -> ()
             | ident_info -> 
               Hashtbl.add meta.ident_tbl param ident_info 
           end;
           arg 
         | Lprim {primitive = Pgetglobal ident;  args = [];  _} -> 
           (* It's not completeness, its to make it sound.. 
              Pass global module as an argument
           *)
           Lam_compile_global.query_lambda ident meta.env 
         (* alias meta param ident (Module (Global ident)) Strict *)
         | Lprim {primitive = Pmakeblock (_, _, Immutable) ;args ; _} -> 
           Hashtbl.replace meta.ident_tbl param 
             (Lam_util.kind_of_lambda_block Normal args ); (** *)
           arg
         | _ -> arg in
       Lam_util.refine_let param arg l) 
     rest_bindings new_body

let propogate_beta_reduce_with_map  
    (meta : Lam_stats.meta) (map : Lam_analysis.stats Ident_map.t ) params body args =
  match Lam_beta_reduce_util.simple_beta_reduce params body args with
  | Some x -> x
  | None ->
  let rest_bindings, rev_new_params  = 
    List.fold_left2 
      (fun (rest_bindings, acc) old_param (arg : Lam.t) -> 
         match arg with          
         | Lconst _
         | Lvar _  -> rest_bindings , arg :: acc 
         | Lprim {primitive = Pgetglobal ident; args = []}
           (* TODO: we can pass Global, but you also need keep track of it*)
           ->
           let p = Ident.rename old_param in 
           (p,arg) :: rest_bindings , (Lam.var p) :: acc 

         | _ -> 
           if  Lam_analysis.no_side_effects arg then
             begin match Ident_map.find old_param map with 
               | exception Not_found -> assert false 
               | {top = true ; times = 0 }
               | {top = true ; times = 1 } 
                 -> 
                 rest_bindings, arg :: acc                
               | _  ->  
                 let p = Ident.rename old_param in 
                 (p,arg) :: rest_bindings , (Lam.var p) :: acc 
             end
           else
             let p = Ident.rename old_param in 
             (p,arg) :: rest_bindings , (Lam.var p) :: acc 
      )  ([],[]) params args in
  let new_body = rewrite (Ext_hashtbl.of_list2 (List.rev params) (rev_new_params)) body in
  List.fold_right
    (fun (param, (arg : Lam.t)) l -> 
       let arg = 
         match arg with 
         | Lvar v -> 
           begin 
             match Hashtbl.find meta.ident_tbl v with 
             | exception Not_found -> ()
             | ident_info -> 
               Hashtbl.add meta.ident_tbl param ident_info 
           end;
           arg 
         | Lprim {primitive = Pgetglobal ident; args =  []} -> 
           (* It's not completeness, its to make it sound.. *)
           Lam_compile_global.query_lambda ident meta.env 
         (* alias meta param ident (Module (Global ident)) Strict *)
         | Lprim {primitive = Pmakeblock (_, _, Immutable ) ; args} -> 
           Hashtbl.replace meta.ident_tbl param 
             (Lam_util.kind_of_lambda_block Normal args ); (** *)
           arg
         | _ -> arg in
       Lam_util.refine_let param arg l) 
     rest_bindings new_body



let beta_reduce params body args =
  match Lam_beta_reduce_util.simple_beta_reduce params body args with 
  | Some x -> x 
  | None -> 
    List.fold_left2 
      (fun l param arg ->
         Lam_util.refine_let param arg l)
      body params args

end
module Js_long : sig 
#1 "js_long.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






type int64_call = J.expression list -> J.expression  

val make_const : lo:Int32.t -> hi:Int32.t -> J.expression

val of_const : int64 -> J.expression

val to_int32 : int64_call

val of_int32 : int64_call
val comp : Lambda.comparison -> int64_call
val neg : int64_call
val add : int64_call
val sub : int64_call
val mul : int64_call
val div : int64_call
val xor : int64_call
val mod_ : int64_call
val lsl_ : int64_call
val lsr_ : int64_call
val asr_ : int64_call
val and_ : int64_call
val or_ : int64_call
val swap : int64_call
val discard_sign : int64_call
val div_mod : int64_call
val to_hex : int64_call  
val to_float : int64_call
val of_float : int64_call
val compare : int64_call
val of_string : int64_call
val float_of_bits : int64_call
val bits_of_float : int64_call  
val get64 : int64_call

end = struct
#1 "js_long.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






module E = Js_exp_make
type int64_call = J.expression list -> J.expression  

let int64_call (fn : string) args  = 
  E.runtime_call Js_config.int64 fn args 


(* TODO: make layout easier to change later *)
let record_info = Lambda.Blk_record [| "hi"; "lo"|]
let make_const ~lo ~hi = 
   E.make_block 
     ~comment:"int64" (E.zero_int_literal) 
     record_info
     [E.int hi; E.to_uint32 @@ E.int lo ; ]
     (* If we use unsigned int for lo field, 
        then we can not use [E.int] which is 
        assumed to to be signed int.
        Or we can use [Int64] to encode 
        in the ast node?
     *)
     Immutable
let make ~lo ~hi = 
   E.make_block 
     ~comment:"int64" (E.zero_int_literal) 
     record_info [   hi; E.to_uint32 lo ]
     Immutable
let get_lo x = E.index x 1l
let get_hi x = E.index x 0l


(* below should  not depend on layout *)


let of_const (v : Int64.t) = 
  make_const
    ~lo:(Int64.to_int32 v )
    ~hi:(Int64.to_int32 (Int64.shift_right v 32))

let to_int32 args = 
  begin match args with
  | [v] ->  E.to_int32 @@ get_lo v
  | _ -> assert false
  end

let of_int32 (args : J.expression list) = 
  match args with 
  | [{expression_desc = Number (Int {i}) ; _}] 
    -> 
    if i < 0l then make_const ~lo:i ~hi:(-1l)
    else make_const ~lo:i ~hi:0l
  | _ -> int64_call  "of_int32" args

let comp (cmp : Lambda.comparison) args = 
  E.runtime_call  Js_config.int64
    (match cmp with 
     | Ceq -> "eq"
     | Cneq -> "neq"
     | Clt -> "lt"
     | Cgt -> "gt"
     | Cle -> "le"
     | Cge -> "ge") args 

let neg args = 
  int64_call "neg" args

let add args = 
  int64_call "add" args 

let sub args = 
  int64_call "sub" args

let mul args =  
  int64_call "mul" args

let div args =
  int64_call "div" args

let bit_op  op args = 
  match args  with 
  | [l;r] -> 
    make ~lo:(op (get_lo l) (get_lo r))
      ~hi:(op (get_hi l) (get_hi r))
  | _ -> assert false

let xor  = bit_op E.int32_bxor 
let or_ = bit_op E.int32_bor
let and_ = bit_op E.int32_band


let lsl_ args = 
  int64_call "lsl_" args

let lsr_ args = 
  int64_call "lsr_" args

let asr_ args = 
  int64_call "asr_" args

let mod_ args = 
  int64_call "mod_" args


let swap args = 
  int64_call "swap" args

(* Safe constant propgation 
   {[
     Number.MAX_SAFE_INTEGER:
       Math.pow(2,53) - 1
   ]}
   {[
     Number.MIN_SAFE_INTEGER:
       - (Math.pow(2,53) -1)
   ]}
   Note that [Number._SAFE_INTEGER] is in ES6, 
   we can hard code this number without bringing browser issue.
*)
let of_float (args : J.expression list ) = 
  int64_call "of_float" args

let compare (args : J.expression list) = 
  int64_call "compare" args 

let of_string (args : J.expression list) = 
  int64_call "of_string" args 
let discard_sign (args : J.expression list) =
  int64_call "discard_sign" args
let div_mod (args : J.expression list) =
  int64_call "div_mod" args
let to_hex (args : J.expression list) =
  int64_call "to_hex"  args
let get64 = int64_call "get64"
let float_of_bits  =  int64_call "float_of_bits" 
let bits_of_float = int64_call "bits_of_float"
let to_float (args : J.expression list ) = 
  match args with
  (* | [ {expression_desc  *)
  (*      = Caml_block (  *)
  (*          [lo =  *)
  (*           {expression_desc = Number (Int {i = lo; _}) }; *)
  (*           hi =  *)
  (*           {expression_desc = Number (Int {i = hi; _}) }; *)
  (*          ], _, _, _); _ }]  *)
  (*   ->  *)
    
  | [ _ ] -> 
      int64_call "to_float" args
  | _ -> 
    assert false    

end
module Js_of_lam_block : sig 
#1 "js_of_lam_block.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Utilities for creating block of lambda expression in JS IR *)

val make_block : 
  Js_op.mutable_flag -> Lambda.tag_info ->
  J.expression -> J.expression list -> J.expression

val field : Lambda.field_dbg_info -> J.expression -> J.jsint -> J.expression

val set_field : 
  Lambda.set_field_dbg_info -> 
  J.expression -> J.jsint -> J.expression -> J.expression


end = struct
#1 "js_of_lam_block.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








module E = Js_exp_make

(* TODO: it would be even better, if the [tag_info] contains more information
   about immutablility
 *)
let make_block mutable_flag (tag_info : Lambda.tag_info) tag args  = 

  match mutable_flag, tag_info with
  | _, Blk_array -> Js_of_lam_array.make_array mutable_flag  Pgenarray args
  | _ , _ -> E.make_block tag tag_info args mutable_flag
  (* | _, (  Tuple | Variant _ ) -> (\** TODO: check with inline record *\) *)
  (*     E.arr Immutable *)
  (*       (E.small_int  ?comment:(Lam_compile_util.comment_of_tag_info tag_info) tag   *)
  (*        :: args) *)
  (* | _, _  ->  *)
  (*     E.arr mutable_flag *)
  (*       (E.int  ?comment:(Lam_compile_util.comment_of_tag_info tag_info) tag   *)
  (*        :: args) *)

let field field_info e i =
  match field_info with 
  | Lambda.Fld_na -> 
    E.index e i 
  | Lambda.Fld_record s 
  | Lambda.Fld_module s 
    -> E.index ~comment:s e i



let set_field field_info e i e0 =
  let comment = 
    match field_info with 
    | Lambda.Fld_set_na 
      -> None
    | Fld_record_set s -> Some (s)
  in (* see GPR#631*)
  E.index_addr ?comment e i  ~no:e0 ~yes:(fun v -> E.assign v e0)






end
module Js_of_lam_string : sig 
#1 "js_of_lam_string.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Utilities to wrap [string] and [bytes] compilation, 

   this is isolated, so that we can swap different representation in the future.
   [string] is Immutable, so there is not [set_string] method
*)

val ref_string : J.expression -> J.expression -> J.expression

val ref_byte : J.expression -> J.expression -> J.expression

val set_byte : J.expression -> J.expression -> J.expression -> J.expression 

val caml_char_of_int : ?comment:string -> J.expression -> J.expression

val caml_char_to_int : ?comment:string -> J.expression -> J.expression

val const_char : char -> J.expression

val bytes_to_string : J.expression -> J.expression

val bytes_of_string : J.expression -> J.expression

end = struct
#1 "js_of_lam_string.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)









module E = Js_exp_make

module A = struct 

  let const_char (i : char) = 
    E.str (String.make 1 i)

  let caml_char_of_int ?comment (v : J.expression)  =  
    E.char_of_int ?comment v

  let caml_char_to_int ?comment v =  
    E.char_to_int ?comment v

  (* string [s[i]] expects to return a [ocaml_char] *)
  let ref_string e e1 = 
    E.string_access e e1

  (* [s[i]] excepts to return a [ocaml_char]
     We use normal array for [bytes]
     TODO: we can use [Buffer] in the future 
   *)
  let ref_byte e e0  =
    E.char_of_int (E.access  e  e0)

  (* {Bytes.set : bytes -> int -> char -> unit }*)
  let set_byte  e e0 e1 = 
    E.assign (E.access e e0)  (E.char_to_int e1)

(*
   Note that [String.fromCharCode] also works, but it only 
   work for small arrays, however, for {bytes_to_string} it is likely the bytes 
   will become big
   {[
   String.fromCharCode.apply(null,[87,97])
   "Wa"
   String.fromCharCode(87,97)
   "Wa" 
   ]}
   This does not work for large arrays
   {[
   String.fromCharCode.apply(null, prim = Array[1048576]) 
   Maxiume call stack size exceeded
   ]}
 *)

  let bytes_to_string e = 
    E.runtime_call Js_config.string "bytes_to_string" [e]

  let bytes_of_string s =
    E.runtime_call Js_config.string "bytes_of_string" [s]
end

(* We use module B for string compilation, once the upstream can make changes to the 
    patten match of range patterns, we can use module [A] which means [char] is [string] in js, 
    currently, it follows the same patten of ocaml, [char] is [int]
 *)

module B = struct 

  let const_char (i : char) = 
    E.int  ~comment:("\"" ^ Ext_string.escaped (String.make 1 i) ^ "\"") 
      ~c:i (Int32.of_int @@ Char.code i)

  let caml_char_of_int ?comment (v : J.expression)  =  v

  let caml_char_to_int ?comment v =  v

  (* string [s[i]] expects to return a [ocaml_char] *)
  let ref_string e e1 = 
    E.char_to_int (E.string_access e e1)

  (* [s[i]] excepts to return a [ocaml_char]
     We use normal array for [bytes]
     TODO: we can use [Buffer] in the future 
   *)
  let ref_byte e e0  = E.access  e  e0

  (* {Bytes.set : bytes -> int -> char -> unit }*)
  let set_byte  e e0 e1 = 
    E.assign (E.access e e0)  e1

(**
   Note that [String.fromCharCode] also works, but it only 
   work for small arrays, however, for {bytes_to_string} it is likely the bytes 
   will become big
   {[
   String.fromCharCode.apply(null,[87,97])
   "Wa"
   String.fromCharCode(87,97)
   "Wa" 
   ]}
   This does not work for large arrays
   {[
   String.fromCharCode.apply(null, prim = Array[1048576]) 
   Maxiume call stack size exceeded
   ]}
 *)

  let bytes_to_string e = 
    E.runtime_call Js_config.string "bytes_to_string" [e]

  let bytes_of_string s =
    E.runtime_call Js_config.string "bytes_of_string" [s]
end

(* include A *)
include B

end
module Lam_compile_const : sig 
#1 "lam_compile_const.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Compile lambda constant to JS *)

val translate : Lambda.structured_constant -> J.expression

end = struct
#1 "lam_compile_const.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








module E = Js_exp_make

let rec translate (x : Lambda.structured_constant ) : J.expression = 
  match x with 
  | Const_base c -> 
    begin match c with 
      | Const_int i -> E.int (Int32.of_int i)
      | Const_char i ->
        Js_of_lam_string.const_char i
      | Const_int32 i -> E.int i 
          (* E.float (Int32.to_string i) *)
      | Const_int64 i -> 
          (*
            TODO:
            {[
            Int64.to_string 0x7FFFFFFFFFFFFFFFL;;
            - : string = "9223372036854775807"
            ]}
            {[
            Int64.(to_float max_int);;
            - : float = 9.22337203685477581e+18
            ]}
            Note we should compile it to Int64 as JS's 
            speical representation -- 
            it is not representatble in JS number
           *)
          (* E.float (Int64.to_string i) *)
        Js_long.of_const i
        (* https://github.com/google/closure-library/blob/master/closure%2Fgoog%2Fmath%2Flong.js *)
      | Const_nativeint i -> E.nint i 
      | Const_float f -> E.float f (* TODO: preserve float *)
      | Const_string (i,_) (*TODO: here inline js*) -> 
        E.str i
    end

  | Const_pointer (c,pointer_info) -> 
    E.int ?comment:(Lam_compile_util.comment_of_pointer_info pointer_info)
      (Int32.of_int c )

  | Const_block(tag, tag_info, xs ) -> 
    Js_of_lam_block.make_block NA tag_info 
      (E.small_int  tag) (List.map translate xs)

  | Const_float_array ars -> 
    (* according to the compiler 
        const_float_array is immutable 
       {[ Lprim(Pccall prim_obj_dup, [master]) ]},
        however, we can not translate 
       {[ prim_obj_dup(x) =>  x' ]}
        since x' is now mutable, prim_obj_dup does a copy,

        the compiler does this  is mainly to extract common data into data section, 
        we  deoptimized this in js backend? so it is actually mutable 
    *)
    (* TODO-- *)
    Js_of_lam_array.make_array Mutable Pfloatarray 
      (List.map (fun x ->  E.float  x ) ars)
    (* E.arr Mutable ~comment:"float array" *)
    (*   (List.map (fun x ->  E.float  x ) ars) *)

  | Const_immstring s ->  (*TODO *)
    E.str s  (* TODO: check *)

end
module Js_of_lam_exception : sig 
#1 "js_of_lam_exception.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






  
val get_builtin_by_name : string -> J.expression



val caml_set_oo_id : J.expression list -> J.expression

end = struct
#1 "js_of_lam_exception.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






(** An pattern match on {!caml_set_oo_id args}
    Note that in the trunk, it is immutable by default now 
 *)
module E = Js_exp_make 

let match_exception_def (args : J.expression list) = 
  match args with   
  | [{ expression_desc  = 
               Caml_block (
                 [ exception_str; 
                   {expression_desc = J.Number (Int { i = 0l; _}); _}
                 ],
                 mutable_flag, 
                 {expression_desc = J.Number (Int {i = object_tag; _}); _}, _ );
              _} ] -> 
    if object_tag = 248l (* Obj.object_tag *) then
      Some ( exception_str, mutable_flag)    
    else
      None
  | _ -> None

(* Sync up with [caml_set_oo_id] 
   Note if we inline {!Caml_exceptions.create}, 
   it seems can be useful for optimizations in theory, 
   in practice, it never happen, since the pattern match 
   never dig into it internally, so maybe {!Obj.set_tag} 
   is not necessary at all
*)
let make_exception exception_str mutable_flag : J.expression = 
  E.runtime_call Js_config.exceptions Literals.create [exception_str]




let get_builtin_by_name name = 
  E.runtime_ref Js_config.builtin_exceptions (String.lowercase name)

let caml_set_oo_id args = 
    begin match match_exception_def args with 
    | Some ( exception_str, mutable_flag)
      -> 
      make_exception exception_str mutable_flag      
    | _ ->
      (**
         If we can guarantee this code path is never hit, we can do 
         a better job for encoding of exception and extension?
      *)
      E.runtime_call Js_config.exceptions "caml_set_oo_id" args 
    end

end
module Js_of_lam_float_record : sig 
#1 "js_of_lam_float_record.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






(** Compile a special representation in OCaml when all fields are of type [float] 
    check the invariant in {!Js_of_lam_array.make_array}
*)

val set_double_field : 
  Lambda.set_field_dbg_info -> 
  J.expression -> J.jsint -> 
  J.expression -> J.expression

val get_double_feild : 
  Lambda.field_dbg_info -> 
  J.expression -> J.jsint -> J.expression

end = struct
#1 "js_of_lam_float_record.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






module E = Js_exp_make 

let get_double_feild field_info e i = 
  match field_info with 
  | Lambda.Fld_na -> 
    E.index e i 
  | Lambda.Fld_record s 
  | Lambda.Fld_module s 
    -> E.index ~comment:s e i


let set_double_field field_info e  i e0 = 
  let v = 
    match field_info with 
    | Lambda.Fld_set_na 
      -> 
      E.index e i 
    | Fld_record_set s -> 
      E.index ~comment:s e i in 
  E.assign v  e0


end
module Ast_literal : sig 
#1 "ast_literal.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


type 'a  lit = ?loc: Location.t -> unit -> 'a
module Lid : sig
  type t = Longident.t 
  val val_unit : t 
  val type_unit : t 
  val js_fn : t 
  val js_meth : t 
  val js_meth_callback : t 
  val js_obj : t 

  val ignore_id : t 
  val js_null : t 
  val js_undefined : t
  val js_null_undefined : t 
  val js_re_id : t 
  val js_unsafe : t 
end

type expression_lit = Parsetree.expression lit 
type core_type_lit = Parsetree.core_type lit 
type pattern_lit = Parsetree.pattern lit 

val val_unit : expression_lit

val type_unit : core_type_lit

val type_string : core_type_lit

val type_any : core_type_lit

val pat_unit : pattern_lit

end = struct
#1 "ast_literal.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

open Ast_helper


module Lid = struct 
  type t = Longident.t 
  let val_unit : t = Lident "()"
  let type_unit : t = Lident "unit"
  let type_string : t = Lident "string"
  (* TODO should be renamed in to {!Js.fn} *)
  (* TODO should be moved into {!Js.t} Later *)
  let js_fn = Longident.Ldot (Lident "Js", "fn")
  let js_meth = Longident.Ldot (Lident "Js", "meth")
  let js_meth_callback = Longident.Ldot (Lident "Js", "meth_callback")
  let js_obj = Longident.Ldot (Lident "Js", "t") 
  let ignore_id = Longident.Ldot (Lident "Pervasives", "ignore")
  let js_null  = Longident.Ldot (Lident "Js", "null")
  let js_undefined = Longident.Ldot (Lident "Js", "undefined")
  let js_null_undefined = Longident.Ldot (Lident "Js", "null_undefined")
  let js_re_id = Longident.Ldot (Lident "Js_re", "t")
  let js_unsafe = Longident.Lident "Js_unsafe"
end

module No_loc = struct 
  let loc = Location.none
  let val_unit = 
    Ast_helper.Exp.construct {txt = Lid.val_unit; loc }  None
  let type_unit =   
    Ast_helper.Typ.mk  (Ptyp_constr ({ txt = Lid.type_unit; loc}, []))

  let type_string =   
    Ast_helper.Typ.mk  (Ptyp_constr ({ txt = Lid.type_string; loc}, []))

  let type_any = Ast_helper.Typ.any ()
  let pat_unit = Pat.construct {txt = Lid.val_unit; loc} None
end 

type 'a  lit = ?loc: Location.t -> unit -> 'a
type expression_lit = Parsetree.expression lit 
type core_type_lit = Parsetree.core_type lit 
type pattern_lit = Parsetree.pattern lit 

let val_unit ?loc () = 
  match loc with 
  | None -> No_loc.val_unit
  | Some loc -> Ast_helper.Exp.construct {txt = Lid.val_unit; loc}  None


let type_unit ?loc () = 
  match loc with
  | None ->     
    No_loc.type_unit
  | Some loc -> 
    Ast_helper.Typ.mk ~loc  (Ptyp_constr ({ txt = Lid.type_unit; loc}, []))


let type_string ?loc () = 
  match loc with 
  | None -> No_loc.type_string 
  | Some loc ->     
    Ast_helper.Typ.mk ~loc  (Ptyp_constr ({ txt = Lid.type_string; loc}, []))

let type_any ?loc () = 
  match loc with 
  | None -> No_loc.type_any
  | Some loc -> Ast_helper.Typ.any ~loc ()

let pat_unit ?loc () = 
  match loc with 
  | None -> No_loc.pat_unit
  | Some loc -> 
    Pat.construct ~loc {txt = Lid.val_unit; loc} None

end
module Ast_comb : sig 
#1 "ast_comb.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


val exp_apply_no_label : 
  ?loc:Location.t ->
  ?attrs:Parsetree.attributes ->
  Parsetree.expression -> Parsetree.expression list -> Parsetree.expression

val fun_no_label : 
  ?loc:Location.t ->
  ?attrs:Parsetree.attributes ->
  Parsetree.pattern -> Parsetree.expression -> Parsetree.expression

val arrow_no_label : 
  ?loc:Location.t ->
  ?attrs:Parsetree.attributes ->
  Parsetree.core_type -> Parsetree.core_type -> Parsetree.core_type

(* note we first declare its type is [unit], 
   then [ignore] it, [ignore] is necessary since 
   the js value  maybe not be of type [unit] and 
   we can use [unit] value (though very little chance) 
   sometimes
*)
val discard_exp_as_unit : 
  Location.t -> Parsetree.expression -> Parsetree.expression


val tuple_type_pair : 
  ?loc:Ast_helper.loc ->
  [< `Make | `Run ] ->
  int -> Parsetree.core_type * Parsetree.core_type list * Parsetree.core_type

val to_js_type :
  Location.t -> Parsetree.core_type -> Parsetree.core_type


(** TODO: make it work for browser too *)
val to_undefined_type :
  Location.t -> Parsetree.core_type -> Parsetree.core_type  

val to_js_re_type : Location.t -> Parsetree.core_type

end = struct
#1 "ast_comb.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


open Ast_helper 

let exp_apply_no_label ?loc ?attrs a b = 
  Exp.apply ?loc ?attrs a (List.map (fun x -> "", x) b)

let fun_no_label ?loc ?attrs  pat body = 
  Exp.fun_ ?loc ?attrs "" None pat body

let arrow_no_label ?loc ?attrs b c = 
  Typ.arrow ?loc ?attrs "" b c 

let discard_exp_as_unit loc e = 
  exp_apply_no_label ~loc     
    (Exp.ident ~loc {txt = Ast_literal.Lid.ignore_id; loc})
    [Exp.constraint_ ~loc e 
       (Ast_literal.type_unit ~loc ())]


let tuple_type_pair ?loc kind arity = 
  let prefix  = "a" in
  if arity = 0 then 
    let ty = Typ.var ?loc ( prefix ^ "0") in 
    match kind with 
    | `Run -> ty,  [], ty 
    | `Make -> 
      (Typ.arrow "" ?loc
         (Ast_literal.type_unit ?loc ())
         ty ,
       [], ty)
  else
    let number = arity + 1 in
    let tys = Ext_list.init number (fun i -> 
        Typ.var ?loc (prefix ^ string_of_int (number - i - 1))
      )  in
    match tys with 
    | result :: rest -> 
      Ext_list.reduce_from_left (fun r arg -> Typ.arrow "" ?loc arg r) tys, 
      List.rev rest , result
    | [] -> assert false
    
    

let js_obj_type_id  = 
  Ast_literal.Lid.js_obj 

let re_id  = 
  Ast_literal.Lid.js_re_id 

let to_js_type loc  x  = 
  Typ.constr ~loc {txt = js_obj_type_id; loc} [x]

let to_js_re_type loc  =
  Typ.constr ~loc { txt = re_id ; loc} []
    
let to_undefined_type loc x =
  Typ.constr ~loc
    {txt = Ast_literal.Lid.js_undefined ; loc}
    [x]  


end
module Ast_core_type : sig 
#1 "ast_core_type.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type t = Parsetree.core_type 



val replace_result : t -> t -> t

val is_unit : t -> bool 
val is_array : t -> bool 
type arg_label =
  | Label of string 
  | Optional of string 
  | Empty
type arg_type = 
  | NullString of (int * string) list 
  | NonNullString of (int * string) list 
  | Int of (int * int ) list 
  | Array 
  | Unit
  | Nothing
  | Ignore

(** for 
       [x:t] -> "x"
       [?x:t] -> "?x"
*)
val label_name : string -> arg_label





(** return a function type 
    [from_labels ~loc tyvars labels]
    example output:
    {[x:'a0 -> y:'a1 -> < x :'a0 ;y :'a1  > Js.t]}
*)
val from_labels :
  loc:Location.t -> int ->  string Asttypes.loc list -> t

val make_obj :
  loc:Location.t ->
  (string * Parsetree.attributes * t) list ->
  t

end = struct
#1 "ast_core_type.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type t = Parsetree.core_type 
type arg_label =
  | Label of string 
  | Optional of string 
  | Empty (* it will be ignored , side effect will be recorded *)

type arg_type = 
  | NullString of (int * string) list 
  | NonNullString of (int * string) list 
  | Int of (int * int ) list 
  | Array 
  | Unit
  | Nothing
  | Ignore

open Ast_helper

let replace_result ty result = 
  let rec aux (ty : Parsetree.core_type) = 
    match ty with 
    | { ptyp_desc = 
          Ptyp_arrow (label,t1,t2)
      } -> { ty with ptyp_desc = Ptyp_arrow(label,t1, aux t2)}
    | {ptyp_desc = Ptyp_poly(fs,ty)} 
      ->  {ty with ptyp_desc = Ptyp_poly(fs, aux ty)}
    | _ -> result in 
  aux ty 

let is_unit (ty : t ) = 
  match ty.ptyp_desc with 
  | Ptyp_constr({txt =Lident "unit"}, []) -> true
  | _ -> false 

let is_array (ty : t) = 
  match ty.ptyp_desc with 
  | Ptyp_constr({txt =Lident "array"}, [_]) -> true
  | _ -> false 

let is_optional l =
  String.length l > 0 && l.[0] = '?'

let label_name l : arg_label =
  if l = "" then Empty else 
  if is_optional l 
  then Optional (String.sub l 1 (String.length l - 1))
  else Label l


(* Note that OCaml type checker will not allow arbitrary 
   name as type variables, for example:
   {[
     '_x'_
   ]}
   will be recognized as a invalid program
*)
let from_labels ~loc arity labels 
  : t =
  let tyvars = 
    ((Ext_list.init arity (fun i ->      
           Typ.var ~loc ("a" ^ string_of_int i)))) in
  let result_type =
    Ast_comb.to_js_type loc  
      (Typ.object_ ~loc
         (List.map2 (fun x y -> x.Asttypes.txt ,[], y) labels tyvars) Closed)
  in 
  List.fold_right2 
    (fun {Asttypes.loc ; txt = label }
      tyvar acc -> Typ.arrow ~loc label tyvar acc) labels tyvars  result_type


let make_obj ~loc xs =
  Ast_comb.to_js_type loc @@
  Ast_helper.Typ.object_  ~loc xs   Closed

end
module Ast_payload : sig 
#1 "ast_payload.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)



(** A utility module used when destructuring parsetree attributes, used for 
    compiling FFI attributes and built-in ppx  *)

type t = Parsetree.payload
type lid = string Asttypes.loc
type label_expr = lid  * Parsetree.expression
type action = 
   lid * Parsetree.expression option 

val is_single_string : t -> string option
val is_single_int : t -> int option 

val as_string_exp : t -> Parsetree.expression option
val as_core_type : Location.t -> t -> Parsetree.core_type    
val as_empty_structure :  t -> bool 
val as_ident : t -> Longident.t Asttypes.loc option
val raw_string_payload : Location.t -> string -> t 
val assert_strings :
  Location.t -> t -> string list  

(** as a record or empty 
    it will accept 
    {[ [@@@bs.config ]]}
    or 
    {[ [@@@bs.config { property  .. } ]]}    
    Note that we only 
    {[
      { flat_property}
    ]}
    below  is not allowed 
    {[
      {M.flat_property}
    ]}
*)
val as_config_record_and_process : 
  Location.t ->
  t -> action list 

val assert_bool_lit : Parsetree.expression -> bool

val empty : t 

val table_dispatch : 
  (Parsetree.expression option  -> 'a) String_map.t -> action -> 'a

end = struct
#1 "ast_payload.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type t = Parsetree.payload

let is_single_string (x : t ) = 
  match x with  (** TODO also need detect empty phrase case *)
  | PStr [ {
      pstr_desc =  
        Pstr_eval (
          {pexp_desc = 
             Pexp_constant 
               (Const_string (name,_));
           _},_);
      _}] -> Some name
  | _  -> None

let is_single_int (x : t ) = 
  match x with  (** TODO also need detect empty phrase case *)
  | PStr [ {
      pstr_desc =  
        Pstr_eval (
          {pexp_desc = 
             Pexp_constant 
               (Const_int name);
           _},_);
      _}] -> Some name
  | _  -> None

let as_string_exp (x : t ) = 
  match x with  (** TODO also need detect empty phrase case *)
  | PStr [ {
      pstr_desc =  
        Pstr_eval (
          {pexp_desc = 
             Pexp_constant 
               (Const_string (_,_));
           _} as e ,_);
      _}] -> Some e
  | _  -> None

let as_core_type loc x =
  match  x with
  | Parsetree.PTyp x -> x
  | _ -> Location.raise_errorf ~loc "except a core type"
           
let as_ident (x : t ) =
  match x with
  | PStr [
      {pstr_desc =
         Pstr_eval (
           {
             pexp_desc =
               Pexp_ident ident 
                 
           } , _)
      }
    ] -> Some ident
  | _ -> None
open Ast_helper

let raw_string_payload loc (s : string) : t =
  PStr [ Str.eval ~loc (Exp.constant ~loc (Const_string (s,None)  ))]
    
let as_empty_structure (x : t ) = 
  match x with 
  | PStr ([]) -> true
  | PTyp _ | PPat _ | PStr (_ :: _ ) -> false 

type lid = string Asttypes.loc
type label_expr = lid  * Parsetree.expression

type action = 
   lid * Parsetree.expression option 
(** None means punning is hit 
    {[ { x } ]}
    otherwise it comes with a payload 
    {[ { x = exp }]}
*)

let as_config_record_and_process 
    loc
    (x : Parsetree.payload) 
  = 
  match  x with 
  | PStr 
      [ {pstr_desc = Pstr_eval
             ({pexp_desc = Pexp_record (label_exprs, with_obj) ; pexp_loc = loc}, _); 
         _
        }]
    -> 
    begin match with_obj with
    | None ->
      List.map
        (fun (x,y) -> 
           match (x,y) with 
           | ({Asttypes.txt = Longident.Lident name; loc} ) , 
             ({Parsetree.pexp_desc = Pexp_ident{txt = Lident name2}} )
             when name2 = name -> 
              ({Asttypes.txt = name ; loc}, None)
           | ({Asttypes.txt = Longident.Lident name; loc} ), y 
             -> 
             ({Asttypes.txt = name ; loc}, Some y)
           | _ -> 
             Location.raise_errorf ~loc "Qualified label is not allood"
        )
        label_exprs
    | Some _ -> 
      Location.raise_errorf ~loc "with is not supported"
    end
  | Parsetree.PStr [] -> []
  | _ -> 
    Location.raise_errorf ~loc "this is not a valid record config"



let assert_strings loc (x : t) : string list
   = 
  let module M = struct exception Not_str end  in 
  match x with 
  | PStr [ {pstr_desc =  
              Pstr_eval (
                {pexp_desc = 
                   Pexp_tuple strs;
                 _},_);
            pstr_loc = loc ;            
            _}] ->
    (try 
        strs |> List.map (fun e ->
           match (e : Parsetree.expression) with
           | {pexp_desc = Pexp_constant (Const_string (name,_)); _} -> 
             name
           | _ -> raise M.Not_str)
     with M.Not_str ->
       Location.raise_errorf ~loc "expect string tuple list"
    )
  | PStr [ {
      pstr_desc =  
        Pstr_eval (
          {pexp_desc = 
             Pexp_constant 
               (Const_string (name,_));
           _},_);
      _}] ->  [name] 
  | PStr [] ->  []
  | PStr _                
  | PTyp _ | PPat _ ->
    Location.raise_errorf ~loc "expect string tuple list"
let assert_bool_lit  (e : Parsetree.expression) = 
  match e.pexp_desc with
  | Pexp_construct ({txt = Lident "true" }, None)
    -> true
  | Pexp_construct ({txt = Lident "false" }, None)
    -> false 
  | _ ->
    Location.raise_errorf ~loc:e.pexp_loc "expect `true` or `false` in this field"


let empty : t = Parsetree.PStr []



let table_dispatch table (action : action)
     = 
  match action with 
  | {txt =  name; loc  }, y -> 
    begin match String_map.find name table with 
      | fn -> fn y
      | exception _ -> Location.raise_errorf ~loc "%s is not supported" name
    end

end
module Ast_attributes : sig 
#1 "ast_attributes.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)
type attr =  Parsetree.attribute
type t =  attr list 

type ('a,'b) st = 
  { get : 'a option ; 
    set : 'b option }

val process_method_attributes_rev : 
  t ->
  (bool * bool , [`Get | `No_get ]) st * t 

val process_attributes_rev : 
  t -> [ `Meth_callback | `Nothing | `Uncurry | `Method ] * t 

val process_bs : 
  t -> [ `Nothing | `Has] * t 

val process_external : t -> bool 

type derive_attr = {
  explict_nonrec : bool;
  bs_deriving : [`Has_deriving of Ast_payload.action list | `Nothing ]
}
val process_bs_string_int : 
  t -> [`Nothing | `String | `Int | `Ignore]  * t 

val process_bs_string_as :
  t -> string option * t 
val process_bs_int_as : 
  t -> int option * t 


val process_derive_type : 
  t -> derive_attr * t 



val bs : attr 
val bs_this : attr
val bs_method : attr



end = struct
#1 "ast_attributes.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type attr =  Parsetree.attribute
type t =  attr list 

type ('a,'b) st = 
  { get : 'a option ; 
    set : 'b option }


let process_method_attributes_rev (attrs : t) = 
  List.fold_left (fun (st,acc) (({txt ; loc}, payload) as attr : attr) -> 

      match txt  with 
      | "bs.get" (* [@@bs.get{null; undefined}]*)
        -> 
        let result = 
          List.fold_left 
          (fun 
            (null, undefined)
            (({txt ; loc}, opt_expr) : Ast_payload.action) -> 
            if txt =  "null" then 
              (match opt_expr with 
              | None -> true
              | Some e -> 
                Ast_payload.assert_bool_lit e), undefined

            else if txt = "undefined" then 
              null, 
              (match opt_expr with
               | None ->  true
               | Some e -> 
                 Ast_payload.assert_bool_lit e)

            else Location.raise_errorf ~loc "unsupported predicates"
          ) (false, false) (Ast_payload.as_config_record_and_process loc payload)  in 

        ({st with get = Some result}, acc  )

      | "bs.set"
        -> 
        let result = 
          List.fold_left 
          (fun st (({txt ; loc}, opt_expr) : Ast_payload.action) -> 
            if txt =  "no_get" then 
              match opt_expr with 
              | None -> `No_get 
              | Some e -> 
                if Ast_payload.assert_bool_lit e then 
                  `No_get
                else `Get
            else Location.raise_errorf ~loc "unsupported predicates"
          ) `Get (Ast_payload.as_config_record_and_process loc payload)  in 
        (* properties -- void 
              [@@bs.set{only}]
           *)
        {st with set = Some result }, acc
      | _ -> 
        (st, attr::acc  )
    ) ( {get = None ; set = None}, []) attrs


let process_attributes_rev (attrs : t) = 
  List.fold_left (fun (st, acc) (({txt; loc}, _) as attr : attr) -> 
      match txt, st  with 
      | "bs", (`Nothing | `Uncurry) 
        -> 
        `Uncurry, acc
      | "bs.this", (`Nothing | `Meth_callback)
        ->  `Meth_callback, acc
      | "bs.meth",  (`Nothing | `Method)
        -> `Method, acc
      | "bs", _
      | "bs.this", _
        -> Location.raise_errorf 
             ~loc
             "[@bs.this], [@bs], [@bs.meth] can not be applied at the same time"
      | _ , _ -> 
        st, attr::acc 
    ) ( `Nothing, []) attrs

let process_bs attrs = 
  List.fold_left (fun (st, acc) (({txt; loc}, _) as attr : attr) -> 
      match txt, st  with 
      | "bs", _
        -> 
        `Has, acc
      | _ , _ -> 
        st, attr::acc 
    ) ( `Nothing, []) attrs

let process_external attrs = 
  List.exists (fun (({txt; }, _)  : attr) -> 
      if Ext_string.starts_with txt "bs." then true 
      else false
    ) attrs


type derive_attr = {
  explict_nonrec : bool;
  bs_deriving : [`Has_deriving of Ast_payload.action list | `Nothing ]
}

let process_derive_type attrs =
  List.fold_left 
    (fun (st, acc) 
      (({txt ; loc}, payload  as attr): attr)  ->
      match  st, txt  with
      |  {bs_deriving = `Nothing}, "bs.deriving"
        ->
        {st with
         bs_deriving = `Has_deriving 
             (Ast_payload.as_config_record_and_process loc payload)}, acc 
      | {bs_deriving = `Has_deriving _}, "bs.deriving"
        -> 
        Location.raise_errorf ~loc "duplicated bs.deriving attribute"
      | _ , _ ->
        let st = 
          if txt = "nonrec" then 
            { st with explict_nonrec = true }
          else st in 
        st, attr::acc
    ) ( {explict_nonrec = false; bs_deriving = `Nothing }, []) attrs



let process_bs_string_int attrs = 
  List.fold_left 
    (fun (st,attrs)
      (({txt ; loc}, payload ) as attr : attr)  ->
      match  txt, st  with
      | "bs.string", (`Nothing | `String)
        -> `String, attrs
      | "bs.int", (`Nothing | `Int)
        ->  `Int, attrs
      | "bs.ignore", (`Nothing | `Ignore)
        -> `Ignore, attrs
      | "bs.int", _
      | "bs.string", _
      | "bs.ignore", _
        -> 
        Location.raise_errorf ~loc "conflict attributes "
      | _ , _ -> st, (attr :: attrs )
    ) (`Nothing, []) attrs

let process_bs_string_as  attrs = 
  List.fold_left 
    (fun (st, attrs)
      (({txt ; loc}, payload ) as attr : attr)  ->
      match  txt, st  with
      | "bs.as", None
        ->
        begin match Ast_payload.is_single_string payload with 
          | None -> 
            Location.raise_errorf ~loc "expect string literal "
          | Some  _ as v->  (v, attrs)  
        end
      | "bs.as",  _ 
        -> 
          Location.raise_errorf ~loc "duplicated bs.as "
      | _ , _ -> (st, attr::attrs) 
    ) (None, []) attrs

let process_bs_int_as  attrs = 
  List.fold_left 
    (fun (st, attrs)
      (({txt ; loc}, payload ) as attr : attr)  ->
      match  txt, st  with
      | "bs.as", None
        ->
        begin match Ast_payload.is_single_int payload with 
          | None -> 
            Location.raise_errorf ~loc "expect int literal "
          | Some  _ as v->  (v, attrs)  
        end
      | "bs.as",  _ 
        -> 
          Location.raise_errorf ~loc "duplicated bs.as "
      | _ , _ -> (st, attr::attrs) 
    ) (None, []) attrs


let bs : attr
  =  {txt = "bs" ; loc = Location.none}, Ast_payload.empty
let bs_this : attr
  =  {txt = "bs.this" ; loc = Location.none}, Ast_payload.empty

let bs_method : attr 
  =  {txt = "bs.meth"; loc = Location.none}, Ast_payload.empty



end
module Bs_loc : sig 
#1 "bs_loc.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type t = Location.t = {
  loc_start : Lexing.position;
  loc_end : Lexing.position ; 
  loc_ghost : bool
} 

val is_ghost : t -> bool
val merge : t -> t -> t 
val none : t 


end = struct
#1 "bs_loc.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


type t = Location.t = {
  loc_start : Lexing.position;
  loc_end : Lexing.position ; 
  loc_ghost : bool
} 

let is_ghost x = x.loc_ghost

let merge (l: t) (r : t) = 
  if is_ghost l then r 
  else if is_ghost r then l 
  else match l,r with 
  | {loc_start ; }, {loc_end; _} (* TODO: improve*)
    -> 
    {loc_start ;loc_end; loc_ghost = false}

let none = Location.none

end
module Lam_methname : sig 
#1 "lam_methname.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)



val translate : ?loc:Location.t -> string -> string

end = struct
#1 "lam_methname.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


let translate ?loc name =
  let i = Ext_string.rfind ~sub:"_" name  in
  if name.[0] = '_' then
    if i <= 0 then
      let len = (String.length name - 1) in
      if len = 0 then
        Location.raise_errorf ?loc "invalid label %s" name
      else String.sub name 1 len
    else
      let len = (i - 1) in
      if len = 0 then
        Location.raise_errorf ?loc "invalid label %s" name 
      else
        String.sub name 1 len
  else if i > 0 then
    String.sub name 0 i
  else name

end
module Ast_external_attributes : sig 
#1 "ast_external_attributes.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


type external_module_name = 
  { bundle : string ; 
    bind_name : string option
  }

type js_call = { 
  name : string;
  external_module_name : external_module_name option;
  splice : bool 
}
type pipe = bool 
type js_send = { 
  name : string ;
  splice : bool ; 
  pipe : pipe   
} (* we know it is a js send, but what will happen if you pass an ocaml objct *)

type js_global_val = {
  name : string ; 
  external_module_name : external_module_name option
  }

type js_new_val = {
  name : string ; 
  external_module_name : external_module_name option;
  splice : bool ;
}

type arg_type = Ast_core_type.arg_type
  
type arg_label = Ast_core_type.arg_label 

type arg_kind = 
  {
    arg_type : arg_type;
    arg_label : arg_label
  }
type js_module_as_fn = 
  { external_module_name : external_module_name;
    splice : bool 
  }
type ffi = 
  | Obj_create of arg_label list
  | Js_global of js_global_val 
  | Js_module_as_var of  external_module_name
  | Js_module_as_fn of js_module_as_fn
  | Js_module_as_class of external_module_name       
  | Js_call of js_call
  | Js_send of js_send
  | Js_new of js_new_val
  | Js_set of string
  | Js_get of string
  | Js_get_index
  | Js_set_index

  (* When it's normal, it is handled as normal c functional ffi call *)

type t  = 
  | Bs of arg_kind list  * arg_type *   ffi
  | Normal 





(**
   return value is of [pval_type, pval_prim]
*)    
val handle_attributes_as_string : 
  Bs_loc.t ->
  string  ->
  Ast_core_type.t ->
  Ast_attributes.t -> 
  string   ->
  Ast_core_type.t * string list * Ast_attributes.t


val bs_external : string 
val to_string : t -> string 
val from_string : string -> t 
val unsafe_from_string : string -> t 
val is_bs_external_prefix : string -> bool



val pval_prim_of_labels : string Asttypes.loc list -> string list

val name_of_ffi : ffi -> string

end = struct
#1 "ast_external_attributes.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)



type external_module_name = 
  { bundle : string ; 
    bind_name : string option
  }

type pipe = bool 
type js_call = { 
  name : string;
  external_module_name : external_module_name option;
  splice : bool 
}

type js_send = { 
  name : string ;
  splice : bool ; 
  pipe : pipe   
} (* we know it is a js send, but what will happen if you pass an ocaml objct *)

type js_global_val = {
  name : string ; 
  external_module_name : external_module_name option
  }

type js_new_val = {
  name : string ; 
  external_module_name : external_module_name option;
  splice : bool ;
}

type js_module_as_fn = 
  { external_module_name : external_module_name;
    splice : bool 
  }

type arg_type = Ast_core_type.arg_type
type arg_label = Ast_core_type.arg_label

type arg_kind = 
  {
    arg_type : arg_type;
    arg_label : arg_label
  }


type ffi = 
  | Obj_create of arg_label list
  | Js_global of js_global_val 
  | Js_module_as_var of  external_module_name
  | Js_module_as_fn of js_module_as_fn
  | Js_module_as_class of external_module_name             
  | Js_call of js_call 
  | Js_send of js_send
  | Js_new of js_new_val
  | Js_set of string
  | Js_get of string
  | Js_get_index
  | Js_set_index

let name_of_ffi ffi =
  match ffi with 
  | Js_get_index -> "[@@bs.get_index]"
  | Js_set_index -> "[@@bs.set_index]"
  | Js_get s -> Printf.sprintf "[@@bs.get %S]" s 
  | Js_set s -> Printf.sprintf "[@@bs.set %S]" s 
  | Js_call v  -> Printf.sprintf "[@@bs.val %S]" v.name
  | Js_send v  -> Printf.sprintf "[@@bs.send %S]" v.name
  | Js_module_as_fn v  -> Printf.sprintf "[@@bs.val %S]" v.external_module_name.bundle
  | Js_new v  -> Printf.sprintf "[@@bs.new %S]" v.name                    
  | Js_module_as_class v
    -> Printf.sprintf "[@@bs.module] %S " v.bundle
  | Js_module_as_var v
    -> 
      Printf.sprintf "[@@bs.module] %S " v.bundle
  | Js_global v 
    -> 
      Printf.sprintf "[@@bs.val] %S " v.name                    
  | Obj_create _ -> 
    Printf.sprintf "[@@bs.obj]"
type t  = 
  | Bs of arg_kind list  * Ast_core_type.arg_type * ffi
  | Normal 
  (* When it's normal, it is handled as normal c functional ffi call *)



let get_arg_type ({ptyp_desc; ptyp_attributes; ptyp_loc = loc} as ptyp : Ast_core_type.t) : 
  arg_type * Ast_core_type.t  = 
    match Ast_attributes.process_bs_string_int ptyp_attributes, ptyp_desc with 
    | (`String, ptyp_attributes),  Ptyp_variant ( row_fields, Closed, None)
      -> 
      let case, result, row_fields  = 
        (List.fold_right (fun tag (nullary, acc, row_fields) -> 
             match nullary, tag with 
             | (`Nothing | `Null), 
               Parsetree.Rtag (label, attrs, true,  [])
               -> 
               begin match Ast_attributes.process_bs_string_as attrs with 
                 | Some name, new_attrs  -> 
                   `Null, ((Ext_pervasives.hash_variant label, name) :: acc ), 
                   Parsetree.Rtag(label, new_attrs, true, []) :: row_fields

                 | None, _ -> 
                   `Null, ((Ext_pervasives.hash_variant label, label) :: acc ), 
                   tag :: row_fields
               end
             | (`Nothing | `NonNull), Parsetree.Rtag(label, attrs, false, ([ _ ] as vs)) 
               -> 
               begin match Ast_attributes.process_bs_string_as attrs with 
                 | Some name, new_attrs -> 
                   `NonNull, ((Ext_pervasives.hash_variant label, name) :: acc),
                   Parsetree.Rtag (label, new_attrs, false, vs) :: row_fields
                 | None, _ -> 
                   `NonNull, ((Ext_pervasives.hash_variant label, label) :: acc),
                   (tag :: row_fields)
               end
             | _ -> Location.raise_errorf ~loc "Not a valid string type"
           ) row_fields (`Nothing, [], [])) in 
       (match case with 
        | `Nothing -> Location.raise_errorf ~loc "Not a valid string type"
        | `Null -> NullString result 
        | `NonNull -> NonNullString result) , 
       {ptyp with ptyp_desc = Ptyp_variant(row_fields, Closed, None);
        ptyp_attributes ;
       }
    | (`String, _),  _ -> Location.raise_errorf ~loc "Not a valid string type"

    | (`Ignore, ptyp_attributes), _  -> 
      (Ignore, {ptyp with ptyp_attributes})
    | (`Int , ptyp_attributes),  Ptyp_variant ( row_fields, Closed, None) -> 
      let _, acc, rev_row_fields = 
        (List.fold_left 
           (fun (i,acc, row_fields) rtag -> 
              match rtag with 
              | Parsetree.Rtag (label, attrs, true,  [])
                -> 
                  begin match Ast_attributes.process_bs_int_as attrs with 
                  | Some i, new_attrs -> 
                    i + 1, ((Ext_pervasives.hash_variant label , i):: acc ), 
                    Parsetree.Rtag (label, new_attrs, true, []) :: row_fields
                  | None, _ -> 
                    i + 1 , ((Ext_pervasives.hash_variant label , i):: acc ), rtag::row_fields
                  end

              | _ -> Location.raise_errorf ~loc "Not a valid string type"
           ) (0, [],[]) row_fields) in 
      Int (List.rev acc),
      {ptyp with 
       ptyp_desc = Ptyp_variant(List.rev rev_row_fields, Closed, None );
       ptyp_attributes
      }
      
    | (`Int, _), _ -> Location.raise_errorf ~loc "Not a valid string type"
    | (`Nothing, ptyp_attributes),  ptyp_desc ->
      begin match ptyp_desc with
        | Ptyp_constr ({txt = Lident "bool"}, [])
          -> 
          Bs_warnings.prerr_warning loc Unsafe_ffi_bool_type;
          Nothing
        | Ptyp_constr ({txt = Lident "unit"}, [])
          -> Unit 
        | Ptyp_constr ({txt = Lident "array"}, [_])
          -> Array
        | Ptyp_variant _ ->
          Bs_warnings.prerr_warning loc Unsafe_poly_variant_type;
          Nothing           
        | _ ->
          Nothing           
      end, ptyp


let valid_js_char =
  let a = Array.init 256 (fun i ->
    let c = Char.chr i in
    (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c = '_' || c = '$'
  ) in
  (fun c -> Array.unsafe_get a (Char.code c))

let valid_first_js_char = 
  let a = Array.init 256 (fun i ->
    let c = Char.chr i in
    (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c = '_' || c = '$'
  ) in
  (fun c -> Array.unsafe_get a (Char.code c))

(** Approximation could be improved *)
let valid_ident (s : string) =
  let len = String.length s in
  len > 0 && valid_js_char s.[0] && valid_first_js_char s.[0] &&
  (let module E = struct exception E end in
   try
     for i = 1 to len - 1 do
       if not (valid_js_char (String.unsafe_get s i)) then
         raise E.E         
     done ;
     true     
   with E.E -> false )  
  
let valid_global_name ?loc txt =
  if not (valid_ident txt) then
    let v = Ext_string.split_by ~keep_empty:true (fun x -> x = '.') txt in
    List.iter
      (fun s ->
         if not (valid_ident s) then
           Location.raise_errorf ?loc "Not a valid  name %s"  txt
      ) v      

let valid_method_name ?loc txt =         
  if not (valid_ident txt) then
    Location.raise_errorf ?loc "Not a valid  name %s"  txt



let check_external_module_name ?loc x = 
  match x with 
  | {bundle = ""; _ } | {bind_name = Some ""} -> 
    Location.raise_errorf ?loc "empty name encountered"
  | _ -> ()
let check_external_module_name_opt ?loc x = 
  match x with 
  | None -> ()
  | Some v -> check_external_module_name ?loc v 


let check_ffi ?loc ffi = 
  match ffi with 
  | Js_global {name} -> valid_global_name ?loc  name
  | Js_send {name } 
  | Js_set  name
  | Js_get name
    ->  valid_method_name ?loc name
  | Obj_create _ -> ()
  | Js_get_index | Js_set_index 
    -> ()

  | Js_module_as_var external_module_name
  | Js_module_as_fn {external_module_name; _}
  | Js_module_as_class external_module_name             
    -> check_external_module_name external_module_name
  | Js_new {external_module_name ;  name}
  | Js_call {external_module_name ;  name ; _}
    -> 
    check_external_module_name_opt ?loc external_module_name ;
    valid_global_name ?loc name     


(** 
   [@@bs.module "react"]
   [@@bs.module "react"]
   ---
   [@@bs.module "@" "react"]
   [@@bs.module "@" "react"]

   They should have the same module name 

   TODO: we should emit an warning if we bind 
   two external files to the same module name
*)
type bundle_source =
  [`Nm_payload of string
  |`Nm_external of string
  | `Nm_val of string      
  ]  

let string_of_bundle_source (x : bundle_source) =
  match x with
  | `Nm_payload x
  | `Nm_external x
  | `Nm_val x -> x   
type name_source =
  [ bundle_source  
  | `Nm_na

  ]
type st = 
  { val_name : name_source;
    external_module_name : external_module_name option;
    module_as_val : external_module_name option;
    val_send : name_source ;
    val_send_pipe : Ast_core_type.t option;    
    splice : bool ; (* mutable *)
    set_index : bool; (* mutable *)
    get_index : bool;
    new_name : name_source ;
    call_name : name_source ;
    set_name : name_source ;
    get_name : name_source ;
    mk_obj : bool ;

  }

let init_st = 
  {
    val_name = `Nm_na; 
    external_module_name = None ;
    module_as_val = None;
    val_send = `Nm_na;
    val_send_pipe = None;    
    splice = false;
    set_index = false;
    get_index = false;
    new_name = `Nm_na;
    call_name = `Nm_na;
    set_name = `Nm_na ;
    get_name = `Nm_na ;
    mk_obj = false ; 

  }


let bs_external = "BS:" ^ Js_config.version
let bs_external_length = String.length bs_external

let is_bs_external_prefix s = 
  Ext_string.starts_with s bs_external

let to_string  t = 
  bs_external ^ Marshal.to_string t []
let unsafe_from_string s = 
    Marshal.from_string  s bs_external_length 
let from_string s : t  = 
  if is_bs_external_prefix s then 
    Marshal.from_string  s (String.length bs_external)
  else Ext_pervasives.failwithf ~loc:__LOC__
      "compiler version mismatch, please do a clean build" 

let process_external_attributes 
    no_arguments 
    (prim_name_or_pval_prim: [< bundle_source ] as 'a)
    pval_prim
    prim_attributes =
  let name_from_payload_or_prim payload : name_source =
    match Ast_payload.is_single_string payload with
    | Some  val_name ->  `Nm_payload val_name
    | None ->  (prim_name_or_pval_prim :> name_source)
  in
  List.fold_left 
    (fun (st, attrs)
      (({txt ; loc}, payload) as attr : Ast_attributes.attr) 
      ->
        if Ext_string.starts_with txt "bs." then
          begin match txt with 
            | "bs.val" ->  
              if no_arguments then
                {st with val_name = name_from_payload_or_prim payload}
              else 
                {st with call_name = name_from_payload_or_prim payload}

            | "bs.module" -> 
              begin match Ast_payload.assert_strings loc payload with 
                | [name] ->
                  {st with external_module_name =
                             Some {bundle=name; bind_name = None}}
                | [bundle;bind_name] -> 
                  {st with external_module_name =
                             Some {bundle; bind_name = Some bind_name}}
                | [] ->
                  { st with
                    module_as_val = 
                      Some
                        { bundle =
                            string_of_bundle_source
                              (prim_name_or_pval_prim :> bundle_source) ;
                          bind_name = Some pval_prim}
                  }
                | _  -> Location.raise_errorf ~loc "Illegal attributes"
              end
            | "bs.splice" -> {st with splice = true}
            | "bs.send" -> 
              { st with val_send = name_from_payload_or_prim payload}
            | "bs.send.pipe"
              ->
              { st with val_send_pipe = Some (Ast_payload.as_core_type loc payload)}                
            | "bs.set" -> 
              {st with set_name = name_from_payload_or_prim payload}
            | "bs.get" -> {st with get_name = name_from_payload_or_prim payload}

            | "bs.new" -> {st with new_name = name_from_payload_or_prim payload}
            | "bs.set_index" -> {st with set_index = true}
            | "bs.get_index"-> {st with get_index = true}
            | "bs.obj" -> {st with mk_obj = true}
            | _ -> (Bs_warnings.warn_unused_attribute loc txt; st)
          end, attrs
        else (st , attr :: attrs)
    )
    (init_st, []) prim_attributes 


let list_of_arrow (ty : Parsetree.core_type) = 
  let rec aux (ty : Parsetree.core_type) acc = 
    match ty.ptyp_desc with 
    | Ptyp_arrow(label,t1,t2) -> 
      aux t2 ((label,t1,ty.ptyp_attributes,ty.ptyp_loc) ::acc)
    | Ptyp_poly(_, ty) -> (* should not happen? *)
      Location.raise_errorf ~loc:ty.ptyp_loc "Unhandled poly type"
    | return_type -> ty, List.rev acc
  in aux ty []

(** Note that the passed [type_annotation] is already processed by visitor pattern before 
*)
let handle_attributes 
    (loc : Bs_loc.t)
    (pval_prim : string ) 
    (type_annotation : Parsetree.core_type)
    (prim_attributes : Ast_attributes.t) (prim_name : string)
  : Ast_core_type.t * string * t * Ast_attributes.t =
  let prim_name_or_pval_prim =
    if String.length prim_name = 0 then  `Nm_val pval_prim
    else  `Nm_external prim_name  (* need check name *)
  in    
  let result_type, arg_types_ty =
    list_of_arrow type_annotation in
  let result_type_spec, new_result_type  = get_arg_type result_type in
  let (st, left_attrs) = 
    process_external_attributes 
      (arg_types_ty = [])
      prim_name_or_pval_prim pval_prim prim_attributes in 

  let splice = st.splice in 
  let arg_type_specs, new_arg_types_ty, arg_type_specs_length   = 
    List.fold_right 
      (fun (label,ty,attr,loc) (arg_type_specs, arg_types, i) -> 
         let spec, new_ty = get_arg_type ty in
         (if i = 0 && splice  then
           match spec with 
           | Array  -> ()
           | _ ->  Location.raise_errorf ~loc "[@@bs.splice] expect last type to array");
         ({ arg_label = Ast_core_type.label_name label ; 
            arg_type = spec 
          } :: arg_type_specs,
          (label, new_ty,attr,loc) :: arg_types,
          i + 1)
      ) arg_types_ty 
      (match st with
       | {val_send_pipe = Some obj} ->      
         let spec, new_ty = get_arg_type obj in 
         [{ arg_label = Empty ; 
           arg_type = spec
          }],
         ["", new_ty, [], obj.ptyp_loc]
         ,0
       | {val_send_pipe = None } -> [],[], 0) in 


  let ffi = 
    match st with 
    | { mk_obj = true;
        val_name = `Nm_na; 
        external_module_name = None ;
        module_as_val = None;
        val_send = `Nm_na;
        val_send_pipe = None;    
        splice = false;
        new_name = `Nm_na;
        call_name = `Nm_na;
        set_name = `Nm_na ;
        get_name = `Nm_na ;
        get_index = false ;
      } ->
      if String.length prim_name <> 0 then 
        Location.raise_errorf ~loc "[@@bs.obj] expect external names to be empty string";
      Obj_create (List.map (function
          | {arg_label = (Empty as l) ; arg_type = Unit  }
            -> l 
          | {arg_label = Empty ; arg_type = _ }
            -> Location.raise_errorf ~loc "expect label, optional, or unit here"
          | {arg_label = (Label _) ; arg_type = (Ignore | Unit) ; }
            -> Empty
          | {arg_label = Label name ; arg_type = (Nothing | Array)} -> 
            Label (Lam_methname.translate ~loc name)            
          | {arg_label = Label l ; arg_type = (NullString _ | NonNullString _ | Int _ ) }
            -> Location.raise_errorf ~loc 
                 "bs.obj label %s does not support such arg type" l
          | {arg_label = Optional name ; arg_type = (Nothing | Array | Unit | Ignore)} 
            -> Optional (Lam_methname.translate ~loc name)
          | {arg_label = Optional l ; arg_type = (NullString _ | NonNullString _ | Int _)} 
            -> Location.raise_errorf ~loc 
                 "bs.obj optional %s does not support such arg type" l )
          arg_type_specs)(* Need fetch label here, for better error message *)
    | {mk_obj = true; _}
      ->
      Location.raise_errorf ~loc "conflict attributes found"                
    | {set_index = true;

       val_name = `Nm_na; 
       external_module_name = None ;
       module_as_val = None;
       val_send = `Nm_na;
       val_send_pipe = None;    
       splice = false;
       get_index = false;
       new_name = `Nm_na;
       call_name = `Nm_na;
       set_name = `Nm_na ;
       get_name = `Nm_na ;
       mk_obj = false ; 

      } 
      ->
      if String.length prim_name <> 0 then 
        Location.raise_errorf ~loc "[@@bs.set_index] expect external names to be empty string";
      if arg_type_specs_length = 3 then 
          Js_set_index
      else 
        Location.raise_errorf ~loc "Ill defined attribute [@@bs.set_index](arity of 3)"

    | {set_index = true; _}
      ->
      Location.raise_errorf ~loc "conflict attributes found"        

    | {get_index = true;

       val_name = `Nm_na; 
       external_module_name = None ;
       module_as_val = None;
       val_send = `Nm_na;
       val_send_pipe = None;    

       splice = false;
       new_name = `Nm_na;
       call_name = `Nm_na;
       set_name = `Nm_na ;
       get_name = `Nm_na ;
       mk_obj = false ; 
      } ->
      if String.length prim_name <> 0 then 
        Location.raise_errorf ~loc "[@@bs.get_index] expect external names to be empty string";
      if arg_type_specs_length = 2 then 
          Js_get_index
      else Location.raise_errorf ~loc "Ill defined attribute [@@bs.get_index] (arity of 2)"

    | {get_index = true; _}
      -> Location.raise_errorf ~loc "conflict attributes found"        
    | {module_as_val = Some external_module_name ;

       get_index = false;
       val_name ;
       new_name ;
       (*TODO: a better way to avoid breaking existing code,
         we need tell the difference from 
         {[
           1. [@@bs.val "x"]
           2. external x : .. "x" [@@bs.val ]
           3. external x : .. ""  [@@bs.val]    ]}
                                                *)         
      external_module_name = None ;
      val_send = `Nm_na;
      val_send_pipe = None;    
      splice ;
      call_name = `Nm_na;
      set_name = `Nm_na ;
      get_name = `Nm_na ;
      mk_obj = false ;} ->
   begin match arg_types_ty, new_name, val_name  with         
    | [], `Nm_na,  _ -> Js_module_as_var external_module_name
    | _, `Nm_na, _ -> Js_module_as_fn {splice; external_module_name }
    | _, #bundle_source, #bundle_source ->
      Location.raise_errorf ~loc "conflict attributes found"
    | _, (`Nm_val _ | `Nm_external _) , `Nm_na
      -> Js_module_as_class external_module_name
    | _, `Nm_payload _ , `Nm_na
      ->
      Location.raise_errorf ~loc
        "conflict attributes found: (bs.new should not carry payload here)"

  end
 | {module_as_val = Some _}
   -> Location.raise_errorf ~loc "conflict attributes found" 
 | {call_name = (`Nm_val name | `Nm_external name | `Nm_payload name) ;
    splice; 
    external_module_name;

    val_name = `Nm_na ;
    module_as_val = None;
    val_send = `Nm_na ;
    val_send_pipe = None;    

    set_index = false;
    get_index = false;
    new_name = `Nm_na;
    set_name = `Nm_na ;
    get_name = `Nm_na 
   } -> 
   Js_call {splice; name; external_module_name}
 | {call_name = #bundle_source } 
   -> Location.raise_errorf ~loc "conflict attributes found"

 | {val_name = (`Nm_val name | `Nm_external name | `Nm_payload name);
    external_module_name;

    call_name = `Nm_na ;
    module_as_val = None;
    val_send = `Nm_na ;
    val_send_pipe = None;    
    set_index = false;
    get_index = false;
    new_name = `Nm_na;
    set_name = `Nm_na ;
    get_name = `Nm_na 

   } 
   -> 
   Js_global { name; external_module_name}
 | {val_name = #bundle_source }
   -> Location.raise_errorf ~loc "conflict attributes found"
 | {splice ;
    external_module_name = (Some _ as external_module_name);

    val_name = `Nm_na ;         
    call_name = `Nm_na ;
    module_as_val = None;
    val_send = `Nm_na ;
    val_send_pipe = None;             
    set_index = false;
    get_index = false;
    new_name = `Nm_na;
    set_name = `Nm_na ;
    get_name = `Nm_na ;

   }
   ->
   let name = string_of_bundle_source prim_name_or_pval_prim in
   if arg_type_specs_length  = 0 then
     Js_global { name; external_module_name}
   else  Js_call {splice; name; external_module_name}                     
 | {val_send = (`Nm_val name | `Nm_external name | `Nm_payload name); 
    splice;
    val_send_pipe = None;
    val_name = `Nm_na  ;
    call_name = `Nm_na ;
    module_as_val = None;
    set_index = false;
    get_index = false;
    new_name = `Nm_na;
    set_name = `Nm_na ;
    get_name = `Nm_na ;
    external_module_name = None ;
   } -> 
   if arg_type_specs_length > 0 then 
       Js_send {splice ; name; pipe = false}
   else 
       Location.raise_errorf ~loc "Ill defined attribute [@@bs.send] (at least one argument)"
 | {val_send = #bundle_source} 
   -> Location.raise_errorf ~loc "conflict attributes found"

 | {val_send_pipe = Some typ; 
    (* splice = (false as splice); *)
    val_send = `Nm_na;
    val_name = `Nm_na  ;
    call_name = `Nm_na ;
    module_as_val = None;
    set_index = false;
    get_index = false;
    new_name = `Nm_na;
    set_name = `Nm_na ;
    get_name = `Nm_na ;
    external_module_name = None ;
   } -> 
   (** can be one argument *)
   Js_send {splice  ;
            name = string_of_bundle_source prim_name_or_pval_prim;
            pipe = true}

 | {val_send_pipe = Some _ } 
   -> Location.raise_errorf ~loc "conflict attributes found"

 | {new_name = (`Nm_val name | `Nm_external name | `Nm_payload name);
    external_module_name;

    val_name = `Nm_na  ;
    call_name = `Nm_na ;
    module_as_val = None;
    set_index = false;
    get_index = false;
    val_send = `Nm_na ;
    val_send_pipe = None;             
    set_name = `Nm_na ;
    get_name = `Nm_na ;
    splice 
   } 
   -> Js_new {name; external_module_name; splice}
 | {new_name = #bundle_source }
   -> Location.raise_errorf ~loc "conflict attributes found"

 | {set_name = (`Nm_val name | `Nm_external name | `Nm_payload name);

    val_name = `Nm_na  ;
    call_name = `Nm_na ;
    module_as_val = None;
    set_index = false;
    get_index = false;
    val_send = `Nm_na ;
    val_send_pipe = None;             
    new_name = `Nm_na ;
    get_name = `Nm_na ;
    external_module_name = None
   } 
   -> 
   if arg_type_specs_length = 2 then 
       Js_set name 
   else  Location.raise_errorf ~loc "Ill defined attribute [@@bs.set] (two args required)"

 | {set_name = #bundle_source}
   -> Location.raise_errorf ~loc "conflict attributes found"

 | {get_name = (`Nm_val name | `Nm_external name | `Nm_payload name);

    val_name = `Nm_na  ;
    call_name = `Nm_na ;
    module_as_val = None;
    set_index = false;
    get_index = false;
    val_send = `Nm_na ;
    val_send_pipe = None;             
    new_name = `Nm_na ;
    set_name = `Nm_na ;
    external_module_name = None
   }
   ->
   if arg_type_specs_length = 1 then  
     Js_get name
   else 
       Location.raise_errorf ~loc "Ill defined attribute [@@bs.get] (only one argument)"
 | {get_name = #bundle_source}
   -> Location.raise_errorf ~loc "conflict attributes found"
 | _ ->  Location.raise_errorf ~loc "Illegal attribute found"  in
  begin 
    check_ffi ~loc ffi;
    (match ffi, new_result_type with
     | Obj_create arg_labels ,  {ptyp_desc = Ptyp_any; _}
       ->
       (* special case: 
          {[ external f : int -> string -> _ = "" ]}
       *)
       let result =
         Ast_core_type.make_obj ~loc (
           List.fold_right2  (fun arg label acc ->
               match arg, label with
               | (_, ty, _,_), Ast_core_type.Label s
                 -> (s , [], ty) :: acc                 
               | (_, ty, _,_), Optional s
                 ->
                 begin match (ty : Ast_core_type.t) with
                   | {ptyp_desc =
                        Ptyp_constr({txt =
                                       Ldot (Lident "*predef*", "option") },
                                    [ty])}
                     ->                
                     (s, [], Ast_comb.to_undefined_type loc ty) :: acc
                   | _ -> assert false                 
                 end                 
               | (_, _, _,_), Ast_core_type.Empty -> acc                
             ) arg_types_ty arg_labels [])  in

       List.fold_right (fun (label,ty,attrs,loc) acc -> 
           Ast_helper.Typ.arrow ~loc  ~attrs label ty acc 
           ) new_arg_types_ty result 

       (* Ast_core_type.replace_result type_annotation result *)
     | _  ->
       List.fold_right (fun (label,ty,attrs,loc) acc -> 
           Ast_helper.Typ.arrow ~loc  ~attrs label ty acc 
           ) new_arg_types_ty new_result_type
    ) ,
    prim_name,
    (Bs(arg_type_specs, result_type_spec,  ffi)), left_attrs
  end

let handle_attributes_as_string 
    pval_loc
    pval_prim 
    (typ : Ast_core_type.t) attrs v = 
  let pval_type, prim_name, ffi, processed_attrs  = 
    handle_attributes pval_loc pval_prim typ attrs v  in
  pval_type, [prim_name; to_string ffi], processed_attrs
    
let pval_prim_of_labels labels = 
  let encoding = 
    let (arg_kinds, vs) = 
      List.fold_right 
        (fun {Asttypes.loc ; txt } (arg_kinds,v)
          ->
            let arg_label =  Ast_core_type.Label (Lam_methname.translate ~loc txt) in
            {arg_type = Nothing ; 
             arg_label  } :: arg_kinds, arg_label :: v
        )
        labels ([],[]) in 
    to_string @@
    Bs (arg_kinds , Nothing, Obj_create vs) in 
  [""; encoding]


end
module Js_of_lam_option : sig 
#1 "js_of_lam_option.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)







val get_default_undefined : J.expression -> J.expression

val none : J.expression 

val some : J.expression -> J.expression

end = struct
#1 "js_of_lam_option.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






module E = Js_exp_make 
 
(**
  Invrariant: 
  - optional encoding
  -  None encoding

  when no argumet is supplied, [undefined] 
  if we detect that all rest arguments are [null], 
  we can remove them


  - avoid duplicate evlauation of [arg] when it
   is not a variable
  {!Js_ast_util.named_expression} does not help 
   since we need an expression here, it might be a statement
*)
let get_default_undefined (arg : J.expression) : J.expression = 
  match arg.expression_desc with 
  | Number _ -> E.undefined
  | Array ([x],_) 
  | Caml_block([x],_,_,_) -> x (* invariant: option encoding *)
  | _ -> 
    if Js_ast_util.is_simple_expression arg then 
      E.econd arg (E.index arg 0l) E.undefined
    else E.runtime_call Js_config.js_primitive "option_get" [arg]
  
(** Another way: 
    {[
      | Var _  ->
        can only bd detected at runtime thing
          (E.bin EqEqEq (E.typeof arg)
             (E.str "number"))
    ]}
*)
let none : J.expression = 
  {expression_desc = Number (Int {i = 0l; c  = None}); comment = Some "None" }

let some x : J.expression = 
  {expression_desc = Caml_block ( [x], Immutable, E.zero_int_literal , Blk_constructor ("Some",1) );
   comment = None}








end
module Js_of_lam_variant : sig 
#1 "js_of_lam_variant.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

val eval : J.expression -> (int * string) list -> J.expression
val eval_as_event : J.expression -> (int * string) list -> J.expression list 
val eval_as_int : J.expression -> (int * int) list -> J.expression

end = struct
#1 "js_of_lam_variant.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

module E = Js_exp_make
module S = Js_stmt_make

let eval (arg : J.expression) (dispatches : (int * string) list ) = 
  match arg.expression_desc with
  | Number (Int {i} | Uint i) -> 
    begin match List.assoc (Int32.to_int i) dispatches with 
    | exception Not_found -> assert false 
    | v ->  E.str v 
    end

  | _ ->  
    E.of_block
      [(S.int_switch arg
      (List.map (fun (i,r) -> 
              {J.case = i ; 
               body = [S.return (E.str r)],
                      false (* FIXME: if true, still print break*)
              }) dispatches))]

let eval_as_event (arg : J.expression) (dispatches : (int * string) list ) = 
  match arg.expression_desc with
  | Array ([{expression_desc = Number (Int {i} | Uint i)}; cb], _)
  | Caml_block([{expression_desc = Number (Int {i} | Uint i)}; cb], _, _, _)
    -> 
    begin match (List.assoc (Int32.to_int i) dispatches) with 
    | v ->     [E.str v ; cb]
    | exception Not_found -> assert false 
    end

  | _ ->  
    let event = Ext_ident.create "action" in
    [
      E.ocaml_fun [event]
      [(S.int_switch arg
      (List.map (fun (i,r) -> 
              {J.case = i ; 
               body = [S.return (E.index (E.var event) 0l)],
                      false (* FIXME: if true, still print break*)
              }) dispatches))]
      ; (* TODO: improve, one dispatch later, 
           the problem is that we can not create bindings 
           due to the 
        *)
      E.ocaml_fun [event]
      [(S.int_switch arg
      (List.map (fun (i,r) -> 
              {J.case = i ; 
               body = [S.return (E.index (E.var event) 1l)],
                      false (* FIXME: if true, still print break*)
              }) dispatches))]
    ]

let eval_as_int (arg : J.expression) (dispatches : (int * int) list ) = 
  match arg.expression_desc with
  | Number (Int {i} | Uint i) ->
    begin match  (List.assoc (Int32.to_int i) dispatches) with
    | e -> E.int (Int32.of_int e)
    | exception Not_found -> assert false 
    end
  | _ ->  
    E.of_block
      [(S.int_switch arg
      (List.map (fun (i,r) -> 
              {J.case = i ; 
               body = [S.return (E.int (Int32.of_int  r))],
                      false (* FIXME: if true, still print break*)
              }) dispatches))]

end
module Js_of_lam_tuple : sig 
#1 "js_of_lam_tuple.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Utilities for compiling lambda tuple into JS IR *)

val make : J.expression list -> J.expression

end = struct
#1 "js_of_lam_tuple.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








module E = Js_exp_make

let make (args : J.expression list) =
  E.make_block E.zero_int_literal Blk_tuple args Immutable


end
module Lam_dispatch_primitive : sig 
#1 "lam_dispatch_primitive.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)









(** Compile lambda primitives (note this is different external c calls) *)


(** 
    @return None when the primitives are not handled in  pre-processing
 *)
val translate : 
  string ->
  J.expression list -> J.expression 

end = struct
#1 "lam_dispatch_primitive.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)









module E = Js_exp_make  
module S = Js_stmt_make


(** 
There are two things we need consider:
1.  For some primitives we can replace caml-primitive with js primitives directly
2.  For some standard library functions, we prefer to replace with javascript primitives
    For example [Pervasives["^"] -> ^]
    We can collect all mli files in OCaml and replace it with an efficient javascript runtime
*)
let translate (prim_name : string) 
    (args : J.expression list) : J.expression  =
  let call m = E.runtime_call m prim_name args in 
  begin match prim_name with 
  | "caml_gc_stat" 
  | "caml_gc_quick_stat"  
  | "caml_gc_counters"
  | "caml_gc_get"
  | "caml_gc_set"
  | "caml_gc_minor"
  | "caml_gc_major_slice"
  | "caml_gc_major"
  | "caml_gc_full_major"
  | "caml_gc_compaction"
  | "caml_final_register"
  | "caml_final_release"
    ->  call Js_config.gc
  | "caml_abs_float" -> 
    E.math "abs" args 
  | "caml_acos_float" -> 
    E.math "acos" args 
  |  "caml_add_float" -> 
    begin match args with 
    | [e0;e1] -> E.float_add e0 e1 (** TODO float plus*)
    | _ -> assert false
    end
  |"caml_div_float" -> 
    begin match args with 
    | [e0;e1] -> E.float_div e0 e1
    | _ -> assert false 
    end
  |"caml_sub_float" -> 
    begin match args with 
    | [e0;e1] -> E.float_minus e0 e1 
    | _ -> assert false 
    end
  | "caml_eq_float" -> 
    begin match args with 
    | [e0;e1] -> E.float_equal e0 e1 
    | _ -> assert false 
    end
  | "caml_ge_float"  ->
    begin match args with 
    | [e0;e1] -> E.float_comp Cge e0 e1
    | _ -> assert false 
    end
  |"caml_gt_float"  ->
    begin match args with 
    | [e0;e1] -> E.float_comp Cgt  e0 e1
    | _ -> assert false 
    end
  | "caml_tan_float"  ->
    E.math "tan" args 
  | "caml_tanh_float"  ->
    E.math "tanh" args 
  | "caml_asin_float"  -> 
    E.math "asin" args 
  | "caml_atan2_float" -> 
    E.math "atan2" args
  | "caml_atan_float" -> 
    E.math "atan" args 
  | "caml_ceil_float" -> 
    E.math "ceil" args 
  | "caml_cos_float" -> 
    E.math "cos" args 
  | "caml_cosh_float" -> 
    E.math "cosh" args
  | "caml_exp_float" -> 
    E.math "exp" args
  | "caml_sin_float" -> 
    E.math "sin" args
  | "caml_sinh_float"-> 
    E.math "sinh" args
  | "caml_sqrt_float" -> 
    E.math "sqrt" args


  | "caml_float_of_int" -> 
    begin match args with 
    | [e] -> e 
    | _ -> assert false 
    end
  | "caml_floor_float" ->
    E.math "floor" args 
  | "caml_log_float" -> 
    E.math "log" args 
  | "caml_log10_float" -> 
    E.math "log10" args 
  | "caml_log1p_float" -> 
    E.math "log1p" args 
  | "caml_power_float"  -> 
    E.math "pow" args
  |  "caml_make_float_vect" -> 
    E.new_ (E.js_global "Array") args 


  | "caml_array_append" -> 
    begin match args with 
    | [e0;e1] -> E.array_append e0 e1
    | _ ->  assert false 
    end

  | "caml_array_get"
  | "caml_array_get_addr"
  | "caml_array_get_float"
  | "caml_array_unsafe_get"
  | "caml_array_unsafe_get_float" -> 
    begin match args with 
    | [e0;e1] -> Js_of_lam_array.ref_array e0 e1
    | _ -> assert false
    end
  | "caml_array_set"
  | "caml_array_set_addr"
  | "caml_array_set_float"
  | "caml_array_unsafe_set"
  | "caml_array_unsafe_set_addr"
  | "caml_array_unsafe_set_float" -> 
    begin match args with 
    | [e0;e1;e2] -> 
      Js_of_lam_array.set_array e0 e1 e2
    | _ -> assert false
    end

  | "caml_int32_add"
    -> 
    begin match args with 
    | [e0;e1] -> E.int32_add e0 e1 
    | _ -> assert false 
    end

  | "caml_nativeint_add" 
    -> 
    begin match args with 
    | [e0;e1] -> E.unchecked_int32_add e0 e1 
    | _ -> assert false 
    end
  | "caml_int32_div" 
    -> 
    begin match args with 
      | [e0;e1] -> 
        E.int32_div  ~checked:(!Js_config.check_div_by_zero) e0 e1
      | _ -> assert false 
    end

  | "caml_nativeint_div" 
    -> (* nativeint behaves exactly the same as js numbers except division *)
    begin match args with 
    | [e0;e1] -> E.int32_div  ~checked:false e0 e1
    | _ -> assert false 
    end

  | "caml_int32_mul"
    -> 
    begin match args with 
    | [e0;e1] -> E.int32_mul e0 e1 
    | _ -> assert false 
    end
  | "caml_nativeint_mul"  -> 
    begin match args with 
    | [e0;e1] -> E.unchecked_int32_mul e0 e1 
    | _ -> assert false 
    end
  | "caml_int32_of_int"
  | "caml_nativeint_of_int" 
  | "caml_nativeint_of_int32" -> 
    begin match args with 
    | [e] -> e 
    | _ -> assert false 
    end
  | "caml_int32_of_float"
  | "caml_int_of_float"
  | "caml_nativeint_of_float" -> 
    begin match args with 
    | [e] -> E.to_int32 e 
    | _ -> assert false 
    end
  | "caml_int32_to_float"
  | "caml_int32_to_int"
  | "caml_nativeint_to_int" 
  | "caml_nativeint_to_float"
  | "caml_nativeint_to_int32" -> 
    begin match args with 
    | [e] -> e (* TODO: do more checking when [to_int32]*)
    | _ -> assert false 
    end
  | "caml_int32_sub" -> 
    begin match args with 
    | [e0;e1] -> E.int32_minus e0 e1 
    | _ -> assert false 
    end

  | "caml_nativeint_sub" ->
    begin match args with 
    | [e0;e1] -> E.unchecked_int32_minus e0 e1 
    | _ -> assert false 
    end
  | "caml_int32_xor" 
  | "caml_nativeint_xor" -> 
    begin match args with 
    | [e0; e1] -> E.int32_bxor e0 e1 
    | _ -> assert false 
    end

  | "caml_int32_and"
  | "caml_nativeint_and" -> 
    begin match args with 
    | [e0;e1] -> E.int32_band e0 e1 
    | _ -> assert false 
    end
  | "caml_int32_or"
  | "caml_nativeint_or" ->
    begin match args with
    | [e0;e1] -> E.int32_bor e0 e1 
    | _ -> assert false  
    end
  | "caml_le_float" ->
    begin match args with 
    | [e0;e1] -> E.float_comp Cle e0 e1 
    | _ -> assert false 
    end
  | "caml_lt_float" ->
    begin match args with 
    | [e0;e1] -> E.float_comp Clt e0 e1 
    | _ -> assert false 
    end
  |  "caml_neg_float" -> 
    begin match args with 
    | [e] -> 
      (** TODO: use float.. *)
      E.int32_minus E.zero_int_literal e 
    | _ -> assert false
    end
  | "caml_neq_float" -> 
    begin match args with 
    | [e0;e1] -> E.float_notequal e0 e1
    | _ -> assert false 
    end
  | "caml_mul_float" -> 
    begin match args with 
    | [e0; e1] -> E.float_mul e0 e1 
    | _ -> assert false  
    end
  | "caml_int64_to_float"
    -> Js_long.to_float args
  | "caml_int64_of_float"
    -> Js_long.of_float args
  | "caml_int64_compare"
    -> Js_long.compare args 
  | "js_int64_discard_sign"
    -> Js_long.discard_sign args
  | "js_int64_div_mod"
    -> Js_long.div_mod args
  | "js_int64_to_hex"
    -> Js_long.to_hex args    
  | "caml_int64_bits_of_float"
    -> Js_long.bits_of_float args     
  | "caml_int64_float_of_bits"
    -> Js_long.float_of_bits args 
  | "caml_int64_bswap"
    -> Js_long.swap args    
  | "caml_int32_float_of_bits"
  | "caml_int32_bits_of_float"
  | "caml_classify_float"
  | "caml_modf_float"
  | "caml_ldexp_float"
  | "caml_frexp_float"
  | "caml_float_compare"
  | "caml_copysign_float"
  | "caml_expm1_float"
  | "caml_hypot_float"

    ->
    call Js_config.float
  | "caml_fmod_float" 
    (* float module like js number module *)      
    ->      
    begin match args with 
    | [e0;e1] -> E.float_mod e0 e1
    | _ -> assert false 
    end

  | "caml_string_equal" 
    -> 
    begin match args with 
    | [e0; e1] -> E.string_equal e0 e1 
    | _ -> assert false 
    end
  | "caml_string_notequal"
    -> 
    begin match args with 
    | [e0; e1] -> E.string_comp NotEqEq e0 e1
    (** TODO: convert to ocaml ones*)
    | _ -> assert false 
    end
  | "caml_string_lessequal"
    -> 
    begin 
      match args with 
      | [e0; e1] 
        -> 
        E.string_comp Le e0 e1
      | _ -> assert false 
    end
  | "caml_string_lessthan"
    -> 
    begin match args with 
    | [e0; e1] 
      -> 
      E.string_comp Lt e0 e1
    | _ -> assert false 
    end
  | "caml_string_greaterequal"
    -> 
    begin match args with 
    | [e0; e1] 
      -> 
      E.string_comp Ge  e0 e1
    | _ -> assert false 
    end
  | "caml_string_greaterthan"
    -> 
    begin match args with 
    | [e0; e1] 
      -> 
      E.string_comp Gt  e0 e1
    | _ -> assert false 
    end
  | "caml_create_string" -> 
    (* Note that for invalid range, JS raise an Exception RangeError, 
       here in OCaml it's [Invalid_argument], we have to preserve this semantics.
        Also, it's creating a [bytes] which is a js array actually.
    *)
    begin match args with
    | [{expression_desc = Number (Int {i; _}); _} as v] 
      when i >= 0l -> 
      E.uninitialized_array v 
    (* TODO: inline and spits out a warning when i is negative *)
    | _ -> 
      call Js_config.string 
    end

  | "caml_string_get"
  | "caml_string_compare"
  | "string_of_bytes"
  | "bytes_of_string"

  | "caml_is_printable"
  | "caml_string_of_char_array"
  | "caml_fill_string"
  | "caml_blit_string" 
  | "caml_blit_bytes"
    -> 
    call Js_config.string

  | "caml_register_named_value" -> 
    (**
       callback.ml
       {[ external register_named_value : string -> Obj.t -> unit
         = "caml_register_named_value" ]}

       See the manual chap19, Interfacing C with OCaml

       {[
         let f x = print_string "f is applied to "; print_int x; print_newline()
         let _ = Callback.register "test function" f
       ]}

       On the C side 
       {[
         let f x = print_string "f is applied to "; print_int x; print_newline()
         let _ = Callback.register "test function" f
       ]}

       [caml_named_value] is a c primitive but not belong to OCaml/runtimedef.ml,
       so we don't needs
       handle it 
    *)
    E.unit

  | "caml_backtrace_status"


  | "caml_get_exception_backtrace"
  | "caml_get_exception_raw_backtrace"
  | "caml_record_backtrace"
  | "caml_convert_raw_backtrace" 
  | "caml_get_current_callstack"
    -> E.unit
  (* unit -> unit 
     _ -> unit  
     major_slice : int -> int 
  *)
  | "caml_set_oo_id" 
    ->
    (** ATT: relevant to how exception is encoded in OCaml 
        IDea: maybe we can delay compile primitive into js?
        benefit: 
        less code side when serialzation, and more knowledge in jsir
    *)
    Js_of_lam_exception.caml_set_oo_id args 

  | "caml_sys_const_big_endian" -> 
    (** return false *)
    E.bool Sys.big_endian
  | "caml_sys_const_word_size" -> 
    E.small_int  Sys.word_size
  (** TODO: How it will affect program behavior *)
  | "caml_sys_const_ostype_cygwin" -> E.caml_false 
  | "caml_sys_const_ostype_win32" -> E.caml_false 
  | "caml_sys_const_ostype_unix" -> E.caml_true
  | "caml_is_js" -> E.caml_true
  | "caml_sys_get_config" ->
    (** No cross compilation *)
    Js_of_lam_tuple.make [E.str Sys.os_type; E.small_int  Sys.word_size; 
                          E.bool Sys.big_endian ]
  | "caml_sys_get_argv" -> 
    (** TODO: refine
        Inlined here is helpful for DCE
        {[ external get_argv: unit -> string * string array = "caml_sys_get_argv" ]}
    *)
    Js_of_lam_tuple.make [E.str "cmd"; 
                          Js_of_lam_array.make_array NA Pgenarray []
                         ]
  | "caml_sys_time"
  | "caml_sys_random_seed"
  | "caml_sys_getenv"
  | "caml_sys_system_command" 
  | "caml_sys_getcwd" (* check browser or nodejs *)
  | "caml_sys_is_directory"
  | "caml_sys_file_exists"
    -> 
    call Js_config.sys
  | "caml_lex_engine"
  | "caml_new_lex_engine"
    -> 
    call Js_config.lexer 
  | "caml_parse_engine"
  | "caml_set_parser_trace" 
    -> 
    call Js_config.parser 

  | "caml_array_sub"
  | "caml_array_concat"
  (*external concat: 'a array list -> 'a array 
     Not good for inline *)

  | "caml_array_blit"
  | "caml_make_vect" -> 
    call Js_config.array
  | "caml_ml_flush"
  | "caml_ml_out_channels_list"
  | "caml_ml_open_descriptor_in" 
  | "caml_ml_open_descriptor_out"
  | "caml_ml_output_char"
  | "caml_ml_output" 
  | "caml_ml_input_char"
    -> 
    call Js_config.io
  | "caml_update_dummy"
  | "caml_obj_dup" -> 
    (** Note currently is an Array copy function, this is tightly coupled with 
        how record, tuple encoded in JS.
        Here we only inline constant cases, since this semantics should be preserved 
        no matter how we represent objects, we don't inline it just for future
    *)
    begin 
      match args with 
      | [ a ] when Js_analyzer.is_constant a ->  a 
      | _ -> 
        call Js_config.obj_runtime 
    end
  | "caml_obj_block" -> 
    (** TODO: Optimize  for [CamlinternalOO] input 
        external new_block : tag:int -> size:int  -> t = "caml_obj_block"
        Note that we don't need initialize its content anyway
        TODO: more optimizations later
        ATTENTION: This optmization is coupled with memory layout
    *)
    begin match args with 
    | [ tag; 
        {expression_desc = Number (Int { i ;_}); _} ] ->
      E.make_block tag Blk_na 
        (Ext_list.init (Int32.to_int i) 
           (fun _ -> E.zero_int_literal)) NA

    | [ tag; size] -> 
      E.uninitialized_object tag size
    | _ -> assert false


    end
  | "caml_format_float"

  | "caml_nativeint_format"
  | "caml_int32_format"
  | "caml_float_of_string"
  | "caml_int_of_string" (* what is the semantics?*)
  | "caml_int32_of_string"
  | "caml_nativeint_of_string" 
  | "caml_int64_format"
  | "caml_int64_of_string"
    -> 
    call Js_config.format 
  | "caml_format_int" -> 
    begin match args with 
    | [ {expression_desc = Str (_, "%d"); _}; v] 
      ->
      E.int_to_string v 
    | _ -> 
      call Js_config.format
    end
    (*   "caml_alloc_dummy"; *)
    (* TODO:   "caml_alloc_dummy_float"; *)


  | "caml_obj_is_block"
    -> 
    begin match args with 
    | [e] -> E.is_caml_block e 
    | _ -> assert false
    end
  | "caml_obj_truncate"
  | "caml_lazy_make_forward"
  | "caml_compare"
  | "caml_int_compare"
  | "caml_int32_compare"
  | "caml_nativeint_compare"
  | "caml_equal"
  | "caml_notequal"
  | "caml_greaterequal"
  | "caml_greaterthan"
  | "caml_lessequal"
  | "caml_lessthan"

    -> 
    call Js_config.obj_runtime
  | "caml_obj_set_tag" 
    -> begin match args with 
      | [a;b]  -> E.set_tag a b 
      | _ -> assert false end
  | "caml_obj_tag" -> 
    (* Note that in ocaml, [int] has tag [1000] and [string] has tag [252]
       also now we need do nullary check 
    *)      
    begin match args with 
    | [e] -> E.tag e 
    | _ -> assert false end

  (* Unix support *)
  | "unix_tcdrain"
  | "unix_tcflush"
  | "unix_setsid"
  | "unix_tcflow"
  | "unix_tcgetattr"
  | "unix_tcsetattr"
  | "unix_tcsendbreak"
  | "unix_getprotobynumber"
  | "unix_getprotobyname"
  | "unix_getservbyport"
  | "unix_getservbyname"
  | "unix_getservbyaddr"
  | "unix_gethostbyname"
  | "unix_gethostname"
  | "unix_getpeername"
  | "unix_accept"
  | "unix_bind"
  | "unix_connect"
  | "unix_listen"
  | "unix_shutdown"
  | "unix_getsockname"
  | "unix_gethostbyaddr"
  | "unix_getgrnam"
  | "unix_getpwuid"
  | "unix_getgrgid"
  | "unix_inet_addr_of_string"
  | "unix_string_of_inet_addr"
  | "unix_socket"
  | "unix_socketpair"
  | "unix_error_message"
  | "unix_read"
  | "unix_write"
  | "unix_single_write"
  | "unix_set_close_on_exec"
  | "unix_sigprocmask"
  | "unix_sigsuspend"
  | "unix_recv"
  | "unix_recvfrom"
  | "unix_send"
  | "unix_sendto"
  | "unix_getsockopt"
  | "unix_setsockopt"
  | "unix_getaddrinfo"
  | "unix_getnameinfo"
  | "unix_waitpid"
  | "unix_wait"
  | "unix_fork"
  | "unix_execv"
  | "unix_dup"
  | "unix_close"
  | "unix_dup2"
  | "unix_execvp"
  | "unix_execvpe"
  | "unix_pipe"
  | "unix_execve"
  | "caml_channel_descriptor"
  | "unix_putenv"
  | "unix_environment"
  | "unix_lseek"
  | "unix_getppid"
  | "unix_getpid"
  | "unix_nice"
  | "unix_open"
  | "unix_truncate"
  | "unix_ftruncate"
  | "unix_stat"
  | "unix_lstat"
  | "unix_fstat"
  | "unix_isatty"
  | "unix_lseek_64"
  | "unix_truncate_64"
  | "unix_ftruncate_64"
  | "unix_stat_64"
  | "unix_lstat_64"
  | "unix_fstat_64"
  | "unix_unlink"
  | "unix_rename"
  | "unix_link"
  | "unix_chmod"
  | "unix_fchmod"
  | "unix_chown"
  | "unix_fchown"
  | "unix_umask"
  | "unix_access"
  | "unix_set_nonblock"
  | "unix_clear_nonblock"
  | "unix_clear_close_on_exec"
  | "unix_mkdir"
  | "unix_rmdir"
  | "unix_chdir"
  | "unix_getcwd"
  | "unix_chroot"
  | "unix_opendir"
  | "unix_readdir"
  | "unix_rewinddir"
  | "unix_closedir"
  | "unix_mkfifo"
  | "unix_symlink"
  | "unix_readlink"
  | "unix_select"
  | "unix_lockf"
  | "unix_kill"
  | "unix_sigpending"
  | "unix_time"
  | "unix_gettimeofday"
  | "unix_gmtime"
  | "unix_localtime"
  | "unix_mktime"
  | "unix_alarm"
  | "unix_sleep"
  | "unix_times"
  | "unix_utimes"
  | "unix_getitimer"
  | "unix_setitimer"
  | "unix_getuid"
  | "unix_geteuid"
  | "unix_setuid"
  | "unix_getgid"
  | "unix_getegid"
  | "unix_setgid"
  | "unix_getgroups"
  | "unix_setgroups"
  | "unix_initgroups"
  | "unix_getlogin"
  | "unix_getpwnam"
    ->  E.not_implemented prim_name
  (* End of Unix support *)
  (* bigarrary support *)
  | "caml_ba_init"
    -> 
    begin match args with 
      | [e] -> E.seq e E.unit 
      | _ -> assert false
    end
  | "caml_ba_create"
  | "caml_ba_get_generic"
  | "caml_ba_set_generic"
  | "caml_ba_num_dims"
  | "caml_ba_dim"
  | "caml_ba_kind"
  | "caml_ba_layout"
  | "caml_ba_sub"
  | "caml_ba_slice"
  | "caml_ba_blit"
  | "caml_ba_fill"
  | "caml_ba_reshape"
  | "caml_ba_map_file_bytecode"

    (* caml_ba_get_1,  (\* %caml_ba_ref_1 *\) *)
    (* caml_ba_get_2, *)
    (* caml_ba_get_3, *)

    (* caml_ba_set_1,  // %caml_ba_set_1 *)
    (* caml_ba_set_2, *)
    (* caml_ba_set_3, *)

    (* caml_ba_dim_1, // %caml_ba_dim_1 *)
    (* caml_ba_dim_2,  *)
    (* caml_ba_dim_3,  *)

    -> 
    E.not_implemented prim_name
    (* call  Js_config.bigarray *)
  (* End of bigarray support *)
  | "caml_convert_raw_backtrace_slot"
    -> call  Js_config.backtrace

  | "caml_bswap16"
  | "caml_int32_bswap"
  | "caml_nativeint_bswap" 
    -> call Js_config.int32
  | "caml_get_public_method"
    ->
    call Js_config.oo
  (** TODO: Primitives not implemented yet ...*)
  | "caml_install_signal_handler"
    -> 
    begin match args with
    | [num; behavior] 
      -> E.seq num behavior (*TODO:*)
    | _ -> assert false
    end
  | "caml_md5_string"
    -> call Js_config.md5
  | "caml_hash"
    -> call Js_config.hash 
  | "caml_weak_set"
  | "caml_weak_create"
  | "caml_weak_get"
  | "caml_weak_check"
  | "caml_weak_blit"
  | "caml_weak_get_copy"
    -> call Js_config.weak

  | "caml_output_value_to_buffer"
  | "caml_marshal_data_size"
  | "caml_input_value_from_string"
  | "caml_output_value"
  | "caml_input_value"
  | "caml_output_value_to_string"
  | "caml_md5_chan"
  | "caml_hash_univ_param"
  | "caml_sys_close"
  | "caml_sys_open"
  | "caml_ml_input"
  | "caml_ml_input_scan_line"
  | "caml_ml_input_int"
  | "caml_ml_close_channel"
  | "caml_ml_output_int"
  | "caml_sys_exit"
  | "caml_ml_channel_size_64"
  | "caml_ml_channel_size"
  | "caml_ml_pos_in_64"
  | "caml_ml_pos_in"
  | "caml_ml_seek_in"
  | "caml_ml_seek_in_64"
  | "caml_ml_pos_out"
  | "caml_ml_pos_out_64"
  | "caml_ml_seek_out"
  | "caml_ml_seek_out_64"
  | "caml_ml_set_binary_mode"
    ->  E.not_implemented prim_name

  | "js_function_length"

    -> begin
        match args with 
        | [f ] -> E.function_length f 
        | _ -> assert false
      end
  | "js_create_array" 
    -> 
    begin match args with 
    | [e] -> E.uninitialized_array e 
    | _ -> assert false
    end
  | "js_array_append" 
    -> 
    begin match args with 
    | [a;b] -> 
      E.array_append a b 
    | _ -> assert false 
    end
  | "js_string_append"
    -> 
    begin match args with 
    | [a ; b] -> E.string_append a b 
    | _ -> assert false
    end
  | "js_apply" 
    -> 
    begin match args with 
    | [f ;  args] -> 
      E.flat_call f args
    | _ -> assert false 
    end
  | "js_string_of_small_int_array"
    ->
    begin match args with 
    | [e] -> E.string_of_small_int_array e 
    | _ -> assert false
    end
  | "js_string_of_char" 
    ->
      begin match args with 
      | [{expression_desc = Number (Int {i; _})} ] 
        -> E.str (String.make 1 (Char.chr (Int32.to_int i)))
      | _ -> call Js_config.string
      end
  | "js_unsafe_lt" 
    -> 
    begin match args with 
      | [l; r] -> E.bin Lt l r 
      | _ -> assert false 
    end
  | "js_unsafe_le" 
    -> begin match args with 
    | [l; r] -> E.bin Le l r 
    | _ -> assert false end 
  | "js_unsafe_gt" 
    -> begin match args with 
    | [l;r] -> E.bin Gt l r 
    | _ ->  assert false end 
  | "js_unsafe_ge" -> 
    begin match args with 
    | [l ; r] -> E.bin Ge l r 
    | _ -> assert false end
  | "js_boolean_to_bool"
    -> 
    begin match args with 
    | [e] -> E.to_ocaml_boolean e 
    | _ -> assert false
    end
  | "js_is_instance_array" 
    ->
    begin match args with 
    | [e] -> E.is_instance_array e 
    | _ -> assert false end
  | "js_typeof"
    -> 
    begin match args with 
    | [e] -> E.typeof e         
    | _ -> assert false
    end

  | "js_dump"
    -> 
    (* This primitive can accept any number of arguments 
       {[
         console.log(1,2,3)
           1 2 3
       ]}         
    *)      
    E.seq (E.dump Log args) E.unit

  | "caml_anything_to_string"
  (* patched to compiler to support for convenience *)      
  | "js_anything_to_string" 
    ->
    begin match args with 
    | [e] -> E.anything_to_string e 
    | _ -> assert false
    end
  | "js_anything_to_number" 
    -> 
    begin match args with 
    | [e] -> E.to_number e 
    | _ -> assert false
    end

  | "js_json_stringify"      
    -> 
    begin match args with 
    | [e] ->        
      E.to_json_string e
    | _ -> 
      assert false      
    end
    (* | "js_dump1" *)
    (* | "js_dump2" *)
    (* | "js_dump3" *)
    (* | "js_dump4" *)
    (* | "js_dump5" *)
    (* | "js_dump6" *)
    (* | "js_dump7" (\* TODO: refin api later *\) *)
    (* | "js_dump8" -> E.dump Log args  *)
    | "js_apply1"
    | "js_apply2"
    | "js_apply3"
    | "js_apply4"
    | "js_apply5"
    | "js_apply6"
    | "js_apply7"
    | "js_apply8" -> 
      begin match args with 
        | fn :: rest -> 
          E.call ~info:{arity=Full; call_info =  Call_na} fn rest 
        | _ -> assert false
      end
    | "js_uninitialized_object"
      ->
      begin match args with 
        | [ tag; size] -> E.uninitialized_object tag size 
        | _ -> assert false  end
    | "js_obj_length" 
      -> 
      begin match args with 
        | [e] -> E.obj_length e 
        | _ -> assert false 
      end
    | "js_pure_expr" (* TODO: conver it even earlier *)
      -> 
      begin match args with 
      | [ { expression_desc = Str (_,s )}] -> 
        E.raw_js_code Exp  s
      | _ -> 
        Ext_log.err __LOC__ 
          "JS.unsafe_js_expr is applied to an non literal string in %s"
          (Js_config.get_current_file ())
        ;
        assert false
      end
    | "js_pure_stmt" (* TODO: convert even ealier *)
      -> 
      begin match args with 
      | [ { expression_desc = Str (_,s )}] -> E.raw_js_code Stmt s
      | _ -> 
        Ext_log.err __LOC__ 
          "JS.unsafe_js_expr is applied to an non literal string in %s"
          (Js_config.get_current_file ())
        ;
        assert false
      end
    | "js_is_nil" -> 
      begin match args with
      | [ e ] -> E.is_nil e 
      | _ -> assert false 
      end
    | "js_is_undef" -> 
      begin match args with 
      | [e] -> E.is_undef e 
      | _ -> assert false
      end
    | "js_is_nil_undef" 
    | "js_from_nullable_def"
      -> call Js_config.js_primitive
    | "js_from_def" 
      -> 
      begin match args with 
      | [e] -> 
        begin match e.expression_desc with 
        | Var _ -> 
          E.econd (E.is_undef e) Js_of_lam_option.none (Js_of_lam_option.some e)
        | _ -> 
          let id = Ext_ident.create "v" in
          let tmp = E.var id in
          E.(seq (assign tmp e ) 
               (econd (is_undef tmp) Js_of_lam_option.none (Js_of_lam_option.some tmp)) )
        end

      | _ -> assert false 
      end
    | "js_from_nullable" 
      -> 
      begin match args with 
      | [e] -> 
        begin match e.expression_desc with 
        | Var _ -> 
          E.econd (E.is_nil e) Js_of_lam_option.none (Js_of_lam_option.some e)
        | _ -> 
          let id = Ext_ident.create "v" in
          let tmp = E.var id in
          E.(seq (assign tmp e ) 
               (econd (is_nil tmp) Js_of_lam_option.none (Js_of_lam_option.some tmp)) )
        end

      | _ -> assert false 
      end
    | "js_obj_set_length"
      ->
      begin match args with 
        | [a; b] -> E.set_length a b 
        | _ -> assert false 
      end

    | _ -> 

      let comment = "Missing primitive" in       
      Ext_log.warn __LOC__  "%s: %s when compiling %s\n" comment prim_name 
        (Js_config.get_current_file ()) ;
      E.not_implemented prim_name
      (*we dont use [throw] here, since [throw] is an statement 
        so we wrap in IIFE
      *)        

  end 



;;

end
module Lam_compile_external_call : sig 
#1 "lam_compile_external_call.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Compile ocaml external function call to JS IR. *) 

(** 
    This module define how the FFI (via `external`) works with attributes. 
    Note it will route to {!Lam_compile_global} 
    for compiling normal functions without attributes.
 *)


(** TODO: document supported attributes
    Attributes starting with `js` are reserved
    examples: "bs.splice"
 *)

val translate :
  Location.t ->
  Lam_compile_defs.cxt -> 
  Primitive.description -> 
  J.expression list -> 
  J.expression

end = struct
#1 "lam_compile_external_call.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)





module E = Js_exp_make



let handle_external 
    ({bundle ; bind_name} : Ast_external_attributes.external_module_name)
  =
  match bind_name with 
  | None -> 
    Lam_compile_env.add_js_module bundle , bundle
  | Some bind_name -> 
    Lam_compile_env.add_js_module 
      ~id:(Ext_ident.create_js_module bind_name) bundle,
    bundle

let handle_external_opt 
    (module_name : Ast_external_attributes.external_module_name option) = 
  match module_name with 
  | Some module_name -> Some (handle_external module_name) 
  | None -> None 

type typ = Ast_core_type.t


let ocaml_to_js_eff ({ Ast_external_attributes.arg_label;  arg_type = ty })
    (arg : J.expression) 
  : E.t list * E.t list  =
  match ty with
  | Unit ->  
    [], 
    (if Js_analyzer.no_side_effect_expression arg then 
       []
     else 
       [arg]) (* leave up later to decide *)
  | Ignore -> 
    [], 
    (if Js_analyzer.no_side_effect_expression arg then 
       []
     else 
       [arg])
  | NullString dispatches -> 
    [Js_of_lam_variant.eval arg dispatches],[]
  | NonNullString dispatches -> 
    Js_of_lam_variant.eval_as_event arg dispatches,[]
  | Int dispatches -> 
    [Js_of_lam_variant.eval_as_int arg dispatches],[]
  | Nothing  | Array -> 
    begin match arg_label with 
      | Optional label -> [Js_of_lam_option.get_default_undefined arg]
      | Label _ | Empty ->  [arg]  
    end, []


let assemble_args arg_types args : E.t list * E.t option  = 
  let args, eff = 
    List.fold_right2 
    (fun arg_type arg (accs, effs) -> 
       match ocaml_to_js_eff arg_type arg with
       | acc, eff  -> 
         acc @ accs , eff @ effs 
    ) arg_types args ([],[]) in
  args, begin match eff with 
    | [] -> None
    | x::xs -> Some (List.fold_left (fun x y -> E.seq x y) x xs )
  end

let add_eff eff e =
  match eff with
  | None -> e 
  | Some v -> E.seq v e 

(* Note: can potentially be inconsistent, sometimes 
   {[
     { x : 3 , y : undefined}
   ]}
   and 
   {[
     {x : 3 }
   ]}
   But the default to be undefined  seems reasonable 
*)
let assemble_args_obj labels args = 
  let map, eff  = 
    List.fold_right2
      (fun label ( arg : J.expression) (accs, eff ) -> 
         match (label : Ast_core_type.arg_label) with 
         | Empty ->  
           accs , 
           if Js_analyzer.no_side_effect_expression arg then eff 
           else arg :: eff 
         | Label label -> 
           ( Js_op.Key label, arg) :: accs, eff  
         | Optional label -> 
           begin match arg.expression_desc with 
             | Number _ -> (*Invariant: None encoding*)
               accs, eff 
             | _ ->  
               ( Js_op.Key label, Js_of_lam_option.get_default_undefined arg) :: accs,
               eff
           end
      ) labels args ([], []) in
  match eff with
  | [] -> 
    E.obj map 
  | x::xs -> E.seq (List.fold_left (fun x y -> E.seq x y) x xs) (E.obj map)


(* TODO: fix splice, 
   we need a static guarantee that it is static array construct
   otherwise, we should provide a good error message here, 
   no compiler failure here 
   Invariant : Array encoding
*)

let ocaml_to_js ~js_splice:(js_splice : bool) call_loc ffi
    last ({ Ast_external_attributes.arg_label;  arg_type = ty } as arg_ty)
    (arg : J.expression) 
  = 
  if last && js_splice then
    match ty with 
    | Array -> 
      begin match arg with 
        | {expression_desc = Array (ls,_mutable_flag) } -> 
          ls, [] 
        | _ -> 
          Location.raise_errorf ~loc:call_loc
            "function call with %s  is a primitive with [@@bs.splice], it expects its arguments to be a syntactic array in the call site" (Ast_external_attributes.name_of_ffi ffi)
      end
    | _ -> assert  false
  else 
    ocaml_to_js_eff arg_ty arg 

let assemble_args_splice call_loc ffi  js_splice arg_types args : E.t list * E.t option = 
  let args, eff = 
    Ext_list.fold_right2_last (fun last arg_ty arg (accs, effs)  -> 
      let (acc,eff) = ocaml_to_js call_loc ffi  ~js_splice last arg_ty arg  in acc @ accs, eff @ effs
      ) arg_types args ([], []) in
  args,
  begin  match eff with
    | [] -> None 
    | x::xs ->  Some (List.fold_left (fun x y -> E.seq x y) x xs)
  end


let translate_ffi call_loc (ffi : Ast_external_attributes.ffi ) prim_name
    (cxt  : Lam_compile_defs.cxt)
    arg_types result_type
    (args : J.expression list) = 
    match ffi with 
    | Obj_create labels -> assemble_args_obj labels args 
    | Js_call{ external_module_name = module_name; 
                 name = fn; splice = js_splice ; 

                     } -> 
      let fn =  
        match handle_external_opt module_name with 
        | Some (id,_) -> 
          E.dot (E.var id) fn
        | None ->  E.js_var fn
      in
      let args, eff  = assemble_args_splice   call_loc ffi js_splice arg_types args in 
      add_eff eff 
      begin match (result_type : Ast_core_type.arg_type) with 
      | Unit -> 
        E.seq (E.call ~info:{arity=Full; call_info = Call_na} fn args) E.unit
      | _ -> 
        E.call ~info:{arity=Full; call_info = Call_na} fn args
      end
    | Js_module_as_var module_name -> 
      let (id, name) =  handle_external  module_name  in
      E.external_var_dot id name None

    | Js_module_as_fn {external_module_name = module_name; splice} ->
      let fn =
        let (id, name) = handle_external  module_name  in
        E.external_var_dot id name None           
      in           
      let args, eff = assemble_args_splice   call_loc ffi splice arg_types args in 
        (* TODO: fix in rest calling convention *)          
      add_eff eff 
      begin match (result_type : Ast_core_type.arg_type) with 
        | Unit -> 
          E.seq (E.call ~info:{arity=Full; call_info = Call_na} fn args) E.unit
        | _ -> 
          E.call ~info:{arity=Full; call_info = Call_na} fn args
      end
    | Js_module_as_class module_name ->
      let fn =
        let (id,name) = handle_external  module_name in
        E.external_var_dot id name None in           
      let args,eff = assemble_args arg_types args in 
        (* TODO: fix in rest calling convention *)   
      add_eff eff        
      begin 
        (match cxt.st with 
         | Declare (_, id) | Assign id  ->
           (* Format.fprintf Format.err_formatter "%a@."Ident.print  id; *)
           Ext_ident.make_js_object id 
         | EffectCall | NeedValue -> ())
        ;
        E.new_ fn args
      end            

    | Js_new { external_module_name = module_name; 
               name = fn;
               splice 
             } -> 
      (* This has some side effect, it will 
         mark its identifier (If it has) as an object,
         ATTENTION: 
         order also matters here, since we mark its jsobject property, 
         it  will affect the code gen later
         TODO: we should propagate this property 
         as much as we can(in alias table)
      *)
      let args, eff = assemble_args_splice  call_loc  ffi splice arg_types args in
      let fn =  
        match handle_external_opt module_name with 
        | Some (id,name) ->  
          E.external_var_dot id name (Some fn)

        | None -> 
          (** TODO: check, no [@@bs.module], 
              assume it's global *)
          E.js_var fn

      in
      add_eff eff 
      begin 
        (match cxt.st with 
         | Declare (_, id) | Assign id  ->
           (* Format.fprintf Format.err_formatter "%a@."Ident.print  id; *)
           Ext_ident.make_js_object id 
         | EffectCall | NeedValue -> ())
        ;
        E.new_ fn args
      end            



    | Js_global {name; external_module_name} -> 

      (* TODO #11
         1. check args -- error checking 
         2. support [@@bs.scope "window"]
         we need know whether we should call [add_js_module] or not 
      *)
      begin match name, handle_external_opt external_module_name with 
        | "true", None -> E.js_bool true
        | "false", None -> E.js_bool false
        | "null", None -> E.nil 
        | "undefined", None -> E.undefined
        | _, Some(id,mod_name)
          -> E.external_var_dot id mod_name (Some name)
        | _, None -> 

          E.var (Ext_ident.create_js name)
      end
    | Js_send {splice  = js_splice ; name ; pipe = false} -> 
      begin match args  with
        | self :: args -> 
          let [@warning"-8"] ( self_type::arg_types )
            = arg_types in
          let args, eff = assemble_args_splice  call_loc ffi  js_splice arg_types args in
          add_eff eff @@ 
          E.call ~info:{arity=Full; call_info = Call_na}  (E.dot self name) args
        | _ -> 
          assert false 
      end
    | Js_send { name ; pipe = true ; splice = js_splice}
      -> (* splice should not happen *)
      (* assert (js_splice = false) ;  *)
      let self, args = Ext_list.exclude_tail args in
      let self_type, arg_types = Ext_list.exclude_tail arg_types in
      let args, eff = assemble_args_splice call_loc ffi  js_splice arg_types args in
      add_eff eff @@
      E.call ~info:{arity=Full; call_info = Call_na}  (E.dot self name) args

    | Js_get name -> 
      begin match args with 
      | [obj] ->
        E.dot obj name        
      | _ -> assert false 
      end  
    | Js_set name -> 
      begin match args with 
      | [obj; v] -> 
        E.assign (E.dot obj name) v         
      | _ -> 
        assert false 
      end
    | Js_get_index 
      -> 
      begin match args with
        | [obj; v ] -> 
          Js_arr.ref_array obj v
        | _ -> assert false 
      end
    | Js_set_index 
      -> 
      begin match args with 
      | [obj; v ; value] -> 
        Js_arr.set_array obj v value
      | _ -> assert false
      end
    


let translate loc cxt 
    ({prim_name ;  prim_native_name} 
     : Primitive.description) args  = 
  if Ast_external_attributes.is_bs_external_prefix prim_native_name then 
    begin 
      match Ast_external_attributes.unsafe_from_string prim_native_name with 
      | Normal -> 
        Lam_dispatch_primitive.translate prim_name args 
      | Bs (arg_types, result_type, ffi) -> 
        translate_ffi loc  ffi prim_name cxt arg_types result_type args 
    end
  else 
    begin 
      Lam_dispatch_primitive.translate prim_name args 
    end


end
module Lam_compile_primitive : sig 
#1 "lam_compile_primitive.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Primitive compilation  *) 

(* The entry point of compile primitives
   Note it will call {!Lam_compile_external_call.translate} for c stubs compilation
 *)

val translate : 
  Location.t -> 
  Lam_compile_defs.cxt  -> Lam.primitive -> J.expression list -> J.expression

end = struct
#1 "lam_compile_primitive.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








module E = Js_exp_make 

(* If it is the return value, since it is a side-effect call,
   we return unit, otherwise just return it
 *)
let decorate_side_effect ({st; should_return;_} : Lam_compile_defs.cxt) e : E.t = 
  match st, should_return with 
  | _, True _ 
  | (Assign _ | Declare _ | NeedValue), _  -> E.seq e E.unit
  | EffectCall, False -> e 
  (* NeedValue should return a meaningful expression*)

let translate  loc
    ({ meta = { env; _}; _} as cxt : Lam_compile_defs.cxt) 
    (prim : Lam.primitive)
    (args : J.expression list) : J.expression = 
  match prim with
  | Pjs_unsafe_downgrade _
  | Pdebugger 
  | Pjs_fn_run _ 
  | Pjs_fn_make _

  | Pjs_fn_runmethod _ 
    -> assert false (* already handled by {!Lam_compile} *)
  | Pjs_fn_method _ -> assert false
  | Pglobal_exception id ->
    Js_of_lam_exception.get_builtin_by_name id.name    
  | Pstringadd ->
    begin match args with      
      | [a;b] ->
        E.string_append a b
      | _ -> assert false          
    end          
  | Pinit_mod -> 
    E.runtime_call Js_config.module_ "init_mod" args
  | Pupdate_mod ->
    E.runtime_call Js_config.module_ "update_mod" args
  | Pmakeblock(tag, tag_info, mutable_flag ) ->  (* RUNTIME *)
    Js_of_lam_block.make_block 
      (Js_op_util.of_lam_mutable_flag mutable_flag) 
      tag_info (E.small_int tag) args 
  | Pfield (i, fld_info) -> 
    begin match args with 
      | [ e ]  -> 
        Js_of_lam_block.field fld_info e (Int32.of_int i)
      (* Invariant depends on runtime *)
      | _ -> assert false
    end

(** Negate boxed int *)
  | Pnegbint Pint32
    ->
    begin match args with
    | [ e ] -> E.int32_minus (E.zero_int_literal)  e 
    | _ -> assert false
    end
  | Pnegbint Pnativeint
    -> 
    begin match args with
    | [ e ] -> E.unchecked_int32_minus (E.zero_int_literal)  e 
    | _ -> assert false
    end
  | Pnegbint Pint64
    -> 
    Js_long.neg args 

  | Pnegint
    -> 
    begin match args with
    | [ e ] -> E.unchecked_int32_minus (E.zero_int_literal)  e 
    | _ -> assert false
    end

  | Pnegfloat 
    -> 
    begin match args with 
    | [ e ] -> E.float_minus (E.zero_float_lit) e 
    | _ -> assert false
    end
(** Negate boxed int end*)
(* Int addition and subtraction *)
  | Paddint 
  | Paddbint  Pint32
    ->
    begin match args with
      | [e1;e2] ->
        E.int32_add  e1  e2
      | _ -> assert false
    end
  | Paddbint Pnativeint 
    -> 
    begin match args with
      | [e1;e2] ->
        E.unchecked_int32_add  e1  e2
      | _ -> assert false
    end

  | Paddbint Pint64
    ->  
    Js_long.add args 


  | Paddfloat
     -> 
     begin match args with
       | [e1;e2] ->
         E.float_add  e1  e2
       | _ -> assert false
     end
  | Psubint 
    -> 
    begin match args with 
    | [e1; e2] ->     
      E.int32_minus e1 e2 
    | _ -> assert false
    end
  | Psubbint Pint32
    -> 
    begin match args with
      | [e1;e2] ->
          E.int32_minus   e1  e2
      | _ -> assert false 
    end
  | Psubbint Pnativeint
    -> 
    begin match args with
      | [e1;e2] ->
          E.unchecked_int32_minus   e1  e2
      | _ -> assert false 
    end
  | Psubbint Pint64
    -> 
    Js_long.sub args 
  | Psubfloat
    ->
    begin match args with
      | [e1;e2] ->
        E.float_minus   e1  e2
      | _ -> assert false 
    end
  | Pmulbint Lambda.Pnativeint
    -> 
    begin match args with
      | [e1; e2]  ->
        E.unchecked_int32_mul  e1  e2
      | _ -> assert false 
    end

  | Pmulint 
  | Pmulbint Lambda.Pint32
    ->
    begin match args with
      | [e1; e2]  ->
        E.int32_mul  e1  e2
      | _ -> assert false 
    end
  | Pmulbint Pint64 
    -> 
    Js_long.mul args 
  | Pmulfloat 
    -> 
      begin match args with
      | [e1; e2]  ->
          E.float_mul  e1  e2
      | _ -> assert false 
      end
  | Pdivfloat -> 
    begin match args with  
      | [e1;e2] -> E.float_div  e1  e2
      | _ -> assert false 
    end
  | Pdivbint Pnativeint
    -> 
    begin match args with 
      | [e1;e2] ->
        E.int32_div ~checked:false e1 e2
      | _ -> assert false
    end
  | Pdivint 
  | Pdivbint Pint32
    -> 
    begin match args with 
      | [e1;e2] ->
        E.int32_div ~checked:(!Js_config.check_div_by_zero) e1 e2
      | _ -> assert false
    end

  | Pdivbint Pint64 
    -> Js_long.div args 
  | Pmodint 
  | Pmodbint Pnativeint
  | Pmodbint Pint32
    ->
    begin match args with
      | [e1; e2] ->
        E.int32_mod   ~checked:(!Js_config.check_div_by_zero) e1  e2
      | _ -> assert false 
    end
  | Pmodbint Lambda.Pint64 
    -> Js_long.mod_ args  
  | Plslint 
  | Plslbint Lambda.Pnativeint
  | Plslbint Lambda.Pint32
    ->
    begin match args with
      | [e1;e2] ->
        E.int32_lsl e1  e2
      | _ -> assert false 
    end
  | Plslbint Lambda.Pint64 
    -> Js_long.lsl_ args
  | Plsrbint Lambda.Pnativeint
    -> 
    begin match args with
      | [e1; e2] ->
        E.int32_lsr   e1  e2
      | _ -> assert false
    end
  | Plsrint 
  | Plsrbint Lambda.Pint32
    ->
    begin match args with
      | [e1; {J.expression_desc = Number (Int {i=0l; _}|Uint 0l | Nint 0n); _}]
        -> 
        e1
      | [e1; e2] ->
        E.to_int32 @@ E.int32_lsr   e1  e2
      | _ -> assert false
    end
  | Plsrbint Lambda.Pint64
    -> Js_long.lsr_ args
  | Pasrint 
  | Pasrbint Lambda.Pnativeint
  | Pasrbint Lambda.Pint32
    ->
    begin match args with
      | [e1;e2] ->
        E.int32_asr  e1  e2
      | _ -> assert false
    end
  | Pasrbint Lambda.Pint64 
    -> Js_long.asr_ args      
  | Pandint 
  | Pandbint Lambda.Pnativeint
  | Pandbint Lambda.Pint32
    ->
    begin match args with
      | [e1;e2] ->
        E.int32_band  e1  e2
      | _ -> assert false
    end
  | Pandbint Lambda.Pint64
    -> Js_long.and_ args
  | Porint 
  | Porbint Lambda.Pnativeint
  | Porbint Lambda.Pint32
    ->
    begin match args with
      | [e1;e2] ->
        E.int32_bor  e1  e2
      | _ -> assert false
    end
  | Porbint Lambda.Pint64 
    -> Js_long.or_ args
  | Pxorint 
  | Pxorbint Lambda.Pnativeint
  | Pxorbint Lambda.Pint32 
    -> 
    begin match args with
      | [e1;e2] ->
        E.int32_bxor  e1  e2
      | _ -> assert false
    end
  | Pxorbint Lambda.Pint64 
    ->
    Js_long.xor args    
  | Pbintcomp (Pnativeint ,cmp)
  | Pfloatcomp cmp
  | Pintcomp cmp
  | Pbintcomp (Pint32 ,cmp)
    ->
    begin 
      (* Global Builtin Exception is an int, like 
         [Not_found] or [Invalid_argument] ?
      *)
      match args with 
      | [e1;e2] -> E.int_comp cmp e1 e2
      | _ -> assert false 
    end
        (* List --> stamp = 0 
           Assert_false --> stamp = 26 
         *)
  | Pbintcomp (Pint64 ,cmp)
    -> Js_long.comp cmp args

  | Pcvtbint ((Pint32 | Pnativeint ), Pint64) 
    -> Js_long.of_int32 args
  | Pcvtbint (Pint64, Pint64)
  | Pcvtbint ((Pnativeint|Pint32), (Pnativeint|Pint32))
    ->   
    begin match args with 
      | [e0] -> e0 
      | _ -> assert false
    end
  | Pcvtbint (Pint64, (Pnativeint|Pint32)) 
    ->  
    Js_long.to_int32 args 
  | Pintoffloat -> 
    begin
      match args with 
      | [e] -> E.to_int32 e 
      | _ -> assert false 
    end
  | Pbintofint Pint64
    -> Js_long.of_int32 args 
  | Pbintofint (Pnativeint 
               | Pint32 )
  | Pintofbint Pnativeint
  | Pintofbint Pint32
  | Pfloatofint 
    -> 
    begin match args with 
      | [e] -> e 
      | _ -> assert false 
    end
  | Pintofbint Pint64
    -> Js_long.to_int32 args
  | Pabsfloat -> 
    begin match args with 
      | [e] ->
        E.math "abs" [e]
        (* GCC treat built-ins like Math in a dirfferent way*)
      | _ -> assert false
      end
  | Pnot ->
    begin match args with
      | [e] ->  E.not  e 
      | _ -> assert false
    end
  | Poffsetint n ->
    begin match args with
      | [e] ->  E.int32_add  e (E.small_int  n)
      | _ -> assert false
    end
  | Poffsetref n ->
    begin match args with
      | [e] -> 
        let v = (Js_of_lam_block.field Fld_na e 0l) in
        E.assign  v (E.int32_add v (E.small_int  n))
      | _ -> assert false
    end

  | Psequand -> (* TODO: rhs is possibly a tail call *)
    begin match args with
      | [e1;e2] ->
        E.and_   e1  e2
      | _ -> assert false
    end
  | Psequor -> (* TODO: rhs is possibly a tail call *)
    begin match args with
      | [e1;e2] ->
        E.or_  e1  e2
      | _ -> assert false
    end
  | Pisout -> 
    begin match args with 
      (* predicate: [x > range  or x < 0 ]
         can be simplified if x is positive , x > range
         if x is negative, fine, its uint is for sure larger than range,
         the output is not readable, we might change it back.

         Note that if range is small like [1], then the negative of 
         it can be more precise (given integer)
         a normal case of the compiler is  that it will do a shift 
         in the first step [ (x - 1) > 1 or ( x - 1 ) < 0 ]
      *)
      | [range; e] -> E.is_out e range
      | _ -> assert false
    end
  | Pbytes_of_string -> 
    begin 
      (* TODO: write a js primitive  - or is it necessary ?
         if we have byte_get/string_get
         still necessary, since you can set it now.
      *)
      match args with 
      |[e] -> Js_of_lam_string.bytes_of_string e
      | _ -> assert false
    end
  | Pbytes_to_string  -> 
    begin 
      match args with 
      |[e] -> Js_of_lam_string.bytes_to_string e 
      | _ -> assert false
    end
  | Pstringlength ->
    begin match args with
      | [e] -> E.string_length e 
      | _ -> assert false 
    end
  | Pbyteslength  -> 
    begin match args with
      | [e] -> E.bytes_length e 
      | _ -> assert false 
    end
  (* This should only be Pbyteset(u|s), which in js, is an int array 
     Bytes is an int array in javascript
  *)
  | Pbytessetu
  | Pbytessets -> 
      begin match args with
      | [e;e0;e1] -> decorate_side_effect cxt 
            (Js_of_lam_string.set_byte e e0 e1)

      | _ -> assert false
      end
  | Pbytesrefu ->
      begin match args with
      | [e;e1] -> Js_of_lam_string.ref_byte e e1
      | _ -> assert false
      end
    
  | Pbytesrefs ->
    begin match args with
      | [e ; e1] ->
        if !Clflags.fast then
          Js_of_lam_string.ref_byte e e1
        else E.runtime_call Js_config.bytes "get" args            
      | _ -> assert false         
    end
   (* For bytes and string, they both return [int] in ocaml 
       we need tell Pbyteref from Pstringref
       1. Pbyteref -> a[i]
       2. Pstringref -> a.charCodeAt (a[i] is wrong)
    *)
  | Pstringrefu  ->
      begin match args with
      | [e;e1] -> Js_of_lam_string.ref_string e e1 
      | _ -> assert false
      end

  | Pstringrefs ->
      begin match args with
        | [e;e1] ->
          if !Clflags.fast then
            Js_of_lam_string.ref_string e e1             
          else       
            E.runtime_call Js_config.string "get" args          
      | _ -> assert false
      end
    
  | Pgetglobal i   -> 
    (* TODO -- check args, case by case -- 
        1. include Array --> let include  = Array 
        2. get exception
    *)
    Lam_compile_global.get_exp (i,env,true)
  
    (** only when Lapply -> expand = true*)
  | Praise  -> assert false (* handled before here *)

(* Runtime encoding relevant *)
  | Parraylength Pgenarray
  | Parraylength Paddrarray
  | Parraylength Pintarray
  | Parraylength Pfloatarray  -> 
      begin match args with 
      | [e] -> E.array_length e 
      | _ -> assert false
      end
  | Psetfield (i, _, field_info) -> 
      begin match args with 
      | [e0;e1] ->  (** RUNTIME *)
          decorate_side_effect cxt 
            (Js_of_lam_block.set_field field_info e0 (Int32.of_int i) e1)
            (*TODO: get rid of [E.unit ()]*)
      | _ -> assert false
      end
  | Psetfloatfield (i,field_info)
    -> (** RUNTIME --  RETURN VALUE SHOULD BE UNIT *)
      begin 
        match args with 
        | [e;e0] -> 
          decorate_side_effect cxt 
            (Js_of_lam_float_record.set_double_field field_info e (Int32.of_int i) e0 ) 
        | _ -> assert false
      end


  | Pfloatfield (i, field_info) -> (** RUNTIME *)
      begin 
        match args with 
        | [e] ->
          Js_of_lam_float_record.get_double_feild field_info e
            (Int32.of_int i) 
        | _ -> assert false 
      end
  | Parrayrefu _kind
  | Parrayrefs _kind ->  
      begin match args with
      | [e;e1] -> Js_of_lam_array.ref_array e e1 (* Todo: Constant Folding *)
      | _ -> assert false
      end
  | Pmakearray kind -> 
      Js_of_lam_array.make_array Mutable kind args 
  | Parraysetu _kind
  | Parraysets _kind -> 
      begin match args with (* wrong*)
      | [e;e0;e1] -> decorate_side_effect cxt @@ Js_of_lam_array.set_array  e e0 e1
      | _ -> assert false
      end
  | Pccall prim -> 
      Lam_compile_external_call.translate loc cxt prim args 
     (* Test if the argument is a block or an immediate integer *)
  | Pisint -> 
    begin 
      match args with 
      | [e] ->  E.is_type_number e 

      | _ ->   assert false
    end
  | Pctconst ct -> 
    begin
      match ct with 
      | Big_endian -> 
        if Sys.big_endian then  E.caml_true
        else E.caml_false
      | Word_size -> 
        E.small_int  Sys.word_size
      | Ostype_unix -> 
        if Sys.unix then E.caml_true else E.caml_false
      | Ostype_win32 -> 
        if Sys.win32 then E.caml_true else E.caml_false
      | Ostype_cygwin -> 
        if Sys.cygwin then E.caml_true else E.caml_false
    end
  | Psetglobal _  -> 
    assert false (* already handled *)
    (* assert false *)
  | Pduprecord ((Record_regular 
                | Record_float ),0)
  | Pduprecord ((Record_regular 
                | Record_float ),_) -> 
    begin match args with 
    | [e] -> Js_of_lam_record.copy e
    | _ -> assert false       
    end
  | Pbigarrayref (unsafe, dimension, kind, layout)
    -> 
    (* can be refined to 
       [caml_bigarray_float32_c_get_1]
       note that kind can be [generic]
       and layout can be [unknown],
       dimension is always available
    *)
    begin match dimension, kind, layout, unsafe with 
      | 1,  ( Pbigarray_float32 | Pbigarray_float64
            | Pbigarray_sint8 | Pbigarray_uint8
            | Pbigarray_sint16 | Pbigarray_uint16
            | Pbigarray_int32 | Pbigarray_int64
            | Pbigarray_caml_int | Pbigarray_native_int
            | Pbigarray_complex32 | Pbigarray_complex64), Pbigarray_c_layout, _
        -> 
        begin match args with
        | [x;indx] -> Js_of_lam_array.ref_array x indx
        | _ -> assert false
        end
    | _, _, _ ,_ -> 
      E.not_implemented ("caml_ba_get_" ^ string_of_int dimension )
      (* E.runtime_call Js_config.bigarray  *)
      (*   ("caml_ba_get_" ^ string_of_int dimension ) args  *)
    end
  | Pbigarrayset (unsafe, dimension, kind, layout)
    -> 
    begin match dimension, kind, layout, unsafe with 
      | 1,  ( Pbigarray_float32 | Pbigarray_float64
            | Pbigarray_sint8 | Pbigarray_uint8
            | Pbigarray_sint16 | Pbigarray_uint16
            | Pbigarray_int32 | Pbigarray_int64
            | Pbigarray_caml_int | Pbigarray_native_int
            | Pbigarray_complex32 | Pbigarray_complex64), Pbigarray_c_layout, _
        -> 
        begin match args with 
        | [x; index; value] -> 
          Js_of_lam_array.set_array x index value          
        | _ -> assert false
        end
      
      | _ , _, _,_ 
        -> 
        E.not_implemented
          ("caml_ba_set_" ^ string_of_int dimension )
        (* E.runtime_call Js_config.bigarray  *)
        (*   ("caml_ba_set_" ^ string_of_int dimension ) args  *)
    end

  | Pbigarraydim i
    -> 
    E.not_implemented ("caml_ba_dim_" ^ string_of_int i)
    (* E.runtime_call Js_config.bigarray *)
    (*   ("caml_ba_dim_" ^ string_of_int i) args        *)
  | Pbswap16 
    -> 
    E.runtime_call Js_config.int32 "caml_bswap16" args
  | Pbbswap Lambda.Pnativeint
  | Pbbswap Lambda.Pint32
    -> 
    E.runtime_call Js_config.int32 "caml_int32_bswap" args
  | Pbbswap Lambda.Pint64
    -> Js_long.swap args 
  | Pstring_load_16 unsafe
    -> E.runtime_call Js_config.string "caml_string_get16" args
  | Pstring_load_32 unsafe
    -> E.runtime_call Js_config.string "caml_string_get32" args
  | Pstring_load_64 unsafe
    -> Js_long.get64 args

  | Plazyforce
  (* | Plazyforce -> *)
  (*     let parm = Ident.create "prim" in *)
  (*     Lfunction(Curried, [parm], *)
  (*               Matching.inline_lazy_force (Lvar parm) Location.none) *)
  (* It is inlined, this should not appear here *)    
  | Pbittest 
  
  | Pstring_set_16 _
  | Pstring_set_32 _
  | Pstring_set_64 _
  | Pbigstring_load_16 _
  | Pbigstring_load_32 _
  | Pbigstring_load_64 _
  | Pbigstring_set_16 _
  | Pbigstring_set_32 _
  | Pbigstring_set_64 _
    -> 
      let comment = "Missing primitive" in       
      let s = Lam_util.string_of_primitive prim in
      let warn = Printf.sprintf  "%s: %s\n" comment s in
      Ext_log.warn __LOC__ "%s"  warn;
      (*we dont use [throw] here, since [throw] is an statement  *)        
      E.dump  Error [ E.str warn]



end
module Lam_exit_code : sig 
#1 "lam_exit_code.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)







val has_exit_code : (int -> bool ) -> Lam.t -> bool 

end = struct
#1 "lam_exit_code.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






let rec has_exit_code exits  (lam : Lam.t)  : bool = 
  match lam with
  | Lvar _
  | Lconst _ 
  | Lfunction _ (* static exit can not across function boundary *)
    -> false
  | Lapply {fn = l; args; _ } 
    -> has_exit_code exits l || List.exists (fun x -> has_exit_code exits x ) args 

  | Llet (_kind,_id,v,body) 
    -> has_exit_code exits v || has_exit_code exits body
  | Lletrec (binding,body) ->
    List.exists (fun (_, l) -> has_exit_code exits l ) binding ||
    has_exit_code exits body    
  | Lprim {args; _} 
    -> List.exists (fun x -> has_exit_code exits x) args
  | Lswitch (l,lam_switch) 
    -> has_exit_code exits l || has_exit_code_lam_switch exits lam_switch

  | Lstringswitch (l,ls,opt) -> 
    has_exit_code exits l ||
    List.exists (fun (_,l) -> has_exit_code exits l) ls ||
    (match opt with 
    | None -> false
    | Some x -> has_exit_code exits l )
  | Lstaticraise (v,ls) ->
      exits v ||    
    List.exists (has_exit_code exits) ls
  | Lstaticcatch (l,_,handler) 
    ->
    has_exit_code exits l || has_exit_code exits handler
  | Ltrywith (l,_, handler) 
    ->
    has_exit_code exits l || has_exit_code exits handler
  | Lifthenelse (a,b,c) 
    -> 
    has_exit_code exits a || has_exit_code exits b || has_exit_code exits c
  | Lsequence (a,b) 
    ->
    has_exit_code exits a || has_exit_code exits b
  | Lwhile (a,b) 
    ->
    has_exit_code exits a || has_exit_code exits b
  | Lfor (_,a,b,_dir,body) -> 
    has_exit_code exits a 
    || has_exit_code exits b
    || has_exit_code exits body
    
  | Lassign (_,a) 
    -> 
    has_exit_code exits a
  | Lsend (_,obj,l,ls,_loc) 
    -> 
    has_exit_code exits obj ||
    has_exit_code exits l ||
    List.exists (has_exit_code exits) ls
  | Lifused (_,b) 
    -> has_exit_code exits b

and has_exit_code_lam_switch exits (lam_switch : Lam.switch) = 
  match lam_switch with
   | { sw_numconsts = _; sw_consts; sw_numblocks = _ ; sw_blocks; sw_failaction } ->
     List.exists (fun (_,l) -> has_exit_code exits l) sw_consts ||
     List.exists (fun (_,l) -> has_exit_code exits l)  sw_blocks ||
     (match sw_failaction with 
     | None -> false 
     | Some x -> has_exit_code exits x)

end
module Lam_compile : sig 
#1 "lam_compile.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Compile single lambda IR to JS IR  *)

val compile_let : 
  Lambda.let_kind ->
  Lam_compile_defs.cxt -> 
  J.ident -> 
  Lam.t -> 
  Js_output.t

val compile_recursive_lets : Lam_compile_defs.cxt -> (Ident.t * Lam.t) list -> Js_output.t

val compile_lambda : Lam_compile_defs.cxt -> Lam.t -> Js_output.t

end = struct
#1 "lam_compile.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








open Js_output.Ops 

module E = Js_exp_make 

module S = Js_stmt_make  

let method_cache_id = ref 1 (*TODO: move to js runtime for re-entrant *)


(* assume outer is [Lstaticcatch] *)
let rec flat_catches acc (x : Lam.t)
  : (int * Lam.t * Ident.t  list ) list * Lam.t = 
  match x with 
  | Lstaticcatch( Lstaticcatch(l, (code,bindings), handler), (code1, bindings1),handler1) 
    when 
      not @@ Lam_exit_code.has_exit_code 
        (fun exit -> exit = code1 || List.exists (fun (c, _, _) -> c = exit ) acc ) handler
    -> 
    (* when handler does not have [exit code] which [code] belongs to collected,
       it is okay to merge
       *)
    flat_catches ( (code, handler,bindings) :: (code1,handler1,bindings1)  :: acc)  l
  | Lstaticcatch(l, (code, bindings), handler) ->
    (code,handler,bindings)::acc, l
    (* flat_catches ((code,handler,bindings)::acc) l  *)
  | _ -> acc, x

let flatten_caches  x = flat_catches [] x 

(* exception Not_an_expression *)

(* TODO:
    for expression generation, 
    name, should_return  is not needed,
    only jmp_table and env needed
*)
let translate_dispatch = ref (fun _ -> assert false)

type default_case = 
  | Default of Lam.t
  | Complete
  | NonComplete


let rec  
  get_exp_with_index (cxt : Lam_compile_defs.cxt) lam 
    ((id : Ident.t), (pos : int),env) : Js_output.t = 
  let f =   Js_output.handle_name_tail cxt.st cxt.should_return lam in    
  Lam_compile_env.find_and_add_if_not_exist (id,pos) env 
    ~not_found:(fun id -> 
        f (E.str ~pure:false (Printf.sprintf "Err %s %d %d" id.name id.flags pos))
        (* E.index m (pos + 1) *) (** shift by one *)
        (** This can not happen since this id should be already consulted by type checker *)
      )
    ~found:(fun {id; name; closed_lambda } ->
        match id, name, closed_lambda with 
        | {name = "Sys"; _}, "os_type" , _
          (** We drop the ability of cross-compiling
              the compiler has to be the same running 
          *)
          ->  f (E.str Sys.os_type)
        | _, _, Some lam 
          when Lam_util.not_function lam
          (* since it's only for alias, there is no arguments, 
             we should not inline function definition here, even though
             it is very small             
             TODO: add comment here, we should try to add comment for 
             cross module inlining             
          
             if we do too agressive inlining here: 

             if we inline {!List.length} which will call {!A_list.length}, 
             then we if we try inline {!A_list.length}, this means if {!A_list} 
             is rebuilt, this module should also be rebuilt,

             But if the build system is content-based, suppose {!A_list} 
             is changed, cmj files in {!List} is unchnaged, however, 
             {!List.length} call {!A_list.length} which is changed, since
             [ocamldep] only detect that we depend on {!List}, it will not 
             get re-built, then we are screwed.                   

             This is okay for stamp based build system.

             Another solution is that we add dependencies in the compiler

             -: we should not do functor application inlining in a 
                non-toplevel, it will explode code very quickly              
          *)               
          ->  
          compile_lambda cxt lam
        | _ -> 
          f (E.ml_var_dot id name)
      ) 
(* TODO: how nested module call would behave,
   In the future, we should keep in track  of if 
   it is fully applied from [Lapply]
   Seems that the module dependency is tricky..
   should we depend on [Pervasives] or not?

   we can not do this correctly for the return value, 
   however we can inline the definition in Pervasives
   TODO:
   [Pervasives.print_endline]
   [Pervasives.prerr_endline]
   @param id external module id 
   @param number the index of the external function 
   @param env typing environment
   @param args arguments 
 *)

and get_exp_with_args (cxt : Lam_compile_defs.cxt)  lam args_lambda
    (id : Ident.t) (pos : int) env : Js_output.t = 
  Lam_compile_env.find_and_add_if_not_exist (id,pos) env ~not_found:(fun id -> 
      (** This can not happen since this id should be already consulted by type checker 
          Worst case 
          {[
            E.index m (pos + 1)
          ]}
          shift by one (due to module encoding)
      *)
      (* Js_output.handle_block_return cxt.st cxt.should_return lam args_code @@  *)
      (* E.str ~pure:false  (Printf.sprintf "Err %s %d %d" *)
      (*                       id.name *)
      (*                       id.flags *)
      (*                       pos *)
      (*                    ) *)
      assert false 
    )

    ~found:(fun {id; name;arity; closed_lambda ; _} -> 
        let args_code, args = 
          List.fold_right 
            (fun (x : Lam.t) (args_code, args)  ->
               match x with 
               | Lprim {primitive = Pgetglobal i; args =  [];_ } -> 
                 (* when module is passed as an argument - unpack to an array
                     for the function, generative module or functor can be a function,
                     however it can not be global -- global can only module
                 *)

                 args_code, (Lam_compile_global.get_exp (i, env, true) :: args)
               | _ -> 
                 begin match compile_lambda {cxt with st = NeedValue; should_return = False} x with
                   | {block = a; value = Some b} -> 
                     (a @ args_code), (b :: args )
                   | _ -> assert false
                 end
            ) args_lambda ([], []) in

        match closed_lambda with 
        | Some (Lfunction{ params; body; _}) 
          when Ext_list.same_length params args_lambda -> 
          (* TODO: serialize it when exporting to save compile time *)
          let (_, param_map)  = 
            Lam_analysis.is_closed_with_map Ident_set.empty params body in
          compile_lambda cxt 
            (Lam_beta_reduce.propogate_beta_reduce_with_map cxt.meta param_map
               params body args_lambda)
        | _ ->  
          Js_output.handle_block_return cxt.st cxt.should_return lam args_code @@ 
          (match id, name,  args with 
           | {name = "Pervasives"; _}, "print_endline", ([ _ ] as args) ->  
             E.seq (E.dump Log args) E.unit
           | {name = "Pervasives"; _}, "prerr_endline", ([ _ ] as args) ->  
             E.seq (E.dump Error args) E.unit
           | _ -> 
             let rec aux (acc : J.expression)
                 (arity : Lam.function_arities) args (len : int)  =
               match arity, len with
               | _, 0 -> 
                 acc (** All arguments consumed so far *)
               | Determin (a, (x,_) :: rest, b), len   ->
                 let x = 
                   if x = 0 
                   then 1 
                   else x in (* Relax when x = 0 *)
                 if  len >= x 
                 then
                   let first_part, continue =  (Ext_list.take x args) in
                   aux
                     (E.call ~info:{arity=Full; call_info = Call_ml} acc first_part)
                     (Determin (a, rest, b))
                     continue (len - x)
                 else  acc 
               (* alpha conversion now? --
                  Since we did an alpha conversion before so it is not here
               *)
               | Determin (a, [], b ), _ ->
                 (* can not happen, unless it's an exception ? *)
                 E.call ~info:Js_call_info.dummy acc args
               | NA, _ ->
                 E.call ~info:Js_call_info.dummy acc args
             in
             aux (E.ml_var_dot id name) arity args (List.length args ))
      )

and  compile_let flag (cxt : Lam_compile_defs.cxt) id (arg : Lam.t) : Js_output.t =


  match flag, arg  with 
  |  let_kind, _  -> 
    compile_lambda {cxt with st = Declare (let_kind, id); should_return = False } arg 
(** 
    The second return values are values which need to be wrapped using 
   [caml_update_dummy] 
   
   Invariant:  jmp_table can not across function boundary,
       here we share env 

*)
and compile_recursive_let 
    (cxt : Lam_compile_defs.cxt)
    (id : Ident.t)
    (arg : Lam.t)   : Js_output.t * Ident.t list = 
  match arg with 
  |  Lfunction { kind; params; body; _}  -> 

    let continue_label = Lam_util.generate_label ~name:id.name () in
    (* TODO: Think about recursive value 
       {[
         let rec v = ref (fun _ ... 
                         )
       ]}
        [Alias] may not be exact 
    *)
    Js_output.handle_name_tail (Declare (Alias, id)) False arg
      (
        let ret : Lam_compile_defs.return_label = 
          {id; 
           label = continue_label; 
           params;
           immutable_mask = Array.make (List.length params) true;
           new_params = Ident_map.empty;
           triggered = false} in
        let output = 
          compile_lambda
            { cxt with 
              st = EffectCall;  
              should_return = True (Some ret );
              jmp_table = Lam_compile_defs.empty_handler_map}  body in
        if ret.triggered then 
          let body_block = Js_output.to_block output in
          E.ocaml_fun
            (* TODO:  save computation of length several times 
               Here we always create [ocaml_fun], 
               it will be renamed into [method] 
               when it is detected by a primitive
            *)
            ~immutable_mask:ret.immutable_mask
            (List.map (fun x -> 
                 try Ident_map.find x ret.new_params with  Not_found -> x)
                params)
            [
              S.while_ (* ~label:continue_label *)
                E.caml_true   
                (
                  Ident_map.fold
                    (fun old new_param  acc ->
                       S.define ~kind:Alias old (E.var new_param) :: acc) 
                    ret.new_params body_block
                )
            ]

        else            (* TODO:  save computation of length several times *)
          E.ocaml_fun params (Js_output.to_block output )
      ), [] 
  | Lprim {primitive = Pmakeblock (0, _, _) ; args =  ls}
    when List.for_all (function  | Lam.Lvar _  -> true | _ -> false) ls 
    ->
    (* capture cases like for {!Queue}
       {[let rec cell = { content = x; next = cell} ]}
    *)
    Js_output.of_block (
      S.define ~kind:Variable id (E.arr Mutable []) :: 
      (List.mapi (fun i x -> 
          match x with  
          | Lam.Lvar lid
            -> S.exp 
                 (Js_arr.set_array (E.var id) (E.int (Int32.of_int i)) (E.var lid))
          | _ -> assert false
         ) ls)
    ), []

  | Lprim{primitive = Pmakeblock _ ; _}   ->
    (* FIXME: also should fill tag *)
    (* Lconst should not appear here if we do [scc]
       optimization, since it's faked recursive value,
       however it would affect scope issues, we have to declare it first 
    *)
    (* Ext_log.err "@[recursive value %s/%d@]@." id.name id.stamp; *)
    begin
      match compile_lambda {cxt with st = NeedValue; should_return = False } arg with
      | { block = b; value = Some v} -> 
        (* TODO: check recursive value .. 
            could be improved for simple cases
        *)
        Js_output.of_block  
          (
            b  @ 
            [S.exp
               (E.runtime_call Js_config.obj_runtime "caml_update_dummy" 
                  [ E.var id;  v])]),
        [id]
      (* S.define ~kind:Variable id (E.arr Mutable [])::  *)
      | _ -> assert false 
    end
  | Lvar _   ->
    compile_lambda {cxt with st = Declare (Alias ,id); should_return = False } arg, []
  | _ -> 
    (* pathological case:
        fail to capture taill call?
       {[ let rec a = 
         if  g > 30 then .. fun () -> a ()
       ]}

        Neither  below is not allowed in ocaml:
       {[
         let rec v = 
           if sum 0 10 > 20 then 
             1::v 
           else 2:: v
       ]}
       {[
         let rec v = 
           if sum 0 10 > 20 then 
             fun _ -> print_endline "hi"; v ()
           else 
             fun _-> print_endline "hey"; v ()
       ]}
    *)
    compile_lambda {cxt with st = Declare (Alias ,id); should_return = False } arg, []

and compile_recursive_lets cxt id_args : Js_output.t = 
  let output_code, ids  = List.fold_right
      (fun (ident,arg) (acc, ids) -> 
         let code, declare_ids  = compile_recursive_let cxt ident arg in
         (code ++ acc, declare_ids @ ids )
      )  id_args (Js_output.dummy, [])
  in
  match ids with 
  | [] -> output_code
  | _ ->  
    (Js_output.of_block  @@
     List.map (fun id -> S.define ~kind:Variable id (E.dummy_obj ())) ids ) 
    ++  output_code

and compile_general_cases : 
  'a . 
  ('a -> J.expression) ->
  (J.expression -> J.expression -> J.expression) -> 
  Lam_compile_defs.cxt -> 
  (?default:J.block ->
   ?declaration:Lambda.let_kind * Ident.t  -> 
   _ -> 'a J.case_clause list ->  J.statement) -> 
  _ -> 
  ('a * Lam.t) list -> default_case -> J.block 
  = fun f eq cxt switch v table default -> 
    let wrap (cxt : Lam_compile_defs.cxt) k =
      let cxt, define =
        match cxt.st with 
        | Declare (kind, did)
          -> 
          {cxt with st = Assign did}, Some (kind,did)
        | _ -> cxt, None
      in
      k cxt  define 
    in
    match table, default with 
    | [], Default lam ->  
      Js_output.to_block  (compile_lambda cxt lam)
    | [], (Complete | NonComplete) ->  []
    | [(id,lam)],Complete -> 
      (* To take advantage of such optimizations, 
          when we generate code using switch, 
          we should always have a default,
          otherwise the compiler engine would think that 
          it's also complete
      *)
      Js_output.to_block @@ compile_lambda cxt lam 
    | [(id,lam)], NonComplete 
      ->
      wrap cxt @@ fun cxt define  ->
      [S.if_ ?declaration:define (eq v (f id) )
         (Js_output.to_block @@ compile_lambda cxt lam )]

    | ([(id,lam)], Default x) | ([(id,lam); (_,x)], Complete)
      ->
      wrap cxt  @@ fun cxt define -> 
      let else_block = Js_output.to_block (compile_lambda cxt x) in
      let then_block = Js_output.to_block (compile_lambda cxt lam)  in
      [ S.if_ ?declaration:define (eq v (f id) )
          then_block
          ~else_:else_block
      ]
    | _ , _ -> 
      (* TODO: this is not relevant to switch case
          however, in a subset of switch-case if we can analysis 
          its branch are the same, we can propogate which 
          might encourage better inlining strategey
          ---
          TODO: grouping can be delayed untile JS IR
      *)
      (*TOOD: disabled temporarily since it's not perfect yet *)
      wrap cxt @@ fun cxt declaration  ->
      let default =
        match default with
        | Complete -> None
        | NonComplete -> None
        | Default lam -> Some (Js_output.to_block  (compile_lambda cxt lam))
      in
      let body = 
        table 
        |> Ext_list.stable_group (fun (_,lam) (_,lam1) -> Lam_analysis.eq_lambda lam lam1)
        |> Ext_list.flat_map 
          (fun group -> 
             group 
             |> Ext_list.map_last 
               (fun last (x,lam) -> 
                  if last 
                  then {J.case =  x; body = Js_output.to_break_block (compile_lambda cxt lam) }
                  else { case = x; body = [],false }))
          (* TODO: we should also group default *)
          (* The last clause does not need [break]
              common break through, *)

      in
      [switch ?default ?declaration v body] 

and compile_cases cxt = compile_general_cases (fun x -> E.small_int  x) E.int_equal cxt 
    (fun  ?default ?declaration e clauses    -> S.int_switch ?default  ?declaration e clauses)

and compile_string_cases cxt = compile_general_cases E.str E.string_equal cxt 
    (fun  ?default ?declaration e clauses    -> S.string_switch ?default  ?declaration e clauses)
(* TODO: optional arguments are not good 
    for high order currying *)
and
  compile_lambda
    ({st ; should_return; jmp_table; meta = {env ; _} } as cxt : Lam_compile_defs.cxt)
    (lam : Lam.t)  : Js_output.t  =
  begin
    match lam with 
    | Lfunction{ kind; params; body} ->
      Js_output.handle_name_tail st should_return lam 
        (E.ocaml_fun
           params
           (* Invariant:  jmp_table can not across function boundary,
              here we share env
           *)
           (Js_output.to_block 
              ( compile_lambda
                  { cxt with st = EffectCall;  
                             should_return = True None; (* Refine*)
                             jmp_table = Lam_compile_defs.empty_handler_map}  body)))


    | Lapply{
        fn = Lapply{ fn = an; args =  args'; status = App_na ; };
        args;  
        status = App_na; loc }
      ->    
      (* After inlining we can generate such code, 
         see {!Ari_regress_test}         
      *)      
      compile_lambda  cxt  
        (Lam.apply an (args' @ args)  loc  App_na )
    (* External function calll *)
    | Lapply{ fn = 
                Lprim{primitive = Pfield (n,_); 
                      args = [ Lprim {primitive = Pgetglobal id; args = []}];_};
             args = args_lambda;
             status = App_na | App_ml_full} ->
      (* Note we skip [App_js_full] since [get_exp_with_args] dont carry 
         this information, we should fix [get_exp_with_args]
      *)
      get_exp_with_args cxt lam  args_lambda id n  env


    | Lapply{ fn; args = args_lambda;   status} -> 
      (* TODO: --- 
         1. check arity, can be simplified for pure expression
         2. no need create names
      *)
      begin 
        let [@warning "-8" (* non-exhaustive pattern*)] (args_code, fn_code:: args) = 
          List.fold_right (fun (x : Lam.t) (args_code, fn_code )-> 
              match x with             
              | Lprim {primitive = Pgetglobal ident; args =  []} -> 
                (* when module is passed as an argument - unpack to an array
                    for the function, generative module or functor can be a function, 
                    however it can not be global -- global can only module 
                *)
                args_code, Lam_compile_global.get_exp  (ident, env,true) :: fn_code
              | _ ->
                begin
                  match compile_lambda 
                          {cxt with st = NeedValue ; should_return =  False} x with
                  | {block = a; value =  Some b} -> a @ args_code , b:: fn_code 
                  | _ -> assert false
                end
            ) (fn::args_lambda) ([],[]) in


        begin
          match fn, should_return with
          | (Lvar id',
             True (Some ({id;label; params; _} as ret))) when Ident.same id id' ->


            (* Ext_log.err "@[ %s : %a tailcall @]@."  cxt.meta.filename Ident.print id; *)
            ret.triggered <- true;
            (* Here we mark [finished] true, since the continuation 
                does not make sense any more (due to that we have [continue])
                TODO: [finished] is not a meaningful name, we should use [truncate] 
                to mean the following statement should be truncated
            *)
            (* 
                actually, there is no easy way to determin 
                if the argument depends on an expresion, since 
                it can be a function, then it may depend on anything
                http://caml.inria.fr/pub/ml-archives/caml-list/2005/02/5727b4ecaaef6a7a350c9d98f5f68432.en.html
                http://caml.inria.fr/pub/ml-archives/caml-list/2005/02/fe9bc4e23e6dc8c932c8ab34240ff195.en.html

            *)
            (* TODO: use [fold]*)            
            let block =  args_code @
                        (
                          let (_,assigned_params,new_params) = 
                            List.fold_left2 (fun (i,assigns,new_params) param (arg : J.expression) ->
                                match arg with
                                | {expression_desc = Var (Id x); _} when Ident.same x param ->
                                  (i + 1, assigns, new_params)
                                | _ ->
                                  let new_param, m  = 
                                    match Ident_map.find  param ret.new_params with 
                                    | exception Not_found -> 
                                      ret.immutable_mask.(i)<- false;
                                      let v = Ext_ident.create ("_"^param.Ident.name) in
                                      v, (Ident_map.add param v new_params) 
                                    | v -> v, new_params  in
                                  (i+1, (new_param, arg) :: assigns, m)
                              ) (0, [], Ident_map.empty) params args  in 
                          let () = ret.new_params <- Ident_map.(merge_disjoint new_params ret.new_params) in
                          assigned_params |> List.map (fun (param, arg) -> S.assign param arg))
                         @
                        [S.continue ()(* label *)]
                         (* Note true and continue needed to be handled together*)
            in
            begin
              (* Ext_log.dwarn __LOC__ "size : %d" (List.length block); *)
              Js_output.of_block  ~finished:True block 
            end

 

          (* match assigned_params with *)
          (* | [] ->  [] *)
          (* | [param,arg] -> [S.assign param arg ] *)
          (* | _ -> *)
          (*    let arg_map = Ident_map.of_list assigned_params in *)
          (*    match Lam_util.sort_dag_args arg_map with *)
          (*    | Some args -> *)
          (*        List.map (fun a -> S.assign a (Ident_map.find a arg_map )) args *)
          (*    | None -> *)
          (*        let renamed_params_args = *)
          (*          assigned_params |> *)
          (*          List.map (fun (param, arg) -> (param, Ident.rename param, arg )) *)
          (*        in *)
          (*        List.map (fun (param, param2, arg) -> *)
          (*          S.declare param2 arg *)
          (*                 ) renamed_params_args *)
          (*        @ *)
          (*          List.map (fun (param, param2, _) -> *)
          (*            S.assign param (E.var param2) *)
          (*                   )  renamed_params_args *)
          (*  Js_output.handle_block_return st should_return lam   *)
          (* (E.call fn_code args)  *)
          | _ -> 

            Js_output.handle_block_return st should_return lam args_code 
              (E.call ~info:(match fn, status with 
                   | _,  App_ml_full -> 
                     {arity = Full ; call_info = Call_ml}
                   | _,  App_js_full -> 
                     {arity = Full ; call_info = Call_na}
                   | _,   App_na -> 
                     {arity = NA; call_info = Call_ml }
                 ) fn_code args) 
        end;
      end


    | Llet (let_kind,id,arg, body) ->
      (* Order matters..  see comment below in [Lletrec] *)
      let args_code =
        compile_let  let_kind cxt id arg  in 
      args_code ++
      compile_lambda  cxt  body

    | Lletrec (id_args, body) -> 
      (* There is a bug in our current design, 
         it requires compile args first (register that some objects are jsidentifiers)
         and compile body wiht such effect.
         So here we should compile [id_args] first, then [body] later.
         Note it has some side effect over cache number as well, mostly the value of
         [Caml_primitive["caml_get_public_method"](x,hash_tab, number)]

         To fix this, 
         1. scan the lambda layer first, register js identifier before proceeding
         2. delay the method call into javascript ast
      *)
      let v =  compile_recursive_lets cxt  id_args in v ++ compile_lambda cxt  body

    | Lvar id -> Js_output.handle_name_tail st  should_return lam (E.var id )
    | Lconst c -> 
      Js_output.handle_name_tail st should_return lam (Lam_compile_const.translate c)

    | Lprim {primitive = Pfield (n,_); 
             args = [ Lprim {primitive = Pgetglobal id; args = [] ; _}]; _} 
      -> (* should be before Pgetglobal *)
        get_exp_with_index cxt lam  (id,n, env)

    | Lprim {primitive = Praise ; args =  [ e ]; _} -> 
      begin
        match compile_lambda {
            cxt with should_return = False; st = NeedValue} e with 
        | {block = b; value =  Some v} -> 

          Js_output.make (b @ [S.throw v])
            ~value:E.undefined ~finished:True
        (* FIXME -- breaks invariant when NeedValue, reason is that js [throw] is statement 
           while ocaml it's an expression, we should remove such things in lambda optimizations
        *)
        | {value =  None; _} -> assert false 
      end
    | Lprim{primitive = Psequand ; args =  [l;r] ; _}
      ->
      begin match cxt with 
        | {should_return = True _ } 
          (* Invariant: if [should_return], then [st] will not be [NeedValue] *)
          ->
          compile_lambda cxt (Lam.sequand  l r )
        | _ -> 
          let l_block,l_expr = 
            match compile_lambda {cxt with st = NeedValue; should_return = False} l with 
            | {block = a; value = Some b} -> a, b
            | _ -> assert false 
          in
          let r_block, r_expr = 
            match compile_lambda {cxt with st = NeedValue; should_return = False} r with
            | {block = a; value = Some b} -> a, b
            | _ -> assert false 
          in
          let args_code =  l_block @ r_block  in
          let exp =  E.and_ l_expr r_expr  in
          Js_output.handle_block_return st should_return lam args_code exp           
      end

    | Lprim {primitive = Psequor; args =  [l;r]}
      ->
      begin match cxt with
        | {should_return = True _ }
          (* Invariant: if [should_return], then [st] will not be [NeedValue] *)
          ->
          compile_lambda cxt @@ Lam.sequor l r
        | _ ->
          let l_block,l_expr =
            match compile_lambda {cxt with st = NeedValue; should_return = False} l with
            | {block = a; value = Some b} -> a, b
            | _ -> assert false
          in
          let r_block, r_expr =
            match compile_lambda {cxt with st = NeedValue; should_return = False} r with
            | {block = a; value = Some b} -> a, b
            | _ -> assert false
          in
          let args_code =  l_block @ r_block  in
          let exp =  E.or_ l_expr r_expr  in
          Js_output.handle_block_return st should_return lam args_code exp
      end
    | Lprim {primitive = Pdebugger ; _}
      -> 
      (* [%bs.debugger] guarantees that the expression does not matter 
         TODO: make it even safer      *)
        Js_output.handle_block_return st should_return lam [S.debugger] E.unit



    (* TODO: 
       check the arity of fn before wrapping it 
       we need mark something that such eta-conversion can not be simplified in some cases 
    *)

    | Lprim {primitive = Pjs_unsafe_downgrade (name,loc); 
             args = [obj]}
      when not (Ext_string.ends_with name Literals.setter_suffix) 
      -> 
      (**
         either a getter {[ x #. height ]} or {[ x ## method_call ]}
      *)
      let property =  Lam_methname.translate ~loc name  in
      begin 
        match compile_lambda {cxt with st = NeedValue; should_return = False} obj
        with 
        | {block; value = Some b } -> 
          let blocks, ret  = 
            if block = [] then [],  E.dot b property
            else 
              (match Js_ast_util.named_expression b  with 
               | None -> block,  E.dot b property
               | Some (x, b) ->  
                 (block @ [x]),  E.dot (E.var b) property
              )
          in 
          Js_output.handle_block_return st should_return lam 
            blocks ret 
        | _ -> assert false 
      end
    | Lprim {primitive = Pjs_fn_run arity;  args = args_lambda}
      ->
      (* 1. prevent eta-conversion
         by using [App_js_full]
         2. invariant: `external` declaration will guarantee
         the function application is saturated
         3. we need a location for Pccall in the call site
      *)

        begin match args_lambda with  
        | [Lprim{
            primitive = 
              Pjs_unsafe_downgrade(method_name,loc);
            args = [obj]} as fn;
           arg]
          -> 
          begin 
            let obj_block = 
              compile_lambda {cxt with st = NeedValue; should_return = False} obj
            in 
            let value_block = 
              compile_lambda {cxt with st = NeedValue; should_return = False} arg
            in 
            let cont block0 block1 obj_code = 
              Js_output.handle_block_return st should_return lam 
                (
                  match obj_code with
                  | None -> block0 @ block1
                  | Some obj_code -> block0 @ obj_code :: block1
                )
            in 
            match obj_block, value_block with 
            | {block = block0; value = Some obj }, 
              {block = block1; value = Some value}
              ->
               if  Ext_string.ends_with method_name Literals.setter_suffix then 
                let property =
                  Lam_methname.translate ~loc @@ 
                  String.sub method_name 0 
                    (String.length method_name - Literals.setter_suffix_len) in 
                match Js_ast_util.named_expression  obj with
                  | None ->
                    cont block0 block1 None (E.assign (E.dot obj property) value)
                  | Some (obj_code, obj)
                    ->
                    cont block0 block1 (Some obj_code)
                      (E.assign (E.dot (E.var obj) property) value)
              else 
                compile_lambda cxt
                  (Lam.apply fn [arg]  
                     Location.none (* TODO *) App_js_full)
            | _ -> 
              assert false 
          end

        | fn :: rest -> 
          compile_lambda cxt 
            (Lam.apply fn rest 
               Location.none (*TODO*)
               App_js_full)
        | _ -> assert false 
        end
    | Lprim {primitive = Pjs_fn_runmethod arity ; args }
      -> 
      begin match args with 
        | (Lprim{primitive = Pjs_unsafe_downgrade (name,loc);
                 args = [ _ ]} as fn) 
          :: _obj
          :: rest -> 
        (* assert (Ident.same id2 id) ;  *)
        (* we ignore the computation of [_obj], 
           since our ast writer 
           {[ obj#.f (x,y)
           ]}
           -->
           {[ runmethod2 f obj#.f x y]}           
        *)
        compile_lambda cxt (Lam.apply fn rest loc App_js_full)
      | _ -> assert false               
      end
    | Lprim {primitive = Pjs_fn_method arity;  args = args_lambda} -> 
      begin match args_lambda with 
        | [Lfunction{arity = len; kind; params; body} ] 
          when len = arity -> 
          Js_output.handle_block_return 
            st
            should_return             
            lam 
            []
            (E.method_
             params
             (* Invariant:  jmp_table can not across function boundary,
                here we share env
             *)
             (Js_output.to_block 
                ( compile_lambda
                    { cxt with st = EffectCall;  
                               should_return = True None; 
                               jmp_table = Lam_compile_defs.empty_handler_map} 
                    body)))
        | _ -> assert false 
      end


    | Lprim {primitive = Pjs_fn_make arity;  args = args_lambda} -> 

        begin match args_lambda with 
          | [fn] -> 
            if arity = 0 then 
              (* 
                Invariant: mk0 : (unit -> 'a0) -> 'a0 t 
                TODO: this case should be optimized, 
                we need check where we handle [arity=0] 
                as a special case -- 
                if we do an optimization before compiling
                into lambda

                 {[Fn.mk0]} is not intended for use by normal users

                 so we assume [Fn.mk0] is only used in such cases
                 {[
                   Fn.mk0 (fun _ -> .. )
                 ]}
                 when it is passed as a function directly
              *)
              begin match fn with 
                | Lfunction {params =  [_]; body}
                  ->
                  compile_lambda cxt 
                    (Lam.function_ 
                       ~arity:0 
                       ~kind:Curried
                       ~params:[]
                       ~body)
                | _ -> 

                  compile_lambda cxt  
                    (Lam.function_ ~arity:0 
                       ~kind:Curried ~params:[] 
                       ~body:(
                         Lam.apply fn
                           [Lam.unit]
                           Location.none App_na
                       ))
              end
            else 
              begin match fn with
                | Lam.Lfunction{arity = len; kind; params = args; body}
                  ->
                  if len = arity then
                    compile_lambda cxt fn 
                  else if len > arity then 
                    let params, rest  = Ext_list.take arity args  in 
                    compile_lambda cxt 
                      (Lam.function_ 
                         ~arity
                         ~kind ~params
                         ~body:(Lam.function_ ~arity:(len - arity)
                                  ~kind ~params:rest ~body)
                      )
                  else 
                    compile_lambda cxt 
                      (Lam_util.eta_conversion arity 
                         Location.none App_na
                         fn  [] )
                (* let extra_args = Ext_list.init (arity - len) (fun _ ->   (Ident.create Literals.param)) in *)
                (* let extra_lambdas = List.map (fun x -> Lambda.Lvar x) extra_args in *)
                (* Lambda.Lfunction (kind, extra_args @ args , body ) *)
                (*TODO: can be optimized ?
                  {[\ x y -> (\u -> body x) x y]}
                  {[\u x -> body x]}        
                  rewrite rules 
                  {[
                    \x -> body 
                          --
                          \y (\x -> body ) y 
                  ]}
                  {[\ x y -> (\a b c -> g a b c) x y]}
                  {[ \a b -> \c -> g a b c ]}
                *)
                | _ -> 
                  compile_lambda cxt 
                    (Lam_util.eta_conversion arity
                       Location.none App_na  fn  [] )
              end
          | _ -> assert false 
        end
    | Lprim{primitive = prim; args =  args_lambda; loc} -> 
      let args_block, args_expr =
        Ext_list.split_map (fun (x : Lam.t) ->
            match compile_lambda {cxt with st = NeedValue; should_return = False} x 
            with 
            | {block = a; value = Some b} -> a,b
            | _ -> assert false ) args_lambda 

      in
      let args_code  = List.concat args_block in
      let exp  =  (* TODO: all can be done in [compile_primitive] *)
        Lam_compile_primitive.translate loc cxt  prim args_expr in
      Js_output.handle_block_return st should_return lam args_code exp  


    | Lsequence (l1,l2) ->
      let output_l1 = 
        compile_lambda {cxt with st = EffectCall; should_return =  False} l1 in
      let output_l2 = 
        compile_lambda cxt l2  in
       output_l1 ++ output_l2


    | Lifthenelse(p,t_br,f_br) ->
      (*
         This should be optimized in lambda layer 
         (let (match/1038 = (apply g/1027 x/1028))
         (catch
         (stringswitch match/1038
         case "aabb": 0
         case "bbc": 1
         default: (exit 1))
         with (1) 2))
      *)
      begin 
        match compile_lambda {cxt with st = NeedValue ; should_return = False } p with 
        | {block = b; value =  Some e} ->
          (match st, should_return, 
                 compile_lambda {cxt with st= NeedValue}  t_br, 
                 compile_lambda {cxt with st= NeedValue}  f_br with 
          | NeedValue, _, 
            {block = []; value =  Some out1}, 
            {block = []; value =  Some out2} -> (* speical optimization *)
            Js_output.make b ~value:(E.econd e out1 out2)
          | NeedValue, _, _, _  -> 
            (* we can not reuse -- here we need they have the same name, 
                   TODO: could be optimized by inspecting assigment statement *)
            let id = Ext_ident.gen_js () in
            (match
               compile_lambda  {cxt with st = Assign id} t_br,
               compile_lambda {cxt with st = Assign id} f_br
             with
             | out1 , out2 -> 
               Js_output.make 
                 (S.declare_variable ~kind:Variable id :: b @ [
                     S.if_ e 
                       (Js_output.to_block out1) 
                       ~else_:(Js_output.to_block out2 )
                   ])
                 ~value:(E.var id)
            )

          | Declare (kind,id), _, 
            {block = []; value =  Some out1},
            {block = []; value =  Some out2} ->  
            (* Invariant: should_return is false*)
            Js_output.make [
              S.define ~kind id (E.econd e out1 out2) ]
          | Declare (kind, id), _, _, _ ->
            Js_output.make 
              ( b @ [
                   S.if_ ~declaration:(kind,id) e 
                     (Js_output.to_block @@ 
                      compile_lambda {cxt with st = Assign id}  t_br)
                     ~else_:(Js_output.to_block @@  
                             (compile_lambda {cxt with st = Assign id} f_br))
                 ])

          | Assign id, _ , 
            {block = []; value =  Some out1}, 
            {block = []; value =  Some out2} ->  
            (* Invariant:  should_return is false *)
            Js_output.make [S.assign id (E.econd e out1 out2)]
          | EffectCall, True _ , 
            {block = []; value =  Some out1}, 
            {block = []; value =  Some out2} ->
            Js_output.make [S.return  (E.econd e  out1 out2)] ~finished:True
              (* see PR#83 *)
          | EffectCall, False , {block = []; value =  Some out1}, 
            {block = []; value =  Some out2} ->
            begin
              match Js_exp_make.extract_non_pure out1 ,
                    Js_exp_make.extract_non_pure out2 with
              | None, None -> Js_output.make b
              | Some out1, Some out2 -> 
                Js_output.make b  ~value:(E.econd e  out1 out2)
              | Some out1, None -> 
                Js_output.make (b @ [S.if_ e  [S.exp out1]])
              | None, Some out2 -> 
                Js_output.make @@
                b @ [S.if_ (E.not e)
                       [S.exp out2]
                    ]
            end
          | EffectCall , False , {block = []; value = Some out1}, _ -> 
            (* assert branch 
                TODO: here we re-compile two branches since
                its context is different -- could be improved
            *)
            if Js_analyzer.no_side_effect_expression out1 then 
              Js_output.make
                (b @[ S.if_ (E.not e)
                        (Js_output.to_block @@
                         (compile_lambda cxt f_br))])
            else 
              Js_output.make 
                (b @[S.if_ e 
                       (Js_output.to_block 
                        @@ compile_lambda cxt t_br)
                       ~else_:(Js_output.to_block @@  
                               (compile_lambda cxt f_br))]
                )

          | EffectCall , False , _, {block = []; value = Some out2} -> 
            let else_ = 
              if  Js_analyzer.no_side_effect_expression out2 then  
                None 
              else 
                Some (
                  Js_output.to_block @@
                  compile_lambda cxt f_br) in 
            Js_output.make 
              (b @[S.if_ e 
                     (Js_output.to_block @@
                      compile_lambda cxt t_br)
                     ?else_])


          | (Assign _ | EffectCall), _, _, _  ->
            let then_output = 
              Js_output.to_block @@ 
              (compile_lambda cxt  t_br) in
            let else_output = 
              Js_output.to_block @@ 
              (compile_lambda cxt f_br) in
            Js_output.make (b @ [
                S.if_ e 
                  then_output
                  ~else_:else_output
              ]))
        | _ -> assert false 
      end
    | Lstringswitch(l, cases, default) -> 

      (* TODO might better optimization according to the number of cases  
          Be careful: we should avoid multiple evaluation of l,
          The [gen] can be elimiated when number of [cases] is less than 3
      *)
      begin
        match compile_lambda {cxt with should_return = False ; st = NeedValue} l 
        with
        | {block ; value =  Some e}  -> 
          (* when should_return is true -- it's passed down 
             otherwise it's ok *)
          let default = 
            match default with 
            | Some x -> Default x 
            | None -> Complete in
          begin
            match st with 
            (* TODO: can be avoided when cases are less than 3 *)
            | NeedValue -> 
              let v = Ext_ident.gen_js () in 
              Js_output.make (block @ 
                              compile_string_cases 
                                {cxt with st = Declare (Variable, v)}
                                e cases default) ~value:(E.var v)
            | _ -> 
              Js_output.make (block @ compile_string_cases  cxt e cases default)  end

        | _ -> assert false 
      end
    | Lswitch(lam,
              {sw_numconsts; 
               sw_consts;
               sw_numblocks;
               sw_blocks;
               sw_failaction = default }) 
      -> 
      (* TODO: if default is None, we can do some optimizations
          Use switch vs if/then/else

          TODO: switch based optimiztion - hash, group, or using array,
                also if last statement is throw -- should we drop remaining
                statement?
      *)
      let default : default_case  = 
        match default with 
        | None -> Complete 
        | Some x -> Default x in
      let compile_whole  ({st; _} as cxt  : Lam_compile_defs.cxt ) =
        begin
          match sw_numconsts, sw_numblocks, 
                compile_lambda {cxt with should_return = False; st = NeedValue}
                  lam with 
          | 0 , _ , {block; value =  Some e}  ->
            compile_cases cxt (E.tag e )  sw_blocks default
          | _, 0, {block; value =  Some e} ->  
            compile_cases cxt e  sw_consts default
          | _, _,  { block; value =  Some e} -> (* [e] will be used twice  *)
            let dispatch e = 
              [
                S.if_ 
                  (E.is_type_number e )
                  (compile_cases cxt e sw_consts default)
                  (* default still needed, could simplified*)
                  ~else_:(
                    (compile_cases  cxt (E.tag e ) sw_blocks default ))] in 
            begin
              match e.expression_desc with 
              | J.Var _  -> dispatch e  
              | _ -> 
                let v = Ext_ident.gen_js () in  
                (* Necessary avoid duplicated computation*)
                (S.define ~kind:Variable v e ) ::  dispatch (E.var v)
            end
          | _, _, {value =  None; _}  -> assert false 
        end in
      begin
        match st with  (* Needs declare first *)
        | NeedValue -> 
          (* Necessary since switch is a statement, we need they return 
             the same value for different branches -- can be optmized 
             when branches are minimial (less than 2)
          *)
          let v = Ext_ident.gen_js () in
          Js_output.make (S.declare_variable ~kind:Variable v   :: compile_whole {cxt with st = Assign v})
            ~value:(E.var  v)

        | Declare (kind,id) -> 
          Js_output.make (S.declare_variable ~kind id
                          :: compile_whole {cxt with st = Assign id} )
        | EffectCall | Assign _  -> Js_output.make (compile_whole cxt)
      end

    | Lstaticraise(i, largs) ->  (* TODO handlding *largs*)
      (* [i] is the jump table, [largs] is the arguments passed to [Lstaticcatch]*)
      begin
        match Lam_compile_defs.HandlerMap.find i cxt.jmp_table  with 
        | {exit_id; args ; order_id} -> 
          let args_code  =
            (Js_output.concat @@ List.map2 (
                fun (x : Lam.t) (arg : Ident.t) ->
                  match x with
                  | Lvar id -> 
                    Js_output.make [S.assign arg (E.var id)]

                  | _ -> (* TODO: should be Assign -- Assign is an optimization *)
                    compile_lambda {cxt with st = Assign arg ; should_return =  False} x 
              ) largs (args : Ident.t list)) 
          in
          args_code ++ (* Declared in [Lstaticraise ]*)
          Js_output.make [S.assign exit_id (E.small_int  order_id)]
            ~value:E.undefined
        | exception Not_found ->
          Js_output.make [S.unknown_lambda ~comment:"error" lam]
          (* staticraise is always enclosed by catch  *)
      end
    (* Invariant: code can not be reused 
        (catch l with (32)
        (handler))
        32 should not be used in another catch
        Assumption: 
        This is true in current ocaml compiler
        currently exit only appears in should_return position relative to staticcatch
        if not we should use ``javascript break`` or ``continue``
    *)
    | Lstaticcatch _  -> 
      let code_table, body =  flatten_caches lam in

      let exit_id =   Ext_ident.gen_js ~name:"exit" () in
      let exit_expr = E.var exit_id in
      let bindings = Ext_list.flat_map (fun (_,_,bindings) -> bindings) code_table in

      (* compile_list name l false (\*\) *)
      (* if exit_code_id == code 
         handler -- ids are not useful, since 
         when compiling `largs` we will do the binding there
         - when exit_code is undefined internally, 
           it should PRESERVE  ``tail`` property
         - if it uses `staticraise` only once 
           or handler is minimal, we can inline
         - always inline also seems to be ok, but it might bloat the code
         - another common scenario is that we have nested catch
           (catch (catch (catch ..))
      *)
      (*
        checkout example {!Digest.file}, you can not inline handler there, 
        we can spot such patten and use finally there?
        {[
        let file filename =
           let ic = open_in_bin filename in
           match channel ic (-1) with
           | d -> close_in ic; d
           | exception e -> close_in ic; raise e

        ]}
       *)
      (* TODO: handle NeedValue *)
      let jmp_table, handlers =  Lam_compile_defs.add_jmps (exit_id, code_table) jmp_table in

      (* Declaration First, body and handler have the same value *)
      (* There is a bug in google closure compiler:
            https://github.com/google/closure-compiler/issues/1234#issuecomment-151976340 
            TODO: wait for a bug fix
        *)
      let declares = 
        S.define ~kind:Variable exit_id
          E.zero_int_literal :: 
        (* we should always make it zero here, since [zero] is reserved in our mapping*)
        List.map (fun x -> S.declare_variable ~kind:Variable x ) bindings in

      begin match  st with 
         (* could be optimized when cases are less than 3 *)
         | NeedValue -> 
           let v = Ext_ident.gen_js  () in 
           let lbody = compile_lambda {cxt with 
                                       jmp_table = jmp_table;
                                       st = Assign v
                                      } body in
           Js_output.make  (S.declare_variable ~kind:Variable v  :: declares) ++ 
           lbody ++ Js_output.make (
             compile_cases 
               {cxt with st = Assign v;
                         jmp_table = jmp_table} 
               exit_expr handlers  NonComplete)  ~value:(E.var v )
         | Declare (kind, id)
         (* declare first this we will do branching*) ->
           let declares = 
             S.declare_variable ~kind id  :: declares in   
           let lbody = compile_lambda {cxt with jmp_table = jmp_table; st = Assign id } body in
           Js_output.make  declares ++ 
           lbody ++ 
           Js_output.make (compile_cases 
                             {cxt with jmp_table = jmp_table; st = Assign id} 
                             exit_expr 
                             handlers
                             NonComplete
                             (* place holder -- tell the compiler that 
                                we don't know if it's complete
                             *)
                          )
         | EffectCall | Assign _  -> 
           let lbody = compile_lambda {cxt with jmp_table = jmp_table } body in
           Js_output.make declares ++
           lbody ++
           Js_output.make (compile_cases
                             {cxt with jmp_table = jmp_table}
                             exit_expr
                             handlers
                             NonComplete)
      end
    | Lwhile(p,body) ->  
      (* Note that ``J.While(expression * statement )``
            idealy if ocaml expression does not need fresh variables, we can generate
            while expression, here we generate for statement, leave optimization later. 
            (Sine OCaml expression can be really complex..)
      *)
      (match compile_lambda {cxt with st = NeedValue; should_return = False } p 
       with 
       | {block; value =  Some e} -> 
         (* st = NeedValue -- this should be optimized and never happen *)
         let e = 
           match block with
           | [] -> e 
           | _ -> E.of_block block ~e  in
         let block = 
           [
             S.while_
               e
               (Js_output.to_block @@ 
                compile_lambda 
                  {cxt with st = EffectCall; should_return = False}
                  body)
           ] in

         begin
           match st, should_return  with 
           | Declare (_kind, x), _  ->  (* FIXME _kind not used *)
             Js_output.make (block @ [S.declare_unit x ])
           | Assign x, _  ->
             Js_output.make (block @ [S.assign_unit x ])
           | EffectCall, True _  -> 
             Js_output.make (block @ [S.return_unit ()]) ~finished:True
           | EffectCall, _ -> Js_output.make block
           | NeedValue, _ -> Js_output.make block ~value:E.unit end
       | _ -> assert false )

    | Lfor (id,start,finish,direction,body) -> 
      (* all non-tail *)
      (* TODO: check semantics should start, finish be executed each time in both 
           ocaml and js?, also check evaluation order..
           in ocaml id is not in the scope of finish, so it should be safe here

           for i  = 0 to (print_int 3; 10) do print_int i done;;
           3012345678910- : unit = ()

         for(var i =  0 ; i < (console.log(i),10); ++i){console.log('hi')}
         print i each time, so they are different semantics...
      *)

      let block =
        begin
          match compile_lambda {cxt with st = NeedValue; should_return = False} start,
                compile_lambda {cxt with st = NeedValue; should_return = False} finish with 
          | {block = b1; value =  Some e1}, {block = b2; value =  Some e2} -> 

            (* order b1 -- (e1 -- b2 -- e2) 
                in most cases we can shift it into such scenarios
                b1, b2, [e1, e2]
                - b2 is Empty
                - e1 is pure
                we can guarantee e1 is pure, if it literally contains a side effect call,
                put it in the beginning


            *)
            begin 
              match b1,b2 with
              | _,[] -> 
                b1 @  [S.for_ (Some e1) e2  id direction 
                         (Js_output.to_block @@ 
                          compile_lambda {cxt with should_return = False ; st = EffectCall}
                            body) ]
              | _, _ when Js_analyzer.no_side_effect_expression e1 
                (* 
                     e1 > b2 > e2
                     re-order 
                     b2 > e1 > e2
                   *)
                -> 
                b1 @ b2 @ [S.for_ (Some e1) e2  id direction 
                             (Js_output.to_block @@ 
                              compile_lambda {cxt with should_return = False ; st = EffectCall}
                                body) ]
              | _ , _
                -> 
                (*       let b2, e2 =  *)
                (*   (\* e2 is of type [int]*\) *)
                (*   match e2.expression_desc with *)
                (*   | Number v  -> b2, J.Const v *)
                (*   | Var v -> b2, J.Finish v *)

                (*   | Array_length e  *)
                (*   | Bytes_length e  *)
                (*   | Function_length e  *)
                (*   | String_length e  *)
                (*     ->  *)
                (*       let len = Ext_ident.create "_length" in *)
                (*       b2 @ [ S.alias_variable len ~exp:e2 ],  J.Finish (Id len ) *)
                (*   | _ ->  *)
                (*       (\* TODO: guess a better name when possible*\) *)
                (*       let len = Ext_ident.create "_finish" in *)
                (*       b2 @ [S.alias_variable len ~exp:e2],  J.Finish (Id len) *)
                (* in  *)

                b1 @ (S.define ~kind:Variable id e1 :: b2 ) @ ([
                    S.for_ None e2 id direction 
                      (Js_output.to_block @@ 
                       compile_lambda {cxt with should_return = False ; st = EffectCall}
                         body) 
                  ])

            end


          | _ -> assert false end in
      begin
        match st, should_return with 
        | EffectCall, False  -> Js_output.make block
        | EffectCall, True _  -> 
          Js_output.make (block @ [S.return_unit()]) ~finished:True
        (* unit -> 0, order does not matter *)
        | (Declare _ | Assign _), True _ -> Js_output.make [S.unknown_lambda lam]
        | Declare (_kind, x), False  ->   
          (* FIXME _kind unused *)
          Js_output.make (block @   [S.declare_unit x ])
        | Assign x, False  -> Js_output.make (block @ [S.assign_unit x ])
        | NeedValue, _ 
          ->  
          Js_output.make block ~value:E.unit
          (* TODO: fixme, here it's ok*)
      end
    | Lassign(id,lambda) -> 
      let block = 
        match lambda with
        | Lprim {primitive = Poffsetint  v; args =  [Lvar id']}
          when Ident.same id id' ->
          [ S.exp (E.assign (E.var id) 
                     (E.int32_add (E.var id) (E.small_int  v)))
          ]
        | _ ->
          begin 
            match compile_lambda {cxt with st = NeedValue; should_return = False} lambda with 
            | {block = b; value =  Some v}  -> 
              (b @ [S.assign id v ])
            | _ -> assert false  
          end
      in
      begin
        match st, should_return with 
        | EffectCall, False -> Js_output.make block
        | EffectCall, True _ -> 
          Js_output.make (block @ [S.return_unit ()]) ~finished:True
        | (Declare _ | Assign _ ) , True _ -> 
          Js_output.make [S.unknown_lambda lam]
        (* bound by a name, while in a tail position, this can not happen  *)
        | Declare (_kind, x) , False ->
          (* FIXME: unused *)
          Js_output.make (block @ [ S.declare_unit x ])
        | Assign x, False  -> Js_output.make (block @ [S.assign_unit x ])
        | NeedValue, _ -> 
          Js_output.make block ~value:E.unit
      end
    | (Ltrywith(
        (Lprim {primitive = Pccall {prim_name = "caml_sys_getenv"; _};
                args = [Lconst _]} as body),
        id, 
        Lifthenelse
          (Lprim{primitive = Pintcomp(Ceq);
                 args = [Lvar id2 ; 
                         Lprim{primitive = Pglobal_exception {name = "Not_found"}; _}]},
           cont, _reraise )
      )
      | Ltrywith(
          (Lprim {primitive = Pccall {prim_name = "caml_sys_getenv"; _};
                  args = [Lconst _]} as body),
          id, 
          Lifthenelse(Lprim{primitive = Pintcomp(Ceq);
                            args = [ 
                              Lprim { primitive = Pglobal_exception {name = "Not_found"; _}; _}; Lvar id2 ]},
                      cont, _reraise )
        )) when Ident.same id id2 
      -> 
      compile_lambda cxt (Lam.try_ body id cont)
    | Ltrywith(lam,id, catch) ->  (* generate documentation *)
      (* 
         tail --> should be renamed to `shouldReturn`  
          in most cases ``shouldReturn`` == ``tail``, however, here is not, 
          should return, but it is not a tail call in js
          (* could be optimized using javascript style exceptions *)
         {[
           {try
              {var $js=g(x);}
                catch(exn){if(exn=Not_found){var $js=0;}else{throw exn;}}
           return h($js);
         }
         ]}
      *)
      let aux st = 
        (* should_return is passed down *)
        [ S.try_ 
            (Js_output.to_block (compile_lambda {cxt with st = st} lam))
            ~with_:(id, 
                    Js_output.to_block @@ 
                    compile_lambda {cxt with st = st} catch )

        ] in 

      begin
        match st with 
        | NeedValue -> 
          let v = Ext_ident.gen_js () in
          Js_output.make (S.declare_variable ~kind:Variable v :: aux (Assign v))  ~value:(E.var v )
        | Declare (kind,  id) -> 
          Js_output.make (S.declare_variable ~kind
                            id :: aux (Assign id))
        | Assign _ | EffectCall -> Js_output.make (aux st)
      end


    | Lsend(meth_kind,met, obj, args,loc) -> 
      (* Note that in [Texp_apply] for [%sendcache] the cache might not be used 
         see {!CamlinternalOO.send_meth} and {!Translcore.transl_exp0} the branch
         [Texp_apply] when [public_send ], args are simply dropped

         reference 
         [js_of_ocaml] 
         1. GETPUBMET
         2. GETDYNMET
         3. GETMETHOD
         [ocaml]
         Lsend (bytegen.ml)
         For the object layout refer to [camlinternalOO/create_object]
         {[
           let create_object table =
             (* XXX Appel de [obj_block] *)
             let obj = mark_ocaml_object @@ Obj.new_block Obj.object_tag table.size in
             (* XXX Appel de [caml_modify] *)
             Obj.set_field obj 0 (Obj.repr table.methods);
             Obj.obj (set_id obj)

           let create_object_opt obj_0 table =
             if (Obj.magic obj_0 : bool) then obj_0 else begin
               (* XXX Appel de [obj_block] *)
               let obj = mark_ocaml_object @@ Obj.new_block Obj.object_tag table.size in
               (* XXX Appel de [caml_modify] *)
               Obj.set_field obj 0 (Obj.repr table.methods);
               Obj.obj (set_id obj)
             end
         ]}
         it's a block with tag [248], the first field is [table.methods] which is an array 
         {[
           type table =
             { mutable size: int;
               mutable methods: closure array;
               mutable methods_by_name: meths;
               mutable methods_by_label: labs;
               mutable previous_states:
                 (meths * labs * (label * item) list * vars *
                  label list * string list) list;
               mutable hidden_meths: (label * item) list;
               mutable vars: vars;
               mutable initializers: (obj -> unit) list }
         ]}
      *)


      begin match 
        (met :: obj :: args) 
        |> Ext_list.split_map (fun (x : Lam.t) -> 
            match x with 
            | Lprim {primitive = Pgetglobal i; args =  []} -> 
              [], Lam_compile_global.get_exp  (i, env, true)
            | Lprim {primitive = Pccall {prim_name ; _}; args =  []}
              (* nullary external call*)
              -> 
              [], E.var (Ext_ident.create_js prim_name)
            | _ -> 
              begin
                match compile_lambda
                        {cxt with st = NeedValue; should_return = False}
                        x with
                | {block = a; value = Some b} -> a, b 
                | _ -> assert false
              end
          ) with  
      | _, ([] | [_]) -> assert false
      | (args_code, label::obj'::args) 
        -> 
        let cont3 obj' k = 
          match Js_ast_util.named_expression obj' with 
          | None -> 
            let cont =
              Js_output.handle_block_return 
                st should_return lam (List.concat args_code)
            in
            cont (k obj')
          | Some (obj_code, v) -> 
            let cont2 obj_code v = 
              Js_output.handle_block_return 
                st should_return lam 
                (obj_code :: List.concat args_code) v in 
            let obj' = E.var v in 
            cont2 obj_code (k obj') 
        in
        begin
          match meth_kind with 
          | Self -> 
            (* TODO: horrible hack -- fixed later *)
            cont3 obj' (fun obj' -> E.call ~info:Js_call_info.dummy 
                   (Js_of_lam_array.ref_array 
                    (Js_of_lam_record.field Fld_na obj' 0l) label )
                 (obj' :: args))
          (* [E.small_int 1] is because we use array, 
              when we change the runtime represenation, it needs to be adapted 
          *)

          | Cached | Public None
            (* TODO: check -- 1. js object propagate 2. js object create  *)
            -> 
            let get = E.runtime_ref  Js_config.oo "caml_get_public_method" in
            let cache = !method_cache_id in
            let () = incr method_cache_id  in
            cont3 obj' (fun obj' -> 
              E.call ~info:Js_call_info.dummy 
                 (E.call ~info:Js_call_info.dummy get 
                    [obj'; label; E.small_int cache]) (obj'::args)
              ) (* avoid duplicated compuattion *)


          | Public (Some name) -> 
            let cache = !method_cache_id in
            incr method_cache_id ;
            cont3 obj' 
              (fun obj' -> E.public_method_call name obj' label 
                  (Int32.of_int cache) args )

        end
      end

    (* [J.Empty,J.N] *)  (* TODO debugging, sourcemap, ignore lambda_event currently *)
    (* 
        seems to be an optimization trick for [translclass]
        | Lifused(v, l) ->
        if count_var v > 0 then simplif l else lambda_unit
    *)
    | Lifused(_,lam) -> compile_lambda cxt lam
  end

end
module Idents_analysis : sig 
#1 "idents_analysis.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** A simple algorithm to calcuate [used] idents given its dependencies and 
    initial list.

    TODO needs improvement
 *)

val calculate_used_idents :
    (Ident.t, Ident_set.t) Hashtbl.t -> Ident.t list -> Ident_set.t

end = struct
#1 "idents_analysis.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)










(* 
    We have a current ident set 
    (mostly exports and variables held by side effect calls) and there is a data set,
    for each variable, its dependency 
    -- 
 *)
let calculate_used_idents 
    (ident_free_vars : (Ident.t, Ident_set.t) Hashtbl.t)
    (initial_idents : Ident.t list) = 
  let s = Ident_set.of_list initial_idents in
  let current_ident_sets = ref s in
  let delta = ref s in
  while 
    Ident_set.(
    delta := 
      diff (fold (fun  id acc  ->

          if Ext_ident.is_js_or_global id  then
            acc (* will not pull in dependencies  any more *)             
          else
            union acc (
              begin match Hashtbl.find ident_free_vars id with 
                | exception Not_found -> 
                  Ext_log.err __LOC__ "%s/%d when compiling %s" 
                    id.name id.stamp (Js_config.get_current_file ()); 
                  assert false 
                | e -> e 
              end
            )

        )  !delta empty)
        !current_ident_sets;
     not (is_empty !delta)) do
    current_ident_sets := Ident_set.(union !current_ident_sets !delta)
  done;
  !current_ident_sets

end
module Lam_group : sig 
#1 "lam_group.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






type t = 
  | Single of Lambda.let_kind  * Ident.t * Lam.t
  | Recursive of (Ident.t * Lam.t) list
  | Nop of Lam.t 


val flatten : t list -> Lam.t -> Lam.t * t list

val lambda_of_groups : Lam.t -> t list -> Lam.t

val deep_flatten : Lam.t -> Lam.t
(** Tricky to be complete *)

val pp_group : Env.t -> Format.formatter -> t -> unit

end = struct
#1 "lam_group.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






type t = 
  | Single of Lambda.let_kind  * Ident.t * Lam.t
  | Recursive of (Ident.t * Lam.t) list
  | Nop of Lam.t 


let pp = Format.fprintf 

let str_of_kind (kind : Lambda.let_kind) = 
  match kind with 
  | Alias -> "a"
  | Strict -> ""
  | StrictOpt -> "o"
  | Variable -> "v" 

let pp_group env fmt ( x : t) =
  match x with
  | Single (kind, id, lam) ->
    Format.fprintf fmt "@[let@ %a@ =%s@ @[<hv>%a@]@ @]" Ident.print id (str_of_kind kind) 
      (Lam_print.env_lambda env) lam
  | Recursive lst -> 
    List.iter (fun (id,lam) -> 
        Format.fprintf fmt
          "@[let %a@ =r@ %a@ @]" Ident.print id (Lam_print.env_lambda env) lam
      ) lst
  | Nop lam -> Lam_print.env_lambda env fmt lam


let rec flatten 
    (acc :  t list ) 
    (lam : Lam.t) :  Lam.t *  t list = 
  match lam with 
  | Llet (str,id,arg,body) -> 
    let (res,l) = flatten acc arg  in
    flatten (Single(str, id, res ) :: l) body
  (* begin *)
  (*   match res with *)
  (*   | Llet _ -> assert false *)
  (*   | Lletrec _-> assert false *)
  (*   | _ ->  *)
  (*       Format.fprintf  Format.err_formatter "%a@." Printlambda.lambda res ; *)
  (*       Format.pp_print_flush Format.err_formatter (); *)
  (*       flatten (Single(str, id, res ) :: l) body *)
  (* end *)
  | Lletrec (bind_args, body) -> 
    (** TODO: more flattening, 
        - also for function compilation, flattening should be done first
        - [compile_group] and [compile] become mutually recursive function
    *)
    (* Printlambda.lambda Format.err_formatter lam ; assert false  *)
    flatten
      (
        Recursive
          (List.map (fun (id, arg ) -> (id, arg)) bind_args)
        :: acc
      )
      body
  | Lsequence (l,r) -> 
    let (res, l)  = flatten acc l in
    flatten (Nop res :: l)  r

  | x ->  
    (*   x = Llet _ -> assert false (* sane check *)*)
    x, acc


(* [groups] are in reverse order *)

let lambda_of_groups result groups = 
  List.fold_left (fun acc x -> 
      match x with 
      | Nop l -> Lam.seq l acc
      | Single(kind,ident,lam) -> Lam_util.refine_let ~kind ident lam acc
      | Recursive bindings -> Lam.letrec bindings acc) 
    result groups


(* TODO: 
    refine effectful [ket_kind] to be pure or not
    Be careful of how [Lifused(v,l)] work 
    since its semantics depend on whether v is used or not
    return value are in reverse order, but handled by [lambda_of_groups]
*)
let deep_flatten
    (lam : Lam.t) :  Lam.t  = 
  let rec
    flatten 
      (acc :  t list ) 
      (lam : Lam.t) :  Lam.t *  t list = 
    match lam with 
    | Llet (str, id, 
            (Lprim {primitive = Pccall 
                      {prim_name = 
                         ("js_from_nullable" 
                         | "js_from_def"
                         |"js_from_nullable_def"); _ }
                   ; args  =  [Lvar _]} as arg), body)
      -> 
      flatten (Single(str, id, (aux arg) ) :: acc) body
    | Llet (str, id, 
            Lprim {primitive = Pccall 
                     ({prim_name = 
                         ("js_from_nullable"
                         | "js_from_def"
                         | "js_from_nullable_def"); _ } as p );
                   args = [arg]}, body)
      -> 
      let id' = Ident.rename id in 
      flatten acc 
        (Lam.let_ str id' arg 
               (Lam.let_ Alias id 
                  (Lam.prim 
                     ~primitive:(Pccall p)
                     ~args: [Lam.var id'] Location.none (* FIXME*))
                  body)
              )
    | Llet (str,id,arg,body) -> 
      let (res,l) = flatten acc arg  in
      flatten (Single(str, id, res ) :: l) body
    | Lletrec (bind_args, body) -> 
      (** TODO: more flattening, 
          - also for function compilation, flattening should be done first
          - [compile_group] and [compile] become mutually recursive function
      *)
      (* Printlambda.lambda Format.err_formatter lam ; assert false  *)
      flatten
        (
          (* let rec iter bind_args acc =  *)
          (*   match bind_args with *)
          (*   | [] ->  acc  *)
          (*   | (id,arg) :: rest ->  *)
          (*       flatten acc  *)
          Recursive
            (List.map (fun (id, arg ) -> (id, aux arg)) bind_args)
          :: acc
        )
        body
    | Lsequence (l,r) -> 
      let (res, l)  = flatten acc l in
      flatten (Nop res :: l)  r
    | x ->  
      aux x, acc      

  and aux  (lam : Lam.t) : Lam.t= 
    match lam with 
    | Llet _ -> 
      let res, groups = flatten [] lam  
      in lambda_of_groups res groups
    | Lletrec (bind_args, body) ->  
      (** be careful to flatten letrec 
          like below : 
          {[
            let rec even = 
              let odd n =  if n ==1 then true else even (n - 1) in
              fun n -> if n ==0  then true else odd (n - 1)
          ]}
          odd and even are recursive values, since all definitions inside 
          e.g, [odd] can see [even] now, however, it should be fine
          in our case? since ocaml's recursive value does not allow immediate 
          access its value direclty?, seems no
          {[
            let rec even2 = 
              let odd = even2 in
              fun n -> if n ==0  then true else odd (n - 1)
          ]}
      *)
      (* let module Ident_set = Lambda.IdentSet in *)
      let rec iter bind_args acc =
        match bind_args with
        | [] ->   acc
        | (id,arg) :: rest ->
          let groups, set = acc in
          let res, groups = flatten groups (aux arg)
          in
          iter rest (Recursive [(id,res)] :: groups, Ident_set.add id set) 
      in
      let groups, collections = iter bind_args ([], Ident_set.empty) in
      (* FIXME:
          here we try to move inner definitions of [recurisve value] upwards
          for example:
         {[
           let rec x = 
             let y = 32 in
             y :: x
           and z = ..
             ---
             le ty = 32 in
           let rec x = y::x
           and z = ..
         ]}
          however, the inner definitions can see [z] and [x], so we
          can not blindly move it in the beginning, however, for 
          recursive value, ocaml does not allow immediate access to 
          recursive value, so what's the best strategy?
          ---
          the motivation is to capture real tail call
      *)
      let (result, _, wrap) = 
        List.fold_left (fun  (acc, set, wrap)  g -> 
            match g with 
            | Recursive [ id, (Lconst _)]
            | Single (Alias, id, ( Lconst _   ))
            | Single ((Alias | Strict | StrictOpt), id, ( Lfunction _ )) -> 
              (** FIXME: 
                   It should be alias and alias will be optimized away
                   in later optmizations, however, 
                   this means if we don't optimize 
                  {[ let u/a = v in ..]}
                   the output would be wrong, we should *optimize 
                   this away right now* instead of delaying it to the 
                   later passes
              *)
              (acc, set, g :: wrap)

            | Single (_, id, ( Lvar bid)) -> 
              (acc, (if Ident_set.mem bid set then Ident_set.add id set else set ), g:: wrap)
            | Single (_, id, lam) ->
              let variables = Lam_util.free_variables  lam in
              if Ident_set.(is_empty (inter variables collections)) 
              then 
                (acc, set, g :: wrap )
              else 
                ((id, lam ) :: acc , Ident_set.add id set, wrap)
            | Recursive us -> 
              (* could also be from nested [let rec] 
                 like 
                 {[
                   let rec x = 
                     let rec y = 1 :: y in
                     2:: List.hd y:: x 
                 ]}
                 TODO: seems like we should update depenency graph, 

              *)
              (us @ acc , 
               List.fold_left (fun acc (id,_) -> Ident_set.add id acc) set us , 
               wrap)
            | Nop _ -> assert false 
          ) ([], collections, []) groups in
      lambda_of_groups 
        (Lam.letrec 
            result 
            (* List.map (fun (id,lam) -> (id, aux lam )) bind_args *)
            (aux body)) (List.rev wrap)
    | Lsequence (l,r) -> Lam.seq (aux l) (aux r)
    | Lconst _ -> lam
    | Lvar _ -> lam 
    (* | Lapply(Lfunction(Curried, params, body), args, _) *)
    (*   when  List.length params = List.length args -> *)
    (*     aux (beta_reduce  params body args) *)
    (* | Lapply(Lfunction(Tupled, params, body), [Lprim(Pmakeblock _, args)], _) *)
    (*     (\** TODO: keep track of this parameter in ocaml trunk, *)
    (*           can we switch to the tupled backend? *\) *)
    (*   when  List.length params = List.length args -> *)
    (*       aux (beta_reduce params body args) *)

    | Lapply{fn = l1; args  = ll; loc; status} -> 
      Lam.apply (aux l1) (List.map aux ll) loc status

    (* This kind of simple optimizations should be done each time
       and as early as possible *) 

    | Lprim {primitive = Pccall{prim_name = "caml_int64_float_of_bits"; _};
            args = [ Lconst (Const_base (Const_int64 i))]; _} 
      ->  
      Lam.const 
        (Const_base (Const_float (Js_number.to_string (Int64.float_of_bits i) )))
    | Lprim {primitive = Pccall{prim_name = "caml_int64_to_float"; _}; 
             args = [ Lconst (Const_base (Const_int64 i))]; _} 
      -> 
      (* TODO: note when int is too big, [caml_int64_to_float] is unsafe *)
      Lam.const 
        (Const_base (Const_float (Js_number.to_string (Int64.to_float i) )))
    | Lprim {primitive ; args; loc }
      -> 
      let args = List.map aux args in
      Lam.prim ~primitive ~args loc

    | Lfunction{arity; kind; params;  body = l} -> 
      Lam.function_ ~arity ~kind ~params  ~body:(aux  l)
    | Lswitch(l, {sw_failaction; 
                  sw_consts; 
                  sw_blocks;
                  sw_numblocks;
                  sw_numconsts;
                 }) ->
      Lam.switch (aux  l)
              {sw_consts = 
                 List.map (fun (v, l) -> v, aux  l) sw_consts;
               sw_blocks = List.map (fun (v, l) -> v, aux  l) sw_blocks;
               sw_numconsts = sw_numconsts;
               sw_numblocks = sw_numblocks;
               sw_failaction = 
                 begin 
                   match sw_failaction with 
                   | None -> None
                   | Some x -> Some (aux x)
                 end}
    | Lstringswitch(l, sw, d) ->
      Lam.stringswitch (aux  l) 
                    (List.map (fun (i, l) -> i,aux  l) sw)
                    (match d with
                     | Some d -> Some (aux d )
                     | None -> None)

    | Lstaticraise (i,ls) 
      -> Lam.staticraise i (List.map aux  ls)
    | Lstaticcatch(l1, ids, l2) 
      -> 
      Lam.staticcatch (aux  l1) ids (aux  l2)
    | Ltrywith(l1, v, l2) ->
      Lam.try_ (aux  l1) v (aux  l2)
    | Lifthenelse(l1, l2, l3) 
      -> 
      Lam.if_ (aux  l1) (aux l2) (aux l3)
    | Lwhile(l1, l2) 
      -> 
      Lam.while_ (aux  l1) (aux l2)
    | Lfor(flag, l1, l2, dir, l3) 
      -> 
      Lam.for_ flag (aux  l1) (aux  l2) dir (aux  l3)
    | Lassign(v, l) ->
      (* Lalias-bound variables are never assigned, so don't increase
         v's refaux *)
      Lam.assign v (aux  l)
    | Lsend(u, m, o, ll, v) -> 
      Lam.send u (aux m) (aux o) (List.map aux ll) v

    | Lifused(v, l) -> Lam.ifused v (aux  l)
  in aux lam

end
module Lam_dce : sig 
#1 "lam_dce.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)









(** Dead code eliminatiion on the lambda layer 
*)

val remove : Ident.t list -> Lam_group.t list -> Lam_group.t list

end = struct
#1 "lam_dce.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








module I = Ident_set

let remove export_idents (rest : Lam_group.t list) : Lam_group.t list  = 
  let ident_free_vars = Hashtbl.create 17 in

  let initial_idents =
    Ext_list.flat_map (fun (x : Lam_group.t) ->
      match x with
      | Single(kind, id,lam) -> (* assert false *)
          begin
            Hashtbl.add ident_free_vars id 
              (Lam_util.free_variables  lam);
            match kind with
            | Alias | StrictOpt -> []
            | Strict | Variable -> [id]
          end
      | Recursive bindings ->
          begin
            bindings |> Ext_list.flat_map (fun (id,lam) ->
              begin
                Hashtbl.add ident_free_vars id (Lam_util.free_variables lam);
                match (lam : Lam.t) with
                | Lfunction _ -> []
                | _ -> [id]
              end)
          end
      | Nop lam ->
          if Lam_analysis.no_side_effects lam then []
          else 
            (** its free varaibles here will be defined above *)
            I.elements ( Lam_util.free_variables lam)) rest  @ export_idents
  in
  let current_ident_sets = 
    Idents_analysis.calculate_used_idents ident_free_vars 
      initial_idents in


  rest |> Ext_list.filter_map (fun ( x : Lam_group.t) ->
    match x with 
    | Single(_,id,_) -> 
        if I.mem id current_ident_sets then 
          Some x else None
    | Nop _ -> Some x 
    | Recursive bindings -> 
        let b = bindings
    |> Ext_list.filter_map (fun  ((id,_) as v) ->
        if I.mem id current_ident_sets then 
          Some v 
        else None
                         )
        in
        match b with 
        | [] -> None 
        | _ -> Some (Recursive b)) 

end
module Lam_stats_util : sig 
#1 "lam_stats_util.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Utilities for lambda analysis *)

val pp_alias_tbl : Format.formatter -> Lam_stats.alias_tbl  -> unit

val pp_arities : Format.formatter -> Lam.function_arities -> unit

val get_arity : Lam_stats.meta -> Lam.t -> Lam.function_arities

(* val dump_exports_arities : Lam_stats.meta -> unit *)



end = struct
#1 "lam_stats_util.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








let pp = Format.fprintf

let pp_arities (fmt : Format.formatter) (x : Lam.function_arities) = 
  match x with 
  | NA -> pp fmt "?"
  | Determin (b,ls,tail) -> 
    begin 
      pp fmt "@[";
      (if not b 
       then 
         pp fmt "~");
      pp fmt "[";
      Format.pp_print_list ~pp_sep:(fun fmt () -> pp fmt ",")
        (fun fmt  (x,_) -> Format.pp_print_int fmt x)
        fmt ls ;
      if tail 
      then pp fmt "@ *";
      pp fmt "]@]";
    end

let pp_arities_tbl 
    (fmt : Format.formatter) 
    (arities_tbl : (Ident.t, Lam.function_arities ref) Hashtbl.t) = 
  Hashtbl.fold (fun (i:Ident.t) (v : Lam.function_arities ref) _ -> 
      pp Format.err_formatter "@[%s -> %a@]@."i.name pp_arities !v ) arities_tbl ()

let pp_alias_tbl fmt (tbl : Lam_stats.alias_tbl) = 
  Hashtbl.iter (fun k v -> pp fmt "@[%a -> %a@]@." Ident.print k Ident.print v)
    tbl

let merge 
    ((n : int ), params as y)
    (x : Lam.function_arities) : Lam.function_arities = 
  match x with 
  | NA -> Determin(false, [y], false)
  | Determin (b,xs,tail) -> Determin (b, y :: xs, tail)

(* we need record all aliases -- since not all aliases are eliminated, 
   mostly are toplevel bindings
   We will keep iterating such environment
   If not found, we will return [NA]
*)
let rec get_arity 
    (meta : Lam_stats.meta) 
    (lam : Lam.t) : 
  Lam.function_arities = 
  match lam with 
  | Lconst _ -> Determin (true,[], false)
  | Lvar v -> 
    (** for functional parameter, if it is a high order function,
        if it's not from function parameter, we should warn
    *)
    begin 
      match Hashtbl.find meta.ident_tbl v with 
      | exception Not_found -> (NA : Lam.function_arities) 
      | Function {arity;_} -> arity
      | _ ->
        (* Format.fprintf Format.err_formatter *)
        (*   "@[%s %a is not function/functor@]@." meta.filename Ident.print v ; *)
        (NA : Lam.function_arities)

    end
  | Llet(_,_,_, l ) -> get_arity meta l 
  (* | Lprim (Pccall {prim_name = "js_pure_expr"; prim_attributes},  *)
  (*          [Lconst (Const_base (Const_string (_str,_)))]) *)
  (*   -> *)
  (*   (\* Ext_log.dwarn __LOC__ "called %s %d" str (List.length prim_attributes ); *\) *)
  (*   begin match Parsetree_util.has_arity prim_attributes with *)
  (*     | Some arity ->  *)
  (*       (\* Ext_log.dwarn __LOC__ "arity %d" arity; *\) *)
  (*       Determin(false, [arity, None], false) *)
  (*     | None -> NA *)
  (*   end *)
  | Lprim {primitive = Pfield (n,_); 
           args =  [Lprim {primitive = Pgetglobal id; args = []; _}]; _} ->
    Lam_compile_env.find_and_add_if_not_exist (id, n) meta.env
      ~not_found:(fun _ -> assert false)
      ~found:(fun x -> x.arity )
  | Lprim {primitive = Pfield _; _} -> NA (** TODO *)
  | Lprim {primitive = Praise ;  _} -> Determin(true,[], true)
  | Lprim {primitive = Pccall _; _} -> Determin(false, [], false)
  | Lprim _  -> Determin(true,[] ,false)
  (* shall we handle primitive in a direct way, 
      since we know all the information
      Invariant: all primitive application is fully applied, 
      since this information  is already available

      -- Check external c functions ?
      -- it's not true for primitives 
      like caml_set_oo_id  or  Lprim (Pmakeblock , [])

      it seems true that primitive is always fully applied, however,
      it can return a function
  *)
  | Lletrec(_, body) ->
    get_arity meta body
  (* | Lapply(Lprim( p, _), _args, _info) -> *)
  (*     Determin(true, [], false) (\** Invariant : primtive application is always complete.. *\) *)

  | Lapply{fn = app;  args; _ } -> (* detect functor application *)
    let fn = get_arity meta app in 
    begin match fn with 
      | NA -> NA 
      | Determin (b, xs, tail ) -> 
        let rec take (xs : _ list) arg_length = 
          match xs with 
          | (x,y) :: xs ->
            if arg_length = x then Lam.Determin (b, xs, tail) 
            else if arg_length > x then
              take xs (arg_length - x)
            else Determin (b, 
                           ((x -  arg_length ), 
                            (match y with
                            | Some y -> Some (Ext_list.drop arg_length y) 
                            | None -> None)) :: xs ,
                           tail)
          | [] -> 
            if tail then Determin(b, [], tail)
            else if not b then 
              NA
            else NA
            (* Actually, you can not have truly deministic arities
               for example [fun x -> x ]
            *)
              (* Ext_pervasives.failwithf ~loc:__LOC__ "%s %s" *)
              (*   (Format.asprintf "%a" pp_arities fn)  *)
              (*   (Lam_util.string_of_lambda lam) *)
        in
        take xs (List.length args) 
    end
  | Lfunction {arity; kind; params; body = l} -> 
    merge (arity, Some params)  (get_arity meta l)
  | Lswitch(l, {sw_failaction; 
                sw_consts; 
                sw_blocks;
                sw_numblocks = _;
                sw_numconsts = _;
               }) -> 
    all_lambdas meta (
      let rest = (sw_consts |> List.map snd) @ (sw_blocks |> List.map snd ) in
      match sw_failaction with None -> rest | Some x -> x::rest )
  | Lstringswitch(l, sw, d) -> 
    begin match d with 
      | None -> all_lambdas meta (List.map snd  sw )
      | Some v -> all_lambdas meta (v:: List.map snd  sw)
    end
  | Lstaticraise _ -> NA (* since it will not be in tail position *)
  | Lstaticcatch(_, _, handler) -> get_arity meta handler
  | Ltrywith(l1, _, l2) -> 
    all_lambdas meta [l1;l2]
  | Lifthenelse(l1, l2, l3) ->
    all_lambdas meta [l2;l3]
  | Lsequence(_, l2) -> get_arity meta l2 
  | Lsend(u, m, o, ll, v) -> NA
  | Lifused(v, l) -> NA 
  | Lwhile _ 
  | Lfor _  
  | Lassign _ -> Determin(true,[], false)

and all_lambdas meta (xs : Lam.t list) = 
  match xs with 
  | y :: ys -> 
    let arity =  get_arity meta y in 
    List.fold_left (fun exist (v : Lam.t) -> 
        match (exist : Lam.function_arities) with 
        | NA -> NA 
        | Determin (b, xs, tail) -> 
          begin 
            match get_arity meta v with 
            | NA -> NA 
            | Determin (u,ys,tail2) -> 
              let rec aux (b,acc) xs ys = 
                match xs,ys with
                | [], [] -> (b, List.rev acc, tail && tail2) 
                | [], y::ys when tail  -> 
                  aux (b,y::acc) [] ys 
                | x::xs, [] when tail2 -> 
                  aux (b,x::acc) [] xs
                | x::xs, y::ys when x = y -> aux (b, (y :: acc)) xs ys 
                | _, _  -> (false, List.rev acc, false) in 
              let (b,acc, tail3)  = aux ( u &&b, []) xs ys in 
              Determin (b,acc, tail3)
          end
      ) arity ys 
  | _ -> assert false 

(*
let dump_exports_arities (meta : Lam_stats.meta ) = 
  let fmt = 
    if meta.filename != "" then 
      let cmj_file = Ext_filename.chop_extension meta.filename ^ Js_config.cmj_ext in
      let out = open_out cmj_file in   
      Format.formatter_of_out_channel out
    else 
      Format.err_formatter in 
  begin 
    List.iter (fun (i : Ident.t) ->  
      pp fmt "@[%s: %s -> %a@]@." meta.filename i.name 
        pp_arities  (get_arity meta (Lvar i))
              ) meta.exports
  end
*)


end
module Lam_pass_alpha_conversion : sig 
#1 "lam_pass_alpha_conversion.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** alpha conversion based on arity *)

val alpha_conversion : Lam_stats.meta -> Lam.t  -> Lam.t

end = struct
#1 "lam_pass_alpha_conversion.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








let alpha_conversion (meta : Lam_stats.meta) (lam : Lam.t) : Lam.t = 
  let rec simpl  (lam : Lam.t) = 
    match lam with 
    | Lconst _ -> lam
    | Lvar _ -> lam 
    | Lapply {fn = l1; args =  ll;  loc ; status} 
      -> (* detect functor application *)
      begin 
        match Lam_stats_util.get_arity meta l1 with 
        | NA -> 
          Lam.apply (simpl  l1) (List.map simpl  ll) loc status
        | Determin (b, args, tail) -> 
          let len = List.length ll in 
          let rec take args = 
            match args with 
            | (x,_) :: xs -> 
              if x = len 
              then 
                Lam.apply (simpl l1)
                  (List.map simpl ll) loc App_ml_full
              else if x > len  
              then 
                let fn = simpl l1 in
                let args = List.map simpl ll in
                Lam_util.eta_conversion (x - len) loc App_ml_full
                  fn args 
              else 
                let first,rest = Ext_list.take x ll in 
                Lam.apply (
                  Lam.apply (simpl l1) 
                         (List.map simpl first) 
                         loc App_ml_full
                )
                  (List.map simpl rest) loc status (* TODO refien *)
            | _ -> Lam.apply (simpl l1) (List.map simpl ll)  loc status
          in take args
      end

    | Llet (str, v, l1, l2) ->
      Lam.let_ str v (simpl l1) (simpl l2 )
    | Lletrec (bindings, body) ->
      let bindings = List.map (fun (k,l) -> (k, simpl l)) bindings in 
      Lam.letrec bindings (simpl body) 
    | Lprim {primitive; args ; loc} -> 
      Lam.prim ~primitive ~args:(List.map simpl  args) loc
    | Lfunction {arity; kind; params; body = l} ->
      (* Lam_mk.lfunction kind params (simpl l) *)
      Lam.function_ ~arity ~kind ~params  ~body:(simpl  l)
    | Lswitch (l, {sw_failaction; 
                  sw_consts; 
                  sw_blocks;
                  sw_numblocks;
                  sw_numconsts;
                 }) ->
      Lam.switch (simpl  l)
              {sw_consts = 
                 List.map (fun (v, l) -> v, simpl  l) sw_consts;
               sw_blocks = List.map (fun (v, l) -> v, simpl  l) sw_blocks;
               sw_numconsts = sw_numconsts;
               sw_numblocks = sw_numblocks;
               sw_failaction = 
                 begin 
                   match sw_failaction with 
                   | None -> None
                   | Some x -> Some (simpl x)
                 end}
    | Lstringswitch (l, sw, d) ->
      Lam.stringswitch (simpl  l)
                    (List.map (fun (i, l) -> i,simpl  l) sw)
                    (match d with
                      | Some d -> Some (simpl d )
                      | None -> None)
                    
    | Lstaticraise (i,ls) ->
      Lam.staticraise i (List.map simpl  ls)
    | Lstaticcatch (l1, ids, l2) 
      -> 
      Lam.staticcatch (simpl  l1) ids (simpl  l2)
    | Ltrywith (l1, v, l2) 
      -> 
      Lam.try_ (simpl  l1) v (simpl  l2)
    | Lifthenelse (l1, l2, l3) -> 
      Lam.if_ (simpl  l1) (simpl  l2) (simpl  l3)
    | Lsequence (l1, l2) 
      -> Lam.seq (simpl  l1) (simpl  l2)
    | Lwhile (l1, l2)
      -> Lam.while_ (simpl  l1) (simpl l2)
    | Lfor (flag, l1, l2, dir, l3)
      -> Lam.for_ flag (simpl  l1) (simpl  l2) dir (simpl  l3)
    | Lassign (v, l) ->
      (* Lalias-bound variables are never assigned, so don't increase
         v's refsimpl *)
      Lam.assign v (simpl  l)
    | Lsend (u, m, o, ll, v) -> 
      Lam.send u (simpl m) (simpl o) (List.map simpl ll) v
    | Lifused (v, l) -> Lam.ifused v (simpl  l)
  in 

  simpl lam

end
module Lam_pass_collect : sig 
#1 "lam_pass_collect.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)









(** This pass is used to collect meta data information.

    It includes:
    alias table, arity for identifiers and might more information,
    
    ATTENTION:
    For later pass to keep its information complete and up to date,
    we  need update its table accordingly

    - Alias inference is not for substitution, it is for analyze which module is 
      actually a global module or an exception, so it can be relaxed a bit
      (without relying on strict analysis)

    - Js object (local) analysis 

    Design choice:

    Side effectful operations:
       - Lassign 
       - Psetfield

    1. What information should be collected:

    2. What's the key
       If it's identifier, 
       
    Information that is always sound, not subject to change 

    - shall we collect that if an identifier is passed as a parameter, (useful for escape analysis), 
    however, since it's going to change after inlning (for local function)

    - function arity, subject to change when you make it a mutable ref and change it later
    
    - Immutable blocks of identifiers
     
      if identifier itself is function/non block then the access can be inlined 
      if identifier itself is immutable block can be inlined
      if identifier is mutable block can be inlined (without Lassign) since

    - When collect some information, shall we propogate this information to 
      all alias table immeidately

      - annotation identifiers (at first time)
      -
 *)

(** Modify existing [meta] *)
val collect_helper : Lam_stats.meta -> Lam.t -> unit

(** return a new [meta] *)
val count_alias_globals : 
    Env.t -> string -> Ident.t list -> Lam.t -> Lam_stats.meta



end = struct
#1 "lam_pass_collect.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)









let annotate (meta : Lam_stats.meta)
    rec_flag    
    (k:Ident.t) (v : Lam.function_arities) lambda = 
  (* Ext_log.dwarn  __LOC__ "%s/%d" k.name k.stamp;     *)
  match Hashtbl.find  meta.ident_tbl k  with 
  | exception Not_found -> 
      Hashtbl.add meta.ident_tbl k (Function {kind = NA; arity = v; lambda; rec_flag})
  |  Function old  ->  
      (** Check, it is shared across ident_tbl, 
          Only [Lassign] will break such invariant,
          how about guarantee that [Lassign] only check the local ref 
          and we track which ids are [Lassign]ed
       *)
      (**
         might not be the same due to refinement
         assert (old.arity = v) 
       *)
      old.arity <- v
      

  | _ -> assert false (* TODO -- avoid exception *)


(** it only make senses recording arities for 
    function definition,
    alias propgation - and toplevel identifiers, this needs to be exported
 *)
let collect_helper  (meta : Lam_stats.meta) (lam : Lam.t)  = 
  let rec collect_bind rec_flag
      (kind : Lambda.let_kind) 
      (ident : Ident.t)
      (lam : Lam.t) = 
    match lam with 
    | Lconst v 
      -> 
      Hashtbl.replace meta.ident_tbl ident (Constant v); (** *)
    | Lprim {primitive = Pmakeblock (_, _, Immutable ) ; args=  ls}
      -> 
      Hashtbl.replace meta.ident_tbl ident 
        (Lam_util.kind_of_lambda_block Normal ls);
      List.iter collect ls 

    | Lprim {primitive = Pccall {prim_name = "js_from_nullable"; _}; 
             args = ([ Lvar _] as ls) ; _}
      ->
      Hashtbl.replace meta.ident_tbl ident 
        (Lam_util.kind_of_lambda_block Null ls )
    | Lprim {primitive = Pccall {prim_name = "js_from_def"; _}; 
             args = ([ Lvar _] as ls); _}
      ->
      Hashtbl.replace meta.ident_tbl ident 
        (Lam_util.kind_of_lambda_block Undefined ls )
    | Lprim {primitive = Pccall {prim_name = "js_from_nullable_def"; _};
             args = ([ Lvar _] as ls);}
      ->
      Hashtbl.replace meta.ident_tbl ident 
        (Lam_util.kind_of_lambda_block Null_undefined ls )
      
    | Lprim {primitive = Pgetglobal v; args = []; _} 
      -> 
      begin 
        Lam_util.alias meta  ident v (Module  v) kind; 
        begin match kind with 
          | Alias -> ()
          | Strict | StrictOpt | Variable -> 
            Lam_util.add_required_module v meta
        end;
      end
    | Lvar v 
      -> 
        (
         (* if Ident.global v then  *)
         Lam_util.alias meta  ident v NA kind
           (* enven for not subsitution, it still propogate some properties *)
           (* else () *)
        )
    | Lfunction{ params; body = l}
        (** TODO record parameters ident ?, but it will be broken after inlining *)  
      -> 
        (** TODO could be optimized in one pass? 
            -- since collect would iter everywhere,
            so -- it would still iterate internally
         *)

      List.iter (fun p -> Hashtbl.add meta.ident_tbl p Parameter ) params;
      let arity = Lam_stats_util.get_arity meta lam in       
      (* Ext_log.dwarn __LOC__ "%s/%d : %a : %a function collected"  *)
      (*   ident.name ident.stamp  *)
      (*   Printlambda.lambda lam *)
      (*   Lam_stats_util.pp_arities arity *)
      (* ; *)
      annotate meta rec_flag ident  arity lam;
      collect l
    | x -> 
        collect x ;
        if Ident_set.mem ident meta.export_idents then 
          annotate meta rec_flag ident (Lam_stats_util.get_arity meta x ) lam


  and collect  (lam : Lam.t)  =
    match lam with 

        (** TODO: 
            how about module aliases..
            record dependency
            --- tricky -- if we inlining, 
            is it safe to remove it? probably not...
         *)
    | Lconst _ -> ()
    | Lvar _ -> ()
    | Lapply{fn = l1; args =  ll; _} ->
        collect  l1; List.iter collect  ll
    | Lfunction { params; body =  l} -> (* functor ? *)
        List.iter (fun p -> Hashtbl.add meta.ident_tbl p Parameter ) params;
        collect  l
    | Llet (kind,ident,arg,body) -> 
        collect_bind Non_rec kind ident arg ; collect body
    | Lletrec (bindings, body) -> 
        List.iter (fun (ident,arg) -> collect_bind Rec  Strict ident arg ) bindings;
        collect body
    | Lprim {args; _} -> List.iter collect  args
    | Lswitch(l, {sw_failaction; sw_consts; sw_blocks}) ->
        collect  l;
        List.iter (fun (_, l) -> collect  l) sw_consts;
        List.iter (fun (_, l) -> collect  l) sw_blocks;
        begin match sw_failaction with 
        | None -> ()
        | Some x -> collect x
        end
    | Lstringswitch(l, sw, d) ->
        collect  l ;
        List.iter (fun (_, l) -> collect  l) sw ;
        begin match d with
        | Some d -> collect d 
        | None -> ()
        end
    | Lstaticraise (code,ls) -> 
        Hash_set.add meta.exit_codes code;
        List.iter collect  ls
    | Lstaticcatch(l1, (_,_), l2) -> collect  l1; collect  l2
    | Ltrywith(l1, _, l2) -> collect  l1; collect  l2
    | Lifthenelse(l1, l2, l3) -> collect  l1; collect  l2; collect  l3
    | Lsequence(l1, l2) -> collect  l1; collect  l2
    | Lwhile(l1, l2) -> collect  l1; collect l2
    | Lfor(_, l1, l2, dir, l3) -> collect  l1; collect  l2; collect  l3
    | Lassign(v, l) ->
        (* Lalias-bound variables are never assigned, so don't increase
           v's refcollect *)
        collect  l
    | Lsend(_, m, o, ll, _) -> List.iter collect  (m::o::ll)
    | Lifused(_, l) -> collect  l in collect lam 



let count_alias_globals 
    env 
    filename
    export_idents
    (lam : Lam.t) : Lam_stats.meta =
  let meta : Lam_stats.meta = 
    {alias_tbl = Hashtbl.create 31 ; 
     ident_tbl = Hashtbl.create 31;
     exit_codes = Hash_set.create 31 ;
     exports =  export_idents;
     required_modules = [] ;
     filename;
     env;
     export_idents = Lam_util.ident_set_of_list export_idents; 
   } in 
  collect_helper  meta lam ; 
  meta

end
module Lam_pass_exits : sig 
#1 "lam_pass_exits.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)
(* Adapted for Javascript backend: Hongbo Zhang,                       *)


(** A pass used to optimize the exit code compilation, adaped from the compiler's
    [simplif] module
 *)

val count_helper : Lam.t -> (int, int ref) Hashtbl.t

type subst_tbl = (int, Ident.t list * Lam.t) Hashtbl.t

val subst_helper : subst_tbl -> (int -> int) -> Lam.t -> Lam.t

val simplify_exits : Lam.t -> Lam.t

end = struct
#1 "lam_pass_exits.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)
(* Adapted for Javascript backend: Hongbo Zhang                        *)

(*
   TODO: 
   we should have a pass called, always inlinable
   as long as its length is smaller than [exit=exit_id], for example
   
   {[
      switch(box_name)
       {case "":exit=178;break;
        case "b":exit=178;break;
        case "h":box_type=/* Pp_hbox */0;break;
        case "hov":box_type=/* Pp_hovbox */3;break;
        case "hv":box_type=/* Pp_hvbox */2;break;
        case "v":box_type=/* Pp_vbox */1;break;
        default:box_type=invalid_box(/* () */0);}
      
      switch(exit){case 178:box_type=/* Pp_box */4;break}
   ]}
*)

(* Count occurrences of (exit n ...) statements *)
let count_exit exits i =
  try
    !(Hashtbl.find exits i)
  with
  | Not_found -> 0

and incr_exit exits i =
  try
    incr (Hashtbl.find exits i)
  with
  | Not_found -> Hashtbl.add exits i (ref 1) 

let count_helper  (lam : Lam.t) : (int, int ref) Hashtbl.t  = 
  let exits = Hashtbl.create 17 in
  let rec count (lam : Lam.t) = 
    match lam with 
    | Lstaticraise (i,ls) -> incr_exit exits i ; List.iter count ls
    | Lstaticcatch (l1,(i,[]),Lstaticraise (j,[])) ->
      (* i will be replaced by j in l1, so each occurence of i in l1
         increases j's ref count *)
      count l1 ;
      let ic = count_exit exits i in
      begin try
          let r = Hashtbl.find exits j in r := !r + ic
        with
        | Not_found ->
          Hashtbl.add exits j (ref ic)
      end
    | Lstaticcatch(l1, (i,_), l2) ->
      count l1;
      (* If l1 does not contain (exit i),
         l2 will be removed, so don't count its exits *)
      if count_exit exits i > 0 
      then
        count l2
    | Lstringswitch(l, sw, d) ->
      count l;
      List.iter (fun (_, l) -> count l) sw;
      begin 
        match  d with
        | None -> ()
        | Some d -> 
          (* See https://github.com/ocaml/ocaml/commit/fcf3571123e2c914768e34f1bd17e4cbaaa7d212#diff-704f66c0fa0fc9339230b39ce7d90919 
             might only necessary for native backend
          *)
          count d
          (* begin match sw with *)
          (* | []|[_] -> count d *)
          (* | _ -> count d; count d (\** ASK: default will get replicated *\) *)
          (* end *)
      end
    | Lvar _| Lconst _ -> ()
    | Lapply{fn = l1; args =  ll; _} -> count l1; List.iter count ll
    | Lfunction {body = l} -> count l
    | Llet(_, _, l1, l2) ->
      count l2; count l1
    | Lletrec(bindings, body) ->
      List.iter (fun (_, l) -> count l) bindings;
      count body
    | Lprim {args;  _} -> List.iter count args
    | Lswitch(l, sw) ->
      count_default sw ;
      count l;
      List.iter (fun (_, l) -> count l) sw.sw_consts;
      List.iter (fun (_, l) -> count l) sw.sw_blocks
    | Ltrywith(l1, v, l2) -> count l1; count l2
    | Lifthenelse(l1, l2, l3) -> count l1; count l2; count l3
    | Lsequence(l1, l2) -> count l1; count l2
    | Lwhile(l1, l2) -> count l1; count l2
    | Lfor(_, l1, l2, dir, l3) -> count l1; count l2; count l3
    | Lassign(_, l) -> count l
    | Lsend(_, m, o, ll, _) -> count m; count o; List.iter count ll
    | Lifused(_, l) -> count l 

  and count_default sw =
    match sw.sw_failaction with
    | None -> ()
    | Some al ->
      let nconsts = List.length sw.sw_consts
      and nblocks = List.length sw.sw_blocks in
      if
        nconsts < sw.sw_numconsts && nblocks < sw.sw_numblocks
      then 
        begin (* default action will occur twice in native code *)
          count al ; count al
          (** 
              Reason: for pattern match, 
              we will  test whether it is 
              an integer or block, both have default cases
              predicate: [sw_numconsts] vs nconsts
          *)
        end 
      else 
        begin (* default action will occur once *)
          assert (nconsts < sw.sw_numconsts || nblocks < sw.sw_numblocks) ;
          count al
        end in 
  count lam ; 
  exits
;;

type subst_tbl = (int, Ident.t list * Lam.t) Hashtbl.t

(*
   Second pass simplify  ``catch body with (i ...) handler''
      - if (exit i ...) does not occur in body, suppress catch
      - if (exit i ...) occurs exactly once in body,
        substitute it with handler
      - If handler is a single variable, replace (exit i ..) with it
*)
(*
  Note:
    In ``catch body with (i x1 .. xn) handler''
     Substituted expression is
      let y1 = x1 and ... yn = xn in
      handler[x1 <- y1 ; ... ; xn <- yn]
     For the sake of preserving the uniqueness  of bound variables.
   ASKS: This documentation seems outdated
     (No alpha conversion of ``handler'' is presently needed, since
     substitution of several ``(exit i ...)''
     occurs only when ``handler'' is a variable.)
*)


let subst_helper (subst : subst_tbl) query lam = 
  let rec simplif (lam : Lam.t) = 
    match lam with 
    | Lstaticraise (i,[])  ->
      begin 
        match Hashtbl.find subst i with
        | _, handler -> handler
        | exception Not_found -> lam
      end
    | Lstaticraise (i,ls) ->
      let ls = List.map simplif ls in
      begin 
        match Hashtbl.find subst i with
        | xs,handler -> 
          let ys = List.map Ident.rename xs in
          let env =
            List.fold_right2
              (fun x y t -> Ident_map.add x (Lam.var y) t)
              xs ys Ident_map.empty in
          List.fold_right2
            (fun y l r -> Lam.let_ Alias y l r)
            ys ls 
               (Lam_util.subst_lambda  env  handler)
        | exception Not_found -> Lam.staticraise i ls
      end
    | Lstaticcatch (l1,(i,[]),(Lstaticraise (j,[]) as l2)) ->
      Hashtbl.add subst i ([],simplif l2) ;
      simplif l1 (** l1 will inline the exit handler *)
    | Lstaticcatch (l1,(i,xs),l2) ->
      begin 
        match query i, l2 with
        | 0,_ -> simplif l1

        (* Note that 
           for [query] result = 2, 
           the non-inline cost is 
           {[
             var exit ;

             exit = 11;
             exit = 11;

             switch(exit){
               case exit = 11 : body ; break
             }

           ]}
           the inline cost is 

           {[
             body;
             body;
           ]}

           when [i] is negative, we can not inline in general, 
           since the outer is a traditional [try .. catch] body, 
           if it is guaranteed to be non throw, then we can inline
        *)
        | ( _ , Lvar _
          | _, Lconst _) ->  
          Hashtbl.add subst i (xs,simplif l2) ;
          simplif l1 (** l1 will inline *)
        | 1,_ when i >= 0 -> (** Ask: Note that we have predicate i >=0 *)
          Hashtbl.add subst i (xs,simplif l2) ;
          simplif l1 (** l1 will inline *)
        | j,_ ->

          (** TODO: better heuristics, also if we can group same exit code [j] 
              in a very early stage -- maybe we can define our enhanced [Lambda] 
              representation and counter can be more precise, for example [apply] 
              does not need patch from the compiler

              FIXME:   when inlining, need refresh local bound identifiers
          *)
          let lam_size = Lam_analysis.size l2 in
          let ok_to_inline = 
             i >=0 && 
             ( (j <= 2 && lam_size < Lam_analysis.exit_inline_size   )
               || lam_size < 5)
             (*TODO: when we do the case merging on the js side, 
               the j is not very indicative                
             *)             
          in 
          if ok_to_inline (* && false *) 
          then 
            begin 
              Hashtbl.add subst i (xs, Lam_beta_reduce.refresh @@ simplif l2) ;
              simplif l1 (** l1 will inline *)
            end
          else Lam.staticcatch (simplif l1) (i,xs) (simplif l2)
      end

    | Lvar _|Lconst _  -> lam
    | Lapply {fn = l1; args =  ll;  loc; status } -> 
      Lam.apply (simplif l1) (List.map simplif ll) loc status
    | Lfunction {arity; kind; params; body =  l} -> 
      Lam.function_ ~arity ~kind ~params ~body:(simplif l)
    | Llet (kind, v, l1, l2) -> 
      Lam.let_ kind v (simplif l1) (simplif l2)
    | Lletrec (bindings, body) ->
      Lam.letrec
        ( List.map (fun (v, l) -> (v, simplif l)) bindings) 
        (simplif body)
    | Lprim {primitive; args; loc} -> 
      let args = List.map simplif args in
      Lam.prim primitive args loc
    | Lswitch(l, sw) ->
      let new_l = simplif l
      and new_consts =  List.map (fun (n, e) -> (n, simplif e)) sw.sw_consts
      and new_blocks =  List.map (fun (n, e) -> (n, simplif e)) sw.sw_blocks
      and new_fail = Misc.may_map simplif sw.sw_failaction in
      Lam.switch
        new_l
         { 
           sw with 
           sw_consts = new_consts ;
           sw_blocks = new_blocks; 
           sw_failaction = new_fail}
    | Lstringswitch(l,sw,d) ->
      Lam.stringswitch
        (simplif l) (List.map (fun (s,l) -> s,simplif l) sw)
         (Misc.may_map simplif d)
    | Ltrywith (l1, v, l2) -> 
      Lam.try_ (simplif l1) v (simplif l2)
    | Lifthenelse (l1, l2, l3) -> 
      Lam.if_ (simplif l1) (simplif l2) (simplif l3)
    | Lsequence (l1, l2) -> Lam.seq (simplif l1) (simplif l2)
    | Lwhile (l1, l2) -> Lam.while_ (simplif l1) (simplif l2)
    | Lfor (v, l1, l2, dir, l3) ->
      Lam.for_ v (simplif l1) (simplif l2) dir (simplif l3)
    | Lassign (v, l) -> 
      Lam.assign v (simplif l)
    | Lsend (k, m, o, ll, loc) ->
      Lam.send k (simplif m) (simplif o) (List.map simplif ll) loc
    | Lifused (v, l) -> 
      Lam.ifused v (simplif l)
  in 
  simplif lam 
 
let simplify_exits (lam : Lam.t) =
  let exits = count_helper lam in
  subst_helper (Hashtbl.create 17 ) (count_exit exits) lam

(* Compile-time beta-reduction of functions immediately applied:
      Lapply(Lfunction(Curried, params, body), args, loc) ->
        let paramN = argN in ... let param1 = arg1 in body
      Lapply(Lfunction(Tupled, params, body), [Lprim(Pmakeblock(args))], loc) ->
        let paramN = argN in ... let param1 = arg1 in body
   Assumes |args| = |params|.
*)

end
module Lam_pass_lets_dce : sig 
#1 "lam_pass_lets_dce.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)
(* Adapted for Javascript backend: Hongbo Zhang                        *)

(**
   This pass would do beta reduction, and dead code elimination (adapted from compiler's built-in [Simplif] module )

   1. beta reduction -> Llet (Strict )
  
   2. The global table [occ] associates to each let-bound identifier
   the number of its uses (as a reference):
     - 0 if never used
     - 1 if used exactly once in and *not under a lambda or within a loop
     - > 1 if used several times or under a lambda or within a loop.

   The local table [bv] associates to each locally-let-bound variable
   its reference count, as above.  [bv] is enriched at let bindings
   but emptied when crossing lambdas and loops. 

   For this pass, when it' used under a lambda or within a loop, we don't do anything,
   in theory, we can still do something if it's pure but we are conservative here.

   [bv] is used to help caculate [occ] it is not useful outside

 *)
val simplify_lets :  Lam.t -> Lam.t

end = struct
#1 "lam_pass_lets_dce.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)
(* Adapted for Javascript backend : Hongbo Zhang,  *)


open Asttypes

exception Real_reference

let rec eliminate_ref id (lam : Lam.t) = 
  match lam with  (** we can do better escape analysis in Javascript backend *)
  | Lvar v ->
    if Ident.same v id then raise Real_reference else lam
  | Lprim {primitive = Pfield (0,_); args =  [Lvar v]} when Ident.same v id ->
    Lam.var id
  | Lfunction{ kind; params; body} as lam ->
    if Ident_set.mem id (Lam_util.free_variables  lam)
    then raise Real_reference
    else lam
  (* In Javascript backend, its okay, we can reify it later
     a failed case 
     {[
       for i = .. 
           let v = ref 0 
               for j = .. 
                   incr v 
                     a[j] = ()=>{!v}

     ]}
     here v is captured by a block, and it's a loop mutable value,
     we have to generate 
     {[
       for i = .. 
           let v = ref 0 
               (function (v){for j = .. 
                                   a[j] = ()=>{!v}}(v)

     ]}
     now, v is a real reference 
     TODO: we can refine analysis in later
  *)
  (* Lfunction(kind, params, eliminate_ref id body) *)
  | Lprim {primitive = Psetfield(0, _,_); 
           args =  [Lvar v; e]} when Ident.same v id ->
    Lam.assign id (eliminate_ref id e)
  | Lprim {primitive = Poffsetref delta ; 
           args =  [Lvar v]; loc } when Ident.same v id ->
    Lam.assign id (Lam.prim ~primitive:(Poffsetint delta) ~args:[Lam.var id] loc)
  | Lconst _  -> lam
  | Lapply{fn = e1; args =  el;  loc; status} ->
    Lam.apply 
      (eliminate_ref id e1)
      (List.map (eliminate_ref id) el)
      loc status
  | Llet(str, v, e1, e2) ->
    Lam.let_ str v (eliminate_ref id e1) (eliminate_ref id e2)
  | Lletrec(idel, e2) ->
    Lam.letrec
      (List.map (fun (v, e) -> (v, eliminate_ref id e)) idel)
      (eliminate_ref id e2)
  | Lprim {primitive ; args ; loc} ->
    Lam.prim  ~primitive ~args:(List.map (eliminate_ref id) args) loc
  | Lswitch(e, sw) ->
    Lam.switch(eliminate_ref id e)
            {sw_numconsts = sw.sw_numconsts;
             sw_consts =
               List.map (fun (n, e) -> (n, eliminate_ref id e)) sw.sw_consts;
             sw_numblocks = sw.sw_numblocks;
             sw_blocks =
               List.map (fun (n, e) -> (n, eliminate_ref id e)) sw.sw_blocks;
             sw_failaction =
               Misc.may_map (eliminate_ref id) sw.sw_failaction; }
  | Lstringswitch(e, sw, default) ->
    Lam.stringswitch
      (eliminate_ref id e)
      (List.map (fun (s, e) -> (s, eliminate_ref id e)) sw)
      (Misc.may_map (eliminate_ref id) default)
  | Lstaticraise (i,args) ->
    Lam.staticraise i (List.map (eliminate_ref id) args)
  | Lstaticcatch(e1, i, e2) ->
    Lam.staticcatch (eliminate_ref id e1) i (eliminate_ref id e2)
  | Ltrywith(e1, v, e2) ->
    Lam.try_ (eliminate_ref id e1) v (eliminate_ref id e2)
  | Lifthenelse(e1, e2, e3) ->
    Lam.if_ (eliminate_ref id e1) (eliminate_ref id e2) (eliminate_ref id e3)
  | Lsequence(e1, e2) ->
    Lam.seq (eliminate_ref id e1) (eliminate_ref id e2)
  | Lwhile(e1, e2) ->
    Lam.while_ (eliminate_ref id e1) (eliminate_ref id e2)
  | Lfor(v, e1, e2, dir, e3) ->
    Lam.for_ v
      (eliminate_ref id e1) 
      (eliminate_ref id e2)
      dir
      (eliminate_ref id e3)
  | Lassign(v, e) ->
    Lam.assign v (eliminate_ref id e)
  | Lsend(k, m, o, el, loc) ->
    Lam.send k 
      (eliminate_ref id m) (eliminate_ref id o)
      (List.map (eliminate_ref id) el) loc
  | Lifused(v, e) ->
    Lam.ifused v (eliminate_ref id e)

(*A naive dead code elimination *)
type used_info = { 
  mutable times : int ; 
  mutable captured : bool;
    (* captured in functon or loop, 
       inline in such cases should be careful
       1. can not inline mutable values
       2. avoid re-computation 
    *)
}

type occ_tbl  = (Ident.t, used_info) Hashtbl.t
(* First pass: count the occurrences of all let-bound identifiers *)

type local_tbl = used_info  Ident_map.t

let dummy_info () = {times =  0 ; captured = false }
(* y is untouched *)

let absorb_info (x : used_info) (y : used_info) = 
  match x, y with
  | {times = x0} , {times = y0; captured } -> 
    x.times <- x0 + y0;
    if captured then x.captured <- true

let lets_helper (count_var : Ident.t -> used_info) lam = 
  let subst = Hashtbl.create 31 in
  let used v = (count_var v ).times > 0 in
  let rec simplif (lam : Lam.t) = 
    match lam with 
    | Lvar v  ->
      begin try Hashtbl.find subst v with Not_found -> lam end
    | Llet( (Strict | Alias | StrictOpt) , v, Lvar w, l2) 
      ->
      Hashtbl.add subst v (simplif (Lam.var w));
      simplif l2
    | Llet((Strict | StrictOpt as kind) ,
           v, (Lprim {primitive = (Pmakeblock(0, tag_info, Mutable) 
                                   as primitive); 
                      args = [linit] ; loc}), lbody)
      ->
      let slinit = simplif linit in
      let slbody = simplif lbody in
      begin 
        try (** TODO: record all references variables *)
          Lam_util.refine_let
            ~kind:Variable v slinit (eliminate_ref v slbody)
        with Real_reference ->
          Lam_util.refine_let 
            ~kind v (Lam.prim ~primitive ~args:[slinit] loc)
            slbody
      end
    | Llet(Alias, v, l1, l2) ->
      (** For alias, [l1] is pure, we can always inline,
          when captured, we should avoid recomputation
      *)
      begin 
        match count_var v, l1  with
        | {times = 0; _}, _  -> simplif l2 
        | {times = 1; captured = false }, _ 
        | {times = 1; captured = true }, (Lconst _ | Lvar _)
        |  _, (Lconst 
                 (Const_base (
                     Const_int _ | Const_char _ | Const_float _ | Const_int32 _ 
                     | Const_nativeint _ )
                 | Const_pointer _ ) (* could be poly-variant [`A] -> [65a]*)
              | Lprim {primitive = Pfield (_);
                       args = [Lprim {primitive = Pgetglobal _;  _}]}
            ) 
          (* Const_int64 is no longer primitive
             Note for some constant which is not 
             inlined, we can still record it and
             do constant folding independently              
          *)
          ->
          Hashtbl.add subst v (simplif l1); simplif l2
        | _ -> Lam.let_ Alias v (simplif l1) (simplif l2)
      end
    | Llet(StrictOpt as kind, v, l1, l2) ->
      (** can not be inlined since [l1] depend on the store
          {[
            let v = [|1;2;3|]
          ]}
          get [StrictOpt] here,  we can not inline v, 
          since the value of [v] can be changed
      *)
      if not @@ used v 
      then simplif l2
      else Lam_util.refine_let ~kind v (simplif l1 ) (simplif l2)
    (* TODO: check if it is correct rollback to [StrictOpt]? *)

    | Llet((Strict | Variable as kind), v, l1, l2) -> 
      if not @@ used v 
      then
        let l1 = simplif l1 in
        let l2 = simplif l2 in
        if Lam_analysis.no_side_effects l1 
        then l2 
        else Lam.seq l1 l2
      else Lam_util.refine_let ~kind v (simplif l1) (simplif l2)

    | Lifused(v, l) ->
      if used  v then
        simplif l
      else Lam.unit
    | Lsequence(Lifused(v, l1), l2) ->
      if used v 
      then Lam.seq (simplif l1) (simplif l2)
      else simplif l2
    | Lsequence(l1, l2) -> Lam.seq (simplif l1) (simplif l2)

    | Lapply{fn = Lfunction{kind =  Curried; params; body};  args; _}
      when  Ext_list.same_length params args ->
      simplif (Lam_beta_reduce.beta_reduce  params body args)
    | Lapply{ fn = Lfunction{kind = Tupled; params; body};
             args = [Lprim {primitive = Pmakeblock _;  args; _}]; _}
      (** TODO: keep track of this parameter in ocaml trunk,
          can we switch to the tupled backend?
      *)
      when  Ext_list.same_length params  args ->
      simplif (Lam_beta_reduce.beta_reduce params body args)

    | Lapply{fn = l1;args =  ll; loc; status} -> 
      Lam.apply (simplif l1) (List.map simplif ll) loc status
    | Lfunction{arity; kind; params; body = l} ->
      Lam.function_ ~arity ~kind ~params ~body:(simplif l)
    | Lconst _ -> lam
    | Lletrec(bindings, body) ->
      Lam.letrec 
        (List.map (fun (v, l) -> (v, simplif l)) bindings) 
        (simplif body)
    | Lprim {primitive; args; loc} 
      -> Lam.prim ~primitive ~args:(List.map simplif args) loc
    | Lswitch(l, sw) ->
      let new_l = simplif l
      and new_consts =  List.map (fun (n, e) -> (n, simplif e)) sw.sw_consts
      and new_blocks =  List.map (fun (n, e) -> (n, simplif e)) sw.sw_blocks
      and new_fail = Misc.may_map simplif sw.sw_failaction in
      Lam.switch
        new_l
        {sw with sw_consts = new_consts ; sw_blocks = new_blocks;
                 sw_failaction = new_fail}
    | Lstringswitch (l,sw,d) ->
      Lam.stringswitch
        (simplif l) (List.map (fun (s,l) -> s,simplif l) sw)
         (Misc.may_map simplif d)
    | Lstaticraise (i,ls) ->
      Lam.staticraise i (List.map simplif ls)
    | Lstaticcatch(l1, (i,args), l2) ->
      Lam.staticcatch (simplif l1) (i,args) (simplif l2)
    | Ltrywith(l1, v, l2) -> Lam.try_ (simplif l1) v (simplif l2)
    | Lifthenelse(l1, l2, l3) -> 
      Lam.if_ (simplif l1) (simplif l2) (simplif l3)
    | Lwhile(l1, l2) 
      -> 
      Lam.while_ (simplif l1) (simplif l2)
    | Lfor(v, l1, l2, dir, l3) ->
      Lam.for_ v (simplif l1) (simplif l2) dir (simplif l3)
    | Lassign(v, l) -> Lam.assign v (simplif l)
    | Lsend(k, m, o, ll, loc) ->
      Lam.send k (simplif m) (simplif o) (List.map simplif ll) loc
  in simplif lam ;;


(* To transform let-bound references into variables *)
let apply_lets  occ lambda = 
  let count_var v =
    try
      Hashtbl.find occ v
    with Not_found -> dummy_info () in
  lets_helper count_var lambda      

let collect_occurs  lam : occ_tbl =
  let occ : occ_tbl = Hashtbl.create 83 in
  (* The global table [occ] associates to each let-bound identifier
     the number of its uses (as a reference):
     - 0 if never used
     - 1 if used exactly once in and not under a lambda or within a loop
         - when under a lambda, 
         - it's probably a closure
         - within a loop
         - update reference,
         niether is good for inlining
     - > 1 if used several times or under a lambda or within a loop.
     The local table [bv] associates to each locally-let-bound variable
     its reference count, as above.  [bv] is enriched at let bindings
     but emptied when crossing lambdas and loops. *)

  (* Current use count of a variable. *)
  let used v = 
    match Hashtbl.find occ v with 
    | exception Not_found -> false 
    | {times ; _} -> times > 0  in

  (* Entering a [let].  Returns updated [bv]. *)
  let bind_var bv ident =
    let r = dummy_info () in
    Hashtbl.add occ ident r;
    Ident_map.add ident r bv in

  (* Record a use of a variable *)
  let add_one_use bv ident  =
    match Ident_map.find ident bv with 
    | r  -> r.times <- r.times + 1 
    | exception Not_found ->
      (* ident is not locally bound, therefore this is a use under a lambda
         or within a loop.  Increase use count by 2 -- enough so
         that single-use optimizations will not apply. *)
      match Hashtbl.find occ ident with 
      | r -> absorb_info r {times = 1; captured =  true}
      | exception Not_found ->
        (* Not a let-bound variable, ignore *)
        () in

  let inherit_use bv ident bid =
    let n = try Hashtbl.find occ bid with Not_found -> dummy_info () in
    match Ident_map.find ident bv with 
    | r  -> absorb_info r n
    | exception Not_found ->
      (* ident is not locally bound, therefore this is a use under a lambda
         or within a loop.  Increase use count by 2 -- enough so
         that single-use optimizations will not apply. *)
      match Hashtbl.find occ ident with 
      | r -> absorb_info r {n with captured = true} 
      | exception Not_found ->
        (* Not a let-bound variable, ignore *)
        () in

  let rec count (bv : local_tbl) (lam : Lam.t) = 
    match lam with 
    | Lfunction{body = l} ->
      count Ident_map.empty l
    (** when entering a function local [bv] 
        is cleaned up, so that all closure variables will not be
        carried over, since the parameters are never rebound, 
        so it is fine to kep it empty
    *)
    | Lvar v ->
      add_one_use bv v 
    | Llet(_, v, Lvar w, l2)  ->
      (* v will be replaced by w in l2, so each occurrence of v in l2
         increases w's refcount *)
      count (bind_var bv v) l2;
      inherit_use bv w v 
    (* | Lprim(Pmakeblock _, ll)  *)
    (*     ->  *)
    (*       List.iter (fun x -> count bv x ; count bv x) ll *)
    (* | Llet(kind, v, (Lprim(Pmakeblock _, _) as l1),l2) -> *)
    (*     count (bind_var bv v) l2; *)
    (*     (\* If v is unused, l1 will be removed, so don't count its variables *\) *)
    (*     if kind = Strict || count_var v > 0 then *)
    (*       count bv l1; count bv l1 *)

    | Llet(kind, v, l1, l2) ->
      count (bind_var bv v) l2;
      (* If v is unused, l1 will be removed, so don't count its variables *)
      if kind = Strict || used v then count bv l1

    | Lprim {args; _} -> List.iter (count bv ) args

    | Lletrec(bindings, body) ->
      List.iter (fun (v, l) -> count bv l) bindings;
      count bv body
    | Lapply{fn = Lfunction{kind= Curried; params; body};  args; _}
      when  Ext_list.same_length params args ->
      count bv (Lam_beta_reduce.beta_reduce  params body args)
    | Lapply{fn = Lfunction{kind = Tupled; params; body};
             args = [Lprim {primitive = Pmakeblock _;  args; _}]; _}
      when  Ext_list.same_length params  args ->
      count bv (Lam_beta_reduce.beta_reduce   params body args)
    | Lapply{fn = l1; args= ll; _} ->
      count bv l1; List.iter (count bv) ll
    | Lassign(_, l) ->
      (* Lalias-bound variables are never assigned, so don't increase
         this ident's refcount *)
      count bv l
    | Lconst cst -> ()
    | Lswitch(l, sw) ->
      count_default bv sw ;
      count bv l;
      List.iter (fun (_, l) -> count bv l) sw.sw_consts;
      List.iter (fun (_, l) -> count bv l) sw.sw_blocks
    | Lstringswitch(l, sw, d) ->
      count bv l ;
      List.iter (fun (_, l) -> count bv l) sw ;
      begin 
        match d with
        | Some d -> count bv d 
        (* begin match sw with *)
        (* | []|[_] -> count bv d *)
        (* | _ -> count bv d ; count bv d *)
        (* end *)
        | None -> ()
      end
    | Lstaticraise (i,ls) -> List.iter (count bv) ls
    | Lstaticcatch(l1, (i,_), l2) -> count bv l1; count bv l2
    | Ltrywith(l1, v, l2) -> count bv l1; count bv l2
    | Lifthenelse(l1, l2, l3) -> count bv l1; count bv l2; count bv l3
    | Lsequence(l1, l2) -> count bv l1; count bv l2
    | Lwhile(l1, l2) -> count Ident_map.empty l1; count Ident_map.empty l2
    | Lfor(_, l1, l2, dir, l3) -> 
      count bv l1;
      count bv l2; 
      count Ident_map.empty l3
    | Lsend(_, m, o, ll, _) -> List.iter (count bv) (m::o::ll)
    | Lifused(v, l) ->
      if used v then count bv l

  and count_default bv sw = 
    match sw.sw_failaction with
    | None -> ()
    | Some al ->
      let nconsts = List.length sw.sw_consts
      and nblocks = List.length sw.sw_blocks in
      if nconsts < sw.sw_numconsts && nblocks < sw.sw_numblocks
      then 
        begin (* default action will occur twice in native code *)
          count bv al ; count bv al
        end 
      else 
        begin (* default action will occur once *)
          assert (nconsts < sw.sw_numconsts || nblocks < sw.sw_numblocks) ;
          count bv al
        end
  in
  count Ident_map.empty  lam;
  occ

let simplify_lets  (lam : Lam.t) = 
  let occ =  collect_occurs  lam in 
  apply_lets  occ   lam

end
module Lam_inline_util : sig 
#1 "lam_inline_util.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Utilities for lambda inlining *)

val maybe_functor : string -> bool

val should_be_functor : string -> Lam.t -> bool 

end = struct
#1 "lam_inline_util.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)







(* TODO: add a context, like 
    [args]
    [Lfunction(params,body)]
 *)


let maybe_functor (name : string) = 
  name.[0] >= 'A' && name.[0] <= 'Z'


let should_be_functor (name : string) (lam : Lam.t) = 
  maybe_functor name  &&
  (match lam with Lfunction _ -> true | _ -> false)



end
module Lam_pass_remove_alias : sig 
#1 "lam_pass_remove_alias.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Keep track of the global module Aliases *) 

(**
    One way:  guarantee that all global aliases *would be removed* ,
    it will not be aliased 
    
    So the only remaining place for globals is either 
    just  Pgetglobal in functor application or 
    `Lprim (Pfield( i ), [Pgetglobal])`

    This pass does not change meta  data
*)

val simplify_alias : 
  Lam_stats.meta -> 
  Lam.t ->
  Lam.t

end = struct
#1 "lam_pass_remove_alias.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








let simplify_alias 
    (meta : Lam_stats.meta)
    (lam : Lam.t) 
  :  Lam.t  = 

  let rec simpl  (lam : Lam.t) : Lam.t = 
    match lam with 
    | Lvar v -> 
      (* GLOBAL module needs to be propogated *)
      (try Lam.var (Hashtbl.find meta.alias_tbl v) with Not_found -> lam )
    | Llet(kind, k, (Lprim {primitive = Pgetglobal i; args = [] ; _} as g),
           l ) -> 
      (* This is detection of MODULE ALIAS 
          we need track all global module aliases, when it's
          passed as a parameter(escaped), we need do the expansion
          since global module access is not the same as local module
          TODO: 
          since we aliased k, so it's safe to remove it?
      *)
      let v = simpl l in
      if Ident_set.mem k meta.export_idents 
      then 
        Lam.let_ kind k g v
        (* in this case it is preserved, but will still be simplified 
            for the inner expression
        *)
      else v
    | Lprim {primitive = Pfield (i,_); args =  [Lvar v]; _} -> 
      (* ATTENTION: 
         Main use case, we should detect inline all immutable block .. *)
      Lam_util.get lam v  i meta.ident_tbl 
    | Lifthenelse(Lvar id as l1, l2, l3) 
      -> 
      begin match Hashtbl.find meta.ident_tbl id with 
      | ImmutableBlock ( _, Normal)
      | MutableBlock _  
        -> simpl l2 
      | ImmutableBlock ( [| SimpleForm l |]  , x) 
        -> 
        let l1 = 
          match x with 
          | Null 
            -> Lam.not_ (Location.none) ( Lam.prim ~primitive:Lam.Prim.js_is_nil ~args:[l] Location.none) 
          | Undefined 
            -> 
            Lam.not_  Location.none (Lam.prim ~primitive:Lam.Prim.js_is_undef ~args:[l] Location.none)
          | Null_undefined
            -> 
            Lam.not_ Location.none
              ( Lam.prim ~primitive:Lam.Prim.js_is_nil_undef  ~args:[l] Location.none) 
          | Normal ->  l1 
        in 
        Lam.if_ l1 (simpl l2) (simpl l3)
      | _ -> Lam.if_ l1 (simpl l2) (simpl l3)

      | exception Not_found -> Lam.if_ l1 (simpl l2) (simpl l3)
      end
    | Lifthenelse (l1, l2, l3) -> 
        Lam.if_ (simpl  l1) (simpl  l2) (simpl  l3)

    | Lconst _ -> lam
    | Llet(str, v, l1, l2) ->
      Lam.let_ str v (simpl l1) (simpl l2 )
    | Lletrec(bindings, body) ->
      let bindings = List.map (fun (k,l) ->  (k, simpl l) ) bindings in 
      Lam.letrec bindings (simpl body) 
    | Lprim {primitive; args; loc } 
      -> Lam.prim ~primitive ~args:(List.map simpl  args) loc

    (* complicated 
        1. inline this function
        2. ...
        exports.Make=
        function(funarg)
      {var $$let=Make(funarg);
        return [0, $$let[5],... $$let[16]]}
    *)      
    | Lapply{fn = 
               Lprim {primitive = Pfield (index, _) ;
                      args = [Lprim {primitive = Pgetglobal ident; args =  []}];
                      _} as l1;
             args; loc ; status} ->
      begin
        Lam_compile_env.find_and_add_if_not_exist (ident,index) meta.env
          ~not_found:(fun _ -> assert false)
          ~found:(fun i ->
              match i with
              | {closed_lambda=Some Lfunction{params; body; _} } 
                (** be more cautious when do cross module inlining *)
                when
                  ( Ext_list.same_length params args &&
                    List.for_all (fun (arg : Lam.t) ->
                        match arg with 
                        | Lvar p -> 
                          begin 
                            try Hashtbl.find meta.ident_tbl p <> Parameter
                            with Not_found -> true
                          end
                        |  _ -> true 
                      ) args) -> 
                simpl @@
                Lam_beta_reduce.propogate_beta_reduce
                  meta params body args
              | _ -> 
                Lam.apply (simpl l1) (List.map simpl args) loc status
            )

      end
    (* Function inlining interact with other optimizations...

        - parameter attributes
        - scope issues 
        - code bloat 
    *)      
    | Lapply{fn = (Lvar v as fn);  args; loc ; status} ->
      (* Check info for always inlining *)

      (* Ext_log.dwarn __LOC__ "%s/%d" v.name v.stamp;     *)
      let normal () = Lam.apply ( simpl fn) (List.map simpl args) loc status in
      begin 
        match Hashtbl.find meta.ident_tbl v with
        | Function {lambda = Lfunction {params; body} as _m;
                    rec_flag;                     
                    _ }
          -> 
        
          if Ext_list.same_length args params (* && false *)
          then               
            if Lam_inline_util.maybe_functor v.name  
              (* && (Ident_set.mem v meta.export_idents) && false *)
            then 
              (* TODO: check l1 if it is exported, 
                 if so, maybe not since in that case, 
                 we are going to have two copy?
              *)

              (* Check: recursive applying may result in non-termination *)
              begin
                (* Ext_log.dwarn __LOC__ "beta .. %s/%d" v.name v.stamp ; *)
                simpl (Lam_beta_reduce.propogate_beta_reduce meta params body args) 
              end
            else 
            if (* Lam_analysis.size body < Lam_analysis.small_inline_size *)
              Lam_analysis.ok_to_inline ~body params args 
            then 

                (* let param_map =  *)
                (*   Lam_analysis.free_variables meta.export_idents  *)
                (*     (Lam_analysis.param_map_of_list params) body in *)
                (* let old_count = List.length params in *)
                (* let new_count = Ident_map.cardinal param_map in *)
                let param_map = 
                  Lam_analysis.is_closed_with_map 
                    meta.export_idents params body in
                let is_export_id = Ident_set.mem v meta.export_idents in
                match is_export_id, param_map with 
                | false, (_, param_map)
                | true, (true, param_map) -> 
                  if rec_flag = Rec then               
                    begin
                      (* Ext_log.dwarn __LOC__ "beta rec.. %s/%d" v.name v.stamp ; *)
                      (* Lam_beta_reduce.propogate_beta_reduce meta params body args *)
                      Lam_beta_reduce.propogate_beta_reduce_with_map meta param_map params body args
                    end
                  else 
                    begin
                      (* Ext_log.dwarn __LOC__ "beta  nonrec..[%d] [%a]  %s/%d"  *)
                      (*   (List.length args)  *)
                      (*   Printlambda.lambda body                      *)
                      (*   v.name v.stamp ; *)
                      simpl (Lam_beta_reduce.propogate_beta_reduce_with_map meta param_map params body args)

                    end
                | _ -> normal ()
              else 
                normal ()
          else
            normal ()
        | _ -> normal ()
        | exception Not_found -> normal ()

      end

    | Lapply{ fn = Lfunction{ kind = Curried ; params; body}; args; _}
      when  Ext_list.same_length params args ->
      simpl (Lam_beta_reduce.propogate_beta_reduce meta params body args)
    | Lapply{ fn = Lfunction{kind =  Tupled;  params; body}; 
             args = [Lprim {primitive = Pmakeblock _; args; _}]; _}
      (** TODO: keep track of this parameter in ocaml trunk,
          can we switch to the tupled backend?
      *)
      when  Ext_list.same_length params args ->
      simpl (Lam_beta_reduce.propogate_beta_reduce meta params body args)

    | Lapply {fn = l1; args =  ll;  loc ; status} ->
      Lam.apply (simpl  l1) (List.map simpl  ll) loc status
    | Lfunction {arity; kind; params; body = l}
      -> Lam.function_ ~arity ~kind ~params  ~body:(simpl  l)
    | Lswitch (l, {sw_failaction; 
                   sw_consts; 
                   sw_blocks;
                   sw_numblocks;
                   sw_numconsts;
                  }) ->
      Lam.switch (simpl  l)
               {sw_consts = 
                  List.map (fun (v, l) -> v, simpl  l) sw_consts;
                sw_blocks = List.map (fun (v, l) -> v, simpl  l) sw_blocks;
                sw_numconsts = sw_numconsts;
                sw_numblocks = sw_numblocks;
                sw_failaction = 
                  begin 
                    match sw_failaction with 
                    | None -> None
                    | Some x -> Some (simpl x)
                  end}
    | Lstringswitch(l, sw, d) ->
      Lam.stringswitch (simpl  l )
                    (List.map (fun (i, l) -> i,simpl  l) sw)
                    (match d with
                     | Some d -> Some (simpl d )
                     | None -> None)
    | Lstaticraise (i,ls) -> 
      Lam.staticraise i (List.map simpl  ls)
    | Lstaticcatch (l1, ids, l2) -> 
      Lam.staticcatch (simpl  l1) ids (simpl  l2)
    | Ltrywith (l1, v, l2) -> Lam.try_ (simpl  l1) v (simpl  l2)

    | Lsequence (Lprim {primitive = Pgetglobal (id); args = []}, l2)
      when Lam_compile_env.is_pure (Lam_module_ident.of_ml id) 
      -> simpl l2
    | Lsequence(l1, l2)
      -> Lam.seq (simpl  l1) (simpl  l2)
    | Lwhile(l1, l2)
      -> Lam.while_ (simpl  l1) (simpl l2)
    | Lfor(flag, l1, l2, dir, l3)
      -> 
      Lam.for_ flag (simpl  l1) (simpl  l2) dir (simpl  l3)
    | Lassign(v, l) ->
      (* Lalias-bound variables are never assigned, so don't increase
         v's refsimpl *)
      Lam.assign v (simpl  l)
    | Lsend (u, m, o, ll, v) 
      -> 
      Lam.send u (simpl m) (simpl o) (List.map simpl ll) v
    | Lifused (v, l) -> Lam.ifused v (simpl  l)
  in 
  simpl lam

end
module Ext_option : sig 
#1 "ext_option.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Utilities for [option] type *)

val bind : 'a option -> ('a -> 'b) -> 'b option

end = struct
#1 "ext_option.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








let bind v f = 
  match v with 
  | None -> None
  | Some x -> Some (f x )

end
module Lam_stats_export : sig 
#1 "lam_stats_export.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






val export_to_cmj : 
  Lam_stats.meta ->
  Js_cmj_format.effect ->
  Lam_module_ident.t list ->
  Lam.t Ident_map.t -> Js_cmj_format.t


end = struct
#1 "lam_stats_export.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






let pp = Format.fprintf 
(* we should exclude meaninglist names and do the convert as well *)

let meaningless_names  = ["*opt*"; "param";]

let rec dump_ident fmt (id : Ident.t) (arity : Lam.function_arities)  = 
  pp fmt  "@[<2>export var %s:@ %a@ ;@]" (Ext_ident.convert true id.name ) dump_arity arity

and dump_arity fmt (arity : Lam.function_arities) = 
  match arity with 
  | NA -> pp fmt "any"
  | Determin (_, [], _) -> pp fmt "any"
  | Determin (_, (n,args)::xs, _) -> 
    let args = match args with 
    | Some args -> args 
    | None -> Ext_list.init n (fun _ -> Ident.create "param") in
    pp fmt "@[(%a)@ =>@ any@]" 
      (Format.pp_print_list  
         ~pp_sep:(fun fmt _ -> 
             Format.pp_print_string fmt ",";
             Format.pp_print_space fmt ();
           )
         (fun fmt ident -> pp fmt "@[%s@ :@ any@]" 
             (Ext_ident.convert true  @@ Ident.name ident))
      ) args 


(* Note that 
   [lambda_exports] is 
   lambda expression to be exported
   for the js backend, we compile to js 
   for the inliner, we try to seriaize it -- 
   relies on other optimizations to make this happen
   {[
     exports.Make = function () {.....}
   ]}
   TODO: check that we don't do this in browser environment
*)
let export_to_cmj 
    (meta : Lam_stats.meta ) 
    maybe_pure
    external_ids 
    export_map

  : Js_cmj_format.t = 
  let values = 

    List.fold_left
      (fun   acc (x : Ident.t)  ->
         let arity =  Lam_stats_util.get_arity meta (Lam.var x) in
         match Ident_map.find x export_map with 
         | lambda  -> 
           if Lam_analysis.safe_to_inline lambda
           (* when inlning a non function, we have to be very careful,
              only truly immutable values can be inlined
           *)
           then
             let closed_lambda = 
               if Lam_inline_util.should_be_functor x.name lambda (* can also be submodule *)
               then
                 if Lam_analysis.is_closed lambda (* TODO: seriealize more*)
                 then Some lambda
                 else None
               else 
                 let lam_size = Lam_analysis.size lambda in
                 (* TODO:
                    1. global need re-assocate when do the beta reduction 
                    2. [lambda_exports] is not precise
                 *)
                 let free_variables =
                   Lam_analysis.free_variables Ident_set.empty
                   (* meta.export_idents *)  Ident_map.empty 
                     lambda in
                 if  lam_size < Lam_analysis.small_inline_size  && 
                     Ident_map.is_empty free_variables
                 then 
                   begin
                     Ext_log.dwarn __LOC__ "%s recorded for inlining @." x.name ;
                     Some lambda
                   end
                 else 
                   begin
                     (* Ext_log.dwarn __LOC__ "%s : %d : {%s} not inlined @."  *)
                     (*   x.name lam_size   *)
                     (*   (String.concat ", " @@  *)
                     (*    List.map (fun x -> x.Ident.name) @@ Ident_map.keys free_variables) ; *)
                     None 
                   end
             in 
             String_map.add x.name  Js_cmj_format.{arity ; closed_lambda } acc 
           else
             String_map.add x.name  Js_cmj_format.{arity ; closed_lambda = None } acc 
         | exception Not_found 
           -> String_map.add x.name  Js_cmj_format.{arity ; closed_lambda = None} acc  
      )
      String_map.empty
      meta.exports 


  in

  let rec dump fmt ids = 
    (* TODO: also use {[Ext_pp]} module instead *)
    match ids with 
    | [] -> ()
    | x::xs -> 
      dump_ident fmt x (Lam_stats_util.get_arity meta (Lam.var x)) ; 
      Format.pp_print_space fmt ();
      dump fmt xs in

  let () =
    if !Js_config.default_gen_tds && not ( Ext_string.is_empty meta.filename) then
      Ext_pervasives.with_file_as_pp
        (Ext_filename.chop_extension ~loc:__LOC__ meta.filename ^ ".d.ts")
      @@ fun fmt ->
        pp fmt "@[<v>%a@]@." dump meta.exports
  in
  let effect = 
    match maybe_pure with
    | None ->  
      Ext_option.bind ( Ext_list.for_all_ret 
                          (fun (id : Lam_module_ident.t) -> 
                             Lam_compile_env.query_and_add_if_not_exist id 
                               (Has_env meta.env )
                               ~not_found:(fun _ -> false ) ~found:(fun i -> 
                                   i.pure)
                          ) external_ids) (fun x -> Lam_module_ident.name x)
    | Some _ -> maybe_pure

  in
  {values; 
   effect ; 
   npm_package_path = Js_config.get_packages_info ();
  }


end
module Lam_compile_group : sig 
#1 "lam_compile_group.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** BuckleScript entry point in the OCaml compiler *) 

(** Compile and register the hook of function to compile  a lambda to JS IR 
 *)

(** For toplevel, [filename] is [""] which is the same as
    {!Env.get_unit_name ()}
 *)
val compile :  
  filename : string -> 
  string -> 
  bool -> 
  Env.t -> 
  Types.signature -> 
  Lambda.lambda -> 
  J.deps_program

val lambda_as_module :  
  Env.t ->
  Types.signature -> string -> 
  string  -> Lambda.lambda -> unit

end = struct
#1 "lam_compile_group.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








module E = Js_exp_make 
module S = Js_stmt_make  

open Js_output.Ops

exception Not_a_module

let compile_group ({filename = file_name; env;} as meta : Lam_stats.meta) 
    (x : Lam_group.t) : Js_output.t  = 
  match x, file_name with 
  (* 
        We need

        2. [E.builtin_dot] for javascript builtin
        3. [E.mldot]
     *)
  (* ATTENTION: check {!Lam_compile_global} for consistency  *)      
  (** Special handling for values in [Pervasives] *)
  | Single(_, ({name="stdout"|"stderr"|"stdin";_} as id),_ ),
    "pervasives.ml" -> 
    Js_output.of_stmt @@ S.alias_variable id
      ~exp:(E.runtime_ref  Js_config.io id.name)
  (* 
         we delegate [stdout, stderr, and stdin] into [caml_io] module, 
         the motivation is to help dead code eliminatiion, it's helpful 
         to make those parts pure (not a function call), then it can be removed 
         if unused 
      *)                     
  | Single(_, ({name="infinity";_} as id),_ ),  "pervasives.ml" 
    -> (* TODO: check relative path to compiler*)
    Js_output.of_stmt @@ S.alias_variable id ~exp:(E.js_global "Infinity")
  | Single(_, ({name="neg_infinity";_} as id),_ ), "pervasives.ml" ->
    Js_output.of_stmt @@ S.alias_variable id ~exp:(E.js_global "-Infinity")
  | Single(_, ({name="nan";_} as id),_ ),  "pervasives.ml" ->
    Js_output.of_stmt @@ S.alias_variable id ~exp:(E.js_global "NaN")

  (* TODO: 
      Make it more safe, we should rewrite the last one...
       checkout [E.mldot], it would make sense that cross module inlining done there
       In general, we would like to do such specialization on primitive specialization
        [Lam_dispatch_primitive], here it makes an exception since this function is not a primitive
  *) 
  | Single(_, ({name="^";_} as id),_ ),  "pervasives.ml" ->
    Js_output.of_stmt @@ S.alias_variable id 
      ~exp:(let a = Ext_ident.create "a" in 
            let b = Ext_ident.create "b" in
            E.ocaml_fun [a;b] [S.return (E.string_append (E.var a) (E.var b))]
            )

  (* QUICK hack to make hello world example nicer,
     Note the arity of [print_endline] is already analyzed before, 
     so it should be safe
  *)
  | Single(_, ({name="print_endline";_} as id),_ ),  "pervasives.ml" ->
    Js_output.of_stmt @@ S.alias_variable id 
      ~exp:(let param = Ext_ident.create "param" in 
            E.ocaml_fun [param] [S.return 
                              (E.seq (E.call ~info:{arity=Full; call_info = Call_na} 
                                        (E.js_global "console.log") [E.var param]) 
                                      E.zero_int_literal )] )
  | Single(_, ({name="prerr_endline";_} as id),_ ),  "pervasives.ml" ->
    Js_output.of_stmt @@ S.alias_variable id 
      ~exp:(let param = Ext_ident.create "param" in 
            E.ocaml_fun [param] [S.return 
                              (E.seq (E.call ~info:{arity=Full; call_info = Call_na} 
                                        (E.js_global "console.error") [E.var param]) 
                                 E.zero_int_literal )] )


  | Single(_, ({name="string_of_int";_} as id),_ ),  "pervasives.ml" ->
    Js_output.of_stmt @@ S.alias_variable id
      ~exp:( 
        let arg = Ext_ident.create "param" in
        E.ocaml_fun [arg] [S.return (E.anything_to_string (E.var arg))]
      )

  | Single(_, ({name="max_float";_} as id),_ ),  "pervasives.ml" ->

    Js_output.of_stmt @@ S.alias_variable id 
      ~exp:(E.js_global_dot "Number" "MAX_VALUE")
  | Single(_, ({name="min_float";_} as id) ,_ ), "pervasives.ml" ->
    Js_output.of_stmt @@  S.alias_variable id
      ~exp:(E.js_global_dot  "Number" "MIN_VALUE")
  | Single(_, ({name="epsilon_float";_} as id) ,_ ),  "pervasives.ml" ->
    Js_output.of_stmt @@ S.alias_variable id 
      ~exp:(E.float "2.220446049250313e-16")
  | Single(_, ({name="cat";_} as id) ,_ ),  "bytes.ml" ->
    Js_output.of_stmt @@ S.alias_variable id
      ~exp:(let a = Ext_ident.create "a" in 
            let b = Ext_ident.create "b" in
            E.ocaml_fun [a;b] [S.return (E.array_append (E.var a) (E.var b))]
           )

  (** Special handling for values in [Sys] *)
  | Single(_, ({name="max_array_length" | "max_string_length";_} as id) ,_ ),  "sys.ml" ->
    (* See [js_knowledge] Array size section, can not be expressed by OCaml int,
       note that casual handling of {!Sys.max_string_length} could result into 
       negative value which could cause wrong behavior of {!Buffer.create}
     *)
    Js_output.of_stmt @@ S.alias_variable id ~exp:(E.float "2147483647")  (*2 ^ 31 - 1*)
                           
  | Single(_, ({name="max_int";_} as id) ,_ ),  ("sys.ml" | "nativeint.ml") ->
    (* See [js_knowledge] Max int section, (2. ** 53. -. 1.;;)
       can not be expressed by OCaml int 
       FIXME: we need handle {!Nativeint} and {!Sys} differently
    *)
    Js_output.of_stmt @@ S.alias_variable id 
      ~exp:(E.float "9007199254740991.") 

  | Single(_, ({name="min_int";_} as id) ,_ ),  ("sys.ml" | "nativeint.ml") ->
    (* See [js_knowledge] Max int section, -. (2. ** 53. -. 1.);;
       can not be expressed by OCaml int 
       FIXME: we need handle {!Nativeint} and {!Sys} differently
    *)
    Js_output.of_stmt @@ S.alias_variable id
      ~exp:(E.float ("-9007199254740991.")) 

  | Single (kind, id, lam), _ -> 
    (* let lam = Optimizer.simplify_lets [] lam in  *)
    (* can not apply again, it's wrong USE it with care*)
    (* ([Js_stmt_make.comment (Gen_of_env.query_type id  env )], None)  ++ *)
    Lam_compile.compile_let  kind { st = Declare (kind, id);
                                    should_return = False;
                                    jmp_table = Lam_compile_defs.empty_handler_map;
                                    meta
                                  } id  lam

  | Recursive id_lams, _   -> 
    Lam_compile.compile_recursive_lets 
      { st = EffectCall ;
        should_return = False; 
        jmp_table = Lam_compile_defs.empty_handler_map;
        meta
      } 
      id_lams
  | Nop lam, _ -> (* TODO: Side effect callls, log and see statistics *)
    Lam_compile.compile_lambda {st = EffectCall;
                                should_return = False;
                                jmp_table = Lam_compile_defs.empty_handler_map;
                                meta
                               } lam

;;

(** Actually simplify_lets is kind of global optimization since it requires you to know whether 
    it's used or not 
    [no_export] is only used in playground
*)
let compile  ~filename output_prefix no_export env _sigs 
    (lam : Lambda.lambda)   = 
  let export_idents = 
    if no_export then
      []    
    else  Translmod.get_export_identifiers()  
  in
  let () = 
    export_idents |> List.iter 
      (fun (id : Ident.t) -> Ext_log.dwarn __LOC__ "export: %s/%d"  id.name id.stamp) 
  in
  (* To make toplevel happy - reentrant for js-demo *)
  let ()   = 
    Translmod.reset () ; 
    Lam_compile_env.reset () ;
  in 
  let lam = Lam.convert  lam in 
  let _d  = Lam_util.dump env  in
  let _j = Js_pass_debug.dump in
  let lam = _d "initial"  lam in
  let lam  = Lam_group.deep_flatten lam in
  let lam = _d  "flatten" lam in
  let meta = 
    Lam_pass_collect.count_alias_globals env filename  export_idents lam in
  let lam = 
    let lam =  
      lam
      |> _d "flattern"
      |>  Lam_pass_exits.simplify_exits
      |> _d "simplyf_exits"
      |>  Lam_pass_remove_alias.simplify_alias  meta 
      |> _d "simplify_alias"
      |> Lam_group.deep_flatten
      |> _d "flatten"
    in  (* Inling happens*)
  
    let ()  = Lam_pass_collect.collect_helper meta lam in
    let lam = Lam_pass_remove_alias.simplify_alias meta lam  in
    let lam = Lam_group.deep_flatten lam in
    let ()  = Lam_pass_collect.collect_helper meta lam in
    let lam = 
      lam
      |> _d "alpha_before"
      |> Lam_pass_alpha_conversion.alpha_conversion meta
      |> Lam_pass_exits.simplify_exits in    
    let () = Lam_pass_collect.collect_helper meta lam in


    lam
    |> _d "simplify_alias_before"
    |>  Lam_pass_remove_alias.simplify_alias meta 
    |> _d "alpha_conversion"
    |>  Lam_pass_alpha_conversion.alpha_conversion meta
    |> _d "simplify_lets"
    (* we should investigate a better way to put different passes : )*)
    |> Lam_pass_lets_dce.simplify_lets 
    |> _d "simplify_lets"
    (* |> (fun lam -> Lam_pass_collect.collect_helper meta lam 
       ; Lam_pass_remove_alias.simplify_alias meta lam) *)
    |> Lam_pass_exits.simplify_exits
    |> _d "simplify_lets"


  in

  (* Debug identifier table *)
  (* Lam_stats_util.pp_alias_tbl Format.err_formatter meta.alias_tbl; *)
  (* Lam_stats_util.dump_exports_arities meta ; *)
  (* Lam_stats_util.pp_arities_tbl Format.err_formatter meta.arities_tbl; *)

  (* Dump for debugger *)

  begin 
    match (lam : Lam.t) with
    | Lprim{primitive = Psetglobal id; args =  [biglambda]; _}
      -> 
      (* Invariant: The last one is always [exports]
         Compile definitions
         Compile exports
         Assume Pmakeblock(_,_),
         lambda_exports are pure
         compile each binding with a return value
         This might be wrong in toplevel
      *)

      begin 
        match Lam_group.flatten [] biglambda with 
        | Lprim {primitive = Pmakeblock (_,_,_); args =  lambda_exports},
          rest ->
          let coercion_groups, new_exports, new_export_set,  export_map = 
            if no_export then 
              [], [], Ident_set.empty, Ident_map.empty
            else
              List.fold_right2 
                (fun  eid lam (coercions, new_exports, new_export_set,  export_map) ->
                   match (lam : Lam.t) with 
                   | Lvar id 
                     when Ident.name id = Ident.name eid -> 
                     (* {[ Ident.same id eid]} is more  correct, 
                        however, it will introduce 
                        a coercion, which is not necessary, 
                        as long as its name is the same, we want to avoid 
                        another coercion                        
                     *)
                     (coercions, 
                      id :: new_exports, 
                      Ident_set.add id new_export_set,
                      export_map)
                   | _ -> (** TODO : bug 
                              check [map.ml] here coercion, we introduced 
                              rebound which is not corrrect 
                              {[
                                let Make/identifier = function (funarg){
                                    var $$let = Make/identifier(funarg);
                                            return [0, ..... ]
                                  }
                              ]}
                              Possible fix ? 
                              change export identifier, we should do this in the very 
                              beginning since lots of optimizations depend on this
                              however
                          *)
                     (Lam_group.Single(Strict ,eid,  lam) :: coercions, 
                      eid :: new_exports,
                      Ident_set.add eid new_export_set, 
                      Ident_map.add eid lam export_map))
                meta.exports lambda_exports 
                ([],[], Ident_set.empty, Ident_map.empty)
          in
          let () = 
            new_exports |> List.iter 
              (fun (id : Ident.t) -> Ext_log.dwarn __LOC__ "export: %s/%d"  id.name id.stamp) 
          in
          let meta = { meta with 
                       export_idents = new_export_set;
                       exports = new_exports
                     } in 
          let (export_map, rest) = 
            List.fold_left 
              (fun (export_map, acc) x ->
                 (match (x : Lam_group.t)  with 
                 | Single (_,id,lam) when Ident_set.mem id new_export_set 
                   -> Ident_map.add id lam export_map
                 | _ -> export_map), x :: acc ) (export_map, coercion_groups) rest in

          (* TODO: turn in on debug mode later*)
          let () =
            if Js_config.is_same_file () then
              let f =
                Ext_filename.chop_extension ~loc:__LOC__ filename ^ ".lambda" in
              Ext_pervasives.with_file_as_pp f @@ fun fmt ->
              Format.pp_print_list ~pp_sep:Format.pp_print_newline
                (Lam_group.pp_group env) fmt rest ;
          in
          let rest = Lam_dce.remove meta.exports rest 
          in
          let module  E = struct exception  Not_pure of string end in
          (** Also need analyze its depenency is pure or not *)
          let no_side_effects rest = 
            Ext_list.for_all_opt (fun (x : Lam_group.t) -> 
                match x with 
                | Single(kind,id,body) -> 
                  begin 
                    match kind with 
                    | Strict | Variable -> 
                      if not @@ Lam_analysis.no_side_effects body 
                      then Some  (Printf.sprintf "%s" id.name)
                      else None
                    | _ -> None
                  end
                | Recursive bindings -> 
                  Ext_list.for_all_opt (fun (id,lam) -> 
                      if not @@ Lam_analysis.no_side_effects lam 
                      then Some (Printf.sprintf "%s" id.Ident.name )
                      else None
                    ) bindings
                | Nop lam -> 
                  if not @@ Lam_analysis.no_side_effects lam 
                  then 
                    (*  (Lam_util.string_of_lambda lam) *)
                    Some ""
                  else None (* TODO :*))
              rest
          in
          let maybe_pure = no_side_effects rest
          in
          let body  = 
            rest
            |> List.map (fun group -> compile_group meta group)
            |> Js_output.concat
            |> Js_output.to_block
          in
          (* The file is not big at all compared with [cmo] *)
          (* Ext_marshal.to_file (Ext_filename.chop_extension filename ^ ".mj")  js; *)
          let js = 
            Js_program_loader.make_program filename meta.exports
              body 
          in
          js 
          |> _j "initial"
          |> Js_pass_flatten.program
          |> _j "flattern"
          |> Js_pass_tailcall_inline.tailcall_inline
          |> _j "inline_and_shake"
          |> Js_pass_flatten_and_mark_dead.program
          |> _j "flatten_and_mark_dead"
          (* |> Js_inline_and_eliminate.inline_and_shake *)
          (* |> _j "inline_and_shake" *)
          |> (fun js -> ignore @@ Js_pass_scope.program  js ; js )
          |> Js_shake.shake_program
          |> _j "shake"
          |> ( fun (js:  J.program) -> 
            let external_module_ids = 
              Lam_compile_env.get_requried_modules  
                meta.env
                meta.required_modules  
                (Js_fold_basic.calculate_hard_dependencies js.block)
              |>
              (fun x ->
                 if !Js_config.sort_imports then
                   Ext_list.sort_via_array
                     (fun (id1 : Lam_module_ident.t) (id2 : Lam_module_ident.t) ->
                       String.compare (Lam_module_ident.name id1) (Lam_module_ident.name id2)
                     ) x
                 else
                   x
              )
            in

            let v = 
              Lam_stats_export.export_to_cmj meta  maybe_pure external_module_ids
                (if no_export then Ident_map.empty else export_map) 
            in
            (if not @@ !Clflags.dont_write_files then
               Js_cmj_format.to_file 
                  (output_prefix ^ Js_config.cmj_ext) v);
            Js_program_loader.decorate_deps external_module_ids v.effect js
          )
        | _ -> raise Not_a_module
      end
    | _ -> raise Not_a_module end
;;



let lambda_as_module 
    env 
    (sigs : Types.signature)
    (filename : string) 
    (output_prefix : string)
    (lam : Lambda.lambda) = 
  begin 
    Js_config.set_current_file filename ;  
    Js_config.iset_debug_file "jsoo_400_test.ml";
    let lambda_output = compile ~filename output_prefix false env sigs lam in
    let (//) = Filename.concat in 
    let basename =  
      (* #758, output_prefix is already chopped *)
        (Filename.basename
           output_prefix (* -o *)
        (* filename *) (* see #757  *)
        ) ^  Js_config.get_ext() in
    (* Not re-entrant *)
    match Js_config.get_packages_info () with 
    | Empty 
    | NonBrowser (_, []) -> 
      (* script mode *)
      let output_filename = 
        (if Filename.is_relative filename then 
           Lazy.force Ext_filename.cwd // 
           Filename.dirname filename 
         else 
           Filename.dirname filename) // basename         
      in 
      let output_chan chan =         
        Js_dump.dump_deps_program output_prefix `NodeJS lambda_output chan in
      (if !Js_config.dump_js then output_chan stdout);
      if not @@ !Clflags.dont_write_files then 
        Ext_pervasives.with_file_as_chan 
          output_filename output_chan


    | NonBrowser (_package_name, module_systems) -> 
      module_systems |> List.iter begin fun (module_system, _path) -> 
        let output_filename = 
          Lazy.force Ext_filename.package_dir //
          _path //
          basename 
        in
        let output_chan chan  = 
          Js_dump.dump_deps_program ~output_prefix
            module_system 
            lambda_output
            chan in
        (if !Js_config.dump_js then 
          output_chan  stdout);
        if not @@ !Clflags.dont_write_files then 
          Ext_pervasives.with_file_as_chan output_filename output_chan
            
      end
  end
(* We can use {!Env.current_unit = "Pervasives"} to tell if it is some specific module, 
    We need handle some definitions in standard libraries in a special way, most are io specific, 
    includes {!Pervasives.stdin, Pervasives.stdout, Pervasives.stderr}

    However, use filename instead of {!Env.current_unit} is more honest, since node-js module system is coupled with the file name 
*)

end
module Ast_signature : sig 
#1 "ast_signature.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type item = Parsetree.signature_item
type t = item list 
val fuse : ?loc:Ast_helper.loc -> item -> t -> item

end = struct
#1 "ast_signature.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type item = Parsetree.signature_item
type t = item list 

open Ast_helper
let fuse ?(loc=Location.none) (item : item) (t : t) : item = 
  Sig.include_ ~loc (Incl.mk ~loc (Mty.signature ~loc (item::t)))

end
module Ast_structure : sig 
#1 "ast_structure.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


type item = Parsetree.structure_item

type t = item list 

val fuse : ?loc:Ast_helper.loc -> item -> t -> item

val constraint_ : ?loc:Ast_helper.loc -> t -> Ast_signature.t -> item

end = struct
#1 "ast_structure.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type item = Parsetree.structure_item

type t = item list 

open Ast_helper

let fuse ?(loc=Location.none) (item : item ) (t : t) : item = 
  Str.include_ ~loc 
    (Incl.mk ~loc (Mod.structure ~loc (item :: t) ))

let constraint_ ?(loc=Location.none) (stru : t) (sign : Ast_signature.t) = 
  Str.include_ ~loc
    (Incl.mk ~loc 
       (Mod.constraint_ ~loc (Mod.structure ~loc stru) (Mty.signature ~loc sign)))

end
module Ast_derive : sig 
#1 "ast_derive.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


type gen = {
  structure_gen : Parsetree.type_declaration list -> bool -> Ast_structure.t ;
  signature_gen : Parsetree.type_declaration list -> bool -> Ast_signature.t ; 
  expression_gen : (Parsetree.core_type -> Parsetree.expression) option ; 
}

val type_deriving_structure: 
  Parsetree.type_declaration list  ->
  Ast_payload.action list ->
  bool -> 
  Ast_structure.t
val type_deriving_signature: 
  Parsetree.type_declaration list ->
  Ast_payload.action list -> 
  bool -> 
  Ast_signature.t


val dispatch_extension : 
  string Asttypes.loc -> Parsetree.core_type -> Parsetree.expression

val update : string -> (Parsetree.expression option -> gen) -> unit

end = struct
#1 "ast_derive.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


type gen = {
  structure_gen : Parsetree.type_declaration list  -> bool -> Ast_structure.t ;
  signature_gen : Parsetree.type_declaration list -> bool -> Ast_signature.t ; 
  expression_gen : (Parsetree.core_type -> Parsetree.expression) option ; 
}

(* the first argument is [config] payload
   {[
     { x = {uu} }
   ]}
*)
type derive_table  = 
  (Parsetree.expression option -> gen) String_map.t

let derive_table : derive_table ref = ref String_map.empty

let update key value = 
  derive_table := String_map.add key value !derive_table 



let type_deriving_structure 
    tdcls 
    (actions :  Ast_payload.action list ) 
    (explict_nonrec : bool )
  : Ast_structure.t = 
  Ext_list.flat_map
    (fun action -> 
       (Ast_payload.table_dispatch !derive_table action).structure_gen 
         tdcls explict_nonrec) actions

let type_deriving_signature
    tdcls
    (actions :  Ast_payload.action list ) 
    (explict_nonrec : bool )
  : Ast_signature.t = 
  Ext_list.flat_map
    (fun action -> 
       (Ast_payload.table_dispatch !derive_table action).signature_gen
         tdcls explict_nonrec) actions

let dispatch_extension ({Asttypes.txt ; loc}) typ =
  let txt = Ext_string.tail_from txt (String.length Literals.bs_deriving_dot) in 
    match (Ast_payload.table_dispatch !derive_table 
            ({txt ; loc}, None)).expression_gen with 
    | None -> Location.raise_errorf ~loc "%s is not registered" txt 
    | Some f -> f typ

end
module Ast_derive_util
= struct
#1 "ast_derive_util.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

open Ast_helper

let core_type_of_type_declaration (tdcl : Parsetree.type_declaration) = 
  match tdcl with 
  | {ptype_name = {txt ; loc};
     ptype_params ;
    } -> Typ.constr {txt = Lident txt ; loc} (List.map fst ptype_params)

let lift_string_list_to_array (labels : string list) = 
  Exp.array
    (List.map (fun s -> Exp.constant (Const_string (s, None)))
       labels)

let lift_int i = Exp.constant (Const_int i)
let lift_int_list_to_array (labels : int list) = 
  Exp.array (List.map lift_int labels)


let mk_fun ~loc (typ : Parsetree.core_type) 
    (value : string) body
  : Parsetree.expression = 
  Exp.fun_ 
    "" None
    (Pat.constraint_ (Pat.var {txt = value ; loc}) typ)
    body

let destruct_label_declarations ~loc
    (arg_name : string)
    (labels : Parsetree.label_declaration list) : 
  (Parsetree.core_type * Parsetree.expression) list * string list 
  =
  List.fold_right
    (fun   ({pld_name = {txt}; pld_type} : Parsetree.label_declaration) 
      (core_type_exps, labels) -> 
      ((pld_type, 
        Exp.field (Exp.ident {txt = Lident arg_name ; loc}) 
          {txt = Lident txt ; loc}) :: core_type_exps),
      txt :: labels 
    ) labels ([], [])

end
module Ast_derive_dyn : sig 
#1 "ast_derive_dyn.mli"
(* *)
val init : unit -> unit

end = struct
#1 "ast_derive_dyn.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

open Ast_helper

let not_supported loc = 
  Location.raise_errorf ~loc "not supported in deriving"

let current_name_set : string list ref = ref []

let loc = Location.none 

let (+>) = Typ.arrow ""

type lid = Longident.t Asttypes.loc


let record_to_value = "record_to_value"
let variant_to_value = "variant_to_value"
let shape = "shape"
let js_dyn = "Bs_dyn"
let value = "value"
let record_shape = "record_shape"
let to_value = "_to_value"
let to_value_ = "_to_value_"
let shape_of_variant = "shape_of_variant"
let shape_of_record = "shape_of_record"
let option_to_value = "option_to_value"
(**
   {[Ptyp_constr of Longident.t loc * core_type list ]}
   ['u M.t]
*)


let bs_attrs = [Ast_attributes.bs]

(** template for 
    {[fun (value : t) -> 
      match value with 
        cases 
    ]}
*)
let js_dyn_value_type () =
  Typ.constr {txt = Longident.Ldot ((Lident  js_dyn), value) ; loc} []
let get_js_dyn_record_shape_type () = 
  Typ.constr {txt = Ldot (Lident js_dyn, record_shape); loc} []
let js_dyn_shape_of_variant () = 
  Exp.ident {txt = Ldot (Lident js_dyn, shape_of_variant); loc}
let js_dyn_shape_of_record () = 
  Exp.ident {txt = Ldot (Lident js_dyn, shape_of_record); loc}

let js_dyn_to_value_type ty  = 
  Typ.arrow "" ty  (js_dyn_value_type ())
let js_dyn_to_value_uncurry_type ty = 
  Typ.arrow "" ~attrs:bs_attrs ty (js_dyn_value_type ())

let js_dyn_variant_to_value () = 
  Exp.ident {txt = Ldot (Lident js_dyn, variant_to_value); loc}

let js_dyn_option_to_value () = 
  Exp.ident {txt = Ldot (Lident js_dyn, option_to_value); loc}

let js_dyn_tuple_to_value i = 
  Exp.ident {txt = Ldot (
      Lident js_dyn,
      "tuple_" ^ string_of_int i ^ "_to_value"); loc}


let bs_apply1 f v = 
  Exp.apply f ["",v] ~attrs:bs_attrs



(** [M.t]-> [M.t_to_value ] *)

let fn_of_lid  suffix (x : lid) : lid = 
  match x with
  | { txt = Lident name} 
    -> { x with  txt = Lident (name ^ suffix )}
  | { txt = Ldot (v,name)} 
    -> {x with txt = Ldot (v,  name ^ suffix )}
  | { txt = Lapply _} -> not_supported x.loc 

let rec exp_of_core_type prefix 
    ({ptyp_loc = loc} as x : Parsetree.core_type)
  : Parsetree.expression = 
  match x.ptyp_desc with 
  | Ptyp_constr (
      {txt = 
         Lident (
           "int" 
         | "int32" 
         | "int64" 
         | "nativeint"
         | "bool"
         | "float"
         | "char"
         | "string" 
           as name );
       loc }, ([] as params))
  | Ptyp_constr (
      {txt = 
         Lident (
           "option" 
         | "list" 
         | "array" 
           as name );
       loc }, ([_] as params))
    -> exp_of_core_type prefix 
         {x with 
          ptyp_desc =
            Ptyp_constr ({txt =  Ldot(Lident js_dyn,name);loc}, params)}
  | Ptyp_constr ({txt ; loc} as lid, []) -> 
    Exp.ident (fn_of_lid prefix lid)       
  | Ptyp_constr (lid, params)
    -> 
    Exp.apply (Exp.ident (fn_of_lid prefix lid))
      (List.map (fun x -> "",exp_of_core_type prefix x ) params) 
  | Ptyp_tuple lst -> 
    begin match lst with 
    | [x] -> exp_of_core_type prefix x 
    | [] -> assert false 
    | _ -> 
      let len = List.length lst in 
      if len > 6 then 
        Location.raise_errorf ~loc "tuple arity > 6 not supported yet"
      else 
        let fn = js_dyn_tuple_to_value len in 
        let args = List.map (fun x -> "", exp_of_core_type prefix x) lst in 
        Exp.apply fn args 
    end


  | _ -> assert false



(** return an expression node of array type *)
let exp_of_core_type_exprs 
    (core_type_exprs : (Parsetree.core_type * Parsetree.expression) list) 
  : Parsetree.expression  = 
    Exp.array 
      (List.fold_right (fun (core_type, exp) acc -> 
           bs_apply1
             (exp_of_core_type to_value  core_type) exp

           (* depends on [core_type] is in recursive name set or not ,
              if not, then uncurried application, otherwise, since 
              the uncurried version is not in scope yet, we 
              have to use the curried version
              the complexity is necessary
              think about such scenario:
              {[
                type nonrec t = A of t (* t_to_value *)
                and u = t (* t_to_value_ *)
              ]}
           *)
           :: acc 
       ) core_type_exprs [])

let destruct_constructor_declaration 
    ({pcd_name = {txt ;loc}; pcd_args} : Parsetree.constructor_declaration)  = 
  let last_i, core_type_exprs, pats = 
    List.fold_left (fun (i,core_type_exps, pats) core_type -> 
      let  txt = "a" ^ string_of_int i  in
      (i+1, (core_type, Exp.ident {txt = Lident txt  ;loc}) :: core_type_exps, 
       Pat.var {txt ; loc} :: pats )
    ) (0, [], []) pcd_args in 
  let core_type_exprs, pats  = List.rev core_type_exprs, List.rev pats in
  Pat.construct {txt = Lident txt ; loc}
    (if last_i = 0 then 
       None
     else if last_i = 1 then 
       Some (List.hd pats) 
     else
       Some (Pat.tuple pats)  ), core_type_exprs


let case_of_ctdcl (ctdcls : Parsetree.constructor_declaration list) = 
    Exp.function_ 
      (List.mapi (fun i ctdcl -> 
           let pat, core_type_exprs = destruct_constructor_declaration ctdcl in 
           Exp.case pat 
             (Exp.apply 
                (js_dyn_variant_to_value ())
                [("", Exp.ident {txt = Lident shape ; loc});
                 ("", Ast_derive_util.lift_int i);
                 ("", exp_of_core_type_exprs core_type_exprs);
                ]
             )) ctdcls
      )
let record args = 
  Exp.apply 
    (Exp.ident {txt = Ldot (Lident js_dyn, record_to_value ); loc})
    ["", Exp.ident {txt = Lident shape ; loc};
     ("",  args)
    ]      


let fun_1 name = 
  Exp.fun_ "" None ~attrs:bs_attrs 
    (Pat.var {txt = "x"; loc})
    (Exp.apply (Exp.ident name)
       ["",(Exp.ident {txt = Lident "x"; loc})])

let record_exp  name core_type  labels : Ast_structure.t = 
  let arg_name : string = "args" in
  let core_type_exprs, labels = 
    Ast_derive_util.destruct_label_declarations ~loc arg_name labels in

  [Str.value Nonrecursive @@ 
   [Vb.mk 
     (Pat.var {txt = shape;  loc}) 
     (Exp.apply (js_dyn_shape_of_record ())
        ["", (Ast_derive_util.lift_string_list_to_array labels)]
     ) ];
   Str.value Nonrecursive @@ 
   [Vb.mk (Pat.var {txt = name ^ to_value_  ; loc })
      (Ast_derive_util.mk_fun ~loc core_type arg_name 
         (record (exp_of_core_type_exprs core_type_exprs))
      )];
   Str.value Nonrecursive @@
   [Vb.mk (Pat.var {txt = name ^ to_value; loc})
      ( fun_1 { txt = Lident (name ^ to_value_) ;loc})
   ]        
  ]



let init ()  =
  Ast_derive.update 
    "dynval"
    begin fun (x : Parsetree.expression option) -> 
      match x with 
      | Some {pexp_loc = loc} 
        -> Location.raise_errorf ~loc "such configuration is not supported"
      | None -> 
        {Ast_derive.structure_gen = 
           begin  fun (tdcl  : Parsetree.type_declaration list) explict_nonrec ->
             begin match tdcl with 
               | [tdcl] -> 
                 let core_type = Ast_derive_util.core_type_of_type_declaration  tdcl in 
                 let name = tdcl.ptype_name.txt in
                 let loc = tdcl.ptype_loc in 
                 let signatures = 
                   [Sig.value ~loc 
                      (Val.mk {txt =  name ^ to_value  ; loc}
                         (js_dyn_to_value_uncurry_type core_type))
                   ] in
                 let constraint_ strs = 
                   [Ast_structure.constraint_  ~loc strs signatures] in
                 begin match tdcl with 
                   | {ptype_params = [];
                      ptype_kind  = Ptype_variant cd;
                      ptype_loc = loc;
                     } -> 
                     if explict_nonrec then 
                       let names, arities = 
                         List.fold_right 
                           (fun (ctdcl : Parsetree.constructor_declaration) 
                             (names,arities) -> 
                             ctdcl.pcd_name.txt :: names, 
                             List.length ctdcl.pcd_args :: arities
                           ) cd ([],[]) in 
                       constraint_ 
                         [
                           Str.value Nonrecursive @@ 
                           [Vb.mk (Pat.var {txt = shape ; loc})
                              (      Exp.apply (js_dyn_shape_of_variant ())
                                       [ "", (Ast_derive_util.lift_string_list_to_array names);
                                         "", (Ast_derive_util.lift_int_list_to_array arities )
                                       ])];
                           Str.value Nonrecursive @@ 
                           [Vb.mk (Pat.var {txt = name ^ to_value_  ; loc})
                              (case_of_ctdcl cd)
                           ];
                           Str.value Nonrecursive @@
                           [Vb.mk (Pat.var {txt = name ^ to_value; loc})
                              ( fun_1 { txt = Lident (name ^ to_value_) ;loc})
                           ]        
                         ]
                     else 
                       []
                   | {ptype_params = []; 
                      ptype_kind = Ptype_abstract; 
                      ptype_manifest = Some x 
                     } -> (** case {[ type t = int ]}*)
                     constraint_ 
                       [
                         Str.value Nonrecursive @@ 
                         [Vb.mk (Pat.var {txt = name ^ to_value  ; loc})
                            (exp_of_core_type to_value x)
                         ]
                       ]

                   |{ptype_params = [];
                     ptype_kind  = Ptype_record labels;
                     ptype_loc = loc;
                    } -> 
                     if explict_nonrec then constraint_ (record_exp name core_type labels) 
                     else []

                   | _ -> 
                     []
                 end
               | _ -> []
              end
            end
              ; 
           expression_gen =  Some begin fun core_type -> 
               exp_of_core_type to_value core_type
             end;
           signature_gen = 
             begin fun 
               (tdcls : Parsetree.type_declaration list)
               (explict_nonrec : bool) -> 
               let handle_tdcl tdcl = 
                 let core_type = Ast_derive_util.core_type_of_type_declaration tdcl in 
                 let name = tdcl.ptype_name.txt in
                 let loc = tdcl.ptype_loc in 
                 Sig.value ~loc (Val.mk {txt = name ^ to_value  ; loc}
                                   (js_dyn_to_value_uncurry_type core_type)) in 
               List.map handle_tdcl tdcls 

             end

         }
     end

end
module Ast_derive_projector : sig 
#1 "ast_derive_projector.mli"
val init : unit -> unit

end = struct
#1 "ast_derive_projector.ml"
open Ast_helper


let init () =
  Ast_derive.update 
    "accessors" 
    begin fun (x : Parsetree.expression option) ->
       match x with 
       | Some {pexp_loc = loc} 
         -> Location.raise_errorf ~loc "such configuration is not supported"
       | None -> 
         {structure_gen = 
            begin fun (tdcls : Parsetree.type_declaration list) _explict_nonrec ->
              let handle_tdcl tdcl = 
                let core_type = Ast_derive_util.core_type_of_type_declaration tdcl in 
                match tdcl with 
                | {ptype_kind = 
                     Ptype_record label_declarations }
                  -> 
                  label_declarations 
                  |> 
                  List.map (fun ({pld_name = {loc; txt = pld_label} as pld_name} : Parsetree.label_declaration) -> 
                      let txt = "param" in
                      Str.value Nonrecursive

                        [Vb.mk (Pat.var pld_name) @@
                         Exp.fun_ "" None
                           (Pat.constraint_ (Pat.var {txt ; loc}) core_type )
                           (Exp.field (Exp.ident {txt = Lident txt ; loc}) 
                              {txt = Longident.Lident pld_label ; loc}) ]
                    )
                | {ptype_kind = 
                     Ptype_variant constructor_declarations 
                  } 
                  -> 
                  constructor_declarations
                  |> 
                  List.map 
                    (fun
                      ( {pcd_name = {loc ; txt = con_name} ; pcd_args ; pcd_loc }:
                          Parsetree.constructor_declaration)
                      -> (* TODO: add type annotations *)
                        let little_con_name = String.uncapitalize con_name  in
                        let arity = List.length pcd_args in 
                        if arity = 0 then 
                          Str.value Nonrecursive 
                            [Vb.mk  
                               (Pat.var  {loc ; txt = little_con_name})
                               (Exp.constraint_
                                  (Exp.construct {loc ; txt = Longident.Lident con_name } None)
                                  core_type
                               )
                            ]
                        else 
                          begin 
                            let vars = 
                              Ext_list.init  arity (fun x -> "param_" ^ string_of_int x ) in 
                            let exp = 
                              Exp.constraint_
                                ( 
                                  Exp.construct {loc ; txt = Longident.Lident con_name} @@ 
                                  Some
                                    ( 
                                      if  arity = 1 then 
                                        Exp.ident { loc ; txt = Longident.Lident (List.hd vars )}
                                      else 
                                        Exp.tuple (List.map 
                                                     (fun x -> Exp.ident {loc ; txt = Longident.Lident x})
                                                     vars 
                                                  ) )) core_type
                            in 
                            let fun_ = 
                              List.fold_right  (fun var b -> 
                                  Exp.fun_ "" None  (Pat.var {loc ; txt = var}) b 
                                ) vars exp  in 

                            Str.value Nonrecursive
                              [
                                Vb.mk 
                                  (Pat.var { loc ; txt  = little_con_name} )
                                  fun_
                              ]
                          end
                    )
                | _ -> []
                (* Location.raise_errorf "projector only works with record" *)
              in Ext_list.flat_map handle_tdcl tdcls


            end;
          signature_gen = 
            begin fun (tdcls : Parsetree.type_declaration list) _explict_nonrec -> 
              let handle_tdcl tdcl = 
                let core_type = Ast_derive_util.core_type_of_type_declaration tdcl in 
                match tdcl with 
                | {ptype_kind = 
                     Ptype_record label_declarations }
                  -> 
                  label_declarations 
                  |> 
                  List.map (fun 
                             ({pld_name = {loc; txt = pld_label} as pld_name;
                               pld_type
                              } : 
                                Parsetree.label_declaration) -> 
                             Sig.value 
                               (Val.mk pld_name 
                                  (Typ.arrow "" core_type pld_type )))
                | {ptype_kind = 
                     Ptype_variant constructor_declarations 
                  } -> 
                  constructor_declarations
                  |>
                  List.map
                    (fun  ({pcd_name = {loc ; txt = con_name} ; pcd_args ; pcd_loc }:
                             Parsetree.constructor_declaration)
                      -> 
                        Sig.value 
                          (Val.mk {loc ; txt = (String.uncapitalize con_name)}
                             
                           (List.fold_right 
                              (fun x acc -> Typ.arrow "" x acc) 
                              pcd_args
                              core_type)
                          )
                    )
                           
                  | _ -> [] 
              in 
              Ext_list.flat_map handle_tdcl tdcls
            end;
          expression_gen = None
         }
    end


end
module Ast_external : sig 
#1 "ast_external.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


val create_local_external : Location.t ->
  ?pval_attributes:Parsetree.attributes ->
  pval_prim:string list ->
  pval_type:Parsetree.core_type ->
  ?local_module_name:string ->
  ?local_fun_name:string ->
  (string * Parsetree.expression) list -> Parsetree.expression_desc

val local_extern_cont : 
  Location.t ->
  ?pval_attributes:Parsetree.attributes ->
  pval_prim:string list ->
  pval_type:Parsetree.core_type ->
  ?local_module_name:string ->
  ?local_fun_name:string ->
  (Parsetree.expression -> Parsetree.expression) -> Parsetree.expression_desc

end = struct
#1 "ast_external.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

let create_local_external loc 
     ?(pval_attributes=[])
     ~pval_prim
     ~pval_type 
     ?(local_module_name = "J")
     ?(local_fun_name = "unsafe_expr")
     args
  : Parsetree.expression_desc = 
  Pexp_letmodule
    ({txt = local_module_name; loc},
     {pmod_desc =
        Pmod_structure
          [{pstr_desc =
              Pstr_primitive
                {pval_name = {txt = local_fun_name; loc};
                 pval_type ;
                 pval_loc = loc;
                 pval_prim ;
                 pval_attributes };
            pstr_loc = loc;
           }];
      pmod_loc = loc;
      pmod_attributes = []},
     {
       pexp_desc =
         Pexp_apply
           (({pexp_desc = Pexp_ident {txt = Ldot (Lident local_module_name, local_fun_name); 
                                      loc};
              pexp_attributes = [] ;
              pexp_loc = loc} : Parsetree.expression),
            args);
       pexp_attributes = [];
       pexp_loc = loc
     })

let local_extern_cont loc 
     ?(pval_attributes=[])
     ~pval_prim
     ~pval_type 
     ?(local_module_name = "J")
     ?(local_fun_name = "unsafe_expr")
     (cb : Parsetree.expression -> 'a) 
  : Parsetree.expression_desc = 
  Pexp_letmodule
    ({txt = local_module_name; loc},
     {pmod_desc =
        Pmod_structure
          [{pstr_desc =
              Pstr_primitive
                {pval_name = {txt = local_fun_name; loc};
                 pval_type ;
                 pval_loc = loc;
                 pval_prim ;
                 pval_attributes };
            pstr_loc = loc;
           }];
      pmod_loc = loc;
      pmod_attributes = []},
     cb {pexp_desc = Pexp_ident {txt = Ldot (Lident local_module_name, local_fun_name); 
                                 loc};
         pexp_attributes = [] ;
         pexp_loc = loc}
)

end
module Ast_pat : sig 
#1 "ast_pat.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type t = Parsetree.pattern

val is_unit_cont : yes:'a -> no:'a -> t -> 'a

(** [arity_of_fun pat e] tells the arity of 
    expression [fun pat -> e]*)
val arity_of_fun : t -> Parsetree.expression -> int

end = struct
#1 "ast_pat.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


type t = Parsetree.pattern


let is_unit_cont ~yes ~no (p : t)  =
  match p  with
  | {ppat_desc = Ppat_construct({txt = Lident "()"}, None)}
    -> yes 
  | _ -> no


(** [arity_of_fun pat e] tells the arity of 
    expression [fun pat -> e]
*)
let arity_of_fun
    (pat : Parsetree.pattern)
    (e : Parsetree.expression) =
  let rec aux (e : Parsetree.expression)  =
    match e.pexp_desc with
    | Pexp_fun ("", None, pat, e) ->
      1 + aux e       
    | Pexp_fun _
      -> Location.raise_errorf
           ~loc:e.pexp_loc "Lable is not allowed in JS object"
    | _ -> 0 in
  is_unit_cont ~yes:0 ~no:1 pat + aux e 

end
module Ast_util : sig 
#1 "ast_util.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


type args = (string * Parsetree.expression) list
type loc = Location.t 
type label_exprs = (Longident.t Asttypes.loc * Parsetree.expression) list
type 'a cxt = loc -> Ast_mapper.mapper -> 'a

(** In general three kinds of ast generation.
    - convert a curried to type to uncurried 
    - convert a curried fun to uncurried fun
    - convert a uncuried application to normal 
*)
type uncurry_expression_gen = 
  (Parsetree.pattern ->
   Parsetree.expression ->
   Parsetree.expression_desc) cxt
type uncurry_type_gen = 
  (string -> (* label for error checking *)
   Parsetree.core_type ->
   Parsetree.core_type  ->
   Parsetree.core_type) cxt

(** TODO: the interface is not reusable, it depends on too much context *)
(** syntax: {[f arg0 arg1 [@bs]]}*)
val uncurry_fn_apply : 
  (Parsetree.expression ->
  args ->
  Parsetree.expression_desc ) cxt 

(** syntax : {[f## arg0 arg1 ]}*)
val method_apply : 
  (Parsetree.expression ->
  string ->
  args ->
  Parsetree.expression_desc) cxt 

(** syntax {[f#@ arg0 arg1 ]}*)
val property_apply : 
  (Parsetree.expression ->
  string ->
  args ->
  Parsetree.expression_desc) cxt 


(** 
    [function] can only take one argument, that is the reason we did not adopt it
    syntax:
    {[ fun [@bs] pat pat1-> body ]}
    [to_uncurry_fn (fun pat -> (fun pat1 -> ...  body))]

*)
val to_uncurry_fn : uncurry_expression_gen


(** syntax: 
    {[fun [@bs.this] obj pat pat1 -> body]}    
*)
val to_method_callback : uncurry_expression_gen


(** syntax : 
    {[ int -> int -> int [@bs]]}
*)
val to_uncurry_type : uncurry_type_gen
  

(** syntax
    {[ method : int -> itn -> int ]}
*)
val to_method_type : uncurry_type_gen

(** syntax:
    {[ 'obj -> int -> int [@bs.this] ]}
*)
val to_method_callback_type : uncurry_type_gen





val record_as_js_object : 
  (label_exprs ->
   Parsetree.expression_desc) cxt 

val js_property : 
  loc ->
  Parsetree.expression -> string -> Parsetree.expression_desc

val handle_debugger : 
  loc -> Ast_payload.t -> Parsetree.expression_desc

val handle_raw : 
  loc -> Ast_payload.t -> Parsetree.expression


val handle_raw_structure : 
  loc -> Ast_payload.t -> Parsetree.structure_item

val ocaml_obj_as_js_object :
  (Parsetree.pattern ->
   Parsetree.class_field list ->
   Parsetree.expression_desc) cxt   

end = struct
#1 "ast_util.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

open Ast_helper 
type 'a cxt = Ast_helper.loc -> Ast_mapper.mapper -> 'a
type loc = Location.t 
type args = (string * Parsetree.expression) list
type label_exprs = (Longident.t Asttypes.loc * Parsetree.expression) list
type uncurry_expression_gen = 
  (Parsetree.pattern ->
   Parsetree.expression ->
   Parsetree.expression_desc) cxt
type uncurry_type_gen = 
  (string ->
   Parsetree.core_type ->
   Parsetree.core_type  ->
   Parsetree.core_type) cxt
    
let uncurry_type_id = 
  Ast_literal.Lid.js_fn

let method_id  = 
  Ast_literal.Lid.js_meth

let method_call_back_id  = 
  Ast_literal.Lid.js_meth_callback

let arity_lit = "Arity_"

let mk_args loc n tys = 
  Typ.variant ~loc 
    [ Rtag (arity_lit ^ string_of_int n, [], (n = 0),  tys)] Closed None

let generic_lift txt loc args result  = 
  let xs =
    match args with 
    | [ ] -> [mk_args loc 0   [] ; result ]
    | [ x ] -> [ mk_args loc 1 [x] ; result ] 
    | _ -> 
      [mk_args loc (List.length args ) [Typ.tuple ~loc args] ; result ]
  in 
  Typ.constr ~loc {txt ; loc} xs

let lift_curry_type  loc   = 
  generic_lift   uncurry_type_id loc

let lift_method_type loc  = 
  generic_lift  method_id loc

let lift_js_method_callback loc
  = 
  generic_lift method_call_back_id loc 
(** Note that currently there is no way to consume [Js.meth_callback]
    so it is fine to encode it with a freedom, 
    but we need make it better for error message.
    - all are encoded as 
    {[ 
      type fn =  (`Args_n of _ , 'result ) Js.fn
      type method = (`Args_n of _, 'result) Js.method
      type method_callback = (`Args_n of _, 'result) Js.method_callback
    ]}
    For [method_callback], the arity is never zero, so both [method] 
    and  [fn] requires (unit -> 'a) to encode arity zero
*)



let arrow = Typ.arrow


let js_property loc obj name =
  Parsetree.Pexp_send
    ((Exp.apply ~loc
        (Exp.ident ~loc
           {loc;
            txt = Ldot (Ast_literal.Lid.js_unsafe, Literals.js_unsafe_downgrade)})
        ["",obj]), name)

(* TODO: 
   have a final checking for property arities 
     [#=], 
*)


let generic_apply  kind loc 
    (self : Ast_mapper.mapper) 
    (obj : Parsetree.expression) 
    (args : args ) cb   =
  let obj = self.expr self obj in
  let args =
    List.map (fun (label,e) ->
        if label <> "" then
          Location.raise_errorf ~loc "label is not allowed here"        ;
        self.expr self e
      ) args in
  let len = List.length args in 
  let arity, fn, args  = 
  match args with 
  | [ {pexp_desc =
         Pexp_construct ({txt = Lident "()"}, None)}]
    -> 
     0, cb loc obj, []
  | _ -> 
    len,  cb loc obj, args in
  if arity < 10 then 
    let txt = 
      match kind with 
      | `Fn | `PropertyFn ->  
        Longident.Ldot (Ast_literal.Lid.js_unsafe, 
                        Literals.js_fn_run ^ string_of_int arity)
      | `Method -> 
        Longident.Ldot(Ast_literal.Lid.js_unsafe,
                       Literals.js_method_run ^ string_of_int arity
                      ) in 
    Parsetree.Pexp_apply (Exp.ident {txt ; loc}, ("",fn) :: List.map (fun x -> "",x) args)
  else 
  let fn_type, args_type, result_type = Ast_comb.tuple_type_pair ~loc `Run arity  in 
  let string_arity = string_of_int arity in
  let pval_prim, pval_type = 
    match kind with 
    | `Fn | `PropertyFn -> 
      [Literals.js_fn_run; string_arity], 
      arrow ~loc ""  (lift_curry_type loc args_type result_type ) fn_type
    | `Method -> 
      [Literals.js_method_run ; string_arity], 
      arrow ~loc "" (lift_method_type loc args_type result_type) fn_type
  in
  Ast_external.create_local_external loc ~pval_prim ~pval_type 
    (("", fn) :: List.map (fun x -> "",x) args )


let uncurry_fn_apply loc self fn args = 
  generic_apply `Fn loc self fn args (fun _ obj -> obj )

let property_apply loc self obj name (args : args) 
  =  generic_apply `PropertyFn loc self obj args 
    (fun loc obj -> Exp.mk ~loc (js_property loc obj name))

let method_apply loc self obj name args = 
  generic_apply `Method loc self obj args 
    (fun loc obj -> Exp.mk ~loc (js_property loc obj name))

let generic_to_uncurry_type  kind loc (mapper : Ast_mapper.mapper) label
    (first_arg : Parsetree.core_type) 
    (typ : Parsetree.core_type)  =
  if label <> "" then
    Location.raise_errorf ~loc "label is not allowed";                 

  let rec aux acc (typ : Parsetree.core_type) = 
    (* in general, 
       we should collect [typ] in [int -> typ] before transformation, 
       however: when attributes [bs] and [bs.this] found in typ, 
       we should stop 
    *)
    match Ast_attributes.process_attributes_rev typ.ptyp_attributes with 
    | `Nothing, _   -> 
      begin match typ.ptyp_desc with 
      | Ptyp_arrow (label, arg, body)
        -> 
        if label <> "" then
          Location.raise_errorf ~loc:typ.ptyp_loc "label is not allowed";
        aux (mapper.typ mapper arg :: acc) body 
      | _ -> mapper.typ mapper typ, acc 
      end
    | _, _ -> mapper.typ mapper typ, acc  
  in 
  let first_arg = mapper.typ mapper first_arg in
  let result, rev_extra_args = aux  [first_arg] typ in 
  let args  = List.rev rev_extra_args in 
  let filter_args args  =  
    match args with 
    | [{Parsetree.ptyp_desc = 
          (Ptyp_constr ({txt = Lident "unit"}, []) 
          )}]
      -> []
    | _ -> args in
  match kind with 
  | `Fn ->
    let args = filter_args args in
    lift_curry_type loc args result 
  | `Method -> 
    let args = filter_args args in
    lift_method_type loc args result 

  | `Method_callback
    -> lift_js_method_callback loc args result 


let to_uncurry_type  = 
  generic_to_uncurry_type `Fn
let to_method_type  =
  generic_to_uncurry_type  `Method
let to_method_callback_type  = 
  generic_to_uncurry_type `Method_callback 

let generic_to_uncurry_exp kind loc (self : Ast_mapper.mapper)  pat body 
  = 
  let rec aux acc (body : Parsetree.expression) = 
    match Ast_attributes.process_attributes_rev body.pexp_attributes with 
    | `Nothing, _ -> 
      begin match body.pexp_desc with 
        | Pexp_fun (label,_, arg, body)
          -> 
          if label <> "" then
            Location.raise_errorf ~loc "label is not allowed";
          aux (self.pat self arg :: acc) body 
        | _ -> self.expr self body, acc 
      end 
    | _, _ -> self.expr self body, acc  
  in 
  let first_arg = self.pat self pat in  
  let result, rev_extra_args = aux [first_arg] body in 
  let body = 
    List.fold_left (fun e p -> Ast_comb.fun_no_label ~loc p e )
      result rev_extra_args in
  let len = List.length rev_extra_args in 
  let arity = 
    match kind with 
    | `Fn  ->
      begin match rev_extra_args with 
        | [ p]
          ->
          Ast_pat.is_unit_cont ~yes:0 ~no:len p           

        | _ -> len 
      end
    | `Method_callback -> len  in 
  if arity < 10  then 
    let txt = 
      match kind with 
      | `Fn -> 
        Longident.Ldot ( Ast_literal.Lid.js_unsafe, Literals.js_fn_mk ^ string_of_int arity)
      | `Method_callback -> 
        Longident.Ldot (Ast_literal.Lid.js_unsafe,  Literals.js_fn_method ^ string_of_int arity) in
    Parsetree.Pexp_apply (Exp.ident {txt;loc} , ["",body])

  else 
    let pval_prim =
      [ (match kind with 
            | `Fn -> Literals.js_fn_mk
            | `Method_callback -> Literals.js_fn_method); 
        string_of_int arity]  in
    let fn_type , args_type, result_type  = Ast_comb.tuple_type_pair ~loc `Make arity  in 
    let pval_type = arrow ~loc "" fn_type (
        match kind with 
        | `Fn -> 
          lift_curry_type loc args_type result_type
        | `Method_callback -> 
          lift_js_method_callback loc args_type result_type
      ) in
    Ast_external.local_extern_cont loc ~pval_prim ~pval_type 
      (fun prim -> Exp.apply ~loc prim ["", body]) 

let to_uncurry_fn   = 
  generic_to_uncurry_exp `Fn
let to_method_callback  = 
  generic_to_uncurry_exp `Method_callback 


let handle_debugger loc payload = 
  if Ast_payload.as_empty_structure payload then
    Parsetree.Pexp_apply
      (Exp.ident {txt = Ldot(Ast_literal.Lid.js_unsafe, Literals.js_debugger ); loc}, 
       ["", Ast_literal.val_unit ~loc ()])
  else Location.raise_errorf ~loc "bs.raw can only be applied to a string"


let handle_raw loc payload = 
  begin match Ast_payload.as_string_exp payload with 
    | None ->
      Location.raise_errorf ~loc
        "bs.raw can only be applied to a string "

    | Some exp -> 
      let pexp_desc = 
        Parsetree.Pexp_apply (
            Exp.ident {loc; 
                       txt = 
                         Ldot (Ast_literal.Lid.js_unsafe, 
                               Literals.js_pure_expr)},
            ["",exp]
          )
      in
      { exp with pexp_desc }
  end




let handle_raw_structure loc payload = 
  begin match Ast_payload.as_string_exp payload with 
    | Some exp 
      -> 
      let pexp_desc = 
        Parsetree.Pexp_apply(
            Exp.ident {txt = Ldot (Ast_literal.Lid.js_unsafe,  Literals.js_pure_stmt); loc},
            ["",exp]) in 
      Ast_helper.Str.eval 
        { exp with pexp_desc }

    | None
      -> 
      Location.raise_errorf ~loc "bs.raw can only be applied to a string"
  end

    
let ocaml_obj_as_js_object
    loc (mapper : Ast_mapper.mapper)
    (self_pat : Parsetree.pattern)
    (clfs : Parsetree.class_field list) =
  let self_type_lit = "self_type"   in 

  (** Attention: we should avoid type variable conflict for each method  
      Since the method name is unique, there would be no conflict 
      OCaml does not allow duplicate instance variable and duplicate methods, 
      but it does allow duplicates between instance variable and method name, 
      we should enforce such rules 
      {[
        object 
          val x = 3
          method x = 3 
        end [@bs]
      ]} should not compile with a meaningful error message
  *)

  let generate_val_method_pair 
      loc (mapper : Ast_mapper.mapper)
      val_name  is_mutable = 

    let result = Typ.var ~loc val_name in 
    result , 
    ((val_name , [], result ) ::
     (if is_mutable then 
        [val_name ^ Literals.setter_suffix,[],
         to_method_type loc mapper "" result (Ast_literal.type_unit ~loc ()) ]
      else 
        []) )
  in 
  (* Note mapper is only for API compatible 
   * TODO: we should check label name to avoid conflict 
  *)  
  let self_type loc = Typ.var ~loc self_type_lit in 

  let generate_arg_type loc (mapper  : Ast_mapper.mapper)
      method_name arity : Ast_core_type.t = 
    let result = Typ.var ~loc method_name in   
    if arity = 0 then
      to_method_type loc mapper "" (Ast_literal.type_unit ~loc ()) result 

    else
      let tyvars =
        Ext_list.init arity (fun i -> Typ.var ~loc (method_name ^ string_of_int i))
      in
      begin match tyvars with
        | x :: rest ->
          let method_rest =
            List.fold_right (fun v acc -> Typ.arrow ~loc "" v acc)
              rest result in         
          to_method_type loc mapper "" x method_rest
        | _ -> assert false
      end in          

  let generate_method_type
      loc
      (mapper : Ast_mapper.mapper)
      ?alias_type method_name arity =
    let result = Typ.var ~loc method_name in   

    let self_type =
      let v = self_type loc  in
      match alias_type with 
      | None -> v 
      | Some ty -> Typ.alias ~loc ty self_type_lit
    in  
    if arity = 0 then
      to_method_callback_type loc mapper  "" self_type result      
    else
      let tyvars =
        Ext_list.init arity (fun i -> Typ.var ~loc (method_name ^ string_of_int i))
      in
      begin match tyvars with
        | x :: rest ->
          let method_rest =
            List.fold_right (fun v acc -> Typ.arrow ~loc "" v acc)
              rest result in         
          (to_method_callback_type loc mapper  "" self_type
             (Typ.arrow ~loc "" x method_rest))
        | _ -> assert false
      end in          


  (** we need calculate the real object type 
      and exposed object type, in some cases there are equivalent

      for public object type its [@bs.meth] it does not depend on itself
      while for label argument it is [@bs.this] which depends internal object
  *)
  let internal_label_attr_types, public_label_attr_types  = 
    List.fold_right
      (fun ({pcf_loc  = loc} as x  : Parsetree.class_field) 
        (label_attr_types, public_label_attr_types) ->
        match x.pcf_desc with
        | Pcf_method (
            label,
            public_flag,
            Cfk_concrete
              (Fresh, e))
           ->
           begin match e.pexp_desc with
             | Pexp_poly
                 (({pexp_desc = Pexp_fun ("", None, pat, e)} ),
                  None) ->  
               let arity = Ast_pat.arity_of_fun pat e in
               let method_type =
                 generate_arg_type x.pcf_loc mapper label.txt arity in 
               ((label.Asttypes.txt, [], method_type) :: label_attr_types),
               (if public_flag = Public then
                  (label.Asttypes.txt, [], method_type) :: public_label_attr_types
                else 
                  public_label_attr_types)
               
             | Pexp_poly( _, Some _)
               ->
               Location.raise_errorf ~loc "polymorphic type annotation not supported yet"
             | Pexp_poly (_, None) ->
               Location.raise_errorf ~loc
                 "Unsupported syntax, expect syntax like `method x () = x ` "
             | _ ->
               Location.raise_errorf ~loc "Unsupported syntax in js object"               
           end
         | Pcf_val (label, mutable_flag, Cfk_concrete(Fresh, val_exp)) ->
           let  label_type, label_attr  = 
             generate_val_method_pair x.pcf_loc mapper label.txt  
               (mutable_flag = Mutable )
           in
           (label_attr @ label_attr_types, public_label_attr_types)
         | Pcf_val (label, mutable_flag, Cfk_concrete(Override, val_exp)) -> 
           Location.raise_errorf ~loc "override flag not support currently"
         | Pcf_val (label, mutable_flag, Cfk_virtual _) -> 
           Location.raise_errorf ~loc "virtual flag not support currently"

         | Pcf_method (_, _, Cfk_concrete(Override, _) ) -> 
           Location.raise_errorf ~loc "override flag not supported"
       
         | Pcf_method (_, _, Cfk_virtual _ )
           ->
           Location.raise_errorf ~loc "virtural method not supported"
           
         | Pcf_inherit _ 
         | Pcf_initializer _
         | Pcf_attribute _
         | Pcf_extension _
         | Pcf_constraint _ ->
           Location.raise_errorf ~loc "Only method support currently"
      ) clfs ([], []) in
  let internal_obj_type = Ast_core_type.make_obj ~loc internal_label_attr_types in
  let public_obj_type = Ast_core_type.make_obj ~loc public_label_attr_types in
  let (labels,  label_types, exprs, _) =
    List.fold_right
      (fun (x  : Parsetree.class_field)
        (labels,
         label_types,
         exprs, aliased ) ->
        match x.pcf_desc with
        | Pcf_method (
            label,
            _public_flag,
            Cfk_concrete
              (Fresh, e))
           ->
           begin match e.pexp_desc with
             | Pexp_poly
                 (({pexp_desc = Pexp_fun ("", None, pat, e)} as f),
                  None) ->  
               let arity = Ast_pat.arity_of_fun pat e in
               let alias_type = 
                 if aliased then None 
                 else Some internal_obj_type in
               let  label_type =
                 generate_method_type ?alias_type
                   x.pcf_loc mapper label.txt arity in 
               (label::labels,
                label_type::label_types,
                {f with
                 pexp_desc =
                   let f = Ast_pat.is_unit_cont pat ~yes:e ~no:f in                       
                   to_method_callback loc mapper self_pat f
                } :: exprs, 
                true
               )
             | Pexp_poly( _, Some _)
               ->
               Location.raise_errorf ~loc
                 "polymorphic type annotation not supported yet"
               
             | Pexp_poly (_, None) ->
               Location.raise_errorf
                 ~loc "Unsupported syntax, expect syntax like `method x () = x ` "
             | _ ->
               Location.raise_errorf ~loc "Unsupported syntax in js object"               
           end
         | Pcf_val (label, mutable_flag, Cfk_concrete(Fresh, val_exp)) ->
           let  label_type, label_attr  = 
             generate_val_method_pair x.pcf_loc mapper label.txt  
               (mutable_flag = Mutable )
           in
           (label::labels,
            label_type :: label_types, 
            (mapper.expr mapper val_exp :: exprs), 
            aliased 
           )

         | Pcf_val (label, mutable_flag, Cfk_concrete(Override, val_exp)) -> 
           Location.raise_errorf ~loc "override flag not support currently"
         | Pcf_val (label, mutable_flag, Cfk_virtual _) -> 
           Location.raise_errorf ~loc "virtual flag not support currently"

         | Pcf_method (_, _, Cfk_concrete(Override, _) ) -> 
           Location.raise_errorf ~loc "override flag not supported"
       
         | Pcf_method (_, _, Cfk_virtual _ )
           ->
           Location.raise_errorf ~loc "virtural method not supported"
           

         | Pcf_inherit _ 
         | Pcf_initializer _
         | Pcf_attribute _
         | Pcf_extension _
         | Pcf_constraint _ ->
           Location.raise_errorf ~loc "Only method support currently"
      ) clfs  ([], [], [], false) in
  let pval_type =
    List.fold_right2
      (fun label label_type acc ->
         Typ.arrow
           ~loc:label.Asttypes.loc
           label.Asttypes.txt
           label_type acc           
      ) labels label_types public_obj_type in
  Ast_external.local_extern_cont
    loc
      ~pval_prim:(Ast_external_attributes.pval_prim_of_labels labels)
      (fun e ->
       Exp.apply ~loc e
         (List.map2 (fun l expr -> l.Asttypes.txt, expr) labels exprs) )
    ~pval_type


let record_as_js_object 
    loc 
    (self : Ast_mapper.mapper)
    (label_exprs : label_exprs)
     : Parsetree.expression_desc = 

  let labels,args, arity =
    List.fold_right (fun ({Location.txt ; loc}, e) (labels,args,i) -> 
        match txt with
        | Longident.Lident x ->
          ({Asttypes.loc = loc ; txt = x} :: labels, (x, self.expr self e) :: args, i + 1)
        | Ldot _ | Lapply _ ->  
          Location.raise_errorf ~loc "invalid js label ") label_exprs ([],[],0) in
  Ast_external.create_local_external loc 
    ~pval_prim:(Ast_external_attributes.pval_prim_of_labels labels)
    ~pval_type:(Ast_core_type.from_labels ~loc arity labels) 
    args 

end
module Ext_ref : sig 
#1 "ext_ref.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

(** [non_exn_protect ref value f] assusme [f()] 
    would not raise
*)

val non_exn_protect : 'a ref -> 'a -> (unit -> 'b) -> 'b
val protect : 'a ref -> 'a -> (unit -> 'b) -> 'b

val protect2 : 'a ref -> 'b ref -> 'a -> 'b -> (unit -> 'c) -> 'c

(** [non_exn_protect2 refa refb va vb f ]
    assume [f ()] would not raise
*)
val non_exn_protect2 : 'a ref -> 'b ref -> 'a -> 'b -> (unit -> 'c) -> 'c

val protect_list : ('a ref * 'a) list -> (unit -> 'b) -> 'b

end = struct
#1 "ext_ref.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

let non_exn_protect r v body = 
  let old = !r in
  r := v;
  let res = body() in
  r := old;
  res

let protect r v body =
  let old = !r in
  try
    r := v;
    let res = body() in
    r := old;
    res
  with x ->
    r := old;
    raise x

let non_exn_protect2 r1 r2 v1 v2 body = 
  let old1 = !r1 in
  let old2 = !r2 in  
  r1 := v1;
  r2 := v2;
  let res = body() in
  r1 := old1;
  r2 := old2;
  res

let protect2 r1 r2 v1 v2 body =
  let old1 = !r1 in
  let old2 = !r2 in  
  try
    r1 := v1;
    r2 := v2;
    let res = body() in
    r1 := old1;
    r2 := old2;
    res
  with x ->
    r1 := old1;
    r2 := old2;
    raise x

let protect_list rvs body = 
  let olds =  List.map (fun (x,y) -> !x)  rvs in 
  let () = List.iter (fun (x,y) -> x:=y) rvs in 
  try 
    let res = body () in 
    List.iter2 (fun (x,_) old -> x := old) rvs olds;
    res 
  with e -> 
    List.iter2 (fun (x,_) old -> x := old) rvs olds;
    raise e 

end
module Ppx_entry : sig 
#1 "ppx_entry.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)




val rewrite_signature :   (Parsetree.signature -> Parsetree.signature) ref

val rewrite_implementation : (Parsetree.structure -> Parsetree.structure) ref





(* object 
    for setter : we can push more into [Lsend] and enclose it with a unit type

    for getter :

    (* Invariant: we expect the typechecker & lambda emitter  
       will not do agressive inlining
       Worst things could happen
    {[
      let x = y## case 3  in 
      x 2
    ]}
       in normal case, it should be compiled into Lambda
    {[
      let x = Lsend(y,case, [3]) in 
      Lapp(x,2)
    ]}

       worst:
    {[ Lsend(y, case, [3,2])
    ]}               
       for setter(include case setter), this could 
       be prevented by type system, for getter.

       solution: we can prevent this by rewrite into 
    {[
      Fn.run1  (!x# case) v 
      ]}
       *)

      *)

end = struct
#1 "ppx_entry.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






(* When we design a ppx, we should keep it simple, and also think about 
   how it would work with other tools like merlin and ocamldep  *)

(**
1. extension point 
   {[ 
     [%bs.raw{| blabla |}]
   ]}
   will be desugared into 
   {[ 
     let module Js = 
     struct unsafe_js : string -> 'a end 
     in Js.unsafe_js {| blabla |}
   ]}
   The major benefit is to better error reporting (with locations).
   Otherwise

   {[

     let f u = Js.unsafe_js u 
     let _ = f (1 + 2)
   ]}
   And if it is inlined some where   
*)



open Ast_helper




let record_as_js_object = ref false (* otherwise has an attribute *)
let no_export = ref false 

let () = 
  Ast_derive_dyn.init  ();
  Ast_derive_projector.init ()

let reset () = 
  record_as_js_object := false ;
  no_export  :=  false



let process_getter_setter ~no ~get ~set
    loc name
    (attrs : Ast_attributes.t)
    (ty : Parsetree.core_type) acc  =
  match Ast_attributes.process_method_attributes_rev attrs with 
  | {get = None; set = None}, _  ->  no ty :: acc 
  | st , pctf_attributes
    -> 
    let get_acc = 
      match st.set with 
      | Some `No_get -> acc 
      | None 
      | Some `Get -> 
        let lift txt = 
          Typ.constr ~loc {txt ; loc} [ty] in
        let (null,undefined) =                
          match st with 
          | {get = Some (null, undefined) } -> (null, undefined)
          | {get = None} -> (false, false ) in 
        let ty = 
          match (null,undefined) with 
          | false, false -> ty
          | true, false -> lift Ast_literal.Lid.js_null
          | false, true -> lift Ast_literal.Lid.js_undefined
          | true , true -> lift Ast_literal.Lid.js_null_undefined in
        get ty name pctf_attributes
        :: acc  
    in 
    if st.set = None then get_acc 
    else
      set ty (name ^ Literals.setter_suffix) pctf_attributes         
      :: get_acc 



let handle_class_type_field self
    ({pctf_loc = loc } as ctf : Parsetree.class_type_field)
    acc =
  match ctf.pctf_desc with 
  | Pctf_method 
      (name, private_flag, virtual_flag, ty) 
    ->
    let no (ty : Parsetree.core_type) =
        let ty = 
          match ty.ptyp_desc with 
          | Ptyp_arrow (label, args, body) 
            ->
            Ast_util.to_method_type
              ty.ptyp_loc  self label args body

          | Ptyp_poly (strs, {ptyp_desc = Ptyp_arrow (label, args, body);
                              ptyp_loc})
            ->
            {ty with ptyp_desc = 
                       Ptyp_poly(strs,             
                                 Ast_util.to_method_type
                                   ptyp_loc  self label args body  )}
          | _ -> 
            self.typ self ty
        in 
        {ctf with 
         pctf_desc = 
           Pctf_method (name , private_flag, virtual_flag, ty)}
    in
    let get ty name pctf_attributes =
      {ctf with 
       pctf_desc =  
         Pctf_method (name , 
                      private_flag, 
                      virtual_flag, 
                      self.typ self ty
                     );
       pctf_attributes} in
    let set ty name pctf_attributes =
      {ctf with 
       pctf_desc =
         Pctf_method (name, 
                      private_flag,
                      virtual_flag,
                      Ast_util.to_method_type
                        loc self "" ty
                        (Ast_literal.type_unit ~loc ())
                     );
       pctf_attributes} in
    process_getter_setter ~no ~get ~set loc name ctf.pctf_attributes ty acc     

  | Pctf_inherit _ 
  | Pctf_val _ 
  | Pctf_constraint _
  | Pctf_attribute _ 
  | Pctf_extension _  -> 
    Ast_mapper.default_mapper.class_type_field self ctf :: acc 

(*
  Attributes are very hard to attribute
  (since ptyp_attributes could happen in so many places), 
  and write ppx extensions correctly, 
  we can only use it locally
*)

let handle_core_type 
    (super : Ast_mapper.mapper) 
    (self : Ast_mapper.mapper)
    (ty : Parsetree.core_type) = 
  match ty with
  | {ptyp_desc = Ptyp_extension({txt = ("bs.obj"|"obj")}, PTyp ty)}
    -> 
    Ext_ref.non_exn_protect record_as_js_object true 
      (fun _ -> self.typ self ty )
  | {ptyp_attributes ;
     ptyp_desc = Ptyp_arrow (label, args, body);
     (* let it go without regard label names, 
        it will report error later when the label is not empty
     *)     
     ptyp_loc = loc
   } ->
    begin match  Ast_attributes.process_attributes_rev ptyp_attributes with 
      | `Uncurry , ptyp_attributes ->
        Ast_util.to_uncurry_type loc self label args body 
      |  `Meth_callback, ptyp_attributes ->
        Ast_util.to_method_callback_type loc self label args body
      | `Method, ptyp_attributes ->
        Ast_util.to_method_type loc self label args body
      | `Nothing , _ -> 
          Ast_mapper.default_mapper.typ self ty
    end
  | {
    ptyp_desc =  Ptyp_object ( methods, closed_flag) ;
    ptyp_loc = loc 
    } -> 
    let (+>) attr (typ : Parsetree.core_type) =
      {typ with ptyp_attributes = attr :: typ.ptyp_attributes} in           
    let new_methods =
      List.fold_right (fun (label, ptyp_attrs, core_type) acc ->
          let get ty name attrs =
            let attrs, core_type =
              match Ast_attributes.process_attributes_rev attrs with
              | `Nothing, attrs -> attrs, core_type
              | `Uncurry, attrs ->
                attrs, Ast_attributes.bs +> ty
              | `Method, _
                -> Location.raise_errorf "bs.get/set conflicts with bs.meth"
              | `Meth_callback, attrs ->
                attrs, Ast_attributes.bs_this +> ty 
            in 
            name , attrs, self.typ self core_type in
          let set ty name attrs =
            let attrs, core_type =
              match Ast_attributes.process_attributes_rev attrs with
              | `Nothing, attrs -> attrs, core_type
              | `Uncurry, attrs ->
                attrs, Ast_attributes.bs +> ty 
              | `Method, _
                -> Location.raise_errorf "bs.get/set conflicts with bs.meth"
              | `Meth_callback, attrs ->
                attrs, Ast_attributes.bs_this +> ty
            in               
            name, attrs, Ast_util.to_method_type loc self "" core_type 
              (Ast_literal.type_unit ~loc ()) in
          let no ty =
            let attrs, core_type =
              match Ast_attributes.process_attributes_rev ptyp_attrs with
              | `Nothing, attrs -> attrs, ty
              | `Uncurry, attrs ->
                attrs, Ast_attributes.bs +> ty 
              | `Method, attrs -> 
                attrs, Ast_attributes.bs_method +> ty 
              | `Meth_callback, attrs ->
                attrs, Ast_attributes.bs_this +> ty  in            
            label, attrs, self.typ self core_type in
          process_getter_setter ~no ~get ~set
            loc label ptyp_attrs core_type acc
        ) methods [] in      
    let inner_type =
      { ty
        with ptyp_desc = Ptyp_object(new_methods, closed_flag);
              } in 
    if !record_as_js_object then 
      Ast_comb.to_js_type loc inner_type          
    else inner_type
  | _ -> super.typ self ty





let rec unsafe_mapper : Ast_mapper.mapper =   
  { Ast_mapper.default_mapper with 
    expr = (fun self ({ pexp_loc = loc } as e) -> 
        match e.pexp_desc with 
        (** Its output should not be rewritten anymore *)        
        | Pexp_extension (
            {txt = ("bs.raw" | "raw"); loc} , payload)
          -> 
          Ast_util.handle_raw loc payload
        | Pexp_extension (
            {txt = ("bs.re" | "re"); loc} , payload)
          ->
          Exp.constraint_ ~loc
            (Ast_util.handle_raw loc payload)
            (Ast_comb.to_js_re_type loc)            
        | Pexp_extension
            ({txt = ("bs.node" | "node"); loc},
             payload)
          ->
          let strip s =
            let len = String.length s in            
            if s.[len - 1] = '_' then
              String.sub s 0 (len - 1)
            else s in                  
          begin match Ast_payload.as_ident payload with
            | Some {txt = Lident
                        ("__filename"
                        | "__dirname"
                        | "module_"
                        | "require" as name); loc}
              ->
              let exp =
                Ast_util.handle_raw loc
                  (Ast_payload.raw_string_payload loc
                     (strip name) ) in
              let typ =
                Ast_comb.to_undefined_type loc @@                 
                if name = "module_" then
                  Typ.constr ~loc
                    { txt = Ldot (Lident "Node", "node_module") ;
                      loc} []   
                else if name = "require" then
                  (Typ.constr ~loc
                     { txt = Ldot (Lident "Node", "node_require") ;
                       loc} [] )  
                else
                  Ast_literal.type_string ~loc () in                  
              Exp.constraint_ ~loc exp typ                
            | Some _ | None ->
              begin match payload with 
              | PTyp _ -> 
                Location.raise_errorf 
                  ~loc "Illegal payload, expect an expression payload instead of type payload"              
              | PPat _ ->
                Location.raise_errorf 
                  ~loc "Illegal payload, expect an expression payload instead of pattern  payload"        
              | _ -> 
                Location.raise_errorf 
                  ~loc "Illegal payload"
              end

          end             

        (** [bs.debugger], its output should not be rewritten any more*)
        | Pexp_extension ({txt = ("bs.debugger"|"debugger"); loc} , payload)
          -> {e with pexp_desc = Ast_util.handle_debugger loc payload}
        | Pexp_extension ({txt = ("bs.obj" | "obj"); loc},  payload)
          -> 
            begin match payload with 
            | PStr [{pstr_desc = Pstr_eval (e,_)}]
              -> 
              Ext_ref.non_exn_protect record_as_js_object true
                (fun () -> self.expr self e ) 
            | _ -> Location.raise_errorf ~loc "Expect an expression here"
            end
        | Pexp_extension({txt ; loc} as lid, PTyp typ) 
          when Ext_string.starts_with txt Literals.bs_deriving_dot -> 
          self.expr self @@ 
            Ast_derive.dispatch_extension lid typ
            
        (** End rewriting *)
        | Pexp_fun ("", None, pat , body)
          ->
          begin match Ast_attributes.process_attributes_rev e.pexp_attributes with 
          | `Nothing, _ 
            -> Ast_mapper.default_mapper.expr self e 
          |   `Uncurry, pexp_attributes
            -> 
            {e with 
             pexp_desc = Ast_util.to_uncurry_fn loc self pat body  ;
             pexp_attributes}
          | `Method , _
            ->  Location.raise_errorf ~loc "bs.meth is not supported in function expression"
          | `Meth_callback , pexp_attributes
            -> 
            {e with pexp_desc = Ast_util.to_method_callback loc  self pat body ;
                    pexp_attributes }
          end
        | Pexp_apply (fn, args  ) ->
          begin match fn with 
            | {pexp_desc = 
                 Pexp_apply (
                   {pexp_desc = 
                      Pexp_ident  {txt = Lident "##"  ; loc} ; _},
                   [("", obj) ;
                    ("", {pexp_desc = Pexp_ident {txt = Lident name;_ } ; _} )
                   ]);
               _} ->  (* f##paint 1 2 *)
              {e with pexp_desc = Ast_util.method_apply loc self obj name args }
            | {pexp_desc = 
                 Pexp_apply (
                   {pexp_desc = 
                      Pexp_ident  {txt = Lident "#@"  ; loc} ; _},
                   [("", obj) ;
                    ("", {pexp_desc = Pexp_ident {txt = Lident name;_ } ; _} )
                   ]);
               _} ->  (* f##paint 1 2 *)
              {e with pexp_desc = Ast_util.property_apply loc self obj name args  }

            | {pexp_desc = 
                 Pexp_ident  {txt = Lident "##" ; loc} ; _} 
              -> 
              begin match args with 
                | [("", obj) ;
                   ("", {pexp_desc = Pexp_apply(
                        {pexp_desc = Pexp_ident {txt = Lident name;_ } ; _},
                        args
                      ) })
                  ] -> (* f##(paint 1 2 ) *)
                  {e with pexp_desc = Ast_util.method_apply loc self obj name args}
                | [("", obj) ;
                   ("", 
                    {pexp_desc = Pexp_ident {txt = Lident name;_ } ; _}
                   )  (* f##paint  *)
                  ] -> 
                  { e with pexp_desc = 
                             Ast_util.js_property loc (self.expr self obj) name  
                  }

                | _ -> 
                  Location.raise_errorf ~loc
                    "Js object ## expect syntax like obj##(paint (a,b)) "
              end
            (* we can not use [:=] for precedece cases 
               like {[i @@ x##length := 3 ]} 
               is parsed as {[ (i @@ x##length) := 3]}
               since we allow user to create Js objects in OCaml, it can be of
               ref type
               {[
                 let u = object (self)
                   val x = ref 3 
                   method setX x = self##x := 32
                   method getX () = !self##x
                 end
               ]}
            *)
            | {pexp_desc = 
                 Pexp_ident {txt = Lident  ("#=" )}
              } -> 
              begin match args with 
              | ["", 
                  {pexp_desc = 
                     Pexp_apply ({pexp_desc = Pexp_ident {txt = Lident "##"}}, 
                                 ["", obj; 
                                  "", {pexp_desc = Pexp_ident {txt = Lident name}}
                                 ]                                 
                                )}; 
                 "", arg
                ] -> 
                 Exp.constraint_ ~loc
                   { e with
                     pexp_desc =
                       Ast_util.method_apply loc self obj 
                         (name ^ Literals.setter_suffix) ["", arg ]  }
                   (Ast_literal.type_unit ~loc ())
              | _ -> Ast_mapper.default_mapper.expr self e 
              end
            | _ -> 

              begin match Ext_list.exclude_with_fact (function 
                  | {Location.txt = "bs"; _}, _ -> true 
                  | _ -> false) e.pexp_attributes with 
              | None, _ -> Ast_mapper.default_mapper.expr self e 
              | Some _, pexp_attributes -> 
                {e with pexp_desc = Ast_util.uncurry_fn_apply loc self fn args ;
                        pexp_attributes }
              end
          end
        | Pexp_record (label_exprs, opt_exp)  -> 
          if !record_as_js_object then
            (match opt_exp with
             | None ->              
               { e with
                 pexp_desc =  
                   Ast_util.record_as_js_object loc self label_exprs;
               }
             | Some e ->
               Location.raise_errorf
                 ~loc:e.pexp_loc "`with` construct is not supported in bs.obj ")
          else
            (* could be supported using `Object.assign`? 
               type 
               {[
                 external update : 'a Js.t -> 'b Js.t -> 'a Js.t = ""
                 constraint 'b :> 'a
               ]}
            *)
            Ast_mapper.default_mapper.expr  self e
        | Pexp_object {pcstr_self;  pcstr_fields} ->
          begin match Ast_attributes.process_bs e.pexp_attributes with
            | `Has, pexp_attributes
              ->
              {e with
               pexp_desc = 
                 Ast_util.ocaml_obj_as_js_object
                   loc self pcstr_self pcstr_fields;
               pexp_attributes               
              }                          
            | `Nothing , _ ->
              Ast_mapper.default_mapper.expr  self e              
          end            
        | _ ->  Ast_mapper.default_mapper.expr self e
      );
    typ = (fun self typ -> handle_core_type Ast_mapper.default_mapper self typ);
    class_type = 
      (fun self ({pcty_attributes; pcty_loc} as ctd) -> 
         match Ast_attributes.process_bs pcty_attributes with 
         | `Nothing,  _ -> 
           Ast_mapper.default_mapper.class_type
             self ctd 
         | `Has, pcty_attributes ->
           begin match ctd.pcty_desc with
             | Pcty_signature ({pcsig_self; pcsig_fields })
               ->
               let pcsig_self = self.typ self pcsig_self in 
               {ctd with
                pcty_desc = Pcty_signature {
                    pcsig_self ;
                    pcsig_fields = List.fold_right (handle_class_type_field self)  pcsig_fields []
                  };
                pcty_attributes                    
               }                    

             | Pcty_constr _
             | Pcty_extension _ 
             | Pcty_arrow _ ->
               Location.raise_errorf ~loc:pcty_loc "invalid or unused attribute `bs`"
               (* {[class x : int -> object 
                    end [@bs]
                  ]}
                  Actually this is not going to happpen as below is an invalid syntax
                  {[class type x = int -> object
                    end[@bs]]}
               *)
           end             
      );
    signature_item =  begin fun (self : Ast_mapper.mapper) (sigi : Parsetree.signature_item) -> 
      match sigi.psig_desc with 
      | Psig_type (_ :: _ as tdcls) -> 
        begin match Ast_attributes.process_derive_type 
                      (Ext_list.last tdcls).ptype_attributes  with 
        | {bs_deriving = `Has_deriving actions; explict_nonrec}, ptype_attributes
          -> Ast_signature.fuse 
               {sigi with 
                psig_desc = Psig_type
                    (
                      Ext_list.map_last (fun last tdcl -> 
                          if last then 
                            self.type_declaration self {tdcl with ptype_attributes}
                          else 
                            self.type_declaration self tdcl                            
                        ) tdcls
                    )
               }
               (self.signature 
                  self @@ 
                Ast_derive.type_deriving_signature tdcls actions explict_nonrec)
        | {bs_deriving = `Nothing }, _ -> 
          Ast_mapper.default_mapper.signature_item self sigi 

        end
      | Psig_value
          ({pval_attributes; 
            pval_type; 
            pval_loc;
            pval_prim;
            pval_name ;
           } as prim) 
        when Ast_attributes.process_external pval_attributes
        -> 
        let pval_type = self.typ self pval_type in
        let pval_attributes = self.attributes self pval_attributes in         
        let pval_type, pval_prim, pval_attributes = 
          match pval_prim with 
          | [ v ] -> 
            Ast_external_attributes.handle_attributes_as_string
              pval_loc 
              pval_name.txt 
              pval_type 
              pval_attributes v
          | _ -> Location.raise_errorf "only a single string is allowed in bs external" in
        {sigi with 
         psig_desc = 
           Psig_value
             {prim with
              pval_type ; 
              pval_prim ;
              pval_attributes 
                 }}

      | _ -> Ast_mapper.default_mapper.signature_item self sigi
    end;
    structure_item = begin fun self (str : Parsetree.structure_item) -> 
        begin match str.pstr_desc with 
        | Pstr_extension ( ({txt = ("bs.raw"| "raw") ; loc}, payload), _attrs) 
          -> 
          Ast_util.handle_raw_structure loc payload
        | Pstr_type (_ :: _ as tdcls ) (* [ {ptype_attributes} as tdcl ] *)-> 
          begin match Ast_attributes.process_derive_type 
                        ((Ext_list.last tdcls).ptype_attributes) with 
          | {bs_deriving = `Has_deriving actions;
             explict_nonrec 
            }, ptype_attributes -> 
            Ast_structure.fuse 
              {str with 
               pstr_desc =
                 Pstr_type 
                    (Ext_list.map_last (fun last tdcl -> 
                         if last then 
                           self.type_declaration self {tdcl with ptype_attributes}
                         else 
                           self.type_declaration self tdcl) tdcls)
                   }
              (self.structure self @@ Ast_derive.type_deriving_structure
                 tdcls actions explict_nonrec )
          | {bs_deriving = `Nothing}, _  -> 
            Ast_mapper.default_mapper.structure_item self str
          end
        | Pstr_primitive 
            ({pval_attributes; 
              pval_prim; 
              pval_type;
              pval_name;
              pval_loc} as prim) 
          when Ast_attributes.process_external pval_attributes
          -> 
          let pval_type = self.typ self pval_type in
          let pval_attributes = self.attributes self pval_attributes in         
          let pval_type, pval_prim, pval_attributes = 
            match pval_prim with 
            | [ v] -> 
              Ast_external_attributes.handle_attributes_as_string
                pval_loc
                pval_name.txt
                pval_type pval_attributes v

            | _ -> Location.raise_errorf "only a single string is allowed in bs external" in
          {str with 
           pstr_desc = 
             Pstr_primitive
               {prim with
                pval_type ; 
                pval_prim;
                pval_attributes 
               }}
          
        | _ -> Ast_mapper.default_mapper.structure_item self str 
        end
    end
  }




(** global configurations below *)
let common_actions_table : 
  (string *  (Parsetree.expression option -> unit)) list = 
  [ 
  ]


let structural_config_table  = 
  String_map.of_list 
    (( "no_export" , 
      (fun x -> 
         no_export := (
           match x with 
           |Some e -> Ast_payload.assert_bool_lit e 
           | None -> true)
      ))
      :: common_actions_table)

let signature_config_table : 
  (Parsetree.expression option -> unit) String_map.t= 
  String_map.of_list common_actions_table



let rewrite_signature : 
  (Parsetree.signature  -> Parsetree.signature) ref = 
  ref (fun  x -> 
      let result = 
        match (x : Parsetree.signature) with 
        | {psig_desc = Psig_attribute ({txt = "bs.config"; loc}, payload); _} :: rest 
          -> 
          begin 
            Ast_payload.as_config_record_and_process loc payload 
            |> List.iter (Ast_payload.table_dispatch signature_config_table) ; 
            unsafe_mapper.signature unsafe_mapper rest
          end
        | _ -> 
          unsafe_mapper.signature  unsafe_mapper x in 
      reset (); result 
    )

let rewrite_implementation : (Parsetree.structure -> Parsetree.structure) ref = 
  ref (fun (x : Parsetree.structure) -> 
      let result = 
        match x with 
        | {pstr_desc = Pstr_attribute ({txt = "bs.config"; loc}, payload); _} :: rest 
          -> 
          begin 
            Ast_payload.as_config_record_and_process loc payload 
            |> List.iter (Ast_payload.table_dispatch structural_config_table) ; 
            let rest = unsafe_mapper.structure unsafe_mapper rest in
            if !no_export then
              [Str.include_ ~loc  
                 (Incl.mk ~loc 
                    (Mod.constraint_ ~loc
                       (Mod.structure ~loc rest  )
                       (Mty.signature ~loc [])
                    ))]
            else rest 
          end
        | _ -> 
          unsafe_mapper.structure  unsafe_mapper x  in 
      reset (); result )


end
module Ocaml_parse : sig 
#1 "ocaml_parse.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

val parse_interface : Format.formatter -> string -> Parsetree.signature

val parse_implementation : Format.formatter -> string -> Parsetree.structure

val parse_implementation_from_string : string -> Parsetree.structure
val lazy_parse_interface : Format.formatter -> string -> Parsetree.signature lazy_t

val lazy_parse_implementation : Format.formatter -> string -> Parsetree.structure lazy_t
    
val check_suffix :  string -> [> `Ml | `Mli ] * string

end = struct
#1 "ocaml_parse.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

let parse_interface ppf sourcefile = 
  let ast = Pparse.parse_interface ~tool_name:Js_config.tool_name ppf sourcefile in
  if !Js_config.no_builtin_ppx_mli then ast else  !Ppx_entry.rewrite_signature ast

let lazy_parse_interface ppf sourcefile =
  lazy (parse_interface ppf sourcefile)

let parse_implementation ppf sourcefile = 
  let ast = 
    Pparse.parse_implementation ~tool_name:Js_config.tool_name ppf sourcefile in 
  if !Js_config.no_builtin_ppx_ml then ast else
    !Ppx_entry.rewrite_implementation ast 

let parse_implementation_from_string  str = 
  let lb = Lexing.from_string str in
  Location.init lb "//toplevel//";
  let ast = Parse.implementation lb  in 
  if !Js_config.no_builtin_ppx_ml then ast else 
    !Ppx_entry.rewrite_implementation ast 


let lazy_parse_implementation ppf sourcefile =
  lazy (parse_implementation ppf sourcefile)
    
let check_suffix  name  = 
  if Filename.check_suffix name ".ml"
  || Filename.check_suffix name ".mlt" then 
    `Ml,
    (** This is per-file based, 
        when [ocamlc] [-c -o another_dir/xx.cmi] 
        it will return (another_dir/xx)
    *)    
    Compenv.output_prefix name 
  else if Filename.check_suffix name !Config.interface_suffix then 
    `Mli,  Compenv.output_prefix name 
  else 
    raise(Arg.Bad("don't know what to do with " ^ name))

end
module Js_implementation : sig 
#1 "js_implementation.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** High level compilation module *) 

(** This module defines a function to compile the program directly into [js]
    given [filename] and [outputprefix], 
    it will be useful if we don't care about bytecode output(generating js only).
 *)
val interface : Format.formatter -> string -> string -> unit

val after_parsing_sig : Format.formatter -> string -> string -> Parsetree.signature -> unit

val implementation : Format.formatter -> string -> string -> unit
(** [implementation ppf sourcefile outprefix] compiles to JS directly *) 


val after_parsing_impl : Format.formatter -> string -> string -> Parsetree.structure -> unit
(** [after_parsing_impl ppf sourcefile outputprefix ast ] *)

end = struct
#1 "js_implementation.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 2002 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* adapted by bucklescript from [driver/compile.ml] for convenience    *)

open Format
open Typedtree
open Compenv



let fprintf = Format.fprintf



let print_if ppf flag printer arg =
  if !flag then fprintf ppf "%a@." printer arg;
  arg



let after_parsing_sig ppf sourcefile outputprefix ast  =
  if !Js_config.binary_ast then
    begin 
      Binary_ast.write_ast
        Mli
        ~fname:sourcefile
        ~output:(outputprefix ^ Literals.suffix_mliast)
        (* to support relocate to another directory *)
        ast 

    end;
  if !Js_config.syntax_only then () else 
    begin 
      if not @@ !Js_config.no_warn_unused_bs_attribute then 
        Bs_ast_invariant.emit_external_warnings.signature Bs_ast_invariant.emit_external_warnings ast ;
      if Js_config.get_diagnose () then
        Format.fprintf Format.err_formatter "Building %s@." sourcefile;    
      let modulename = module_of_filename ppf sourcefile outputprefix in
      let initial_env = Compmisc.initial_env () in
      Env.set_unit_name modulename;
      let tsg = Typemod.type_interface initial_env ast in
      if !Clflags.dump_typedtree then fprintf ppf "%a@." Printtyped.interface tsg;
      let sg = tsg.sig_type in
      if !Clflags.print_types then
        Printtyp.wrap_printing_env initial_env (fun () ->
            fprintf std_formatter "%a@."
              Printtyp.signature (Typemod.simplify_signature sg));
      ignore (Includemod.signatures initial_env sg sg);
      Typecore.force_delayed_checks ();
      Warnings.check_fatal ();
      if not !Clflags.print_types then begin
        let sg = Env.save_signature sg modulename (outputprefix ^ ".cmi") in
        Typemod.save_signature modulename tsg outputprefix sourcefile
          initial_env sg ;
      end
    end
let interface ppf sourcefile outputprefix =
  Compmisc.init_path false;
  Ocaml_parse.parse_interface ppf sourcefile
  |> print_if ppf Clflags.dump_parsetree Printast.interface
  |> print_if ppf Clflags.dump_source Pprintast.signature 
  |> after_parsing_sig ppf sourcefile outputprefix 

let after_parsing_impl ppf sourcefile outputprefix ast =
  if !Js_config.binary_ast then
      Binary_ast.write_ast ~fname:sourcefile 
        Ml ~output:(outputprefix ^ Literals.suffix_mlast)
        ast ;

  if !Js_config.syntax_only then () else 
    begin
      
      if not @@ !Js_config.no_warn_unused_bs_attribute then 
        Bs_ast_invariant.emit_external_warnings.structure Bs_ast_invariant.emit_external_warnings ast ;
      if Js_config.get_diagnose () then
        Format.fprintf Format.err_formatter "Building %s@." sourcefile;      
      let modulename = Compenv.module_of_filename ppf sourcefile outputprefix in
      let env = Compmisc.initial_env() in
      Env.set_unit_name modulename;
      try
        let (typedtree, coercion, finalenv, current_signature) =
          ast 
          |> Typemod.type_implementation_more sourcefile outputprefix modulename env 
          |> print_if ppf Clflags.dump_typedtree
            (fun fmt (ty,co,_,_) -> Printtyped.implementation_with_coercion fmt  (ty,co))
        in
        if !Clflags.print_types then begin
          Warnings.check_fatal ();
        end else begin
          (typedtree, coercion)
          |> Translmod.transl_implementation modulename
          |> print_if ppf Clflags.dump_rawlambda Printlambda.lambda
          |> (fun lambda -> 
              match           
                Lam_compile_group.lambda_as_module
                  finalenv current_signature 
                  sourcefile  outputprefix lambda  with
              | e -> e 
              | exception e -> 
                (* Save to a file instead so that it will not scare user *)
                if Js_config.get_diagnose () then
                  begin              
                    let file = "bsc.dump" in
                    Ext_pervasives.with_file_as_chan file
                      (fun ch -> output_string ch @@             
                        Printexc.raw_backtrace_to_string (Printexc.get_raw_backtrace ()));
                    Ext_log.err __LOC__
                      "Compilation fatal error, stacktrace saved into %s when compiling %s"
                      file sourcefile;
                  end;            
                raise e             
            );
        end;
        Stypes.dump (Some (outputprefix ^ ".annot"));
      with x ->
        Stypes.dump (Some (outputprefix ^ ".annot"));
        raise x
    end
let implementation ppf sourcefile outputprefix =
  Compmisc.init_path false;
  Ocaml_parse.parse_implementation ppf sourcefile
  |> print_if ppf Clflags.dump_parsetree Printast.implementation
  |> print_if ppf Clflags.dump_source Pprintast.structure
  |> after_parsing_impl ppf sourcefile outputprefix 

end
module Binary_cache : sig 
#1 "binary_cache.mli"

(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type ml_kind =
  | Ml of string 
  | Re of string 
  | Ml_empty
type mli_kind = 
  | Mli of string 
  | Rei of string
  | Mli_empty

type module_info = 
  {
    mli : mli_kind ; 
    ml : ml_kind ; 
    mll : string option 
  }

type t = module_info String_map.t 
val write_build_cache : string -> t -> unit

val read_build_cache : string -> t

val bsbuild_cache : string

val simple_concat : string -> string -> string



(** if not added, it is guaranteed the reference equality will 
    be held
*)
val map_update : ?dir:string -> t -> string -> t

end = struct
#1 "binary_cache.ml"

(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


type ml_kind =
  | Ml of string 
  | Re of string 
  | Ml_empty
type mli_kind = 
  | Mli of string 
  | Rei of string
  | Mli_empty

type module_info = 
  {
    mli : mli_kind ; 
    ml : ml_kind ; 
    mll : string option 
  }

type t = module_info String_map.t 

let module_info_magic_number = "BSBUILD20161012"

let write_build_cache bsbuild (bs_files : module_info String_map.t)  = 
  let oc = open_out_bin bsbuild in 
  output_string oc module_info_magic_number ;
  output_value oc bs_files ;
  close_out oc 

let read_build_cache bsbuild : module_info String_map.t = 
  let ic = open_in bsbuild in 
  let buffer = really_input_string ic (String.length module_info_magic_number) in
  assert(buffer = module_info_magic_number); 
  let data : module_info String_map.t = input_value ic in 
  close_in ic ;
  data 


let bsbuild_cache = ".bsbuild"


(* TODO check duplication *)
let module_info_of_ml exist ml : module_info =
  match exist with 
  | None -> { ml  = Ml ml ; mli = Mli_empty ; mll = None }
  | Some x -> { x with ml = Ml ml}

let module_info_of_re exist ml : module_info =
  match exist with 
  | None -> { ml  = Re ml ; mli = Mli_empty ; mll = None }
  | Some x -> { x with ml = Re ml} 

let module_info_of_mli exist mli : module_info = 
  match exist with 
  | None -> { mli  = Mli mli ; ml = Ml_empty ; mll = None }
  | Some x -> { x with mli = Mli mli} 

let module_info_of_rei exist mli : module_info = 
  match exist with 
  | None -> { mli  = Rei mli ; ml = Ml_empty ; mll = None }
  | Some x -> { x with mli = Rei mli} 

let module_info_of_mll exist mll : module_info = 
  match exist with 
  | None -> { mll  = Some mll ; ml = Ml_empty ; mli = Mli_empty }
  | Some x -> { x with mll = Some mll} 

let simple_concat (x : string)  y =
  if x = Filename.current_dir_name then y else 
  if y = Filename.current_dir_name then x else 
    Filename.concat x y

let map_update ?dir (map : t)  name : t  = 
  let prefix   = 
    match dir with
    | None -> fun x ->  x
    | Some v -> fun x ->  simple_concat v x in
  let module_name = Ext_filename.module_name_of_file_if_any name in 
  let handle name v cb =
    String_map.add module_name
      (cb v (prefix name ) ) map 
  in 
  let aux v name = 
    if Filename.check_suffix name ".ml" then handle name  v  module_info_of_ml  else
    if Filename.check_suffix name ".mll" then handle name  v  module_info_of_mll  else 
    if Filename.check_suffix name ".mli" then handle name  v  module_info_of_mli else 
    if Filename.check_suffix name ".re" then handle name v module_info_of_re else 
    if Filename.check_suffix name ".rei" then handle name v module_info_of_rei else 
      map    in 
  match String_map.find module_name map with 
  | exception Not_found 
    -> aux None name 
  | v -> 
    aux (Some v ) name

end
module Ast_extract : sig 
#1 "ast_extract.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)




type _ kind =
  | Ml_kind : Parsetree.structure kind
  | Mli_kind : Parsetree.signature kind






module String_set = Depend.StringSet

val read_parse_and_extract : 'a kind -> 'a -> String_set.t

type ('a,'b) t 

val sort_files_by_dependencies :
  domain:String_set.t -> String_set.t String_map.t -> string Queue.t


val sort :
  ('a -> Parsetree.structure) ->
  ('b -> Parsetree.signature) ->
  ('a, 'b) t String_map.t -> string Queue.t  



(**
   [build fmt files parse_implementation parse_interface]
   Given a list of files return an ast table 
*)
val collect_ast_map :
  Format.formatter ->
  string list ->
  (Format.formatter -> string -> 'a) ->
  (Format.formatter -> string -> 'b) ->
  ('a, 'b) t String_map.t


val collect_from_main :
  ?extra_dirs:[`Dir of string  | `Dir_with_excludes of string * string list] list -> 
  ?excludes : string list -> 
  Format.formatter ->
  (Format.formatter -> string -> 'a) ->
  (Format.formatter -> string -> 'b) ->
  ('a -> Parsetree.structure) ->
  ('b -> Parsetree.signature) ->
  string -> ('a, 'b) t String_map.t * string Queue.t

val build_queue :
  Format.formatter ->
  string Queue.t ->
  ('b, 'c) t String_map.t ->
  (Format.formatter -> string -> string -> 'b -> unit) ->
  (Format.formatter -> string -> string -> 'c -> unit) -> unit
  
val handle_queue :
  Format.formatter ->
  String_map.key Queue.t ->
  ('a, 'b) t String_map.t ->
  (string -> string -> 'a -> unit) ->
  (string -> string -> 'b  -> unit) ->
  (string -> string -> string -> 'b -> 'a -> unit) -> unit


val build_lazy_queue :
  Format.formatter ->
  string Queue.t ->
  (Parsetree.structure lazy_t, Parsetree.signature lazy_t) t String_map.t ->
  (Format.formatter -> string -> string -> Parsetree.structure -> unit) ->
  (Format.formatter -> string -> string -> Parsetree.signature -> unit) -> unit  

val handle_depfile : 
  string option -> string -> unit

end = struct
#1 "ast_extract.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type module_name = private string

module String_set = Depend.StringSet

type _ kind =
  | Ml_kind : Parsetree.structure kind
  | Mli_kind : Parsetree.signature kind
        
let read_parse_and_extract (type t) (k : t kind) (ast : t) : String_set.t =
  Depend.free_structure_names := String_set.empty;
  let bound_vars = String_set.empty in
  List.iter
    (fun modname  ->
       Depend.open_module bound_vars (Longident.Lident modname))
    (!Clflags.open_modules);
  (match k with
   | Ml_kind  -> Depend.add_implementation bound_vars ast
   | Mli_kind  -> Depend.add_signature bound_vars ast  ); 
  !Depend.free_structure_names


type ('a,'b) ast_info =
  | Ml of
      string * (* sourcefile *)
      'a *
      string (* opref *)      
  | Mli of string * (* sourcefile *)
           'b *
           string (* opref *)
  | Ml_mli of
      string * (* sourcefile *)
      'a *
      string  * (* opref1 *)
      string * (* sourcefile *)      
      'b *
      string (* opref2*)

type ('a,'b) t =
  { module_name : string ; ast_info : ('a,'b) ast_info }


(* only visit nodes that are currently in the domain *)
(* https://en.wikipedia.org/wiki/Topological_sorting *)
(* dfs   *)
let sort_files_by_dependencies ~domain dependency_graph =
  let next current =
    (String_map.find  current dependency_graph) in    
  let worklist = ref domain in
  let result = Queue.create () in
  let rec visit visiting path current =
    if String_set.mem current visiting then
      Bs_exception.error (Bs_cyclic_depends (current::path))
    else if String_set.mem current !worklist then
      begin
        next current |>        
        String_set.iter
          (fun node ->
             if  String_map.mem node  dependency_graph then
               visit (String_set.add current visiting) (current::path) node)
        ;
        worklist := String_set.remove  current !worklist;
        Queue.push current result ;
      end in        
  while not (String_set.is_empty !worklist) do 
    visit String_set.empty []  (String_set.choose !worklist)
  done;
  if Js_config.get_diagnose () then
    Format.fprintf Format.err_formatter
      "Order: @[%a@]@."    
      (Ext_format.pp_print_queue
         ~pp_sep:Format.pp_print_space
         Format.pp_print_string)
      result ;       
  result
;;



let sort  project_ml project_mli (ast_table : _ t String_map.t) = 
  let domain =
    String_map.fold
      (fun k _ acc -> String_set.add k acc)
      ast_table String_set.empty in
  let h =
    String_map.map
      (fun
        ({ast_info})
        ->
          match ast_info with
          | Ml (_, ast,  _)
            ->
            read_parse_and_extract Ml_kind (project_ml ast)            
          | Mli (_, ast, _)
            ->
            read_parse_and_extract Mli_kind (project_mli ast)
          | Ml_mli (_, impl, _, _, intf, _)
            ->
            String_set.union
              (read_parse_and_extract Ml_kind (project_ml impl))
              (read_parse_and_extract Mli_kind (project_mli intf))              
      ) ast_table in    
  sort_files_by_dependencies  domain h

(** same as {!Ocaml_parse.check_suffix} but does not care with [-c -o] option*)
let check_suffix  name  = 
  if Filename.check_suffix name ".ml"
  || Filename.check_suffix name ".mlt" then 
    `Ml,
    Ext_filename.chop_extension_if_any  name 
  else if Filename.check_suffix name !Config.interface_suffix then 
    `Mli,   Ext_filename.chop_extension_if_any  name 
  else 
    raise(Arg.Bad("don't know what to do with " ^ name))


let collect_ast_map ppf files parse_implementation parse_interface  =
  List.fold_left
    (fun (acc : _ t String_map.t)
      source_file ->
      match check_suffix source_file with
      | `Ml, opref ->
        let module_name = Ext_filename.module_name_of_file source_file in
        begin match String_map.find module_name acc with
          | exception Not_found ->
            String_map.add module_name
              {ast_info =
                 (Ml (source_file, parse_implementation
                        ppf source_file, opref));
               module_name ;
              } acc
          | {ast_info = (Ml (source_file2, _, _)
                        | Ml_mli(source_file2, _, _,_,_,_))} ->
            Bs_exception.error
              (Bs_duplicated_module (source_file, source_file2))
          | {ast_info =  Mli (source_file2, intf, opref2)}
            ->
            String_map.add module_name
              {ast_info =
                 Ml_mli (source_file,
                         parse_implementation ppf source_file,
                         opref,
                         source_file2,
                         intf,
                         opref2
                        );
               module_name} acc
        end
      | `Mli, opref ->
        let module_name = Ext_filename.module_name_of_file source_file in
        begin match String_map.find module_name acc with
          | exception Not_found ->
            String_map.add module_name
              {ast_info = (Mli (source_file, parse_interface
                                              ppf source_file, opref));
               module_name } acc
          | {ast_info =
               (Mli (source_file2, _, _) |
                Ml_mli(_,_,_,source_file2,_,_)) } ->
            Bs_exception.error
              (Bs_duplicated_module (source_file, source_file2))
          | {ast_info = Ml (source_file2, impl, opref2)}
            ->
            String_map.add module_name
              {ast_info =
                 Ml_mli
                   (source_file2,
                    impl,
                    opref2,
                    source_file,
                    parse_interface ppf source_file,
                    opref
                   );
               module_name} acc
        end
    ) String_map.empty files


let collect_from_main 
    ?(extra_dirs=[])
    ?(excludes=[])
    (ppf : Format.formatter)
    parse_implementation
    parse_interface
    project_impl 
    project_intf 
    main_file =
  let not_excluded  = 
    match excludes with 
    | [] -> fun _ -> true
    | _ -> 
      fun source_file -> not (List.mem source_file excludes)
  in 
  let dirname = Filename.dirname main_file in
  (** TODO: same filename module detection  *)
  let files = 
    Array.fold_left (fun acc source_file ->
        if (Ext_string.ends_with source_file ".ml" ||
            Ext_string.ends_with source_file ".mli") 
           && not_excluded source_file
        then 
          (Filename.concat dirname source_file) :: acc else acc ) []   
      (Sys.readdir dirname) in 
  let files = 
    List.fold_left (fun acc dir_spec -> 
        let  dirname, excludes = 
          match dir_spec with 
          | `Dir dirname -> dirname, excludes
          | `Dir_with_excludes (dirname, dir_excludes) ->
            dirname,
            Ext_list.flat_map 
              (fun x -> [x ^ ".ml" ; x ^ ".mli" ])
              dir_excludes @ excludes
        in 
        Array.fold_left (fun acc source_file -> 
            if (Ext_string.ends_with source_file ".ml" ||
               Ext_string.ends_with source_file ".mli" )
               && (* not_excluded source_file *) (not (List.mem source_file excludes))
            then 
              (Filename.concat dirname source_file) :: acc else acc
          ) acc (Sys.readdir dirname))
      files extra_dirs in
  let ast_table = collect_ast_map ppf files parse_implementation parse_interface in 
  let visited = Hashtbl.create 31 in
  let result = Queue.create () in  
  let next module_name =
    match String_map.find module_name ast_table with
    | exception _ -> String_set.empty
    | {ast_info = Ml (_,  impl, _)} ->
      read_parse_and_extract Ml_kind (project_impl impl)
    | {ast_info = Mli (_,  intf,_)} ->
      read_parse_and_extract Mli_kind (project_intf intf)
    | {ast_info = Ml_mli(_, impl, _, _,  intf, _)}
      -> 
      String_set.union
        (read_parse_and_extract Ml_kind (project_impl impl))
        (read_parse_and_extract Mli_kind (project_intf intf))
  in
  let rec visit visiting path current =
    if String_set.mem current visiting  then
      Bs_exception.error (Bs_cyclic_depends (current::path))
    else
    if not (Hashtbl.mem visited current)
    && String_map.mem current ast_table then
      begin
        String_set.iter
          (visit
             (String_set.add current visiting)
             (current::path))
          (next current) ;
        Queue.push current result;
        Hashtbl.add visited current ();
      end in
  visit (String_set.empty) [] (Ext_filename.module_name_of_file main_file) ;
  ast_table, result   


let build_queue ppf queue
    (ast_table : _ t String_map.t)
    after_parsing_impl
    after_parsing_sig    
  =
  queue
  |> Queue.iter
    (fun modname -> 
      match String_map.find modname ast_table  with
      | {ast_info = Ml(source_file,ast, opref)}
        -> 
        after_parsing_impl ppf source_file 
          opref ast 
      | {ast_info = Mli (source_file,ast,opref) ; }  
        ->
        after_parsing_sig ppf source_file 
          opref ast 
      | {ast_info = Ml_mli(source_file1,impl,opref1,source_file2,intf,opref2)}
        -> 
        after_parsing_sig ppf source_file1 opref1 intf ;
        after_parsing_impl ppf source_file2 opref2 impl
      | exception Not_found -> assert false 
    )


let handle_queue ppf queue ast_table decorate_module_only decorate_interface_only decorate_module = 
  queue 
  |> Queue.iter
    (fun base ->
       match (String_map.find  base ast_table).ast_info with
       | exception Not_found -> assert false
       | Ml (ml_name,  ml_content, _)
         ->
         decorate_module_only  base ml_name ml_content
       | Mli (mli_name , mli_content, _) ->
         decorate_interface_only base  mli_name mli_content
       | Ml_mli (ml_name, ml_content, _, mli_name,   mli_content, _)
         ->
         decorate_module  base mli_name ml_name mli_content ml_content

    )



let build_lazy_queue ppf queue (ast_table : _ t String_map.t)
    after_parsing_impl
    after_parsing_sig    
  =
  queue |> Queue.iter (fun modname -> 
      match String_map.find modname ast_table  with
      | {ast_info = Ml(source_file,lazy ast, opref)}
        -> 
        after_parsing_impl ppf source_file opref ast 
      | {ast_info = Mli (source_file,lazy ast,opref) ; }  
        ->
        after_parsing_sig ppf source_file opref ast 
      | {ast_info = Ml_mli(source_file1,lazy impl,opref1,source_file2,lazy intf,opref2)}
        -> 
        after_parsing_sig ppf source_file1 opref1 intf ;
        after_parsing_impl ppf source_file2 opref2 impl
      | exception Not_found -> assert false 
    )


let dep_lit = " :"
let space = " "
let (//) = Filename.concat
let length_space = String.length space 
let handle_depfile oprefix  (fn : string) : unit = 
  let op_concat s = match oprefix with None -> s | Some v -> v // s in 
  let data =
    Binary_cache.read_build_cache (op_concat  Binary_cache.bsbuild_cache) in 
  let deps = 
    match Ext_string.ends_with_then_chop fn Literals.suffix_mlast with 
    | Some  input_file -> 
      let stru  = Binary_ast.read_ast Ml  fn in 
      let set = read_parse_and_extract Ml_kind stru in 
      let dependent_file = (input_file ^ Literals.suffix_cmj) ^ dep_lit in
      let (files, len) = 
      String_set.fold
        (fun k ((acc, len) as v) -> 
           match String_map.find k data with
           | {ml = Ml s | Re s  } 
           | {mll = Some s } 
             -> 
             let new_file = op_concat @@ Filename.chop_extension s ^ Literals.suffix_cmj  
             in (new_file :: acc , len + String.length new_file + length_space)
           | {mli = Mli s | Rei s } -> 
             let new_file =  op_concat @@   Filename.chop_extension s ^ Literals.suffix_cmi in
             (new_file :: acc , len + String.length new_file + length_space)
           | _ -> assert false
           | exception Not_found -> v
        ) set ([],String.length dependent_file)in
      Ext_string.unsafe_concat_with_length len
        space
        (dependent_file :: files)
    | None -> 
      begin match Ext_string.ends_with_then_chop fn Literals.suffix_mliast with 
      | Some input_file -> 
        let stri = Binary_ast.read_ast Mli  fn in 
        let s = read_parse_and_extract Mli_kind stri in 
        let dependent_file = (input_file ^ Literals.suffix_cmi) ^ dep_lit in
        let (files, len) = 
          String_set.fold
            (fun k ((acc, len) as v) ->
               match String_map.find k data with 
               | { ml = Ml f | Re f  }
               | { mll = Some f }
               | { mli = Mli f | Rei f } -> 
                 let new_file = (op_concat @@ Filename.chop_extension f ^ Literals.suffix_cmi) in
                 (new_file :: acc , len + String.length new_file + length_space)
               | _ -> assert false
               | exception Not_found -> v
            ) s  ([], String.length dependent_file) in 
        Ext_string.unsafe_concat_with_length len
          space 
          (dependent_file :: files) 
      | None -> 
        raise (Arg.Bad ("don't know what to do with  " ^ fn))
      end
  in 
  let output = fn ^ Literals.suffix_d in
  Ext_pervasives.with_file_as_chan output  (fun v -> output_string v deps)

end
module Ocaml_batch_compile : sig 
#1 "ocaml_batch_compile.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type task = 
  | Main of string
  | Eval of string 
  | None

(** reutrn value is the error code *)
val batch_compile : Format.formatter -> string list -> task ->  int

end = struct
#1 "ocaml_batch_compile.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)



module String_set = Depend.StringSet

let process_result ppf  main_file ast_table result = 
  if Js_config.get_diagnose () then
    Format.fprintf Format.err_formatter
      "Order: @[%a@]@."
      (Ext_format.pp_print_queue
         ~pp_sep:Format.pp_print_space
         Format.pp_print_string)
      result ;
  Ast_extract.build_lazy_queue ppf result ast_table
    Js_implementation.after_parsing_impl
    Js_implementation.after_parsing_sig
  ;
  if not (!Clflags.compile_only) then
    Sys.command
      ("node " ^ Filename.chop_extension main_file ^ ".js")
  else 0

type task = 
  | Main of string
  | Eval of string 
  (* currently we just output JS file, 
     it is compilicated to run via node.
     1. Create a temporary file, it has to be in the same directory?
     2. Via `node -e`, we need a module to do shell escaping properly
  *)
  | None


let print_if ppf flag printer arg =
  if !flag then Format.fprintf ppf "%a@." printer arg;
  arg

let batch_compile ppf files main_file =
  Compenv.readenv ppf Before_compile; 
  Compmisc.init_path  false;
  if files <> [] then 
    begin
      let ast_table =
        Ast_extract.collect_ast_map ppf files
          Ocaml_parse.parse_implementation
          Ocaml_parse.parse_interface in
      Ast_extract.build_queue ppf
        (Ast_extract.sort Ext_pervasives.id  Ext_pervasives.id  ast_table)
        ast_table
        Js_implementation.after_parsing_impl
        Js_implementation.after_parsing_sig        
    end        
  ;
  begin match main_file with
    | Main main_file -> 
      let ast_table, result =
        Ast_extract.collect_from_main ppf
          Ocaml_parse.lazy_parse_implementation
          Ocaml_parse.lazy_parse_interface         
          Lazy.force
          Lazy.force
          main_file in
      (* if Queue.is_empty result then  *)
      (*   Bs_exception.error (Bs_main_not_exist main_file) *)
      (* ; *) (* Not necessary since we will alwasy check [main_file] is valid or not*)
      process_result ppf main_file ast_table result     
    | None ->  0
    | Eval s ->
      Ext_ref.protect_list 
        [Clflags.dont_write_files , true ; 
         Clflags.annotations, false;
         Clflags.binary_annotations, false;
         Js_config.dump_js, true ;
        ]  (fun _ -> 
          Ocaml_parse.parse_implementation_from_string s 
          |> print_if ppf Clflags.dump_parsetree Printast.implementation
          |> print_if ppf Clflags.dump_source Pprintast.structure
          |> Js_implementation.after_parsing_impl ppf "//<toplevel>//" "Bs_internal_eval" 
          ); 0
  end



                    

end
module Ocaml_options : sig 
#1 "ocaml_options.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)



val mk_impl : (string -> unit) -> string * Arg.spec * string
val mk_intf : (string -> unit) -> string * Arg.spec * string
val mk__ : (string -> unit) -> string * Arg.spec * string
(**
   [ocaml_options] are command options inherited from ocaml 
   bytecode compiler except three options 
   [impl] [intf] and [annoymous] which is in another module 
   due to  dependencies
*)
val ocaml_options : (string * Arg.spec * string) list

end = struct
#1 "ocaml_options.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Clflags
open Compenv

let mk_absname f =
  "-absname", Arg.Unit f, " Show absolute filenames in error messages"
;;

let mk_annot f =
  "-annot", Arg.Unit f, " Save information in <filename>.annot"
;;

let mk_binannot f =
  "-bin-annot", Arg.Unit f, " Save typedtree in <filename>.cmt"
;;

let mk_c f =
  "-c", Arg.Unit f, " Compile only (do not link)"
;;

let mk_config f =
  "-config", Arg.Unit f, " Print configuration values and exit"
;;

let mk_g_byt f =
  "-g", Arg.Unit f, " Save debugging information"
;;

let mk_i f =
  "-i", Arg.Unit f, " Print inferred interface"
;;

let mk_I f =
  "-I", Arg.String f, "<dir>  Add <dir> to the list of include directories"
;;

let mk_impl f =
  "-impl", Arg.String f, "<file>  Compile <file> as a .ml file"
;;

let mk_intf f =
  "-intf", Arg.String f, "<file>  Compile <file> as a .mli file"
;;

let mk_intf_suffix f =
  "-intf-suffix", Arg.String f,
  "<string>  Suffix for interface files (default: .mli)"
;;

let mk_keep_docs f =
  "-keep-docs", Arg.Unit f, " Keep documentation strings in .cmi files"
;;

let mk_keep_locs f =
  "-keep-locs", Arg.Unit f, " Keep locations in .cmi files"
;;

let mk_labels f =
  "-labels", Arg.Unit f, " Use commuting label mode"
;;

let mk_no_alias_deps f =
  "-no-alias-deps", Arg.Unit f,
  " Do not record dependencies for module aliases"
;;

let mk_no_app_funct f =
  "-no-app-funct", Arg.Unit f, " Deactivate applicative functors"
;;

let mk_no_check_prims f =
  "-no-check-prims", Arg.Unit f, " Do not check runtime for primitives"
;;

let mk_noassert f =
  "-noassert", Arg.Unit f, " Do not compile assertion checks"
;;

let mk_nolabels f =
  "-nolabels", Arg.Unit f, " Ignore non-optional labels in types"
;;

let mk_nostdlib f =
  "-nostdlib", Arg.Unit f,
  " Do not add default directory to the list of include directories"
;;

let mk_o f =
  "-o", Arg.String f, "<file>  Set output file name to <file>"
;;

let mk_open f =
  "-open", Arg.String f, "<module>  Opens the module <module> before typing"

let mk_pp f =
  "-pp", Arg.String f, "<command>  Pipe sources through preprocessor <command>"
;;

let mk_ppx f =
  "-ppx", Arg.String f,
  "<command>  Pipe abstract syntax trees through preprocessor <command>"
;;

let mk_principal f =
  "-principal", Arg.Unit f, " Check principality of type inference"
;;

let mk_rectypes f =
  "-rectypes", Arg.Unit f, " Allow arbitrary recursive types"
;;

let mk_safe_string f =
  "-safe-string", Arg.Unit f, " Make strings immutable"
;;

let mk_short_paths f =
  "-short-paths", Arg.Unit f, " Shorten paths in types"
;;

let mk_stdin f =
  "-stdin", Arg.Unit f, " Read script from standard input"
;;

let mk_strict_sequence f =
  "-strict-sequence", Arg.Unit f,
  " Left-hand part of a sequence must have type unit"
;;

let mk_unsafe f =
  "-unsafe", Arg.Unit f,
  " Do not compile bounds checking on array and string access"
;;

let mk_v f =
  "-v", Arg.Unit f,
  " Print compiler version and location of standard library and exit"
;;

let mk_verbose f =
  "-verbose", Arg.Unit f, " Print calls to external commands"
;;

let mk_version f =
  "-version", Arg.Unit f, " Print version and exit"
;;

let mk_vnum f =
  "-vnum", Arg.Unit f, " Print version number and exit"
;;

let mk_w f =
  "-w", Arg.String f,
  Printf.sprintf
  "<list>  Enable or disable warnings according to <list>:\n\
  \        +<spec>   enable warnings in <spec>\n\
  \        -<spec>   disable warnings in <spec>\n\
  \        @<spec>   enable warnings in <spec> and treat them as errors\n\
  \     <spec> can be:\n\
  \        <num>             a single warning number\n\
  \        <num1>..<num2>    a range of consecutive warning numbers\n\
  \        <letter>          a predefined set\n\
  \     default setting is %S" Warnings.defaults_w
;;

let mk_warn_error f =
  "-warn-error", Arg.String f,
  Printf.sprintf
  "<list>  Enable or disable error status for warnings according\n\
  \     to <list>.  See option -w for the syntax of <list>.\n\
  \     Default setting is %S" Warnings.defaults_warn_error
;;

let mk_warn_help f =
  "-warn-help", Arg.Unit f, " Show description of warning numbers"
;;

let mk_where f =
  "-where", Arg.Unit f, " Print location of standard library and exit"
;;

let mk_nopervasives f =
  "-nopervasives", Arg.Unit f, " (undocumented)"
;;

let mk_dparsetree f =
  "-dparsetree", Arg.Unit f, " (undocumented)"
;;

let mk_dtypedtree f =
  "-dtypedtree", Arg.Unit f, " (undocumented)"
;;

let mk_drawlambda f =
  "-drawlambda", Arg.Unit f, " (undocumented)"
;;

let mk_dsource f =
  "-dsource", Arg.Unit f, " (undocumented)"
;;

let mk_dlambda f =
  "-dlambda", Arg.Unit f, " (undocumented)"
;;

let mk_opaque f =
  "-opaque", Arg.Unit f,
  " Does not generate cross-module optimization information\n\
  \     (reduces necessary recompilation on module change)"
;;

let mk_strict_formats f =
  "-strict-formats", Arg.Unit f,
  " Reject invalid formats accepted by legacy implementations\n\
  \     (Warning: Invalid formats may behave differently from\n\
  \      previous OCaml versions, and will become always-rejected\n\
  \      in future OCaml versions. You should use this flag\n\
  \      to detect and fix invalid formats.)"
;;

let mk__ f =
  "-", Arg.String f,
  "<file>  Treat <file> as a file name (even if it starts with `-')"
;;

let show_config () =
  Config.print_config stdout;
  exit 0;
;;

let ocaml_options = 
  let bs_version_string = 
    "BuckleScript " ^ Js_config.version ^
    " (Using OCaml" ^ Config.version ^ " )" in

  let print_version_and_library compiler =
    Printf.printf "The OCaml %s, version " compiler;
    print_string bs_version_string; print_newline();
    print_string "Standard library directory: ";
    print_string Config.standard_library; print_newline();
    exit 0 in

  let print_standard_library = Compenv.print_standard_library in

  let print_version_string () = 
    print_string bs_version_string;
    print_newline (); 
    exit 0 in

  let set r () = r := true in 
  let unset r () = r := false in 
  let _absname = set Location.absname in 
  let _annot = set annotations in 
  let _binannot = set binary_annotations in 
  let _c = set compile_only in 
  let _config = show_config in 
  let _g = set debug in 
  let _i () = print_types := true; compile_only := true in 
  let _I s = include_dirs := s :: !include_dirs in 
  (* let _impl = impl in  *)
  (* let _intf = intf in  *)
  let _intf_suffix s = Config.interface_suffix := s in 
  let _keep_docs = set keep_docs in 
  let _keep_locs = set keep_locs in 
  let _labels = unset classic in 
  let _no_alias_deps = set transparent_modules in 
  let _no_app_funct = unset applicative_functors in 
  let _noassert = set noassert in 
  let _nolabels = set classic in 
  let _nostdlib = set no_std_include in 
  let _o s = output_name := Some s in 
  let _open s = open_modules := s :: !open_modules in 
  let _pp s = preprocessor := Some s in 
  let _ppx s = first_ppx := s :: !first_ppx in 
  let _principal = set principal in 
  let _rectypes = set recursive_types in 
  let _safe_string = unset unsafe_string in 
  let _short_paths = unset real_paths in 
  let _strict_sequence = set strict_sequence in 
  let _strict_formats = set strict_formats in 
  let _unsafe = set fast in 
  let _unsafe_string = set unsafe_string in 
  let _v () = print_version_and_library "compiler" in 
  let _version = print_version_string in 
  let _vnum = print_version_string in 
  let _w = (Warnings.parse_options false) in
  let _warn_error = (Warnings.parse_options true) in
  let _warn_help = Warnings.help_warnings in
  let _where = print_standard_library in 
  let _verbose = set verbose in 
  let _nopervasives = set nopervasives in
  let _dsource = set dump_source in 
  let _dparsetree = set dump_parsetree in 
  let _dtypedtree = set dump_typedtree in
  let _drawlambda = set dump_rawlambda in
  let _dlambda = set dump_lambda in
  (* let anonymous = anonymous in *)

  [ mk_absname _absname;
    mk_annot _annot;
    mk_binannot _binannot;
    mk_c _c;
    mk_config _config;
    mk_g_byt _g;
    mk_i _i;
    mk_I _I;
    (* mk_impl _impl; *)
    (* mk_intf _intf; *)
    mk_intf_suffix _intf_suffix;
    mk_keep_docs _keep_docs;
    mk_keep_locs _keep_locs;
    mk_labels _labels;
    mk_no_alias_deps _no_alias_deps;
    mk_no_app_funct _no_app_funct;
    mk_noassert _noassert;
    mk_nolabels _nolabels;
    mk_nostdlib _nostdlib;
    mk_o _o;
    mk_open _open;
    mk_pp _pp;
    mk_ppx _ppx;
    mk_principal _principal;
    mk_rectypes _rectypes;
    mk_safe_string _safe_string;
    mk_short_paths _short_paths;
    mk_strict_sequence _strict_sequence;
    mk_strict_formats _strict_formats;
    mk_unsafe _unsafe;
    mk_v _v;
    mk_verbose _verbose;
    mk_version _version;
    mk_vnum _vnum;
    mk_w _w;
    mk_warn_error _warn_error;
    mk_warn_help _warn_help;
    mk_where _where;
    (* mk__ anonymous; *)
    mk_nopervasives _nopervasives;
    mk_dsource _dsource;
    mk_dparsetree _dparsetree;
    mk_dtypedtree _dtypedtree;
    mk_drawlambda _drawlambda;
    mk_dlambda _dlambda ]


end
module Js_main : sig 
#1 "js_main.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


end = struct
#1 "js_main.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)


let process_interface_file ppf name =
  Js_implementation.interface ppf name (Compenv.output_prefix name)
let process_implementation_file ppf name =
  Js_implementation.implementation ppf name (Compenv.output_prefix name)


let process_file ppf name =
  match Ocaml_parse.check_suffix  name with 
  | `Ml, opref ->
    Js_implementation.implementation ppf name opref 
  | `Mli, opref -> 
    Js_implementation.interface ppf name opref 


let usage = "Usage: bsc <options> <files>\nOptions are:"

let ppf = Format.err_formatter

(* Error messages to standard error formatter *)
let anonymous filename =
  Compenv.readenv ppf Before_compile; process_file ppf filename;;
let impl filename =
  Compenv.readenv ppf Before_compile; process_implementation_file ppf filename;;
let intf filename =
  Compenv.readenv ppf Before_compile; process_interface_file ppf filename;;

let batch_files  = ref []
let main_file  = ref ""
let eval_string = ref ""
    
let collect_file name = 
  batch_files := name :: !batch_files


let set_main_entry name =
  if !eval_string <> "" then
    raise (Arg.Bad ("-bs-main conflicts with -bs-eval")) else 
  if Sys.file_exists name then 
    main_file := name else
  raise (Arg.Bad ("file " ^ name ^ " don't exist"))


let set_eval_string s = 
  if !main_file <> "" then 
    raise (Arg.Bad ("-bs-main conflicts with -bs-eval")) else 
  eval_string :=  s 


let (//) = Filename.concat
(** [resolve cwd module_name], 
    [cwd] is current working directory, absolute path
    Trying to find paths to load [module_name]
    it is sepcialized for option [-bs-package-include] which requires
    [npm_package_name/lib/ocaml]
*)
let  resolve_bs_package ~cwd name = 
  let sub_path = name // "lib" // "ocaml" in
  let rec aux origin cwd name = 
    let destdir =  cwd // Literals.node_modules // sub_path in 
    if Ext_sys.is_directory_no_exn destdir then destdir
    else 
      let cwd' = Filename.dirname cwd in 
      if String.length cwd' < String.length cwd then  
        aux origin   cwd' name
      else 
        try 
          let destdir = 
            Sys.getenv "npm_config_prefix" 
            // "lib" // Literals.node_modules // sub_path in
          if Ext_sys.is_directory_no_exn destdir
          then destdir
          else
            Bs_exception.error (Bs_package_not_found name)
        with 
          Not_found ->
          Bs_exception.error (Bs_package_not_found name)          
  in
  aux cwd cwd name

let add_package s = 
  let path = 
    resolve_bs_package
      ~cwd:(Lazy.force Ext_filename.cwd) s   in 
  Clflags.include_dirs := path :: ! Clflags.include_dirs


let set_noassert () = 
  Js_config.set_no_any_assert ();
  Clflags.noassert := true

let pp_directive_value fmt (x : Lexer.directive_value) =
  match x with
  | Dir_bool b -> Format.pp_print_bool fmt b
  | Dir_int b -> Format.pp_print_int fmt b
  | Dir_float b -> Format.pp_print_float fmt b
  | Dir_string s  -> Format.fprintf fmt "%S" s
                       
let list_variables () =
  let fmt = Format.err_formatter in
  Lexer.iter_directive_built_in_value
    (fun s  dir_value ->
       Format.fprintf
         fmt "@[%s@ %a@]@."
         s pp_directive_value dir_value
         
    )

let define_variable s =
  match Ext_string.split ~keep_empty:true s '=' with
  | [key; v] when
      String.length key > 0
      && Char.uppercase (key.[0]) = key.[0]
    ->
    Lexer.replace_directive_built_in_value key
      begin
        (* NEED Sync up across {!lexer.mll} {!bspp.ml} and here,
           TODO: put it in {!lexer.mll}
        *)
        try Dir_bool (bool_of_string v) with 
          _ -> 
          begin 
            try Dir_int (int_of_string v )
            with 
              _ -> 
              begin try (Dir_float (float_of_string v)) 
                with _ -> Dir_string v
              end
          end
      end

  | _ -> raise (Arg.Bad ("illegal definition" ^ s))
  
let buckle_script_flags =
  ("-bs-no-implicit-include", Arg.Set Clflags.no_implicit_current_dir
  , " Don't include current dir implicitly")
  ::
  ("-bs-assume-no-mli", Arg.Set Clflags.assume_no_mli,
  " Don't lookup whether mli exist or not")
  ::
  ("-bs-D", Arg.String define_variable,
     " Define conditional variable e.g, -D DEBUG=true"
  )
  ::
  ("-bs-list-conditionals",
   Arg.Unit list_variables,
   " List existing conditional variables")
  ::
  (
    "-bs-binary-ast", Arg.Set Js_config.binary_ast,
    " generate binary .mli_ast and ml_ast"
  )
  ::
  ("-bs-syntax-only", 
   Arg.Set Js_config.syntax_only,
   " only check syntax"
  )
  ::
  ("-bs-eval", 
   Arg.String set_eval_string, 
   " (experimental) Set the string to be evaluated, note this flag will be conflicted with -bs-main"
  )
  ::
  (
    "-bs-sort-imports",
    Arg.Set Js_config.sort_imports,
    " Sort the imports by lexical order so the output will be more stable"
  )
  ::
  ("-bs-better-errors",
   Arg.Set Js_config.better_errors,
   " Better error message combined with other tools "
  )::
  ("-bs-package-name", 
   Arg.String Js_config.set_package_name, 
   " set package name, useful when you want to produce npm packages")
  :: 
  ("-bs-no-version-header", 
   Arg.Set Js_config.no_version_header,
   " Don't print version header"
  )
  ::
  ("-bs-package-output", 
   Arg.String Js_config.set_npm_package_path, 
   " set npm-output-path: [opt_module]:path, for example: 'lib/cjs', 'amdjs:lib/amdjs' and 'goog:lib/gjs'")
  ::
  ("-bs-package-include", 
   Arg.String add_package, 
   " set package names, for example bs-platform "  )
  ::
  ("-bs-no-warn-unused-bs-attribute",
   Arg.Set Js_config.no_warn_unused_bs_attribute,
   " disable warnings on unused bs. attribute"
  )
  ::
  ("-bs-no-warn-ffi-type", 
   Arg.Set Js_config.no_warn_ffi_type,
   " disable warnings for ffi type"
  ) 
  ::
  ("-bs-no-builtin-ppx-ml", 
   Arg.Set Js_config.no_builtin_ppx_ml,
   "disable built-in ppx for ml files (internal use)")
  :: 
  ("-bs-no-builtin-ppx-mli",
   Arg.Set Js_config.no_builtin_ppx_mli,
   "disable built-in ppx for mli files (internal use)")
  :: 
  ("-bs-cross-module-opt", 
   Arg.Set Js_config.cross_module_inline, 
   "enable cross module inlining(experimental), default(false)")
  :: 
  ("-bs-gen-tds",
   Arg.Set Js_config.default_gen_tds, 
   " set will generate `.d.ts` file for typescript (experimental)")
  :: 
  ("-bs-diagnose",
   Arg.Set Js_config.diagnose, 
   " More verbose output")
  :: 
  ("-bs-no-check-div-by-zero",
   Arg.Clear Js_config.check_div_by_zero, 
   " unsafe mode, don't check div by zero and mod by zero")
  ::
  ("-bs-no-any-assert",
   Arg.Unit set_noassert, 
   " no code containing any assertion"
  )
  ::
  ("-bs-main",
   Arg.String set_main_entry,   
   " set the Main entry file")
  :: 
  ("-bs-files", 
   Arg.Rest collect_file, 
   " Provide batch of files, the compiler will sort it before compiling"
  )
  (* :: *)
  (* ("-bs-list-directives", *)
  (* ) *)
  :: Ocaml_options.mk_impl impl
  :: Ocaml_options.mk_intf intf 
  :: Ocaml_options.mk__ anonymous
  :: Ocaml_options.ocaml_options




let _ = 
  Clflags.unsafe_string := false;
  Clflags.debug := true;
  Bs_conditional_initial.setup_env ();
  try
    Compenv.readenv ppf Before_args;
    Arg.parse buckle_script_flags anonymous usage;
    let main_file = !main_file in
    let eval_string = !eval_string in
    let task : Ocaml_batch_compile.task = 
      if main_file <> "" then 
        Main main_file
      else if eval_string <> "" then 
        Eval eval_string
      else None in
    exit (Ocaml_batch_compile.batch_compile ppf !batch_files task) 
  with x ->
    if not @@ !Js_config.better_errors then
      begin (* plain error messge reporting*)
        Location.report_exception ppf x;
        exit 2
      end
    else
      (** Fancy error message reporting*)
      exit 2





end
