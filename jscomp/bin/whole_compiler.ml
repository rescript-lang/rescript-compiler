module Config = Config_whole_compiler
module Bs_version : sig 
#1 "bs_version.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

val version : string

val header : string 

val package_name : string
end = struct
#1 "bs_version.ml"

(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)    
let version = "1.9.3"
let header = 
   "// Generated by BUCKLESCRIPT VERSION 1.9.3, PLEASE EDIT WITH CARE"  
let package_name = "bs-platform"   
    
end
module Clflags : sig 
#1 "clflags.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 2005 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

val objfiles : string list ref
val ccobjs : string list ref
val dllibs : string list ref
val compile_only : bool ref
val output_name : string option ref
val include_dirs : string list ref
val no_std_include : bool ref
val print_types : bool ref
val make_archive : bool ref
val debug : bool ref
val fast : bool ref
val link_everything : bool ref
val custom_runtime : bool ref
val no_check_prims : bool ref
val bytecode_compatible_32 : bool ref
val output_c_object : bool ref
val output_complete_object : bool ref
val all_ccopts : string list ref
val classic : bool ref
val nopervasives : bool ref
val open_modules : string list ref
val preprocessor : string option ref
val all_ppx : string list ref
val annotations : bool ref
val binary_annotations : bool ref
val use_threads : bool ref
val use_vmthreads : bool ref
val noassert : bool ref
val verbose : bool ref
val noprompt : bool ref
val nopromptcont : bool ref
val init_file : string option ref
val noinit : bool ref
val use_prims : string ref
val use_runtime : string ref
val principal : bool ref
val real_paths : bool ref
val recursive_types : bool ref
val strict_sequence : bool ref
val strict_formats : bool ref
val applicative_functors : bool ref
val make_runtime : bool ref
val gprofile : bool ref
val c_compiler : string option ref
val no_auto_link : bool ref
val dllpaths : string list ref
val make_package : bool ref
val for_package : string option ref
val error_size : int ref
val float_const_prop : bool ref
val transparent_modules : bool ref
val dump_source : bool ref
val dump_parsetree : bool ref
val dump_typedtree : bool ref
val dump_rawlambda : bool ref
val dump_lambda : bool ref
val dump_clambda : bool ref
val dump_instr : bool ref
val keep_asm_file : bool ref
val optimize_for_speed : bool ref
val dump_cmm : bool ref
val dump_selection : bool ref
val dump_cse : bool ref
val dump_live : bool ref
val dump_spill : bool ref
val dump_split : bool ref
val dump_interf : bool ref
val dump_prefer : bool ref
val dump_regalloc : bool ref
val dump_reload : bool ref
val dump_scheduling : bool ref
val dump_linear : bool ref
val keep_startup_file : bool ref
val dump_combine : bool ref
val native_code : bool ref
val inline_threshold : int ref
val dont_write_files : bool ref
val std_include_flag : string -> string
val std_include_dir : unit -> string list
val shared : bool ref
val dlcode : bool ref
val runtime_variant : string ref
val force_slash : bool ref
val keep_docs : bool ref
val keep_locs : bool ref
val unsafe_string : bool ref
val opaque : bool ref


 
type mli_status = Mli_na | Mli_exists | Mli_non_exists
val no_implicit_current_dir : bool ref
val assume_no_mli : mli_status ref 
val record_event_when_debug : bool ref 
val bs_vscode : bool


type color_setting = Auto | Always | Never
val parse_color_setting : string -> color_setting option
val color : color_setting ref


end = struct
#1 "clflags.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Command-line parameters *)

let objfiles = ref ([] : string list)   (* .cmo and .cma files *)
and ccobjs = ref ([] : string list)     (* .o, .a, .so and -cclib -lxxx *)
and dllibs = ref ([] : string list)     (* .so and -dllib -lxxx *)

let compile_only = ref false            (* -c *)
and output_name = ref (None : string option) (* -o *)
and include_dirs = ref ([] : string list)(* -I *)
and no_std_include = ref false          (* -nostdlib *)
and print_types = ref false             (* -i *)
and make_archive = ref false            (* -a *)
and debug = ref false                   (* -g *)
and fast = ref false                    (* -unsafe *)
and link_everything = ref false         (* -linkall *)
and custom_runtime = ref false          (* -custom *)
and no_check_prims = ref false          (* -no-check-prims *)
and bytecode_compatible_32 = ref false  (* -compat-32 *)
and output_c_object = ref false         (* -output-obj *)
and output_complete_object = ref false  (* -output-complete-obj *)
and all_ccopts = ref ([] : string list)     (* -ccopt *)
and classic = ref false                 (* -nolabels *)
and nopervasives = ref false            (* -nopervasives *)
and preprocessor = ref(None : string option) (* -pp *)
and all_ppx = ref ([] : string list)        (* -ppx *)
let annotations = ref false             (* -annot *)
let binary_annotations = ref false      (* -annot *)
and use_threads = ref false             (* -thread *)
and use_vmthreads = ref false           (* -vmthread *)
and noassert = ref false                (* -noassert *)
and verbose = ref false                 (* -verbose *)
and noprompt = ref false                (* -noprompt *)
and nopromptcont = ref false            (* -nopromptcont *)
and init_file = ref (None : string option)   (* -init *)
and noinit = ref false                  (* -noinit *)
and open_modules = ref []               (* -open *)
and use_prims = ref ""                  (* -use-prims ... *)
and use_runtime = ref ""                (* -use-runtime ... *)
and principal = ref false               (* -principal *)
and real_paths = ref true               (* -short-paths *)
and recursive_types = ref false         (* -rectypes *)
and strict_sequence = ref false         (* -strict-sequence *)
and strict_formats = ref false          (* -strict-formats *)
and applicative_functors = ref true     (* -no-app-funct *)
and make_runtime = ref false            (* -make-runtime *)
and gprofile = ref false                (* -p *)
and c_compiler = ref (None: string option) (* -cc *)
and no_auto_link = ref false            (* -noautolink *)
and dllpaths = ref ([] : string list)   (* -dllpath *)
and make_package = ref false            (* -pack *)
and for_package = ref (None: string option) (* -for-pack *)
and error_size = ref 500                (* -error-size *)
and float_const_prop = ref true         (* -no-float-const-prop *)
and transparent_modules = ref false     (* -trans-mod *)
let dump_source = ref false             (* -dsource *)
let dump_parsetree = ref false          (* -dparsetree *)
and dump_typedtree = ref false          (* -dtypedtree *)
and dump_rawlambda = ref false          (* -drawlambda *)
and dump_lambda = ref false             (* -dlambda *)
and dump_clambda = ref false            (* -dclambda *)
and dump_instr = ref false              (* -dinstr *)

let keep_asm_file = ref false           (* -S *)
let optimize_for_speed = ref true       (* -compact *)
and opaque = ref false                  (* -opaque *)

and dump_cmm = ref false                (* -dcmm *)
let dump_selection = ref false          (* -dsel *)
let dump_cse = ref false                (* -dcse *)
let dump_live = ref false               (* -dlive *)
let dump_spill = ref false              (* -dspill *)
let dump_split = ref false              (* -dsplit *)
let dump_interf = ref false             (* -dinterf *)
let dump_prefer = ref false             (* -dprefer *)
let dump_regalloc = ref false           (* -dalloc *)
let dump_reload = ref false             (* -dreload *)
let dump_scheduling = ref false         (* -dscheduling *)
let dump_linear = ref false             (* -dlinear *)
let keep_startup_file = ref false       (* -dstartup *)
let dump_combine = ref false            (* -dcombine *)
let native_code = ref false             (* set to true under ocamlopt *)
let inline_threshold = ref 10
let force_slash = ref false             (* for ocamldep *)

let dont_write_files = ref false        (* set to true under ocamldoc *)

let std_include_flag prefix =
  if !no_std_include then ""
  else (prefix ^ (Filename.quote Config.standard_library))
;;

let std_include_dir () =
  if !no_std_include then [] else [Config.standard_library]
;;

let shared = ref false (* -shared *)
let dlcode = ref true (* not -nodynlink *)

let runtime_variant = ref "";;      (* -runtime-variant *)

let keep_docs = ref false              (* -keep-docs *)
let keep_locs = ref false              (* -keep-locs *)
let unsafe_string = ref true;;         (* -safe-string / -unsafe-string *)


 
type mli_status = Mli_na | Mli_exists | Mli_non_exists
let no_implicit_current_dir = ref false
let assume_no_mli = ref Mli_na
let record_event_when_debug = ref true (* turned off in BuckleScript*)
let bs_vscode = 
    try ignore @@ Sys.getenv "BS_VSCODE" ; true with _ -> false
    (* We get it from environment variable mostly due to 
       we don't want to rebuild when flip on or off
    *)


type color_setting = Auto | Always | Never
let parse_color_setting = function
  | "auto" -> Some Auto
  | "always" -> Some Always
  | "never" -> Some Never
  | _ -> None
let color = ref Auto ;; (* -color *)


end
module Misc : sig 
#1 "misc.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Miscellaneous useful types and functions *)

val fatal_error: string -> 'a
exception Fatal_error

val try_finally : (unit -> 'a) -> (unit -> unit) -> 'a;;

val map_end: ('a -> 'b) -> 'a list -> 'b list -> 'b list
        (* [map_end f l t] is [map f l @ t], just more efficient. *)
val map_left_right: ('a -> 'b) -> 'a list -> 'b list
        (* Like [List.map], with guaranteed left-to-right evaluation order *)
val for_all2: ('a -> 'b -> bool) -> 'a list -> 'b list -> bool
        (* Same as [List.for_all] but for a binary predicate.
           In addition, this [for_all2] never fails: given two lists
           with different lengths, it returns false. *)
val replicate_list: 'a -> int -> 'a list
        (* [replicate_list elem n] is the list with [n] elements
           all identical to [elem]. *)
val list_remove: 'a -> 'a list -> 'a list
        (* [list_remove x l] returns a copy of [l] with the first
           element equal to [x] removed. *)
val split_last: 'a list -> 'a list * 'a
        (* Return the last element and the other elements of the given list. *)
val samelist: ('a -> 'a -> bool) -> 'a list -> 'a list -> bool
        (* Like [List.for_all2] but returns [false] if the two
           lists have different length. *)

val may: ('a -> unit) -> 'a option -> unit
val may_map: ('a -> 'b) -> 'a option -> 'b option

val find_in_path: string list -> string -> string
        (* Search a file in a list of directories. *)
val find_in_path_rel: string list -> string -> string
        (* Search a relative file in a list of directories. *)
val find_in_path_uncap: string list -> string -> string
        (* Same, but search also for uncapitalized name, i.e.
           if name is Foo.ml, allow /path/Foo.ml and /path/foo.ml
           to match. *)
val remove_file: string -> unit
        (* Delete the given file if it exists. Never raise an error. *)
val expand_directory: string -> string -> string
        (* [expand_directory alt file] eventually expands a [+] at the
           beginning of file into [alt] (an alternate root directory) *)

val create_hashtable: int -> ('a * 'b) list -> ('a, 'b) Hashtbl.t
        (* Create a hashtable of the given size and fills it with the
           given bindings. *)

val copy_file: in_channel -> out_channel -> unit
        (* [copy_file ic oc] reads the contents of file [ic] and copies
           them to [oc]. It stops when encountering EOF on [ic]. *)
val copy_file_chunk: in_channel -> out_channel -> int -> unit
        (* [copy_file_chunk ic oc n] reads [n] bytes from [ic] and copies
           them to [oc]. It raises [End_of_file] when encountering
           EOF on [ic]. *)
val string_of_file: in_channel -> string
        (* [string_of_file ic] reads the contents of file [ic] and copies
           them to a string. It stops when encountering EOF on [ic]. *)
val log2: int -> int
        (* [log2 n] returns [s] such that [n = 1 lsl s]
           if [n] is a power of 2*)
val align: int -> int -> int
        (* [align n a] rounds [n] upwards to a multiple of [a]
           (a power of 2). *)
val no_overflow_add: int -> int -> bool
        (* [no_overflow_add n1 n2] returns [true] if the computation of
           [n1 + n2] does not overflow. *)
val no_overflow_sub: int -> int -> bool
        (* [no_overflow_add n1 n2] returns [true] if the computation of
           [n1 - n2] does not overflow. *)
val no_overflow_lsl: int -> bool
        (* [no_overflow_add n] returns [true] if the computation of
           [n lsl 1] does not overflow. *)

val chop_extension_if_any: string -> string
        (* Like Filename.chop_extension but returns the initial file
           name if it has no extension *)

val chop_extensions: string -> string
        (* Return the given file name without its extensions. The extensions
           is the longest suffix starting with a period and not including
           a directory separator, [.xyz.uvw] for instance.

           Return the given name if it does not contain an extension. *)

val search_substring: string -> string -> int -> int
        (* [search_substring pat str start] returns the position of the first
           occurrence of string [pat] in string [str].  Search starts
           at offset [start] in [str].  Raise [Not_found] if [pat]
           does not occur. *)

val replace_substring: before:string -> after:string -> string -> string
        (* [search_substring ~before ~after str] replaces all occurences
           of [before] with [after] in [str] and returns the resulting string. *)

val rev_split_words: string -> string list
        (* [rev_split_words s] splits [s] in blank-separated words, and return
           the list of words in reverse order. *)

val get_ref: 'a list ref -> 'a list
        (* [get_ref lr] returns the content of the list reference [lr] and reset
           its content to the empty list. *)


val fst3: 'a * 'b * 'c -> 'a
val snd3: 'a * 'b * 'c -> 'b
val thd3: 'a * 'b * 'c -> 'c

val fst4: 'a * 'b * 'c * 'd -> 'a
val snd4: 'a * 'b * 'c * 'd -> 'b
val thd4: 'a * 'b * 'c * 'd -> 'c
val for4: 'a * 'b * 'c * 'd -> 'd

module LongString :
  sig
    type t = bytes array
    val create : int -> t
    val length : t -> int
    val get : t -> int -> char
    val set : t -> int -> char -> unit
    val blit : t -> int -> t -> int -> int -> unit
    val output : out_channel -> t -> int -> int -> unit
    val unsafe_blit_to_bytes : t -> int -> bytes -> int -> int -> unit
    val input_bytes : in_channel -> int -> t
  end

val edit_distance : string -> string -> int -> int option
(** [edit_distance a b cutoff] computes the edit distance between
    strings [a] and [b]. To help efficiency, it uses a cutoff: if the
    distance [d] is smaller than [cutoff], it returns [Some d], else
    [None].

    The distance algorithm currently used is Damerau-Levenshtein: it
    computes the number of insertion, deletion, substitution of
    letters, or swapping of adjacent letters to go from one word to the
    other. The particular algorithm may change in the future.
*)

val split : string -> char -> string list
(** [String.split string char] splits the string [string] at every char
    [char], and returns the list of sub-strings between the chars.
    [String.concat (String.make 1 c) (String.split s c)] is the identity.
    @since 4.01
 *)

val cut_at : string -> char -> string * string
(** [String.cut_at s c] returns a pair containing the sub-string before
   the first occurrence of [c] in [s], and the sub-string after the
   first occurrence of [c] in [s].
   [let (before, after) = String.cut_at s c in
    before ^ String.make 1 c ^ after] is the identity if [s] contains [c].

   Raise [Not_found] if the character does not appear in the string
   @since 4.01
*)





(* Color handling *)
module Color : sig
  type color =
    | Black
    | Red
    | Green
    | Yellow
    | Blue
    | Magenta
    | Cyan
    | White
  ;;

  type style =
    | FG of color (* foreground *)
    | BG of color (* background *)
    | Bold
    | Reset

    | Dim


  val ansi_of_style_l : style list -> string
  (* ANSI escape sequence for the given style *)

  type styles = {
    error: style list;
    warning: style list;
    loc: style list;
  }

  val default_styles: styles
  val get_styles: unit -> styles
  val set_styles: styles -> unit

  val setup : Clflags.color_setting -> unit
  (* [setup opt] will enable or disable color handling on standard formatters
     according to the value of color setting [opt].
     Only the first call to this function has an effect. *)

  val set_color_tag_handling : Format.formatter -> unit
  (* adds functions to support color tags to the given formatter. *)
end


end = struct
#1 "misc.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Errors *)

exception Fatal_error

let fatal_error msg =
  prerr_string ">> Fatal error: "; prerr_endline msg; raise Fatal_error

(* Exceptions *)

let try_finally work cleanup =
  let result = (try work () with e -> cleanup (); raise e) in
  cleanup ();
  result
;;

(* List functions *)

let rec map_end f l1 l2 =
  match l1 with
    [] -> l2
  | hd::tl -> f hd :: map_end f tl l2

let rec map_left_right f = function
    [] -> []
  | hd::tl -> let res = f hd in res :: map_left_right f tl

let rec for_all2 pred l1 l2 =
  match (l1, l2) with
    ([], []) -> true
  | (hd1::tl1, hd2::tl2) -> pred hd1 hd2 && for_all2 pred tl1 tl2
  | (_, _) -> false

let rec replicate_list elem n =
  if n <= 0 then [] else elem :: replicate_list elem (n-1)

let rec list_remove x = function
    [] -> []
  | hd :: tl ->
      if hd = x then tl else hd :: list_remove x tl

let rec split_last = function
    [] -> assert false
  | [x] -> ([], x)
  | hd :: tl ->
      let (lst, last) = split_last tl in
      (hd :: lst, last)

let rec samelist pred l1 l2 =
  match (l1, l2) with
  | ([], []) -> true
  | (hd1 :: tl1, hd2 :: tl2) -> pred hd1 hd2 && samelist pred tl1 tl2
  | (_, _) -> false

(* Options *)

let may f = function
    Some x -> f x
  | None -> ()

let may_map f = function
    Some x -> Some (f x)
  | None -> None

(* File functions *)

let find_in_path path name =
  if not (Filename.is_implicit name) then
    if Sys.file_exists name then name else raise Not_found
  else begin
    let rec try_dir = function
      [] -> raise Not_found
    | dir::rem ->
        let fullname = Filename.concat dir name in
        if Sys.file_exists fullname then fullname else try_dir rem
    in try_dir path
  end

let find_in_path_rel path name =
  let rec simplify s =
    let open Filename in
    let base = basename s in
    let dir = dirname s in
    if dir = s then dir
    else if base = current_dir_name then simplify dir
    else concat (simplify dir) base
  in
  let rec try_dir = function
    [] -> raise Not_found
  | dir::rem ->
      let fullname = simplify (Filename.concat dir name) in
      if Sys.file_exists fullname then fullname else try_dir rem
  in try_dir path

let find_in_path_uncap path name =
  let uname = String.uncapitalize name in
  let rec try_dir = function
    [] -> raise Not_found
  | dir::rem ->
      let fullname = Filename.concat dir name
      and ufullname = Filename.concat dir uname in
      if Sys.file_exists ufullname then ufullname
      else if Sys.file_exists fullname then fullname
      else try_dir rem
  in try_dir path

let remove_file filename =
  try
    Sys.remove filename
  with Sys_error msg ->
    ()

(* Expand a -I option: if it starts with +, make it relative to the standard
   library directory *)

let expand_directory alt s =
  if String.length s > 0 && s.[0] = '+'
  then Filename.concat alt
                       (String.sub s 1 (String.length s - 1))
  else s

(* Hashtable functions *)

let create_hashtable size init =
  let tbl = Hashtbl.create size in
  List.iter (fun (key, data) -> Hashtbl.add tbl key data) init;
  tbl

(* File copy *)

let copy_file ic oc =
  let buff = Bytes.create 0x1000 in
  let rec copy () =
    let n = input ic buff 0 0x1000 in
    if n = 0 then () else (output oc buff 0 n; copy())
  in copy()

let copy_file_chunk ic oc len =
  let buff = Bytes.create 0x1000 in
  let rec copy n =
    if n <= 0 then () else begin
      let r = input ic buff 0 (min n 0x1000) in
      if r = 0 then raise End_of_file else (output oc buff 0 r; copy(n-r))
    end
  in copy len

let string_of_file ic =
  let b = Buffer.create 0x10000 in
  let buff = Bytes.create 0x1000 in
  let rec copy () =
    let n = input ic buff 0 0x1000 in
    if n = 0 then Buffer.contents b else
      (Buffer.add_subbytes b buff 0 n; copy())
  in copy()

(* Integer operations *)

let rec log2 n =
  if n <= 1 then 0 else 1 + log2(n asr 1)

let align n a =
  if n >= 0 then (n + a - 1) land (-a) else n land (-a)

let no_overflow_add a b = (a lxor b) lor (a lxor (lnot (a+b))) < 0

let no_overflow_sub a b = (a lxor (lnot b)) lor (b lxor (a-b)) < 0

let no_overflow_lsl a = min_int asr 1 <= a && a <= max_int asr 1

(* String operations *)

let chop_extension_if_any fname =
  try Filename.chop_extension fname with Invalid_argument _ -> fname

let chop_extensions file =
  let dirname = Filename.dirname file and basename = Filename.basename file in
  try
    let pos = String.index basename '.' in
    let basename = String.sub basename 0 pos in
    if Filename.is_implicit file && dirname = Filename.current_dir_name then
      basename
    else
      Filename.concat dirname basename
  with Not_found -> file

let search_substring pat str start =
  let rec search i j =
    if j >= String.length pat then i
    else if i + j >= String.length str then raise Not_found
    else if str.[i + j] = pat.[j] then search i (j+1)
    else search (i+1) 0
  in search start 0

let replace_substring ~before ~after str =
  let rec search acc curr =
    match search_substring before str curr with
      | next ->
         let prefix = String.sub str curr (next - curr) in
         search (prefix :: acc) (next + String.length before)
      | exception Not_found ->
        let suffix = String.sub str curr (String.length str - curr) in
        List.rev (suffix :: acc)
  in String.concat after (search [] 0)

let rev_split_words s =
  let rec split1 res i =
    if i >= String.length s then res else begin
      match s.[i] with
        ' ' | '\t' | '\r' | '\n' -> split1 res (i+1)
      | _ -> split2 res i (i+1)
    end
  and split2 res i j =
    if j >= String.length s then String.sub s i (j-i) :: res else begin
      match s.[j] with
        ' ' | '\t' | '\r' | '\n' -> split1 (String.sub s i (j-i) :: res) (j+1)
      | _ -> split2 res i (j+1)
    end
  in split1 [] 0

let get_ref r =
  let v = !r in
  r := []; v

let fst3 (x, _, _) = x
let snd3 (_,x,_) = x
let thd3 (_,_,x) = x

let fst4 (x, _, _, _) = x
let snd4 (_,x,_, _) = x
let thd4 (_,_,x,_) = x
let for4 (_,_,_,x) = x


module LongString = struct
  type t = bytes array

  let create str_size =
    let tbl_size = str_size / Sys.max_string_length + 1 in
    let tbl = Array.make tbl_size Bytes.empty in
    for i = 0 to tbl_size - 2 do
      tbl.(i) <- Bytes.create Sys.max_string_length;
    done;
    tbl.(tbl_size - 1) <- Bytes.create (str_size mod Sys.max_string_length);
    tbl

  let length tbl =
    let tbl_size = Array.length tbl in
    Sys.max_string_length * (tbl_size - 1) + Bytes.length tbl.(tbl_size - 1)

  let get tbl ind =
    Bytes.get tbl.(ind / Sys.max_string_length) (ind mod Sys.max_string_length)

  let set tbl ind c =
    Bytes.set tbl.(ind / Sys.max_string_length) (ind mod Sys.max_string_length)
              c

  let blit src srcoff dst dstoff len =
    for i = 0 to len - 1 do
      set dst (dstoff + i) (get src (srcoff + i))
    done

  let output oc tbl pos len =
    for i = pos to pos + len - 1 do
      output_char oc (get tbl i)
    done

  let unsafe_blit_to_bytes src srcoff dst dstoff len =
    for i = 0 to len - 1 do
      Bytes.unsafe_set dst (dstoff + i) (get src (srcoff + i))
    done

  let input_bytes ic len =
    let tbl = create len in
    Array.iter (fun str -> really_input ic str 0 (Bytes.length str)) tbl;
    tbl
end


let edit_distance a b cutoff =
  let la, lb = String.length a, String.length b in
  let cutoff =
    (* using max_int for cutoff would cause overflows in (i + cutoff + 1);
       we bring it back to the (max la lb) worstcase *)
    min (max la lb) cutoff in
  if abs (la - lb) > cutoff then None
  else begin
    (* initialize with 'cutoff + 1' so that not-yet-written-to cases have
       the worst possible cost; this is useful when computing the cost of
       a case just at the boundary of the cutoff diagonal. *)
    let m = Array.make_matrix (la + 1) (lb + 1) (cutoff + 1) in
    m.(0).(0) <- 0;
    for i = 1 to la do
      m.(i).(0) <- i;
    done;
    for j = 1 to lb do
      m.(0).(j) <- j;
    done;
    for i = 1 to la do
      for j = max 1 (i - cutoff - 1) to min lb (i + cutoff + 1) do
        let cost = if a.[i-1] = b.[j-1] then 0 else 1 in
        let best =
          (* insert, delete or substitute *)
          min (1 + min m.(i-1).(j) m.(i).(j-1)) (m.(i-1).(j-1) + cost)
        in
        let best =
          (* swap two adjacent letters; we use "cost" again in case of
             a swap between two identical letters; this is slightly
             redundant as this is a double-substitution case, but it
             was done this way in most online implementations and
             imitation has its virtues *)
          if not (i > 1 && j > 1 && a.[i-1] = b.[j-2] && a.[i-2] = b.[j-1])
          then best
          else min best (m.(i-2).(j-2) + cost)
        in
        m.(i).(j) <- best
      done;
    done;
    let result = m.(la).(lb) in
    if result > cutoff
    then None
    else Some result
  end


(* split a string [s] at every char [c], and return the list of sub-strings *)
let split s c =
  let len = String.length s in
  let rec iter pos to_rev =
    if pos = len then List.rev ("" :: to_rev) else
      match try
              Some ( String.index_from s pos c )
        with Not_found -> None
      with
          Some pos2 ->
            if pos2 = pos then iter (pos+1) ("" :: to_rev) else
              iter (pos2+1) ((String.sub s pos (pos2-pos)) :: to_rev)
        | None -> List.rev ( String.sub s pos (len-pos) :: to_rev )
  in
  iter 0 []

let cut_at s c =
  let pos = String.index s c in
  String.sub s 0 pos, String.sub s (pos+1) (String.length s - pos - 1)





(* Color handling *)
module Color = struct
  (* use ANSI color codes, see https://en.wikipedia.org/wiki/ANSI_escape_code *)
  type color =
    | Black
    | Red
    | Green
    | Yellow
    | Blue
    | Magenta
    | Cyan
    | White
  ;;

  type style =
    | FG of color (* foreground *)
    | BG of color (* background *)
    | Bold
    | Reset

    | Dim


  let ansi_of_color = function
    | Black -> "0"
    | Red -> "1"
    | Green -> "2"
    | Yellow -> "3"
    | Blue -> "4"
    | Magenta -> "5"
    | Cyan -> "6"
    | White -> "7"

  let code_of_style = function
    | FG c -> "3" ^ ansi_of_color c
    | BG c -> "4" ^ ansi_of_color c
    | Bold -> "1"
    | Reset -> "0"

    | Dim -> "2"


  let ansi_of_style_l l =
    let s = match l with
      | [] -> code_of_style Reset
      | [s] -> code_of_style s
      | _ -> String.concat ";" (List.map code_of_style l)
    in
    "\x1b[" ^ s ^ "m"

  type styles = {
    error: style list;
    warning: style list;
    loc: style list;
  }

  let default_styles = {
    warning = [Bold; FG Magenta];
    error = [Bold; FG Red];
    loc = [Bold];
  }

  let cur_styles = ref default_styles
  let get_styles () = !cur_styles
  let set_styles s = cur_styles := s

  (* map a tag to a style, if the tag is known.
     @raise Not_found otherwise *)
  let style_of_tag s = match s with
    | "error" -> (!cur_styles).error
    | "warning" -> (!cur_styles).warning
    | "loc" -> (!cur_styles).loc

    | "info" -> [Bold; FG Yellow]
    | "dim" -> [Dim]
    | "filename" -> [FG Cyan]

    | _ -> raise Not_found

  let color_enabled = ref true

  (* either prints the tag of [s] or delegate to [or_else] *)
  let mark_open_tag ~or_else s =
    try
      let style = style_of_tag s in
      if !color_enabled then ansi_of_style_l style else ""
    with Not_found -> or_else s

  let mark_close_tag ~or_else s =
    try
      let _ = style_of_tag s in
      if !color_enabled then ansi_of_style_l [Reset] else ""
    with Not_found -> or_else s

  (* add color handling to formatter [ppf] *)
  let set_color_tag_handling ppf =
    let open Format in
    let functions = pp_get_formatter_tag_functions ppf () in
    let functions' = {functions with
      mark_open_tag=(mark_open_tag ~or_else:functions.mark_open_tag);
      mark_close_tag=(mark_close_tag ~or_else:functions.mark_close_tag);
    } in
    pp_set_mark_tags ppf true; (* enable tags *)
    pp_set_formatter_tag_functions ppf functions'

  (* external isatty : out_channel -> bool = "caml_sys_isatty" *)

  (* reasonable heuristic on whether colors should be enabled *)
   let should_enable_color () = false  
(*    let term = try Sys.getenv "TERM" with Not_found -> "" in
    term <> "dumb"
    && term <> "" *)
(*    && isatty stderr *)

  let setup =
    let first = ref true in (* initialize only once *)
    let formatter_l = [Format.std_formatter; Format.err_formatter; Format.str_formatter] in
    fun o ->
      if !first then (
        first := false;
        Format.set_mark_tags true;
        List.iter set_color_tag_handling formatter_l;
        color_enabled := (match o with
          | Clflags.Always -> true
          | Clflags.Auto -> should_enable_color ()
          | Clflags.Never -> false
        )
      );
      ()
end


end
module Terminfo : sig 
#1 "terminfo.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Basic interface to the terminfo database *)

type status =
  | Uninitialised
  | Bad_term
  | Good_term of int  (* number of lines of the terminal *)
;;
external setup : out_channel -> status = "caml_terminfo_setup";;
external backup : int -> unit = "caml_terminfo_backup";;
external standout : bool -> unit = "caml_terminfo_standout";;
external resume : int -> unit = "caml_terminfo_resume";;

end = struct
#1 "terminfo.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Basic interface to the terminfo database *)

type status =
  | Uninitialised
  | Bad_term
  | Good_term of int
;;
external setup : out_channel -> status = "caml_terminfo_setup";;
external backup : int -> unit = "caml_terminfo_backup";;
external standout : bool -> unit = "caml_terminfo_standout";;
external resume : int -> unit = "caml_terminfo_resume";;

end
module Warnings : sig 
#1 "warnings.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Pierre Weis && Damien Doligez, INRIA Rocquencourt        *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Format

type t =
  | Comment_start                           (*  1 *)
  | Comment_not_end                         (*  2 *)
  | Deprecated of string                    (*  3 *)
  | Fragile_match of string                 (*  4 *)
  | Partial_application                     (*  5 *)
  | Labels_omitted                          (*  6 *)
  | Method_override of string list          (*  7 *)
  | Partial_match of string                 (*  8 *)
  | Non_closed_record_pattern of string     (*  9 *)
  | Statement_type                          (* 10 *)
  | Unused_match                            (* 11 *)
  | Unused_pat                              (* 12 *)
  | Instance_variable_override of string list (* 13 *)
  | Illegal_backslash                       (* 14 *)
  | Implicit_public_methods of string list  (* 15 *)
  | Unerasable_optional_argument            (* 16 *)
  | Undeclared_virtual_method of string     (* 17 *)
  | Not_principal of string                 (* 18 *)
  | Without_principality of string          (* 19 *)
  | Unused_argument                         (* 20 *)
  | Nonreturning_statement                  (* 21 *)
  | Preprocessor of string                  (* 22 *)
  | Useless_record_with                     (* 23 *)
  | Bad_module_name of string               (* 24 *)
  | All_clauses_guarded                     (* 25 *)
  | Unused_var of string                    (* 26 *)
  | Unused_var_strict of string             (* 27 *)
  | Wildcard_arg_to_constant_constr         (* 28 *)
  | Eol_in_string                           (* 29 *)
  | Duplicate_definitions of string * string * string * string (* 30 *)
  | Multiple_definition of string * string * string (* 31 *)
  | Unused_value_declaration of string      (* 32 *)
  | Unused_open of string                   (* 33 *)
  | Unused_type_declaration of string       (* 34 *)
  | Unused_for_index of string              (* 35 *)
  | Unused_ancestor of string               (* 36 *)
  | Unused_constructor of string * bool * bool (* 37 *)
  | Unused_extension of string * bool * bool   (* 38 *)
  | Unused_rec_flag                         (* 39 *)
  | Name_out_of_scope of string * string list * bool   (* 40 *)
  | Ambiguous_name of string list * string list * bool (* 41 *)
  | Disambiguated_name of string            (* 42 *)
  | Nonoptional_label of string             (* 43 *)
  | Open_shadow_identifier of string * string (* 44 *)
  | Open_shadow_label_constructor of string * string (* 45 *)
  | Bad_env_variable of string * string     (* 46 *)
  | Attribute_payload of string * string    (* 47 *)
  | Eliminated_optional_arguments of string list (* 48 *)
  | No_cmi_file of string                   (* 49 *)
  | Bad_docstring of bool                   (* 50 *)
;;

val parse_options : bool -> string -> unit;;

val is_active : t -> bool;;
val is_error : t -> bool;;

val defaults_w : string;;
val defaults_warn_error : string;;

val print : formatter -> t -> unit;;

exception Errors of int;;

val check_fatal : unit -> unit;;

val help_warnings: unit -> unit

type state
val backup: unit -> state
val restore: state -> unit

end = struct
#1 "warnings.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Pierre Weis && Damien Doligez, INRIA Rocquencourt        *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* When you change this, you need to update the documentation:
   - man/ocamlc.m   in ocaml
   - man/ocamlopt.m in ocaml
   - manual/cmds/comp.etex   in the doc sources
   - manual/cmds/native.etex in the doc sources
*)

type t =
  | Comment_start                           (*  1 *)
  | Comment_not_end                         (*  2 *)
  | Deprecated of string                    (*  3 *)
  | Fragile_match of string                 (*  4 *)
  | Partial_application                     (*  5 *)
  | Labels_omitted                          (*  6 *)
  | Method_override of string list          (*  7 *)
  | Partial_match of string                 (*  8 *)
  | Non_closed_record_pattern of string     (*  9 *)
  | Statement_type                          (* 10 *)
  | Unused_match                            (* 11 *)
  | Unused_pat                              (* 12 *)
  | Instance_variable_override of string list (* 13 *)
  | Illegal_backslash                       (* 14 *)
  | Implicit_public_methods of string list  (* 15 *)
  | Unerasable_optional_argument            (* 16 *)
  | Undeclared_virtual_method of string     (* 17 *)
  | Not_principal of string                 (* 18 *)
  | Without_principality of string          (* 19 *)
  | Unused_argument                         (* 20 *)
  | Nonreturning_statement                  (* 21 *)
  | Preprocessor of string                  (* 22 *)
  | Useless_record_with                     (* 23 *)
  | Bad_module_name of string               (* 24 *)
  | All_clauses_guarded                     (* 25 *)
  | Unused_var of string                    (* 26 *)
  | Unused_var_strict of string             (* 27 *)
  | Wildcard_arg_to_constant_constr         (* 28 *)
  | Eol_in_string                           (* 29 *)
  | Duplicate_definitions of string * string * string * string (*30 *)
  | Multiple_definition of string * string * string (* 31 *)
  | Unused_value_declaration of string      (* 32 *)
  | Unused_open of string                   (* 33 *)
  | Unused_type_declaration of string       (* 34 *)
  | Unused_for_index of string              (* 35 *)
  | Unused_ancestor of string               (* 36 *)
  | Unused_constructor of string * bool * bool  (* 37 *)
  | Unused_extension of string * bool * bool    (* 38 *)
  | Unused_rec_flag                         (* 39 *)
  | Name_out_of_scope of string * string list * bool (* 40 *)
  | Ambiguous_name of string list * string list *  bool    (* 41 *)
  | Disambiguated_name of string            (* 42 *)
  | Nonoptional_label of string             (* 43 *)
  | Open_shadow_identifier of string * string (* 44 *)
  | Open_shadow_label_constructor of string * string (* 45 *)
  | Bad_env_variable of string * string     (* 46 *)
  | Attribute_payload of string * string    (* 47 *)
  | Eliminated_optional_arguments of string list (* 48 *)
  | No_cmi_file of string                   (* 49 *)
  | Bad_docstring of bool                   (* 50 *)
;;

(* If you remove a warning, leave a hole in the numbering.  NEVER change
   the numbers of existing warnings.
   If you add a new warning, add it at the end with a new number;
   do NOT reuse one of the holes.
*)

let number = function
  | Comment_start -> 1
  | Comment_not_end -> 2
  | Deprecated _ -> 3
  | Fragile_match _ -> 4
  | Partial_application -> 5
  | Labels_omitted -> 6
  | Method_override _ -> 7
  | Partial_match _ -> 8
  | Non_closed_record_pattern _ -> 9
  | Statement_type -> 10
  | Unused_match -> 11
  | Unused_pat -> 12
  | Instance_variable_override _ -> 13
  | Illegal_backslash -> 14
  | Implicit_public_methods _ -> 15
  | Unerasable_optional_argument -> 16
  | Undeclared_virtual_method _ -> 17
  | Not_principal _ -> 18
  | Without_principality _ -> 19
  | Unused_argument -> 20
  | Nonreturning_statement -> 21
  | Preprocessor _ -> 22
  | Useless_record_with -> 23
  | Bad_module_name _ -> 24
  | All_clauses_guarded -> 25
  | Unused_var _ -> 26
  | Unused_var_strict _ -> 27
  | Wildcard_arg_to_constant_constr -> 28
  | Eol_in_string -> 29
  | Duplicate_definitions _ -> 30
  | Multiple_definition _ -> 31
  | Unused_value_declaration _ -> 32
  | Unused_open _ -> 33
  | Unused_type_declaration _ -> 34
  | Unused_for_index _ -> 35
  | Unused_ancestor _ -> 36
  | Unused_constructor _ -> 37
  | Unused_extension _ -> 38
  | Unused_rec_flag -> 39
  | Name_out_of_scope _ -> 40
  | Ambiguous_name _ -> 41
  | Disambiguated_name _ -> 42
  | Nonoptional_label _ -> 43
  | Open_shadow_identifier _ -> 44
  | Open_shadow_label_constructor _ -> 45
  | Bad_env_variable _ -> 46
  | Attribute_payload _ -> 47
  | Eliminated_optional_arguments _ -> 48
  | No_cmi_file _ -> 49
  | Bad_docstring _ -> 50
;;

let last_warning_number = 50
(* Must be the max number returned by the [number] function. *)

let letter = function
  | 'a' ->
     let rec loop i = if i = 0 then [] else i :: loop (i - 1) in
     loop last_warning_number
  | 'b' -> []
  | 'c' -> [1; 2]
  | 'd' -> [3]
  | 'e' -> [4]
  | 'f' -> [5]
  | 'g' -> []
  | 'h' -> []
  | 'i' -> []
  | 'j' -> []
  | 'k' -> [32; 33; 34; 35; 36; 37; 38; 39]
  | 'l' -> [6]
  | 'm' -> [7]
  | 'n' -> []
  | 'o' -> []
  | 'p' -> [8]
  | 'q' -> []
  | 'r' -> [9]
  | 's' -> [10]
  | 't' -> []
  | 'u' -> [11; 12]
  | 'v' -> [13]
  | 'w' -> []
  | 'x' -> [14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 30]
  | 'y' -> [26]
  | 'z' -> [27]
  | _ -> assert false
;;

type state =
  {
    active: bool array;
    error: bool array;
  }

let current =
  ref
    {
      active = Array.make (last_warning_number + 1) true;
      error = Array.make (last_warning_number + 1) false;
    }

let backup () = !current

let restore x = current := x

let is_active x = (!current).active.(number x);;
let is_error x = (!current).error.(number x);;

let parse_opt error active flags s =
  let set i = flags.(i) <- true in
  let clear i = flags.(i) <- false in
  let set_all i = active.(i) <- true; error.(i) <- true in
  let error () = raise (Arg.Bad "Ill-formed list of warnings") in
  let rec get_num n i =
    if i >= String.length s then i, n
    else match s.[i] with
    | '0'..'9' -> get_num (10 * n + Char.code s.[i] - Char.code '0') (i + 1)
    | _ -> i, n
  in
  let get_range i =
    let i, n1 = get_num 0 i in
    if i + 2 < String.length s && s.[i] = '.' && s.[i + 1] = '.' then
      let i, n2 = get_num 0 (i + 2) in
      if n2 < n1 then error ();
      i, n1, n2
    else
      i, n1, n1
  in
  let rec loop i =
    if i >= String.length s then () else
    match s.[i] with
    | 'A' .. 'Z' ->
       List.iter set (letter (Char.lowercase s.[i]));
       loop (i+1)
    | 'a' .. 'z' ->
       List.iter clear (letter s.[i]);
       loop (i+1)
    | '+' -> loop_letter_num set (i+1)
    | '-' -> loop_letter_num clear (i+1)
    | '@' -> loop_letter_num set_all (i+1)
    | c -> error ()
  and loop_letter_num myset i =
    if i >= String.length s then error () else
    match s.[i] with
    | '0' .. '9' ->
        let i, n1, n2 = get_range i in
        for n = n1 to min n2 last_warning_number do myset n done;
        loop i
    | 'A' .. 'Z' ->
       List.iter myset (letter (Char.lowercase s.[i]));
       loop (i+1)
    | 'a' .. 'z' ->
       List.iter myset (letter s.[i]);
       loop (i+1)
    | _ -> error ()
  in
  loop 0
;;

let parse_options errflag s =
  let error = Array.copy (!current).error in
  let active = Array.copy (!current).active in
  parse_opt error active (if errflag then error else active) s;
  current := {error; active}

(* If you change these, don't forget to change them in man/ocamlc.m *)
let defaults_w = "+a-4-6-7-9-27-29-32..39-41..42-44-45-48-50";;
let defaults_warn_error = "-a";;

let () = parse_options false defaults_w;;
let () = parse_options true defaults_warn_error;;

let message = function
  | Comment_start -> "this is the start of a comment."
  | Comment_not_end -> "this is not the end of a comment."
  | Deprecated s -> "deprecated: " ^ s
  | Fragile_match "" ->
      "this pattern-matching is fragile."
  | Fragile_match s ->
      "this pattern-matching is fragile.\n\
       It will remain exhaustive when constructors are added to type " ^ s ^ "."
  | Partial_application ->
      "this function application is partial,\n\
       maybe some arguments are missing."
  | Labels_omitted ->
      "labels were omitted in the application of this function."
  | Method_override [lab] ->
      "the method " ^ lab ^ " is overridden."
  | Method_override (cname :: slist) ->
      String.concat " "
        ("the following methods are overridden by the class"
         :: cname  :: ":\n " :: slist)
  | Method_override [] -> assert false
  | Partial_match "" -> "this pattern-matching is not exhaustive."
  | Partial_match s ->
      "this pattern-matching is not exhaustive.\n\
       Here is an example of a value that is not matched:\n" ^ s
  | Non_closed_record_pattern s ->
      "the following labels are not bound in this record pattern:\n" ^ s ^
      "\nEither bind these labels explicitly or add '; _' to the pattern."
  | Statement_type ->
      "this expression should have type unit."
  | Unused_match -> "this match case is unused."
  | Unused_pat   -> "this sub-pattern is unused."
  | Instance_variable_override [lab] ->
      "the instance variable " ^ lab ^ " is overridden.\n" ^
      "The behaviour changed in ocaml 3.10 (previous behaviour was hiding.)"
  | Instance_variable_override (cname :: slist) ->
      String.concat " "
        ("the following instance variables are overridden by the class"
         :: cname  :: ":\n " :: slist) ^
      "\nThe behaviour changed in ocaml 3.10 (previous behaviour was hiding.)"
  | Instance_variable_override [] -> assert false
  | Illegal_backslash -> "illegal backslash escape in string."
  | Implicit_public_methods l ->
      "the following private methods were made public implicitly:\n "
      ^ String.concat " " l ^ "."
  | Unerasable_optional_argument -> "this optional argument cannot be erased."
  | Undeclared_virtual_method m -> "the virtual method "^m^" is not declared."
  | Not_principal s -> s^" is not principal."
  | Without_principality s -> s^" without principality."
  | Unused_argument -> "this argument will not be used by the function."
  | Nonreturning_statement ->
      "this statement never returns (or has an unsound type.)"
  | Preprocessor s -> s
  | Useless_record_with ->
      "all the fields are explicitly listed in this record:\n\
       the 'with' clause is useless."
  | Bad_module_name (modname) ->
      "bad source file name: \"" ^ modname ^ "\" is not a valid module name."
  | All_clauses_guarded ->
      "bad style, all clauses in this pattern-matching are guarded."
  | Unused_var v | Unused_var_strict v -> "unused variable " ^ v ^ "."
  | Wildcard_arg_to_constant_constr ->
     "wildcard pattern given as argument to a constant constructor"
  | Eol_in_string ->
     "unescaped end-of-line in a string constant (non-portable code)"
  | Duplicate_definitions (kind, cname, tc1, tc2) ->
      Printf.sprintf "the %s %s is defined in both types %s and %s."
        kind cname tc1 tc2
  | Multiple_definition(modname, file1, file2) ->
      Printf.sprintf
        "files %s and %s both define a module named %s"
        file1 file2 modname
  | Unused_value_declaration v -> "unused value " ^ v ^ "."
  | Unused_open s -> "unused open " ^ s ^ "."
  | Unused_type_declaration s -> "unused type " ^ s ^ "."
  | Unused_for_index s -> "unused for-loop index " ^ s ^ "."
  | Unused_ancestor s -> "unused ancestor variable " ^ s ^ "."
  | Unused_constructor (s, false, false) -> "unused constructor " ^ s ^ "."
  | Unused_constructor (s, true, _) ->
      "constructor " ^ s ^
      " is never used to build values.\n\
        (However, this constructor appears in patterns.)"
  | Unused_constructor (s, false, true) ->
      "constructor " ^ s ^
      " is never used to build values.\n\
        Its type is exported as a private type."
  | Unused_extension (s, false, false) ->
      "unused extension constructor " ^ s ^ "."
  | Unused_extension (s, true, _) ->
      "extension constructor " ^ s ^
      " is never used to build values.\n\
        (However, this constructor appears in patterns.)"
  | Unused_extension (s, false, true) ->
      "extension constructor " ^ s ^
      " is never used to build values.\n\
        It is exported or rebound as a private extension."
  | Unused_rec_flag ->
      "unused rec flag."
  | Name_out_of_scope (ty, [nm], false) ->
      nm ^ " was selected from type " ^ ty ^
      ".\nIt is not visible in the current scope, and will not \n\
       be selected if the type becomes unknown."
  | Name_out_of_scope (_, _, false) -> assert false
  | Name_out_of_scope (ty, slist, true) ->
      "this record of type "^ ty ^" contains fields that are \n\
       not visible in the current scope: "
      ^ String.concat " " slist ^ ".\n\
       They will not be selected if the type becomes unknown."
  | Ambiguous_name ([s], tl, false) ->
      s ^ " belongs to several types: " ^ String.concat " " tl ^
      "\nThe first one was selected. Please disambiguate if this is wrong."
  | Ambiguous_name (_, _, false) -> assert false
  | Ambiguous_name (slist, tl, true) ->
      "these field labels belong to several types: " ^
      String.concat " " tl ^
      "\nThe first one was selected. Please disambiguate if this is wrong."
  | Disambiguated_name s ->
      "this use of " ^ s ^ " required disambiguation."
  | Nonoptional_label s ->
      "the label " ^ s ^ " is not optional."
  | Open_shadow_identifier (kind, s) ->
      Printf.sprintf
        "this open statement shadows the %s identifier %s (which is later used)"
        kind s
  | Open_shadow_label_constructor (kind, s) ->
      Printf.sprintf
        "this open statement shadows the %s %s (which is later used)"
        kind s
  | Bad_env_variable (var, s) ->
      Printf.sprintf "illegal environment variable %s : %s" var s
  | Attribute_payload (a, s) ->
      Printf.sprintf "illegal payload for attribute '%s'.\n%s" a s
  | Eliminated_optional_arguments sl ->
      Printf.sprintf "implicit elimination of optional argument%s %s"
        (if List.length sl = 1 then "" else "s")
        (String.concat ", " sl)
  | No_cmi_file s ->
      "no cmi file was found in path for module " ^ s
  | Bad_docstring unattached ->
      if unattached then "unattached documentation comment (ignored)"
      else "ambiguous documentation comment"
;;

let nerrors = ref 0;;

let print ppf w =
  let msg = message w in
  let num = number w in
  Format.fprintf ppf "%d: %s" num msg;
  Format.pp_print_flush ppf ();
  if (!current).error.(num) then incr nerrors
;;

exception Errors of int;;

let check_fatal () =
  if !nerrors > 0 then begin
    let e = Errors !nerrors in
    nerrors := 0;
    raise e;
  end;
;;

let descriptions =
  [
    1, "Suspicious-looking start-of-comment mark.";
    2, "Suspicious-looking end-of-comment mark.";
    3, "Deprecated feature.";
    4, "Fragile pattern matching: matching that will remain complete even\n\
   \    if additional constructors are added to one of the variant types\n\
   \    matched.";
    5, "Partially applied function: expression whose result has function\n\
   \    type and is ignored.";
    6, "Label omitted in function application.";
    7, "Method overridden.";
    8, "Partial match: missing cases in pattern-matching.";
    9, "Missing fields in a record pattern.";
   10, "Expression on the left-hand side of a sequence that doesn't have type\n\
   \    \"unit\" (and that is not a function, see warning number 5).";
   11, "Redundant case in a pattern matching (unused match case).";
   12, "Redundant sub-pattern in a pattern-matching.";
   13, "Instance variable overridden.";
   14, "Illegal backslash escape in a string constant.";
   15, "Private method made public implicitly.";
   16, "Unerasable optional argument.";
   17, "Undeclared virtual method.";
   18, "Non-principal type.";
   19, "Type without principality.";
   20, "Unused function argument.";
   21, "Non-returning statement.";
   22, "Proprocessor warning.";
   23, "Useless record \"with\" clause.";
   24, "Bad module name: the source file name is not a valid OCaml module \
        name.";
   25, "Pattern-matching with all clauses guarded.  Exhaustiveness cannot be\n\
   \    checked.";
   26, "Suspicious unused variable: unused variable that is bound\n\
   \    with \"let\" or \"as\", and doesn't start with an underscore (\"_\")\n\
   \    character.";
   27, "Innocuous unused variable: unused variable that is not bound with\n\
   \    \"let\" nor \"as\", and doesn't start with an underscore (\"_\")\n\
   \    character.";
   28, "Wildcard pattern given as argument to a constant constructor.";
   29, "Unescaped end-of-line in a string constant (non-portable code).";
   30, "Two labels or constructors of the same name are defined in two\n\
   \    mutually recursive types.";
   31, "A module is linked twice in the same executable.";
   32, "Unused value declaration.";
   33, "Unused open statement.";
   34, "Unused type declaration.";
   35, "Unused for-loop index.";
   36, "Unused ancestor variable.";
   37, "Unused constructor.";
   38, "Unused extension constructor.";
   39, "Unused rec flag.";
   40, "Constructor or label name used out of scope.";
   41, "Ambiguous constructor or label name.";
   42, "Disambiguated constructor or label name.";
   43, "Nonoptional label applied as optional.";
   44, "Open statement shadows an already defined identifier.";
   45, "Open statement shadows an already defined label or constructor.";
   46, "Error in environment variable.";
   47, "Illegal attribute payload.";
   48, "Implicit elimination of optional arguments.";
   49, "Missing cmi file when looking up module alias.";
   50, "Unexpected documentation comment.";
  ]
;;

let help_warnings () =
  List.iter (fun (i, s) -> Printf.printf "%3i %s\n" i s) descriptions;
  print_endline "  A all warnings";
  for i = Char.code 'b' to Char.code 'z' do
    let c = Char.chr i in
    match letter c with
    | [] -> ()
    | [n] ->
        Printf.printf "  %c warning %i\n" (Char.uppercase c) n
    | l ->
        Printf.printf "  %c warnings %s.\n"
          (Char.uppercase c)
          (String.concat ", " (List.map string_of_int l))
  done;
  exit 0
;;

end
module Location : sig 
#1 "location.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Source code locations (ranges of positions), used in parsetree. *)

open Format

type t = {
  loc_start: Lexing.position;
  loc_end: Lexing.position;
  loc_ghost: bool;
}

(* Note on the use of Lexing.position in this module.
   If [pos_fname = ""], then use [!input_name] instead.
   If [pos_lnum = -1], then [pos_bol = 0]. Use [pos_cnum] and
     re-parse the file to get the line and character numbers.
   Else all fields are correct.
*)

val none : t
(** An arbitrary value of type [t]; describes an empty ghost range. *)

val in_file : string -> t
(** Return an empty ghost range located in a given file. *)

val init : Lexing.lexbuf -> string -> unit
(** Set the file name and line number of the [lexbuf] to be the start
    of the named file. *)

val curr : Lexing.lexbuf -> t
(** Get the location of the current token from the [lexbuf]. *)

val symbol_rloc: unit -> t
val symbol_gloc: unit -> t

(** [rhs_loc n] returns the location of the symbol at position [n], starting
  at 1, in the current parser rule. *)
val rhs_loc: int -> t

val input_name: string ref
val input_lexbuf: Lexing.lexbuf option ref

val get_pos_info: Lexing.position -> string * int * int (* file, line, char *)
val print_loc: formatter -> t -> unit
val print_error: formatter -> t -> unit
val print_error_cur_file: formatter -> unit -> unit
val print_warning: t -> formatter -> Warnings.t -> unit
val formatter_for_warnings : formatter ref
val prerr_warning: t -> Warnings.t -> unit
val echo_eof: unit -> unit
val reset: unit -> unit

val warning_printer : (t -> formatter -> Warnings.t -> unit) ref
(** Hook for intercepting warnings. *)

val default_warning_printer : t -> formatter -> Warnings.t -> unit
(** Original warning printer for use in hooks. *)

val highlight_locations: formatter -> t list -> bool

type 'a loc = {
  txt : 'a;
  loc : t;
}

val mknoloc : 'a -> 'a loc
val mkloc : 'a -> t -> 'a loc

val print: formatter -> t -> unit
val print_filename: formatter -> string -> unit

val absolute_path: string -> string

val show_filename: string -> string
    (** In -absname mode, return the absolute path for this filename.
        Otherwise, returns the filename unchanged. *)


val absname: bool ref

(* Support for located errors *)

type error =
  {
    loc: t;
    msg: string;
    sub: error list;
    if_highlight: string; (* alternative message if locations are highlighted *)
  }

exception Error of error

val print_error_prefix: formatter -> unit -> unit
  (* print the prefix "Error:" possibly with style *)

val error: ?loc:t -> ?sub:error list -> ?if_highlight:string -> string -> error

 
val pp_ksprintf : ?before:(formatter -> unit) -> (string -> 'a) -> ('b, formatter, unit, 'a) format4 -> 'b


val errorf: ?loc:t -> ?sub:error list -> ?if_highlight:string
            -> ('a, Format.formatter, unit, error) format4 -> 'a

val raise_errorf: ?loc:t -> ?sub:error list -> ?if_highlight:string
            -> ('a, Format.formatter, unit, 'b) format4 -> 'a

val error_of_printer: t -> (formatter -> 'a -> unit) -> 'a -> error

val error_of_printer_file: (formatter -> 'a -> unit) -> 'a -> error

val error_of_exn: exn -> error option

val register_error_of_exn: (exn -> error option) -> unit
  (* Each compiler module which defines a custom type of exception
     which can surface as a user-visible error should register
     a "printer" for this exception using [register_error_of_exn].
     The result of the printer is an [error] value containing
     a location, a message, and optionally sub-messages (each of them
     being located as well). *)

val report_error: formatter -> error -> unit

val error_reporter : (formatter -> error -> unit) ref
(** Hook for intercepting error reports. *)

val default_error_reporter : formatter -> error -> unit
(** Original error reporter for use in hooks. *)

val report_exception: formatter -> exn -> unit
  (* Reraise the exception if it is unknown. *)

end = struct
#1 "location.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Lexing

let absname = ref false
    (* This reference should be in Clflags, but it would create an additional
       dependency and make bootstrapping Camlp4 more difficult. *)

type t = { loc_start: position; loc_end: position; loc_ghost: bool };;

let in_file name =
  let loc = {
    pos_fname = name;
    pos_lnum = 1;
    pos_bol = 0;
    pos_cnum = -1;
  } in
  { loc_start = loc; loc_end = loc; loc_ghost = true }
;;

let none = in_file "_none_";;

let curr lexbuf = {
  loc_start = lexbuf.lex_start_p;
  loc_end = lexbuf.lex_curr_p;
  loc_ghost = false
};;

let init lexbuf fname =
  lexbuf.lex_curr_p <- {
    pos_fname = fname;
    pos_lnum = 1;
    pos_bol = 0;
    pos_cnum = 0;
  }
;;

let symbol_rloc () = {
  loc_start = Parsing.symbol_start_pos ();
  loc_end = Parsing.symbol_end_pos ();
  loc_ghost = false;
};;

let symbol_gloc () = {
  loc_start = Parsing.symbol_start_pos ();
  loc_end = Parsing.symbol_end_pos ();
  loc_ghost = true;
};;

let rhs_loc n = {
  loc_start = Parsing.rhs_start_pos n;
  loc_end = Parsing.rhs_end_pos n;
  loc_ghost = false;
};;

let input_name = ref "_none_"
let input_lexbuf = ref (None : lexbuf option)

(* Terminal info *)

let status = ref Terminfo.Uninitialised

let num_loc_lines = ref 0 (* number of lines already printed after input *)

let print_updating_num_loc_lines ppf f arg =
  let open Format in
  let out_functions = pp_get_formatter_out_functions ppf () in
  let out_string str start len =
    let rec count i c =
      if i = start + len then c
      else if String.get str i = '\n' then count (succ i) (succ c)
      else count (succ i) c in
    num_loc_lines := !num_loc_lines + count start 0 ;
    out_functions.out_string str start len in
  pp_set_formatter_out_functions ppf
    { out_functions with out_string } ;
  f ppf arg ;
  pp_print_flush ppf ();
  pp_set_formatter_out_functions ppf out_functions

(* Highlight the locations using standout mode. *)

let highlight_terminfo ppf num_lines lb locs =
  Format.pp_print_flush ppf ();  (* avoid mixing Format and normal output *)
  (* Char 0 is at offset -lb.lex_abs_pos in lb.lex_buffer. *)
  let pos0 = -lb.lex_abs_pos in
  (* Do nothing if the buffer does not contain the whole phrase. *)
  if pos0 < 0 then raise Exit;
  (* Count number of lines in phrase *)
  let lines = ref !num_loc_lines in
  for i = pos0 to lb.lex_buffer_len - 1 do
    if Bytes.get lb.lex_buffer i = '\n' then incr lines
  done;
  (* If too many lines, give up *)
  if !lines >= num_lines - 2 then raise Exit;
  (* Move cursor up that number of lines *)
  flush stdout; Terminfo.backup !lines;
  (* Print the input, switching to standout for the location *)
  let bol = ref false in
  print_string "# ";
  for pos = 0 to lb.lex_buffer_len - pos0 - 1 do
    if !bol then (print_string "  "; bol := false);
    if List.exists (fun loc -> pos = loc.loc_start.pos_cnum) locs then
      Terminfo.standout true;
    if List.exists (fun loc -> pos = loc.loc_end.pos_cnum) locs then
      Terminfo.standout false;
    let c = Bytes.get lb.lex_buffer (pos + pos0) in
    print_char c;
    bol := (c = '\n')
  done;
  (* Make sure standout mode is over *)
  Terminfo.standout false;
  (* Position cursor back to original location *)
  Terminfo.resume !num_loc_lines;
  flush stdout

(* Highlight the location by printing it again. *)

let highlight_dumb ppf lb loc =
  (* Char 0 is at offset -lb.lex_abs_pos in lb.lex_buffer. *)
  let pos0 = -lb.lex_abs_pos in
  (* Do nothing if the buffer does not contain the whole phrase. *)
  if pos0 < 0 then raise Exit;
  let end_pos = lb.lex_buffer_len - pos0 - 1 in
  (* Determine line numbers for the start and end points *)
  let line_start = ref 0 and line_end = ref 0 in
  for pos = 0 to end_pos do
    if Bytes.get lb.lex_buffer (pos + pos0) = '\n' then begin
      if loc.loc_start.pos_cnum > pos then incr line_start;
      if loc.loc_end.pos_cnum   > pos then incr line_end;
    end
  done;
  (* Print character location (useful for Emacs) *)
  Format.fprintf ppf "Characters %i-%i:@."
                 loc.loc_start.pos_cnum loc.loc_end.pos_cnum;
  (* Print the input, underlining the location *)
  Format.pp_print_string ppf "  ";
  let line = ref 0 in
  let pos_at_bol = ref 0 in
  for pos = 0 to end_pos do
    match Bytes.get lb.lex_buffer (pos + pos0) with
    | '\n' ->
      if !line = !line_start && !line = !line_end then begin
        (* loc is on one line: underline location *)
        Format.fprintf ppf "@.  ";
        for _i = !pos_at_bol to loc.loc_start.pos_cnum - 1 do
          Format.pp_print_char ppf ' '
        done;
        for _i = loc.loc_start.pos_cnum to loc.loc_end.pos_cnum - 1 do
          Format.pp_print_char ppf '^'
        done
      end;
      if !line >= !line_start && !line <= !line_end then begin
        Format.fprintf ppf "@.";
        if pos < loc.loc_end.pos_cnum then Format.pp_print_string ppf "  "
      end;
      incr line;
      pos_at_bol := pos + 1
    | '\r' -> () (* discard *)
    | c ->
      if !line = !line_start && !line = !line_end then
        (* loc is on one line: print whole line *)
        Format.pp_print_char ppf c
      else if !line = !line_start then
        (* first line of multiline loc:
           print a dot for each char before loc_start *)
        if pos < loc.loc_start.pos_cnum then
          Format.pp_print_char ppf '.'
        else
          Format.pp_print_char ppf c
      else if !line = !line_end then
        (* last line of multiline loc: print a dot for each char
           after loc_end, even whitespaces *)
        if pos < loc.loc_end.pos_cnum then
          Format.pp_print_char ppf c
        else
          Format.pp_print_char ppf '.'
      else if !line > !line_start && !line < !line_end then
        (* intermediate line of multiline loc: print whole line *)
        Format.pp_print_char ppf c
  done

(* Highlight the location using one of the supported modes. *)

let rec highlight_locations ppf locs =
  match !status with
    Terminfo.Uninitialised ->
      status := Terminfo.setup stdout; highlight_locations ppf locs
  | Terminfo.Bad_term ->
      begin match !input_lexbuf with
        None -> false
      | Some lb ->
          let norepeat =
            try Sys.getenv "TERM" = "norepeat" with Not_found -> false in
          if norepeat then false else
            let loc1 = List.hd locs in
            try highlight_dumb ppf lb loc1; true
            with Exit -> false
      end
  | Terminfo.Good_term num_lines ->
      begin match !input_lexbuf with
        None -> false
      | Some lb ->
          try highlight_terminfo ppf num_lines lb locs; true
          with Exit -> false
      end

(* Print the location in some way or another *)

open Format

let absolute_path s = (* This function could go into Filename *)
  let open Filename in
  let s = if is_relative s then concat (Sys.getcwd ()) s else s in
  (* Now simplify . and .. components *)
  let rec aux s =
    let base = basename s in
    let dir = dirname s in
    if dir = s then dir
    else if base = current_dir_name then aux dir
    else if base = parent_dir_name then dirname (aux dir)
    else concat (aux dir) base
  in
  aux s

let show_filename file =
  if !absname then absolute_path file else file

let print_filename ppf file =
  Format.fprintf ppf "%s" (show_filename file)

let reset () =
  num_loc_lines := 0

let (msg_file, msg_line, msg_chars, msg_to, msg_colon) =
  ("File \"", "\", line ", ", characters ", "-", ":")

(* return file, line, char from the given position *)
let get_pos_info pos =
  (pos.pos_fname, pos.pos_lnum, pos.pos_cnum - pos.pos_bol)
;;

let setup_colors () =
  Misc.Color.setup !Clflags.color

let print_loc ppf loc =
  setup_colors ();
  let (file, line, startchar) = get_pos_info loc.loc_start in
 
  let startchar = 
    if Clflags.bs_vscode then startchar + 1 else startchar in 
    
  let endchar = loc.loc_end.pos_cnum - loc.loc_start.pos_cnum + startchar in
  if file = "//toplevel//" then begin
    if highlight_locations ppf [loc] then () else
      fprintf ppf "Characters %i-%i"
              loc.loc_start.pos_cnum loc.loc_end.pos_cnum
  end else begin
    fprintf ppf "%s@{<loc>%a%s%i" msg_file print_filename file msg_line line;
    if startchar >= 0 then
      fprintf ppf "%s%i%s%i" msg_chars startchar msg_to endchar;
    fprintf ppf "@}"
  end
;;

let print ppf loc =
  setup_colors ();
  if loc.loc_start.pos_fname = "//toplevel//"
  && highlight_locations ppf [loc] then ()
  else fprintf ppf "@{<loc>%a@}%s@." print_loc loc msg_colon
;;

let error_prefix = "Error"
let warning_prefix = "Warning"

let print_error_prefix ppf () =
  setup_colors ();
  fprintf ppf "@{<error>%s@}:" error_prefix;
  ()
;;

let print_error ppf loc =
  print ppf loc;
  print_error_prefix ppf ()
;;

let print_error_cur_file ppf () = print_error ppf (in_file !input_name);;

let default_warning_printer loc ppf w =
  if Warnings.is_active w then begin
    setup_colors ();
    print ppf loc;
    fprintf ppf "@{<warning>%s@} %a@." warning_prefix Warnings.print w
  end
;;

let warning_printer = ref default_warning_printer ;;

let print_warning loc ppf w =
  print_updating_num_loc_lines ppf (!warning_printer loc) w
;;

let formatter_for_warnings = ref err_formatter;;
let prerr_warning loc w = print_warning loc !formatter_for_warnings w;;

let echo_eof () =
  print_newline ();
  incr num_loc_lines

type 'a loc = {
  txt : 'a;
  loc : t;
}

let mkloc txt loc = { txt ; loc }
let mknoloc txt = mkloc txt none


type error =
  {
    loc: t;
    msg: string;
    sub: error list;
    if_highlight: string; (* alternative message if locations are highlighted *)
  }

let pp_ksprintf ?before k fmt =
  let buf = Buffer.create 64 in
  let ppf = Format.formatter_of_buffer buf in
  Misc.Color.set_color_tag_handling ppf;
  begin match before with
    | None -> ()
    | Some f -> f ppf
  end;
  kfprintf
    (fun _ ->
      pp_print_flush ppf ();
      let msg = Buffer.contents buf in
      k msg)
    ppf fmt

(* Shift the formatter's offset by the length of the error prefix, which
   is always added by the compiler after the message has been formatted *)
let print_phanton_error_prefix ppf =
  Format.pp_print_as ppf (String.length error_prefix + 2 (* ": " *)) ""

let errorf ?(loc = none) ?(sub = []) ?(if_highlight = "") fmt =
  pp_ksprintf
    ~before:print_phanton_error_prefix
    (fun msg -> {loc; msg; sub; if_highlight})
    fmt

let error ?(loc = none) ?(sub = []) ?(if_highlight = "") msg =
  {loc; msg; sub; if_highlight}

let error_of_exn : (exn -> error option) list ref = ref []

let register_error_of_exn f = error_of_exn := f :: !error_of_exn

let error_of_exn exn =
  let rec loop = function
    | [] -> None
    | f :: rest ->
        match f exn with
        | Some _ as r -> r
        | None -> loop rest
  in
  loop !error_of_exn

let rec default_error_reporter ppf ({loc; msg; sub; if_highlight} as err) =
  let highlighted =
    if if_highlight <> "" then
      let rec collect_locs locs {loc; sub; if_highlight; _} =
        List.fold_left collect_locs (loc :: locs) sub
      in
      let locs = collect_locs [] err in
      highlight_locations ppf locs
    else
      false
  in
  if highlighted then
    Format.pp_print_string ppf if_highlight
  else begin
    fprintf ppf "%a%a %s" print loc print_error_prefix () msg;
    List.iter (Format.fprintf ppf "@\n@[<2>%a@]" default_error_reporter) sub
  end

let error_reporter = ref default_error_reporter

let report_error ppf err =
  print_updating_num_loc_lines ppf !error_reporter err
;;

let error_of_printer loc print x =
  errorf ~loc "%a@?" print x

let error_of_printer_file print x =
  error_of_printer (in_file !input_name) print x

let () =
  register_error_of_exn
    (function
      | Sys_error msg ->
          Some (errorf ~loc:(in_file !input_name)
                "I/O error: %s" msg)
      | Warnings.Errors n ->
          Some
            (errorf ~loc:(in_file !input_name)
             "Some fatal warnings were triggered (%d occurrences)" n)
      | _ ->
          None
    )


let rec report_exception_rec n ppf exn =
  try match error_of_exn exn with
  | Some err ->
      fprintf ppf "@[%a@]@." report_error err
  | None -> raise exn
  with exn when n > 0 ->
    report_exception_rec (n-1) ppf exn

let report_exception ppf exn = report_exception_rec 5 ppf exn


exception Error of error

let () =
  register_error_of_exn
    (function
      | Error e -> Some e
      | _ -> None
    )

let raise_errorf ?(loc = none) ?(sub = []) ?(if_highlight = "") =
  pp_ksprintf
    ~before:print_phanton_error_prefix
    (fun msg -> raise (Error ({loc; msg; sub; if_highlight})))

end
(** Interface as module  *)
module Asttypes
= struct
#1 "asttypes.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Auxiliary a.s.t. types used by parsetree and typedtree. *)

type constant =
    Const_int of int
  | Const_char of char
  | Const_string of string * string option
  | Const_float of string
  | Const_int32 of int32
  | Const_int64 of int64
  | Const_nativeint of nativeint

type rec_flag = Nonrecursive | Recursive

type direction_flag = Upto | Downto

type private_flag = Private | Public

type mutable_flag = Immutable | Mutable

type virtual_flag = Virtual | Concrete

type override_flag = Override | Fresh

type closed_flag = Closed | Open

type label = string

type 'a loc = 'a Location.loc = {
  txt : 'a;
  loc : Location.t;
}


type variance =
  | Covariant
  | Contravariant
  | Invariant

end
module Longident : sig 
#1 "longident.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Long identifiers, used in parsetree. *)

type t =
    Lident of string
  | Ldot of t * string
  | Lapply of t * t

val flatten: t -> string list
val last: t -> string
val parse: string -> t

end = struct
#1 "longident.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

type t =
    Lident of string
  | Ldot of t * string
  | Lapply of t * t

let rec flat accu = function
    Lident s -> s :: accu
  | Ldot(lid, s) -> flat (s :: accu) lid
  | Lapply(_, _) -> Misc.fatal_error "Longident.flat"

let flatten lid = flat [] lid

let last = function
    Lident s -> s
  | Ldot(_, s) -> s
  | Lapply(_, _) -> Misc.fatal_error "Longident.last"

let rec split_at_dots s pos =
  try
    let dot = String.index_from s pos '.' in
    String.sub s pos (dot - pos) :: split_at_dots s (dot + 1)
  with Not_found ->
    [String.sub s pos (String.length s - pos)]

let parse s =
  match split_at_dots s 0 with
    [] -> Lident ""  (* should not happen, but don't put assert false
                        so as not to crash the toplevel (see Genprintval) *)
  | hd :: tl -> List.fold_left (fun p s -> Ldot(p, s)) (Lident hd) tl

end
(** Interface as module  *)
module Parsetree
= struct
#1 "parsetree.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(** Abstract syntax tree produced by parsing *)

open Asttypes

(** {2 Extension points} *)

type attribute = string loc * payload
       (* [@id ARG]
          [@@id ARG]

          Metadata containers passed around within the AST.
          The compiler ignores unknown attributes.
       *)

and extension = string loc * payload
      (* [%id ARG]
         [%%id ARG]

         Sub-language placeholder -- rejected by the typechecker.
      *)

and attributes = attribute list

and payload =
  | PStr of structure
  | PTyp of core_type  (* : T *)
  | PPat of pattern * expression option  (* ? P  or  ? P when E *)

(** {2 Core language} *)

(* Type expressions *)

and core_type =
    {
     ptyp_desc: core_type_desc;
     ptyp_loc: Location.t;
     ptyp_attributes: attributes; (* ... [@id1] [@id2] *)
    }

and core_type_desc =
  | Ptyp_any
        (*  _ *)
  | Ptyp_var of string
        (* 'a *)
  | Ptyp_arrow of label * core_type * core_type
        (* T1 -> T2       (label = "")
           ~l:T1 -> T2    (label = "l")
           ?l:T1 -> T2    (label = "?l")
         *)
  | Ptyp_tuple of core_type list
        (* T1 * ... * Tn

           Invariant: n >= 2
        *)
  | Ptyp_constr of Longident.t loc * core_type list
        (* tconstr
           T tconstr
           (T1, ..., Tn) tconstr
         *)
  | Ptyp_object of (string * attributes * core_type) list * closed_flag
        (* < l1:T1; ...; ln:Tn >     (flag = Closed)
           < l1:T1; ...; ln:Tn; .. > (flag = Open)
         *)
  | Ptyp_class of Longident.t loc * core_type list
        (* #tconstr
           T #tconstr
           (T1, ..., Tn) #tconstr
         *)
  | Ptyp_alias of core_type * string
        (* T as 'a *)
  | Ptyp_variant of row_field list * closed_flag * label list option
        (* [ `A|`B ]         (flag = Closed; labels = None)
           [> `A|`B ]        (flag = Open;   labels = None)
           [< `A|`B ]        (flag = Closed; labels = Some [])
           [< `A|`B > `X `Y ](flag = Closed; labels = Some ["X";"Y"])
         *)
  | Ptyp_poly of string list * core_type
        (* 'a1 ... 'an. T

           Can only appear in the following context:

           - As the core_type of a Ppat_constraint node corresponding
             to a constraint on a let-binding: let x : 'a1 ... 'an. T
             = e ...

           - Under Cfk_virtual for methods (not values).

           - As the core_type of a Pctf_method node.

           - As the core_type of a Pexp_poly node.

           - As the pld_type field of a label_declaration.

           - As a core_type of a Ptyp_object node.
         *)

  | Ptyp_package of package_type
        (* (module S) *)
  | Ptyp_extension of extension
        (* [%id] *)

and package_type = Longident.t loc * (Longident.t loc * core_type) list
      (*
        (module S)
        (module S with type t1 = T1 and ... and tn = Tn)
       *)

and row_field =
  | Rtag of label * attributes * bool * core_type list
        (* [`A]                   ( true,  [] )
           [`A of T]              ( false, [T] )
           [`A of T1 & .. & Tn]   ( false, [T1;...Tn] )
           [`A of & T1 & .. & Tn] ( true,  [T1;...Tn] )

          - The 2nd field is true if the tag contains a
            constant (empty) constructor.
          - '&' occurs when several types are used for the same constructor
            (see 4.2 in the manual)

          - TODO: switch to a record representation, and keep location
        *)
  | Rinherit of core_type
        (* [ T ] *)

(* Patterns *)

and pattern =
    {
     ppat_desc: pattern_desc;
     ppat_loc: Location.t;
     ppat_attributes: attributes; (* ... [@id1] [@id2] *)
    }

and pattern_desc =
  | Ppat_any
        (* _ *)
  | Ppat_var of string loc
        (* x *)
  | Ppat_alias of pattern * string loc
        (* P as 'a *)
  | Ppat_constant of constant
        (* 1, 'a', "true", 1.0, 1l, 1L, 1n *)
  | Ppat_interval of constant * constant
        (* 'a'..'z'

           Other forms of interval are recognized by the parser
           but rejected by the type-checker. *)
  | Ppat_tuple of pattern list
        (* (P1, ..., Pn)

           Invariant: n >= 2
        *)
  | Ppat_construct of Longident.t loc * pattern option
        (* C                None
           C P              Some P
           C (P1, ..., Pn)  Some (Ppat_tuple [P1; ...; Pn])
         *)
  | Ppat_variant of label * pattern option
        (* `A             (None)
           `A P           (Some P)
         *)
  | Ppat_record of (Longident.t loc * pattern) list * closed_flag
        (* { l1=P1; ...; ln=Pn }     (flag = Closed)
           { l1=P1; ...; ln=Pn; _}   (flag = Open)

           Invariant: n > 0
         *)
  | Ppat_array of pattern list
        (* [| P1; ...; Pn |] *)
  | Ppat_or of pattern * pattern
        (* P1 | P2 *)
  | Ppat_constraint of pattern * core_type
        (* (P : T) *)
  | Ppat_type of Longident.t loc
        (* #tconst *)
  | Ppat_lazy of pattern
        (* lazy P *)
  | Ppat_unpack of string loc
        (* (module P)
           Note: (module P : S) is represented as
           Ppat_constraint(Ppat_unpack, Ptyp_package)
         *)
  | Ppat_exception of pattern
        (* exception P *)
  | Ppat_extension of extension
        (* [%id] *)

(* Value expressions *)

and expression =
    {
     pexp_desc: expression_desc;
     pexp_loc: Location.t;
     pexp_attributes: attributes; (* ... [@id1] [@id2] *)
    }

and expression_desc =
  | Pexp_ident of Longident.t loc
        (* x
           M.x
         *)
  | Pexp_constant of constant
        (* 1, 'a', "true", 1.0, 1l, 1L, 1n *)
  | Pexp_let of rec_flag * value_binding list * expression
        (* let P1 = E1 and ... and Pn = EN in E       (flag = Nonrecursive)
           let rec P1 = E1 and ... and Pn = EN in E   (flag = Recursive)
         *)
  | Pexp_function of case list
        (* function P1 -> E1 | ... | Pn -> En *)
  | Pexp_fun of label * expression option * pattern * expression
        (* fun P -> E1                          (lab = "", None)
           fun ~l:P -> E1                       (lab = "l", None)
           fun ?l:P -> E1                       (lab = "?l", None)
           fun ?l:(P = E0) -> E1                (lab = "?l", Some E0)

           Notes:
           - If E0 is provided, lab must start with '?'.
           - "fun P1 P2 .. Pn -> E1" is represented as nested Pexp_fun.
           - "let f P = E" is represented using Pexp_fun.
         *)
  | Pexp_apply of expression * (label * expression) list
        (* E0 ~l1:E1 ... ~ln:En
           li can be empty (non labeled argument) or start with '?'
           (optional argument).

           Invariant: n > 0
         *)
  | Pexp_match of expression * case list
        (* match E0 with P1 -> E1 | ... | Pn -> En *)
  | Pexp_try of expression * case list
        (* try E0 with P1 -> E1 | ... | Pn -> En *)
  | Pexp_tuple of expression list
        (* (E1, ..., En)

           Invariant: n >= 2
        *)
  | Pexp_construct of Longident.t loc * expression option
        (* C                None
           C E              Some E
           C (E1, ..., En)  Some (Pexp_tuple[E1;...;En])
        *)
  | Pexp_variant of label * expression option
        (* `A             (None)
           `A E           (Some E)
         *)
  | Pexp_record of (Longident.t loc * expression) list * expression option
        (* { l1=P1; ...; ln=Pn }     (None)
           { E0 with l1=P1; ...; ln=Pn }   (Some E0)

           Invariant: n > 0
         *)
  | Pexp_field of expression * Longident.t loc
        (* E.l *)
  | Pexp_setfield of expression * Longident.t loc * expression
        (* E1.l <- E2 *)
  | Pexp_array of expression list
        (* [| E1; ...; En |] *)
  | Pexp_ifthenelse of expression * expression * expression option
        (* if E1 then E2 else E3 *)
  | Pexp_sequence of expression * expression
        (* E1; E2 *)
  | Pexp_while of expression * expression
        (* while E1 do E2 done *)
  | Pexp_for of
      pattern *  expression * expression * direction_flag * expression
        (* for i = E1 to E2 do E3 done      (flag = Upto)
           for i = E1 downto E2 do E3 done  (flag = Downto)
         *)
  | Pexp_constraint of expression * core_type
        (* (E : T) *)
  | Pexp_coerce of expression * core_type option * core_type
        (* (E :> T)        (None, T)
           (E : T0 :> T)   (Some T0, T)
         *)
  | Pexp_send of expression * string
        (*  E # m *)
  | Pexp_new of Longident.t loc
        (* new M.c *)
  | Pexp_setinstvar of string loc * expression
        (* x <- 2 *)
  | Pexp_override of (string loc * expression) list
        (* {< x1 = E1; ...; Xn = En >} *)
  | Pexp_letmodule of string loc * module_expr * expression
        (* let module M = ME in E *)
  | Pexp_assert of expression
        (* assert E
           Note: "assert false" is treated in a special way by the
           type-checker. *)
  | Pexp_lazy of expression
        (* lazy E *)
  | Pexp_poly of expression * core_type option
        (* Used for method bodies.

           Can only be used as the expression under Cfk_concrete
           for methods (not values). *)
  | Pexp_object of class_structure
        (* object ... end *)
  | Pexp_newtype of string * expression
        (* fun (type t) -> E *)
  | Pexp_pack of module_expr
        (* (module ME)

           (module ME : S) is represented as
           Pexp_constraint(Pexp_pack, Ptyp_package S) *)
  | Pexp_open of override_flag * Longident.t loc * expression
        (* let open M in E
           let! open M in E
        *)
  | Pexp_extension of extension
        (* [%id] *)

and case =   (* (P -> E) or (P when E0 -> E) *)
    {
     pc_lhs: pattern;
     pc_guard: expression option;
     pc_rhs: expression;
    }

(* Value descriptions *)

and value_description =
    {
     pval_name: string loc;
     pval_type: core_type;
     pval_prim: string list;
     pval_attributes: attributes;  (* ... [@@id1] [@@id2] *)
     pval_loc: Location.t;
    }

(*
  val x: T                            (prim = [])
  external x: T = "s1" ... "sn"       (prim = ["s1";..."sn"])

  Note: when used under Pstr_primitive, prim cannot be empty
*)

(* Type declarations *)

and type_declaration =
    {
     ptype_name: string loc;
     ptype_params: (core_type * variance) list;
           (* ('a1,...'an) t; None represents  _*)
     ptype_cstrs: (core_type * core_type * Location.t) list;
           (* ... constraint T1=T1'  ... constraint Tn=Tn' *)
     ptype_kind: type_kind;
     ptype_private: private_flag;   (* = private ... *)
     ptype_manifest: core_type option;  (* = T *)
     ptype_attributes: attributes;   (* ... [@@id1] [@@id2] *)
     ptype_loc: Location.t;
    }

(*
  type t                     (abstract, no manifest)
  type t = T0                (abstract, manifest=T0)
  type t = C of T | ...      (variant,  no manifest)
  type t = T0 = C of T | ... (variant,  manifest=T0)
  type t = {l: T; ...}       (record,   no manifest)
  type t = T0 = {l : T; ...} (record,   manifest=T0)
  type t = ..                (open,     no manifest)
*)

and type_kind =
  | Ptype_abstract
  | Ptype_variant of constructor_declaration list
        (* Invariant: non-empty list *)
  | Ptype_record of label_declaration list
        (* Invariant: non-empty list *)
  | Ptype_open

and label_declaration =
    {
     pld_name: string loc;
     pld_mutable: mutable_flag;
     pld_type: core_type;
     pld_loc: Location.t;
     pld_attributes: attributes; (* l [@id1] [@id2] : T *)
    }

(*  { ...; l: T; ... }            (mutable=Immutable)
    { ...; mutable l: T; ... }    (mutable=Mutable)

    Note: T can be a Ptyp_poly.
*)

and constructor_declaration =
    {
     pcd_name: string loc;
     pcd_args: core_type list;
     pcd_res: core_type option;
     pcd_loc: Location.t;
     pcd_attributes: attributes; (* C [@id1] [@id2] of ... *)
    }
(*
  | C of T1 * ... * Tn     (res = None)
  | C: T0                  (args = [], res = Some T0)
  | C: T1 * ... * Tn -> T0 (res = Some T0)
*)

and type_extension =
    {
     ptyext_path: Longident.t loc;
     ptyext_params: (core_type * variance) list;
     ptyext_constructors: extension_constructor list;
     ptyext_private: private_flag;
     ptyext_attributes: attributes;   (* ... [@@id1] [@@id2] *)
    }
(*
  type t += ...
*)

and extension_constructor =
    {
     pext_name: string loc;
     pext_kind : extension_constructor_kind;
     pext_loc : Location.t;
     pext_attributes: attributes; (* C [@id1] [@id2] of ... *)
    }

and extension_constructor_kind =
    Pext_decl of core_type list * core_type option
      (*
         | C of T1 * ... * Tn     ([T1; ...; Tn], None)
         | C: T0                  ([], Some T0)
         | C: T1 * ... * Tn -> T0 ([T1; ...; Tn], Some T0)
       *)
  | Pext_rebind of Longident.t loc
      (*
         | C = D
       *)

(** {2 Class language} *)

(* Type expressions for the class language *)

and class_type =
    {
     pcty_desc: class_type_desc;
     pcty_loc: Location.t;
     pcty_attributes: attributes; (* ... [@id1] [@id2] *)
    }

and class_type_desc =
  | Pcty_constr of Longident.t loc * core_type list
        (* c
           ['a1, ..., 'an] c *)
  | Pcty_signature of class_signature
        (* object ... end *)
  | Pcty_arrow of label * core_type * class_type
        (* T -> CT       (label = "")
           ~l:T -> CT    (label = "l")
           ?l:T -> CT    (label = "?l")
         *)
  | Pcty_extension of extension
        (* [%id] *)

and class_signature =
    {
     pcsig_self: core_type;
     pcsig_fields: class_type_field list;
    }
(* object('selfpat) ... end
   object ... end             (self = Ptyp_any)
 *)

and class_type_field =
    {
     pctf_desc: class_type_field_desc;
     pctf_loc: Location.t;
     pctf_attributes: attributes; (* ... [@@id1] [@@id2] *)
    }

and class_type_field_desc =
  | Pctf_inherit of class_type
        (* inherit CT *)
  | Pctf_val of (string * mutable_flag * virtual_flag * core_type)
        (* val x: T *)
  | Pctf_method  of (string * private_flag * virtual_flag * core_type)
        (* method x: T

           Note: T can be a Ptyp_poly.
         *)
  | Pctf_constraint  of (core_type * core_type)
        (* constraint T1 = T2 *)
  | Pctf_attribute of attribute
        (* [@@@id] *)
  | Pctf_extension of extension
        (* [%%id] *)

and 'a class_infos =
    {
     pci_virt: virtual_flag;
     pci_params: (core_type * variance) list;
     pci_name: string loc;
     pci_expr: 'a;
     pci_loc: Location.t;
     pci_attributes: attributes;  (* ... [@@id1] [@@id2] *)
    }
(* class c = ...
   class ['a1,...,'an] c = ...
   class virtual c = ...

   Also used for "class type" declaration.
*)

and class_description = class_type class_infos

and class_type_declaration = class_type class_infos

(* Value expressions for the class language *)

and class_expr =
    {
     pcl_desc: class_expr_desc;
     pcl_loc: Location.t;
     pcl_attributes: attributes; (* ... [@id1] [@id2] *)
    }

and class_expr_desc =
  | Pcl_constr of Longident.t loc * core_type list
        (* c
           ['a1, ..., 'an] c *)
  | Pcl_structure of class_structure
        (* object ... end *)
  | Pcl_fun of label * expression option * pattern * class_expr
        (* fun P -> CE                          (lab = "", None)
           fun ~l:P -> CE                       (lab = "l", None)
           fun ?l:P -> CE                       (lab = "?l", None)
           fun ?l:(P = E0) -> CE                (lab = "?l", Some E0)
         *)
  | Pcl_apply of class_expr * (label * expression) list
        (* CE ~l1:E1 ... ~ln:En
           li can be empty (non labeled argument) or start with '?'
           (optional argument).

           Invariant: n > 0
         *)
  | Pcl_let of rec_flag * value_binding list * class_expr
        (* let P1 = E1 and ... and Pn = EN in CE      (flag = Nonrecursive)
           let rec P1 = E1 and ... and Pn = EN in CE  (flag = Recursive)
         *)
  | Pcl_constraint of class_expr * class_type
        (* (CE : CT) *)
  | Pcl_extension of extension
        (* [%id] *)

and class_structure =
    {
     pcstr_self: pattern;
     pcstr_fields: class_field list;
    }
(* object(selfpat) ... end
   object ... end           (self = Ppat_any)
 *)

and class_field =
    {
     pcf_desc: class_field_desc;
     pcf_loc: Location.t;
     pcf_attributes: attributes; (* ... [@@id1] [@@id2] *)
    }

and class_field_desc =
  | Pcf_inherit of override_flag * class_expr * string option
        (* inherit CE
           inherit CE as x
           inherit! CE
           inherit! CE as x
         *)
  | Pcf_val of (string loc * mutable_flag * class_field_kind)
        (* val x = E
           val virtual x: T
         *)
  | Pcf_method of (string loc * private_flag * class_field_kind)
        (* method x = E            (E can be a Pexp_poly)
           method virtual x: T     (T can be a Ptyp_poly)
         *)
  | Pcf_constraint of (core_type * core_type)
        (* constraint T1 = T2 *)
  | Pcf_initializer of expression
        (* initializer E *)
  | Pcf_attribute of attribute
        (* [@@@id] *)
  | Pcf_extension of extension
        (* [%%id] *)

and class_field_kind =
  | Cfk_virtual of core_type
  | Cfk_concrete of override_flag * expression

and class_declaration = class_expr class_infos

(** {2 Module language} *)

(* Type expressions for the module language *)

and module_type =
    {
     pmty_desc: module_type_desc;
     pmty_loc: Location.t;
     pmty_attributes: attributes; (* ... [@id1] [@id2] *)
    }

and module_type_desc =
  | Pmty_ident of Longident.t loc
        (* S *)
  | Pmty_signature of signature
        (* sig ... end *)
  | Pmty_functor of string loc * module_type option * module_type
        (* functor(X : MT1) -> MT2 *)
  | Pmty_with of module_type * with_constraint list
        (* MT with ... *)
  | Pmty_typeof of module_expr
        (* module type of ME *)
  | Pmty_extension of extension
        (* [%id] *)
  | Pmty_alias of Longident.t loc
        (* (module M) *)

and signature = signature_item list

and signature_item =
    {
     psig_desc: signature_item_desc;
     psig_loc: Location.t;
    }

and signature_item_desc =
  | Psig_value of value_description
        (*
          val x: T
          external x: T = "s1" ... "sn"
         *)
  | Psig_type of type_declaration list
        (* type t1 = ... and ... and tn = ... *)
  | Psig_typext of type_extension
        (* type t1 += ... *)
  | Psig_exception of extension_constructor
        (* exception C of T *)
  | Psig_module of module_declaration
        (* module X : MT *)
  | Psig_recmodule of module_declaration list
        (* module rec X1 : MT1 and ... and Xn : MTn *)
  | Psig_modtype of module_type_declaration
        (* module type S = MT
           module type S *)
  | Psig_open of open_description
        (* open X *)
  | Psig_include of include_description
        (* include MT *)
  | Psig_class of class_description list
        (* class c1 : ... and ... and cn : ... *)
  | Psig_class_type of class_type_declaration list
        (* class type ct1 = ... and ... and ctn = ... *)
  | Psig_attribute of attribute
        (* [@@@id] *)
  | Psig_extension of extension * attributes
        (* [%%id] *)

and module_declaration =
    {
     pmd_name: string loc;
     pmd_type: module_type;
     pmd_attributes: attributes; (* ... [@@id1] [@@id2] *)
     pmd_loc: Location.t;
    }
(* S : MT *)

and module_type_declaration =
    {
     pmtd_name: string loc;
     pmtd_type: module_type option;
     pmtd_attributes: attributes; (* ... [@@id1] [@@id2] *)
     pmtd_loc: Location.t;
    }
(* S = MT
   S       (abstract module type declaration, pmtd_type = None)
*)

and open_description =
    {
     popen_lid: Longident.t loc;
     popen_override: override_flag;
     popen_loc: Location.t;
     popen_attributes: attributes;
    }
(* open! X - popen_override = Override (silences the 'used identifier
                              shadowing' warning)
   open  X - popen_override = Fresh
 *)

and 'a include_infos =
    {
     pincl_mod: 'a;
     pincl_loc: Location.t;
     pincl_attributes: attributes;
    }

and include_description = module_type include_infos
(* include MT *)

and include_declaration = module_expr include_infos
(* include ME *)

and with_constraint =
  | Pwith_type of Longident.t loc * type_declaration
        (* with type X.t = ...

           Note: the last component of the longident must match
           the name of the type_declaration. *)
  | Pwith_module of Longident.t loc * Longident.t loc
        (* with module X.Y = Z *)
  | Pwith_typesubst of type_declaration
        (* with type t := ... *)
  | Pwith_modsubst of string loc * Longident.t loc
        (* with module X := Z *)

(* Value expressions for the module language *)

and module_expr =
    {
     pmod_desc: module_expr_desc;
     pmod_loc: Location.t;
     pmod_attributes: attributes; (* ... [@id1] [@id2] *)
    }

and module_expr_desc =
  | Pmod_ident of Longident.t loc
        (* X *)
  | Pmod_structure of structure
        (* struct ... end *)
  | Pmod_functor of string loc * module_type option * module_expr
        (* functor(X : MT1) -> ME *)
  | Pmod_apply of module_expr * module_expr
        (* ME1(ME2) *)
  | Pmod_constraint of module_expr * module_type
        (* (ME : MT) *)
  | Pmod_unpack of expression
        (* (val E) *)
  | Pmod_extension of extension
        (* [%id] *)

and structure = structure_item list

and structure_item =
    {
     pstr_desc: structure_item_desc;
     pstr_loc: Location.t;
    }

and structure_item_desc =
  | Pstr_eval of expression * attributes
        (* E *)
  | Pstr_value of rec_flag * value_binding list
        (* let P1 = E1 and ... and Pn = EN       (flag = Nonrecursive)
           let rec P1 = E1 and ... and Pn = EN   (flag = Recursive)
         *)
  | Pstr_primitive of value_description
        (* external x: T = "s1" ... "sn" *)
  | Pstr_type of type_declaration list
        (* type t1 = ... and ... and tn = ... *)
  | Pstr_typext of type_extension
        (* type t1 += ... *)
  | Pstr_exception of extension_constructor
        (* exception C of T
           exception C = M.X *)
  | Pstr_module of module_binding
        (* module X = ME *)
  | Pstr_recmodule of module_binding list
        (* module rec X1 = ME1 and ... and Xn = MEn *)
  | Pstr_modtype of module_type_declaration
        (* module type S = MT *)
  | Pstr_open of open_description
        (* open X *)
  | Pstr_class of class_declaration list
        (* class c1 = ... and ... and cn = ... *)
  | Pstr_class_type of class_type_declaration list
        (* class type ct1 = ... and ... and ctn = ... *)
  | Pstr_include of include_declaration
        (* include ME *)
  | Pstr_attribute of attribute
        (* [@@@id] *)
  | Pstr_extension of extension * attributes
        (* [%%id] *)

and value_binding =
  {
    pvb_pat: pattern;
    pvb_expr: expression;
    pvb_attributes: attributes;
    pvb_loc: Location.t;
  }

and module_binding =
    {
     pmb_name: string loc;
     pmb_expr: module_expr;
     pmb_attributes: attributes;
     pmb_loc: Location.t;
    }
(* X = ME *)

(** {2 Toplevel} *)

(* Toplevel phrases *)

type toplevel_phrase =
  | Ptop_def of structure
  | Ptop_dir of string * directive_argument
     (* #use, #load ... *)

and directive_argument =
  | Pdir_none
  | Pdir_string of string
  | Pdir_int of int
  | Pdir_ident of Longident.t
  | Pdir_bool of bool

end
module Docstrings : sig 
#1 "docstrings.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*                              Leo White                              *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(** (Re)Initialise all docstring state *)
val init : unit -> unit

(** Emit warnings for unattached and ambiguous docstrings *)
val warn_bad_docstrings : unit -> unit

(** {3 Docstrings} *)

(** Documentation comments *)
type docstring

(** Create a docstring *)
val docstring : string -> Location.t -> docstring

(** Get the text of a docstring *)
val docstring_body : docstring -> string

(** Get the location of a docstring *)
val docstring_loc : docstring -> Location.t

(** {3 Set functions}

   These functions are used by the lexer to associate docstrings to
   the locations of tokens. *)

(** Docstrings immediately preceding a token *)
val set_pre_docstrings : Lexing.position -> docstring list -> unit

(** Docstrings immediately following a token *)
val set_post_docstrings : Lexing.position -> docstring list -> unit

(** Docstrings not immediately adjacent to a token *)
val set_floating_docstrings : Lexing.position -> docstring list -> unit

(** Docstrings immediately following the token which precedes this one *)
val set_pre_extra_docstrings : Lexing.position -> docstring list -> unit

(** Docstrings immediately preceding the token which follows this one *)
val set_post_extra_docstrings : Lexing.position -> docstring list -> unit

(** {3 Items}

    The {!docs} type represents documentation attached to an item. *)

type docs =
  { docs_pre: docstring option;
    docs_post: docstring option; }

val empty_docs : docs

val docs_attr : docstring -> Parsetree.attribute

(** Convert item documentation to attributes and add them to an
    attribute list *)
val add_docs_attrs : docs -> Parsetree.attributes -> Parsetree.attributes

(** Fetch the item documentation for the current symbol. This also
    marks this documentation (for ambiguity warnings). *)
val symbol_docs : unit -> docs
val symbol_docs_lazy : unit -> docs Lazy.t

(** Fetch the item documentation for the symbols between two
    positions. This also marks this documentation (for ambiguity
    warnings). *)
val rhs_docs : int -> int -> docs
val rhs_docs_lazy : int -> int -> docs Lazy.t

(** Mark the item documentation for the current symbol (for ambiguity
    warnings). *)
val mark_symbol_docs : unit -> unit

(** Mark as associated the item documentation for the symbols between
    two positions (for ambiguity warnings) *)
val mark_rhs_docs : int -> int -> unit

(** {3 Fields and constructors}

    The {!info} type represents documentation attached to a field or
    constructor. *)

type info = docstring option

val empty_info : info

val info_attr : docstring -> Parsetree.attribute

(** Convert field info to attributes and add them to an
    attribute list *)
val add_info_attrs : info -> Parsetree.attributes -> Parsetree.attributes

(** Fetch the field info for the current symbol. *)
val symbol_info : unit -> info

(** Fetch the field info following the symbol at a given position. *)
val rhs_info : int -> info

(** {3 Unattached comments}

    The {!text} type represents documentation which is not attached to
    anything. *)

type text = docstring list

val empty_text : text

val text_attr : docstring -> Parsetree.attribute

(** Convert text to attributes and add them to an attribute list *)
val add_text_attrs : text -> Parsetree.attributes -> Parsetree.attributes

(** Fetch the text preceding the current symbol. *)
val symbol_text : unit -> text
val symbol_text_lazy : unit -> text Lazy.t

(** Fetch the text preceding the symbol at the given position. *)
val rhs_text : int -> text
val rhs_text_lazy : int -> text Lazy.t

(** {3 Extra text}

    There may be additional text attached to the delimiters of a block
    (e.g. [struct] and [end]). This is fetched by the following
    functions, which are applied to the contents of the block rather
    than the delimiters. *)

(** Fetch additional text preceding the current symbol *)
val symbol_pre_extra_text : unit -> text

(** Fetch additional text following the current symbol *)
val symbol_post_extra_text : unit -> text

(** Fetch additional text preceding the symbol at the given position *)
val rhs_pre_extra_text : int -> text

(** Fetch additional text following the symbol at the given position *)
val rhs_post_extra_text : int -> text

end = struct
#1 "docstrings.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*                              Leo White                              *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Location

(* Docstrings *)

(* A docstring is "attached" if it has been inserted in the AST. This
   is used for generating unexpected docstring warnings. *)
type ds_attached =
  | Unattached   (* Not yet attached anything.*)
  | Info         (* Attached to a field or constructor. *)
  | Docs         (* Attached to an item or as floating text. *)

(* A docstring is "associated" with an item if there are no blank lines between
   them. This is used for generating docstring ambiguity warnings. *)
type ds_associated =
  | Zero             (* Not associated with an item *)
  | One              (* Associated with one item *)
  | Many             (* Associated with multiple items (ambiguity) *)

type docstring =
  { ds_body: string;
    ds_loc: Location.t;
    mutable ds_attached: ds_attached;
    mutable ds_associated: ds_associated; }

(* List of docstrings *)

let docstrings : docstring list ref = ref []

(* Warn for unused and ambiguous docstrings *)

let warn_bad_docstrings () =
  if Warnings.is_active (Warnings.Bad_docstring true) then begin
    List.iter
      (fun ds ->
         match ds.ds_attached with
         | Info -> ()
         | Unattached ->
           prerr_warning ds.ds_loc (Warnings.Bad_docstring true)
         | Docs ->
             match ds.ds_associated with
             | Zero | One -> ()
             | Many ->
               prerr_warning ds.ds_loc (Warnings.Bad_docstring false))
      (List.rev !docstrings)
end

(* Docstring constructors and descturctors *)

let docstring body loc =
  let ds =
    { ds_body = body;
      ds_loc = loc;
      ds_attached = Unattached;
      ds_associated = Zero; }
  in
  docstrings := ds :: !docstrings;
  ds

let docstring_body ds = ds.ds_body

let docstring_loc ds = ds.ds_loc

(* Docstrings attached to items *)

type docs =
  { docs_pre: docstring option;
    docs_post: docstring option; }

let empty_docs = { docs_pre = None; docs_post = None }

let doc_loc = {txt = "ocaml.doc"; loc = Location.none}

let docs_attr ds =
  let open Asttypes in
  let open Parsetree in
  let exp =
    { pexp_desc = Pexp_constant (Const_string(ds.ds_body, None));
      pexp_loc = ds.ds_loc;
      pexp_attributes = []; }
  in
  let item =
    { pstr_desc = Pstr_eval (exp, []); pstr_loc = exp.pexp_loc }
  in
    (doc_loc, PStr [item])

let add_docs_attrs docs attrs =
  let attrs =
    match docs.docs_pre with
    | None -> attrs
    | Some ds -> docs_attr ds :: attrs
  in
  let attrs =
    match docs.docs_post with
    | None -> attrs
    | Some ds -> attrs @ [docs_attr ds]
  in
  attrs

(* Docstrings attached to consturctors or fields *)

type info = docstring option

let empty_info = None

let info_attr = docs_attr

let add_info_attrs info attrs =
  let attrs =
    match info with
    | None -> attrs
    | Some ds -> attrs @ [info_attr ds]
  in
  attrs

(* Docstrings not attached to a specifc item *)

type text = docstring list

let empty_text = []

let text_loc = {txt = "ocaml.text"; loc = Location.none}

let text_attr ds =
  let open Asttypes in
  let open Parsetree in
  let exp =
    { pexp_desc = Pexp_constant (Const_string(ds.ds_body, None));
      pexp_loc = ds.ds_loc;
      pexp_attributes = []; }
  in
  let item =
    { pstr_desc = Pstr_eval (exp, []); pstr_loc = exp.pexp_loc }
  in
    (text_loc, PStr [item])

let add_text_attrs dsl attrs =
  (List.map text_attr dsl) @ attrs

(* Find the first non-info docstring in a list, attach it and return it *)
let get_docstring ~info dsl =
  let rec loop = function
    | [] -> None
    | {ds_attached = Info; _} :: rest -> loop rest
    | ds :: rest ->
        ds.ds_attached <- if info then Info else Docs;
        Some ds
  in
  loop dsl

(* Find all the non-info docstrings in a list, attach them and return them *)
let get_docstrings dsl =
  let rec loop acc = function
    | [] -> List.rev acc
    | {ds_attached = Info; _} :: rest -> loop acc rest
    | ds :: rest ->
        ds.ds_attached <- Docs;
        loop (ds :: acc) rest
  in
    loop [] dsl

(* "Associate" all the docstrings in a list *)
let associate_docstrings dsl =
  List.iter
    (fun ds ->
       match ds.ds_associated with
       | Zero -> ds.ds_associated <- One
       | (One | Many) -> ds.ds_associated <- Many)
    dsl

(* Map from positions to pre docstrings *)

let pre_table : (Lexing.position, docstring list) Hashtbl.t =
  Hashtbl.create 50

let set_pre_docstrings pos dsl =
  if dsl <> [] then Hashtbl.add pre_table pos dsl

let get_pre_docs pos =
  try
    let dsl = Hashtbl.find pre_table pos in
      associate_docstrings dsl;
      get_docstring ~info:false dsl
  with Not_found -> None

let mark_pre_docs pos =
  try
    let dsl = Hashtbl.find pre_table pos in
      associate_docstrings dsl
  with Not_found -> ()

(* Map from positions to post docstrings *)

let post_table : (Lexing.position, docstring list) Hashtbl.t =
  Hashtbl.create 50

let set_post_docstrings pos dsl =
  if dsl <> [] then Hashtbl.add post_table pos dsl

let get_post_docs pos =
  try
    let dsl = Hashtbl.find post_table pos in
      associate_docstrings dsl;
      get_docstring ~info:false dsl
  with Not_found -> None

let mark_post_docs pos =
  try
    let dsl = Hashtbl.find post_table pos in
      associate_docstrings dsl
  with Not_found -> ()

let get_info pos =
  try
    let dsl = Hashtbl.find post_table pos in
      get_docstring ~info:true dsl
  with Not_found -> None

(* Map from positions to floating docstrings *)

let floating_table : (Lexing.position, docstring list) Hashtbl.t =
  Hashtbl.create 50

let set_floating_docstrings pos dsl =
  if dsl <> [] then Hashtbl.add floating_table pos dsl

let get_text pos =
  try
    let dsl = Hashtbl.find floating_table pos in
      get_docstrings dsl
  with Not_found -> []

(* Maps from positions to extra docstrings *)

let pre_extra_table : (Lexing.position, docstring list) Hashtbl.t =
  Hashtbl.create 50

let set_pre_extra_docstrings pos dsl =
  if dsl <> [] then Hashtbl.add pre_extra_table pos dsl

let get_pre_extra_text pos =
  try
    let dsl = Hashtbl.find pre_extra_table pos in
      get_docstrings dsl
  with Not_found -> []

let post_extra_table : (Lexing.position, docstring list) Hashtbl.t =
  Hashtbl.create 50

let set_post_extra_docstrings pos dsl =
  if dsl <> [] then Hashtbl.add post_extra_table pos dsl

let get_post_extra_text pos =
  try
    let dsl = Hashtbl.find post_extra_table pos in
      get_docstrings dsl
  with Not_found -> []

(* Docstrings from parser actions *)

let symbol_docs () =
  { docs_pre = get_pre_docs (Parsing.symbol_start_pos ());
    docs_post = get_post_docs (Parsing.symbol_end_pos ()); }

let symbol_docs_lazy () =
  let p1 = Parsing.symbol_start_pos () in
  let p2 = Parsing.symbol_end_pos () in
    lazy { docs_pre = get_pre_docs p1;
           docs_post = get_post_docs p2; }

let rhs_docs pos1 pos2 =
  { docs_pre = get_pre_docs (Parsing.rhs_start_pos pos1);
    docs_post = get_post_docs (Parsing.rhs_end_pos pos2); }

let rhs_docs_lazy pos1 pos2 =
  let p1 = Parsing.rhs_start_pos pos1 in
  let p2 = Parsing.rhs_end_pos pos2 in
    lazy { docs_pre = get_pre_docs p1;
           docs_post = get_post_docs p2; }

let mark_symbol_docs () =
  mark_pre_docs (Parsing.symbol_start_pos ());
  mark_post_docs (Parsing.symbol_end_pos ())

let mark_rhs_docs pos1 pos2 =
  mark_pre_docs (Parsing.rhs_start_pos pos1);
  mark_post_docs (Parsing.rhs_end_pos pos2)

let symbol_info () =
  get_info (Parsing.symbol_end_pos ())

let rhs_info pos =
  get_info (Parsing.rhs_end_pos pos)

let symbol_text () =
  get_text (Parsing.symbol_start_pos ())

let symbol_text_lazy () =
  let pos = Parsing.symbol_start_pos () in
    lazy (get_text pos)

let rhs_text pos =
  get_text (Parsing.rhs_start_pos pos)

let rhs_text_lazy pos =
  let pos = Parsing.rhs_start_pos pos in
    lazy (get_text pos)

let symbol_pre_extra_text () =
  get_pre_extra_text (Parsing.symbol_start_pos ())

let symbol_post_extra_text () =
  get_post_extra_text (Parsing.symbol_end_pos ())

let rhs_pre_extra_text pos =
  get_pre_extra_text (Parsing.rhs_start_pos pos)

let rhs_post_extra_text pos =
  get_post_extra_text (Parsing.rhs_end_pos pos)


(* (Re)Initialise all comment state *)

let init () =
  docstrings := [];
  Hashtbl.reset pre_table;
  Hashtbl.reset post_table;
  Hashtbl.reset floating_table;
  Hashtbl.reset pre_extra_table;
  Hashtbl.reset post_extra_table




end
module Ast_helper : sig 
#1 "ast_helper.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*                        Alain Frisch, LexiFi                         *)
(*                                                                     *)
(*  Copyright 2012 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(** Helpers to produce Parsetree fragments *)

open Parsetree
open Asttypes
open Docstrings

type lid = Longident.t loc
type str = string loc
type loc = Location.t
type attrs = attribute list

(** {2 Default locations} *)

val default_loc: loc ref
    (** Default value for all optional location arguments. *)

val with_default_loc: loc -> (unit -> 'a) -> 'a
    (** Set the [default_loc] within the scope of the execution
        of the provided function. *)

(** {2 Core language} *)

(** Type expressions *)
module Typ :
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> core_type_desc -> core_type
    val attr: core_type -> attribute -> core_type

    val any: ?loc:loc -> ?attrs:attrs -> unit -> core_type
    val var: ?loc:loc -> ?attrs:attrs -> string -> core_type
    val arrow: ?loc:loc -> ?attrs:attrs -> label -> core_type -> core_type
               -> core_type
    val tuple: ?loc:loc -> ?attrs:attrs -> core_type list -> core_type
    val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> core_type
    val object_: ?loc:loc -> ?attrs:attrs ->
                  (string * attributes * core_type) list -> closed_flag ->
                  core_type
    val class_: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> core_type
    val alias: ?loc:loc -> ?attrs:attrs -> core_type -> string -> core_type
    val variant: ?loc:loc -> ?attrs:attrs -> row_field list -> closed_flag
                 -> label list option -> core_type
    val poly: ?loc:loc -> ?attrs:attrs -> string list -> core_type -> core_type
    val package: ?loc:loc -> ?attrs:attrs -> lid -> (lid * core_type) list
                 -> core_type
    val extension: ?loc:loc -> ?attrs:attrs -> extension -> core_type

    val force_poly: core_type -> core_type
  end

(** Patterns *)
module Pat:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> pattern_desc -> pattern
    val attr:pattern -> attribute -> pattern

    val any: ?loc:loc -> ?attrs:attrs -> unit -> pattern
    val var: ?loc:loc -> ?attrs:attrs -> str -> pattern
    val alias: ?loc:loc -> ?attrs:attrs -> pattern -> str -> pattern
    val constant: ?loc:loc -> ?attrs:attrs -> constant -> pattern
    val interval: ?loc:loc -> ?attrs:attrs -> constant -> constant -> pattern
    val tuple: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern
    val construct: ?loc:loc -> ?attrs:attrs -> lid -> pattern option -> pattern
    val variant: ?loc:loc -> ?attrs:attrs -> label -> pattern option -> pattern
    val record: ?loc:loc -> ?attrs:attrs -> (lid * pattern) list -> closed_flag
                -> pattern
    val array: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern
    val or_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern -> pattern
    val constraint_: ?loc:loc -> ?attrs:attrs -> pattern -> core_type -> pattern
    val type_: ?loc:loc -> ?attrs:attrs -> lid -> pattern
    val lazy_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern
    val unpack: ?loc:loc -> ?attrs:attrs -> str -> pattern
    val exception_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern
    val extension: ?loc:loc -> ?attrs:attrs -> extension -> pattern
  end

(** Expressions *)
module Exp:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> expression_desc -> expression
    val attr: expression -> attribute -> expression

    val ident: ?loc:loc -> ?attrs:attrs -> lid -> expression
    val constant: ?loc:loc -> ?attrs:attrs -> constant -> expression
    val let_: ?loc:loc -> ?attrs:attrs -> rec_flag -> value_binding list
              -> expression -> expression
    val fun_: ?loc:loc -> ?attrs:attrs -> label -> expression option -> pattern
              -> expression -> expression
    val function_: ?loc:loc -> ?attrs:attrs -> case list -> expression
    val apply: ?loc:loc -> ?attrs:attrs -> expression
               -> (label * expression) list -> expression
    val match_: ?loc:loc -> ?attrs:attrs -> expression -> case list
                -> expression
    val try_: ?loc:loc -> ?attrs:attrs -> expression -> case list -> expression
    val tuple: ?loc:loc -> ?attrs:attrs -> expression list -> expression
    val construct: ?loc:loc -> ?attrs:attrs -> lid -> expression option
                   -> expression
    val variant: ?loc:loc -> ?attrs:attrs -> label -> expression option
                 -> expression
    val record: ?loc:loc -> ?attrs:attrs -> (lid * expression) list
                -> expression option -> expression
    val field: ?loc:loc -> ?attrs:attrs -> expression -> lid -> expression
    val setfield: ?loc:loc -> ?attrs:attrs -> expression -> lid -> expression
                  -> expression
    val array: ?loc:loc -> ?attrs:attrs -> expression list -> expression
    val ifthenelse: ?loc:loc -> ?attrs:attrs -> expression -> expression
                    -> expression option -> expression
    val sequence: ?loc:loc -> ?attrs:attrs -> expression -> expression
                  -> expression
    val while_: ?loc:loc -> ?attrs:attrs -> expression -> expression
                -> expression
    val for_: ?loc:loc -> ?attrs:attrs -> pattern -> expression -> expression
              -> direction_flag -> expression -> expression
    val coerce: ?loc:loc -> ?attrs:attrs -> expression -> core_type option
                -> core_type -> expression
    val constraint_: ?loc:loc -> ?attrs:attrs -> expression -> core_type
                     -> expression
    val send: ?loc:loc -> ?attrs:attrs -> expression -> string -> expression
    val new_: ?loc:loc -> ?attrs:attrs -> lid -> expression
    val setinstvar: ?loc:loc -> ?attrs:attrs -> str -> expression -> expression
    val override: ?loc:loc -> ?attrs:attrs -> (str * expression) list
                  -> expression
    val letmodule: ?loc:loc -> ?attrs:attrs -> str -> module_expr -> expression
                   -> expression
    val assert_: ?loc:loc -> ?attrs:attrs -> expression -> expression
    val lazy_: ?loc:loc -> ?attrs:attrs -> expression -> expression
    val poly: ?loc:loc -> ?attrs:attrs -> expression -> core_type option -> expression
    val object_: ?loc:loc -> ?attrs:attrs -> class_structure -> expression
    val newtype: ?loc:loc -> ?attrs:attrs -> string -> expression -> expression
    val pack: ?loc:loc -> ?attrs:attrs -> module_expr -> expression
    val open_: ?loc:loc -> ?attrs:attrs -> override_flag -> lid -> expression -> expression
    val extension: ?loc:loc -> ?attrs:attrs -> extension -> expression

    val case: pattern -> ?guard:expression -> expression -> case
  end

(** Value declarations *)
module Val:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs ->
      ?prim:string list -> str -> core_type -> value_description
  end

(** Type declarations *)
module Type:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
      ?params:(core_type * variance) list -> ?cstrs:(core_type * core_type * loc) list ->
      ?kind:type_kind -> ?priv:private_flag -> ?manifest:core_type -> str ->
      type_declaration

    val constructor: ?loc:loc -> ?attrs:attrs -> ?info:info ->
      ?args:core_type list -> ?res:core_type -> str -> constructor_declaration
    val field: ?loc:loc -> ?attrs:attrs -> ?info:info ->
      ?mut:mutable_flag -> str -> core_type -> label_declaration
  end

(** Type extensions *)
module Te:
  sig
    val mk: ?attrs:attrs -> ?docs:docs ->
      ?params:(core_type * variance) list -> ?priv:private_flag ->
      lid -> extension_constructor list -> type_extension

    val constructor: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->
      str -> extension_constructor_kind -> extension_constructor

    val decl: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->
      ?args:core_type list -> ?res:core_type -> str -> extension_constructor
    val rebind: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->
      str -> lid -> extension_constructor
  end

(** {2 Module language} *)

(** Module type expressions *)
module Mty:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> module_type_desc -> module_type
    val attr: module_type -> attribute -> module_type

    val ident: ?loc:loc -> ?attrs:attrs -> lid -> module_type
    val alias: ?loc:loc -> ?attrs:attrs -> lid -> module_type
    val signature: ?loc:loc -> ?attrs:attrs -> signature -> module_type
    val functor_: ?loc:loc -> ?attrs:attrs ->
      str -> module_type option -> module_type -> module_type
    val with_: ?loc:loc -> ?attrs:attrs -> module_type -> with_constraint list -> module_type
    val typeof_: ?loc:loc -> ?attrs:attrs -> module_expr -> module_type
    val extension: ?loc:loc -> ?attrs:attrs -> extension -> module_type
  end

(** Module expressions *)
module Mod:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> module_expr_desc -> module_expr
    val attr: module_expr -> attribute -> module_expr

    val ident: ?loc:loc -> ?attrs:attrs -> lid -> module_expr
    val structure: ?loc:loc -> ?attrs:attrs -> structure -> module_expr
    val functor_: ?loc:loc -> ?attrs:attrs ->
      str -> module_type option -> module_expr -> module_expr
    val apply: ?loc:loc -> ?attrs:attrs -> module_expr -> module_expr -> module_expr
    val constraint_: ?loc:loc -> ?attrs:attrs -> module_expr -> module_type -> module_expr
    val unpack: ?loc:loc -> ?attrs:attrs -> expression -> module_expr
    val extension: ?loc:loc -> ?attrs:attrs -> extension -> module_expr
  end

(** Signature items *)
module Sig:
  sig
    val mk: ?loc:loc -> signature_item_desc -> signature_item

    val value: ?loc:loc -> value_description -> signature_item
    val type_: ?loc:loc -> type_declaration list -> signature_item
    val type_extension: ?loc:loc -> type_extension -> signature_item
    val exception_: ?loc:loc -> extension_constructor -> signature_item
    val module_: ?loc:loc -> module_declaration -> signature_item
    val rec_module: ?loc:loc -> module_declaration list -> signature_item
    val modtype: ?loc:loc -> module_type_declaration -> signature_item
    val open_: ?loc:loc -> open_description -> signature_item
    val include_: ?loc:loc -> include_description -> signature_item
    val class_: ?loc:loc -> class_description list -> signature_item
    val class_type: ?loc:loc -> class_type_declaration list -> signature_item
    val extension: ?loc:loc -> ?attrs:attrs -> extension -> signature_item
    val attribute: ?loc:loc -> attribute -> signature_item
    val text: text -> signature_item list
  end

(** Structure items *)
module Str:
  sig
    val mk: ?loc:loc -> structure_item_desc -> structure_item

    val eval: ?loc:loc -> ?attrs:attributes -> expression -> structure_item
    val value: ?loc:loc -> rec_flag -> value_binding list -> structure_item
    val primitive: ?loc:loc -> value_description -> structure_item
    val type_: ?loc:loc -> type_declaration list -> structure_item
    val type_extension: ?loc:loc -> type_extension -> structure_item
    val exception_: ?loc:loc -> extension_constructor -> structure_item
    val module_: ?loc:loc -> module_binding -> structure_item
    val rec_module: ?loc:loc -> module_binding list -> structure_item
    val modtype: ?loc:loc -> module_type_declaration -> structure_item
    val open_: ?loc:loc -> open_description -> structure_item
    val class_: ?loc:loc -> class_declaration list -> structure_item
    val class_type: ?loc:loc -> class_type_declaration list -> structure_item
    val include_: ?loc:loc -> include_declaration -> structure_item
    val extension: ?loc:loc -> ?attrs:attrs -> extension -> structure_item
    val attribute: ?loc:loc -> attribute -> structure_item
    val text: text -> structure_item list
  end

(** Module declarations *)
module Md:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
      str -> module_type -> module_declaration
  end

(** Module type declarations *)
module Mtd:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
      ?typ:module_type -> str -> module_type_declaration
  end

(** Module bindings *)
module Mb:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
      str -> module_expr -> module_binding
  end

(* Opens *)
module Opn:
  sig
    val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs ->
      ?override:override_flag -> lid -> open_description
  end

(* Includes *)
module Incl:
  sig
    val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs -> 'a -> 'a include_infos
  end

(** Value bindings *)

module Vb:
  sig
    val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
      pattern -> expression -> value_binding
  end


(** {2 Class language} *)

(** Class type expressions *)
module Cty:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> class_type_desc -> class_type
    val attr: class_type -> attribute -> class_type

    val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> class_type
    val signature: ?loc:loc -> ?attrs:attrs -> class_signature -> class_type
    val arrow: ?loc:loc -> ?attrs:attrs -> label -> core_type -> class_type -> class_type
    val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_type
  end

(** Class type fields *)
module Ctf:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs ->
      class_type_field_desc -> class_type_field
    val attr: class_type_field -> attribute -> class_type_field

    val inherit_: ?loc:loc -> ?attrs:attrs -> class_type -> class_type_field
    val val_: ?loc:loc -> ?attrs:attrs -> string -> mutable_flag -> virtual_flag -> core_type -> class_type_field
    val method_: ?loc:loc -> ?attrs:attrs -> string -> private_flag -> virtual_flag -> core_type -> class_type_field
    val constraint_: ?loc:loc -> ?attrs:attrs -> core_type -> core_type -> class_type_field
    val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_type_field
    val attribute: ?loc:loc -> attribute -> class_type_field
    val text: text -> class_type_field list
  end

(** Class expressions *)
module Cl:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> class_expr_desc -> class_expr
    val attr: class_expr -> attribute -> class_expr

    val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> class_expr
    val structure: ?loc:loc -> ?attrs:attrs -> class_structure -> class_expr
    val fun_: ?loc:loc -> ?attrs:attrs -> label -> expression option -> pattern -> class_expr -> class_expr
    val apply: ?loc:loc -> ?attrs:attrs -> class_expr -> (label * expression) list -> class_expr
    val let_: ?loc:loc -> ?attrs:attrs -> rec_flag -> value_binding list -> class_expr -> class_expr
    val constraint_: ?loc:loc -> ?attrs:attrs -> class_expr -> class_type -> class_expr
    val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_expr
  end

(** Class fields *)
module Cf:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> class_field_desc -> class_field
    val attr: class_field -> attribute -> class_field

    val inherit_: ?loc:loc -> ?attrs:attrs -> override_flag -> class_expr -> string option -> class_field
    val val_: ?loc:loc -> ?attrs:attrs -> str -> mutable_flag -> class_field_kind -> class_field
    val method_: ?loc:loc -> ?attrs:attrs -> str -> private_flag -> class_field_kind -> class_field
    val constraint_: ?loc:loc -> ?attrs:attrs -> core_type -> core_type -> class_field
    val initializer_: ?loc:loc -> ?attrs:attrs -> expression -> class_field
    val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_field
    val attribute: ?loc:loc -> attribute -> class_field
    val text: text -> class_field list

    val virtual_: core_type -> class_field_kind
    val concrete: override_flag -> expression -> class_field_kind

  end

(** Classes *)
module Ci:
  sig
    val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
      ?virt:virtual_flag -> ?params:(core_type * variance) list ->
      str -> 'a -> 'a class_infos
  end

(** Class signatures *)
module Csig:
  sig
    val mk: core_type -> class_type_field list -> class_signature
  end

(** Class structures *)
module Cstr:
  sig
    val mk: pattern -> class_field list -> class_structure
  end

end = struct
#1 "ast_helper.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*                        Alain Frisch, LexiFi                         *)
(*                                                                     *)
(*  Copyright 2012 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(** Helpers to produce Parsetree fragments *)

open Asttypes
open Parsetree
open Docstrings

type lid = Longident.t loc
type str = string loc
type loc = Location.t
type attrs = attribute list

let default_loc = ref Location.none

let with_default_loc l f =
  let old = !default_loc in
  default_loc := l;
  try let r = f () in default_loc := old; r
  with exn -> default_loc := old; raise exn

module Typ = struct
  let mk ?(loc = !default_loc) ?(attrs = []) d =
    {ptyp_desc = d; ptyp_loc = loc; ptyp_attributes = attrs}
  let attr d a = {d with ptyp_attributes = d.ptyp_attributes @ [a]}

  let any ?loc ?attrs () = mk ?loc ?attrs Ptyp_any
  let var ?loc ?attrs a = mk ?loc ?attrs (Ptyp_var a)
  let arrow ?loc ?attrs a b c = mk ?loc ?attrs (Ptyp_arrow (a, b, c))
  let tuple ?loc ?attrs a = mk ?loc ?attrs (Ptyp_tuple a)
  let constr ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_constr (a, b))
  let object_ ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_object (a, b))
  let class_ ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_class (a, b))
  let alias ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_alias (a, b))
  let variant ?loc ?attrs a b c = mk ?loc ?attrs (Ptyp_variant (a, b, c))
  let poly ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_poly (a, b))
  let package ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_package (a, b))
  let extension ?loc ?attrs a = mk ?loc ?attrs (Ptyp_extension a)

  let force_poly t =
    match t.ptyp_desc with
    | Ptyp_poly _ -> t
    | _ -> poly ~loc:t.ptyp_loc [] t (* -> ghost? *)
end

module Pat = struct
  let mk ?(loc = !default_loc) ?(attrs = []) d =
    {ppat_desc = d; ppat_loc = loc; ppat_attributes = attrs}
  let attr d a = {d with ppat_attributes = d.ppat_attributes @ [a]}

  let any ?loc ?attrs () = mk ?loc ?attrs Ppat_any
  let var ?loc ?attrs a = mk ?loc ?attrs (Ppat_var a)
  let alias ?loc ?attrs a b = mk ?loc ?attrs (Ppat_alias (a, b))
  let constant ?loc ?attrs a = mk ?loc ?attrs (Ppat_constant a)
  let interval ?loc ?attrs a b = mk ?loc ?attrs (Ppat_interval (a, b))
  let tuple ?loc ?attrs a = mk ?loc ?attrs (Ppat_tuple a)
  let construct ?loc ?attrs a b = mk ?loc ?attrs (Ppat_construct (a, b))
  let variant ?loc ?attrs a b = mk ?loc ?attrs (Ppat_variant (a, b))
  let record ?loc ?attrs a b = mk ?loc ?attrs (Ppat_record (a, b))
  let array ?loc ?attrs a = mk ?loc ?attrs (Ppat_array a)
  let or_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_or (a, b))
  let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_constraint (a, b))
  let type_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_type a)
  let lazy_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_lazy a)
  let unpack ?loc ?attrs a = mk ?loc ?attrs (Ppat_unpack a)
  let exception_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_exception a)
  let extension ?loc ?attrs a = mk ?loc ?attrs (Ppat_extension a)
end

module Exp = struct
  let mk ?(loc = !default_loc) ?(attrs = []) d =
    {pexp_desc = d; pexp_loc = loc; pexp_attributes = attrs}
  let attr d a = {d with pexp_attributes = d.pexp_attributes @ [a]}

  let ident ?loc ?attrs a = mk ?loc ?attrs (Pexp_ident a)
  let constant ?loc ?attrs a = mk ?loc ?attrs (Pexp_constant a)
  let let_ ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_let (a, b, c))
  let fun_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pexp_fun (a, b, c, d))
  let function_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_function a)
  let apply ?loc ?attrs a b = mk ?loc ?attrs (Pexp_apply (a, b))
  let match_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_match (a, b))
  let try_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_try (a, b))
  let tuple ?loc ?attrs a = mk ?loc ?attrs (Pexp_tuple a)
  let construct ?loc ?attrs a b = mk ?loc ?attrs (Pexp_construct (a, b))
  let variant ?loc ?attrs a b = mk ?loc ?attrs (Pexp_variant (a, b))
  let record ?loc ?attrs a b = mk ?loc ?attrs (Pexp_record (a, b))
  let field ?loc ?attrs a b = mk ?loc ?attrs (Pexp_field (a, b))
  let setfield ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_setfield (a, b, c))
  let array ?loc ?attrs a = mk ?loc ?attrs (Pexp_array a)
  let ifthenelse ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_ifthenelse (a, b, c))
  let sequence ?loc ?attrs a b = mk ?loc ?attrs (Pexp_sequence (a, b))
  let while_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_while (a, b))
  let for_ ?loc ?attrs a b c d e = mk ?loc ?attrs (Pexp_for (a, b, c, d, e))
  let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_constraint (a, b))
  let coerce ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_coerce (a, b, c))
  let send ?loc ?attrs a b = mk ?loc ?attrs (Pexp_send (a, b))
  let new_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_new a)
  let setinstvar ?loc ?attrs a b = mk ?loc ?attrs (Pexp_setinstvar (a, b))
  let override ?loc ?attrs a = mk ?loc ?attrs (Pexp_override a)
  let letmodule ?loc ?attrs a b c= mk ?loc ?attrs (Pexp_letmodule (a, b, c))
  let assert_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_assert a)
  let lazy_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_lazy a)
  let poly ?loc ?attrs a b = mk ?loc ?attrs (Pexp_poly (a, b))
  let object_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_object a)
  let newtype ?loc ?attrs a b = mk ?loc ?attrs (Pexp_newtype (a, b))
  let pack ?loc ?attrs a = mk ?loc ?attrs (Pexp_pack a)
  let open_ ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_open (a, b, c))
  let extension ?loc ?attrs a = mk ?loc ?attrs (Pexp_extension a)

  let case lhs ?guard rhs =
    {
     pc_lhs = lhs;
     pc_guard = guard;
     pc_rhs = rhs;
    }
end

module Mty = struct
  let mk ?(loc = !default_loc) ?(attrs = []) d =
    {pmty_desc = d; pmty_loc = loc; pmty_attributes = attrs}
  let attr d a = {d with pmty_attributes = d.pmty_attributes @ [a]}

  let ident ?loc ?attrs a = mk ?loc ?attrs (Pmty_ident a)
  let alias ?loc ?attrs a = mk ?loc ?attrs (Pmty_alias a)
  let signature ?loc ?attrs a = mk ?loc ?attrs (Pmty_signature a)
  let functor_ ?loc ?attrs a b c = mk ?loc ?attrs (Pmty_functor (a, b, c))
  let with_ ?loc ?attrs a b = mk ?loc ?attrs (Pmty_with (a, b))
  let typeof_ ?loc ?attrs a = mk ?loc ?attrs (Pmty_typeof a)
  let extension ?loc ?attrs a = mk ?loc ?attrs (Pmty_extension a)
end

module Mod = struct
let mk ?(loc = !default_loc) ?(attrs = []) d =
  {pmod_desc = d; pmod_loc = loc; pmod_attributes = attrs}
  let attr d a = {d with pmod_attributes = d.pmod_attributes @ [a]}

  let ident ?loc ?attrs x = mk ?loc ?attrs (Pmod_ident x)
  let structure ?loc ?attrs x = mk ?loc ?attrs (Pmod_structure x)
  let functor_ ?loc ?attrs arg arg_ty body =
    mk ?loc ?attrs (Pmod_functor (arg, arg_ty, body))
  let apply ?loc ?attrs m1 m2 = mk ?loc ?attrs (Pmod_apply (m1, m2))
  let constraint_ ?loc ?attrs m mty = mk ?loc ?attrs (Pmod_constraint (m, mty))
  let unpack ?loc ?attrs e = mk ?loc ?attrs (Pmod_unpack e)
  let extension ?loc ?attrs a = mk ?loc ?attrs (Pmod_extension a)
end

module Sig = struct
  let mk ?(loc = !default_loc) d = {psig_desc = d; psig_loc = loc}

  let value ?loc a = mk ?loc (Psig_value a)
  let type_ ?loc a = mk ?loc (Psig_type a)
  let type_extension ?loc a = mk ?loc (Psig_typext a)
  let exception_ ?loc a = mk ?loc (Psig_exception a)
  let module_ ?loc a = mk ?loc (Psig_module a)
  let rec_module ?loc a = mk ?loc (Psig_recmodule a)
  let modtype ?loc a = mk ?loc (Psig_modtype a)
  let open_ ?loc a = mk ?loc (Psig_open a)
  let include_ ?loc a = mk ?loc (Psig_include a)
  let class_ ?loc a = mk ?loc (Psig_class a)
  let class_type ?loc a = mk ?loc (Psig_class_type a)
  let extension ?loc ?(attrs = []) a = mk ?loc (Psig_extension (a, attrs))
  let attribute ?loc a = mk ?loc (Psig_attribute a)
  let text txt =
    List.map
      (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
      txt
end

module Str = struct
  let mk ?(loc = !default_loc) d = {pstr_desc = d; pstr_loc = loc}

  let eval ?loc ?(attrs = []) a = mk ?loc (Pstr_eval (a, attrs))
  let value ?loc a b = mk ?loc (Pstr_value (a, b))
  let primitive ?loc a = mk ?loc (Pstr_primitive a)
  let type_ ?loc a = mk ?loc (Pstr_type a)
  let type_extension ?loc a = mk ?loc (Pstr_typext a)
  let exception_ ?loc a = mk ?loc (Pstr_exception a)
  let module_ ?loc a = mk ?loc (Pstr_module a)
  let rec_module ?loc a = mk ?loc (Pstr_recmodule a)
  let modtype ?loc a = mk ?loc (Pstr_modtype a)
  let open_ ?loc a = mk ?loc (Pstr_open a)
  let class_ ?loc a = mk ?loc (Pstr_class a)
  let class_type ?loc a = mk ?loc (Pstr_class_type a)
  let include_ ?loc a = mk ?loc (Pstr_include a)
  let extension ?loc ?(attrs = []) a = mk ?loc (Pstr_extension (a, attrs))
  let attribute ?loc a = mk ?loc (Pstr_attribute a)
  let text txt =
    List.map
      (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
      txt
end

module Cl = struct
  let mk ?(loc = !default_loc) ?(attrs = []) d =
    {
     pcl_desc = d;
     pcl_loc = loc;
     pcl_attributes = attrs;
    }
  let attr d a = {d with pcl_attributes = d.pcl_attributes @ [a]}

  let constr ?loc ?attrs a b = mk ?loc ?attrs (Pcl_constr (a, b))
  let structure ?loc ?attrs a = mk ?loc ?attrs (Pcl_structure a)
  let fun_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pcl_fun (a, b, c, d))
  let apply ?loc ?attrs a b = mk ?loc ?attrs (Pcl_apply (a, b))
  let let_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcl_let (a, b, c))
  let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pcl_constraint (a, b))
  let extension ?loc ?attrs a = mk ?loc ?attrs (Pcl_extension a)
end

module Cty = struct
  let mk ?(loc = !default_loc) ?(attrs = []) d =
    {
     pcty_desc = d;
     pcty_loc = loc;
     pcty_attributes = attrs;
    }
  let attr d a = {d with pcty_attributes = d.pcty_attributes @ [a]}

  let constr ?loc ?attrs a b = mk ?loc ?attrs (Pcty_constr (a, b))
  let signature ?loc ?attrs a = mk ?loc ?attrs (Pcty_signature a)
  let arrow ?loc ?attrs a b c = mk ?loc ?attrs (Pcty_arrow (a, b, c))
  let extension ?loc ?attrs a = mk ?loc ?attrs (Pcty_extension a)
end

module Ctf = struct
  let mk ?(loc = !default_loc) ?(attrs = [])
           ?(docs = empty_docs) d =
    {
     pctf_desc = d;
     pctf_loc = loc;
     pctf_attributes = add_docs_attrs docs attrs;
    }

  let inherit_ ?loc ?attrs a = mk ?loc ?attrs (Pctf_inherit a)
  let val_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pctf_val (a, b, c, d))
  let method_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pctf_method (a, b, c, d))
  let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pctf_constraint (a, b))
  let extension ?loc ?attrs a = mk ?loc ?attrs (Pctf_extension a)
  let attribute ?loc a = mk ?loc (Pctf_attribute a)
  let text txt =
    List.map
      (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
      txt

  let attr d a = {d with pctf_attributes = d.pctf_attributes @ [a]}

end

module Cf = struct
  let mk ?(loc = !default_loc) ?(attrs = [])
        ?(docs = empty_docs) d =
    {
     pcf_desc = d;
     pcf_loc = loc;
     pcf_attributes = add_docs_attrs docs attrs;
    }

  let inherit_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_inherit (a, b, c))
  let val_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_val (a, b, c))
  let method_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_method (a, b, c))
  let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pcf_constraint (a, b))
  let initializer_ ?loc ?attrs a = mk ?loc ?attrs (Pcf_initializer a)
  let extension ?loc ?attrs a = mk ?loc ?attrs (Pcf_extension a)
  let attribute ?loc a = mk ?loc (Pcf_attribute a)
  let text txt =
    List.map
      (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
      txt

  let virtual_ ct = Cfk_virtual ct
  let concrete o e = Cfk_concrete (o, e)

  let attr d a = {d with pcf_attributes = d.pcf_attributes @ [a]}

end

module Val = struct
  let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
        ?(prim = []) name typ =
    {
     pval_name = name;
     pval_type = typ;
     pval_attributes = add_docs_attrs docs attrs;
     pval_loc = loc;
     pval_prim = prim;
    }
end

module Md = struct
  let mk ?(loc = !default_loc) ?(attrs = [])
        ?(docs = empty_docs) ?(text = []) name typ =
    {
     pmd_name = name;
     pmd_type = typ;
     pmd_attributes =
       add_text_attrs text (add_docs_attrs docs attrs);
     pmd_loc = loc;
    }
end

module Mtd = struct
  let mk ?(loc = !default_loc) ?(attrs = [])
        ?(docs = empty_docs) ?(text = []) ?typ name =
    {
     pmtd_name = name;
     pmtd_type = typ;
     pmtd_attributes =
       add_text_attrs text (add_docs_attrs docs attrs);
     pmtd_loc = loc;
    }
end

module Mb = struct
  let mk ?(loc = !default_loc) ?(attrs = [])
        ?(docs = empty_docs) ?(text = []) name expr =
    {
     pmb_name = name;
     pmb_expr = expr;
     pmb_attributes =
       add_text_attrs text (add_docs_attrs docs attrs);
     pmb_loc = loc;
    }
end

module Opn = struct
  let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
        ?(override = Fresh) lid =
    {
     popen_lid = lid;
     popen_override = override;
     popen_loc = loc;
     popen_attributes = add_docs_attrs docs attrs;
    }
end

module Incl = struct
  let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs) mexpr =
    {
     pincl_mod = mexpr;
     pincl_loc = loc;
     pincl_attributes = add_docs_attrs docs attrs;
    }

end

module Vb = struct
  let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
        ?(text = []) pat expr =
    {
     pvb_pat = pat;
     pvb_expr = expr;
     pvb_attributes =
       add_text_attrs text (add_docs_attrs docs attrs);
     pvb_loc = loc;
    }
end

module Ci = struct
  let mk ?(loc = !default_loc) ?(attrs = [])
        ?(docs = empty_docs) ?(text = [])
        ?(virt = Concrete) ?(params = []) name expr =
    {
     pci_virt = virt;
     pci_params = params;
     pci_name = name;
     pci_expr = expr;
     pci_attributes =
       add_text_attrs text (add_docs_attrs docs attrs);
     pci_loc = loc;
    }
end

module Type = struct
  let mk ?(loc = !default_loc) ?(attrs = [])
        ?(docs = empty_docs) ?(text = [])
      ?(params = [])
      ?(cstrs = [])
      ?(kind = Ptype_abstract)
      ?(priv = Public)
      ?manifest
      name =
    {
     ptype_name = name;
     ptype_params = params;
     ptype_cstrs = cstrs;
     ptype_kind = kind;
     ptype_private = priv;
     ptype_manifest = manifest;
     ptype_attributes =
       add_text_attrs text (add_docs_attrs docs attrs);
     ptype_loc = loc;
    }

  let constructor ?(loc = !default_loc) ?(attrs = []) ?(info = empty_info)
        ?(args = []) ?res name =
    {
     pcd_name = name;
     pcd_args = args;
     pcd_res = res;
     pcd_loc = loc;
     pcd_attributes = add_info_attrs info attrs;
    }

  let field ?(loc = !default_loc) ?(attrs = []) ?(info = empty_info)
        ?(mut = Immutable) name typ =
    {
     pld_name = name;
     pld_mutable = mut;
     pld_type = typ;
     pld_loc = loc;
     pld_attributes = add_info_attrs info attrs;
    }

end

(** Type extensions *)
module Te = struct
  let mk ?(attrs = []) ?(docs = empty_docs)
        ?(params = []) ?(priv = Public) path constructors =
    {
     ptyext_path = path;
     ptyext_params = params;
     ptyext_constructors = constructors;
     ptyext_private = priv;
     ptyext_attributes = add_docs_attrs docs attrs;
    }

  let constructor ?(loc = !default_loc) ?(attrs = [])
        ?(docs = empty_docs) ?(info = empty_info) name kind =
    {
     pext_name = name;
     pext_kind = kind;
     pext_loc = loc;
     pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);
    }

  let decl ?(loc = !default_loc) ?(attrs = [])
        ?(docs = empty_docs) ?(info = empty_info) ?(args = []) ?res name =
    {
     pext_name = name;
     pext_kind = Pext_decl(args, res);
     pext_loc = loc;
     pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);
    }

  let rebind ?(loc = !default_loc) ?(attrs = [])
        ?(docs = empty_docs) ?(info = empty_info) name lid =
    {
     pext_name = name;
     pext_kind = Pext_rebind lid;
     pext_loc = loc;
     pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);
    }

end

module Csig = struct
  let mk self fields =
    {
     pcsig_self = self;
     pcsig_fields = fields;
    }
end

module Cstr = struct
  let mk self fields =
    {
     pcstr_self = self;
     pcstr_fields = fields;
    }
end


end
module Syntaxerr : sig 
#1 "syntaxerr.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1997 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Auxiliary type for reporting syntax errors *)

open Format

type error =
    Unclosed of Location.t * string * Location.t * string
  | Expecting of Location.t * string
  | Not_expecting of Location.t * string
  | Applicative_path of Location.t
  | Variable_in_scope of Location.t * string
  | Other of Location.t
  | Ill_formed_ast of Location.t * string

exception Error of error
exception Escape_error

val report_error: formatter -> error -> unit
 (* Deprecated.  Use Location.{error_of_exn, report_error}. *)

val location_of_error: error -> Location.t
val ill_formed_ast: Location.t -> string -> 'a

end = struct
#1 "syntaxerr.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1997 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Auxiliary type for reporting syntax errors *)

type error =
    Unclosed of Location.t * string * Location.t * string
  | Expecting of Location.t * string
  | Not_expecting of Location.t * string
  | Applicative_path of Location.t
  | Variable_in_scope of Location.t * string
  | Other of Location.t
  | Ill_formed_ast of Location.t * string

exception Error of error
exception Escape_error

let prepare_error = function
  | Unclosed(opening_loc, opening, closing_loc, closing) ->
      Location.errorf ~loc:closing_loc
        ~sub:[
          Location.errorf ~loc:opening_loc
            "This '%s' might be unmatched" opening
        ]
        ~if_highlight:
          (Printf.sprintf "Syntax error: '%s' expected, \
                           the highlighted '%s' might be unmatched"
             closing opening)
        "Syntax error: '%s' expected" closing

  | Expecting (loc, nonterm) ->
      Location.errorf ~loc "Syntax error: %s expected." nonterm
  | Not_expecting (loc, nonterm) ->
      Location.errorf ~loc "Syntax error: %s not expected." nonterm
  | Applicative_path loc ->
      Location.errorf ~loc
        "Syntax error: applicative paths of the form F(X).t \
         are not supported when the option -no-app-func is set."
  | Variable_in_scope (loc, var) ->
      Location.errorf ~loc
        "In this scoped type, variable '%s \
         is reserved for the local type %s."
         var var
  | Other loc ->
      Location.errorf ~loc "Syntax error"
  | Ill_formed_ast (loc, s) ->
      Location.errorf ~loc "broken invariant in parsetree: %s" s

let () =
  Location.register_error_of_exn
    (function
      | Error err -> Some (prepare_error err)
      | _ -> None
    )


let report_error ppf err =
  Location.report_error ppf (prepare_error err)

let location_of_error = function
  | Unclosed(l,_,_,_)
  | Applicative_path l
  | Variable_in_scope(l,_)
  | Other l
  | Not_expecting (l, _)
  | Ill_formed_ast (l, _)
  | Expecting (l, _) -> l


let ill_formed_ast loc s =
  raise (Error (Ill_formed_ast (loc, s)))

end
module Parser : sig 
#1 "parser.mli"
type token =
  | AMPERAMPER
  | AMPERSAND
  | AND
  | AS
  | ASSERT
  | BACKQUOTE
  | BANG
  | BAR
  | BARBAR
  | BARRBRACKET
  | BEGIN
  | CHAR of (char)
  | CLASS
  | COLON
  | COLONCOLON
  | COLONEQUAL
  | COLONGREATER
  | COMMA
  | CONSTRAINT
  | DO
  | DONE
  | DOT
  | DOTDOT
  | DOWNTO
  | ELSE
  | END
  | EOF
  | EQUAL
  | EXCEPTION
  | EXTERNAL
  | FALSE
  | FLOAT of (string)
  | FOR
  | FUN
  | FUNCTION
  | FUNCTOR
  | GREATER
  | GREATERRBRACE
  | GREATERRBRACKET
  | IF
  | IN
  | INCLUDE
  | INFIXOP0 of (string)
  | INFIXOP1 of (string)
  | INFIXOP2 of (string)
  | INFIXOP3 of (string)
  | INFIXOP4 of (string)
  | INHERIT
  | INITIALIZER
  | INT of (int)
  | INT32 of (int32)
  | INT64 of (int64)
  | LABEL of (string)
  | LAZY
  | LBRACE
  | LBRACELESS
  | LBRACKET
  | LBRACKETBAR
  | LBRACKETLESS
  | LBRACKETGREATER
  | LBRACKETPERCENT
  | LBRACKETPERCENTPERCENT
  | LESS
  | LESSMINUS
  | LET
  | LIDENT of (string)
  | LPAREN
  | LBRACKETAT
  | LBRACKETATAT
  | LBRACKETATATAT
  | MATCH
  | METHOD
  | MINUS
  | MINUSDOT
  | MINUSGREATER
  | MODULE
  | MUTABLE
  | NATIVEINT of (nativeint)
  | NEW
  | NONREC
  | OBJECT
  | OF
  | OPEN
  | OPTLABEL of (string)
  | OR
  | PERCENT
  | PLUS
  | PLUSDOT
  | PLUSEQ
  | PREFIXOP of (string)
  | PRIVATE
  | QUESTION
  | QUOTE
  | RBRACE
  | RBRACKET
  | REC
  | RPAREN
  | SEMI
  | SEMISEMI
  | SHARP
  | SHARPOP of (string)
  | SIG
  | STAR
  | STRING of (string * string option)
  | STRUCT
  | THEN
  | TILDE
  | TO
  | TRUE
  | TRY
  | TYPE
  | UIDENT of (string)
  | UNDERSCORE
  | VAL
  | VIRTUAL
  | WHEN
  | WHILE
  | WITH
  | COMMENT of (string * Location.t)
  | DOCSTRING of (Docstrings.docstring)
  | EOL

val implementation :
  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> Parsetree.structure
val interface :
  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> Parsetree.signature
val toplevel_phrase :
  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> Parsetree.toplevel_phrase
val use_file :
  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> Parsetree.toplevel_phrase list
val parse_core_type :
  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> Parsetree.core_type
val parse_expression :
  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> Parsetree.expression
val parse_pattern :
  (Lexing.lexbuf  -> token) -> Lexing.lexbuf -> Parsetree.pattern

end = struct
#1 "parser.ml"
type token =
  | AMPERAMPER
  | AMPERSAND
  | AND
  | AS
  | ASSERT
  | BACKQUOTE
  | BANG
  | BAR
  | BARBAR
  | BARRBRACKET
  | BEGIN
  | CHAR of (char)
  | CLASS
  | COLON
  | COLONCOLON
  | COLONEQUAL
  | COLONGREATER
  | COMMA
  | CONSTRAINT
  | DO
  | DONE
  | DOT
  | DOTDOT
  | DOWNTO
  | ELSE
  | END
  | EOF
  | EQUAL
  | EXCEPTION
  | EXTERNAL
  | FALSE
  | FLOAT of (string)
  | FOR
  | FUN
  | FUNCTION
  | FUNCTOR
  | GREATER
  | GREATERRBRACE
  | GREATERRBRACKET
  | IF
  | IN
  | INCLUDE
  | INFIXOP0 of (string)
  | INFIXOP1 of (string)
  | INFIXOP2 of (string)
  | INFIXOP3 of (string)
  | INFIXOP4 of (string)
  | INHERIT
  | INITIALIZER
  | INT of (int)
  | INT32 of (int32)
  | INT64 of (int64)
  | LABEL of (string)
  | LAZY
  | LBRACE
  | LBRACELESS
  | LBRACKET
  | LBRACKETBAR
  | LBRACKETLESS
  | LBRACKETGREATER
  | LBRACKETPERCENT
  | LBRACKETPERCENTPERCENT
  | LESS
  | LESSMINUS
  | LET
  | LIDENT of (string)
  | LPAREN
  | LBRACKETAT
  | LBRACKETATAT
  | LBRACKETATATAT
  | MATCH
  | METHOD
  | MINUS
  | MINUSDOT
  | MINUSGREATER
  | MODULE
  | MUTABLE
  | NATIVEINT of (nativeint)
  | NEW
  | NONREC
  | OBJECT
  | OF
  | OPEN
  | OPTLABEL of (string)
  | OR
  | PERCENT
  | PLUS
  | PLUSDOT
  | PLUSEQ
  | PREFIXOP of (string)
  | PRIVATE
  | QUESTION
  | QUOTE
  | RBRACE
  | RBRACKET
  | REC
  | RPAREN
  | SEMI
  | SEMISEMI
  | SHARP
  | SHARPOP of (string)
  | SIG
  | STAR
  | STRING of (string * string option)
  | STRUCT
  | THEN
  | TILDE
  | TO
  | TRUE
  | TRY
  | TYPE
  | UIDENT of (string)
  | UNDERSCORE
  | VAL
  | VIRTUAL
  | WHEN
  | WHILE
  | WITH
  | COMMENT of (string * Location.t)
  | DOCSTRING of (Docstrings.docstring)
  | EOL

open Parsing;;
let _ = parse_error;;
# 16 "parsing/parser.mly"
open Location
open Asttypes
open Longident
open Parsetree
open Ast_helper
open Docstrings

let mktyp d = Typ.mk ~loc:(symbol_rloc()) d
let mkpat d = Pat.mk ~loc:(symbol_rloc()) d
let mkexp d = Exp.mk ~loc:(symbol_rloc()) d
let mkmty d = Mty.mk ~loc:(symbol_rloc()) d
let mksig d = Sig.mk ~loc:(symbol_rloc()) d
let mkmod d = Mod.mk ~loc:(symbol_rloc()) d
let mkstr d = Str.mk ~loc:(symbol_rloc()) d
let mkclass d = Cl.mk ~loc:(symbol_rloc()) d
let mkcty d = Cty.mk ~loc:(symbol_rloc()) d
let mkctf ?attrs ?docs d =
  Ctf.mk ~loc:(symbol_rloc()) ?attrs ?docs d
let mkcf ?attrs ?docs d =
  Cf.mk ~loc:(symbol_rloc()) ?attrs ?docs d

let mkrhs rhs pos = mkloc rhs (rhs_loc pos)
let mkoption d =
  let loc = {d.ptyp_loc with loc_ghost = true} in
  Typ.mk ~loc (Ptyp_constr(mkloc (Ldot (Lident "*predef*", "option")) loc,[d]))

let reloc_pat x = { x with ppat_loc = symbol_rloc () };;
let reloc_exp x = { x with pexp_loc = symbol_rloc () };;

let mkoperator name pos =
  let loc = rhs_loc pos in
  Exp.mk ~loc (Pexp_ident(mkloc (Lident name) loc))

let mkpatvar name pos =
  Pat.mk ~loc:(rhs_loc pos) (Ppat_var (mkrhs name pos))

(*
  Ghost expressions and patterns:
  expressions and patterns that do not appear explicitly in the
  source file they have the loc_ghost flag set to true.
  Then the profiler will not try to instrument them and the
  -annot option will not try to display their type.

  Every grammar rule that generates an element with a location must
  make at most one non-ghost element, the topmost one.

  How to tell whether your location must be ghost:
  A location corresponds to a range of characters in the source file.
  If the location contains a piece of code that is syntactically
  valid (according to the documentation), and corresponds to the
  AST node, then the location must be real; in all other cases,
  it must be ghost.
*)
let ghexp d = Exp.mk ~loc:(symbol_gloc ()) d
let ghpat d = Pat.mk ~loc:(symbol_gloc ()) d
let ghtyp d = Typ.mk ~loc:(symbol_gloc ()) d
let ghloc d = { txt = d; loc = symbol_gloc () }
let ghstr d = Str.mk ~loc:(symbol_gloc()) d

let ghunit () =
  ghexp (Pexp_construct (mknoloc (Lident "()"), None))

let mkinfix arg1 name arg2 =
  mkexp(Pexp_apply(mkoperator name 2, ["", arg1; "", arg2]))

let neg_float_string f =
  if String.length f > 0 && f.[0] = '-'
  then String.sub f 1 (String.length f - 1)
  else "-" ^ f

let mkuminus name arg =
  match name, arg.pexp_desc with
  | "-", Pexp_constant(Const_int n) ->
      mkexp(Pexp_constant(Const_int(-n)))
  | "-", Pexp_constant(Const_int32 n) ->
      mkexp(Pexp_constant(Const_int32(Int32.neg n)))
  | "-", Pexp_constant(Const_int64 n) ->
      mkexp(Pexp_constant(Const_int64(Int64.neg n)))
  | "-", Pexp_constant(Const_nativeint n) ->
      mkexp(Pexp_constant(Const_nativeint(Nativeint.neg n)))
  | ("-" | "-."), Pexp_constant(Const_float f) ->
      mkexp(Pexp_constant(Const_float(neg_float_string f)))
  | _ ->
      mkexp(Pexp_apply(mkoperator ("~" ^ name) 1, ["", arg]))

let mkuplus name arg =
  let desc = arg.pexp_desc in
  match name, desc with
  | "+", Pexp_constant(Const_int _)
  | "+", Pexp_constant(Const_int32 _)
  | "+", Pexp_constant(Const_int64 _)
  | "+", Pexp_constant(Const_nativeint _)
  | ("+" | "+."), Pexp_constant(Const_float _) -> mkexp desc
  | _ ->
      mkexp(Pexp_apply(mkoperator ("~" ^ name) 1, ["", arg]))

let mkexp_cons consloc args loc =
  Exp.mk ~loc (Pexp_construct(mkloc (Lident "::") consloc, Some args))

let mkpat_cons consloc args loc =
  Pat.mk ~loc (Ppat_construct(mkloc (Lident "::") consloc, Some args))

let rec mktailexp nilloc = function
    [] ->
      let loc = { nilloc with loc_ghost = true } in
      let nil = { txt = Lident "[]"; loc = loc } in
      Exp.mk ~loc (Pexp_construct (nil, None))
  | e1 :: el ->
      let exp_el = mktailexp nilloc el in
      let loc = {loc_start = e1.pexp_loc.loc_start;
               loc_end = exp_el.pexp_loc.loc_end;
               loc_ghost = true}
      in
      let arg = Exp.mk ~loc (Pexp_tuple [e1; exp_el]) in
      mkexp_cons {loc with loc_ghost = true} arg loc

let rec mktailpat nilloc = function
    [] ->
      let loc = { nilloc with loc_ghost = true } in
      let nil = { txt = Lident "[]"; loc = loc } in
      Pat.mk ~loc (Ppat_construct (nil, None))
  | p1 :: pl ->
      let pat_pl = mktailpat nilloc pl in
      let loc = {loc_start = p1.ppat_loc.loc_start;
               loc_end = pat_pl.ppat_loc.loc_end;
               loc_ghost = true}
      in
      let arg = Pat.mk ~loc (Ppat_tuple [p1; pat_pl]) in
      mkpat_cons {loc with loc_ghost = true} arg loc

let mkstrexp e attrs =
  { pstr_desc = Pstr_eval (e, attrs); pstr_loc = e.pexp_loc }

let mkexp_constraint e (t1, t2) =
  match t1, t2 with
  | Some t, None -> ghexp(Pexp_constraint(e, t))
  | _, Some t -> ghexp(Pexp_coerce(e, t1, t))
  | None, None -> assert false

let array_function str name =
  ghloc (Ldot(Lident str, (if !Clflags.fast then "unsafe_" ^ name else name)))

let syntax_error () =
  raise Syntaxerr.Escape_error

let unclosed opening_name opening_num closing_name closing_num =
  raise(Syntaxerr.Error(Syntaxerr.Unclosed(rhs_loc opening_num, opening_name,
                                           rhs_loc closing_num, closing_name)))

let expecting pos nonterm =
    raise Syntaxerr.(Error(Expecting(rhs_loc pos, nonterm)))

let not_expecting pos nonterm =
    raise Syntaxerr.(Error(Not_expecting(rhs_loc pos, nonterm)))

let bigarray_function str name =
  ghloc (Ldot(Ldot(Lident "Bigarray", str), name))

let bigarray_untuplify = function
    { pexp_desc = Pexp_tuple explist; pexp_loc = _ } -> explist
  | exp -> [exp]

let bigarray_get arr arg =
  let get = if !Clflags.fast then "unsafe_get" else "get" in
  match bigarray_untuplify arg with
    [c1] ->
      mkexp(Pexp_apply(ghexp(Pexp_ident(bigarray_function "Array1" get)),
                       ["", arr; "", c1]))
  | [c1;c2] ->
      mkexp(Pexp_apply(ghexp(Pexp_ident(bigarray_function "Array2" get)),
                       ["", arr; "", c1; "", c2]))
  | [c1;c2;c3] ->
      mkexp(Pexp_apply(ghexp(Pexp_ident(bigarray_function "Array3" get)),
                       ["", arr; "", c1; "", c2; "", c3]))
  | coords ->
      mkexp(Pexp_apply(ghexp(Pexp_ident(bigarray_function "Genarray" "get")),
                       ["", arr; "", ghexp(Pexp_array coords)]))

let bigarray_set arr arg newval =
  let set = if !Clflags.fast then "unsafe_set" else "set" in
  match bigarray_untuplify arg with
    [c1] ->
      mkexp(Pexp_apply(ghexp(Pexp_ident(bigarray_function "Array1" set)),
                       ["", arr; "", c1; "", newval]))
  | [c1;c2] ->
      mkexp(Pexp_apply(ghexp(Pexp_ident(bigarray_function "Array2" set)),
                       ["", arr; "", c1; "", c2; "", newval]))
  | [c1;c2;c3] ->
      mkexp(Pexp_apply(ghexp(Pexp_ident(bigarray_function "Array3" set)),
                       ["", arr; "", c1; "", c2; "", c3; "", newval]))
  | coords ->
      mkexp(Pexp_apply(ghexp(Pexp_ident(bigarray_function "Genarray" "set")),
                       ["", arr;
                        "", ghexp(Pexp_array coords);
                        "", newval]))

let lapply p1 p2 =
  if !Clflags.applicative_functors
  then Lapply(p1, p2)
  else raise (Syntaxerr.Error(Syntaxerr.Applicative_path (symbol_rloc())))

let exp_of_label lbl pos =
  mkexp (Pexp_ident(mkrhs (Lident(Longident.last lbl)) pos))

let pat_of_label lbl pos =
  mkpat (Ppat_var (mkrhs (Longident.last lbl) pos))

let check_variable vl loc v =
  if List.mem v vl then
    raise Syntaxerr.(Error(Variable_in_scope(loc,v)))

let varify_constructors var_names t =
  let rec loop t =
    let desc =
      match t.ptyp_desc with
      | Ptyp_any -> Ptyp_any
      | Ptyp_var x ->
          check_variable var_names t.ptyp_loc x;
          Ptyp_var x
      | Ptyp_arrow (label,core_type,core_type') ->
          Ptyp_arrow(label, loop core_type, loop core_type')
      | Ptyp_tuple lst -> Ptyp_tuple (List.map loop lst)
      | Ptyp_constr( { txt = Lident s }, []) when List.mem s var_names ->
          Ptyp_var s
      | Ptyp_constr(longident, lst) ->
          Ptyp_constr(longident, List.map loop lst)
      | Ptyp_object (lst, o) ->
          Ptyp_object
            (List.map (fun (s, attrs, t) -> (s, attrs, loop t)) lst, o)
      | Ptyp_class (longident, lst) ->
          Ptyp_class (longident, List.map loop lst)
      | Ptyp_alias(core_type, string) ->
          check_variable var_names t.ptyp_loc string;
          Ptyp_alias(loop core_type, string)
      | Ptyp_variant(row_field_list, flag, lbl_lst_option) ->
          Ptyp_variant(List.map loop_row_field row_field_list,
                       flag, lbl_lst_option)
      | Ptyp_poly(string_lst, core_type) ->
          List.iter (check_variable var_names t.ptyp_loc) string_lst;
          Ptyp_poly(string_lst, loop core_type)
      | Ptyp_package(longident,lst) ->
          Ptyp_package(longident,List.map (fun (n,typ) -> (n,loop typ) ) lst)
      | Ptyp_extension (s, arg) ->
          Ptyp_extension (s, arg)
    in
    {t with ptyp_desc = desc}
  and loop_row_field  =
    function
      | Rtag(label,attrs,flag,lst) ->
          Rtag(label,attrs,flag,List.map loop lst)
      | Rinherit t ->
          Rinherit (loop t)
  in
  loop t

let wrap_type_annotation newtypes core_type body =
  let exp = mkexp(Pexp_constraint(body,core_type)) in
  let exp =
    List.fold_right (fun newtype exp -> mkexp (Pexp_newtype (newtype, exp)))
      newtypes exp
  in
  (exp, ghtyp(Ptyp_poly(newtypes,varify_constructors newtypes core_type)))

let wrap_exp_attrs body (ext, attrs) =
  (* todo: keep exact location for the entire attribute *)
  let body = {body with pexp_attributes = attrs @ body.pexp_attributes} in
  match ext with
  | None -> body
  | Some id -> ghexp(Pexp_extension (id, PStr [mkstrexp body []]))

let mkexp_attrs d attrs =
  wrap_exp_attrs (mkexp d) attrs

let text_str pos = Str.text (rhs_text pos)
let text_sig pos = Sig.text (rhs_text pos)
let text_cstr pos = Cf.text (rhs_text pos)
let text_csig pos = Ctf.text (rhs_text pos)
let text_def pos = [Ptop_def (Str.text (rhs_text pos))]

let extra_text text pos items =
  let pre_extras = rhs_pre_extra_text pos in
  let post_extras = rhs_post_extra_text pos in
    text pre_extras @ items @ text post_extras

let extra_str pos items = extra_text Str.text pos items
let extra_sig pos items = extra_text Sig.text pos items
let extra_cstr pos items = extra_text Cf.text pos items
let extra_csig pos items = extra_text Ctf.text pos items
let extra_def pos items =
  extra_text (fun txt -> [Ptop_def (Str.text txt)]) pos items

let add_nonrec rf attrs pos =
  match rf with
  | Recursive -> attrs
  | Nonrecursive ->
      let name = { txt = "nonrec"; loc = rhs_loc pos } in
        (name, PStr []) :: attrs

type let_binding =
  { lb_pattern: pattern;
    lb_expression: expression;
    lb_attributes: attributes;
    lb_docs: docs Lazy.t;
    lb_text: text Lazy.t;
    lb_loc: Location.t; }

type let_bindings =
  { lbs_bindings: let_binding list;
    lbs_rec: rec_flag;
    lbs_extension: string Asttypes.loc option;
    lbs_attributes: attributes;
    lbs_loc: Location.t }

let mklb (p, e) attrs =
  { lb_pattern = p;
    lb_expression = e;
    lb_attributes = attrs;
    lb_docs = symbol_docs_lazy ();
    lb_text = symbol_text_lazy ();
    lb_loc = symbol_rloc (); }

let mklbs (ext, attrs) rf lb =
  { lbs_bindings = [lb];
    lbs_rec = rf;
    lbs_extension = ext ;
    lbs_attributes = attrs;
    lbs_loc = symbol_rloc (); }

let addlb lbs lb =
  { lbs with lbs_bindings = lb :: lbs.lbs_bindings }

let val_of_let_bindings lbs =
  let str =
    match lbs.lbs_bindings with
    | [ {lb_pattern = { ppat_desc = Ppat_any; ppat_loc = _ }; _} as lb ] ->
        let exp = wrap_exp_attrs lb.lb_expression
                    (None, lbs.lbs_attributes) in
        mkstr (Pstr_eval (exp, lb.lb_attributes))
    | bindings ->
        if lbs.lbs_attributes <> [] then
          raise Syntaxerr.(Error(Not_expecting(lbs.lbs_loc, "attributes")));
        let bindings =
          List.map
            (fun lb ->
               Vb.mk ~loc:lb.lb_loc ~attrs:lb.lb_attributes
                 ~docs:(Lazy.force lb.lb_docs)
                 ~text:(Lazy.force lb.lb_text)
                 lb.lb_pattern lb.lb_expression)
            bindings
        in
        mkstr(Pstr_value(lbs.lbs_rec, List.rev bindings))
  in
  match lbs.lbs_extension with
  | None -> str
  | Some id -> ghstr (Pstr_extension((id, PStr [str]), []))

let expr_of_let_bindings lbs body =
  let bindings =
    List.map
      (fun lb ->
         if lb.lb_attributes <> [] then
           raise Syntaxerr.(Error(Not_expecting(lb.lb_loc, "item attribute")));
         Vb.mk ~loc:lb.lb_loc lb.lb_pattern lb.lb_expression)
      lbs.lbs_bindings
  in
    mkexp_attrs (Pexp_let(lbs.lbs_rec, List.rev bindings, body))
      (lbs.lbs_extension, lbs.lbs_attributes)

let class_of_let_bindings lbs body =
  let bindings =
    List.map
      (fun lb ->
         if lb.lb_attributes <> [] then
           raise Syntaxerr.(Error(Not_expecting(lb.lb_loc, "item attribute")));
         Vb.mk ~loc:lb.lb_loc lb.lb_pattern lb.lb_expression)
      lbs.lbs_bindings
  in
    if lbs.lbs_extension <> None then
      raise Syntaxerr.(Error(Not_expecting(lbs.lbs_loc, "extension")));
    if lbs.lbs_attributes <> [] then
      raise Syntaxerr.(Error(Not_expecting(lbs.lbs_loc, "attributes")));
    mkclass(Pcl_let (lbs.lbs_rec, List.rev bindings, body))

# 511 "parsing/parser.ml"
let yytransl_const = [|
  257 (* AMPERAMPER *);
  258 (* AMPERSAND *);
  259 (* AND *);
  260 (* AS *);
  261 (* ASSERT *);
  262 (* BACKQUOTE *);
  263 (* BANG *);
  264 (* BAR *);
  265 (* BARBAR *);
  266 (* BARRBRACKET *);
  267 (* BEGIN *);
  269 (* CLASS *);
  270 (* COLON *);
  271 (* COLONCOLON *);
  272 (* COLONEQUAL *);
  273 (* COLONGREATER *);
  274 (* COMMA *);
  275 (* CONSTRAINT *);
  276 (* DO *);
  277 (* DONE *);
  278 (* DOT *);
  279 (* DOTDOT *);
  280 (* DOWNTO *);
  281 (* ELSE *);
  282 (* END *);
    0 (* EOF *);
  283 (* EQUAL *);
  284 (* EXCEPTION *);
  285 (* EXTERNAL *);
  286 (* FALSE *);
  288 (* FOR *);
  289 (* FUN *);
  290 (* FUNCTION *);
  291 (* FUNCTOR *);
  292 (* GREATER *);
  293 (* GREATERRBRACE *);
  294 (* GREATERRBRACKET *);
  295 (* IF *);
  296 (* IN *);
  297 (* INCLUDE *);
  303 (* INHERIT *);
  304 (* INITIALIZER *);
  309 (* LAZY *);
  310 (* LBRACE *);
  311 (* LBRACELESS *);
  312 (* LBRACKET *);
  313 (* LBRACKETBAR *);
  314 (* LBRACKETLESS *);
  315 (* LBRACKETGREATER *);
  316 (* LBRACKETPERCENT *);
  317 (* LBRACKETPERCENTPERCENT *);
  318 (* LESS *);
  319 (* LESSMINUS *);
  320 (* LET *);
  322 (* LPAREN *);
  323 (* LBRACKETAT *);
  324 (* LBRACKETATAT *);
  325 (* LBRACKETATATAT *);
  326 (* MATCH *);
  327 (* METHOD *);
  328 (* MINUS *);
  329 (* MINUSDOT *);
  330 (* MINUSGREATER *);
  331 (* MODULE *);
  332 (* MUTABLE *);
  334 (* NEW *);
  335 (* NONREC *);
  336 (* OBJECT *);
  337 (* OF *);
  338 (* OPEN *);
  340 (* OR *);
  341 (* PERCENT *);
  342 (* PLUS *);
  343 (* PLUSDOT *);
  344 (* PLUSEQ *);
  346 (* PRIVATE *);
  347 (* QUESTION *);
  348 (* QUOTE *);
  349 (* RBRACE *);
  350 (* RBRACKET *);
  351 (* REC *);
  352 (* RPAREN *);
  353 (* SEMI *);
  354 (* SEMISEMI *);
  355 (* SHARP *);
  357 (* SIG *);
  358 (* STAR *);
  360 (* STRUCT *);
  361 (* THEN *);
  362 (* TILDE *);
  363 (* TO *);
  364 (* TRUE *);
  365 (* TRY *);
  366 (* TYPE *);
  368 (* UNDERSCORE *);
  369 (* VAL *);
  370 (* VIRTUAL *);
  371 (* WHEN *);
  372 (* WHILE *);
  373 (* WITH *);
  376 (* EOL *);
    0|]

let yytransl_block = [|
  268 (* CHAR *);
  287 (* FLOAT *);
  298 (* INFIXOP0 *);
  299 (* INFIXOP1 *);
  300 (* INFIXOP2 *);
  301 (* INFIXOP3 *);
  302 (* INFIXOP4 *);
  305 (* INT *);
  306 (* INT32 *);
  307 (* INT64 *);
  308 (* LABEL *);
  321 (* LIDENT *);
  333 (* NATIVEINT *);
  339 (* OPTLABEL *);
  345 (* PREFIXOP *);
  356 (* SHARPOP *);
  359 (* STRING *);
  367 (* UIDENT *);
  374 (* COMMENT *);
  375 (* DOCSTRING *);
    0|]

let yylhs = "\255\255\
\001\000\002\000\003\000\003\000\003\000\010\000\010\000\014\000\
\014\000\004\000\016\000\016\000\017\000\017\000\017\000\017\000\
\017\000\017\000\017\000\005\000\006\000\007\000\020\000\020\000\
\021\000\021\000\023\000\023\000\024\000\024\000\024\000\024\000\
\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
\024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
\008\000\008\000\030\000\030\000\030\000\015\000\015\000\015\000\
\015\000\015\000\015\000\015\000\015\000\015\000\015\000\015\000\
\015\000\015\000\015\000\042\000\045\000\045\000\045\000\036\000\
\037\000\037\000\046\000\047\000\022\000\022\000\022\000\022\000\
\022\000\022\000\022\000\022\000\022\000\022\000\009\000\009\000\
\009\000\050\000\050\000\050\000\050\000\050\000\050\000\050\000\
\050\000\050\000\050\000\050\000\050\000\050\000\050\000\050\000\
\039\000\057\000\060\000\060\000\060\000\054\000\055\000\056\000\
\056\000\061\000\062\000\063\000\063\000\038\000\040\000\040\000\
\065\000\066\000\069\000\069\000\069\000\068\000\068\000\074\000\
\074\000\070\000\070\000\070\000\070\000\070\000\070\000\075\000\
\075\000\075\000\075\000\075\000\075\000\075\000\075\000\079\000\
\080\000\080\000\080\000\081\000\081\000\082\000\082\000\082\000\
\082\000\082\000\082\000\082\000\083\000\083\000\084\000\084\000\
\084\000\084\000\085\000\085\000\085\000\085\000\085\000\071\000\
\071\000\071\000\071\000\071\000\094\000\094\000\094\000\094\000\
\094\000\094\000\097\000\098\000\098\000\099\000\099\000\100\000\
\100\000\100\000\100\000\100\000\100\000\101\000\101\000\101\000\
\103\000\086\000\058\000\058\000\104\000\105\000\041\000\041\000\
\106\000\107\000\012\000\012\000\012\000\072\000\072\000\072\000\
\072\000\072\000\072\000\072\000\072\000\112\000\112\000\109\000\
\109\000\108\000\108\000\110\000\111\000\111\000\026\000\026\000\
\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
\026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
\026\000\026\000\114\000\114\000\114\000\114\000\114\000\114\000\
\114\000\114\000\114\000\114\000\114\000\114\000\114\000\114\000\
\114\000\114\000\114\000\114\000\114\000\114\000\114\000\114\000\
\114\000\114\000\114\000\114\000\114\000\114\000\114\000\114\000\
\114\000\114\000\114\000\114\000\114\000\114\000\114\000\114\000\
\114\000\114\000\114\000\114\000\114\000\114\000\114\000\114\000\
\114\000\114\000\076\000\076\000\132\000\132\000\133\000\133\000\
\133\000\133\000\134\000\093\000\093\000\135\000\135\000\135\000\
\135\000\135\000\031\000\031\000\140\000\141\000\137\000\137\000\
\092\000\092\000\092\000\117\000\117\000\143\000\143\000\118\000\
\118\000\118\000\119\000\119\000\128\000\128\000\144\000\144\000\
\144\000\145\000\145\000\131\000\131\000\129\000\129\000\089\000\
\089\000\089\000\089\000\089\000\019\000\019\000\019\000\019\000\
\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\
\019\000\019\000\019\000\113\000\113\000\139\000\139\000\139\000\
\139\000\139\000\139\000\139\000\139\000\139\000\139\000\139\000\
\139\000\139\000\139\000\139\000\139\000\139\000\139\000\139\000\
\139\000\139\000\139\000\146\000\146\000\146\000\150\000\150\000\
\149\000\149\000\149\000\149\000\151\000\151\000\051\000\152\000\
\152\000\032\000\033\000\033\000\153\000\154\000\158\000\158\000\
\157\000\157\000\157\000\157\000\157\000\157\000\157\000\157\000\
\157\000\157\000\156\000\156\000\156\000\161\000\162\000\162\000\
\164\000\164\000\165\000\165\000\165\000\166\000\163\000\163\000\
\163\000\167\000\073\000\073\000\159\000\159\000\159\000\168\000\
\169\000\035\000\035\000\053\000\171\000\171\000\171\000\171\000\
\160\000\160\000\160\000\175\000\176\000\034\000\052\000\178\000\
\178\000\178\000\178\000\178\000\178\000\179\000\179\000\179\000\
\180\000\181\000\182\000\183\000\049\000\049\000\184\000\184\000\
\184\000\184\000\185\000\185\000\138\000\138\000\090\000\090\000\
\177\000\177\000\018\000\018\000\186\000\186\000\188\000\188\000\
\188\000\188\000\188\000\190\000\190\000\174\000\174\000\191\000\
\191\000\191\000\191\000\191\000\191\000\191\000\191\000\191\000\
\191\000\191\000\191\000\191\000\191\000\191\000\191\000\191\000\
\191\000\191\000\027\000\027\000\198\000\197\000\197\000\194\000\
\194\000\195\000\195\000\193\000\193\000\199\000\199\000\200\000\
\200\000\196\000\196\000\189\000\189\000\095\000\095\000\077\000\
\077\000\201\000\201\000\173\000\173\000\192\000\192\000\192\000\
\202\000\087\000\127\000\127\000\127\000\127\000\127\000\127\000\
\127\000\147\000\147\000\147\000\147\000\147\000\147\000\147\000\
\147\000\147\000\147\000\147\000\064\000\064\000\136\000\136\000\
\136\000\136\000\136\000\203\000\203\000\203\000\203\000\203\000\
\203\000\203\000\203\000\203\000\203\000\203\000\203\000\203\000\
\203\000\203\000\203\000\203\000\203\000\203\000\203\000\203\000\
\203\000\203\000\170\000\170\000\170\000\170\000\170\000\126\000\
\126\000\120\000\120\000\120\000\120\000\120\000\125\000\125\000\
\148\000\148\000\025\000\025\000\187\000\187\000\187\000\048\000\
\048\000\096\000\096\000\078\000\078\000\011\000\011\000\011\000\
\011\000\011\000\011\000\011\000\121\000\142\000\142\000\155\000\
\155\000\122\000\122\000\091\000\091\000\088\000\088\000\067\000\
\067\000\102\000\102\000\102\000\102\000\102\000\059\000\059\000\
\116\000\116\000\130\000\130\000\123\000\123\000\124\000\124\000\
\204\000\204\000\204\000\204\000\204\000\204\000\204\000\204\000\
\204\000\204\000\204\000\204\000\204\000\204\000\204\000\204\000\
\204\000\204\000\204\000\204\000\204\000\204\000\204\000\204\000\
\204\000\204\000\204\000\204\000\204\000\204\000\204\000\204\000\
\204\000\204\000\204\000\204\000\204\000\204\000\204\000\204\000\
\204\000\204\000\204\000\204\000\204\000\204\000\204\000\204\000\
\204\000\204\000\205\000\205\000\028\000\207\000\044\000\013\000\
\013\000\172\000\172\000\115\000\115\000\115\000\029\000\043\000\
\206\000\206\000\206\000\206\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000"

let yylen = "\002\000\
\002\000\002\000\002\000\002\000\001\000\002\000\001\000\000\000\
\002\000\001\000\001\000\003\000\001\000\002\000\004\000\003\000\
\003\000\002\000\002\000\002\000\002\000\002\000\002\000\005\000\
\001\000\001\000\002\000\001\000\001\000\003\000\003\000\004\000\
\004\000\003\000\004\000\005\000\005\000\003\000\003\000\004\000\
\006\000\008\000\006\000\005\000\005\000\004\000\002\000\001\000\
\003\000\001\000\000\000\002\000\002\000\001\000\001\000\001\000\
\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
\001\000\002\000\001\000\003\000\002\000\004\000\002\000\004\000\
\001\000\002\000\005\000\004\000\001\000\003\000\003\000\004\000\
\003\000\004\000\003\000\003\000\001\000\002\000\000\000\002\000\
\002\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
\001\000\001\000\001\000\001\000\001\000\001\000\002\000\001\000\
\004\000\003\000\002\000\006\000\003\000\004\000\005\000\001\000\
\002\000\006\000\005\000\000\000\002\000\005\000\001\000\002\000\
\006\000\006\000\002\000\004\000\002\000\000\000\003\000\003\000\
\002\000\001\000\002\000\002\000\003\000\002\000\001\000\004\000\
\001\000\003\000\003\000\005\000\005\000\003\000\003\000\002\000\
\003\000\005\000\000\000\000\000\002\000\005\000\003\000\003\000\
\003\000\003\000\002\000\001\000\002\000\000\000\006\000\005\000\
\005\000\006\000\006\000\006\000\004\000\007\000\010\000\001\000\
\006\000\004\000\005\000\003\000\004\000\001\000\003\000\003\000\
\002\000\001\000\002\000\003\000\000\000\000\000\002\000\003\000\
\003\000\006\000\003\000\002\000\001\000\005\000\005\000\003\000\
\003\000\003\000\001\000\002\000\007\000\007\000\001\000\002\000\
\008\000\007\000\001\000\002\000\003\000\005\000\002\000\005\000\
\002\000\004\000\002\000\002\000\001\000\001\000\001\000\000\000\
\002\000\001\000\003\000\001\000\001\000\003\000\001\000\002\000\
\003\000\007\000\007\000\004\000\004\000\007\000\006\000\006\000\
\005\000\001\000\002\000\002\000\007\000\005\000\006\000\010\000\
\003\000\008\000\003\000\003\000\003\000\003\000\003\000\003\000\
\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
\003\000\003\000\003\000\003\000\003\000\003\000\002\000\002\000\
\005\000\007\000\007\000\007\000\003\000\003\000\003\000\004\000\
\004\000\002\000\001\000\001\000\001\000\001\000\003\000\003\000\
\004\000\003\000\004\000\004\000\003\000\005\000\005\000\005\000\
\005\000\005\000\005\000\005\000\005\000\003\000\003\000\005\000\
\005\000\004\000\004\000\002\000\006\000\006\000\004\000\004\000\
\006\000\006\000\002\000\002\000\003\000\004\000\004\000\002\000\
\006\000\006\000\003\000\003\000\004\000\006\000\005\000\008\000\
\007\000\001\000\001\000\002\000\001\000\001\000\002\000\002\000\
\002\000\002\000\001\000\001\000\002\000\002\000\007\000\008\000\
\003\000\005\000\001\000\002\000\005\000\003\000\001\000\003\000\
\002\000\002\000\005\000\001\000\003\000\003\000\005\000\002\000\
\002\000\005\000\003\000\003\000\003\000\001\000\001\000\003\000\
\002\000\003\000\001\000\003\000\005\000\001\000\003\000\002\000\
\004\000\002\000\002\000\002\000\001\000\003\000\003\000\001\000\
\002\000\002\000\003\000\003\000\008\000\008\000\003\000\003\000\
\002\000\002\000\002\000\001\000\001\000\001\000\001\000\003\000\
\001\000\001\000\002\000\003\000\003\000\004\000\004\000\004\000\
\002\000\004\000\003\000\003\000\005\000\005\000\004\000\004\000\
\006\000\006\000\001\000\003\000\003\000\003\000\001\000\003\000\
\001\000\002\000\004\000\003\000\003\000\001\000\005\000\001\000\
\002\000\007\000\001\000\002\000\007\000\006\000\003\000\000\000\
\000\000\002\000\003\000\002\000\003\000\002\000\005\000\005\000\
\004\000\007\000\000\000\001\000\003\000\002\000\001\000\003\000\
\002\000\001\000\000\000\001\000\003\000\002\000\000\000\001\000\
\001\000\002\000\001\000\003\000\001\000\001\000\002\000\003\000\
\004\000\001\000\006\000\005\000\000\000\002\000\004\000\002\000\
\001\000\001\000\002\000\005\000\007\000\008\000\008\000\001\000\
\001\000\001\000\001\000\002\000\002\000\001\000\001\000\002\000\
\003\000\004\000\004\000\005\000\001\000\003\000\006\000\005\000\
\004\000\004\000\001\000\002\000\002\000\003\000\001\000\003\000\
\001\000\003\000\001\000\002\000\001\000\004\000\001\000\006\000\
\004\000\005\000\003\000\001\000\003\000\001\000\003\000\002\000\
\001\000\001\000\002\000\004\000\003\000\002\000\002\000\003\000\
\005\000\003\000\004\000\005\000\004\000\002\000\004\000\006\000\
\004\000\001\000\001\000\003\000\004\000\001\000\003\000\001\000\
\003\000\001\000\001\000\005\000\002\000\001\000\000\000\001\000\
\003\000\001\000\002\000\001\000\003\000\001\000\003\000\001\000\
\003\000\001\000\003\000\001\000\003\000\003\000\002\000\001\000\
\004\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
\001\000\001\000\002\000\002\000\002\000\002\000\002\000\002\000\
\002\000\002\000\002\000\002\000\001\000\001\000\001\000\003\000\
\003\000\002\000\003\000\001\000\001\000\001\000\001\000\001\000\
\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
\001\000\001\000\001\000\002\000\001\000\001\000\001\000\001\000\
\003\000\001\000\002\000\002\000\001\000\001\000\001\000\003\000\
\001\000\003\000\001\000\003\000\001\000\003\000\004\000\001\000\
\003\000\001\000\003\000\001\000\003\000\002\000\003\000\003\000\
\003\000\003\000\003\000\003\000\002\000\000\000\001\000\000\000\
\001\000\001\000\001\000\000\000\001\000\000\000\001\000\000\000\
\001\000\000\000\001\000\001\000\002\000\002\000\000\000\001\000\
\000\000\001\000\000\000\001\000\001\000\001\000\001\000\001\000\
\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
\001\000\001\000\001\000\003\000\004\000\004\000\004\000\000\000\
\002\000\000\000\002\000\000\000\002\000\003\000\004\000\004\000\
\001\000\002\000\002\000\004\000\002\000\002\000\002\000\002\000\
\002\000\002\000\002\000"

let yydefred = "\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\060\002\000\000\000\000\000\000\
\117\002\062\002\000\000\000\000\000\000\000\000\000\000\059\002\
\063\002\064\002\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\165\002\166\002\
\000\000\065\002\000\000\000\000\000\000\167\002\168\002\000\000\
\000\000\061\002\118\002\000\000\000\000\123\002\000\000\237\002\
\000\000\000\000\000\000\000\000\000\000\066\001\050\000\000\000\
\055\000\000\000\057\000\058\000\059\000\000\000\061\000\062\000\
\000\000\000\000\065\000\000\000\067\000\073\000\210\001\119\000\
\000\000\199\000\000\000\000\000\000\000\000\000\000\000\000\000\
\019\001\020\001\112\002\083\001\171\001\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\238\002\000\000\091\000\000\000\
\098\000\099\000\000\000\000\000\104\000\000\000\090\000\093\000\
\094\000\095\000\096\000\000\000\100\000\000\000\112\000\195\000\
\005\000\000\000\239\002\000\000\000\000\000\000\007\000\000\000\
\013\000\000\000\240\002\000\000\000\000\000\000\010\000\011\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\125\002\009\002\241\002\000\000\026\002\010\002\
\251\001\000\000\000\000\255\001\000\000\000\000\242\002\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\079\002\000\000\
\000\000\000\000\000\000\134\001\243\002\000\000\000\000\155\001\
\117\001\000\000\000\000\066\002\132\001\133\001\000\000\000\000\
\000\000\000\000\000\000\000\000\078\002\077\002\141\002\000\000\
\052\001\021\001\022\001\000\000\000\000\153\002\000\000\109\002\
\110\002\000\000\111\002\107\002\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\048\000\000\000\000\000\000\000\000\000\000\000\000\000\102\001\
\000\000\056\001\058\002\000\000\000\000\115\002\000\000\000\000\
\044\001\000\000\171\002\172\002\173\002\174\002\175\002\176\002\
\177\002\178\002\179\002\180\002\181\002\182\002\183\002\184\002\
\185\002\186\002\187\002\188\002\189\002\190\002\191\002\192\002\
\193\002\194\002\195\002\169\002\196\002\197\002\198\002\199\002\
\200\002\201\002\202\002\203\002\204\002\205\002\206\002\207\002\
\208\002\209\002\210\002\211\002\212\002\213\002\170\002\214\002\
\215\002\216\002\217\002\218\002\000\000\000\000\000\000\000\000\
\000\000\000\000\082\002\103\002\102\002\000\000\101\002\000\000\
\104\002\097\002\099\002\085\002\086\002\087\002\088\002\089\002\
\098\002\000\000\000\000\000\000\100\002\106\002\000\000\000\000\
\105\002\000\000\116\002\090\002\096\002\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\160\002\000\000\
\051\001\052\000\000\000\145\002\000\000\000\000\001\000\000\000\
\000\000\000\000\000\000\053\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\018\001\000\000\000\000\
\084\001\000\000\172\001\000\000\074\000\000\000\120\000\000\000\
\200\000\066\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\067\001\070\001\000\000\000\000\
\000\000\007\001\008\001\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\085\000\077\000\128\002\000\000\000\000\
\000\000\088\000\000\000\000\000\002\000\103\000\089\000\000\000\
\113\000\000\000\196\000\000\000\003\000\004\000\006\000\009\000\
\014\000\000\000\000\000\000\000\019\000\000\000\018\000\000\000\
\121\002\000\000\035\002\000\000\000\000\162\002\000\000\022\002\
\000\000\056\002\014\002\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\008\002\132\002\000\000\015\002\
\020\000\252\001\000\000\000\000\000\000\000\000\000\000\000\000\
\011\002\021\000\130\001\000\000\129\001\137\001\138\001\119\002\
\000\000\000\000\000\000\000\000\000\000\000\000\145\001\000\000\
\091\002\000\000\000\000\095\002\000\000\000\000\093\002\084\002\
\000\000\068\002\067\002\069\002\070\002\071\002\073\002\072\002\
\074\002\075\002\076\002\139\001\000\000\000\000\000\000\000\000\
\022\000\131\001\000\000\121\001\122\001\000\000\000\000\000\000\
\000\000\000\000\229\002\000\000\000\000\026\001\000\000\000\000\
\000\000\000\000\108\002\000\000\000\000\000\000\000\000\094\002\
\000\000\092\002\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\213\000\000\000\000\000\000\000\028\000\000\000\
\000\000\000\000\000\000\000\000\068\000\047\000\000\000\000\000\
\000\000\000\000\039\001\038\001\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\233\002\000\000\
\000\000\000\000\000\000\143\002\000\000\000\000\083\002\000\000\
\024\001\000\000\000\000\023\001\000\000\081\002\080\002\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\053\001\
\000\000\000\000\148\000\000\000\000\000\000\000\201\001\200\001\
\000\000\188\001\000\000\000\000\000\000\049\000\225\002\000\000\
\000\000\000\000\000\000\000\000\124\002\113\002\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\205\000\000\000\000\000\000\000\000\000\
\000\000\225\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\075\001\073\001\059\001\
\000\000\072\001\068\001\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\106\000\086\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\139\002\136\002\
\135\002\140\002\000\000\137\002\017\000\000\000\016\000\012\000\
\034\002\000\000\032\002\000\000\037\002\018\002\000\000\000\000\
\000\000\000\000\013\002\000\000\055\002\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\122\002\126\002\000\000\
\000\000\000\000\050\002\000\000\016\002\000\000\000\000\141\001\
\140\001\000\000\000\000\000\000\000\000\000\000\000\000\148\001\
\000\000\147\001\119\001\118\001\128\001\000\000\124\001\000\000\
\158\001\000\000\000\000\136\001\000\000\230\002\227\002\000\000\
\000\000\000\000\029\001\027\001\025\001\000\000\000\000\000\000\
\203\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\214\001\052\002\000\000\000\000\000\000\212\000\
\000\000\214\000\000\000\215\000\209\000\220\000\000\000\207\000\
\000\000\211\000\000\000\000\000\000\000\229\000\000\000\000\000\
\092\001\000\000\023\000\025\000\026\000\000\000\000\000\027\000\
\000\000\039\000\000\000\038\000\031\000\030\000\034\000\000\000\
\000\000\101\001\000\000\104\001\000\000\000\000\055\001\054\001\
\000\000\048\001\047\001\043\001\042\001\220\002\000\000\000\000\
\231\002\232\002\000\000\000\000\000\000\000\000\000\000\061\001\
\115\001\000\000\116\001\000\000\028\001\223\002\000\000\000\000\
\000\000\000\000\000\000\000\000\071\000\072\000\000\000\017\001\
\016\001\000\000\105\000\000\000\191\001\000\000\000\000\000\000\
\000\000\194\001\190\001\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\086\001\000\000\000\000\000\000\
\000\000\000\000\087\001\078\001\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\084\000\083\000\000\000\079\000\078\000\000\000\000\000\000\000\
\237\001\000\000\129\002\000\000\000\000\000\000\000\000\000\000\
\110\000\000\000\000\000\000\000\000\000\000\000\015\000\000\000\
\019\002\038\002\000\000\000\000\000\000\023\002\021\002\000\000\
\000\000\000\000\249\001\054\002\000\000\025\002\000\000\000\000\
\000\000\012\002\000\000\000\000\133\002\000\000\127\002\254\001\
\000\000\120\002\000\000\000\000\164\001\000\000\143\001\142\001\
\146\001\144\001\000\000\000\000\152\001\151\001\000\000\221\002\
\000\000\000\000\000\000\000\000\000\000\127\000\000\000\198\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\212\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\096\001\097\001\000\000\000\000\000\000\000\000\
\000\000\000\000\046\000\000\000\000\000\040\000\000\000\035\000\
\033\000\000\000\000\000\000\000\000\000\085\001\000\000\063\001\
\000\000\000\000\000\000\075\000\000\000\118\000\000\000\000\000\
\145\000\000\000\000\000\000\000\000\000\000\000\000\000\156\000\
\149\000\233\000\000\000\000\000\189\001\000\000\176\001\000\000\
\193\001\000\000\222\002\041\001\040\001\000\000\000\000\000\000\
\000\000\031\001\030\001\081\001\000\000\000\000\089\001\000\000\
\090\001\000\000\000\000\176\001\076\000\000\000\000\000\000\000\
\037\001\035\001\000\000\033\001\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\196\001\000\000\000\000\
\111\000\109\000\000\000\000\000\167\001\000\000\000\000\033\002\
\040\002\000\000\020\002\042\002\000\000\000\000\000\000\000\000\
\057\002\000\000\000\000\028\002\000\000\017\002\000\000\051\002\
\164\002\163\001\000\000\000\000\150\001\149\001\036\001\034\001\
\032\001\000\000\204\001\202\001\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\174\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\135\000\000\000\
\000\000\000\000\137\000\121\000\125\000\000\000\215\001\053\002\
\211\001\000\000\000\000\147\002\146\002\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\210\000\000\000\094\001\000\000\
\093\001\000\000\000\000\044\000\000\000\045\000\000\000\037\000\
\036\000\000\000\236\002\000\000\000\000\000\000\062\001\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\155\000\000\000\192\001\000\000\
\182\001\000\000\000\000\000\000\000\000\000\000\000\000\205\001\
\206\001\000\000\000\000\149\002\000\000\239\000\058\001\057\001\
\050\001\049\001\046\001\045\001\000\000\000\000\000\000\000\000\
\000\000\088\001\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\238\001\114\000\000\000\000\000\115\000\000\000\000\000\036\002\
\024\002\043\002\250\001\246\001\000\000\000\000\000\000\000\000\
\154\001\153\001\000\000\130\002\178\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\182\000\000\000\000\000\
\000\000\177\000\000\000\000\000\000\000\000\000\131\000\000\000\
\000\000\000\000\000\000\134\000\000\000\169\001\170\001\000\000\
\230\000\000\000\217\000\208\000\206\000\000\000\000\000\000\000\
\000\000\024\000\000\000\041\000\043\000\226\000\227\000\000\000\
\146\000\000\000\153\000\000\000\154\000\000\000\000\000\000\000\
\152\000\151\002\000\000\000\000\000\000\151\000\000\000\000\000\
\000\000\000\000\000\000\207\001\000\000\000\000\173\001\000\000\
\000\000\000\000\224\001\225\001\226\001\227\001\065\001\000\000\
\077\001\000\000\000\000\000\000\082\001\174\001\122\000\000\000\
\000\000\000\000\000\000\197\000\000\000\000\000\197\001\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\230\001\231\001\
\000\000\041\002\000\000\031\002\000\000\201\000\000\000\000\000\
\000\000\000\000\000\000\176\000\175\000\000\000\000\000\000\000\
\000\000\172\000\047\002\000\000\000\000\129\000\000\000\143\000\
\000\000\142\000\139\000\138\000\000\000\000\000\098\001\095\001\
\000\000\242\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\185\001\000\000\000\000\000\000\
\217\001\000\000\208\001\000\000\175\001\000\000\000\000\000\000\
\222\001\228\001\229\001\064\001\000\000\000\000\091\001\202\000\
\240\001\244\001\176\001\108\000\000\000\223\001\232\001\198\000\
\000\000\126\001\125\001\131\002\173\000\000\000\180\000\000\000\
\000\000\000\000\000\000\000\000\189\000\183\000\170\000\000\000\
\000\000\136\000\000\000\000\000\042\000\157\000\150\000\000\000\
\000\000\000\000\165\000\000\000\000\000\000\000\000\000\209\001\
\000\000\000\000\000\000\183\001\219\001\000\000\000\000\000\000\
\000\000\233\001\000\000\079\001\000\000\171\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\188\000\
\000\000\141\000\140\000\240\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\161\000\000\000\000\000\000\000\
\000\000\000\000\234\001\235\001\080\001\187\000\184\000\157\002\
\158\002\000\000\000\000\000\000\000\000\185\000\169\000\163\000\
\164\000\000\000\000\000\000\000\000\000\162\000\186\001\000\000\
\236\001\000\000\000\000\000\000\000\000\000\000\166\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\186\000\000\000\
\000\000\000\000\221\001\167\000"

let yydgoto = "\008\000\
\056\000\101\000\123\000\131\000\149\000\159\000\173\000\055\002\
\102\000\124\000\132\000\058\000\081\001\127\000\059\000\135\000\
\136\000\193\001\233\001\078\002\022\003\147\001\032\002\215\000\
\060\000\061\000\191\002\110\001\062\000\063\000\161\000\065\000\
\066\000\067\000\068\000\069\000\070\000\071\000\072\000\073\000\
\074\000\075\000\076\000\077\000\079\002\078\000\117\001\149\001\
\120\003\110\000\111\000\112\000\079\000\114\000\115\000\116\000\
\117\000\118\000\072\001\162\002\119\000\161\001\066\003\150\001\
\080\000\119\001\199\000\010\002\187\003\089\004\076\004\013\003\
\239\002\223\004\090\004\131\001\194\001\091\004\082\002\083\002\
\074\003\241\003\085\005\140\004\137\004\133\004\081\000\095\005\
\098\003\185\005\150\004\099\003\167\004\077\004\078\004\079\004\
\213\004\214\004\062\005\134\005\175\005\171\005\101\005\120\000\
\163\001\082\000\121\001\199\003\106\004\200\003\198\003\005\003\
\177\000\083\000\034\001\183\001\016\003\014\003\084\000\085\000\
\086\000\102\004\087\000\088\000\222\000\089\000\090\000\223\000\
\232\000\048\002\229\000\133\001\134\001\143\002\127\002\091\000\
\100\003\186\005\182\000\092\000\113\001\061\002\017\003\224\000\
\225\000\183\000\184\000\152\000\219\001\222\001\220\001\099\004\
\093\000\115\001\077\001\089\002\247\003\155\004\151\004\096\005\
\090\002\078\003\091\002\083\003\029\004\241\002\184\003\152\004\
\153\004\154\004\015\002\003\002\244\002\080\004\097\005\098\005\
\146\003\018\005\046\005\019\005\020\005\021\005\022\005\121\003\
\042\005\153\000\154\000\155\000\156\000\157\000\158\000\189\001\
\177\002\178\002\179\002\045\004\052\004\053\004\139\003\042\004\
\247\002\190\001\063\001\029\001\030\001\056\002\082\001"

let yysindex = "\020\008\
\217\062\157\006\112\044\005\044\107\015\144\064\150\068\000\000\
\132\004\108\002\087\070\132\004\000\000\202\001\101\000\017\001\
\000\000\000\000\132\004\132\004\132\004\132\004\025\003\000\000\
\000\000\000\000\132\004\150\070\082\255\049\063\139\063\219\058\
\219\058\029\005\000\000\184\055\219\058\132\004\000\000\000\000\
\232\004\000\000\132\004\132\004\142\255\000\000\000\000\087\070\
\217\062\000\000\000\000\132\004\185\255\000\000\132\004\000\000\
\040\001\047\000\155\011\024\000\217\071\000\000\000\000\246\002\
\000\000\056\000\000\000\000\000\000\000\222\001\000\000\000\000\
\034\002\055\002\000\000\047\000\000\000\000\000\000\000\000\000\
\048\002\000\000\217\069\155\000\087\070\087\070\144\064\144\064\
\000\000\000\000\000\000\000\000\000\000\202\001\101\000\024\004\
\066\005\157\006\185\255\017\001\000\000\136\003\000\000\056\000\
\000\000\000\000\055\002\047\000\000\000\157\006\000\000\000\000\
\000\000\000\000\000\000\135\002\000\000\158\002\000\000\000\000\
\000\000\108\002\000\000\060\002\096\002\047\000\000\000\227\002\
\000\000\228\044\000\000\082\004\047\000\082\004\000\000\000\000\
\011\009\213\002\172\255\135\004\010\003\133\073\107\015\140\003\
\108\002\243\002\000\000\000\000\000\000\076\000\000\000\000\000\
\000\000\212\001\019\000\000\000\144\003\182\002\000\000\043\005\
\246\002\150\068\150\069\024\003\135\067\205\067\000\000\144\059\
\102\003\183\003\028\003\000\000\000\000\074\000\036\004\000\000\
\000\000\150\068\150\068\000\000\000\000\000\000\085\004\152\004\
\219\058\219\058\083\004\087\070\000\000\000\000\000\000\040\056\
\000\000\000\000\000\000\226\063\207\003\000\000\126\004\000\000\
\000\000\088\004\000\000\000\000\079\002\152\071\189\004\150\068\
\199\066\213\002\144\064\149\004\111\002\217\062\091\005\036\004\
\000\000\087\070\000\000\217\004\014\001\229\004\145\255\000\000\
\147\004\000\000\000\000\234\004\161\004\000\000\149\072\190\004\
\000\000\190\004\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\016\005\128\062\128\062\132\004\
\142\255\213\004\000\000\000\000\000\000\087\070\000\000\225\004\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\179\000\000\000\000\000\000\000\000\000\
\000\000\087\070\000\000\000\000\000\000\041\000\118\255\128\062\
\144\064\204\004\108\002\193\002\243\002\008\005\000\000\226\004\
\000\000\000\000\144\064\000\000\185\004\144\064\000\000\219\058\
\155\011\047\000\132\004\000\000\087\005\009\006\144\064\144\064\
\144\064\144\064\144\064\144\064\144\064\144\064\144\064\144\064\
\144\064\144\064\144\064\144\064\144\064\144\064\144\064\144\064\
\144\064\144\064\144\064\144\064\144\064\000\000\150\068\144\064\
\000\000\185\004\000\000\250\004\000\000\207\003\000\000\207\003\
\000\000\000\000\144\064\031\004\087\070\087\070\054\005\059\005\
\087\070\054\005\024\070\098\001\000\000\000\000\144\064\098\001\
\098\001\000\000\000\000\126\004\152\001\149\004\024\004\002\005\
\157\006\000\000\059\002\000\000\000\000\000\000\173\002\027\005\
\074\003\000\000\185\004\128\005\000\000\000\000\000\000\051\005\
\000\000\207\003\000\000\066\006\000\000\000\000\000\000\000\000\
\000\000\082\004\047\000\082\004\000\000\082\004\000\000\073\012\
\000\000\025\004\000\000\077\005\165\005\000\000\073\012\000\000\
\073\012\000\000\000\000\171\005\151\005\093\005\107\015\059\003\
\083\004\029\001\123\005\186\005\000\000\000\000\182\005\000\000\
\000\000\000\000\061\003\096\005\120\005\107\015\095\007\243\002\
\000\000\000\000\000\000\084\061\000\000\000\000\000\000\000\000\
\191\005\187\005\064\000\122\005\249\003\125\005\000\000\125\005\
\000\000\134\005\102\003\000\000\135\255\183\003\000\000\000\000\
\129\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\044\002\148\061\212\061\020\062\
\000\000\000\000\139\005\000\000\000\000\150\068\192\002\128\062\
\083\004\083\004\000\000\098\001\208\004\000\000\245\002\126\004\
\042\004\173\005\000\000\003\039\116\001\003\039\083\004\000\000\
\236\005\000\000\107\015\043\003\150\069\001\060\100\002\068\005\
\100\005\071\066\000\000\150\068\149\005\014\005\000\000\011\001\
\144\064\139\001\167\003\214\003\000\000\000\000\098\001\124\006\
\024\003\144\064\000\000\000\000\024\003\144\064\059\005\199\003\
\144\064\187\255\122\255\219\058\107\015\150\068\000\000\164\005\
\166\005\148\005\132\004\000\000\150\068\195\005\000\000\118\001\
\000\000\152\011\214\012\000\000\170\005\000\000\000\000\168\005\
\150\005\193\002\241\005\024\004\025\003\193\002\047\000\000\000\
\150\068\053\004\000\000\108\003\156\005\042\004\000\000\000\000\
\098\003\000\000\239\000\254\005\128\062\000\000\000\000\150\070\
\059\005\144\064\144\064\152\056\000\000\000\000\134\073\134\073\
\081\073\026\007\149\072\081\073\143\012\143\012\143\012\143\012\
\165\002\229\005\229\005\143\012\165\002\165\002\081\073\229\005\
\165\002\165\002\165\002\000\000\229\005\015\005\047\000\062\065\
\006\006\000\000\213\005\193\002\126\004\126\004\149\072\144\064\
\144\064\144\064\217\005\098\001\098\001\000\000\000\000\000\000\
\001\006\000\000\000\000\081\073\221\005\019\005\143\255\201\005\
\072\004\254\003\000\000\000\000\109\003\020\006\024\004\226\004\
\216\002\047\000\098\003\107\015\024\006\126\004\000\000\000\000\
\000\000\000\000\017\006\000\000\000\000\082\004\000\000\000\000\
\000\000\218\000\000\000\041\006\000\000\000\000\073\012\191\000\
\025\001\029\016\000\000\236\001\000\000\226\005\218\005\196\005\
\107\015\047\003\107\015\107\015\117\003\000\000\000\000\187\001\
\108\002\242\005\000\000\215\005\000\000\129\003\150\068\000\000\
\000\000\032\003\150\068\032\000\063\003\004\006\034\001\000\000\
\156\013\000\000\000\000\000\000\000\000\170\002\000\000\052\006\
\000\000\096\255\096\255\000\000\233\005\000\000\000\000\144\064\
\144\064\144\064\000\000\000\000\000\000\007\006\187\000\240\005\
\000\000\196\065\133\073\003\006\000\000\182\002\232\005\244\005\
\239\005\083\004\000\000\000\000\047\000\194\001\144\064\000\000\
\015\006\000\000\150\068\000\000\000\000\000\000\023\006\000\000\
\023\006\000\000\114\060\144\064\071\066\000\000\029\000\081\006\
\000\000\144\064\000\000\000\000\000\000\076\006\025\003\000\000\
\105\071\000\000\024\004\000\000\000\000\000\000\000\000\253\000\
\000\000\000\000\149\072\000\000\149\072\065\006\000\000\000\000\
\149\072\000\000\000\000\000\000\000\000\000\000\083\004\121\255\
\000\000\000\000\193\002\226\004\047\000\144\064\148\255\000\000\
\000\000\016\002\000\000\083\004\000\000\000\000\213\002\047\000\
\024\004\047\000\043\001\112\005\000\000\000\000\053\002\000\000\
\000\000\043\002\000\000\131\005\000\000\056\001\067\006\005\006\
\108\002\000\000\000\000\144\064\011\006\083\000\161\004\190\004\
\190\004\179\000\166\255\144\064\000\000\036\011\144\064\227\060\
\129\065\068\006\000\000\000\000\107\015\067\006\047\000\033\006\
\036\006\249\071\003\005\069\000\174\255\144\064\089\006\024\004\
\000\000\000\000\025\003\000\000\000\000\252\005\194\004\105\006\
\000\000\000\000\000\000\024\004\036\002\108\003\118\002\099\006\
\000\000\026\006\115\005\024\004\056\006\226\255\000\000\073\012\
\000\000\000\000\107\015\064\001\116\006\000\000\000\000\108\002\
\043\000\083\004\000\000\000\000\107\015\000\000\014\006\083\004\
\243\002\000\000\242\005\053\006\000\000\019\006\000\000\000\000\
\095\007\000\000\249\003\038\006\000\000\249\003\000\000\000\000\
\000\000\000\000\150\068\059\003\000\000\000\000\205\255\000\000\
\055\072\182\000\217\255\106\006\042\004\000\000\108\002\000\000\
\097\010\156\004\047\000\196\065\094\001\141\046\003\039\047\000\
\000\000\037\006\007\000\040\006\203\003\114\006\114\006\128\006\
\047\006\079\006\000\000\000\000\144\064\144\064\150\068\087\072\
\024\004\112\005\000\000\156\255\157\255\000\000\160\255\000\000\
\000\000\144\064\144\064\108\006\024\005\000\000\181\072\000\000\
\049\006\107\015\150\068\000\000\036\002\000\000\025\003\107\015\
\000\000\107\015\142\255\144\064\142\255\117\255\047\000\000\000\
\000\000\000\000\150\068\042\004\000\000\227\070\000\000\060\006\
\000\000\130\006\000\000\000\000\000\000\051\004\235\000\062\005\
\085\002\000\000\000\000\000\000\090\006\084\001\000\000\100\006\
\000\000\144\064\163\002\000\000\000\000\196\065\129\006\103\006\
\000\000\000\000\104\006\000\000\109\006\149\072\097\010\036\002\
\112\005\152\006\144\000\042\004\150\003\000\000\254\003\059\002\
\000\000\000\000\024\004\060\006\000\000\059\002\159\006\000\000\
\000\000\046\002\000\000\000\000\065\001\000\000\107\015\108\002\
\000\000\242\005\024\003\000\000\172\006\000\000\107\015\000\000\
\000\000\000\000\037\004\090\000\000\000\000\000\000\000\000\000\
\000\000\012\003\000\000\000\000\114\014\168\006\133\073\118\006\
\141\046\122\006\000\000\161\006\083\004\120\006\000\000\093\006\
\042\003\182\002\007\067\107\015\156\004\008\005\000\000\080\004\
\083\004\024\070\000\000\000\000\000\000\047\003\000\000\000\000\
\000\000\037\006\047\000\000\000\000\000\144\064\071\066\107\015\
\144\064\096\006\101\006\107\015\000\000\107\006\000\000\125\006\
\000\000\144\064\037\255\000\000\079\255\000\000\110\006\000\000\
\000\000\149\072\000\000\144\064\144\064\144\064\000\000\083\004\
\081\006\112\005\059\255\255\002\047\000\156\004\047\000\000\003\
\047\000\133\006\135\006\047\000\000\000\081\006\000\000\101\000\
\000\000\219\048\034\071\000\000\111\003\142\006\192\006\000\000\
\000\000\152\001\001\002\000\000\037\001\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\169\255\090\006\179\006\107\015\
\119\006\000\000\144\064\001\002\047\000\012\003\144\064\144\064\
\144\064\047\000\096\005\096\005\149\001\000\000\189\006\187\006\
\000\000\000\000\222\002\121\001\000\000\097\010\107\015\000\000\
\000\000\000\000\000\000\000\000\193\006\014\006\242\005\020\062\
\000\000\000\000\107\015\000\000\000\000\115\005\153\003\087\001\
\144\003\141\046\159\001\107\015\137\004\000\000\145\006\207\006\
\156\004\000\000\097\010\003\039\179\003\135\066\000\000\097\001\
\223\255\144\004\156\004\000\000\024\070\000\000\000\000\202\006\
\000\000\083\004\000\000\000\000\000\000\083\004\071\066\144\064\
\149\072\000\000\059\003\000\000\000\000\000\000\000\000\019\073\
\000\000\107\015\000\000\195\001\000\000\113\006\060\006\059\005\
\000\000\000\000\059\005\123\006\059\005\000\000\152\001\083\004\
\192\006\192\001\133\006\000\000\083\004\107\015\000\000\101\000\
\094\002\032\002\000\000\000\000\000\000\000\000\000\000\132\006\
\000\000\107\015\146\003\129\065\000\000\000\000\000\000\115\005\
\149\072\149\072\149\072\000\000\240\003\240\003\000\000\107\015\
\134\006\107\015\118\002\101\000\152\001\071\002\000\000\000\000\
\047\000\000\000\107\015\000\000\031\001\000\000\206\003\208\003\
\156\006\047\003\087\000\000\000\000\000\109\001\097\010\141\046\
\083\004\000\000\000\000\000\000\156\004\000\000\243\002\000\000\
\097\010\000\000\000\000\000\000\083\004\144\064\000\000\000\000\
\138\006\000\000\083\004\171\006\047\000\059\005\059\005\007\066\
\226\006\059\005\012\005\083\004\000\000\207\000\059\005\148\006\
\000\000\133\006\000\000\221\003\000\000\127\002\116\001\083\004\
\000\000\000\000\000\000\000\000\229\003\144\064\000\000\000\000\
\000\000\000\000\000\000\000\000\152\001\000\000\000\000\000\000\
\083\004\000\000\000\000\000\000\000\000\097\010\000\000\107\015\
\012\003\058\004\186\002\047\000\000\000\000\000\000\000\178\006\
\083\004\000\000\108\000\236\006\000\000\000\000\000\000\244\006\
\245\006\189\070\000\000\107\015\248\006\144\064\239\006\000\000\
\133\006\192\006\249\006\000\000\000\000\107\015\116\001\083\004\
\083\004\000\000\144\064\000\000\250\006\000\000\047\000\115\005\
\170\006\181\006\059\005\207\003\133\006\015\007\047\000\000\000\
\097\010\000\000\000\000\000\000\029\016\029\016\090\006\083\004\
\006\007\172\001\083\004\107\015\000\000\144\064\197\006\029\016\
\083\004\083\004\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\021\007\059\005\059\005\107\015\000\000\000\000\000\000\
\000\000\017\007\144\064\107\015\083\004\000\000\000\000\083\004\
\000\000\029\016\028\007\030\007\083\004\107\015\000\000\083\004\
\205\006\047\000\107\015\107\015\004\004\083\004\000\000\083\004\
\083\004\144\064\000\000\000\000"

let yyrindex = "\000\000\
\047\008\048\008\208\006\000\000\000\000\000\000\000\000\000\000\
\213\070\000\000\000\000\057\064\000\000\115\003\000\000\000\000\
\000\000\000\000\214\068\071\067\016\068\231\064\000\000\000\000\
\000\000\000\000\213\070\000\000\000\000\000\000\000\000\000\000\
\000\000\080\068\234\016\000\000\000\000\231\064\000\000\000\000\
\000\000\000\000\247\003\237\001\194\006\000\000\000\000\000\000\
\071\000\000\000\000\000\231\064\212\003\000\000\231\064\000\000\
\000\000\226\009\071\000\102\017\154\038\000\000\000\000\064\054\
\000\000\103\054\000\000\000\000\000\000\147\054\000\000\000\000\
\192\054\214\054\000\000\223\054\000\000\000\000\000\000\000\000\
\000\000\000\000\251\022\115\023\014\022\132\022\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\115\003\000\000\000\000\
\000\000\110\000\212\003\000\000\000\000\000\000\000\000\121\014\
\000\000\000\000\063\049\181\049\000\000\110\000\000\000\000\000\
\000\000\000\000\000\000\240\050\000\000\089\051\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\209\006\000\000\208\006\
\000\000\000\000\000\000\000\000\127\004\000\000\000\000\000\000\
\000\000\060\013\060\013\000\000\010\039\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\037\015\000\000\237\039\082\040\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\086\045\000\000\
\000\000\164\002\032\006\000\000\000\000\000\000\149\006\200\045\
\000\000\000\000\003\057\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\115\003\000\000\252\006\000\000\
\000\000\000\000\000\000\000\000\248\052\000\000\000\000\000\000\
\000\000\022\069\000\000\000\000\000\000\197\004\223\054\243\005\
\000\000\000\000\096\001\155\004\000\000\201\255\000\000\000\000\
\091\000\000\000\000\000\000\000\130\004\000\000\094\000\254\000\
\000\000\092\005\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\067\055\215\006\215\006\199\006\
\034\004\086\069\000\000\000\000\000\000\151\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\117\057\205\057\000\000\000\000\000\000\037\058\125\058\
\000\000\153\000\000\000\000\000\000\000\000\000\000\000\215\006\
\000\000\000\000\000\000\000\000\000\000\091\006\000\000\000\000\
\000\000\000\000\000\000\000\000\248\002\000\000\000\000\000\000\
\071\000\247\047\080\068\000\000\064\054\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\202\031\000\000\000\000\000\000\000\000\
\000\000\050\003\000\000\000\000\000\000\115\003\000\000\115\003\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\224\017\169\020\000\000\000\000\000\000\233\023\
\095\024\000\000\000\000\252\006\138\010\000\000\000\000\000\000\
\214\004\202\007\181\049\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\248\002\000\000\000\000\000\000\000\000\000\000\
\000\000\115\003\000\000\111\007\000\000\000\000\000\000\000\000\
\000\000\000\000\127\004\000\000\000\000\000\000\000\000\000\000\
\000\000\071\001\000\000\048\007\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\027\007\000\000\000\000\
\144\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\202\255\000\000\150\000\168\000\254\000\000\000\092\005\
\000\000\000\000\201\000\000\000\000\000\202\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\215\006\
\003\057\149\043\000\000\215\024\000\000\000\000\000\000\252\006\
\228\006\000\000\000\000\000\000\000\000\000\000\172\011\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\077\025\000\000\
\000\000\000\000\000\000\000\000\015\001\000\000\169\004\000\000\
\161\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\199\006\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\019\039\000\000\000\000\000\000\223\054\000\000\
\000\000\000\000\000\000\122\052\000\000\047\004\000\000\000\000\
\000\000\000\000\000\000\000\000\215\006\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\133\034\244\034\
\080\009\127\005\207\015\094\035\064\032\183\032\046\033\164\033\
\002\029\195\025\058\026\027\034\120\029\239\029\200\035\176\026\
\102\030\220\030\083\031\000\000\039\027\000\000\070\053\175\004\
\105\005\000\000\000\000\000\000\252\006\252\006\090\016\000\000\
\000\000\000\000\087\018\033\021\152\021\000\000\000\000\000\000\
\206\018\000\000\000\000\050\036\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\181\049\000\000\000\000\000\000\252\006\000\000\000\000\
\000\000\000\000\017\012\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\003\054\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\029\007\000\000\000\000\000\000\153\255\
\000\000\183\040\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\131\041\000\000\030\041\000\000\000\000\000\000\000\000\
\000\000\028\001\161\255\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\019\004\000\000\009\010\
\000\000\198\003\043\008\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\046\048\122\048\000\000\000\000\
\000\000\203\053\000\000\000\000\122\052\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\158\027\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\111\001\000\000\219\255\000\000\169\000\000\000\000\000\000\000\
\170\000\000\000\000\000\000\000\000\000\000\000\224\006\229\006\
\000\000\000\000\000\000\000\000\070\053\000\000\000\000\000\000\
\000\000\053\001\000\000\185\001\000\000\000\000\022\069\014\054\
\000\000\122\052\000\000\144\052\000\000\000\000\000\000\000\000\
\000\000\219\004\000\000\022\069\000\000\000\000\205\049\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\130\004\254\000\
\092\005\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\118\050\014\054\000\000\
\000\000\000\000\243\072\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\161\002\128\003\
\000\000\243\010\000\000\000\000\068\013\181\049\000\000\000\000\
\000\000\000\000\181\049\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\027\002\000\000\000\000\000\000\000\000\000\000\153\001\
\000\000\000\000\232\041\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\005\000\044\001\000\000\246\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\228\006\000\000\000\000\000\000\
\000\000\000\000\014\054\000\000\000\000\000\000\000\000\223\054\
\000\000\000\000\000\000\000\000\199\001\234\006\234\006\215\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\125\039\
\000\000\247\006\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\224\051\000\000\000\000\000\000\
\000\000\000\000\245\004\000\000\044\255\231\004\058\008\000\000\
\000\000\000\000\000\000\047\004\000\000\024\007\000\000\008\002\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\068\019\
\000\000\000\000\188\019\000\000\051\020\151\036\000\000\255\049\
\033\043\114\004\000\000\228\006\000\000\000\000\000\000\233\013\
\000\000\000\000\000\000\008\002\000\000\233\013\000\000\000\000\
\000\000\071\001\000\000\000\000\000\000\065\059\000\000\000\000\
\000\000\079\042\000\000\000\000\172\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\069\047\000\000\216\005\
\000\000\000\000\128\047\000\000\192\008\000\000\000\000\001\007\
\000\000\139\048\000\000\000\000\000\000\091\006\000\000\000\000\
\092\053\020\046\000\000\000\000\000\000\231\048\000\000\000\000\
\000\000\018\052\122\052\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\181\000\000\000\000\000\000\000\000\000\000\000\219\001\
\020\028\189\052\000\000\000\000\058\008\000\000\058\008\014\007\
\058\008\018\007\018\007\058\008\000\000\139\028\000\000\000\000\
\000\000\000\000\032\007\157\046\177\050\000\000\236\050\000\000\
\000\000\131\049\077\052\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\058\007\000\000\000\000\
\000\000\000\000\000\000\077\052\014\054\000\000\000\000\000\000\
\000\000\233\013\000\000\000\000\000\000\052\005\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\180\042\000\000\
\000\000\000\000\000\000\000\000\000\000\077\052\000\000\000\000\
\013\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\079\046\000\000\000\000\000\000\
\000\000\242\001\000\000\000\000\000\000\009\002\000\000\000\000\
\252\036\000\000\000\000\000\000\000\000\000\000\000\000\086\001\
\000\000\000\000\000\000\054\002\000\000\019\007\014\007\000\000\
\000\000\000\000\000\000\037\007\000\000\000\000\131\049\039\051\
\106\051\243\001\018\007\000\000\058\050\000\000\000\000\000\000\
\239\052\223\054\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\077\052\
\102\037\203\037\048\038\000\000\080\012\221\012\000\000\000\000\
\038\065\000\000\000\000\000\000\068\007\181\049\000\000\000\000\
\233\013\000\000\000\000\000\000\250\003\000\000\000\000\000\000\
\000\000\053\049\000\000\000\000\000\000\227\004\000\000\000\000\
\114\053\000\000\000\000\187\047\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\216\046\000\000\000\000\000\000\
\000\000\000\000\009\005\000\000\058\008\000\000\000\000\000\000\
\000\000\000\000\000\000\058\050\000\000\000\000\000\000\000\000\
\000\000\069\002\000\000\000\000\000\000\239\052\000\000\215\051\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\068\007\000\000\000\000\000\000\
\190\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\038\007\000\000\227\009\000\000\000\000\000\000\000\000\
\019\047\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\018\007\165\051\000\000\000\000\000\000\000\000\000\000\215\051\
\193\053\000\000\000\000\000\000\044\014\000\000\227\009\227\009\
\045\007\050\007\000\000\056\007\018\007\000\000\227\009\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\048\003\
\000\000\000\000\047\005\000\000\000\000\000\000\000\000\000\000\
\239\042\193\053\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\180\005\000\000\000\000\155\002\
\000\000\000\000\000\000\000\000\184\005\000\000\000\000\105\004\
\255\006\227\009\000\000\000\000\000\000\159\004\000\000\225\006\
\211\008\000\000\000\000\000\000"

let yygindex = "\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\092\000\
\243\255\000\000\086\000\253\255\232\006\255\007\062\000\000\000\
\204\255\135\000\063\000\091\255\000\000\148\254\000\007\071\255\
\210\007\163\014\243\252\017\000\022\004\014\000\049\000\052\000\
\066\000\000\000\000\000\000\000\000\000\075\000\088\000\000\000\
\097\000\000\000\002\000\004\000\094\254\000\000\000\000\083\254\
\000\000\000\000\000\000\000\000\099\000\000\000\000\000\000\000\
\000\000\000\000\238\254\160\252\000\000\000\000\000\000\006\000\
\000\000\000\000\164\255\207\254\136\254\018\252\114\252\072\255\
\103\004\168\003\000\000\048\004\056\253\115\255\055\004\000\000\
\000\000\000\000\000\000\000\000\000\000\016\003\247\255\204\251\
\201\254\036\254\129\252\057\003\139\251\029\252\010\252\090\003\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\140\005\205\004\168\004\000\000\000\000\
\103\255\030\000\231\000\140\255\005\002\009\253\093\255\190\008\
\049\011\000\000\000\000\000\000\106\255\251\006\142\012\062\006\
\001\000\086\255\073\006\134\254\000\000\034\007\112\006\214\011\
\189\252\088\253\212\254\000\000\000\000\000\000\220\004\076\004\
\000\000\000\000\166\006\119\255\220\005\010\008\000\000\079\004\
\000\000\000\000\080\008\073\002\080\005\045\252\184\251\244\252\
\210\253\000\000\015\254\000\000\000\000\234\255\000\000\000\000\
\235\251\249\255\240\251\105\254\254\253\034\254\000\000\000\000\
\247\002\000\000\000\000\252\003\160\251\000\000\170\003\154\004\
\000\000\115\253\003\012\126\255\000\000\009\000\067\254\010\006\
\136\255\215\254\130\255\000\000\253\003\000\000\000\000\000\000\
\238\006\000\000\000\000\000\000\026\000\053\255\000\000"

let yytablesize = 19189
let yytable = "\126\000\
\133\000\140\001\160\000\108\000\200\001\109\000\069\002\205\000\
\147\002\213\001\181\001\251\002\195\001\218\001\059\002\191\000\
\180\001\145\003\192\002\228\000\209\001\204\003\185\001\240\002\
\026\002\187\000\181\002\034\002\187\000\009\004\034\004\234\000\
\062\001\244\001\151\002\187\000\187\000\187\000\187\000\077\003\
\193\000\225\003\189\003\187\000\147\003\245\002\031\002\252\002\
\025\005\064\000\187\000\064\000\064\000\103\000\187\000\027\002\
\172\004\221\000\031\001\187\000\187\000\050\002\064\001\051\002\
\128\000\134\000\129\002\104\000\187\000\174\000\051\000\187\000\
\084\001\249\001\009\005\201\001\105\000\073\001\246\002\173\001\
\246\002\175\001\215\004\057\002\154\001\003\005\005\005\141\001\
\125\000\106\000\149\002\048\005\057\000\028\002\206\004\243\004\
\159\001\064\000\107\000\108\000\113\000\109\000\225\004\185\000\
\008\002\230\002\231\002\085\001\159\002\087\000\247\001\108\000\
\132\001\109\000\136\001\137\001\072\002\070\002\226\000\253\002\
\157\004\044\003\064\002\071\001\245\001\185\000\171\001\164\001\
\246\001\012\005\188\001\045\003\242\004\159\002\063\002\247\001\
\178\004\013\005\248\001\150\000\074\001\184\002\113\003\185\002\
\043\002\179\001\227\000\224\003\071\001\103\000\197\001\252\004\
\027\002\154\002\249\004\116\004\118\004\159\002\060\004\120\004\
\164\002\103\000\185\000\104\000\188\004\002\004\202\001\064\003\
\023\005\027\002\164\002\069\003\105\000\020\004\244\004\104\000\
\085\001\106\005\064\000\182\001\085\001\006\004\085\001\080\002\
\105\000\106\000\042\003\185\000\062\001\128\000\250\001\172\001\
\007\002\134\000\107\000\134\000\113\000\106\000\117\004\119\004\
\107\001\166\001\032\005\002\002\061\004\119\005\107\000\029\002\
\113\000\185\000\000\002\001\002\189\000\071\002\238\002\170\001\
\020\004\004\002\106\001\057\005\189\000\189\000\072\005\067\003\
\211\001\103\003\185\000\221\001\221\001\139\002\138\004\038\002\
\031\002\189\000\065\005\219\003\073\005\044\002\114\003\188\000\
\252\001\253\001\196\000\012\005\077\005\215\002\092\005\039\002\
\027\002\208\000\209\000\210\000\211\000\041\004\164\002\121\004\
\104\005\218\000\146\001\154\002\165\001\003\004\064\000\076\001\
\000\005\184\001\146\001\146\001\065\001\021\004\020\002\185\000\
\129\002\069\001\070\001\189\002\154\002\154\005\205\001\146\001\
\043\003\133\002\075\001\134\002\104\005\078\001\100\004\167\003\
\245\001\185\000\167\000\206\000\246\001\107\001\166\001\079\001\
\065\002\107\001\166\001\247\001\062\004\086\001\248\001\049\005\
\187\000\035\002\125\003\212\002\229\002\213\002\066\002\106\001\
\065\004\067\002\114\001\106\001\190\002\073\002\074\005\208\002\
\047\004\210\005\205\002\193\000\018\004\166\002\051\000\085\002\
\075\002\136\005\092\002\202\002\066\005\245\001\064\000\064\000\
\101\002\246\001\252\003\104\003\105\003\160\005\137\005\073\001\
\247\001\201\004\103\001\248\001\206\001\110\001\094\002\185\000\
\051\000\165\001\192\003\187\000\160\005\165\001\205\003\110\001\
\124\002\093\002\032\003\178\005\130\002\087\000\235\002\233\004\
\064\000\101\004\080\001\200\000\133\003\173\002\144\002\175\002\
\204\005\176\002\024\003\000\003\208\004\168\003\211\004\087\005\
\027\002\085\001\201\000\153\002\012\005\240\002\048\004\087\000\
\068\002\192\002\094\005\224\004\185\000\140\003\185\000\206\003\
\220\003\085\003\108\000\068\003\109\000\161\001\091\002\024\005\
\084\002\185\000\140\002\141\002\209\002\168\005\145\002\165\005\
\132\001\195\004\019\004\156\002\051\000\251\001\202\000\159\001\
\108\001\111\001\180\004\030\002\135\001\126\002\215\003\253\003\
\135\005\159\001\063\002\111\001\109\001\018\004\127\005\103\001\
\179\001\202\004\139\005\110\001\030\002\029\002\110\001\179\001\
\029\002\179\001\002\002\240\002\103\000\143\004\136\003\097\003\
\094\002\092\002\116\005\179\005\181\003\108\001\029\002\080\003\
\203\000\202\001\104\000\204\000\229\003\212\000\144\004\203\002\
\111\005\109\001\085\001\105\000\085\001\200\000\085\001\095\004\
\096\004\136\003\141\003\250\001\107\003\081\005\027\002\134\000\
\106\000\134\000\161\004\134\000\201\000\250\001\032\000\166\005\
\024\003\107\000\161\001\113\000\213\000\160\001\091\002\079\005\
\084\002\250\001\049\004\082\004\216\003\163\002\192\002\160\001\
\082\004\246\002\208\004\024\004\153\005\159\001\058\002\111\001\
\159\001\108\001\111\001\030\002\250\001\250\001\105\001\032\004\
\202\000\002\002\002\002\064\004\203\002\109\001\203\002\038\004\
\182\003\130\003\214\000\162\001\142\003\029\002\122\005\002\002\
\136\003\054\000\207\005\005\002\250\001\038\003\192\002\192\002\
\094\002\092\002\240\002\163\002\016\005\247\001\193\002\172\003\
\064\000\050\005\038\002\200\000\222\002\224\002\226\002\137\003\
\154\003\188\003\203\000\218\001\227\002\204\000\036\002\185\000\
\155\003\156\003\201\000\093\004\107\003\231\003\010\000\136\003\
\162\004\244\003\081\003\187\000\030\002\046\003\226\002\112\001\
\038\002\167\000\206\000\160\001\023\003\157\005\160\001\228\000\
\027\002\082\004\015\003\163\002\217\003\210\003\082\003\119\002\
\091\003\185\000\088\003\089\003\115\004\100\001\202\000\100\001\
\193\002\168\004\226\002\105\001\209\001\185\000\120\002\193\002\
\128\001\129\001\193\002\027\002\048\003\079\002\143\003\005\002\
\162\001\135\003\119\002\126\002\194\002\221\000\123\005\128\005\
\044\005\173\003\041\002\055\003\079\002\108\003\109\003\200\000\
\163\002\120\002\026\003\082\004\191\005\064\000\250\001\071\003\
\203\000\017\000\192\004\204\000\112\001\173\004\201\000\245\003\
\027\003\254\002\113\005\129\005\115\005\043\004\193\004\154\002\
\001\004\048\002\123\003\137\001\226\002\012\002\181\003\156\002\
\097\003\033\000\049\002\248\002\254\003\255\003\000\004\048\004\
\193\002\037\000\188\001\130\005\056\005\249\002\187\004\036\002\
\185\000\025\004\202\000\047\003\119\002\094\004\071\005\179\001\
\119\002\212\005\079\002\079\002\128\001\129\001\084\005\027\002\
\058\003\060\003\227\003\120\002\036\002\185\000\160\003\120\002\
\158\003\079\002\079\002\114\001\079\002\056\003\093\005\243\003\
\134\004\067\005\136\004\139\004\194\003\131\005\085\001\051\000\
\116\001\221\000\054\000\079\002\203\000\178\003\179\003\204\000\
\014\002\203\001\028\003\134\000\228\002\048\002\250\001\048\002\
\250\001\218\000\250\001\250\001\039\005\113\001\049\002\192\002\
\049\002\058\004\148\002\195\003\204\001\252\002\058\005\228\002\
\082\004\148\002\186\001\188\003\185\000\185\000\228\002\048\004\
\203\003\040\004\002\002\054\004\222\000\163\003\202\001\148\002\
\148\002\166\003\050\004\014\005\082\004\204\001\148\002\145\003\
\114\001\156\004\159\003\228\002\228\002\082\004\246\002\250\001\
\226\003\052\003\027\002\219\000\118\001\148\002\221\000\016\005\
\148\002\228\002\131\003\219\002\227\000\130\004\228\002\191\004\
\038\002\228\002\147\003\228\002\148\002\158\000\218\000\197\000\
\245\001\120\001\113\001\198\000\246\001\234\003\226\002\202\001\
\250\001\197\003\232\003\247\001\080\001\192\002\248\001\152\003\
\158\000\148\002\202\001\239\003\202\001\240\003\044\005\158\000\
\250\003\222\000\185\000\156\002\038\002\188\003\249\003\250\001\
\004\004\235\003\236\003\007\004\012\002\228\002\148\002\175\003\
\030\004\148\002\165\004\080\001\158\000\158\000\185\000\033\000\
\219\000\013\002\147\002\012\002\167\000\206\000\123\001\037\000\
\185\000\237\003\158\000\148\002\027\002\099\005\148\002\185\000\
\103\005\158\000\158\000\226\002\158\000\185\000\080\001\081\000\
\216\002\082\004\082\004\159\002\245\001\150\002\184\004\157\001\
\246\001\160\001\080\001\082\004\012\002\156\002\217\002\247\001\
\179\001\212\000\248\001\202\001\233\003\046\004\036\002\185\000\
\154\002\159\005\222\004\238\003\197\004\165\001\067\004\014\002\
\162\001\218\001\002\002\137\001\002\003\003\003\158\000\137\001\
\202\001\056\004\032\000\137\001\189\000\137\001\014\002\154\002\
\213\000\137\001\137\001\250\001\199\004\137\001\250\001\161\002\
\247\001\027\002\131\002\248\001\068\004\171\004\137\001\202\001\
\082\004\166\001\157\002\185\000\152\005\157\001\181\001\056\004\
\209\001\111\004\112\004\013\000\180\001\027\002\076\002\014\002\
\162\005\098\001\099\001\004\003\154\003\250\001\214\000\123\004\
\208\005\209\005\190\000\077\002\182\001\054\000\018\000\033\002\
\218\002\195\001\038\002\163\002\058\003\185\000\137\001\156\002\
\135\004\059\004\088\004\011\004\185\000\137\001\204\001\014\000\
\024\000\025\000\026\000\082\004\236\002\156\002\177\001\226\002\
\111\001\104\001\227\000\226\002\199\001\226\005\015\000\016\000\
\137\001\137\001\030\002\137\001\137\001\172\005\170\004\169\000\
\195\005\196\005\109\001\023\000\042\000\015\003\237\002\195\001\
\044\002\038\002\127\001\183\004\035\002\170\000\137\001\191\001\
\208\001\250\004\151\000\202\001\176\000\112\001\044\002\033\000\
\185\000\015\003\083\001\151\005\147\000\222\004\050\000\037\000\
\156\002\038\002\217\005\173\005\217\000\041\000\245\001\247\001\
\156\002\015\003\246\001\198\001\045\000\196\004\156\002\127\003\
\187\001\247\001\002\002\212\000\248\001\043\005\169\003\221\004\
\225\005\185\000\247\001\203\004\027\002\255\002\128\003\032\000\
\170\003\247\001\247\001\250\001\204\004\209\004\235\005\044\002\
\053\000\129\000\154\002\199\001\032\000\027\002\044\002\159\002\
\216\001\254\004\213\000\072\004\177\001\218\004\247\001\247\001\
\216\001\054\000\232\004\097\003\160\002\235\004\187\001\199\001\
\128\004\228\004\044\002\204\001\247\001\185\000\131\004\177\001\
\132\004\255\004\187\001\247\001\247\001\148\001\247\001\132\001\
\246\004\247\004\147\000\189\000\149\004\198\002\224\002\081\000\
\214\000\251\001\027\002\156\002\234\001\088\004\054\000\054\000\
\007\005\010\005\147\000\161\002\081\000\199\001\054\000\164\003\
\202\001\153\003\038\002\202\001\202\001\017\005\235\001\236\001\
\237\001\081\000\081\000\081\000\081\000\147\000\151\000\097\003\
\247\001\199\001\079\003\151\000\151\000\202\001\029\003\029\005\
\081\000\146\001\152\002\199\002\110\005\189\000\055\005\080\001\
\154\003\185\000\238\001\152\002\045\005\157\003\088\004\176\000\
\176\000\138\005\176\000\176\000\081\000\176\000\027\002\081\000\
\030\003\162\003\081\000\081\000\081\000\157\001\039\003\176\000\
\176\000\157\001\081\000\156\002\196\001\157\001\245\001\157\001\
\147\000\081\000\246\001\157\001\185\000\239\001\182\004\157\001\
\104\004\247\001\204\001\122\003\248\001\081\000\218\004\081\000\
\157\001\081\000\081\000\101\002\203\002\176\000\176\000\240\001\
\241\001\242\001\217\000\040\003\080\005\081\000\234\004\101\002\
\081\000\228\004\238\004\068\005\081\000\207\001\088\005\158\005\
\212\000\089\005\202\001\091\005\245\001\157\001\202\001\163\005\
\246\001\157\001\132\001\243\001\054\000\158\003\053\005\247\001\
\102\005\088\004\248\001\157\001\228\004\185\000\124\005\157\001\
\204\004\032\000\127\001\088\004\144\002\144\002\127\001\213\000\
\202\001\008\005\127\001\144\002\127\001\002\002\234\005\185\000\
\127\001\199\002\157\001\157\001\117\005\157\001\157\001\185\000\
\245\001\144\002\210\001\202\001\246\001\127\001\027\005\144\002\
\218\004\204\001\159\004\247\001\072\003\031\003\200\004\228\002\
\157\001\251\001\142\001\185\000\199\002\214\000\147\000\132\005\
\198\000\133\005\144\002\144\002\054\000\250\001\185\000\116\003\
\118\003\217\000\140\005\202\001\144\005\145\005\073\003\203\005\
\149\005\228\004\111\001\032\000\136\002\155\005\137\002\160\004\
\189\000\143\001\059\005\185\000\127\001\228\004\014\000\216\001\
\138\002\117\003\144\001\202\001\159\002\228\002\254\001\185\000\
\248\001\180\002\164\005\119\003\002\002\015\000\016\000\127\001\
\127\001\087\002\127\001\127\001\202\001\088\004\159\002\227\004\
\002\002\174\005\023\000\248\001\145\001\202\001\241\000\088\002\
\083\005\163\002\248\001\248\001\176\000\127\001\146\001\123\002\
\060\005\202\001\199\001\224\002\123\002\054\000\033\000\075\005\
\159\002\083\001\189\005\169\005\100\005\185\000\037\000\248\001\
\248\001\228\004\224\002\224\002\041\000\186\001\199\001\197\005\
\109\005\202\005\061\005\045\000\148\001\248\001\163\002\224\002\
\164\002\076\005\187\001\170\005\248\001\248\001\255\001\248\001\
\002\002\002\002\132\001\130\000\122\000\009\002\132\001\011\002\
\218\004\121\005\214\005\224\002\083\004\132\001\224\002\053\000\
\132\001\219\005\220\005\224\002\051\000\151\000\185\000\227\000\
\202\001\224\002\019\002\202\001\151\000\164\002\151\000\223\005\
\224\002\202\001\002\002\084\004\151\000\087\000\030\002\032\000\
\186\000\248\001\144\000\083\001\198\001\085\004\051\000\226\002\
\224\002\224\002\179\000\151\000\151\000\202\001\236\005\129\004\
\002\002\176\000\226\002\086\004\224\002\202\001\040\002\087\000\
\202\001\132\001\029\000\045\002\144\000\202\001\002\002\142\004\
\202\001\202\001\086\002\226\002\179\000\114\002\114\002\042\002\
\087\002\047\002\017\004\028\004\046\002\232\002\132\004\233\002\
\194\000\087\002\054\000\176\000\176\000\176\000\088\002\114\002\
\216\001\234\002\245\001\176\000\135\001\159\002\246\001\088\002\
\184\005\066\002\187\005\194\000\067\002\247\001\049\002\138\001\
\248\001\151\000\194\000\151\000\193\005\052\002\150\005\159\002\
\151\000\092\003\176\000\176\000\159\002\251\001\160\000\176\000\
\159\002\176\000\159\002\060\002\159\002\159\002\159\002\194\000\
\194\000\217\000\074\002\184\005\184\005\163\004\054\000\125\004\
\062\002\160\000\213\005\058\002\159\002\194\000\066\001\164\004\
\160\000\081\002\151\000\176\000\194\000\194\000\119\002\194\000\
\054\000\185\000\176\000\221\005\030\002\067\001\068\001\151\000\
\151\000\111\001\224\005\163\002\112\003\160\000\160\000\185\000\
\184\005\148\001\217\000\159\002\229\005\163\002\176\000\032\001\
\132\002\232\005\233\005\160\000\133\001\019\003\033\001\152\002\
\133\001\186\000\160\000\160\000\034\003\160\000\142\002\133\001\
\036\003\194\000\133\001\227\000\020\003\021\003\241\000\241\000\
\241\000\241\000\242\003\133\001\006\003\007\003\241\000\241\000\
\241\000\158\002\182\001\241\000\241\000\164\002\241\000\241\000\
\241\000\241\000\241\000\241\000\120\001\176\000\241\000\241\000\
\241\000\241\000\241\000\241\000\036\002\185\000\080\001\160\000\
\152\001\165\002\241\000\241\000\006\003\009\003\241\000\241\000\
\241\000\241\000\182\002\133\001\183\002\241\000\241\000\067\001\
\153\001\036\002\185\000\159\000\148\001\185\000\080\001\192\000\
\186\002\151\000\187\002\241\000\241\000\188\002\241\000\008\003\
\010\003\241\000\241\000\241\000\195\002\241\000\159\000\196\002\
\241\000\241\000\192\000\197\002\151\000\159\000\147\000\151\000\
\241\000\192\000\241\000\201\002\206\002\207\002\151\000\181\000\
\151\000\151\000\210\002\241\000\241\000\211\002\241\000\241\000\
\241\000\241\000\159\000\159\000\176\000\214\002\192\000\241\000\
\176\000\241\000\181\000\063\002\241\000\242\002\151\000\241\000\
\159\000\181\000\029\000\241\000\192\000\029\000\032\000\159\000\
\159\000\101\002\159\000\192\000\192\000\018\003\192\000\029\000\
\029\000\049\003\051\003\050\003\054\003\062\003\181\000\176\000\
\151\000\061\003\063\003\065\003\029\000\029\000\029\000\029\000\
\076\003\084\003\099\001\101\003\181\000\102\003\005\002\110\003\
\176\000\115\003\029\000\029\000\181\000\111\003\181\000\138\001\
\176\000\124\003\176\000\138\001\159\000\132\003\134\003\138\001\
\192\000\138\001\138\003\149\003\217\000\138\001\138\001\029\000\
\148\001\138\001\029\000\122\001\029\000\029\000\029\000\029\000\
\151\003\150\003\138\001\206\001\161\003\029\000\096\002\097\002\
\098\002\099\002\247\001\213\001\029\000\171\003\176\003\180\003\
\181\000\167\000\100\002\183\003\190\003\191\003\059\001\196\003\
\029\000\230\000\029\000\158\001\029\000\029\000\148\001\006\003\
\207\003\209\003\147\000\218\003\248\003\246\003\010\004\167\002\
\029\000\014\004\138\001\029\000\015\004\167\001\023\004\029\000\
\251\003\138\001\026\004\031\004\174\001\147\000\134\002\217\000\
\035\004\036\004\168\002\151\000\147\000\176\000\176\000\101\002\
\039\004\010\000\151\000\051\004\138\001\138\001\055\004\138\001\
\138\001\199\002\167\000\206\000\066\004\148\001\057\004\103\004\
\217\000\147\000\147\000\098\004\105\004\108\004\109\004\110\004\
\127\004\148\001\138\001\124\004\120\001\156\004\158\004\147\000\
\120\001\148\001\166\004\174\004\120\001\151\000\120\001\147\000\
\151\000\147\000\120\001\120\001\169\004\175\004\176\004\179\004\
\169\002\094\000\151\000\177\004\190\004\170\002\198\004\120\001\
\054\000\096\002\097\002\098\002\099\002\210\004\151\000\212\004\
\095\000\016\000\216\004\217\004\033\003\100\002\037\002\236\004\
\176\000\219\004\220\004\011\005\237\004\096\000\240\004\144\004\
\026\005\077\002\239\004\147\000\040\005\245\004\075\004\087\004\
\002\005\176\000\004\005\151\000\151\000\041\005\028\005\120\001\
\175\000\033\000\063\005\051\005\064\005\078\005\120\001\114\005\
\191\000\037\000\086\005\108\005\176\000\126\005\148\001\097\000\
\216\000\141\005\101\002\142\005\090\005\220\000\045\000\148\005\
\156\005\120\001\120\001\191\000\120\001\120\001\032\000\151\000\
\176\000\032\000\191\000\177\005\217\000\151\000\098\000\151\000\
\180\005\181\005\182\005\032\000\032\000\188\005\192\005\120\001\
\176\000\190\005\099\000\151\000\014\005\100\000\201\005\191\000\
\032\000\032\000\032\000\032\000\001\000\002\000\003\000\004\000\
\005\000\006\000\007\000\200\005\205\005\191\000\032\000\032\000\
\211\005\215\005\218\005\176\000\191\000\191\000\222\005\191\000\
\090\001\227\005\156\001\228\005\075\004\230\005\051\000\087\000\
\159\002\008\000\224\002\032\000\051\000\228\002\032\000\034\002\
\148\001\095\002\032\000\032\000\126\000\234\002\163\002\199\001\
\164\002\032\000\235\002\213\001\151\000\097\001\098\001\099\001\
\032\000\216\000\046\002\213\001\151\000\148\002\148\002\076\001\
\213\001\191\000\150\002\149\002\032\000\149\002\032\000\205\004\
\032\000\032\000\151\000\220\001\151\000\213\001\151\000\213\001\
\213\001\101\001\102\001\199\001\032\000\151\002\154\002\032\000\
\176\000\151\000\087\004\032\000\213\001\155\002\104\001\105\001\
\106\001\107\001\156\002\175\000\175\000\217\001\175\000\175\000\
\152\002\175\000\155\002\134\002\176\000\151\000\168\001\109\001\
\213\001\151\000\181\004\175\000\175\000\070\005\213\001\213\001\
\213\001\229\004\134\002\134\002\226\004\150\002\213\001\167\005\
\147\005\125\005\174\002\107\004\201\003\213\001\137\000\134\002\
\138\000\139\000\032\000\087\004\140\000\086\003\172\002\177\001\
\142\000\175\000\175\000\146\002\228\002\213\001\216\000\151\000\
\151\000\087\003\113\004\134\002\053\003\165\003\134\002\224\001\
\230\004\213\001\155\001\134\002\213\001\012\004\216\005\047\005\
\185\004\134\002\145\000\107\005\204\002\151\000\000\000\168\000\
\134\002\146\000\052\005\205\004\178\000\148\003\000\000\000\000\
\194\000\077\002\000\000\000\000\077\002\147\000\148\000\000\000\
\134\002\134\002\000\000\075\004\151\000\000\000\077\002\000\000\
\000\000\194\000\077\002\000\000\134\002\176\000\000\000\125\002\
\151\000\000\000\000\000\077\002\077\002\077\002\077\002\151\000\
\000\000\151\000\000\000\000\000\000\000\194\000\087\004\000\000\
\075\004\151\000\077\002\176\000\000\000\000\000\000\000\000\000\
\087\004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\176\000\216\000\077\002\000\000\
\000\000\077\002\000\000\125\002\077\002\077\002\077\002\151\000\
\194\000\000\000\194\000\194\000\077\002\000\000\199\001\000\000\
\000\000\084\002\000\000\077\002\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\151\000\000\000\000\000\000\000\077\002\
\000\000\077\002\156\001\077\002\077\002\000\000\156\001\151\000\
\000\000\176\000\156\001\000\000\156\001\000\000\070\003\077\002\
\156\001\224\002\077\002\075\003\156\001\151\000\077\002\151\000\
\175\000\000\000\000\000\000\000\000\000\156\001\000\000\000\000\
\151\000\000\000\000\000\000\000\224\002\217\001\000\000\003\001\
\000\000\000\000\000\000\224\002\075\004\151\000\000\000\000\000\
\000\000\000\000\087\004\000\000\000\000\000\000\075\004\178\000\
\214\001\000\000\178\000\178\000\000\000\178\000\093\003\000\000\
\224\002\224\002\000\000\000\000\000\000\176\000\000\000\178\000\
\178\000\000\000\000\000\000\000\156\001\171\002\224\002\000\000\
\000\000\194\000\000\000\000\000\000\000\000\000\224\002\000\000\
\224\002\000\000\000\000\000\000\000\000\000\000\000\000\156\001\
\156\001\129\003\156\001\156\001\000\000\178\000\214\001\000\000\
\000\000\000\000\000\000\075\004\000\000\151\000\205\004\194\000\
\000\000\000\000\000\000\000\000\000\000\156\001\000\000\000\000\
\000\000\199\001\000\000\000\000\000\000\175\000\000\000\151\000\
\000\000\151\000\224\002\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\151\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\168\000\
\000\000\000\000\168\000\000\000\000\000\000\000\075\004\175\000\
\175\000\175\000\151\000\151\000\168\000\000\000\000\000\175\000\
\000\000\151\000\190\000\000\000\000\000\151\000\217\001\000\000\
\000\000\168\000\168\000\168\000\168\000\000\000\175\000\000\000\
\000\000\224\002\151\000\194\000\193\003\190\000\175\000\175\000\
\168\000\151\000\000\000\175\000\190\000\175\000\000\000\151\000\
\000\000\000\000\000\000\151\000\000\000\216\000\000\000\194\000\
\151\000\151\000\217\001\000\000\168\000\000\000\217\001\000\000\
\000\000\190\000\000\000\168\000\168\000\000\000\000\000\175\000\
\123\001\000\000\168\000\000\000\000\000\000\000\175\000\190\000\
\010\000\168\000\176\001\000\000\000\000\000\000\190\000\190\000\
\000\000\190\000\000\000\000\000\222\003\000\000\216\000\168\000\
\000\000\168\000\175\000\000\000\000\000\000\000\000\000\228\003\
\000\000\230\003\000\000\000\000\178\000\168\000\000\000\000\000\
\168\000\220\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\194\000\194\000\000\000\000\000\194\000\000\000\
\194\000\000\000\137\000\190\000\138\000\139\000\032\000\000\000\
\140\000\000\000\000\000\177\001\142\000\000\000\013\004\003\001\
\000\000\175\000\003\001\000\000\000\000\000\000\000\000\003\001\
\000\000\003\001\000\000\000\000\003\001\003\001\000\000\003\001\
\003\001\003\001\003\001\003\001\003\001\033\004\145\000\003\001\
\003\001\003\001\037\004\003\001\003\001\146\000\000\000\000\000\
\000\000\126\003\000\000\000\000\003\001\000\000\000\000\003\001\
\003\001\147\000\148\000\000\000\000\000\000\000\003\001\003\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\213\001\000\000\000\000\003\001\000\000\000\000\003\001\
\000\000\178\000\000\000\003\001\003\001\000\000\003\001\000\000\
\000\000\003\001\003\001\000\000\000\000\000\000\000\000\000\000\
\175\000\003\001\092\004\217\001\175\000\000\000\000\000\097\004\
\000\000\000\000\000\000\000\000\003\001\003\001\000\000\003\001\
\003\001\003\001\003\001\178\000\178\000\178\000\000\000\000\000\
\003\001\000\000\003\001\178\000\000\000\003\001\000\000\000\000\
\003\001\000\000\000\000\175\000\003\001\000\000\000\000\000\000\
\000\000\000\000\250\002\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\214\001\178\000\175\000\000\000\141\004\214\001\
\000\000\178\000\000\000\000\000\175\000\000\000\175\000\000\000\
\000\000\224\002\224\002\000\000\000\000\000\000\000\000\000\000\
\216\000\000\000\000\000\000\000\000\000\000\000\224\002\000\000\
\000\000\000\000\077\002\178\000\000\000\224\002\000\000\000\000\
\000\000\000\000\178\000\224\002\224\002\224\002\224\002\000\000\
\000\000\000\000\000\000\000\000\000\000\221\003\000\000\186\004\
\123\001\000\000\224\002\000\000\123\001\189\004\178\000\000\000\
\123\001\224\002\123\001\000\000\000\000\000\000\123\001\000\000\
\000\000\000\000\123\001\000\000\000\000\194\000\224\002\224\002\
\000\000\224\002\000\000\123\001\000\000\000\000\224\002\224\002\
\000\000\224\002\000\000\216\000\224\002\000\000\000\000\000\000\
\000\000\175\000\175\000\224\002\000\000\000\000\000\000\179\000\
\000\000\000\000\000\000\195\000\000\000\214\001\000\000\224\002\
\000\000\000\000\000\000\224\002\216\000\000\000\000\000\027\004\
\000\000\000\000\231\004\123\001\195\000\000\000\000\000\224\002\
\000\000\000\000\123\001\224\002\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\195\000\000\000\000\000\000\000\000\000\123\001\123\001\000\000\
\123\001\123\001\199\001\000\000\251\004\000\000\253\004\000\000\
\001\005\000\000\000\000\006\005\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\123\001\175\000\000\000\000\000\000\000\
\000\000\000\000\015\005\195\000\000\000\195\000\195\000\000\000\
\000\000\213\001\000\000\199\001\178\000\175\000\000\000\000\000\
\178\000\000\000\000\000\030\005\031\005\000\000\213\001\000\000\
\069\004\036\005\138\000\139\000\032\000\000\000\140\000\000\000\
\175\000\070\004\071\004\213\001\000\000\213\001\213\001\000\000\
\000\000\000\000\000\000\226\002\000\000\000\000\000\000\214\001\
\072\004\000\000\213\001\073\004\175\000\054\005\000\000\000\000\
\216\000\178\001\000\000\074\004\145\000\000\000\000\000\000\000\
\178\000\000\000\000\000\146\000\175\000\000\000\213\001\000\000\
\178\000\000\000\214\001\000\000\213\001\213\001\213\001\147\000\
\148\000\000\000\179\000\215\001\213\001\179\000\179\000\000\000\
\179\000\000\000\000\000\213\001\181\000\000\000\000\000\175\000\
\000\000\000\000\179\000\179\000\000\000\207\000\000\000\000\000\
\000\000\000\000\000\000\213\001\195\000\000\000\217\001\000\000\
\000\000\000\000\077\002\000\000\000\000\077\002\000\000\213\001\
\000\000\105\005\213\001\000\000\000\000\000\000\000\000\077\002\
\179\000\215\001\000\000\077\002\217\001\000\000\000\000\112\005\
\126\002\000\000\195\000\000\000\077\002\077\002\077\002\077\002\
\138\002\000\000\000\000\000\000\000\000\118\005\000\000\000\000\
\120\005\000\000\000\000\077\002\000\000\178\000\214\001\000\000\
\000\000\000\000\000\000\057\003\175\000\000\000\199\001\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\077\002\
\000\000\000\000\077\002\000\000\126\002\077\002\077\002\077\002\
\175\000\156\001\000\000\000\000\143\005\077\002\000\000\000\000\
\000\000\000\000\000\000\000\000\077\002\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\242\001\
\077\002\000\000\077\002\000\000\077\002\077\002\195\000\199\001\
\000\000\000\000\000\000\137\000\000\000\138\000\139\000\032\000\
\077\002\140\000\151\001\077\002\141\000\142\000\000\000\077\002\
\178\000\000\000\195\000\176\005\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\143\000\181\000\
\181\000\214\001\181\000\181\000\000\000\181\000\144\000\144\003\
\000\000\000\000\000\000\000\000\000\000\000\000\146\000\181\000\
\181\000\000\000\000\000\000\000\178\000\000\000\198\005\199\005\
\000\000\005\004\147\000\148\000\180\000\000\000\206\005\057\003\
\000\000\175\000\000\000\000\000\000\000\000\000\000\000\179\000\
\178\000\000\000\000\000\000\000\000\000\181\000\181\000\014\000\
\000\000\000\000\199\001\226\002\000\000\195\000\195\000\175\000\
\178\000\195\000\000\000\195\000\199\001\000\000\015\000\016\000\
\226\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\175\000\000\000\000\000\023\000\000\000\226\002\000\000\226\002\
\226\002\231\005\000\000\214\001\000\000\000\000\000\000\137\000\
\000\000\138\000\139\000\032\000\226\002\140\000\000\000\033\000\
\141\000\142\000\083\001\000\000\241\001\000\000\000\000\037\000\
\178\001\000\000\000\000\000\000\000\000\041\000\000\000\178\001\
\226\002\178\001\143\000\226\002\045\000\175\000\000\000\226\002\
\226\002\000\000\144\000\145\000\000\000\000\000\226\002\000\000\
\000\000\000\000\146\000\000\000\049\000\226\002\000\000\000\000\
\000\000\000\000\000\000\000\000\179\000\000\000\147\000\148\000\
\053\000\226\002\000\000\000\000\000\000\226\002\226\002\000\000\
\214\001\000\000\000\000\000\000\000\000\000\000\199\001\194\000\
\199\001\226\002\000\000\000\000\226\002\138\002\000\000\000\000\
\000\000\000\000\000\000\000\000\214\001\000\000\179\000\179\000\
\179\000\175\000\000\000\102\002\138\002\138\002\179\000\180\000\
\180\000\000\000\180\000\180\000\000\000\180\000\000\000\000\000\
\175\000\138\002\000\000\000\000\000\000\000\000\000\000\180\000\
\180\000\000\000\000\000\107\000\128\002\215\001\179\000\000\000\
\000\000\000\000\215\001\000\000\179\000\138\002\010\000\242\001\
\138\002\000\000\242\001\000\000\000\000\138\002\000\000\000\000\
\000\000\000\000\000\000\138\002\242\001\180\000\180\000\000\000\
\000\000\000\000\138\002\000\000\000\000\000\000\179\000\000\000\
\000\000\242\001\242\001\242\001\242\001\179\000\000\000\000\000\
\175\000\000\000\138\002\138\002\000\000\000\000\000\000\000\000\
\242\001\000\000\000\000\000\000\000\000\000\000\138\002\000\000\
\137\000\179\000\138\000\139\000\032\000\178\000\140\000\000\000\
\000\000\177\001\142\000\000\000\242\001\000\000\000\000\242\001\
\195\000\151\001\242\001\242\001\242\001\000\000\000\000\000\000\
\000\000\000\000\242\001\214\001\000\000\090\001\000\000\000\000\
\000\000\242\001\194\000\000\000\145\000\000\000\000\000\000\000\
\000\000\181\000\000\000\146\000\214\001\242\001\000\000\242\001\
\215\001\242\001\242\001\000\000\000\000\000\000\000\000\147\000\
\148\000\096\001\097\001\098\001\099\001\242\001\000\000\000\000\
\242\001\000\000\151\001\000\000\242\001\000\000\000\000\000\000\
\000\000\000\000\220\002\181\000\181\000\181\000\200\002\000\000\
\000\000\185\000\000\000\181\000\000\000\059\003\101\001\102\001\
\000\000\214\001\000\000\000\000\241\001\000\000\000\000\241\001\
\000\000\000\000\000\000\104\001\105\001\106\001\107\001\178\001\
\224\002\241\001\181\000\181\000\000\000\000\000\000\000\181\000\
\000\000\181\000\000\000\000\000\109\001\000\000\241\001\241\001\
\241\001\241\001\000\000\000\000\180\000\102\002\000\000\179\000\
\000\000\000\000\000\000\179\000\000\000\241\001\000\000\000\000\
\000\000\000\000\000\000\181\000\000\000\137\000\000\000\138\000\
\139\000\032\000\128\002\140\000\000\000\214\001\141\000\142\000\
\000\000\241\001\000\000\000\000\241\001\000\000\000\000\241\001\
\241\001\241\001\215\001\000\000\161\005\000\000\181\000\241\001\
\143\000\000\000\000\000\239\001\000\000\000\000\241\001\000\000\
\144\000\145\000\000\000\179\000\000\000\000\000\000\000\000\000\
\146\000\000\000\241\001\179\000\241\001\215\001\241\001\241\001\
\000\000\161\002\000\000\107\000\147\000\148\000\000\000\000\000\
\000\000\000\000\241\001\000\000\000\000\241\001\151\001\000\000\
\107\000\241\001\000\000\000\000\000\000\181\000\000\000\000\000\
\000\000\000\000\000\000\000\000\194\005\107\000\000\000\107\000\
\107\000\180\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\107\000\000\000\000\000\000\000\
\000\000\000\000\000\000\161\002\000\000\161\002\161\002\161\002\
\092\000\161\002\000\000\000\000\161\002\161\002\000\000\000\000\
\107\000\000\000\000\000\180\000\180\000\180\000\000\000\107\000\
\107\000\000\000\000\000\180\000\180\000\000\000\107\000\000\000\
\179\000\215\001\000\000\000\000\000\000\107\000\000\000\161\002\
\000\000\000\000\000\000\174\003\000\000\000\000\161\002\000\000\
\000\000\151\001\180\000\180\000\181\000\107\000\000\000\180\000\
\181\000\180\000\161\002\161\002\000\000\000\000\000\000\000\000\
\000\000\107\000\000\000\000\000\107\000\000\000\000\000\000\000\
\178\001\000\000\000\000\000\000\000\000\044\004\000\000\000\000\
\231\000\231\000\000\000\180\000\000\000\000\000\000\000\181\000\
\000\000\000\000\180\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\137\000\000\000\138\000\139\000\032\000\
\181\000\140\000\000\000\179\000\141\000\142\000\180\000\000\000\
\181\000\000\000\181\000\000\000\000\000\000\000\000\000\000\000\
\224\002\000\000\000\000\224\002\215\001\000\000\143\000\000\000\
\000\000\000\000\000\000\000\000\000\000\224\002\144\000\145\000\
\000\000\138\001\139\001\000\000\000\000\000\000\146\000\179\000\
\000\000\000\000\224\002\000\000\224\002\224\002\000\000\000\000\
\000\000\000\000\147\000\148\000\000\000\180\000\000\000\000\000\
\000\000\224\002\000\000\179\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\151\001\000\000\000\000\
\000\000\000\000\000\000\179\000\253\001\224\002\000\000\000\000\
\000\000\000\000\000\000\239\001\000\000\224\002\239\001\000\000\
\000\000\000\000\000\000\224\002\000\000\181\000\181\000\000\000\
\239\001\151\001\224\002\000\000\000\000\000\000\215\001\000\000\
\000\000\000\000\000\000\151\001\000\000\239\001\239\001\239\001\
\239\001\000\000\224\002\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\239\001\000\000\224\002\000\000\
\000\000\224\002\000\000\102\002\180\000\194\004\000\000\000\000\
\180\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\239\001\000\000\000\000\239\001\000\000\000\000\239\001\239\001\
\239\001\000\000\151\001\000\000\000\000\178\001\239\001\010\000\
\092\000\176\001\000\000\000\000\000\000\239\001\151\001\180\000\
\181\000\000\000\000\000\215\001\000\000\092\000\151\001\000\000\
\000\000\239\001\195\000\239\001\000\000\239\001\239\001\000\000\
\180\000\181\000\092\000\000\000\092\000\092\000\000\000\215\001\
\180\000\239\001\180\000\000\000\239\001\000\000\000\000\000\000\
\239\001\092\000\000\000\000\000\181\000\000\000\000\000\000\000\
\000\000\137\000\000\000\138\000\139\000\032\000\151\001\140\000\
\000\000\000\000\141\000\142\000\000\000\092\000\000\000\000\000\
\181\000\000\000\000\000\081\004\000\000\092\000\000\000\000\000\
\000\000\000\000\000\000\092\000\143\000\000\000\000\000\000\000\
\181\000\000\000\092\000\000\000\144\000\145\000\006\001\000\000\
\000\000\000\000\000\000\151\001\146\000\000\000\151\001\151\001\
\000\000\000\000\092\000\000\000\000\000\000\000\000\000\000\000\
\147\000\148\000\000\000\181\000\000\000\000\000\092\000\000\000\
\000\000\092\000\000\000\000\000\000\000\180\000\180\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\179\000\103\002\104\002\105\002\106\002\107\002\108\002\109\002\
\110\002\111\002\112\002\113\002\114\002\115\002\116\002\117\002\
\118\002\119\002\120\002\121\002\122\002\123\002\215\001\125\002\
\000\000\000\000\000\000\000\000\000\000\195\000\000\000\000\000\
\000\000\081\004\000\000\000\000\000\000\135\002\000\000\215\001\
\000\000\000\000\000\000\000\000\253\001\151\001\253\001\253\001\
\181\000\148\002\000\000\000\000\253\001\000\000\000\000\000\000\
\000\000\253\001\000\000\000\000\000\000\253\001\253\001\253\001\
\180\000\000\000\000\000\000\000\181\000\000\000\253\001\253\001\
\253\001\253\001\000\000\000\000\207\004\000\000\000\000\000\000\
\253\001\180\000\000\000\000\000\215\001\253\001\000\000\000\000\
\000\000\000\000\000\000\253\001\253\001\000\000\000\000\000\000\
\000\000\013\001\000\000\000\000\180\000\000\000\000\000\000\000\
\000\000\253\001\000\000\000\000\253\001\000\000\000\000\253\001\
\253\001\253\001\000\000\253\001\000\000\000\000\000\000\253\001\
\180\000\000\000\000\000\000\000\000\000\000\000\253\001\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\180\000\253\001\253\001\000\000\253\001\253\001\253\001\253\001\
\215\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\253\001\000\000\000\000\253\001\000\000\000\000\
\000\000\253\001\000\000\180\000\000\000\181\000\000\000\000\000\
\000\000\000\000\137\000\000\000\138\000\139\000\032\000\151\001\
\140\000\000\000\000\000\141\000\142\000\000\000\000\000\000\000\
\207\004\000\000\000\000\181\000\000\000\037\005\038\005\000\000\
\000\000\000\000\000\000\000\000\000\000\143\000\000\000\000\000\
\081\004\000\000\000\000\025\003\181\000\144\000\145\000\000\000\
\000\000\000\000\000\000\000\000\035\003\146\000\006\001\000\000\
\037\003\006\001\000\000\041\003\000\000\000\000\006\001\000\000\
\006\001\147\000\148\000\006\001\006\001\081\004\000\000\006\001\
\180\000\006\001\006\001\006\001\000\000\000\000\006\001\006\001\
\006\001\079\002\006\001\006\001\000\000\000\000\000\000\000\000\
\000\000\181\000\000\000\006\001\180\000\151\001\006\001\006\001\
\000\000\000\000\000\000\000\000\000\000\006\001\006\001\000\000\
\000\000\000\000\000\000\000\000\231\000\231\000\000\000\000\000\
\000\000\000\000\000\000\006\001\000\000\000\000\006\001\000\000\
\000\000\000\000\006\001\006\001\000\000\006\001\000\000\000\000\
\006\001\006\001\000\000\000\000\000\000\000\000\000\000\000\000\
\006\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\106\003\006\001\006\001\181\000\006\001\006\001\
\006\001\006\001\000\000\000\000\000\000\000\000\000\000\006\001\
\000\000\006\001\207\004\000\000\006\001\000\000\000\000\006\001\
\000\000\081\004\000\000\006\001\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\081\004\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\137\000\180\000\138\000\139\000\
\032\000\013\001\140\000\000\000\013\001\141\000\142\000\000\000\
\000\000\013\001\000\000\013\001\000\000\114\002\013\001\013\001\
\000\000\000\000\013\001\180\000\013\001\013\001\013\001\143\000\
\000\000\013\001\013\001\013\001\000\000\013\001\013\001\144\000\
\144\003\000\000\000\000\000\000\180\000\000\000\013\001\146\000\
\081\004\013\001\013\001\207\004\000\000\000\000\000\000\000\000\
\013\001\013\001\177\003\147\000\148\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\013\001\000\000\
\000\000\013\001\000\000\000\000\000\000\013\001\013\001\000\000\
\013\001\000\000\000\000\013\001\013\001\000\000\000\000\000\000\
\000\000\180\000\000\000\013\001\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\081\004\208\003\000\000\013\001\013\001\
\000\000\013\001\013\001\013\001\013\001\000\000\000\000\000\000\
\000\000\000\000\013\001\000\000\013\001\000\000\000\000\013\001\
\000\000\000\000\013\001\000\000\000\000\000\000\013\001\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\223\003\000\000\000\000\000\000\000\000\000\000\000\000\224\000\
\000\000\000\000\000\000\000\000\000\000\180\000\000\000\000\000\
\000\000\079\002\079\002\079\002\079\002\000\000\000\000\079\002\
\079\002\079\002\079\002\079\002\079\002\079\002\079\002\079\002\
\079\002\079\002\079\002\079\002\079\002\079\002\079\002\079\002\
\000\000\079\002\079\002\079\002\079\002\079\002\079\002\079\002\
\079\002\000\000\000\000\000\000\000\000\079\002\079\002\000\000\
\022\004\079\002\079\002\079\002\079\002\079\002\079\002\079\002\
\079\002\079\002\079\002\079\002\079\002\079\002\000\000\079\002\
\079\002\079\002\079\002\000\000\000\000\079\002\079\002\079\002\
\058\002\079\002\079\002\079\002\079\002\079\002\079\002\000\000\
\079\002\079\002\079\002\079\002\079\002\000\000\079\002\079\002\
\000\000\000\000\000\000\079\002\079\002\079\002\079\002\079\002\
\079\002\079\002\079\002\000\000\079\002\000\000\079\002\079\002\
\000\000\079\002\079\002\079\002\079\002\079\002\000\000\079\002\
\079\002\000\000\079\002\079\002\079\002\079\002\029\001\079\002\
\079\002\000\000\079\002\000\000\000\000\000\000\079\002\000\000\
\000\000\000\000\000\000\000\000\000\000\114\002\114\002\114\002\
\114\002\114\002\000\000\114\002\114\002\114\002\114\002\114\002\
\114\002\114\002\114\002\114\002\114\002\114\002\114\002\114\002\
\114\002\114\002\114\002\000\000\122\004\114\002\114\002\114\002\
\114\002\114\002\114\002\114\002\114\002\000\000\000\000\000\000\
\000\000\114\002\114\002\000\000\000\000\114\002\114\002\114\002\
\114\002\114\002\114\002\114\002\114\002\114\002\114\002\114\002\
\114\002\114\002\000\000\114\002\114\002\114\002\114\002\000\000\
\000\000\114\002\114\002\114\002\000\000\114\002\114\002\114\002\
\114\002\114\002\114\002\000\000\114\002\114\002\114\002\114\002\
\114\002\000\000\114\002\114\002\000\000\000\000\000\000\114\002\
\114\002\114\002\114\002\114\002\114\002\114\002\114\002\000\000\
\114\002\000\000\114\002\114\002\000\000\114\002\114\002\114\002\
\114\002\114\002\000\000\114\002\114\002\060\001\114\002\114\002\
\114\002\114\002\000\000\114\002\114\002\000\000\114\002\000\000\
\000\000\000\000\114\002\000\000\000\000\000\000\000\000\224\000\
\224\000\224\000\224\000\000\000\000\000\000\000\000\000\224\000\
\224\000\224\000\000\000\000\000\224\000\224\000\224\000\224\000\
\224\000\224\000\224\000\224\000\224\000\000\000\000\000\224\000\
\224\000\224\000\224\000\224\000\224\000\000\000\000\000\000\000\
\000\000\000\000\000\000\224\000\224\000\000\000\000\000\224\000\
\224\000\224\000\224\000\224\000\224\000\224\000\224\000\224\000\
\000\000\000\000\000\000\000\000\241\004\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\224\000\224\000\000\000\224\000\
\248\004\000\000\224\000\224\000\224\000\000\000\224\000\224\000\
\224\000\224\000\224\000\000\000\000\000\000\000\000\000\000\000\
\000\000\224\000\000\000\224\000\224\000\224\000\224\000\224\000\
\000\000\000\000\000\000\000\000\224\000\224\000\000\000\224\000\
\224\000\224\000\224\000\036\001\000\000\224\000\000\000\000\000\
\224\000\000\000\224\000\000\000\000\000\224\000\000\000\000\000\
\224\000\033\005\034\005\035\005\224\000\000\000\029\001\029\001\
\029\001\029\001\000\000\000\000\029\001\029\001\029\001\029\001\
\029\001\029\001\029\001\029\001\029\001\029\001\029\001\029\001\
\029\001\029\001\029\001\029\001\029\001\000\000\029\001\029\001\
\029\001\029\001\029\001\029\001\029\001\029\001\000\000\000\000\
\000\000\000\000\029\001\029\001\000\000\000\000\029\001\029\001\
\029\001\029\001\029\001\029\001\029\001\029\001\029\001\029\001\
\029\001\029\001\029\001\000\000\029\001\029\001\029\001\029\001\
\000\000\000\000\029\001\029\001\029\001\000\000\029\001\029\001\
\029\001\029\001\029\001\029\001\000\000\029\001\029\001\029\001\
\029\001\029\001\000\000\029\001\029\001\000\000\000\000\000\000\
\029\001\029\001\029\001\029\001\029\001\029\001\029\001\029\001\
\000\000\029\001\000\000\029\001\029\001\000\000\029\001\029\001\
\029\001\029\001\029\001\034\001\029\001\029\001\000\000\029\001\
\029\001\029\001\029\001\000\000\029\001\029\001\000\000\029\001\
\000\000\000\000\000\000\029\001\000\000\060\001\060\001\060\001\
\060\001\060\001\000\000\060\001\060\001\060\001\060\001\060\001\
\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\
\060\001\060\001\060\001\000\000\000\000\060\001\060\001\060\001\
\060\001\060\001\060\001\060\001\060\001\000\000\000\000\000\000\
\000\000\060\001\060\001\000\000\000\000\060\001\060\001\060\001\
\060\001\060\001\060\001\060\001\060\001\060\001\060\001\060\001\
\060\001\060\001\000\000\060\001\060\001\060\001\060\001\000\000\
\000\000\060\001\060\001\060\001\000\000\060\001\060\001\060\001\
\060\001\060\001\060\001\000\000\060\001\060\001\060\001\060\001\
\060\001\000\000\060\001\060\001\000\000\000\000\000\000\060\001\
\060\001\060\001\060\001\060\001\060\001\060\001\060\001\000\000\
\060\001\000\000\060\001\060\001\000\000\060\001\060\001\060\001\
\060\001\060\001\032\001\060\001\060\001\000\000\060\001\060\001\
\060\001\060\001\000\000\060\001\060\001\000\000\060\001\000\000\
\000\000\000\000\060\001\036\001\036\001\036\001\036\001\000\000\
\000\000\036\001\036\001\036\001\036\001\036\001\036\001\036\001\
\036\001\036\001\036\001\036\001\036\001\036\001\036\001\036\001\
\036\001\036\001\000\000\036\001\036\001\036\001\036\001\036\001\
\036\001\036\001\036\001\000\000\000\000\000\000\000\000\036\001\
\036\001\000\000\000\000\036\001\036\001\036\001\036\001\036\001\
\036\001\036\001\036\001\036\001\036\001\036\001\036\001\036\001\
\000\000\036\001\036\001\036\001\036\001\000\000\000\000\036\001\
\036\001\036\001\000\000\036\001\036\001\036\001\036\001\036\001\
\036\001\000\000\036\001\036\001\036\001\036\001\036\001\000\000\
\036\001\036\001\000\000\000\000\000\000\036\001\036\001\036\001\
\036\001\036\001\036\001\036\001\036\001\000\000\036\001\000\000\
\036\001\036\001\000\000\036\001\036\001\036\001\036\001\036\001\
\069\001\036\001\036\001\000\000\036\001\036\001\036\001\036\001\
\000\000\036\001\036\001\000\000\036\001\000\000\000\000\000\000\
\036\001\000\000\000\000\034\001\034\001\034\001\034\001\000\000\
\000\000\034\001\034\001\034\001\034\001\034\001\034\001\034\001\
\034\001\034\001\034\001\034\001\034\001\034\001\034\001\034\001\
\034\001\034\001\000\000\034\001\034\001\034\001\034\001\034\001\
\034\001\034\001\034\001\000\000\000\000\000\000\000\000\034\001\
\034\001\000\000\000\000\034\001\034\001\034\001\034\001\034\001\
\034\001\034\001\034\001\034\001\034\001\034\001\034\001\034\001\
\000\000\034\001\034\001\034\001\034\001\000\000\000\000\034\001\
\034\001\034\001\000\000\034\001\034\001\034\001\034\001\034\001\
\034\001\000\000\034\001\034\001\034\001\034\001\034\001\000\000\
\034\001\034\001\000\000\000\000\000\000\034\001\034\001\034\001\
\034\001\034\001\034\001\034\001\034\001\000\000\034\001\000\000\
\034\001\034\001\000\000\034\001\034\001\034\001\034\001\034\001\
\071\001\034\001\034\001\000\000\034\001\034\001\034\001\034\001\
\000\000\034\001\034\001\000\000\034\001\000\000\000\000\000\000\
\034\001\000\000\032\001\032\001\032\001\032\001\000\000\000\000\
\032\001\032\001\032\001\032\001\032\001\032\001\032\001\032\001\
\032\001\032\001\032\001\032\001\032\001\032\001\032\001\032\001\
\032\001\000\000\032\001\032\001\032\001\032\001\032\001\032\001\
\032\001\032\001\000\000\000\000\000\000\000\000\032\001\032\001\
\000\000\000\000\032\001\032\001\032\001\032\001\032\001\032\001\
\032\001\032\001\032\001\032\001\032\001\032\001\032\001\000\000\
\032\001\032\001\032\001\032\001\000\000\000\000\032\001\032\001\
\032\001\000\000\032\001\032\001\032\001\032\001\032\001\032\001\
\000\000\032\001\032\001\032\001\032\001\032\001\000\000\032\001\
\032\001\000\000\000\000\000\000\032\001\032\001\032\001\032\001\
\032\001\032\001\032\001\032\001\000\000\032\001\000\000\032\001\
\032\001\000\000\032\001\032\001\032\001\032\001\032\001\074\001\
\032\001\032\001\000\000\032\001\032\001\032\001\032\001\000\000\
\032\001\032\001\000\000\032\001\000\000\000\000\000\000\032\001\
\069\001\069\001\069\001\069\001\069\001\000\000\069\001\069\001\
\069\001\069\001\069\001\069\001\069\001\069\001\069\001\069\001\
\069\001\069\001\069\001\069\001\069\001\069\001\000\000\000\000\
\069\001\069\001\069\001\069\001\069\001\069\001\069\001\069\001\
\000\000\000\000\000\000\000\000\069\001\069\001\000\000\000\000\
\069\001\069\001\069\001\069\001\069\001\069\001\069\001\069\001\
\069\001\069\001\069\001\069\001\069\001\000\000\069\001\069\001\
\069\001\069\001\000\000\000\000\069\001\069\001\069\001\000\000\
\069\001\069\001\069\001\069\001\069\001\069\001\000\000\069\001\
\069\001\069\001\069\001\069\001\000\000\069\001\069\001\000\000\
\000\000\000\000\069\001\069\001\069\001\069\001\069\001\069\001\
\069\001\069\001\000\000\069\001\000\000\069\001\069\001\000\000\
\069\001\069\001\069\001\000\000\000\000\021\001\069\001\069\001\
\000\000\069\001\069\001\069\001\069\001\000\000\069\001\069\001\
\000\000\069\001\000\000\000\000\000\000\069\001\000\000\000\000\
\071\001\071\001\071\001\071\001\071\001\000\000\071\001\071\001\
\071\001\071\001\071\001\071\001\071\001\071\001\071\001\071\001\
\071\001\071\001\071\001\071\001\071\001\071\001\000\000\000\000\
\071\001\071\001\071\001\071\001\071\001\071\001\071\001\071\001\
\000\000\000\000\000\000\000\000\071\001\071\001\000\000\000\000\
\071\001\071\001\071\001\071\001\071\001\071\001\071\001\071\001\
\071\001\071\001\071\001\071\001\071\001\000\000\071\001\071\001\
\071\001\071\001\000\000\000\000\071\001\071\001\071\001\000\000\
\071\001\071\001\071\001\071\001\071\001\071\001\000\000\071\001\
\071\001\071\001\071\001\071\001\000\000\071\001\071\001\000\000\
\000\000\000\000\071\001\071\001\071\001\071\001\071\001\071\001\
\071\001\071\001\000\000\071\001\000\000\071\001\071\001\000\000\
\071\001\071\001\071\001\022\001\000\000\000\000\071\001\071\001\
\000\000\071\001\071\001\071\001\071\001\000\000\071\001\071\001\
\000\000\071\001\000\000\000\000\000\000\071\001\000\000\074\001\
\074\001\074\001\074\001\074\001\000\000\074\001\074\001\074\001\
\074\001\074\001\074\001\074\001\074\001\074\001\074\001\074\001\
\074\001\074\001\074\001\074\001\074\001\000\000\000\000\074\001\
\074\001\074\001\074\001\074\001\074\001\074\001\074\001\000\000\
\000\000\000\000\000\000\074\001\074\001\000\000\000\000\074\001\
\074\001\074\001\074\001\074\001\074\001\074\001\074\001\074\001\
\074\001\074\001\074\001\074\001\000\000\074\001\074\001\074\001\
\074\001\000\000\000\000\074\001\074\001\074\001\000\000\074\001\
\074\001\074\001\074\001\074\001\074\001\000\000\074\001\074\001\
\074\001\074\001\074\001\000\000\074\001\074\001\000\000\000\000\
\000\000\074\001\074\001\074\001\074\001\074\001\074\001\074\001\
\074\001\000\000\074\001\000\000\074\001\074\001\000\000\074\001\
\074\001\074\001\223\000\000\000\000\000\074\001\074\001\000\000\
\074\001\074\001\074\001\074\001\000\000\074\001\074\001\000\000\
\074\001\000\000\000\000\000\000\074\001\021\001\021\001\021\001\
\021\001\000\000\000\000\000\000\000\000\021\001\021\001\021\001\
\000\000\000\000\021\001\021\001\021\001\021\001\021\001\021\001\
\021\001\021\001\021\001\021\001\000\000\021\001\021\001\021\001\
\021\001\021\001\021\001\000\000\000\000\000\000\000\000\000\000\
\000\000\021\001\021\001\000\000\000\000\021\001\021\001\021\001\
\021\001\021\001\021\001\021\001\021\001\021\001\000\000\000\000\
\000\000\021\001\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\021\001\021\001\000\000\021\001\000\000\000\000\
\021\001\021\001\021\001\000\000\021\001\021\001\021\001\021\001\
\021\001\000\000\000\000\000\000\000\000\000\000\000\000\021\001\
\021\001\021\001\021\001\021\001\021\001\021\001\000\000\000\000\
\021\001\000\000\021\001\021\001\000\000\021\001\021\001\021\001\
\021\001\021\001\234\000\021\001\000\000\000\000\021\001\021\001\
\021\001\000\000\000\000\021\001\000\000\000\000\021\001\000\000\
\000\000\000\000\021\001\022\001\022\001\022\001\022\001\000\000\
\000\000\000\000\000\000\022\001\022\001\022\001\000\000\000\000\
\022\001\022\001\022\001\022\001\022\001\022\001\022\001\022\001\
\022\001\022\001\000\000\022\001\022\001\022\001\022\001\022\001\
\022\001\000\000\000\000\000\000\000\000\000\000\000\000\022\001\
\022\001\000\000\000\000\022\001\022\001\022\001\022\001\022\001\
\022\001\022\001\022\001\022\001\000\000\000\000\000\000\022\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\022\001\022\001\000\000\022\001\000\000\000\000\022\001\022\001\
\022\001\000\000\022\001\022\001\022\001\022\001\022\001\000\000\
\000\000\000\000\000\000\000\000\000\000\022\001\022\001\022\001\
\022\001\022\001\022\001\022\001\000\000\000\000\022\001\000\000\
\022\001\022\001\000\000\022\001\022\001\022\001\022\001\022\001\
\235\000\022\001\000\000\000\000\022\001\022\001\022\001\000\000\
\000\000\022\001\000\000\000\000\022\001\000\000\000\000\000\000\
\022\001\000\000\223\000\223\000\223\000\223\000\000\000\000\000\
\000\000\000\000\223\000\223\000\223\000\000\000\000\000\223\000\
\223\000\223\000\223\000\223\000\223\000\223\000\223\000\223\000\
\000\000\000\000\223\000\223\000\223\000\223\000\223\000\223\000\
\000\000\000\000\000\000\000\000\000\000\000\000\223\000\223\000\
\000\000\000\000\223\000\223\000\223\000\223\000\223\000\223\000\
\223\000\223\000\223\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\223\000\
\223\000\000\000\223\000\000\000\000\000\223\000\223\000\223\000\
\000\000\223\000\223\000\223\000\223\000\223\000\000\000\000\000\
\000\000\000\000\000\000\000\000\223\000\000\000\223\000\223\000\
\223\000\223\000\223\000\000\000\000\000\000\000\000\000\223\000\
\223\000\000\000\223\000\223\000\223\000\000\000\236\000\000\000\
\223\000\000\000\000\000\223\000\000\000\223\000\000\000\000\000\
\223\000\000\000\000\000\223\000\000\000\000\000\000\000\223\000\
\000\000\000\000\234\000\234\000\234\000\234\000\000\000\000\000\
\000\000\000\000\234\000\234\000\234\000\000\000\000\000\234\000\
\234\000\234\000\234\000\234\000\000\000\234\000\234\000\234\000\
\000\000\000\000\234\000\234\000\234\000\234\000\234\000\234\000\
\000\000\000\000\000\000\000\000\000\000\000\000\234\000\234\000\
\000\000\000\000\234\000\234\000\234\000\234\000\234\000\234\000\
\234\000\234\000\234\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\234\000\
\234\000\000\000\234\000\000\000\000\000\234\000\234\000\234\000\
\000\000\234\000\234\000\234\000\234\000\234\000\000\000\000\000\
\000\000\000\000\000\000\000\000\234\000\000\000\234\000\234\000\
\234\000\234\000\234\000\000\000\000\000\000\000\000\000\234\000\
\234\000\000\000\234\000\234\000\234\000\234\000\014\001\000\000\
\234\000\000\000\000\000\234\000\000\000\234\000\000\000\000\000\
\234\000\000\000\000\000\234\000\000\000\000\000\000\000\234\000\
\235\000\235\000\235\000\235\000\000\000\000\000\000\000\000\000\
\235\000\235\000\235\000\000\000\000\000\235\000\235\000\235\000\
\235\000\235\000\235\000\235\000\235\000\235\000\000\000\000\000\
\235\000\235\000\235\000\235\000\235\000\235\000\000\000\000\000\
\000\000\000\000\000\000\000\000\235\000\235\000\000\000\000\000\
\235\000\235\000\235\000\235\000\235\000\235\000\235\000\235\000\
\235\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\235\000\235\000\000\000\
\235\000\000\000\000\000\235\000\235\000\235\000\000\000\235\000\
\235\000\235\000\235\000\235\000\000\000\000\000\000\000\000\000\
\000\000\000\000\235\000\000\000\235\000\235\000\235\000\235\000\
\235\000\000\000\000\000\000\000\000\000\235\000\235\000\000\000\
\235\000\235\000\235\000\000\000\015\001\000\000\235\000\000\000\
\000\000\235\000\000\000\235\000\000\000\000\000\235\000\000\000\
\000\000\235\000\000\000\000\000\000\000\235\000\236\000\236\000\
\236\000\236\000\000\000\000\000\000\000\000\000\236\000\236\000\
\236\000\000\000\000\000\236\000\236\000\236\000\236\000\236\000\
\236\000\236\000\236\000\236\000\000\000\000\000\236\000\236\000\
\236\000\236\000\236\000\236\000\000\000\000\000\000\000\000\000\
\000\000\000\000\236\000\236\000\000\000\000\000\236\000\236\000\
\236\000\236\000\236\000\236\000\236\000\236\000\236\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\236\000\236\000\000\000\236\000\000\000\
\000\000\236\000\236\000\236\000\000\000\236\000\236\000\236\000\
\236\000\236\000\000\000\000\000\000\000\000\000\000\000\000\000\
\236\000\000\000\236\000\236\000\236\000\236\000\236\000\000\000\
\000\000\000\000\000\000\236\000\236\000\000\000\236\000\236\000\
\236\000\000\000\246\000\000\000\236\000\000\000\000\000\236\000\
\000\000\236\000\000\000\000\000\236\000\000\000\000\000\236\000\
\000\000\000\000\000\000\236\000\000\000\000\000\014\001\014\001\
\014\001\014\001\000\000\000\000\000\000\000\000\014\001\014\001\
\014\001\000\000\000\000\014\001\014\001\014\001\014\001\014\001\
\014\001\014\001\014\001\014\001\000\000\000\000\014\001\014\001\
\014\001\014\001\014\001\014\001\000\000\000\000\000\000\000\000\
\000\000\000\000\014\001\014\001\000\000\000\000\014\001\014\001\
\014\001\014\001\014\001\014\001\014\001\014\001\014\001\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\014\001\014\001\000\000\014\001\000\000\
\000\000\014\001\014\001\014\001\000\000\014\001\014\001\014\001\
\014\001\014\001\000\000\000\000\000\000\000\000\000\000\000\000\
\014\001\000\000\014\001\014\001\014\001\014\001\014\001\000\000\
\000\000\000\000\000\000\014\001\014\001\000\000\014\001\014\001\
\014\001\247\000\000\000\000\000\014\001\000\000\000\000\014\001\
\000\000\014\001\000\000\000\000\014\001\000\000\000\000\014\001\
\000\000\000\000\000\000\014\001\015\001\015\001\015\001\015\001\
\000\000\000\000\000\000\000\000\015\001\015\001\015\001\000\000\
\000\000\015\001\015\001\015\001\015\001\015\001\015\001\015\001\
\015\001\015\001\000\000\000\000\015\001\015\001\015\001\015\001\
\015\001\015\001\000\000\000\000\000\000\000\000\000\000\000\000\
\015\001\015\001\000\000\000\000\015\001\015\001\015\001\015\001\
\015\001\015\001\015\001\015\001\015\001\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\015\001\015\001\000\000\015\001\000\000\000\000\015\001\
\015\001\015\001\000\000\015\001\015\001\015\001\015\001\015\001\
\000\000\000\000\000\000\000\000\000\000\000\000\015\001\000\000\
\015\001\015\001\015\001\015\001\015\001\000\000\000\000\000\000\
\000\000\015\001\015\001\000\000\015\001\015\001\015\001\254\000\
\000\000\000\000\015\001\000\000\000\000\015\001\000\000\015\001\
\000\000\000\000\015\001\000\000\000\000\015\001\000\000\000\000\
\000\000\015\001\246\000\246\000\246\000\246\000\000\000\000\000\
\000\000\000\000\246\000\246\000\246\000\000\000\000\000\246\000\
\246\000\246\000\246\000\246\000\246\000\246\000\246\000\246\000\
\000\000\000\000\246\000\246\000\246\000\246\000\246\000\246\000\
\000\000\000\000\000\000\000\000\000\000\000\000\246\000\246\000\
\000\000\000\000\246\000\246\000\246\000\246\000\246\000\246\000\
\000\000\246\000\246\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\246\000\
\246\000\000\000\246\000\000\000\000\000\246\000\246\000\246\000\
\000\000\246\000\246\000\246\000\246\000\246\000\000\000\000\000\
\000\000\000\000\000\000\000\000\246\000\000\000\246\000\246\000\
\246\000\246\000\246\000\000\000\000\000\000\000\000\000\246\000\
\246\000\000\000\246\000\246\000\246\000\246\000\253\000\000\000\
\246\000\000\000\000\000\246\000\000\000\246\000\000\000\000\000\
\246\000\000\000\000\000\246\000\000\000\000\000\000\000\246\000\
\000\000\247\000\247\000\247\000\247\000\000\000\000\000\000\000\
\000\000\247\000\247\000\247\000\000\000\000\000\247\000\247\000\
\247\000\247\000\247\000\247\000\247\000\247\000\247\000\000\000\
\000\000\247\000\247\000\247\000\247\000\247\000\247\000\000\000\
\000\000\000\000\000\000\000\000\000\000\247\000\247\000\000\000\
\000\000\247\000\247\000\247\000\247\000\247\000\247\000\000\000\
\247\000\247\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\247\000\247\000\
\000\000\247\000\000\000\000\000\247\000\247\000\247\000\000\000\
\247\000\247\000\247\000\247\000\247\000\000\000\000\000\000\000\
\000\000\000\000\000\000\247\000\000\000\247\000\247\000\247\000\
\247\000\247\000\000\000\000\000\000\000\000\000\247\000\247\000\
\000\000\247\000\247\000\247\000\247\000\228\000\000\000\247\000\
\000\000\000\000\247\000\000\000\247\000\000\000\000\000\247\000\
\000\000\000\000\247\000\000\000\000\000\000\000\247\000\254\000\
\254\000\254\000\254\000\000\000\000\000\000\000\000\000\254\000\
\254\000\254\000\000\000\000\000\254\000\254\000\254\000\254\000\
\254\000\254\000\254\000\254\000\254\000\000\000\000\000\254\000\
\254\000\254\000\254\000\254\000\254\000\000\000\000\000\000\000\
\000\000\000\000\000\000\254\000\254\000\000\000\000\000\254\000\
\254\000\254\000\254\000\254\000\254\000\000\000\254\000\254\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\254\000\254\000\000\000\254\000\
\000\000\000\000\254\000\254\000\254\000\000\000\254\000\254\000\
\254\000\254\000\254\000\000\000\000\000\000\000\000\000\000\000\
\000\000\254\000\000\000\254\000\254\000\254\000\254\000\254\000\
\000\000\000\000\000\000\000\000\254\000\254\000\000\000\254\000\
\254\000\254\000\254\000\231\000\000\000\254\000\000\000\000\000\
\254\000\000\000\254\000\000\000\000\000\254\000\000\000\000\000\
\254\000\000\000\000\000\000\000\254\000\000\000\253\000\253\000\
\253\000\253\000\000\000\000\000\000\000\000\000\253\000\253\000\
\253\000\000\000\000\000\253\000\253\000\253\000\253\000\253\000\
\253\000\253\000\253\000\253\000\000\000\000\000\253\000\253\000\
\253\000\253\000\253\000\253\000\000\000\000\000\000\000\000\000\
\000\000\000\000\253\000\253\000\000\000\000\000\253\000\253\000\
\253\000\253\000\253\000\253\000\000\000\253\000\253\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\253\000\253\000\000\000\253\000\000\000\
\000\000\253\000\253\000\253\000\000\000\253\000\253\000\253\000\
\253\000\253\000\000\000\000\000\000\000\000\000\000\000\000\000\
\253\000\000\000\253\000\253\000\253\000\253\000\253\000\000\000\
\000\000\000\000\000\000\253\000\253\000\000\000\253\000\253\000\
\253\000\253\000\232\000\000\000\253\000\000\000\000\000\253\000\
\000\000\253\000\000\000\000\000\253\000\000\000\000\000\253\000\
\000\000\000\000\000\000\253\000\000\000\228\000\228\000\228\000\
\228\000\000\000\000\000\000\000\000\000\000\000\228\000\228\000\
\000\000\000\000\228\000\228\000\228\000\228\000\228\000\228\000\
\228\000\228\000\228\000\000\000\000\000\228\000\228\000\228\000\
\228\000\228\000\228\000\000\000\000\000\000\000\000\000\000\000\
\000\000\228\000\228\000\000\000\000\000\228\000\228\000\228\000\
\228\000\228\000\228\000\228\000\228\000\228\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\228\000\228\000\000\000\228\000\000\000\000\000\
\228\000\228\000\228\000\000\000\228\000\228\000\228\000\228\000\
\228\000\000\000\000\000\000\000\000\000\000\000\000\000\228\000\
\000\000\228\000\228\000\228\000\228\000\228\000\000\000\000\000\
\000\000\000\000\228\000\228\000\000\000\228\000\228\000\228\000\
\228\000\245\000\000\000\228\000\000\000\000\000\228\000\000\000\
\228\000\000\000\000\000\228\000\000\000\000\000\228\000\000\000\
\000\000\000\000\228\000\231\000\231\000\231\000\231\000\000\000\
\000\000\000\000\000\000\000\000\231\000\231\000\000\000\000\000\
\231\000\231\000\231\000\231\000\231\000\231\000\231\000\231\000\
\231\000\000\000\000\000\231\000\231\000\231\000\231\000\231\000\
\231\000\000\000\000\000\000\000\000\000\000\000\000\000\231\000\
\231\000\000\000\000\000\231\000\231\000\231\000\231\000\231\000\
\231\000\231\000\231\000\231\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\231\000\231\000\000\000\231\000\000\000\000\000\231\000\231\000\
\231\000\000\000\231\000\231\000\231\000\231\000\231\000\000\000\
\000\000\000\000\000\000\000\000\000\000\231\000\000\000\231\000\
\231\000\231\000\231\000\231\000\000\000\000\000\000\000\000\000\
\231\000\231\000\000\000\231\000\231\000\231\000\231\000\251\000\
\000\000\231\000\000\000\000\000\231\000\000\000\231\000\000\000\
\000\000\231\000\000\000\000\000\231\000\000\000\000\000\000\000\
\231\000\000\000\232\000\232\000\232\000\232\000\000\000\000\000\
\000\000\000\000\000\000\232\000\232\000\000\000\000\000\232\000\
\232\000\232\000\232\000\232\000\232\000\232\000\232\000\232\000\
\000\000\000\000\232\000\232\000\232\000\232\000\232\000\232\000\
\000\000\000\000\000\000\000\000\000\000\000\000\232\000\232\000\
\000\000\000\000\232\000\232\000\232\000\232\000\232\000\232\000\
\232\000\232\000\232\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\232\000\
\232\000\000\000\232\000\000\000\000\000\232\000\232\000\232\000\
\000\000\232\000\232\000\232\000\232\000\232\000\000\000\000\000\
\000\000\000\000\000\000\000\000\232\000\000\000\232\000\232\000\
\232\000\232\000\232\000\000\000\000\000\000\000\000\000\232\000\
\232\000\000\000\232\000\232\000\232\000\232\000\252\000\000\000\
\232\000\000\000\000\000\232\000\000\000\232\000\000\000\000\000\
\232\000\000\000\000\000\232\000\000\000\000\000\000\000\232\000\
\000\000\245\000\245\000\245\000\245\000\000\000\000\000\000\000\
\000\000\245\000\245\000\245\000\000\000\000\000\245\000\245\000\
\245\000\245\000\245\000\245\000\245\000\245\000\245\000\000\000\
\000\000\245\000\245\000\245\000\245\000\245\000\245\000\000\000\
\000\000\000\000\000\000\000\000\000\000\245\000\245\000\000\000\
\000\000\245\000\245\000\245\000\245\000\245\000\000\000\000\000\
\245\000\245\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\245\000\245\000\
\000\000\245\000\000\000\000\000\245\000\245\000\245\000\000\000\
\245\000\245\000\245\000\245\000\245\000\000\000\000\000\000\000\
\000\000\000\000\000\000\245\000\000\000\245\000\000\000\245\000\
\245\000\245\000\000\000\000\000\000\000\000\000\245\000\245\000\
\000\000\245\000\245\000\245\000\245\000\248\000\000\000\000\000\
\000\000\000\000\245\000\000\000\245\000\000\000\000\000\245\000\
\000\000\000\000\245\000\000\000\000\000\000\000\245\000\251\000\
\251\000\251\000\251\000\000\000\000\000\000\000\000\000\251\000\
\251\000\251\000\000\000\000\000\251\000\251\000\251\000\251\000\
\251\000\251\000\251\000\251\000\251\000\000\000\000\000\251\000\
\251\000\251\000\251\000\251\000\251\000\000\000\000\000\000\000\
\000\000\000\000\000\000\251\000\251\000\000\000\000\000\251\000\
\251\000\251\000\251\000\251\000\000\000\000\000\251\000\251\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\251\000\251\000\000\000\251\000\
\000\000\000\000\251\000\251\000\251\000\000\000\251\000\251\000\
\251\000\251\000\251\000\000\000\000\000\000\000\000\000\000\000\
\000\000\251\000\000\000\251\000\000\000\251\000\251\000\251\000\
\000\000\000\000\000\000\000\000\251\000\251\000\000\000\251\000\
\251\000\251\000\251\000\249\000\000\000\000\000\000\000\000\000\
\251\000\000\000\251\000\000\000\000\000\251\000\000\000\000\000\
\251\000\000\000\000\000\000\000\251\000\000\000\252\000\252\000\
\252\000\252\000\000\000\000\000\000\000\000\000\252\000\252\000\
\252\000\000\000\000\000\252\000\252\000\252\000\252\000\252\000\
\252\000\252\000\252\000\252\000\000\000\000\000\252\000\252\000\
\252\000\252\000\252\000\252\000\000\000\000\000\000\000\000\000\
\000\000\000\000\252\000\252\000\000\000\000\000\252\000\252\000\
\252\000\252\000\252\000\000\000\000\000\252\000\252\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\252\000\252\000\000\000\252\000\000\000\
\000\000\252\000\252\000\252\000\000\000\252\000\252\000\252\000\
\252\000\252\000\000\000\000\000\000\000\000\000\000\000\000\000\
\252\000\000\000\252\000\000\000\252\000\252\000\252\000\000\000\
\000\000\000\000\000\000\252\000\252\000\000\000\252\000\252\000\
\252\000\252\000\250\000\000\000\000\000\000\000\000\000\252\000\
\000\000\252\000\000\000\000\000\252\000\000\000\000\000\252\000\
\000\000\000\000\000\000\252\000\000\000\248\000\248\000\248\000\
\248\000\000\000\000\000\000\000\000\000\248\000\248\000\248\000\
\000\000\000\000\248\000\248\000\248\000\248\000\248\000\248\000\
\248\000\248\000\248\000\000\000\000\000\248\000\248\000\248\000\
\248\000\248\000\248\000\000\000\000\000\000\000\000\000\000\000\
\000\000\248\000\248\000\000\000\000\000\248\000\248\000\248\000\
\248\000\248\000\000\000\000\000\248\000\248\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\248\000\248\000\000\000\248\000\000\000\000\000\
\248\000\248\000\248\000\000\000\248\000\248\000\248\000\248\000\
\248\000\000\000\000\000\000\000\000\000\000\000\000\000\248\000\
\000\000\248\000\000\000\248\000\248\000\248\000\000\000\000\000\
\000\000\000\000\248\000\248\000\000\000\248\000\248\000\248\000\
\248\000\204\000\000\000\000\000\000\000\000\000\248\000\000\000\
\248\000\000\000\000\000\248\000\000\000\000\000\248\000\000\000\
\000\000\000\000\248\000\249\000\249\000\249\000\249\000\000\000\
\000\000\000\000\000\000\249\000\249\000\249\000\000\000\000\000\
\249\000\249\000\249\000\249\000\249\000\249\000\249\000\249\000\
\249\000\000\000\000\000\249\000\249\000\249\000\249\000\249\000\
\249\000\000\000\000\000\000\000\000\000\000\000\000\000\249\000\
\249\000\000\000\000\000\249\000\249\000\249\000\249\000\249\000\
\000\000\000\000\249\000\249\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\249\000\249\000\000\000\249\000\000\000\000\000\249\000\249\000\
\249\000\000\000\249\000\249\000\249\000\249\000\249\000\000\000\
\000\000\000\000\000\000\000\000\000\000\249\000\000\000\249\000\
\000\000\249\000\249\000\249\000\000\000\000\000\000\000\000\000\
\249\000\249\000\000\000\249\000\249\000\249\000\249\000\255\000\
\000\000\000\000\000\000\000\000\249\000\000\000\249\000\000\000\
\000\000\249\000\000\000\000\000\249\000\000\000\000\000\000\000\
\249\000\000\000\250\000\250\000\250\000\250\000\000\000\000\000\
\000\000\000\000\250\000\250\000\250\000\000\000\000\000\250\000\
\250\000\250\000\250\000\250\000\250\000\250\000\250\000\250\000\
\000\000\000\000\250\000\250\000\250\000\250\000\250\000\250\000\
\000\000\000\000\000\000\000\000\000\000\000\000\250\000\250\000\
\000\000\000\000\250\000\250\000\250\000\250\000\250\000\000\000\
\000\000\250\000\250\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\250\000\
\250\000\000\000\250\000\000\000\000\000\250\000\250\000\250\000\
\000\000\250\000\250\000\250\000\250\000\250\000\000\000\000\000\
\000\000\000\000\000\000\000\000\250\000\000\000\250\000\000\000\
\250\000\250\000\250\000\000\000\000\000\000\000\000\000\250\000\
\250\000\000\000\250\000\250\000\250\000\250\000\001\001\000\000\
\000\000\000\000\000\000\250\000\000\000\250\000\000\000\000\000\
\250\000\000\000\000\000\250\000\000\000\000\000\000\000\250\000\
\000\000\204\000\204\000\204\000\204\000\000\000\000\000\000\000\
\000\000\204\000\204\000\204\000\000\000\000\000\204\000\204\000\
\204\000\204\000\204\000\204\000\204\000\204\000\204\000\000\000\
\000\000\204\000\204\000\204\000\204\000\204\000\204\000\000\000\
\000\000\000\000\000\000\000\000\000\000\204\000\204\000\000\000\
\000\000\204\000\204\000\204\000\204\000\204\000\204\000\204\000\
\204\000\204\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\204\000\204\000\
\000\000\000\000\000\000\000\000\204\000\204\000\204\000\000\000\
\204\000\000\000\000\000\204\000\204\000\000\000\000\000\000\000\
\000\000\000\000\000\000\204\000\000\000\204\000\204\000\000\000\
\000\000\204\000\000\000\000\000\000\000\000\000\204\000\204\000\
\000\000\204\000\204\000\204\000\204\000\243\000\000\000\204\000\
\000\000\000\000\204\000\000\000\204\000\000\000\000\000\204\000\
\000\000\000\000\204\000\000\000\000\000\000\000\204\000\255\000\
\255\000\255\000\255\000\000\000\000\000\000\000\000\000\255\000\
\255\000\255\000\000\000\000\000\255\000\255\000\000\000\255\000\
\255\000\255\000\255\000\255\000\255\000\000\000\000\000\255\000\
\255\000\255\000\255\000\255\000\255\000\000\000\000\000\000\000\
\000\000\000\000\000\000\255\000\255\000\000\000\000\000\255\000\
\255\000\255\000\000\000\000\000\000\000\000\000\255\000\255\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\255\000\255\000\000\000\255\000\
\000\000\000\000\000\000\255\000\255\000\000\000\255\000\000\000\
\000\000\255\000\255\000\000\000\000\000\000\000\000\000\000\000\
\000\000\255\000\000\000\255\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\255\000\255\000\000\000\255\000\
\255\000\255\000\255\000\244\000\000\000\000\000\000\000\000\000\
\255\000\000\000\255\000\000\000\000\000\255\000\000\000\000\000\
\255\000\000\000\000\000\000\000\255\000\000\000\001\001\001\001\
\001\001\001\001\000\000\000\000\000\000\000\000\001\001\001\001\
\001\001\000\000\000\000\001\001\001\001\000\000\001\001\001\001\
\001\001\001\001\001\001\001\001\000\000\000\000\001\001\001\001\
\001\001\001\001\001\001\001\001\000\000\000\000\000\000\000\000\
\000\000\000\000\001\001\001\001\000\000\000\000\001\001\001\001\
\001\001\000\000\000\000\000\000\000\000\001\001\001\001\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\001\001\001\001\000\000\001\001\000\000\
\000\000\000\000\001\001\001\001\000\000\001\001\000\000\000\000\
\001\001\001\001\000\000\000\000\000\000\000\000\000\000\000\000\
\001\001\000\000\001\001\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\001\001\001\001\000\000\001\001\001\001\
\001\001\001\001\000\001\000\000\000\000\000\000\000\000\001\001\
\000\000\001\001\000\000\000\000\001\001\000\000\000\000\001\001\
\000\000\000\000\000\000\001\001\000\000\243\000\243\000\243\000\
\243\000\000\000\000\000\000\000\000\000\243\000\243\000\243\000\
\000\000\000\000\243\000\243\000\000\000\243\000\243\000\243\000\
\243\000\243\000\243\000\000\000\000\000\243\000\243\000\243\000\
\243\000\243\000\243\000\000\000\000\000\000\000\000\000\000\000\
\000\000\243\000\243\000\000\000\000\000\243\000\243\000\243\000\
\000\000\000\000\000\000\000\000\243\000\243\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\243\000\243\000\000\000\243\000\000\000\000\000\
\000\000\243\000\243\000\000\000\243\000\000\000\000\000\243\000\
\243\000\000\000\000\000\000\000\000\000\000\000\000\000\243\000\
\000\000\243\000\000\000\000\000\005\001\000\000\000\000\000\000\
\000\000\000\000\243\000\243\000\000\000\243\000\243\000\243\000\
\243\000\000\000\000\000\000\000\000\000\000\000\243\000\000\000\
\243\000\000\000\000\000\243\000\000\000\000\000\243\000\000\000\
\000\000\000\000\243\000\244\000\244\000\244\000\244\000\000\000\
\000\000\000\000\000\000\244\000\244\000\244\000\000\000\000\000\
\244\000\244\000\000\000\244\000\244\000\244\000\244\000\244\000\
\244\000\000\000\000\000\244\000\244\000\244\000\244\000\244\000\
\244\000\000\000\000\000\000\000\000\000\000\000\000\000\244\000\
\244\000\000\000\000\000\244\000\244\000\244\000\000\000\000\000\
\000\000\000\000\244\000\244\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\244\000\244\000\000\000\244\000\000\000\000\000\000\000\244\000\
\244\000\000\000\244\000\000\000\000\000\244\000\244\000\000\000\
\000\000\000\000\000\000\004\001\000\000\244\000\000\000\244\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\244\000\244\000\000\000\244\000\244\000\244\000\244\000\000\000\
\000\000\000\000\000\000\000\000\244\000\000\000\244\000\000\000\
\000\000\244\000\000\000\000\000\244\000\000\000\000\000\000\000\
\244\000\000\000\000\001\000\001\000\001\000\001\000\000\000\000\
\000\000\000\000\000\001\000\001\000\001\000\000\000\000\000\001\
\000\001\000\000\000\001\000\001\000\001\000\001\000\001\000\001\
\000\000\000\000\000\001\000\001\000\001\000\001\000\001\000\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000\001\
\000\000\000\000\000\001\000\001\000\001\000\000\000\000\000\000\
\000\000\000\001\000\001\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\
\000\001\000\000\000\001\000\000\000\000\100\001\000\001\000\001\
\000\000\000\001\000\000\000\000\000\001\000\001\000\000\000\000\
\000\000\000\000\000\000\000\000\000\001\000\000\000\001\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\
\000\001\000\000\000\001\000\001\000\001\000\001\000\000\000\000\
\000\000\000\000\000\000\000\001\005\001\000\001\000\000\005\001\
\000\001\000\000\000\000\000\001\005\001\005\001\005\001\000\001\
\000\000\005\001\005\001\000\000\005\001\005\001\005\001\005\001\
\005\001\005\001\000\000\000\000\005\001\005\001\005\001\000\000\
\005\001\005\001\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\005\001\000\000\000\000\005\001\005\001\000\000\000\000\
\000\000\000\000\000\000\005\001\005\001\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\005\001\000\000\000\000\005\001\000\000\000\000\002\001\
\005\001\005\001\000\000\005\001\000\000\000\000\005\001\005\001\
\000\000\000\000\000\000\000\000\000\000\000\000\005\001\000\000\
\005\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\005\001\005\001\000\000\005\001\005\001\005\001\005\001\
\000\000\000\000\000\000\000\000\000\000\005\001\000\000\005\001\
\000\000\000\000\005\001\004\001\000\000\005\001\004\001\000\000\
\000\000\005\001\000\000\004\001\004\001\004\001\000\000\000\000\
\004\001\004\001\000\000\004\001\004\001\004\001\004\001\004\001\
\004\001\000\000\000\000\004\001\004\001\004\001\000\000\004\001\
\004\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\004\001\000\000\000\000\004\001\004\001\000\000\000\000\000\000\
\000\000\000\000\004\001\004\001\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\004\001\099\001\000\000\004\001\000\000\000\000\000\000\004\001\
\004\001\000\000\004\001\000\000\000\000\004\001\004\001\000\000\
\000\000\000\000\000\000\000\000\000\000\004\001\000\000\004\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\004\001\004\001\000\000\004\001\004\001\004\001\004\001\000\000\
\000\000\000\000\000\000\000\000\004\001\100\001\004\001\000\000\
\100\001\004\001\000\000\000\000\004\001\100\001\000\000\100\001\
\004\001\000\000\100\001\100\001\000\000\100\001\100\001\100\001\
\100\001\100\001\100\001\000\000\000\000\100\001\100\001\100\001\
\000\000\100\001\100\001\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\100\001\000\000\000\000\100\001\100\001\000\000\
\000\000\000\000\000\000\000\000\100\001\100\001\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\009\001\000\000\
\000\000\000\000\100\001\000\000\000\000\100\001\000\000\000\000\
\000\000\100\001\100\001\000\000\100\001\000\000\000\000\100\001\
\100\001\000\000\000\000\000\000\000\000\000\000\000\000\100\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\100\001\100\001\000\000\100\001\100\001\100\001\
\100\001\000\000\000\000\000\000\000\000\000\000\100\001\002\001\
\100\001\000\000\002\001\100\001\000\000\000\000\100\001\002\001\
\000\000\002\001\100\001\000\000\002\001\002\001\000\000\002\001\
\002\001\002\001\002\001\002\001\002\001\000\000\000\000\002\001\
\002\001\002\001\000\000\002\001\002\001\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\002\001\000\000\000\000\002\001\
\002\001\000\000\000\000\000\000\000\000\000\000\002\001\002\001\
\000\000\000\000\000\000\237\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\002\001\000\000\000\000\002\001\
\000\000\000\000\000\000\002\001\002\001\000\000\002\001\000\000\
\000\000\002\001\002\001\000\000\000\000\000\000\000\000\000\000\
\000\000\002\001\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\002\001\002\001\000\000\002\001\
\002\001\002\001\002\001\000\000\000\000\000\000\000\000\000\000\
\002\001\099\001\002\001\000\000\099\001\002\001\000\000\000\000\
\002\001\099\001\000\000\099\001\002\001\000\000\099\001\099\001\
\000\000\099\001\099\001\099\001\099\001\099\001\099\001\000\000\
\000\000\099\001\099\001\099\001\000\000\099\001\099\001\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\099\001\000\000\
\000\000\099\001\099\001\000\000\000\000\000\000\000\000\000\000\
\099\001\099\001\000\000\000\000\000\000\012\001\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\099\001\000\000\
\000\000\099\001\000\000\000\000\000\000\099\001\099\001\000\000\
\099\001\000\000\000\000\099\001\099\001\000\000\000\000\000\000\
\000\000\000\000\000\000\099\001\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\099\001\099\001\
\000\000\099\001\099\001\099\001\099\001\000\000\009\001\000\000\
\000\000\009\001\099\001\000\000\099\001\000\000\009\001\099\001\
\009\001\000\000\099\001\009\001\009\001\000\000\099\001\009\001\
\000\000\009\001\009\001\009\001\000\000\000\000\009\001\009\001\
\009\001\000\000\009\001\009\001\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\009\001\000\000\000\000\009\001\009\001\
\000\000\000\000\000\000\000\000\000\000\009\001\009\001\000\000\
\000\000\000\000\011\001\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\009\001\000\000\000\000\009\001\000\000\
\000\000\000\000\009\001\009\001\000\000\009\001\000\000\000\000\
\009\001\009\001\000\000\000\000\000\000\000\000\000\000\000\000\
\009\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\009\001\009\001\000\000\009\001\009\001\
\009\001\009\001\000\000\237\000\000\000\000\000\237\000\009\001\
\000\000\009\001\000\000\237\000\009\001\237\000\000\000\009\001\
\237\000\237\000\000\000\009\001\237\000\000\000\237\000\237\000\
\237\000\000\000\000\000\237\000\237\000\237\000\000\000\237\000\
\237\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\237\000\000\000\000\000\237\000\237\000\000\000\000\000\000\000\
\000\000\000\000\237\000\237\000\000\000\000\000\000\000\010\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\237\000\000\000\000\000\237\000\000\000\000\000\000\000\237\000\
\237\000\000\000\237\000\000\000\000\000\237\000\237\000\000\000\
\000\000\000\000\000\000\000\000\000\000\237\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\237\000\237\000\000\000\237\000\237\000\237\000\237\000\000\000\
\000\000\000\000\000\000\000\000\237\000\012\001\237\000\000\000\
\012\001\237\000\000\000\000\000\237\000\012\001\000\000\012\001\
\237\000\000\000\012\001\012\001\000\000\000\000\012\001\000\000\
\012\001\012\001\012\001\000\000\000\000\012\001\012\001\012\001\
\000\000\012\001\012\001\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\012\001\000\000\000\000\012\001\012\001\000\000\
\000\000\000\000\000\000\000\000\012\001\012\001\000\000\000\000\
\000\000\203\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\012\001\000\000\000\000\012\001\000\000\000\000\
\000\000\012\001\012\001\000\000\012\001\000\000\000\000\012\001\
\012\001\000\000\000\000\000\000\000\000\000\000\000\000\012\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\012\001\012\001\000\000\012\001\012\001\012\001\
\012\001\000\000\011\001\000\000\000\000\011\001\012\001\000\000\
\012\001\000\000\011\001\012\001\011\001\000\000\012\001\011\001\
\011\001\000\000\012\001\011\001\000\000\011\001\011\001\011\001\
\000\000\000\000\011\001\011\001\011\001\000\000\011\001\011\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\011\001\
\000\000\000\000\011\001\011\001\000\000\000\000\000\000\000\000\
\000\000\011\001\011\001\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\011\001\
\000\000\121\002\011\001\000\000\000\000\000\000\011\001\011\001\
\000\000\011\001\116\000\000\000\011\001\011\001\000\000\000\000\
\000\000\000\000\000\000\000\000\011\001\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\011\001\
\011\001\000\000\011\001\011\001\011\001\011\001\000\000\010\001\
\000\000\000\000\010\001\011\001\000\000\011\001\000\000\010\001\
\011\001\010\001\000\000\011\001\010\001\010\001\000\000\011\001\
\010\001\000\000\010\001\010\001\010\001\000\000\000\000\010\001\
\010\001\010\001\000\000\010\001\010\001\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\010\001\000\000\000\000\010\001\
\010\001\000\000\000\000\000\000\000\000\000\000\010\001\010\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\010\001\000\000\000\000\010\001\
\000\000\000\000\000\000\010\001\010\001\000\000\010\001\000\000\
\000\000\010\001\010\001\000\000\238\000\000\000\000\000\000\000\
\000\000\010\001\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\010\001\010\001\000\000\010\001\
\010\001\010\001\010\001\000\000\000\000\000\000\000\000\000\000\
\010\001\203\000\010\001\000\000\203\000\010\001\000\000\000\000\
\010\001\203\000\000\000\203\000\010\001\000\000\203\000\203\000\
\000\000\000\000\203\000\000\000\203\000\203\000\203\000\000\000\
\000\000\203\000\203\000\203\000\000\000\203\000\203\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\203\000\000\000\
\000\000\203\000\203\000\000\000\000\000\000\000\000\000\000\000\
\203\000\203\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\203\000\000\000\
\000\000\203\000\000\000\000\000\000\000\203\000\203\000\000\000\
\203\000\000\000\000\000\203\000\203\000\000\000\000\000\000\000\
\000\000\000\000\000\000\203\000\044\002\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\203\000\203\000\
\000\000\203\000\000\000\203\000\203\000\000\000\000\000\000\000\
\000\000\000\000\203\000\000\000\203\000\000\000\000\000\203\000\
\000\000\121\002\203\000\121\002\121\002\121\002\203\000\000\000\
\000\000\121\002\116\000\000\000\000\000\000\000\121\002\000\000\
\000\000\000\000\121\002\121\002\121\002\000\000\000\000\116\000\
\000\000\000\000\000\000\121\002\121\002\121\002\121\002\000\000\
\000\000\000\000\000\000\000\000\116\000\121\002\116\000\116\000\
\000\000\000\000\121\002\000\000\000\000\000\000\000\000\000\000\
\121\002\121\002\137\000\116\000\138\000\139\000\032\000\000\000\
\140\000\000\000\000\000\177\001\243\002\000\000\121\002\000\000\
\000\000\121\002\121\002\000\000\121\002\121\002\121\002\116\000\
\121\002\004\002\116\000\121\002\121\002\000\000\116\000\116\000\
\000\000\000\000\000\000\121\002\000\000\116\000\145\000\000\000\
\000\000\000\000\000\000\000\000\116\000\146\000\121\002\121\002\
\000\000\121\002\121\002\121\002\121\002\000\000\000\000\121\002\
\116\000\147\000\148\000\000\000\116\000\116\000\000\000\121\002\
\121\002\000\000\121\002\000\000\238\000\000\000\121\002\238\000\
\116\000\000\000\000\000\116\000\238\000\000\000\238\000\000\000\
\000\000\238\000\238\000\000\000\000\000\238\000\000\000\238\000\
\238\000\238\000\000\000\000\000\238\000\000\000\238\000\000\000\
\238\000\238\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\238\000\000\000\000\000\238\000\238\000\000\000\000\000\
\000\000\000\000\000\000\238\000\238\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\005\002\000\000\
\000\000\238\000\000\000\000\000\238\000\000\000\000\000\000\000\
\238\000\238\000\000\000\238\000\000\000\000\000\238\000\238\000\
\000\000\000\000\000\000\000\000\000\000\000\000\238\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\238\000\238\000\000\000\238\000\238\000\238\000\238\000\
\000\000\000\000\000\000\000\000\000\000\238\000\000\000\238\000\
\000\000\000\000\238\000\000\000\044\002\238\000\044\002\044\002\
\044\002\238\000\000\000\000\000\044\002\000\000\000\000\000\000\
\000\000\044\002\000\000\000\000\000\000\044\002\044\002\044\002\
\000\000\000\000\000\000\000\000\000\000\000\000\044\002\044\002\
\044\002\044\002\000\000\000\000\000\000\000\000\000\000\000\000\
\044\002\000\000\000\000\000\000\000\000\044\002\000\000\000\000\
\000\000\000\000\000\000\044\002\044\002\045\002\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\044\002\000\000\000\000\044\002\000\000\000\000\044\002\
\044\002\044\002\000\000\044\002\000\000\000\000\044\002\044\002\
\000\000\000\000\000\000\000\000\000\000\000\000\044\002\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\044\002\044\002\000\000\044\002\044\002\044\002\044\002\
\000\000\004\002\000\000\004\002\004\002\004\002\000\000\000\000\
\000\000\004\002\044\002\000\000\000\000\044\002\004\002\000\000\
\000\000\044\002\004\002\004\002\004\002\000\000\000\000\000\000\
\000\000\000\000\000\000\004\002\004\002\004\002\004\002\000\000\
\000\000\000\000\000\000\000\000\000\000\004\002\000\000\000\000\
\000\000\000\000\004\002\000\000\000\000\000\000\000\000\000\000\
\004\002\004\002\003\002\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\004\002\000\000\
\000\000\004\002\000\000\000\000\004\002\004\002\004\002\000\000\
\004\002\000\000\000\000\004\002\004\002\000\000\000\000\000\000\
\000\000\000\000\000\000\004\002\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\004\002\004\002\
\000\000\004\002\004\002\004\002\000\000\000\000\005\002\004\002\
\005\002\005\002\005\002\000\000\000\000\000\000\005\002\004\002\
\000\000\000\000\004\002\005\002\000\000\000\000\004\002\005\002\
\005\002\005\002\000\000\000\000\000\000\000\000\000\000\000\000\
\005\002\005\002\005\002\005\002\000\000\000\000\000\000\000\000\
\000\000\000\000\005\002\000\000\000\000\000\000\000\000\005\002\
\000\000\000\000\000\000\000\000\000\000\005\002\005\002\001\002\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\005\002\000\000\000\000\005\002\000\000\
\000\000\005\002\005\002\005\002\000\000\005\002\000\000\000\000\
\005\002\005\002\000\000\000\000\000\000\000\000\000\000\000\000\
\005\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\005\002\005\002\000\000\005\002\005\002\
\005\002\000\000\000\000\000\000\005\002\045\002\000\000\045\002\
\045\002\045\002\000\000\000\000\005\002\045\002\000\000\005\002\
\000\000\000\000\045\002\005\002\000\000\000\000\045\002\045\002\
\045\002\000\000\000\000\000\000\000\000\000\000\000\000\045\002\
\045\002\045\002\045\002\000\000\000\000\000\000\000\000\000\000\
\000\000\045\002\000\000\000\000\000\000\000\000\045\002\000\000\
\000\000\000\000\000\000\000\000\045\002\045\002\002\002\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\045\002\000\000\000\000\045\002\000\000\000\000\
\045\002\045\002\045\002\000\000\045\002\000\000\000\000\045\002\
\045\002\000\000\000\000\000\000\000\000\000\000\000\000\045\002\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\045\002\045\002\000\000\045\002\045\002\045\002\
\045\002\000\000\003\002\000\000\003\002\003\002\003\002\000\000\
\000\000\000\000\003\002\045\002\000\000\000\000\045\002\003\002\
\000\000\000\000\045\002\003\002\003\002\003\002\000\000\000\000\
\000\000\000\000\000\000\000\000\003\002\003\002\003\002\003\002\
\000\000\000\000\000\000\000\000\000\000\000\000\003\002\000\000\
\000\000\000\000\000\000\003\002\000\000\000\000\000\000\000\000\
\000\000\003\002\003\002\000\002\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\002\
\000\000\000\000\003\002\000\000\000\000\003\002\003\002\003\002\
\000\000\003\002\000\000\000\000\000\000\003\002\000\000\000\000\
\000\000\000\000\000\000\000\000\003\002\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\002\
\003\002\000\000\003\002\003\002\003\002\003\002\000\000\001\002\
\000\000\001\002\001\002\001\002\000\000\000\000\193\000\001\002\
\003\002\000\000\000\000\003\002\001\002\000\000\000\000\003\002\
\001\002\001\002\001\002\000\000\000\000\000\000\000\000\000\000\
\000\000\001\002\001\002\001\002\001\002\000\000\000\000\000\000\
\000\000\000\000\000\000\001\002\000\000\000\000\000\000\000\000\
\001\002\000\000\000\000\000\000\000\000\000\000\001\002\001\002\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\082\000\000\000\000\000\000\000\001\002\000\000\000\000\001\002\
\000\000\000\000\001\002\001\002\001\002\000\000\001\002\000\000\
\000\000\000\000\001\002\000\000\000\000\000\000\000\000\000\000\
\000\000\001\002\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\001\002\001\002\000\000\001\002\
\001\002\001\002\001\002\000\000\000\000\000\000\002\002\000\000\
\002\002\002\002\002\002\000\000\000\000\001\002\002\002\000\000\
\001\002\000\000\000\000\002\002\001\002\000\000\000\000\002\002\
\002\002\002\002\000\000\000\000\000\000\000\000\000\000\000\000\
\002\002\002\002\002\002\002\002\000\000\000\000\000\000\000\000\
\000\000\000\000\002\002\000\000\000\000\000\000\000\000\002\002\
\000\000\000\000\000\000\000\000\000\000\002\002\002\002\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\002\002\000\000\000\000\002\002\000\000\
\000\000\002\002\002\002\002\002\226\002\002\002\000\000\000\000\
\000\000\002\002\000\000\000\000\000\000\000\000\000\000\000\000\
\002\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\002\002\002\002\000\000\002\002\002\002\
\002\002\002\002\000\000\000\002\000\000\000\002\000\002\000\002\
\000\000\000\000\000\000\000\002\002\002\000\000\000\000\002\002\
\000\002\000\000\000\000\002\002\000\002\000\002\000\002\000\000\
\000\000\000\000\000\000\000\000\000\000\000\002\000\002\000\002\
\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\002\
\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\
\000\000\000\000\000\002\000\002\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\193\000\000\000\
\000\002\193\000\000\000\000\002\000\000\000\000\000\002\000\002\
\000\002\000\000\000\002\193\000\000\000\000\000\000\002\000\000\
\000\000\193\000\000\000\000\000\129\000\000\002\000\000\000\000\
\193\000\193\000\193\000\193\000\000\000\000\000\000\000\000\000\
\000\002\000\002\000\000\000\002\000\002\000\002\000\002\193\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\082\000\000\002\000\000\082\000\000\002\000\000\000\000\000\000\
\000\002\000\000\000\000\193\000\000\000\082\000\193\000\000\000\
\000\000\000\000\193\000\193\000\000\000\000\000\000\000\000\000\
\000\000\193\000\082\000\082\000\082\000\082\000\000\000\000\000\
\193\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\082\000\000\000\000\000\193\000\000\000\193\000\000\000\
\193\000\193\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\193\000\082\000\000\000\193\000\
\082\000\000\000\000\000\193\000\082\000\082\000\000\000\000\000\
\000\000\000\000\000\000\082\000\000\000\000\000\000\000\121\000\
\000\000\000\000\082\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\082\000\000\000\
\082\000\000\000\082\000\082\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\082\000\000\000\
\000\000\082\000\000\000\000\000\226\002\082\000\000\000\226\002\
\000\000\226\002\226\002\226\002\226\002\000\000\000\000\226\002\
\226\002\226\002\000\000\000\000\000\000\000\000\000\000\226\002\
\000\000\000\000\000\000\000\000\000\000\000\000\226\002\000\000\
\226\002\226\002\226\002\226\002\226\002\226\002\226\002\000\000\
\226\002\000\000\000\000\226\002\000\000\226\002\000\000\000\000\
\000\000\000\000\000\000\226\002\226\002\226\002\226\002\226\002\
\226\002\226\002\226\002\226\002\226\002\226\002\000\000\000\000\
\226\002\226\002\000\000\000\000\226\002\226\002\226\002\000\000\
\226\002\226\002\226\002\226\002\226\002\226\002\000\000\226\002\
\226\002\226\002\226\002\169\001\226\002\000\000\226\002\226\002\
\000\000\000\000\226\002\226\002\000\000\226\002\000\000\226\002\
\000\000\226\002\226\002\226\002\000\000\226\002\226\002\226\002\
\000\000\000\000\000\000\226\002\000\000\000\000\226\002\000\000\
\226\002\226\002\226\002\226\002\226\002\226\002\000\000\000\000\
\226\002\009\000\010\000\011\000\000\000\000\000\000\000\012\000\
\013\000\014\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\015\000\016\000\017\000\018\000\019\000\020\000\021\000\000\000\
\000\000\000\000\000\000\022\000\000\000\023\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\024\000\025\000\026\000\
\000\000\027\000\028\000\029\000\030\000\031\000\000\000\000\000\
\032\000\033\000\000\000\000\000\034\000\035\000\036\000\000\000\
\000\000\037\000\038\000\000\000\039\000\040\000\000\000\041\000\
\000\000\042\000\043\000\000\000\044\000\114\002\045\000\000\000\
\000\000\000\000\046\000\047\000\000\000\048\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\130\000\122\000\
\000\000\000\000\000\000\050\000\000\000\000\000\000\000\000\000\
\051\000\052\000\053\000\054\000\009\000\010\000\011\000\000\000\
\055\000\000\000\012\000\013\000\014\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\015\000\016\000\017\000\018\000\019\000\
\020\000\021\000\000\000\000\000\000\000\000\000\022\000\000\000\
\023\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\024\000\025\000\026\000\000\000\027\000\028\000\029\000\030\000\
\031\000\000\000\000\000\032\000\033\000\000\000\000\000\034\000\
\035\000\036\000\000\000\000\000\037\000\038\000\000\000\039\000\
\040\000\000\000\041\000\000\000\042\000\043\000\000\000\044\000\
\000\000\045\000\000\000\000\000\000\000\046\000\047\000\135\001\
\048\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\122\000\000\000\000\000\000\000\050\000\000\000\
\000\000\000\000\000\000\051\000\052\000\053\000\054\000\000\000\
\000\000\000\000\000\000\055\000\000\000\000\000\000\000\000\000\
\009\000\010\000\011\000\000\000\000\000\000\000\012\000\013\000\
\014\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\015\000\
\016\000\017\000\018\000\019\000\020\000\021\000\000\000\000\000\
\000\000\000\000\022\000\000\000\023\000\000\000\000\000\000\000\
\000\000\000\000\000\000\130\000\024\000\025\000\026\000\000\000\
\027\000\028\000\029\000\030\000\031\000\000\000\000\000\032\000\
\033\000\000\000\000\000\034\000\035\000\036\000\000\000\000\000\
\037\000\038\000\000\000\039\000\040\000\000\000\041\000\000\000\
\042\000\043\000\000\000\044\000\000\000\045\000\000\000\000\000\
\000\000\046\000\047\000\000\000\048\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\122\000\000\000\
\000\000\000\000\050\000\000\000\000\000\000\000\132\000\051\000\
\052\000\053\000\054\000\000\000\000\000\114\002\000\000\055\000\
\000\000\114\002\000\000\114\002\000\000\114\002\000\000\114\002\
\000\000\114\002\114\002\114\002\114\002\000\000\114\002\114\002\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\114\002\
\114\002\114\002\114\002\114\002\114\002\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\114\002\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\114\002\114\002\
\114\002\114\002\114\002\114\002\000\000\114\002\114\002\000\000\
\000\000\114\002\114\002\000\000\000\000\114\002\114\002\114\002\
\114\002\114\002\114\002\000\000\107\002\114\002\000\000\114\002\
\114\002\000\000\114\002\000\000\000\000\000\000\000\000\114\002\
\114\002\000\000\000\000\114\002\000\000\000\000\000\000\000\000\
\114\002\000\000\114\002\114\002\000\000\114\002\114\002\114\002\
\114\002\000\000\000\000\000\000\114\002\000\000\000\000\114\002\
\000\000\114\002\000\000\114\002\114\002\114\002\000\000\135\001\
\114\002\000\000\000\000\135\001\000\000\135\001\000\000\135\001\
\000\000\135\001\000\000\135\001\000\000\135\001\135\001\133\000\
\135\001\135\001\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\135\001\000\000\000\000\135\001\135\001\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\135\001\135\001\135\001\135\001\000\000\135\001\000\000\135\001\
\135\001\000\000\000\000\135\001\000\000\000\000\000\000\000\000\
\135\001\135\001\135\001\000\000\000\000\000\000\000\000\135\001\
\000\000\135\001\128\000\130\000\135\001\000\000\130\000\130\000\
\000\000\000\000\135\001\000\000\000\000\135\001\000\000\000\000\
\130\000\130\000\135\001\000\000\135\001\135\001\130\000\135\001\
\135\001\000\000\135\001\000\000\000\000\130\000\135\001\130\000\
\130\000\135\001\000\000\135\001\000\000\000\000\135\001\135\001\
\000\000\000\000\135\001\000\000\130\000\000\000\000\000\000\000\
\000\000\000\000\130\000\130\000\130\002\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\132\000\000\000\
\130\000\132\000\132\000\130\000\000\000\000\000\130\000\130\000\
\130\000\000\000\130\000\132\000\132\000\000\000\130\000\000\000\
\000\000\132\000\000\000\000\000\000\000\130\000\000\000\000\000\
\132\000\000\000\132\000\132\000\000\000\000\000\000\000\000\000\
\000\000\130\000\000\000\130\000\000\000\130\000\130\000\132\000\
\000\000\000\000\000\000\000\000\000\000\132\000\132\000\178\000\
\000\000\130\000\000\000\000\000\130\000\000\000\000\000\000\000\
\000\000\000\000\000\000\132\000\000\000\000\000\132\000\000\000\
\000\000\132\000\132\000\132\000\000\000\132\000\000\000\000\000\
\000\000\132\000\000\000\000\000\107\002\000\000\000\000\107\002\
\132\000\000\000\000\000\000\000\107\002\000\000\000\000\000\000\
\000\000\107\002\107\002\000\000\132\000\000\000\132\000\107\002\
\132\000\132\000\125\002\000\000\000\000\000\000\107\002\000\000\
\107\002\107\002\131\002\000\000\132\000\000\000\000\000\132\000\
\000\000\000\000\000\000\000\000\137\000\107\002\138\000\139\000\
\032\000\000\000\140\000\000\000\000\000\177\001\071\004\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\133\000\
\000\000\107\002\133\000\133\000\107\002\000\000\125\002\107\002\
\107\002\107\002\000\000\000\000\133\000\133\000\000\000\107\002\
\145\000\000\000\133\000\000\000\000\000\107\002\107\002\146\000\
\000\000\133\000\000\000\133\000\133\000\000\000\224\002\000\000\
\000\000\000\000\107\002\147\000\148\000\000\000\107\002\107\002\
\133\000\000\000\000\000\000\000\000\000\000\000\133\000\133\000\
\000\000\000\000\107\002\000\000\000\000\107\002\000\000\000\000\
\000\000\000\000\128\000\000\000\133\000\128\000\128\000\133\000\
\000\000\000\000\000\000\133\000\133\000\000\000\133\000\128\000\
\128\000\000\000\133\000\000\000\000\000\128\000\000\000\000\000\
\000\000\133\000\000\000\000\000\128\000\216\001\128\000\128\000\
\000\000\000\000\000\000\000\000\000\000\133\000\000\000\133\000\
\000\000\133\000\133\000\128\000\000\000\000\000\000\000\000\000\
\000\000\128\000\128\000\000\000\130\002\133\000\000\000\130\002\
\133\000\000\000\000\000\000\000\000\000\000\000\000\000\128\000\
\000\000\130\002\128\000\000\000\000\000\000\000\128\000\128\000\
\000\000\128\000\000\000\000\000\000\000\128\000\130\002\130\002\
\130\002\130\002\000\000\000\000\128\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\130\002\000\000\000\000\
\128\000\000\000\128\000\000\000\128\000\128\000\000\000\000\000\
\000\000\006\002\000\000\000\000\000\000\000\000\000\000\178\000\
\128\000\130\002\178\000\128\000\000\000\121\002\000\000\130\002\
\130\002\130\002\006\002\000\000\178\000\000\000\121\002\130\002\
\000\000\000\000\000\000\000\000\000\000\000\000\130\002\000\000\
\000\000\178\000\178\000\178\000\178\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\130\002\000\000\130\002\121\002\
\178\000\000\000\121\002\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\130\002\121\002\000\000\130\002\000\000\000\000\
\000\000\000\000\131\002\000\000\178\000\131\002\000\000\000\000\
\026\002\000\000\178\000\178\000\178\000\000\000\000\000\131\002\
\000\000\026\002\178\000\000\000\000\000\000\000\000\000\000\000\
\000\000\178\000\000\000\000\000\131\002\131\002\131\002\131\002\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\178\000\
\000\000\178\000\026\002\131\002\000\000\026\002\007\002\000\000\
\000\000\000\000\000\000\000\000\000\000\178\000\026\002\000\000\
\178\000\000\000\000\000\000\000\000\000\000\000\224\002\131\002\
\000\000\224\002\000\000\122\002\000\000\131\002\131\002\131\002\
\000\000\000\000\000\000\224\002\122\002\131\002\000\000\000\000\
\000\000\224\002\000\000\000\000\131\002\000\000\000\000\000\000\
\224\002\000\000\224\002\224\002\000\000\000\000\000\000\000\000\
\000\000\000\000\131\002\000\000\131\002\122\002\224\002\224\002\
\122\002\000\000\000\000\000\000\000\000\224\002\224\002\000\000\
\131\002\122\002\000\000\131\002\000\000\216\001\000\000\000\000\
\216\001\000\000\000\000\224\002\007\002\216\001\224\002\000\000\
\000\000\000\000\216\001\224\002\000\000\224\002\102\000\000\000\
\216\001\224\002\000\000\000\000\000\000\000\000\000\000\216\001\
\224\002\216\001\216\001\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\224\002\000\000\216\001\000\000\
\224\002\224\002\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\224\002\000\000\000\000\224\002\
\000\000\000\000\216\001\000\000\000\000\216\001\000\000\000\000\
\216\001\216\001\216\001\000\000\000\000\000\000\000\000\052\002\
\216\001\006\002\000\000\000\000\006\002\000\000\000\000\216\001\
\000\000\006\002\213\001\000\000\000\000\000\000\006\002\000\000\
\000\000\000\000\006\002\216\001\006\002\006\002\000\000\216\001\
\216\001\000\000\006\002\006\002\000\000\006\002\006\002\006\002\
\000\000\000\000\000\000\216\001\000\000\006\002\216\001\000\000\
\000\000\000\000\006\002\000\000\006\002\000\000\006\002\006\002\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\006\002\224\002\000\000\006\002\000\000\
\000\000\006\002\000\000\000\000\006\002\006\002\006\002\000\000\
\000\000\000\000\000\000\006\002\006\002\000\000\000\000\006\002\
\000\000\000\000\006\002\006\002\177\001\006\002\006\002\006\002\
\000\000\000\000\000\000\000\000\006\002\006\002\000\000\006\002\
\000\000\000\000\000\000\006\002\006\002\000\000\000\000\004\002\
\000\000\000\000\000\000\000\000\000\000\000\000\007\002\006\002\
\006\002\007\002\006\002\000\000\006\002\000\000\007\002\000\000\
\006\002\000\000\000\000\007\002\000\000\000\000\000\000\000\000\
\006\002\007\002\000\000\006\002\000\000\000\000\080\000\000\000\
\007\002\000\000\007\002\007\002\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\007\002\
\000\000\000\000\137\000\000\000\138\000\139\000\032\000\000\000\
\140\000\000\000\000\000\141\000\142\000\000\000\000\000\000\000\
\000\000\000\000\000\000\007\002\000\000\192\001\007\002\000\000\
\000\000\007\002\007\002\007\002\000\000\143\000\000\000\000\000\
\007\002\007\002\000\000\000\000\007\002\144\000\145\000\007\002\
\007\002\226\002\011\002\000\000\007\002\146\000\102\000\000\000\
\000\000\007\002\000\000\000\000\007\002\000\000\000\000\007\002\
\007\002\147\000\148\000\102\000\005\002\000\000\007\002\000\000\
\007\002\007\002\000\000\000\000\007\002\000\000\000\000\007\002\
\102\000\000\000\102\000\102\000\000\000\007\002\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\102\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\007\002\000\000\000\000\007\002\177\001\000\000\007\002\
\007\002\007\002\000\000\102\000\000\000\000\000\007\002\007\002\
\000\000\000\000\213\001\102\000\000\000\213\001\007\002\000\000\
\000\000\102\000\213\001\000\000\000\000\000\000\000\000\213\001\
\102\000\000\000\007\002\000\000\000\000\213\001\007\002\000\000\
\000\000\000\000\007\002\000\000\213\001\000\000\213\001\213\001\
\102\000\000\000\007\002\000\000\000\000\007\002\000\000\000\000\
\000\000\000\000\000\000\213\001\102\000\000\000\000\000\102\000\
\178\001\000\000\000\000\000\000\224\002\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\213\001\
\000\000\224\002\213\001\000\000\000\000\213\001\213\001\213\001\
\000\000\000\000\000\000\000\000\177\001\213\001\224\002\177\001\
\224\002\224\002\000\000\000\000\213\001\000\000\000\000\000\000\
\000\000\177\001\000\000\000\000\000\000\224\002\000\000\177\001\
\213\001\000\000\000\000\000\000\213\001\213\001\177\001\000\000\
\177\001\177\001\000\000\180\001\000\000\000\000\000\000\097\000\
\213\001\224\002\000\000\213\001\000\000\177\001\000\000\000\000\
\000\000\224\002\000\000\000\000\000\000\000\000\080\000\224\002\
\000\000\080\000\000\000\000\000\000\000\000\000\224\002\000\000\
\000\000\177\001\000\000\080\000\177\001\000\000\000\000\000\000\
\177\001\177\001\000\000\000\000\000\000\000\000\224\002\177\001\
\080\000\080\000\080\000\080\000\000\000\000\000\177\001\000\000\
\000\000\000\000\224\002\000\000\121\002\224\002\179\001\080\000\
\000\000\000\000\177\001\000\000\000\000\000\000\177\001\177\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\226\002\177\001\080\000\226\002\177\001\080\000\000\000\
\000\000\226\002\080\000\080\000\000\000\000\000\226\002\000\000\
\000\000\080\000\000\000\000\000\226\002\000\000\000\000\000\000\
\080\000\000\000\000\000\226\002\000\000\226\002\226\002\000\000\
\101\000\000\000\000\000\000\000\080\000\000\000\080\000\000\000\
\080\000\080\000\226\002\000\000\000\000\000\000\000\000\000\000\
\000\000\181\001\000\000\000\000\080\000\000\000\000\000\080\000\
\000\000\000\000\000\000\000\000\000\000\177\001\226\002\000\000\
\177\001\226\002\000\000\000\000\000\000\226\002\226\002\000\000\
\000\000\000\000\177\001\000\000\226\002\000\000\000\000\000\000\
\177\001\000\000\000\000\226\002\000\000\000\000\000\000\177\001\
\000\000\177\001\177\001\000\000\000\000\000\000\000\000\226\002\
\000\000\000\000\000\000\226\002\226\002\000\000\177\001\000\000\
\000\000\000\000\000\000\000\000\184\001\000\000\000\000\226\002\
\000\000\000\000\226\002\000\000\000\000\000\000\000\000\000\000\
\178\001\000\000\177\001\178\001\000\000\177\001\000\000\000\000\
\000\000\177\001\177\001\000\000\000\000\178\001\000\000\000\000\
\177\001\000\000\000\000\178\001\000\000\000\000\000\000\177\001\
\000\000\000\000\178\001\000\000\178\001\178\001\000\000\000\000\
\000\000\000\000\000\000\177\001\000\000\000\000\226\002\177\001\
\177\001\178\001\000\000\000\000\000\000\000\000\000\000\117\000\
\000\000\000\000\000\000\177\001\000\000\000\000\177\001\000\000\
\000\000\000\000\000\000\180\001\000\000\178\001\180\001\097\000\
\178\001\000\000\000\000\000\000\178\001\178\001\000\000\000\000\
\180\001\000\000\000\000\178\001\097\000\000\000\180\001\000\000\
\000\000\000\000\178\001\000\000\000\000\180\001\000\000\180\001\
\180\001\097\000\000\000\097\000\097\000\000\000\178\001\000\000\
\000\000\168\001\178\001\178\001\180\001\000\000\000\000\000\000\
\097\000\000\000\000\000\000\000\000\000\000\000\178\001\000\000\
\000\000\178\001\000\000\000\000\000\000\000\000\179\001\000\000\
\180\001\179\001\000\000\180\001\097\000\000\000\000\000\180\001\
\180\001\000\000\000\000\179\001\097\000\000\000\180\001\000\000\
\000\000\179\001\097\000\000\000\000\000\180\001\000\000\000\000\
\179\001\097\000\179\001\179\001\000\000\000\000\000\000\000\000\
\000\000\180\001\000\000\000\000\224\002\180\001\180\001\179\001\
\000\000\097\000\000\000\000\000\000\000\000\000\000\000\000\000\
\101\000\180\001\000\000\000\000\180\001\097\000\000\000\000\000\
\097\000\000\000\000\000\179\001\000\000\101\000\179\001\000\000\
\000\000\181\001\179\001\179\001\181\001\000\000\000\000\000\000\
\000\000\179\001\101\000\000\000\101\000\101\000\181\001\000\000\
\179\001\224\002\000\000\000\000\181\001\000\000\000\000\000\000\
\000\000\101\000\000\000\181\001\179\001\181\001\181\001\000\000\
\179\001\179\001\000\000\000\000\000\000\000\000\000\000\069\000\
\000\000\000\000\181\001\000\000\179\001\101\000\000\000\179\001\
\000\000\000\000\000\000\000\000\000\000\101\000\000\000\000\000\
\000\000\000\000\000\000\101\000\184\001\000\000\181\001\184\001\
\000\000\181\001\101\000\000\000\000\000\181\001\181\001\000\000\
\000\000\184\001\000\000\000\000\181\001\000\000\000\000\184\001\
\000\000\000\000\101\000\181\001\070\000\000\000\184\001\000\000\
\184\001\184\001\000\000\000\000\000\000\000\000\101\000\181\001\
\000\000\101\000\000\000\181\001\181\001\184\001\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\226\002\181\001\
\000\000\000\000\181\001\000\000\000\000\000\000\226\002\117\000\
\000\000\184\001\000\000\226\002\184\001\000\000\000\000\000\000\
\184\001\184\001\000\000\000\000\117\000\000\000\213\001\184\001\
\226\002\000\000\226\002\226\002\000\000\000\000\184\001\213\001\
\000\000\117\000\000\000\117\000\117\000\000\000\000\000\226\002\
\000\000\000\000\184\001\000\000\000\000\000\000\184\001\184\001\
\117\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\168\001\184\001\226\002\000\000\184\001\226\002\000\000\
\000\000\000\000\226\002\226\002\117\000\000\000\168\001\117\000\
\000\000\226\002\000\000\117\000\117\000\000\000\000\000\000\000\
\226\002\000\000\117\000\168\001\000\000\168\001\168\001\000\000\
\000\000\117\000\000\000\000\000\226\002\000\000\000\000\000\000\
\226\002\226\002\168\001\000\000\000\000\117\000\000\000\000\000\
\000\000\117\000\117\000\000\000\226\002\224\002\000\000\226\002\
\000\000\000\000\000\000\000\000\224\002\117\000\168\001\224\002\
\117\000\168\001\000\000\000\000\000\000\168\001\168\001\000\000\
\000\000\224\002\000\000\123\000\168\001\000\000\000\000\000\000\
\000\000\000\000\000\000\168\001\000\000\000\000\224\002\000\000\
\224\002\224\002\000\000\000\000\000\000\000\000\000\000\168\001\
\000\000\124\000\000\000\168\001\168\001\224\002\000\000\000\000\
\000\000\224\002\000\000\000\000\000\000\000\000\000\000\168\001\
\000\000\000\000\168\001\000\000\000\000\000\000\224\002\000\000\
\000\000\224\002\000\000\000\000\224\002\000\000\000\000\069\000\
\000\000\224\002\069\000\224\002\000\000\224\002\224\002\224\002\
\000\000\000\000\000\000\000\000\069\000\000\000\224\002\000\000\
\000\000\000\000\224\002\000\000\000\000\000\000\000\000\000\000\
\000\000\069\000\224\002\069\000\069\000\000\000\224\002\224\002\
\000\000\000\000\000\000\000\000\000\000\000\000\224\002\069\000\
\069\000\224\002\224\002\000\000\070\000\224\002\224\002\070\000\
\226\002\000\000\000\000\000\000\224\002\000\000\000\000\000\000\
\000\000\070\000\226\002\224\002\069\000\000\000\000\000\069\000\
\000\000\000\000\000\000\069\000\069\000\000\000\070\000\224\002\
\070\000\070\000\069\000\224\002\224\002\000\000\000\000\000\000\
\000\000\069\000\000\000\000\000\070\000\070\000\000\000\224\002\
\000\000\000\000\224\002\000\000\000\000\069\000\213\001\000\000\
\000\000\069\000\069\000\000\000\000\000\000\000\213\001\213\001\
\000\000\070\000\000\000\213\001\070\000\069\000\000\000\000\000\
\070\000\070\000\000\000\000\000\213\001\000\000\000\000\070\000\
\213\001\000\000\213\001\213\001\000\000\224\002\070\000\000\000\
\000\000\213\001\000\000\213\001\213\001\000\000\000\000\213\001\
\000\000\000\000\070\000\000\000\000\000\000\000\070\000\070\000\
\213\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\070\000\213\001\000\000\000\000\213\001\000\000\
\000\000\213\001\213\001\213\001\213\001\000\000\000\000\213\001\
\000\000\213\001\213\001\213\001\213\001\000\000\000\000\054\000\
\213\001\000\000\213\001\000\000\000\000\224\002\000\000\000\000\
\224\002\213\001\000\000\000\000\213\001\000\000\000\000\000\000\
\213\001\213\001\224\002\000\000\000\000\213\001\000\000\000\000\
\000\000\213\001\213\001\123\000\213\001\000\000\123\000\224\002\
\000\000\224\002\224\002\000\000\000\000\213\001\056\000\000\000\
\123\000\000\000\000\000\000\000\000\000\224\002\224\002\000\000\
\000\000\124\000\000\000\000\000\124\000\123\000\000\000\123\000\
\123\000\000\000\000\000\000\000\000\000\000\000\124\000\000\000\
\000\000\000\000\224\002\000\000\123\000\224\002\000\000\000\000\
\000\000\000\000\224\002\124\000\000\000\124\000\124\000\000\000\
\224\002\000\000\060\000\000\000\000\000\000\000\000\000\224\002\
\123\000\000\000\124\000\123\000\000\000\000\000\000\000\123\000\
\123\000\000\000\000\000\224\002\000\000\000\000\123\000\224\002\
\224\002\000\000\000\000\000\000\000\000\123\000\124\000\000\000\
\000\000\124\000\000\000\224\002\000\000\124\000\124\000\000\000\
\000\000\123\000\000\000\000\000\124\000\123\000\123\000\063\000\
\226\002\000\000\000\000\124\000\000\000\000\000\000\000\000\000\
\226\002\123\000\226\002\000\000\000\000\226\002\000\000\124\000\
\000\000\000\000\000\000\124\000\124\000\064\000\000\000\226\002\
\000\000\000\000\226\002\000\000\226\002\226\002\224\002\124\000\
\000\000\000\000\000\000\000\000\226\002\000\000\226\002\226\002\
\000\000\226\002\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\226\002\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\226\002\000\000\000\000\
\226\002\000\000\000\000\000\000\226\002\226\002\000\000\226\002\
\000\000\000\000\226\002\226\002\000\000\224\002\226\002\226\002\
\224\002\000\000\226\002\000\000\000\000\226\002\000\000\000\000\
\000\000\000\000\224\002\000\000\226\002\000\000\226\002\000\000\
\000\000\000\000\226\002\226\002\000\000\000\000\000\000\224\002\
\226\002\224\002\224\002\000\000\226\002\226\002\226\002\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\224\002\000\000\
\226\002\000\000\039\002\000\000\039\002\039\002\039\002\054\000\
\039\002\000\000\000\000\039\002\039\002\000\000\000\000\000\000\
\000\000\000\000\224\002\000\000\054\000\224\002\000\000\000\000\
\000\000\000\000\224\002\000\000\000\000\039\002\000\000\000\000\
\224\002\054\000\000\000\054\000\054\000\039\002\039\002\224\002\
\000\000\000\000\000\000\000\000\000\000\039\002\056\000\000\000\
\054\000\000\000\000\000\224\002\000\000\000\000\000\000\224\002\
\224\002\039\002\039\002\056\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\224\002\054\000\000\000\000\000\054\000\
\056\000\000\000\056\000\056\000\054\000\000\000\000\000\000\000\
\000\000\000\000\054\000\000\000\000\000\000\000\000\000\056\000\
\000\000\054\000\060\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\054\000\000\000\060\000\
\000\000\054\000\054\000\056\000\000\000\000\000\056\000\000\000\
\000\000\000\000\000\000\056\000\060\000\054\000\060\000\060\000\
\000\000\056\000\000\000\000\000\000\000\000\000\000\000\000\000\
\056\000\000\000\000\000\060\000\000\000\000\000\000\000\063\000\
\000\000\000\000\000\000\000\000\056\000\000\000\000\000\000\000\
\056\000\056\000\000\000\000\000\063\000\000\000\000\000\060\000\
\000\000\000\000\060\000\000\000\056\000\064\000\000\000\060\000\
\000\000\063\000\000\000\063\000\063\000\060\000\224\002\000\000\
\000\000\000\000\064\000\000\000\060\000\000\000\000\000\000\000\
\063\000\000\000\000\000\224\002\000\000\000\000\000\000\064\000\
\060\000\064\000\064\000\000\000\060\000\060\000\000\000\000\000\
\224\002\000\000\224\002\224\002\063\000\000\000\064\000\063\000\
\060\000\000\000\000\000\000\000\063\000\000\000\000\000\224\002\
\000\000\000\000\063\000\000\000\000\000\000\000\000\000\000\000\
\000\000\063\000\064\000\000\000\000\000\064\000\000\000\000\000\
\000\000\000\000\064\000\224\002\000\000\063\000\224\002\000\000\
\064\000\063\000\063\000\224\002\000\000\000\000\000\000\064\000\
\000\000\224\002\000\000\000\000\000\000\063\000\000\000\000\000\
\224\002\000\000\000\000\064\000\000\000\000\000\000\000\064\000\
\064\000\000\000\000\000\000\000\224\002\000\000\000\000\000\000\
\224\002\224\002\219\002\064\000\000\000\000\000\000\000\219\002\
\219\002\219\002\219\002\000\000\224\002\219\002\219\002\219\002\
\219\002\000\000\000\000\000\000\000\000\219\002\000\000\000\000\
\000\000\000\000\000\000\000\000\219\002\000\000\219\002\219\002\
\219\002\219\002\219\002\219\002\219\002\000\000\000\000\000\000\
\000\000\219\002\000\000\219\002\000\000\000\000\000\000\000\000\
\000\000\219\002\219\002\219\002\219\002\219\002\219\002\219\002\
\219\002\219\002\219\002\219\002\000\000\000\000\219\002\219\002\
\000\000\000\000\219\002\219\002\219\002\219\002\000\000\219\002\
\219\002\219\002\219\002\219\002\000\000\219\002\000\000\219\002\
\219\002\000\000\219\002\000\000\219\002\219\002\000\000\000\000\
\219\002\219\002\000\000\219\002\000\000\219\002\000\000\000\000\
\219\002\219\002\000\000\000\000\219\002\219\002\000\000\000\000\
\000\000\219\002\000\000\000\000\219\002\000\000\219\002\219\002\
\219\002\219\002\219\002\219\002\000\000\000\000\219\002\035\001\
\036\001\037\001\000\000\000\000\009\000\010\000\038\001\000\000\
\039\001\000\000\012\000\013\000\000\000\000\000\040\001\041\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\042\001\000\000\000\000\017\000\018\000\019\000\
\020\000\021\000\000\000\043\001\000\000\000\000\022\000\000\000\
\000\000\044\001\045\001\046\001\047\001\048\001\000\000\000\000\
\024\000\025\000\026\000\000\000\027\000\028\000\029\000\030\000\
\031\000\000\000\000\000\032\000\000\000\049\001\000\000\034\000\
\035\000\036\000\000\000\000\000\000\000\038\000\000\000\050\001\
\051\001\000\000\052\001\000\000\042\000\043\000\000\000\044\000\
\000\000\000\000\000\000\053\001\054\001\055\001\056\001\057\001\
\058\001\000\000\000\000\000\000\000\000\000\000\000\000\059\001\
\000\000\000\000\000\000\060\001\000\000\061\001\050\000\000\000\
\000\000\000\000\000\000\051\000\052\000\000\000\054\000\035\001\
\036\001\037\001\000\000\055\000\009\000\010\000\038\001\000\000\
\039\001\000\000\012\000\013\000\000\000\000\000\000\000\041\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\042\001\000\000\000\000\017\000\018\000\019\000\
\020\000\021\000\000\000\043\001\000\000\000\000\022\000\000\000\
\000\000\044\001\045\001\046\001\047\001\048\001\000\000\000\000\
\024\000\025\000\026\000\000\000\027\000\028\000\029\000\030\000\
\031\000\000\000\000\000\032\000\000\000\049\001\000\000\034\000\
\035\000\036\000\000\000\000\000\000\000\038\000\000\000\050\001\
\051\001\000\000\052\001\000\000\042\000\043\000\000\000\044\000\
\000\000\000\000\000\000\053\001\054\001\055\001\056\001\057\001\
\058\001\000\000\000\000\000\000\000\000\000\000\000\000\059\001\
\000\000\000\000\000\000\060\001\000\000\061\001\050\000\000\000\
\000\000\000\000\000\000\051\000\052\000\000\000\054\000\035\001\
\036\001\037\001\000\000\055\000\009\000\010\000\038\001\000\000\
\039\001\000\000\012\000\013\000\000\000\000\000\000\000\041\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\042\001\000\000\000\000\017\000\018\000\019\000\
\020\000\021\000\000\000\043\001\000\000\000\000\022\000\000\000\
\000\000\044\001\045\001\046\001\047\001\048\001\000\000\000\000\
\024\000\025\000\026\000\000\000\027\000\028\000\029\000\030\000\
\031\000\000\000\000\000\032\000\000\000\049\001\000\000\034\000\
\035\000\036\000\000\000\000\000\000\000\038\000\000\000\050\001\
\051\001\000\000\090\003\000\000\042\000\043\000\000\000\044\000\
\000\000\000\000\000\000\053\001\054\001\055\001\056\001\057\001\
\058\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\060\001\000\000\061\001\050\000\000\000\
\000\000\000\000\226\002\051\000\052\000\000\000\054\000\226\002\
\226\002\226\002\226\002\055\000\000\000\226\002\226\002\000\000\
\000\000\000\000\000\000\000\000\000\000\226\002\000\000\000\000\
\000\000\000\000\000\000\000\000\226\002\000\000\226\002\000\000\
\226\002\226\002\226\002\226\002\226\002\000\000\000\000\000\000\
\000\000\226\002\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\226\002\226\002\226\002\226\002\226\002\226\002\226\002\
\226\002\226\002\226\002\226\002\000\000\000\000\226\002\226\002\
\000\000\000\000\226\002\226\002\226\002\000\000\000\000\226\002\
\226\002\226\002\226\002\226\002\000\000\000\000\000\000\226\002\
\226\002\000\000\226\002\000\000\000\000\226\002\000\000\000\000\
\226\002\226\002\000\000\226\002\000\000\226\002\000\000\000\000\
\000\000\226\002\000\000\000\000\000\000\226\002\000\000\000\000\
\000\000\226\002\000\000\000\000\226\002\000\000\226\002\226\002\
\000\000\226\002\226\002\226\002\094\002\000\000\226\002\000\000\
\000\000\165\002\165\002\165\002\000\000\000\000\000\000\165\002\
\165\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\165\002\165\002\165\002\165\002\165\002\000\000\
\000\000\000\000\000\000\165\002\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\165\002\165\002\165\002\
\000\000\165\002\165\002\165\002\165\002\165\002\000\000\000\000\
\165\002\000\000\000\000\000\000\165\002\165\002\165\002\000\000\
\000\000\000\000\165\002\000\000\165\002\165\002\000\000\000\000\
\000\000\165\002\165\002\000\000\165\002\000\000\000\000\000\000\
\000\000\000\000\165\002\165\002\095\002\165\002\000\000\000\000\
\000\000\166\002\166\002\166\002\094\002\000\000\000\000\166\002\
\166\002\000\000\000\000\165\002\000\000\000\000\000\000\000\000\
\165\002\165\002\000\000\165\002\000\000\000\000\000\000\000\000\
\165\002\000\000\166\002\166\002\166\002\166\002\166\002\000\000\
\000\000\000\000\000\000\166\002\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\166\002\166\002\166\002\
\000\000\166\002\166\002\166\002\166\002\166\002\000\000\000\000\
\166\002\000\000\000\000\000\000\166\002\166\002\166\002\000\000\
\000\000\000\000\166\002\000\000\166\002\166\002\000\000\000\000\
\000\000\166\002\166\002\000\000\166\002\000\000\000\000\000\000\
\000\000\000\000\166\002\166\002\092\002\166\002\000\000\000\000\
\000\000\167\002\167\002\167\002\095\002\000\000\000\000\167\002\
\167\002\000\000\000\000\166\002\000\000\000\000\000\000\000\000\
\166\002\166\002\000\000\166\002\000\000\000\000\000\000\000\000\
\166\002\000\000\167\002\167\002\167\002\167\002\167\002\000\000\
\000\000\000\000\000\000\167\002\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\167\002\167\002\167\002\
\000\000\167\002\167\002\167\002\167\002\167\002\000\000\000\000\
\167\002\000\000\000\000\000\000\167\002\167\002\167\002\000\000\
\000\000\000\000\167\002\000\000\167\002\167\002\000\000\000\000\
\000\000\167\002\167\002\000\000\167\002\000\000\000\000\000\000\
\000\000\000\000\167\002\167\002\093\002\167\002\000\000\000\000\
\000\000\168\002\168\002\168\002\092\002\000\000\000\000\168\002\
\168\002\000\000\000\000\167\002\000\000\000\000\000\000\000\000\
\167\002\167\002\000\000\167\002\000\000\000\000\000\000\000\000\
\167\002\000\000\168\002\168\002\168\002\168\002\168\002\000\000\
\000\000\000\000\000\000\168\002\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\168\002\168\002\168\002\
\000\000\168\002\168\002\168\002\168\002\168\002\000\000\000\000\
\168\002\000\000\000\000\000\000\168\002\168\002\168\002\000\000\
\000\000\000\000\168\002\000\000\168\002\168\002\000\000\000\000\
\000\000\168\002\168\002\000\000\168\002\000\000\000\000\000\000\
\000\000\000\000\168\002\168\002\000\000\168\002\000\000\000\000\
\000\000\000\000\000\000\000\000\093\002\235\000\236\000\237\000\
\000\000\000\000\000\000\168\002\000\000\238\000\000\000\239\000\
\168\002\168\002\000\000\168\002\000\000\240\000\241\000\242\000\
\168\002\000\000\243\000\244\000\245\000\000\000\246\000\247\000\
\248\000\000\000\249\000\250\000\251\000\252\000\000\000\000\000\
\000\000\253\000\254\000\255\000\000\000\000\000\000\000\000\000\
\000\000\000\001\001\001\000\000\000\000\000\000\000\000\002\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\003\001\004\001\000\000\000\000\000\000\000\000\
\005\001\006\001\000\000\000\000\000\000\007\001\008\001\000\000\
\009\001\000\000\010\001\011\001\012\001\000\000\013\001\000\000\
\000\000\000\000\000\000\000\000\014\001\000\000\000\000\000\000\
\000\000\015\001\000\000\000\000\000\000\000\000\000\000\016\001\
\008\002\000\000\017\001\018\001\008\002\019\001\020\001\021\001\
\022\001\023\001\000\000\024\001\025\001\026\001\027\001\028\001\
\000\000\008\002\000\000\008\002\000\000\000\000\245\001\000\000\
\000\000\000\000\008\002\008\002\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\008\002\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\008\002\
\008\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\008\002\000\000\000\000\
\000\000\008\002\000\000\008\002\008\002\008\002\000\000\008\002\
\000\000\000\000\008\002\000\000\000\000\000\000\000\000\035\001\
\036\001\037\001\000\000\000\000\000\000\010\000\225\001\000\000\
\039\001\000\000\000\000\013\000\245\001\008\002\226\001\041\001\
\000\000\008\002\000\000\008\002\000\000\000\000\008\002\000\000\
\000\000\000\000\042\001\162\000\000\000\017\000\018\000\008\002\
\000\000\008\002\000\000\043\001\000\000\000\000\000\000\000\000\
\000\000\044\001\045\001\046\001\047\001\048\001\000\000\000\000\
\024\000\025\000\026\000\000\000\163\000\164\000\000\000\165\000\
\166\000\000\000\000\000\032\000\000\000\049\001\000\000\000\000\
\167\000\168\000\000\000\000\000\000\000\000\000\000\000\227\001\
\228\001\000\000\229\001\000\000\042\000\000\000\000\000\000\000\
\000\000\000\000\000\000\053\001\054\001\230\001\231\001\057\001\
\232\001\000\000\000\000\000\000\000\000\000\000\000\000\059\001\
\000\000\000\000\171\000\060\001\000\000\061\001\050\000\000\000\
\000\000\000\000\000\000\051\000\000\000\000\000\054\000\172\000\
\035\001\036\001\037\001\000\000\000\000\000\000\010\000\225\001\
\000\000\039\001\000\000\000\000\013\000\000\000\000\000\000\000\
\041\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\042\001\162\000\000\000\017\000\018\000\
\000\000\000\000\000\000\000\000\043\001\000\000\000\000\000\000\
\000\000\000\000\044\001\045\001\046\001\047\001\048\001\000\000\
\000\000\024\000\025\000\026\000\000\000\163\000\164\000\000\000\
\165\000\166\000\000\000\000\000\032\000\000\000\049\001\000\000\
\000\000\167\000\168\000\000\000\000\000\000\000\000\000\000\000\
\227\001\228\001\000\000\229\001\000\000\042\000\000\000\000\000\
\000\000\000\000\000\000\000\000\053\001\054\001\230\001\231\001\
\057\001\232\001\000\000\000\000\000\000\000\000\000\000\000\000\
\059\001\000\000\000\000\171\000\060\001\000\000\061\001\050\000\
\000\000\000\000\000\000\000\000\051\000\000\000\001\003\054\000\
\172\000\035\001\036\001\037\001\000\000\000\000\000\000\010\000\
\225\001\000\000\039\001\000\000\000\000\013\000\000\000\000\000\
\000\000\041\001\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\042\001\162\000\000\000\017\000\
\018\000\000\000\000\000\000\000\000\000\043\001\000\000\000\000\
\000\000\000\000\000\000\044\001\045\001\046\001\047\001\048\001\
\000\000\000\000\024\000\025\000\026\000\000\000\163\000\164\000\
\000\000\165\000\166\000\000\000\000\000\032\000\000\000\049\001\
\000\000\000\000\167\000\168\000\000\000\000\000\000\000\000\000\
\000\000\227\001\228\001\000\000\229\001\000\000\042\000\000\000\
\000\000\000\000\000\000\000\000\000\000\053\001\054\001\230\001\
\231\001\057\001\232\001\000\000\000\000\000\000\000\000\000\000\
\000\000\059\001\000\000\000\000\171\000\060\001\000\000\061\001\
\050\000\000\000\000\000\000\000\000\000\051\000\000\000\202\003\
\054\000\172\000\035\001\036\001\037\001\000\000\000\000\000\000\
\010\000\225\001\000\000\039\001\000\000\000\000\013\000\000\000\
\000\000\000\000\041\001\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\042\001\162\000\000\000\
\017\000\018\000\000\000\000\000\000\000\000\000\043\001\000\000\
\000\000\000\000\000\000\000\000\044\001\045\001\046\001\047\001\
\048\001\000\000\000\000\024\000\025\000\026\000\000\000\163\000\
\164\000\000\000\165\000\166\000\000\000\000\000\032\000\000\000\
\049\001\000\000\000\000\167\000\168\000\000\000\000\000\000\000\
\000\000\000\000\227\001\228\001\000\000\229\001\000\000\042\000\
\000\000\000\000\000\000\000\000\000\000\000\000\053\001\054\001\
\230\001\231\001\057\001\232\001\000\000\000\000\000\000\000\000\
\000\000\000\000\059\001\000\000\000\000\171\000\060\001\000\000\
\061\001\050\000\000\000\000\000\000\000\000\000\051\000\000\000\
\008\004\054\000\172\000\035\001\036\001\037\001\000\000\000\000\
\000\000\010\000\225\001\000\000\039\001\000\000\000\000\013\000\
\000\000\000\000\000\000\041\001\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\042\001\162\000\
\000\000\017\000\018\000\000\000\000\000\000\000\000\000\043\001\
\000\000\000\000\000\000\000\000\000\000\044\001\045\001\046\001\
\047\001\048\001\000\000\000\000\024\000\025\000\026\000\000\000\
\163\000\164\000\000\000\165\000\166\000\000\000\000\000\032\000\
\000\000\049\001\000\000\221\002\167\000\168\000\000\000\000\000\
\000\000\010\000\000\000\227\001\228\001\000\000\229\001\013\000\
\042\000\000\000\000\000\000\000\000\000\000\000\000\000\053\001\
\054\001\230\001\231\001\057\001\232\001\000\000\000\000\162\000\
\000\000\017\000\018\000\059\001\000\000\000\000\171\000\060\001\
\000\000\061\001\050\000\000\000\000\000\000\000\000\000\051\000\
\000\000\000\000\054\000\172\000\024\000\025\000\026\000\000\000\
\163\000\164\000\000\000\165\000\166\000\000\000\000\000\032\000\
\000\000\000\000\000\000\223\002\167\000\168\000\000\000\000\000\
\000\000\010\000\000\000\169\000\000\000\000\000\000\000\013\000\
\042\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\170\000\000\000\000\000\000\000\000\000\000\000\162\000\
\000\000\017\000\018\000\000\000\000\000\000\000\171\000\000\000\
\000\000\000\000\050\000\000\000\000\000\000\000\000\000\051\000\
\000\000\000\000\054\000\172\000\024\000\025\000\026\000\000\000\
\163\000\164\000\000\000\165\000\166\000\000\000\000\000\032\000\
\000\000\000\000\000\000\225\002\167\000\168\000\000\000\000\000\
\000\000\010\000\000\000\169\000\000\000\000\000\000\000\013\000\
\042\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\170\000\000\000\000\000\000\000\000\000\000\000\162\000\
\000\000\017\000\018\000\000\000\000\000\000\000\171\000\000\000\
\000\000\000\000\050\000\000\000\000\000\000\000\000\000\051\000\
\000\000\000\000\054\000\172\000\024\000\025\000\026\000\000\000\
\163\000\164\000\000\000\165\000\166\000\000\000\000\000\032\000\
\000\000\000\000\000\000\000\000\167\000\168\000\000\000\000\000\
\000\000\000\000\000\000\169\000\000\000\000\000\000\000\000\000\
\042\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\170\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\171\000\000\000\
\000\000\000\000\050\000\000\000\000\000\000\000\000\000\051\000\
\000\000\000\000\054\000\172\000\009\000\010\000\011\000\000\000\
\000\000\000\000\012\000\013\000\014\000\053\002\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\015\000\016\000\017\000\018\000\019\000\
\020\000\021\000\000\000\000\000\000\000\000\000\022\000\000\000\
\023\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\024\000\025\000\026\000\000\000\027\000\028\000\029\000\030\000\
\031\000\000\000\000\000\032\000\033\000\000\000\000\000\034\000\
\035\000\036\000\000\000\000\000\037\000\038\000\000\000\039\000\
\040\000\000\000\041\000\000\000\042\000\043\000\000\000\044\000\
\000\000\045\000\000\000\000\000\000\000\046\000\047\000\000\000\
\048\000\000\000\054\002\000\000\000\000\009\000\010\000\011\000\
\000\000\049\000\000\000\012\000\013\000\014\000\050\000\000\000\
\000\000\000\000\000\000\051\000\052\000\053\000\054\000\000\000\
\000\000\000\000\000\000\055\000\015\000\016\000\017\000\018\000\
\019\000\020\000\021\000\000\000\000\000\000\000\000\000\022\000\
\000\000\023\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\024\000\025\000\026\000\000\000\027\000\028\000\029\000\
\030\000\031\000\000\000\000\000\032\000\033\000\000\000\000\000\
\034\000\035\000\036\000\000\000\000\000\037\000\038\000\000\000\
\039\000\040\000\000\000\041\000\000\000\042\000\043\000\000\000\
\044\000\000\000\045\000\000\000\000\000\000\000\046\000\047\000\
\000\000\048\000\000\000\000\000\000\000\009\000\010\000\011\000\
\000\000\000\000\049\000\012\000\013\000\000\000\000\000\050\000\
\000\000\000\000\000\000\000\000\051\000\052\000\053\000\054\000\
\000\000\000\000\000\000\000\000\055\000\000\000\017\000\018\000\
\019\000\020\000\021\000\000\000\000\000\000\000\000\000\022\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\024\000\025\000\026\000\000\000\027\000\028\000\029\000\
\030\000\031\000\000\000\000\000\032\000\000\000\000\000\000\000\
\034\000\035\000\036\000\000\000\000\000\000\000\038\000\000\000\
\039\000\040\000\000\000\000\000\000\000\042\000\043\000\000\000\
\044\000\000\000\000\000\000\000\000\000\000\000\046\000\047\000\
\000\000\048\000\000\000\000\000\000\000\000\000\230\000\009\000\
\010\000\011\000\000\000\000\000\233\000\012\000\013\000\050\000\
\000\000\000\000\000\000\000\000\051\000\052\000\000\000\054\000\
\000\000\000\000\000\000\000\000\055\000\000\000\000\000\000\000\
\017\000\018\000\019\000\020\000\021\000\000\000\000\000\000\000\
\000\000\022\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\024\000\025\000\026\000\000\000\027\000\
\028\000\029\000\030\000\031\000\000\000\000\000\032\000\000\000\
\000\000\000\000\034\000\035\000\036\000\000\000\000\000\000\000\
\038\000\000\000\039\000\040\000\000\000\000\000\000\000\042\000\
\043\000\000\000\044\000\000\000\000\000\000\000\000\000\000\000\
\046\000\047\000\000\000\048\000\000\000\000\000\009\000\010\000\
\011\000\000\000\000\000\000\000\012\000\013\000\000\000\000\000\
\000\000\050\000\000\000\000\000\000\000\000\000\051\000\052\000\
\000\000\054\000\000\000\006\002\000\000\000\000\055\000\017\000\
\018\000\019\000\020\000\021\000\000\000\000\000\000\000\000\000\
\022\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\024\000\025\000\026\000\000\000\027\000\028\000\
\029\000\030\000\031\000\000\000\000\000\032\000\000\000\000\000\
\000\000\034\000\035\000\036\000\000\000\000\000\000\000\038\000\
\000\000\039\000\040\000\000\000\000\000\000\000\042\000\043\000\
\000\000\044\000\000\000\000\000\000\000\000\000\000\000\046\000\
\047\000\000\000\048\000\000\000\000\000\228\002\228\002\228\002\
\000\000\000\000\000\000\228\002\228\002\000\000\000\000\000\000\
\050\000\000\000\000\000\000\000\000\000\051\000\052\000\000\000\
\054\000\000\000\228\002\000\000\000\000\055\000\228\002\228\002\
\228\002\228\002\228\002\000\000\000\000\000\000\000\000\228\002\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\228\002\228\002\228\002\000\000\228\002\228\002\228\002\
\228\002\228\002\000\000\000\000\228\002\000\000\000\000\000\000\
\228\002\228\002\228\002\000\000\000\000\000\000\228\002\000\000\
\228\002\228\002\000\000\000\000\000\000\228\002\228\002\000\000\
\228\002\000\000\000\000\000\000\000\000\000\000\228\002\228\002\
\000\000\228\002\000\000\000\000\009\000\010\000\011\000\000\000\
\000\000\000\000\012\000\013\000\000\000\000\000\000\000\228\002\
\000\000\000\000\000\000\000\000\228\002\228\002\000\000\228\002\
\000\000\000\000\000\000\000\000\228\002\017\000\018\000\019\000\
\020\000\021\000\000\000\000\000\000\000\000\000\022\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\024\000\025\000\026\000\000\000\027\000\028\000\029\000\030\000\
\031\000\000\000\000\000\032\000\000\000\000\000\000\000\034\000\
\035\000\036\000\000\000\000\000\000\000\038\000\000\000\039\000\
\040\000\000\000\000\000\000\000\042\000\043\000\000\000\044\000\
\000\000\000\000\000\000\000\000\000\000\046\000\047\000\000\000\
\048\000\000\000\000\000\228\002\228\002\228\002\000\000\000\000\
\000\000\228\002\228\002\000\000\000\000\000\000\050\000\000\000\
\000\000\000\000\000\000\051\000\052\000\000\000\054\000\000\000\
\000\000\000\000\000\000\055\000\228\002\228\002\228\002\228\002\
\228\002\000\000\000\000\000\000\000\000\228\002\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\228\002\
\228\002\228\002\000\000\228\002\228\002\228\002\228\002\228\002\
\000\000\000\000\228\002\000\000\000\000\000\000\228\002\228\002\
\228\002\000\000\000\000\000\000\228\002\000\000\228\002\228\002\
\000\000\000\000\000\000\228\002\228\002\000\000\228\002\000\000\
\000\000\000\000\000\000\000\000\228\002\228\002\000\000\228\002\
\000\000\000\000\000\000\010\000\000\000\000\000\000\000\000\000\
\000\000\013\000\000\000\094\003\000\000\228\002\067\002\000\000\
\000\000\000\000\228\002\228\002\000\000\228\002\000\000\000\000\
\095\003\000\000\228\002\017\000\018\000\243\001\000\000\243\001\
\243\001\243\001\000\000\243\001\000\000\000\000\243\001\243\001\
\000\000\000\000\000\000\000\000\000\000\000\000\024\000\025\000\
\026\000\021\002\000\000\164\000\000\000\165\000\166\000\000\000\
\243\001\032\000\000\000\000\000\000\000\000\000\167\000\096\003\
\243\001\243\001\000\000\000\000\000\000\169\000\010\000\000\000\
\243\001\000\000\042\000\000\000\013\000\000\000\066\002\000\000\
\023\002\067\002\000\000\170\000\243\001\243\001\000\000\000\000\
\024\002\000\000\000\000\095\003\000\000\000\000\017\000\018\000\
\171\000\000\000\000\000\000\000\050\000\000\000\000\000\025\002\
\000\000\051\000\000\000\000\000\054\000\172\000\000\000\000\000\
\000\000\024\000\025\000\026\000\021\002\000\000\164\000\000\000\
\165\000\166\000\000\000\000\000\032\000\000\000\000\000\000\000\
\000\000\167\000\096\003\000\000\000\000\000\000\000\000\000\000\
\169\000\010\000\000\000\000\000\000\000\042\000\000\000\013\000\
\000\000\185\003\000\000\023\002\000\000\000\000\170\000\000\000\
\000\000\000\000\000\000\024\002\000\000\000\000\186\003\000\000\
\000\000\017\000\018\000\171\000\000\000\000\000\000\000\050\000\
\000\000\000\000\025\002\000\000\051\000\000\000\000\000\054\000\
\172\000\000\000\000\000\000\000\024\000\025\000\026\000\021\002\
\000\000\164\000\000\000\165\000\166\000\000\000\000\000\032\000\
\000\000\000\000\000\000\000\000\167\000\212\001\000\000\000\000\
\000\000\000\000\000\000\169\000\010\000\000\000\000\000\000\000\
\042\000\000\000\013\000\000\000\146\005\000\000\023\002\000\000\
\000\000\170\000\000\000\000\000\000\000\000\000\024\002\000\000\
\000\000\095\003\000\000\000\000\017\000\018\000\171\000\000\000\
\000\000\000\000\050\000\000\000\000\000\025\002\000\000\051\000\
\000\000\000\000\054\000\172\000\000\000\000\000\000\000\024\000\
\025\000\026\000\021\002\000\000\164\000\000\000\165\000\166\000\
\000\000\000\000\032\000\000\000\000\000\000\000\000\000\167\000\
\096\003\000\000\000\000\000\000\010\000\000\000\169\000\000\000\
\000\000\000\000\013\000\042\000\000\000\000\000\000\000\000\000\
\000\000\023\002\000\000\000\000\170\000\000\000\000\000\000\000\
\000\000\024\002\000\000\000\000\017\000\018\000\000\000\000\000\
\000\000\171\000\000\000\000\000\000\000\050\000\000\000\000\000\
\025\002\000\000\051\000\000\000\000\000\054\000\172\000\024\000\
\025\000\026\000\021\002\000\000\164\000\000\000\165\000\166\000\
\000\000\000\000\032\000\000\000\000\000\000\000\000\000\167\000\
\011\003\000\000\000\000\000\000\010\000\000\000\169\000\000\000\
\012\003\000\000\013\000\042\000\000\000\000\000\000\000\000\000\
\000\000\023\002\000\000\000\000\170\000\000\000\000\000\000\000\
\000\000\024\002\000\000\000\000\017\000\018\000\000\000\000\000\
\000\000\171\000\000\000\000\000\000\000\050\000\000\000\000\000\
\025\002\000\000\051\000\000\000\000\000\054\000\172\000\024\000\
\025\000\026\000\021\002\000\000\164\000\000\000\165\000\166\000\
\000\000\000\000\032\000\000\000\000\000\000\000\000\000\167\000\
\212\001\000\000\000\000\000\000\010\000\000\000\169\000\000\000\
\069\005\000\000\013\000\042\000\000\000\000\000\000\000\000\000\
\000\000\023\002\000\000\000\000\170\000\000\000\000\000\000\000\
\000\000\024\002\000\000\000\000\017\000\018\000\000\000\000\000\
\000\000\171\000\000\000\000\000\000\000\050\000\000\000\000\000\
\025\002\000\000\051\000\000\000\000\000\054\000\172\000\024\000\
\025\000\026\000\021\002\000\000\164\000\000\000\165\000\166\000\
\000\000\000\000\032\000\000\000\000\000\000\000\000\000\167\000\
\022\002\000\000\000\000\000\000\010\000\000\000\169\000\000\000\
\000\000\000\000\013\000\042\000\000\000\000\000\000\000\000\000\
\000\000\023\002\000\000\000\000\170\000\000\000\000\000\000\000\
\000\000\024\002\000\000\000\000\017\000\018\000\000\000\000\000\
\000\000\171\000\000\000\000\000\000\000\050\000\000\000\000\000\
\025\002\000\000\051\000\000\000\000\000\054\000\172\000\024\000\
\025\000\026\000\021\002\000\000\164\000\000\000\165\000\166\000\
\000\000\000\000\032\000\000\000\000\000\000\000\000\000\167\000\
\212\001\000\000\000\000\000\000\228\002\000\000\169\000\000\000\
\000\000\000\000\228\002\042\000\000\000\000\000\000\000\000\000\
\000\000\023\002\000\000\000\000\170\000\000\000\000\000\000\000\
\000\000\024\002\000\000\000\000\228\002\228\002\000\000\000\000\
\000\000\171\000\000\000\000\000\000\000\050\000\000\000\000\000\
\025\002\000\000\051\000\000\000\000\000\054\000\172\000\228\002\
\228\002\228\002\228\002\000\000\228\002\000\000\228\002\228\002\
\000\000\000\000\228\002\000\000\000\000\000\000\000\000\228\002\
\228\002\000\000\000\000\000\000\010\000\000\000\228\002\000\000\
\000\000\000\000\013\000\228\002\000\000\000\000\000\000\000\000\
\000\000\228\002\000\000\000\000\228\002\000\000\000\000\000\000\
\000\000\228\002\162\000\000\000\017\000\018\000\000\000\000\000\
\000\000\228\002\000\000\000\000\000\000\228\002\000\000\000\000\
\228\002\000\000\228\002\000\000\000\000\228\002\228\002\024\000\
\025\000\026\000\000\000\163\000\164\000\000\000\165\000\166\000\
\000\000\000\000\032\000\000\000\000\000\000\000\000\000\167\000\
\168\000\000\000\000\000\000\000\000\000\000\000\169\000\000\000\
\000\000\000\000\010\000\042\000\000\000\000\000\223\001\000\000\
\013\000\000\000\000\000\000\000\170\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\230\000\000\000\000\000\000\000\
\162\000\171\000\017\000\018\000\000\000\050\000\000\000\000\000\
\000\000\000\000\051\000\000\000\000\000\054\000\172\000\000\000\
\000\000\000\000\000\000\000\000\000\000\024\000\025\000\026\000\
\000\000\163\000\164\000\000\000\165\000\166\000\000\000\000\000\
\032\000\000\000\000\000\000\000\000\000\167\000\168\000\000\000\
\000\000\000\000\000\000\000\000\169\000\228\002\000\000\228\002\
\000\000\042\000\000\000\228\002\000\000\000\000\000\000\000\000\
\000\000\000\000\170\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\228\002\000\000\228\002\228\002\171\000\
\000\000\000\000\000\000\050\000\000\000\000\000\000\000\000\000\
\051\000\000\000\000\000\054\000\172\000\000\000\000\000\000\000\
\228\002\228\002\228\002\000\000\228\002\228\002\000\000\228\002\
\228\002\000\000\000\000\228\002\000\000\000\000\000\000\000\000\
\228\002\228\002\000\000\000\000\000\000\228\002\000\000\228\002\
\000\000\000\000\000\000\228\002\228\002\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\228\002\000\000\000\000\
\000\000\000\000\000\000\228\002\000\000\228\002\228\002\000\000\
\000\000\000\000\228\002\000\000\000\000\000\000\228\002\000\000\
\000\000\000\000\000\000\228\002\000\000\000\000\228\002\228\002\
\228\002\228\002\228\002\000\000\228\002\228\002\000\000\228\002\
\228\002\000\000\000\000\228\002\000\000\000\000\000\000\000\000\
\228\002\228\002\000\000\000\000\000\000\000\000\000\000\228\002\
\000\000\000\000\000\000\010\000\228\002\000\000\000\000\000\000\
\000\000\013\000\000\000\000\000\000\000\228\002\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\228\002\000\000\
\000\000\162\000\228\002\017\000\018\000\000\000\228\002\000\000\
\000\000\000\000\000\000\228\002\000\000\000\000\228\002\228\002\
\000\000\000\000\000\000\000\000\000\000\000\000\024\000\025\000\
\026\000\000\000\163\000\164\000\000\000\165\000\166\000\000\000\
\000\000\032\000\000\000\000\000\000\000\000\000\167\000\168\000\
\000\000\000\000\000\000\228\002\000\000\169\000\000\000\000\000\
\000\000\228\002\042\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\170\000\000\000\000\000\000\000\000\000\
\000\000\228\002\000\000\228\002\228\002\000\000\000\000\000\000\
\171\000\000\000\000\000\000\000\050\000\000\000\000\000\000\000\
\000\000\051\000\000\000\000\000\054\000\172\000\228\002\228\002\
\228\002\000\000\228\002\228\002\000\000\228\002\228\002\000\000\
\000\000\228\002\000\000\000\000\000\000\000\000\228\002\228\002\
\000\000\000\000\000\000\161\002\000\000\228\002\000\000\000\000\
\000\000\161\002\228\002\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\228\002\000\000\000\000\000\000\000\000\
\000\000\161\002\000\000\161\002\161\002\000\000\000\000\000\000\
\228\002\000\000\000\000\000\000\228\002\000\000\000\000\000\000\
\000\000\228\002\000\000\000\000\228\002\228\002\161\002\161\002\
\161\002\000\000\161\002\161\002\000\000\161\002\161\002\000\000\
\000\000\161\002\000\000\000\000\000\000\000\000\161\002\161\002\
\000\000\000\000\000\000\142\002\000\000\161\002\000\000\000\000\
\000\000\142\002\161\002\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\161\002\000\000\000\000\000\000\000\000\
\000\000\142\002\000\000\142\002\142\002\000\000\000\000\000\000\
\161\002\000\000\000\000\000\000\161\002\000\000\000\000\000\000\
\000\000\161\002\000\000\000\000\161\002\161\002\142\002\142\002\
\142\002\000\000\142\002\142\002\000\000\142\002\142\002\000\000\
\000\000\142\002\000\000\000\000\000\000\000\000\142\002\142\002\
\000\000\000\000\000\000\010\000\000\000\142\002\000\000\000\000\
\000\000\013\000\142\002\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\142\002\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\017\000\018\000\000\000\000\000\000\000\
\142\002\000\000\000\000\000\000\142\002\000\000\000\000\000\000\
\000\000\142\002\000\000\000\000\142\002\142\002\024\000\025\000\
\026\000\000\000\000\000\164\000\000\000\165\000\166\000\000\000\
\000\000\032\000\000\000\000\000\000\000\000\000\167\000\212\001\
\000\000\000\000\000\000\000\000\000\000\169\000\010\000\011\000\
\000\000\000\000\042\000\012\000\013\000\000\000\000\000\000\000\
\000\000\000\000\000\000\170\000\000\000\000\000\124\001\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\017\000\018\000\
\171\000\000\000\000\000\000\000\050\000\000\000\000\000\000\000\
\000\000\051\000\000\000\000\000\054\000\172\000\000\000\000\000\
\000\000\024\000\025\000\026\000\125\001\000\000\028\000\029\000\
\030\000\031\000\000\000\000\000\032\000\000\000\000\000\000\000\
\000\000\167\000\192\000\000\000\000\000\010\000\011\000\000\000\
\000\000\000\000\012\000\013\000\000\000\042\000\043\000\000\000\
\000\000\000\000\000\000\126\001\000\000\000\000\000\000\000\000\
\000\000\048\000\000\000\127\001\000\000\017\000\018\000\000\000\
\000\000\000\000\000\000\128\001\129\001\000\000\000\000\050\000\
\000\000\000\000\130\001\000\000\051\000\000\000\000\000\054\000\
\024\000\025\000\026\000\125\001\000\000\028\000\029\000\030\000\
\031\000\000\000\000\000\032\000\000\000\000\000\000\000\000\000\
\167\000\192\000\000\000\000\000\010\000\011\000\000\000\000\000\
\000\000\012\000\013\000\000\000\042\000\043\000\000\000\000\000\
\000\000\000\000\126\001\000\000\000\000\000\000\000\000\000\000\
\048\000\000\000\127\001\000\000\017\000\018\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\050\000\000\000\
\000\000\130\001\000\000\051\000\000\000\000\000\054\000\024\000\
\025\000\026\000\000\000\000\000\028\000\029\000\030\000\031\000\
\000\000\000\000\032\000\000\000\000\000\000\000\000\000\167\000\
\192\000\000\000\000\000\010\000\011\000\000\000\000\000\000\000\
\012\000\013\000\000\000\042\000\043\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\048\000\
\000\000\000\000\000\000\017\000\018\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\050\000\000\000\000\000\
\000\000\000\000\051\000\000\000\000\000\054\000\024\000\025\000\
\026\000\000\000\000\000\028\000\029\000\030\000\031\000\000\000\
\000\000\032\000\000\000\000\000\000\000\000\000\219\000\192\000\
\000\000\000\000\228\002\228\002\000\000\000\000\000\000\228\002\
\228\002\000\000\042\000\043\000\000\000\000\000\000\000\000\000\
\000\000\000\000\144\004\000\000\000\000\000\000\048\000\000\000\
\000\000\200\000\228\002\228\002\137\000\000\000\138\000\139\000\
\032\000\145\004\140\000\000\000\050\000\141\000\142\000\000\000\
\201\000\051\000\000\000\000\000\054\000\228\002\228\002\228\002\
\000\000\000\000\228\002\228\002\228\002\228\002\000\000\143\000\
\228\002\000\000\000\000\000\000\000\000\228\002\228\002\144\000\
\144\003\000\000\137\000\000\000\138\000\139\000\032\000\146\000\
\140\000\228\002\228\002\141\000\146\004\000\000\000\000\000\000\
\000\000\144\004\183\005\147\000\148\000\228\002\000\000\000\000\
\200\000\000\000\000\000\000\000\000\000\143\000\000\000\000\000\
\000\000\000\000\000\000\228\002\147\004\144\000\145\000\201\000\
\228\002\000\000\000\000\228\002\000\000\146\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\203\000\000\000\
\000\000\148\004\148\000\000\000\000\000\000\000\000\000\000\000\
\000\000\137\000\000\000\138\000\139\000\032\000\000\000\140\000\
\000\000\000\000\141\000\146\004\000\000\000\000\000\000\000\000\
\211\003\087\001\088\001\000\000\000\000\000\000\000\000\000\000\
\000\000\089\001\000\000\000\000\143\000\000\000\212\003\090\001\
\091\001\213\003\092\001\000\000\144\000\145\000\000\000\000\000\
\000\000\000\000\000\000\093\001\146\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\094\001\203\000\000\000\000\000\
\148\004\148\000\095\001\096\001\097\001\098\001\099\001\035\001\
\036\001\037\001\000\000\000\000\000\000\000\000\225\001\000\000\
\039\001\000\000\000\000\000\000\000\000\000\000\100\001\041\001\
\000\000\000\000\000\000\185\000\000\000\000\000\000\000\000\000\
\101\001\102\001\042\001\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\043\001\103\001\104\001\105\001\106\001\
\107\001\044\001\045\001\046\001\047\001\048\001\000\000\000\000\
\214\003\000\000\000\000\000\000\000\000\000\000\109\001\000\000\
\000\000\000\000\000\000\000\000\000\000\049\001\000\000\000\000\
\000\000\087\001\088\001\000\000\000\000\000\000\000\000\016\002\
\228\001\089\001\017\002\000\000\000\000\000\000\000\000\090\001\
\091\001\000\000\092\001\053\001\054\001\018\002\231\001\057\001\
\232\001\000\000\000\000\093\001\000\000\000\000\000\000\000\000\
\000\000\087\001\088\001\060\001\094\001\061\001\000\000\000\000\
\000\000\089\001\095\001\096\001\097\001\098\001\099\001\090\001\
\091\001\000\000\092\001\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\093\001\000\000\000\000\100\001\000\000\
\000\000\000\000\000\000\185\000\094\001\000\000\000\000\000\000\
\101\001\102\001\095\001\096\001\097\001\098\001\099\001\000\000\
\000\000\000\000\000\000\000\000\103\001\104\001\105\001\106\001\
\107\001\000\000\000\000\000\000\000\000\000\000\100\001\087\001\
\088\001\108\001\000\000\185\000\000\000\000\000\109\001\089\001\
\101\001\102\001\000\000\000\000\000\000\090\001\091\001\000\000\
\092\001\000\000\000\000\000\000\103\001\104\001\105\001\106\001\
\107\001\093\001\000\000\000\000\000\000\016\004\000\000\087\001\
\088\001\000\000\094\001\000\000\000\000\000\000\109\001\089\001\
\095\001\096\001\097\001\098\001\099\001\090\001\091\001\000\000\
\092\001\000\000\000\000\000\000\000\000\000\000\000\000\114\004\
\000\000\093\001\000\000\000\000\100\001\000\000\000\000\000\000\
\000\000\185\000\094\001\000\000\000\000\000\000\101\001\102\001\
\095\001\096\001\097\001\098\001\099\001\000\000\000\000\000\000\
\000\000\000\000\103\001\104\001\105\001\106\001\107\001\000\000\
\000\000\000\000\000\000\063\004\100\001\087\001\088\001\000\000\
\000\000\185\000\000\000\000\000\109\001\089\001\101\001\102\001\
\000\000\000\000\000\000\090\001\091\001\000\000\092\001\000\000\
\000\000\000\000\103\001\104\001\105\001\106\001\107\001\093\001\
\000\000\000\000\000\000\000\000\000\000\087\001\088\001\000\000\
\094\001\000\000\000\000\000\000\109\001\089\001\095\001\096\001\
\097\001\098\001\099\001\090\001\091\001\000\000\126\004\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\093\001\
\000\000\000\000\100\001\000\000\000\000\000\000\000\000\185\000\
\094\001\000\000\000\000\000\000\101\001\102\001\095\001\096\001\
\097\001\098\001\099\001\000\000\000\000\000\000\000\000\000\000\
\103\001\104\001\105\001\106\001\107\001\000\000\000\000\000\000\
\000\000\000\000\100\001\234\000\234\000\000\000\000\000\185\000\
\000\000\000\000\109\001\234\000\101\001\102\001\000\000\000\000\
\000\000\234\000\234\000\000\000\000\000\000\000\000\000\000\000\
\103\001\104\001\105\001\106\001\107\001\234\000\000\000\000\000\
\000\000\000\000\000\000\087\001\088\001\000\000\234\000\000\000\
\000\000\000\000\109\001\089\001\234\000\234\000\234\000\234\000\
\234\000\090\001\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\093\001\000\000\000\000\
\234\000\000\000\000\000\000\000\000\000\234\000\094\001\000\000\
\000\000\000\000\234\000\234\000\095\001\096\001\097\001\098\001\
\099\001\000\000\000\000\000\000\000\000\000\000\234\000\234\000\
\234\000\234\000\234\000\000\000\000\000\000\000\000\000\234\000\
\100\001\087\001\088\001\000\000\000\000\185\000\000\000\000\000\
\234\000\089\001\101\001\102\001\000\000\000\000\000\000\090\001\
\000\000\000\000\000\000\000\000\000\000\000\000\103\001\104\001\
\105\001\106\001\107\001\093\001\000\000\000\000\000\000\000\000\
\000\000\000\000\082\005\000\000\094\001\000\000\000\000\000\000\
\109\001\000\000\095\001\096\001\097\001\098\001\099\001\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\087\001\088\001\
\000\000\000\000\000\000\000\000\000\000\000\000\100\001\000\000\
\000\000\000\000\000\000\185\000\090\001\000\000\000\000\000\000\
\101\001\102\001\000\000\000\000\000\000\000\000\000\000\000\000\
\093\001\000\000\000\000\000\000\103\001\104\001\105\001\106\001\
\107\001\094\001\000\000\000\000\000\000\000\000\000\000\095\001\
\096\001\097\001\098\001\099\001\000\000\000\000\109\001\000\000\
\000\000\000\000\000\000\000\000\137\000\000\000\138\000\139\000\
\032\000\000\000\140\000\100\001\000\000\141\000\142\000\000\000\
\185\000\000\000\000\000\000\000\000\000\101\001\102\001\192\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\143\000\
\000\000\000\000\104\001\105\001\106\001\107\001\000\000\144\000\
\145\000\000\000\000\000\000\000\000\000\000\000\000\000\146\000\
\000\000\000\000\000\000\109\001\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\147\000\148\000"

let yycheck = "\003\000\
\004\000\094\000\006\000\002\000\146\000\002\000\062\001\015\000\
\131\001\163\000\137\000\014\002\143\000\164\000\033\001\010\000\
\137\000\186\002\192\001\029\000\158\000\013\003\139\000\009\002\
\209\000\009\000\178\001\213\000\012\000\097\003\127\003\031\000\
\036\000\171\000\143\001\019\000\020\000\021\000\022\000\086\002\
\011\000\055\003\243\002\027\000\186\002\012\002\212\000\014\002\
\166\004\001\000\034\000\003\000\004\000\002\000\038\000\209\000\
\012\004\028\000\033\000\043\000\044\000\232\000\037\000\234\000\
\003\000\004\000\111\001\002\000\052\000\007\000\000\000\055\000\
\059\000\000\000\147\004\000\000\002\000\048\000\012\002\132\000\
\014\002\134\000\073\004\031\001\098\000\138\004\139\004\095\000\
\003\000\002\000\140\001\188\004\001\000\210\000\066\004\017\001\
\110\000\049\000\002\000\098\000\002\000\098\000\085\004\067\001\
\197\000\001\002\002\002\059\000\065\001\000\000\015\001\110\000\
\083\000\110\000\085\000\086\000\064\001\000\001\037\001\015\002\
\248\003\000\001\052\001\007\001\004\001\067\001\130\000\122\000\
\008\001\151\004\140\000\010\001\096\001\090\001\000\001\015\001\
\023\004\154\004\018\001\005\000\049\000\183\001\000\001\185\001\
\000\001\137\000\065\001\000\001\007\001\098\000\145\000\134\004\
\000\001\117\001\096\001\000\001\000\001\114\001\172\003\000\001\
\000\001\110\000\067\001\098\000\036\004\000\001\150\000\074\002\
\000\001\017\001\010\001\078\002\098\000\000\001\096\001\110\000\
\128\000\018\005\130\000\008\001\132\000\094\003\134\000\069\001\
\110\000\098\000\000\001\067\001\192\000\128\000\174\000\130\000\
\196\000\132\000\098\000\134\000\098\000\110\000\212\003\213\003\
\000\001\000\001\174\004\187\000\000\001\046\005\110\000\211\000\
\110\000\067\001\185\000\186\000\065\001\096\001\008\002\130\000\
\000\001\188\000\000\001\210\004\065\001\065\001\000\001\076\002\
\162\000\132\002\067\001\165\000\166\000\124\001\114\001\215\000\
\142\001\065\001\217\004\115\001\014\001\093\001\096\001\009\000\
\178\000\179\000\012\000\009\005\227\004\111\001\007\005\218\000\
\096\001\019\000\020\000\021\000\022\000\139\003\094\001\096\001\
\017\005\027\000\111\001\117\001\000\001\096\001\214\000\079\001\
\136\004\094\001\111\001\111\001\038\000\096\001\208\000\067\001\
\061\002\043\000\044\000\190\001\117\001\094\005\004\001\111\001\
\094\001\118\001\052\000\120\001\045\005\055\000\024\001\000\001\
\004\001\067\001\065\001\066\001\008\001\093\001\093\001\000\000\
\000\001\097\001\097\001\015\001\096\001\022\001\018\001\190\004\
\032\001\214\000\159\002\222\001\000\002\224\001\014\001\093\001\
\096\001\017\001\003\001\097\001\191\001\065\001\096\001\000\001\
\022\001\183\005\208\001\038\001\000\001\162\001\000\001\075\001\
\067\001\064\005\078\001\206\001\219\004\004\001\030\001\031\001\
\111\001\008\001\000\001\133\002\134\002\102\005\069\005\058\001\
\015\001\000\001\000\001\018\001\074\001\000\001\081\001\067\001\
\026\001\093\001\250\002\083\001\117\005\097\001\074\001\010\001\
\108\001\080\001\036\002\000\001\112\001\000\001\005\002\103\004\
\064\001\107\001\068\001\015\001\166\002\170\001\128\001\172\001\
\173\005\174\001\032\002\021\002\069\004\094\001\071\004\255\004\
\026\002\081\001\030\001\145\001\154\005\119\003\092\001\026\001\
\096\001\055\003\010\005\084\004\067\001\183\002\067\001\115\001\
\051\003\093\002\145\001\077\002\145\001\000\001\000\001\165\004\
\000\001\067\001\125\001\126\001\093\001\129\005\129\001\115\005\
\131\001\047\004\094\001\147\001\094\001\022\001\066\001\000\001\
\000\001\000\001\027\001\000\001\018\001\111\001\027\003\093\001\
\063\005\010\001\000\001\010\001\000\001\000\001\096\001\093\001\
\176\001\096\001\073\005\094\001\017\001\000\001\097\001\183\001\
\003\001\185\001\178\001\181\003\145\001\244\003\008\001\128\002\
\000\001\000\001\043\005\096\001\018\001\037\001\017\001\089\002\
\108\001\193\001\145\001\111\001\065\003\035\001\008\001\207\001\
\028\005\037\001\170\001\145\001\172\001\015\001\174\001\190\003\
\191\003\008\001\036\001\211\001\136\002\243\004\128\002\170\001\
\145\001\172\001\000\001\174\001\030\001\221\001\060\001\126\005\
\150\002\145\001\093\001\145\001\066\001\000\001\096\001\239\004\
\096\001\233\001\146\003\185\003\000\001\000\001\172\003\010\001\
\190\003\191\003\203\004\112\003\054\001\094\001\032\001\094\001\
\097\001\097\001\097\001\096\001\252\001\253\001\000\001\124\003\
\066\001\001\002\002\002\094\001\012\002\097\001\014\002\132\003\
\094\001\163\002\104\001\000\001\094\001\096\001\000\001\015\002\
\008\001\111\001\177\005\022\001\020\002\047\002\212\003\213\003\
\096\001\096\001\028\004\000\001\008\001\015\001\018\001\014\001\
\000\002\191\004\034\002\015\001\246\001\247\001\248\001\094\001\
\194\002\242\002\108\001\210\002\254\001\111\001\066\001\067\001\
\195\002\196\002\030\001\188\003\232\002\027\001\006\001\008\001\
\094\001\018\001\092\001\059\002\066\001\052\002\008\001\027\001\
\064\002\065\001\066\001\094\001\074\001\098\005\097\001\097\002\
\242\002\023\004\028\002\094\001\096\001\023\003\112\001\000\001\
\100\002\067\001\098\002\099\002\209\003\016\001\066\001\018\001\
\018\001\022\001\036\001\093\001\246\002\067\001\000\001\018\001\
\099\001\100\001\018\001\013\003\054\002\022\001\094\001\022\001\
\093\001\174\002\027\001\061\002\096\001\096\002\096\001\019\001\
\008\001\096\001\117\001\014\001\022\001\137\002\138\002\015\001\
\093\001\027\001\000\001\073\004\153\005\093\002\126\002\081\002\
\108\001\030\001\042\004\111\001\096\001\014\004\030\001\096\001\
\014\001\019\002\040\005\047\001\042\005\094\001\094\001\117\001\
\090\003\018\001\157\002\000\000\094\001\014\001\018\001\151\002\
\097\003\061\001\018\001\056\001\087\003\088\003\089\003\092\001\
\018\001\069\001\188\002\071\001\094\001\066\001\035\004\066\001\
\067\001\115\003\066\001\053\002\093\001\096\001\094\001\183\002\
\097\001\022\001\099\001\100\001\099\001\100\001\004\001\097\003\
\066\002\067\002\063\003\093\001\066\001\067\001\201\002\097\001\
\022\001\099\001\100\001\027\001\117\001\096\001\023\001\076\003\
\235\003\220\004\237\003\238\003\027\001\113\001\174\002\108\001\
\003\001\027\001\111\001\117\001\108\001\233\002\234\002\111\001\
\081\001\022\001\096\001\174\002\000\001\094\001\222\002\096\001\
\224\002\027\001\226\002\227\002\096\001\027\001\094\001\165\004\
\096\001\164\003\008\001\255\002\066\001\220\004\096\001\019\001\
\190\004\015\001\023\001\188\003\067\001\067\001\026\001\092\001\
\012\003\136\003\250\002\153\003\027\001\207\002\254\002\008\001\
\030\001\211\002\149\003\019\001\210\004\066\001\015\001\192\005\
\096\001\090\001\096\001\047\001\048\001\219\004\220\004\015\003\
\017\001\059\002\188\003\027\001\003\001\030\001\096\001\008\001\
\054\001\061\001\164\002\000\001\065\001\231\003\066\001\002\001\
\032\003\069\001\192\005\071\001\066\001\000\001\096\001\110\001\
\004\001\003\001\096\001\114\001\008\001\019\001\036\001\047\003\
\048\003\003\003\014\001\015\001\068\001\243\004\018\001\193\002\
\019\001\066\001\058\003\074\003\060\003\074\003\008\001\026\001\
\084\003\096\001\067\001\067\003\068\003\014\004\081\003\071\003\
\092\003\047\001\048\001\095\003\014\001\113\001\108\001\217\002\
\119\003\111\001\014\001\068\001\047\001\048\001\067\001\061\001\
\096\001\027\001\229\004\014\001\065\001\066\001\063\001\069\001\
\067\001\071\001\061\001\108\001\014\004\013\005\111\001\067\001\
\027\001\068\001\069\001\097\001\071\001\067\001\068\001\000\000\
\000\001\063\005\064\005\014\001\004\001\065\001\029\004\000\000\
\008\001\003\001\068\001\073\005\014\001\125\003\014\001\015\001\
\136\003\035\001\018\001\131\003\096\001\144\003\066\001\067\001\
\117\001\027\001\083\004\113\001\051\004\098\001\181\003\081\001\
\003\001\093\001\146\003\000\001\065\001\066\001\113\001\004\001\
\152\003\161\003\060\001\008\001\065\001\010\001\081\001\117\001\
\066\001\014\001\015\001\163\003\055\004\018\001\166\003\066\001\
\015\001\083\004\114\001\018\001\183\003\027\001\027\001\175\003\
\126\005\098\001\022\001\067\001\092\005\000\000\069\004\191\003\
\082\004\205\003\206\003\012\001\069\004\103\004\014\001\081\001\
\104\005\045\001\046\001\112\001\094\004\197\003\104\001\219\003\
\181\005\182\005\111\001\027\001\008\001\111\001\031\001\113\001\
\096\001\065\001\210\003\155\001\094\003\067\001\067\001\215\003\
\236\003\171\003\186\003\101\003\067\001\074\001\066\001\013\001\
\049\001\050\001\051\001\177\005\000\001\229\003\065\001\093\001\
\003\001\085\001\065\001\097\001\092\001\218\005\028\001\029\001\
\093\001\094\001\066\001\096\001\097\001\076\001\010\004\072\001\
\160\005\161\005\102\001\041\001\077\001\207\003\026\001\111\001\
\004\001\001\004\000\000\029\004\008\001\086\001\115\001\014\001\
\099\001\027\001\005\000\011\004\007\000\040\001\018\001\061\001\
\067\001\227\003\064\001\091\005\111\001\222\004\103\001\069\001\
\024\004\025\004\194\005\114\001\023\000\075\001\004\001\000\001\
\032\004\243\003\008\001\065\001\082\001\048\004\038\004\096\001\
\065\001\015\001\042\004\035\001\018\001\096\001\000\001\022\001\
\216\005\067\001\019\001\056\001\222\004\027\001\111\001\060\001\
\010\001\026\001\027\001\059\004\065\001\069\004\230\005\067\001\
\110\001\000\000\117\001\092\001\060\001\239\004\074\001\014\001\
\065\001\090\001\066\001\080\001\065\001\077\004\047\001\048\001\
\065\001\111\001\102\004\028\005\027\001\105\004\111\001\112\001\
\226\003\089\004\094\001\066\001\061\001\067\001\232\003\065\001\
\234\003\114\001\065\001\068\001\069\001\096\000\071\001\090\004\
\124\004\125\004\111\001\065\001\246\003\065\001\000\000\000\001\
\104\001\022\001\028\005\115\004\031\001\085\004\111\001\111\001\
\144\004\027\001\111\001\066\001\013\001\092\001\111\001\112\001\
\128\004\099\001\130\004\131\004\132\004\157\004\049\001\050\001\
\051\001\026\001\027\001\028\001\029\001\111\001\137\000\088\005\
\113\001\112\001\065\001\142\000\143\000\149\004\000\001\171\004\
\041\001\111\001\056\001\111\001\027\001\065\001\022\001\068\001\
\058\005\067\001\077\001\065\001\188\004\065\001\134\004\162\000\
\163\000\071\005\165\000\166\000\061\001\168\000\088\005\064\001\
\026\001\065\001\067\001\068\001\069\001\000\001\000\001\178\000\
\179\000\004\001\075\001\187\004\065\001\008\001\004\001\010\001\
\111\001\082\001\008\001\014\001\067\001\031\001\065\001\018\001\
\014\001\015\001\066\001\111\001\018\001\094\001\206\004\096\001\
\027\001\098\001\099\001\111\001\220\004\208\000\209\000\049\001\
\050\001\051\001\213\000\037\001\240\004\110\001\104\004\111\001\
\113\001\225\004\108\004\065\001\117\001\102\001\000\005\027\001\
\035\001\003\005\234\004\005\005\004\001\004\001\238\004\027\001\
\008\001\008\001\229\004\077\001\111\001\022\001\200\004\015\001\
\016\005\217\004\018\001\018\001\252\004\067\001\065\001\074\001\
\065\001\060\001\000\001\227\004\065\001\066\001\004\001\066\001\
\008\005\147\004\008\001\072\001\010\001\013\005\027\001\067\001\
\014\001\111\001\093\001\094\001\044\005\096\001\097\001\067\001\
\004\001\086\001\000\000\027\005\008\001\027\001\168\004\092\001\
\032\005\066\001\000\001\015\001\000\001\096\001\018\001\065\001\
\115\001\022\001\035\001\067\001\111\001\104\001\111\001\062\005\
\114\001\062\005\111\001\112\001\111\001\053\005\067\001\000\001\
\075\001\052\001\078\005\059\005\086\005\087\005\026\001\172\005\
\090\005\065\005\003\001\060\001\054\001\095\005\056\001\037\001\
\065\001\066\001\212\004\067\001\074\001\077\005\013\001\065\001\
\066\001\026\001\075\001\083\005\067\001\111\001\018\001\067\001\
\000\001\081\001\110\005\110\001\092\005\028\001\029\001\093\001\
\094\001\072\001\096\001\097\001\100\005\069\005\085\001\040\001\
\104\005\131\005\041\001\019\001\101\001\109\005\000\000\086\001\
\250\004\000\001\026\001\027\001\111\001\115\001\111\001\022\001\
\000\001\121\005\092\001\013\001\027\001\111\001\061\001\000\001\
\111\001\064\001\150\005\090\001\014\005\067\001\069\001\047\001\
\048\001\137\005\028\001\029\001\075\001\023\001\112\001\163\005\
\026\005\171\005\026\001\082\001\143\001\061\001\037\001\041\001\
\000\001\026\001\036\001\114\001\068\001\069\001\023\001\071\001\
\160\005\161\005\004\001\098\001\099\001\056\001\008\001\096\001\
\168\005\051\005\190\005\061\001\033\001\015\001\064\001\110\001\
\018\001\203\005\204\005\069\001\000\001\176\001\067\001\065\001\
\184\005\075\001\014\001\187\005\183\001\037\001\185\001\211\005\
\082\001\193\005\194\005\056\001\191\001\000\001\066\001\060\001\
\085\001\113\001\000\001\064\001\065\001\066\001\026\001\065\001\
\098\001\099\001\000\001\206\001\207\001\213\005\234\005\227\003\
\216\005\212\001\076\001\080\001\110\001\221\005\022\001\026\001\
\224\005\067\001\000\000\097\001\026\001\229\005\230\005\243\003\
\232\005\233\005\066\001\093\001\026\001\099\001\100\001\027\001\
\072\001\097\001\000\001\066\001\027\001\054\001\128\005\056\001\
\000\001\072\001\111\001\246\001\247\001\248\001\086\001\117\001\
\065\001\066\001\004\001\254\001\018\001\033\001\008\001\086\001\
\146\005\014\001\148\005\019\001\017\001\015\001\097\001\000\000\
\018\001\012\002\026\001\014\002\158\005\022\001\027\001\065\001\
\019\002\027\001\021\002\022\002\056\001\022\001\000\001\026\002\
\060\001\028\002\076\001\095\001\064\001\065\001\066\001\047\001\
\048\001\036\002\111\001\181\005\182\005\000\001\111\001\040\001\
\096\001\019\001\188\005\016\001\080\001\061\001\095\001\010\001\
\026\001\066\001\053\002\054\002\068\001\069\001\027\001\071\001\
\111\001\067\001\061\002\205\005\066\001\110\001\111\001\066\002\
\067\002\003\001\212\005\000\001\074\001\047\001\048\001\067\001\
\218\005\076\002\077\002\111\001\222\005\010\001\081\002\075\001\
\111\001\227\005\228\005\061\001\004\001\096\001\082\001\110\001\
\008\001\085\001\068\001\069\001\041\002\071\001\065\001\015\001\
\045\002\113\001\018\001\065\001\111\001\112\001\000\001\001\001\
\002\001\003\001\000\001\027\001\065\001\066\001\008\001\009\001\
\010\001\111\001\008\001\013\001\014\001\014\001\016\001\017\001\
\018\001\019\001\020\001\021\001\000\000\128\002\024\001\025\001\
\026\001\027\001\028\001\029\001\066\001\067\001\068\001\113\001\
\095\001\111\001\036\001\037\001\065\001\066\001\040\001\041\001\
\042\001\043\001\094\001\067\001\008\001\047\001\048\001\110\001\
\111\001\066\001\067\001\000\001\159\002\067\001\068\001\000\001\
\014\001\164\002\036\001\061\001\062\001\097\001\064\001\024\002\
\025\002\067\001\068\001\069\001\074\001\071\001\019\001\014\001\
\074\001\075\001\019\001\022\001\183\002\026\001\111\001\186\002\
\082\001\026\001\084\001\092\001\022\001\027\001\193\002\000\001\
\195\002\196\002\097\001\093\001\094\001\097\001\096\001\097\001\
\098\001\099\001\047\001\048\001\207\002\096\001\047\001\105\001\
\211\002\107\001\019\001\000\001\110\001\065\001\217\002\113\001\
\061\001\026\001\000\001\117\001\061\001\003\001\000\000\068\001\
\069\001\111\001\071\001\068\001\069\001\105\001\071\001\013\001\
\014\001\094\001\111\001\094\001\066\001\094\001\047\001\242\002\
\243\002\096\001\117\001\027\001\026\001\027\001\028\001\029\001\
\117\001\020\001\046\001\014\001\061\001\065\001\022\001\063\001\
\003\003\081\001\040\001\041\001\069\001\065\001\071\001\000\001\
\011\003\014\001\013\003\004\001\113\001\014\001\022\001\008\001\
\113\001\010\001\002\001\074\001\023\003\014\001\015\001\061\001\
\027\003\018\001\064\001\076\000\066\001\067\001\068\001\069\001\
\117\001\096\001\027\001\074\001\102\001\075\001\054\001\055\001\
\056\001\057\001\015\001\000\000\082\001\066\001\094\001\065\001\
\113\001\065\001\066\001\092\001\074\001\102\001\096\001\065\001\
\094\001\094\001\096\001\108\000\098\001\099\001\065\003\065\001\
\008\001\014\001\000\001\027\001\088\001\027\001\027\001\030\001\
\110\001\065\001\067\001\113\001\065\001\126\000\014\001\117\001\
\094\001\074\001\111\001\003\001\133\000\019\001\000\000\090\003\
\014\001\088\001\049\001\094\003\026\001\096\003\097\003\111\001\
\065\001\006\001\101\003\110\001\093\001\094\001\074\001\096\001\
\097\001\111\001\065\001\066\001\027\001\112\003\097\001\096\001\
\115\003\047\001\048\001\103\001\027\001\014\001\096\001\065\001\
\096\001\124\003\115\001\040\001\000\001\090\001\021\001\061\001\
\004\001\132\003\065\001\027\001\008\001\136\003\010\001\069\001\
\139\003\071\001\014\001\015\001\065\001\063\001\063\001\016\001\
\103\001\013\001\149\003\063\001\014\001\108\001\003\001\027\001\
\111\001\054\001\055\001\056\001\057\001\014\001\161\003\066\001\
\028\001\029\001\065\001\027\001\065\001\066\001\215\000\096\001\
\171\003\074\001\102\001\054\001\096\001\041\001\074\001\008\001\
\022\001\000\000\096\001\113\001\016\001\096\001\185\003\186\003\
\076\001\188\003\076\001\190\003\191\003\027\001\096\001\067\001\
\007\000\061\001\074\001\027\001\014\001\020\001\074\001\090\001\
\000\001\069\001\114\001\096\001\207\003\074\001\209\003\075\001\
\023\000\096\001\111\001\065\001\114\001\028\000\082\001\014\001\
\093\001\093\001\094\001\019\001\096\001\097\001\000\001\226\003\
\227\003\003\001\026\001\074\001\231\003\232\003\098\001\234\003\
\021\001\014\001\014\001\013\001\014\001\014\001\014\001\115\001\
\243\003\027\001\110\001\246\003\019\001\113\001\090\001\047\001\
\026\001\027\001\028\001\029\001\001\000\002\000\003\000\004\000\
\005\000\006\000\007\000\114\001\014\001\061\001\040\001\041\001\
\027\001\093\001\014\001\014\004\068\001\069\001\022\001\071\001\
\015\001\014\001\000\000\014\001\023\004\097\001\000\000\000\000\
\111\001\098\001\098\001\061\001\094\001\111\001\064\001\008\001\
\035\004\082\001\068\001\069\001\065\001\094\001\036\001\092\001\
\036\001\075\001\094\001\000\001\047\004\044\001\045\001\046\001\
\082\001\096\001\074\001\008\001\055\004\054\001\065\001\022\001\
\013\001\113\001\065\001\065\001\094\001\054\001\096\001\066\004\
\098\001\099\001\069\004\093\001\071\004\026\001\073\004\028\001\
\029\001\072\001\073\001\146\000\110\001\065\001\065\001\113\001\
\083\004\084\004\085\004\117\001\041\001\065\001\085\001\086\001\
\087\001\088\001\065\001\162\000\163\000\164\000\165\000\166\000\
\065\001\168\000\147\001\013\001\103\004\104\004\128\000\102\001\
\061\001\108\004\028\004\178\000\179\000\222\004\067\001\068\001\
\069\001\090\004\028\001\029\001\086\004\142\001\075\001\128\005\
\088\005\056\005\171\001\199\003\009\003\082\001\056\001\041\001\
\058\001\059\001\060\001\134\004\062\001\096\002\164\001\065\001\
\066\001\208\000\209\000\130\001\255\001\098\001\213\000\146\004\
\147\004\097\002\207\003\061\001\061\002\210\002\064\001\166\000\
\098\004\110\001\099\000\069\001\113\001\102\003\192\005\188\004\
\031\004\075\001\092\001\018\005\207\001\168\004\255\255\000\000\
\082\001\099\001\198\004\174\004\007\000\188\002\255\255\255\255\
\011\000\000\001\255\255\255\255\003\001\111\001\112\001\255\255\
\098\001\099\001\255\255\190\004\191\004\255\255\013\001\255\255\
\255\255\028\000\017\001\255\255\110\001\200\004\255\255\022\001\
\203\004\255\255\255\255\026\001\027\001\028\001\029\001\210\004\
\255\255\212\004\255\255\255\255\255\255\048\000\217\004\255\255\
\219\004\220\004\041\001\222\004\255\255\255\255\255\255\255\255\
\227\004\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\239\004\052\001\061\001\255\255\
\255\255\064\001\255\255\066\001\067\001\068\001\069\001\250\004\
\083\000\255\255\085\000\086\000\075\001\255\255\069\001\255\255\
\255\255\072\001\255\255\082\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\014\005\255\255\255\255\255\255\094\001\
\255\255\096\001\000\001\098\001\099\001\255\255\004\001\026\005\
\255\255\028\005\008\001\255\255\010\001\255\255\079\002\110\001\
\014\001\000\001\113\001\084\002\018\001\040\005\117\001\042\005\
\111\001\255\255\255\255\255\255\255\255\027\001\255\255\255\255\
\051\005\255\255\255\255\255\255\019\001\124\001\255\255\000\000\
\255\255\255\255\255\255\026\001\063\005\064\005\255\255\255\255\
\255\255\255\255\069\005\255\255\255\255\255\255\073\005\162\000\
\163\000\255\255\165\000\166\000\255\255\168\000\127\002\255\255\
\047\001\048\001\255\255\255\255\255\255\088\005\255\255\178\000\
\179\000\255\255\255\255\255\255\074\001\164\001\061\001\255\255\
\255\255\188\000\255\255\255\255\255\255\255\255\069\001\255\255\
\071\001\255\255\255\255\255\255\255\255\255\255\255\255\093\001\
\094\001\162\002\096\001\097\001\255\255\208\000\209\000\255\255\
\255\255\255\255\255\255\126\005\255\255\128\005\129\005\218\000\
\255\255\255\255\255\255\255\255\255\255\115\001\255\255\255\255\
\255\255\208\001\255\255\255\255\255\255\212\001\255\255\146\005\
\255\255\148\005\113\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\158\005\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\000\001\
\255\255\255\255\003\001\255\255\255\255\255\255\177\005\246\001\
\247\001\248\001\181\005\182\005\013\001\255\255\255\255\254\001\
\255\255\188\005\000\001\255\255\255\255\192\005\005\002\255\255\
\255\255\026\001\027\001\028\001\029\001\255\255\013\002\255\255\
\255\255\000\000\205\005\038\001\253\002\019\001\021\002\022\002\
\041\001\212\005\255\255\026\002\026\001\028\002\255\255\218\005\
\255\255\255\255\255\255\222\005\255\255\036\002\255\255\058\001\
\227\005\228\005\041\002\255\255\061\001\255\255\045\002\255\255\
\255\255\047\001\255\255\068\001\069\001\255\255\255\255\054\002\
\000\000\255\255\075\001\255\255\255\255\255\255\061\002\061\001\
\006\001\082\001\008\001\255\255\255\255\255\255\068\001\069\001\
\255\255\071\001\255\255\255\255\053\003\255\255\077\002\096\001\
\255\255\098\001\081\002\255\255\255\255\255\255\255\255\064\003\
\255\255\066\003\255\255\255\255\111\001\110\001\255\255\255\255\
\113\001\096\002\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\125\001\126\001\255\255\255\255\129\001\255\255\
\131\001\255\255\056\001\113\001\058\001\059\001\060\001\255\255\
\062\001\255\255\255\255\065\001\066\001\255\255\103\003\000\001\
\255\255\128\002\003\001\255\255\255\255\255\255\255\255\008\001\
\255\255\010\001\255\255\255\255\013\001\014\001\255\255\016\001\
\017\001\018\001\019\001\020\001\021\001\126\003\092\001\024\001\
\025\001\026\001\131\003\028\001\029\001\099\001\255\255\255\255\
\255\255\160\002\255\255\255\255\037\001\255\255\255\255\040\001\
\041\001\111\001\112\001\255\255\255\255\255\255\047\001\048\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\000\000\255\255\255\255\061\001\255\255\255\255\064\001\
\255\255\212\001\255\255\068\001\069\001\255\255\071\001\255\255\
\255\255\074\001\075\001\255\255\255\255\255\255\255\255\255\255\
\207\002\082\001\187\003\210\002\211\002\255\255\255\255\192\003\
\255\255\255\255\255\255\255\255\093\001\094\001\255\255\096\001\
\097\001\098\001\099\001\246\001\247\001\248\001\255\255\255\255\
\105\001\255\255\107\001\254\001\255\255\110\001\255\255\255\255\
\113\001\255\255\255\255\242\002\117\001\255\255\255\255\255\255\
\255\255\255\255\013\002\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\021\002\022\002\003\003\255\255\239\003\026\002\
\255\255\028\002\255\255\255\255\011\003\255\255\013\003\255\255\
\255\255\000\001\000\001\255\255\255\255\255\255\255\255\255\255\
\023\003\255\255\255\255\255\255\255\255\255\255\013\001\255\255\
\255\255\255\255\000\000\054\002\255\255\019\001\255\255\255\255\
\255\255\255\255\061\002\026\001\026\001\028\001\029\001\255\255\
\255\255\255\255\255\255\255\255\255\255\052\003\255\255\032\004\
\000\001\255\255\041\001\255\255\004\001\038\004\081\002\255\255\
\008\001\047\001\010\001\255\255\255\255\255\255\014\001\255\255\
\255\255\255\255\018\001\255\255\255\255\096\002\061\001\061\001\
\255\255\064\001\255\255\027\001\255\255\255\255\069\001\069\001\
\255\255\071\001\255\255\090\003\075\001\255\255\255\255\255\255\
\255\255\096\003\097\003\082\001\255\255\255\255\255\255\007\000\
\255\255\255\255\255\255\011\000\255\255\128\002\255\255\094\001\
\255\255\255\255\255\255\098\001\115\003\255\255\255\255\118\003\
\255\255\255\255\099\004\067\001\028\000\255\255\255\255\110\001\
\255\255\255\255\074\001\113\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\048\000\255\255\255\255\255\255\255\255\093\001\094\001\255\255\
\096\001\097\001\153\003\255\255\133\004\255\255\135\004\255\255\
\137\004\255\255\255\255\140\004\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\115\001\171\003\255\255\255\255\255\255\
\255\255\255\255\155\004\083\000\255\255\085\000\086\000\255\255\
\255\255\000\001\255\255\186\003\207\002\188\003\255\255\255\255\
\211\002\255\255\255\255\172\004\173\004\255\255\013\001\255\255\
\056\001\178\004\058\001\059\001\060\001\255\255\062\001\255\255\
\207\003\065\001\066\001\026\001\255\255\028\001\029\001\255\255\
\255\255\255\255\255\255\000\000\255\255\255\255\255\255\242\002\
\080\001\255\255\041\001\083\001\227\003\206\004\255\255\255\255\
\231\003\137\000\255\255\091\001\092\001\255\255\255\255\255\255\
\003\003\255\255\255\255\099\001\243\003\255\255\061\001\255\255\
\011\003\255\255\013\003\255\255\067\001\068\001\069\001\111\001\
\112\001\255\255\162\000\163\000\075\001\165\000\166\000\255\255\
\168\000\255\255\255\255\082\001\007\000\255\255\255\255\014\004\
\255\255\255\255\178\000\179\000\255\255\016\000\255\255\255\255\
\255\255\255\255\255\255\098\001\188\000\255\255\029\004\255\255\
\255\255\255\255\000\001\255\255\255\255\003\001\255\255\110\001\
\255\255\018\005\113\001\255\255\255\255\255\255\255\255\013\001\
\208\000\209\000\255\255\017\001\051\004\255\255\255\255\032\005\
\022\001\255\255\218\000\255\255\026\001\027\001\028\001\029\001\
\000\000\255\255\255\255\255\255\255\255\046\005\255\255\255\255\
\049\005\255\255\255\255\041\001\255\255\096\003\097\003\255\255\
\255\255\255\255\255\255\000\001\083\004\255\255\085\004\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\061\001\
\255\255\255\255\064\001\255\255\066\001\067\001\068\001\069\001\
\103\004\100\000\255\255\255\255\085\005\075\001\255\255\255\255\
\255\255\255\255\255\255\255\255\082\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\000\000\
\094\001\255\255\096\001\255\255\098\001\099\001\038\001\134\004\
\255\255\255\255\255\255\056\001\255\255\058\001\059\001\060\001\
\110\001\062\001\096\000\113\001\065\001\066\001\255\255\117\001\
\171\003\255\255\058\001\132\005\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\083\001\162\000\
\163\000\188\003\165\000\166\000\255\255\168\000\091\001\092\001\
\255\255\255\255\255\255\255\255\255\255\255\255\099\001\178\000\
\179\000\255\255\255\255\255\255\207\003\255\255\167\005\168\005\
\255\255\110\001\111\001\112\001\007\000\255\255\175\005\000\001\
\255\255\200\004\255\255\255\255\255\255\255\255\255\255\111\001\
\227\003\255\255\255\255\255\255\255\255\208\000\209\000\013\001\
\255\255\255\255\217\004\000\001\255\255\125\001\126\001\222\004\
\243\003\129\001\255\255\131\001\227\004\255\255\028\001\029\001\
\013\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\239\004\255\255\255\255\041\001\255\255\026\001\255\255\028\001\
\029\001\226\005\255\255\014\004\255\255\255\255\255\255\056\001\
\255\255\058\001\059\001\060\001\041\001\062\001\255\255\061\001\
\065\001\066\001\064\001\255\255\000\000\255\255\255\255\069\001\
\176\001\255\255\255\255\255\255\255\255\075\001\255\255\183\001\
\061\001\185\001\083\001\064\001\082\001\028\005\255\255\068\001\
\069\001\255\255\091\001\092\001\255\255\255\255\075\001\255\255\
\255\255\255\255\099\001\255\255\098\001\082\001\255\255\255\255\
\255\255\255\255\255\255\255\255\212\001\255\255\111\001\112\001\
\110\001\094\001\255\255\255\255\255\255\098\001\099\001\255\255\
\083\004\255\255\255\255\255\255\255\255\255\255\069\005\090\004\
\071\005\110\001\255\255\255\255\113\001\013\001\255\255\255\255\
\255\255\255\255\255\255\255\255\103\004\255\255\246\001\247\001\
\248\001\088\005\255\255\086\001\028\001\029\001\254\001\162\000\
\163\000\255\255\165\000\166\000\255\255\168\000\255\255\255\255\
\103\005\041\001\255\255\255\255\255\255\255\255\255\255\178\000\
\179\000\255\255\255\255\000\000\111\001\021\002\022\002\255\255\
\255\255\255\255\026\002\255\255\028\002\061\001\006\001\000\001\
\064\001\255\255\003\001\255\255\255\255\069\001\255\255\255\255\
\255\255\255\255\255\255\075\001\013\001\208\000\209\000\255\255\
\255\255\255\255\082\001\255\255\255\255\255\255\054\002\255\255\
\255\255\026\001\027\001\028\001\029\001\061\002\255\255\255\255\
\159\005\255\255\098\001\099\001\255\255\255\255\255\255\255\255\
\041\001\255\255\255\255\255\255\255\255\255\255\110\001\255\255\
\056\001\081\002\058\001\059\001\060\001\200\004\062\001\255\255\
\255\255\065\001\066\001\255\255\061\001\255\255\255\255\064\001\
\096\002\143\001\067\001\068\001\069\001\255\255\255\255\255\255\
\255\255\255\255\075\001\222\004\255\255\015\001\255\255\255\255\
\255\255\082\001\229\004\255\255\092\001\255\255\255\255\255\255\
\255\255\212\001\255\255\099\001\239\004\094\001\255\255\096\001\
\128\002\098\001\099\001\255\255\255\255\255\255\255\255\111\001\
\112\001\043\001\044\001\045\001\046\001\110\001\255\255\255\255\
\113\001\255\255\192\001\255\255\117\001\255\255\255\255\255\255\
\255\255\255\255\245\001\246\001\247\001\248\001\204\001\255\255\
\255\255\067\001\255\255\254\001\255\255\000\001\072\001\073\001\
\255\255\028\005\255\255\255\255\000\001\255\255\255\255\003\001\
\255\255\255\255\255\255\085\001\086\001\087\001\088\001\183\002\
\000\000\013\001\021\002\022\002\255\255\255\255\255\255\026\002\
\255\255\028\002\255\255\255\255\102\001\255\255\026\001\027\001\
\028\001\029\001\255\255\255\255\111\001\040\002\255\255\207\002\
\255\255\255\255\255\255\211\002\255\255\041\001\255\255\255\255\
\255\255\255\255\255\255\054\002\255\255\056\001\255\255\058\001\
\059\001\060\001\061\002\062\001\255\255\088\005\065\001\066\001\
\255\255\061\001\255\255\255\255\064\001\255\255\255\255\067\001\
\068\001\069\001\242\002\255\255\103\005\255\255\081\002\075\001\
\083\001\255\255\255\255\000\000\255\255\255\255\082\001\255\255\
\091\001\092\001\255\255\003\003\255\255\255\255\255\255\255\255\
\099\001\255\255\094\001\011\003\096\001\013\003\098\001\099\001\
\255\255\006\001\255\255\000\001\111\001\112\001\255\255\255\255\
\255\255\255\255\110\001\255\255\255\255\113\001\076\002\255\255\
\013\001\117\001\255\255\255\255\255\255\128\002\255\255\255\255\
\255\255\255\255\255\255\255\255\159\005\026\001\255\255\028\001\
\029\001\212\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\041\001\255\255\255\255\255\255\
\255\255\255\255\255\255\056\001\255\255\058\001\059\001\060\001\
\000\000\062\001\255\255\255\255\065\001\066\001\255\255\255\255\
\061\001\255\255\255\255\246\001\247\001\248\001\255\255\068\001\
\069\001\255\255\255\255\254\001\255\001\255\255\075\001\255\255\
\096\003\097\003\255\255\255\255\255\255\082\001\255\255\092\001\
\255\255\255\255\255\255\000\001\255\255\255\255\099\001\255\255\
\255\255\159\002\021\002\022\002\207\002\098\001\255\255\026\002\
\211\002\028\002\111\001\112\001\255\255\255\255\255\255\255\255\
\255\255\110\001\255\255\255\255\113\001\255\255\255\255\255\255\
\136\003\255\255\255\255\255\255\255\255\141\003\255\255\255\255\
\030\000\031\000\255\255\054\002\255\255\255\255\255\255\242\002\
\255\255\255\255\061\002\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\056\001\255\255\058\001\059\001\060\001\
\003\003\062\001\255\255\171\003\065\001\066\001\081\002\255\255\
\011\003\255\255\013\003\255\255\255\255\255\255\255\255\255\255\
\000\001\255\255\255\255\003\001\188\003\255\255\083\001\255\255\
\255\255\255\255\255\255\255\255\255\255\013\001\091\001\092\001\
\255\255\087\000\088\000\255\255\255\255\255\255\099\001\207\003\
\255\255\255\255\026\001\255\255\028\001\029\001\255\255\255\255\
\255\255\255\255\111\001\112\001\255\255\128\002\255\255\255\255\
\255\255\041\001\255\255\227\003\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\027\003\255\255\255\255\
\255\255\255\255\255\255\243\003\000\000\061\001\255\255\255\255\
\255\255\255\255\255\255\000\001\255\255\069\001\003\001\255\255\
\255\255\255\255\255\255\075\001\255\255\096\003\097\003\255\255\
\013\001\055\003\082\001\255\255\255\255\255\255\014\004\255\255\
\255\255\255\255\255\255\065\003\255\255\026\001\027\001\028\001\
\029\001\255\255\098\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\041\001\255\255\110\001\255\255\
\255\255\113\001\255\255\134\003\207\002\045\004\255\255\255\255\
\211\002\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\061\001\255\255\255\255\064\001\255\255\255\255\067\001\068\001\
\069\001\255\255\112\003\255\255\255\255\069\004\075\001\006\001\
\000\001\008\001\255\255\255\255\255\255\082\001\124\003\242\002\
\171\003\255\255\255\255\083\004\255\255\013\001\132\003\255\255\
\255\255\094\001\090\004\096\001\255\255\098\001\099\001\255\255\
\003\003\188\003\026\001\255\255\028\001\029\001\255\255\103\004\
\011\003\110\001\013\003\255\255\113\001\255\255\255\255\255\255\
\117\001\041\001\255\255\255\255\207\003\255\255\255\255\255\255\
\255\255\056\001\255\255\058\001\059\001\060\001\172\003\062\001\
\255\255\255\255\065\001\066\001\255\255\061\001\255\255\255\255\
\227\003\255\255\255\255\185\003\255\255\069\001\255\255\255\255\
\255\255\255\255\255\255\075\001\083\001\255\255\255\255\255\255\
\243\003\255\255\082\001\255\255\091\001\092\001\000\000\255\255\
\255\255\255\255\255\255\209\003\099\001\255\255\212\003\213\003\
\255\255\255\255\098\001\255\255\255\255\255\255\255\255\255\255\
\111\001\112\001\255\255\014\004\255\255\255\255\110\001\255\255\
\255\255\113\001\255\255\255\255\255\255\096\003\097\003\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\200\004\087\001\088\001\089\001\090\001\091\001\092\001\093\001\
\094\001\095\001\096\001\097\001\098\001\099\001\100\001\101\001\
\102\001\103\001\104\001\105\001\106\001\107\001\222\004\109\001\
\255\255\255\255\255\255\255\255\255\255\229\004\255\255\255\255\
\255\255\023\004\255\255\255\255\255\255\123\001\255\255\239\004\
\255\255\255\255\255\255\255\255\000\001\035\004\002\001\003\001\
\083\004\135\001\255\255\255\255\008\001\255\255\255\255\255\255\
\255\255\013\001\255\255\255\255\255\255\017\001\018\001\019\001\
\171\003\255\255\255\255\255\255\103\004\255\255\026\001\027\001\
\028\001\029\001\255\255\255\255\066\004\255\255\255\255\255\255\
\036\001\188\003\255\255\255\255\028\005\041\001\255\255\255\255\
\255\255\255\255\255\255\047\001\048\001\255\255\255\255\255\255\
\255\255\000\000\255\255\255\255\207\003\255\255\255\255\255\255\
\255\255\061\001\255\255\255\255\064\001\255\255\255\255\067\001\
\068\001\069\001\255\255\071\001\255\255\255\255\255\255\075\001\
\227\003\255\255\255\255\255\255\255\255\255\255\082\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\243\003\093\001\094\001\255\255\096\001\097\001\098\001\099\001\
\088\005\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\110\001\255\255\255\255\113\001\255\255\255\255\
\255\255\117\001\255\255\014\004\255\255\200\004\255\255\255\255\
\255\255\255\255\056\001\255\255\058\001\059\001\060\001\165\004\
\062\001\255\255\255\255\065\001\066\001\255\255\255\255\255\255\
\174\004\255\255\255\255\222\004\255\255\179\004\180\004\255\255\
\255\255\255\255\255\255\255\255\255\255\083\001\255\255\255\255\
\190\004\255\255\255\255\033\002\239\004\091\001\092\001\255\255\
\255\255\255\255\255\255\255\255\042\002\099\001\000\001\255\255\
\046\002\003\001\255\255\049\002\255\255\255\255\008\001\255\255\
\010\001\111\001\112\001\013\001\014\001\219\004\255\255\017\001\
\083\004\019\001\020\001\021\001\255\255\255\255\024\001\025\001\
\026\001\000\000\028\001\029\001\255\255\255\255\255\255\255\255\
\255\255\028\005\255\255\037\001\103\004\243\004\040\001\041\001\
\255\255\255\255\255\255\255\255\255\255\047\001\048\001\255\255\
\255\255\255\255\255\255\255\255\098\002\099\002\255\255\255\255\
\255\255\255\255\255\255\061\001\255\255\255\255\064\001\255\255\
\255\255\255\255\068\001\069\001\255\255\071\001\255\255\255\255\
\074\001\075\001\255\255\255\255\255\255\255\255\255\255\255\255\
\082\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\136\002\093\001\094\001\088\005\096\001\097\001\
\098\001\099\001\255\255\255\255\255\255\255\255\255\255\105\001\
\255\255\107\001\056\005\255\255\110\001\255\255\255\255\113\001\
\255\255\063\005\255\255\117\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\073\005\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\056\001\200\004\058\001\059\001\
\060\001\000\001\062\001\255\255\003\001\065\001\066\001\255\255\
\255\255\008\001\255\255\010\001\255\255\000\000\013\001\014\001\
\255\255\255\255\017\001\222\004\019\001\020\001\021\001\083\001\
\255\255\024\001\025\001\026\001\255\255\028\001\029\001\091\001\
\092\001\255\255\255\255\255\255\239\004\255\255\037\001\099\001\
\126\005\040\001\041\001\129\005\255\255\255\255\255\255\255\255\
\047\001\048\001\232\002\111\001\112\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\061\001\255\255\
\255\255\064\001\255\255\255\255\255\255\068\001\069\001\255\255\
\071\001\255\255\255\255\074\001\075\001\255\255\255\255\255\255\
\255\255\028\005\255\255\082\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\177\005\018\003\255\255\093\001\094\001\
\255\255\096\001\097\001\098\001\099\001\255\255\255\255\255\255\
\255\255\255\255\105\001\255\255\107\001\255\255\255\255\110\001\
\255\255\255\255\113\001\255\255\255\255\255\255\117\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\054\003\255\255\255\255\255\255\255\255\255\255\255\255\000\000\
\255\255\255\255\255\255\255\255\255\255\088\005\255\255\255\255\
\255\255\000\001\001\001\002\001\003\001\255\255\255\255\006\001\
\007\001\008\001\009\001\010\001\011\001\012\001\013\001\014\001\
\015\001\016\001\017\001\018\001\019\001\020\001\021\001\022\001\
\255\255\024\001\025\001\026\001\027\001\028\001\029\001\030\001\
\031\001\255\255\255\255\255\255\255\255\036\001\037\001\255\255\
\110\003\040\001\041\001\042\001\043\001\044\001\045\001\046\001\
\047\001\048\001\049\001\050\001\051\001\052\001\255\255\054\001\
\055\001\056\001\057\001\255\255\255\255\060\001\061\001\062\001\
\063\001\064\001\065\001\066\001\067\001\068\001\069\001\255\255\
\071\001\072\001\073\001\074\001\075\001\255\255\077\001\078\001\
\255\255\255\255\255\255\082\001\083\001\084\001\085\001\086\001\
\087\001\088\001\089\001\255\255\091\001\255\255\093\001\094\001\
\255\255\096\001\097\001\098\001\099\001\100\001\255\255\102\001\
\103\001\255\255\105\001\106\001\107\001\108\001\000\000\110\001\
\111\001\255\255\113\001\255\255\255\255\255\255\117\001\255\255\
\255\255\255\255\255\255\255\255\255\255\000\001\001\001\002\001\
\003\001\004\001\255\255\006\001\007\001\008\001\009\001\010\001\
\011\001\012\001\013\001\014\001\015\001\016\001\017\001\018\001\
\019\001\020\001\021\001\255\255\218\003\024\001\025\001\026\001\
\027\001\028\001\029\001\030\001\031\001\255\255\255\255\255\255\
\255\255\036\001\037\001\255\255\255\255\040\001\041\001\042\001\
\043\001\044\001\045\001\046\001\047\001\048\001\049\001\050\001\
\051\001\052\001\255\255\054\001\055\001\056\001\057\001\255\255\
\255\255\060\001\061\001\062\001\255\255\064\001\065\001\066\001\
\067\001\068\001\069\001\255\255\071\001\072\001\073\001\074\001\
\075\001\255\255\077\001\078\001\255\255\255\255\255\255\082\001\
\083\001\084\001\085\001\086\001\087\001\088\001\089\001\255\255\
\091\001\255\255\093\001\094\001\255\255\096\001\097\001\098\001\
\099\001\100\001\255\255\102\001\103\001\000\000\105\001\106\001\
\107\001\108\001\255\255\110\001\111\001\255\255\113\001\255\255\
\255\255\255\255\117\001\255\255\255\255\255\255\255\255\000\001\
\001\001\002\001\003\001\255\255\255\255\255\255\255\255\008\001\
\009\001\010\001\255\255\255\255\013\001\014\001\015\001\016\001\
\017\001\018\001\019\001\020\001\021\001\255\255\255\255\024\001\
\025\001\026\001\027\001\028\001\029\001\255\255\255\255\255\255\
\255\255\255\255\255\255\036\001\037\001\255\255\255\255\040\001\
\041\001\042\001\043\001\044\001\045\001\046\001\047\001\048\001\
\255\255\255\255\255\255\255\255\114\004\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\061\001\062\001\255\255\064\001\
\126\004\255\255\067\001\068\001\069\001\255\255\071\001\072\001\
\073\001\074\001\075\001\255\255\255\255\255\255\255\255\255\255\
\255\255\082\001\255\255\084\001\085\001\086\001\087\001\088\001\
\255\255\255\255\255\255\255\255\093\001\094\001\255\255\096\001\
\097\001\098\001\099\001\000\000\255\255\102\001\255\255\255\255\
\105\001\255\255\107\001\255\255\255\255\110\001\255\255\255\255\
\113\001\175\004\176\004\177\004\117\001\255\255\000\001\001\001\
\002\001\003\001\255\255\255\255\006\001\007\001\008\001\009\001\
\010\001\011\001\012\001\013\001\014\001\015\001\016\001\017\001\
\018\001\019\001\020\001\021\001\022\001\255\255\024\001\025\001\
\026\001\027\001\028\001\029\001\030\001\031\001\255\255\255\255\
\255\255\255\255\036\001\037\001\255\255\255\255\040\001\041\001\
\042\001\043\001\044\001\045\001\046\001\047\001\048\001\049\001\
\050\001\051\001\052\001\255\255\054\001\055\001\056\001\057\001\
\255\255\255\255\060\001\061\001\062\001\255\255\064\001\065\001\
\066\001\067\001\068\001\069\001\255\255\071\001\072\001\073\001\
\074\001\075\001\255\255\077\001\078\001\255\255\255\255\255\255\
\082\001\083\001\084\001\085\001\086\001\087\001\088\001\089\001\
\255\255\091\001\255\255\093\001\094\001\255\255\096\001\097\001\
\098\001\099\001\100\001\000\000\102\001\103\001\255\255\105\001\
\106\001\107\001\108\001\255\255\110\001\111\001\255\255\113\001\
\255\255\255\255\255\255\117\001\255\255\000\001\001\001\002\001\
\003\001\004\001\255\255\006\001\007\001\008\001\009\001\010\001\
\011\001\012\001\013\001\014\001\015\001\016\001\017\001\018\001\
\019\001\020\001\021\001\255\255\255\255\024\001\025\001\026\001\
\027\001\028\001\029\001\030\001\031\001\255\255\255\255\255\255\
\255\255\036\001\037\001\255\255\255\255\040\001\041\001\042\001\
\043\001\044\001\045\001\046\001\047\001\048\001\049\001\050\001\
\051\001\052\001\255\255\054\001\055\001\056\001\057\001\255\255\
\255\255\060\001\061\001\062\001\255\255\064\001\065\001\066\001\
\067\001\068\001\069\001\255\255\071\001\072\001\073\001\074\001\
\075\001\255\255\077\001\078\001\255\255\255\255\255\255\082\001\
\083\001\084\001\085\001\086\001\087\001\088\001\089\001\255\255\
\091\001\255\255\093\001\094\001\255\255\096\001\097\001\098\001\
\099\001\100\001\000\000\102\001\103\001\255\255\105\001\106\001\
\107\001\108\001\255\255\110\001\111\001\255\255\113\001\255\255\
\255\255\255\255\117\001\000\001\001\001\002\001\003\001\255\255\
\255\255\006\001\007\001\008\001\009\001\010\001\011\001\012\001\
\013\001\014\001\015\001\016\001\017\001\018\001\019\001\020\001\
\021\001\022\001\255\255\024\001\025\001\026\001\027\001\028\001\
\029\001\030\001\031\001\255\255\255\255\255\255\255\255\036\001\
\037\001\255\255\255\255\040\001\041\001\042\001\043\001\044\001\
\045\001\046\001\047\001\048\001\049\001\050\001\051\001\052\001\
\255\255\054\001\055\001\056\001\057\001\255\255\255\255\060\001\
\061\001\062\001\255\255\064\001\065\001\066\001\067\001\068\001\
\069\001\255\255\071\001\072\001\073\001\074\001\075\001\255\255\
\077\001\078\001\255\255\255\255\255\255\082\001\083\001\084\001\
\085\001\086\001\087\001\088\001\089\001\255\255\091\001\255\255\
\093\001\094\001\255\255\096\001\097\001\098\001\099\001\100\001\
\000\000\102\001\103\001\255\255\105\001\106\001\107\001\108\001\
\255\255\110\001\111\001\255\255\113\001\255\255\255\255\255\255\
\117\001\255\255\255\255\000\001\001\001\002\001\003\001\255\255\
\255\255\006\001\007\001\008\001\009\001\010\001\011\001\012\001\
\013\001\014\001\015\001\016\001\017\001\018\001\019\001\020\001\
\021\001\022\001\255\255\024\001\025\001\026\001\027\001\028\001\
\029\001\030\001\031\001\255\255\255\255\255\255\255\255\036\001\
\037\001\255\255\255\255\040\001\041\001\042\001\043\001\044\001\
\045\001\046\001\047\001\048\001\049\001\050\001\051\001\052\001\
\255\255\054\001\055\001\056\001\057\001\255\255\255\255\060\001\
\061\001\062\001\255\255\064\001\065\001\066\001\067\001\068\001\
\069\001\255\255\071\001\072\001\073\001\074\001\075\001\255\255\
\077\001\078\001\255\255\255\255\255\255\082\001\083\001\084\001\
\085\001\086\001\087\001\088\001\089\001\255\255\091\001\255\255\
\093\001\094\001\255\255\096\001\097\001\098\001\099\001\100\001\
\000\000\102\001\103\001\255\255\105\001\106\001\107\001\108\001\
\255\255\110\001\111\001\255\255\113\001\255\255\255\255\255\255\
\117\001\255\255\000\001\001\001\002\001\003\001\255\255\255\255\
\006\001\007\001\008\001\009\001\010\001\011\001\012\001\013\001\
\014\001\015\001\016\001\017\001\018\001\019\001\020\001\021\001\
\022\001\255\255\024\001\025\001\026\001\027\001\028\001\029\001\
\030\001\031\001\255\255\255\255\255\255\255\255\036\001\037\001\
\255\255\255\255\040\001\041\001\042\001\043\001\044\001\045\001\
\046\001\047\001\048\001\049\001\050\001\051\001\052\001\255\255\
\054\001\055\001\056\001\057\001\255\255\255\255\060\001\061\001\
\062\001\255\255\064\001\065\001\066\001\067\001\068\001\069\001\
\255\255\071\001\072\001\073\001\074\001\075\001\255\255\077\001\
\078\001\255\255\255\255\255\255\082\001\083\001\084\001\085\001\
\086\001\087\001\088\001\089\001\255\255\091\001\255\255\093\001\
\094\001\255\255\096\001\097\001\098\001\099\001\100\001\000\000\
\102\001\103\001\255\255\105\001\106\001\107\001\108\001\255\255\
\110\001\111\001\255\255\113\001\255\255\255\255\255\255\117\001\
\000\001\001\001\002\001\003\001\004\001\255\255\006\001\007\001\
\008\001\009\001\010\001\011\001\012\001\013\001\014\001\015\001\
\016\001\017\001\018\001\019\001\020\001\021\001\255\255\255\255\
\024\001\025\001\026\001\027\001\028\001\029\001\030\001\031\001\
\255\255\255\255\255\255\255\255\036\001\037\001\255\255\255\255\
\040\001\041\001\042\001\043\001\044\001\045\001\046\001\047\001\
\048\001\049\001\050\001\051\001\052\001\255\255\054\001\055\001\
\056\001\057\001\255\255\255\255\060\001\061\001\062\001\255\255\
\064\001\065\001\066\001\067\001\068\001\069\001\255\255\071\001\
\072\001\073\001\074\001\075\001\255\255\077\001\078\001\255\255\
\255\255\255\255\082\001\083\001\084\001\085\001\086\001\087\001\
\088\001\089\001\255\255\091\001\255\255\093\001\094\001\255\255\
\096\001\097\001\098\001\255\255\255\255\000\000\102\001\103\001\
\255\255\105\001\106\001\107\001\108\001\255\255\110\001\111\001\
\255\255\113\001\255\255\255\255\255\255\117\001\255\255\255\255\
\000\001\001\001\002\001\003\001\004\001\255\255\006\001\007\001\
\008\001\009\001\010\001\011\001\012\001\013\001\014\001\015\001\
\016\001\017\001\018\001\019\001\020\001\021\001\255\255\255\255\
\024\001\025\001\026\001\027\001\028\001\029\001\030\001\031\001\
\255\255\255\255\255\255\255\255\036\001\037\001\255\255\255\255\
\040\001\041\001\042\001\043\001\044\001\045\001\046\001\047\001\
\048\001\049\001\050\001\051\001\052\001\255\255\054\001\055\001\
\056\001\057\001\255\255\255\255\060\001\061\001\062\001\255\255\
\064\001\065\001\066\001\067\001\068\001\069\001\255\255\071\001\
\072\001\073\001\074\001\075\001\255\255\077\001\078\001\255\255\
\255\255\255\255\082\001\083\001\084\001\085\001\086\001\087\001\
\088\001\089\001\255\255\091\001\255\255\093\001\094\001\255\255\
\096\001\097\001\098\001\000\000\255\255\255\255\102\001\103\001\
\255\255\105\001\106\001\107\001\108\001\255\255\110\001\111\001\
\255\255\113\001\255\255\255\255\255\255\117\001\255\255\000\001\
\001\001\002\001\003\001\004\001\255\255\006\001\007\001\008\001\
\009\001\010\001\011\001\012\001\013\001\014\001\015\001\016\001\
\017\001\018\001\019\001\020\001\021\001\255\255\255\255\024\001\
\025\001\026\001\027\001\028\001\029\001\030\001\031\001\255\255\
\255\255\255\255\255\255\036\001\037\001\255\255\255\255\040\001\
\041\001\042\001\043\001\044\001\045\001\046\001\047\001\048\001\
\049\001\050\001\051\001\052\001\255\255\054\001\055\001\056\001\
\057\001\255\255\255\255\060\001\061\001\062\001\255\255\064\001\
\065\001\066\001\067\001\068\001\069\001\255\255\071\001\072\001\
\073\001\074\001\075\001\255\255\077\001\078\001\255\255\255\255\
\255\255\082\001\083\001\084\001\085\001\086\001\087\001\088\001\
\089\001\255\255\091\001\255\255\093\001\094\001\255\255\096\001\
\097\001\098\001\000\000\255\255\255\255\102\001\103\001\255\255\
\105\001\106\001\107\001\108\001\255\255\110\001\111\001\255\255\
\113\001\255\255\255\255\255\255\117\001\000\001\001\001\002\001\
\003\001\255\255\255\255\255\255\255\255\008\001\009\001\010\001\
\255\255\255\255\013\001\014\001\015\001\016\001\017\001\018\001\
\019\001\020\001\021\001\022\001\255\255\024\001\025\001\026\001\
\027\001\028\001\029\001\255\255\255\255\255\255\255\255\255\255\
\255\255\036\001\037\001\255\255\255\255\040\001\041\001\042\001\
\043\001\044\001\045\001\046\001\047\001\048\001\255\255\255\255\
\255\255\052\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\061\001\062\001\255\255\064\001\255\255\255\255\
\067\001\068\001\069\001\255\255\071\001\072\001\073\001\074\001\
\075\001\255\255\255\255\255\255\255\255\255\255\255\255\082\001\
\083\001\084\001\085\001\086\001\087\001\088\001\255\255\255\255\
\091\001\255\255\093\001\094\001\255\255\096\001\097\001\098\001\
\099\001\100\001\000\000\102\001\255\255\255\255\105\001\106\001\
\107\001\255\255\255\255\110\001\255\255\255\255\113\001\255\255\
\255\255\255\255\117\001\000\001\001\001\002\001\003\001\255\255\
\255\255\255\255\255\255\008\001\009\001\010\001\255\255\255\255\
\013\001\014\001\015\001\016\001\017\001\018\001\019\001\020\001\
\021\001\022\001\255\255\024\001\025\001\026\001\027\001\028\001\
\029\001\255\255\255\255\255\255\255\255\255\255\255\255\036\001\
\037\001\255\255\255\255\040\001\041\001\042\001\043\001\044\001\
\045\001\046\001\047\001\048\001\255\255\255\255\255\255\052\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\061\001\062\001\255\255\064\001\255\255\255\255\067\001\068\001\
\069\001\255\255\071\001\072\001\073\001\074\001\075\001\255\255\
\255\255\255\255\255\255\255\255\255\255\082\001\083\001\084\001\
\085\001\086\001\087\001\088\001\255\255\255\255\091\001\255\255\
\093\001\094\001\255\255\096\001\097\001\098\001\099\001\100\001\
\000\000\102\001\255\255\255\255\105\001\106\001\107\001\255\255\
\255\255\110\001\255\255\255\255\113\001\255\255\255\255\255\255\
\117\001\255\255\000\001\001\001\002\001\003\001\255\255\255\255\
\255\255\255\255\008\001\009\001\010\001\255\255\255\255\013\001\
\014\001\015\001\016\001\017\001\018\001\019\001\020\001\021\001\
\255\255\255\255\024\001\025\001\026\001\027\001\028\001\029\001\
\255\255\255\255\255\255\255\255\255\255\255\255\036\001\037\001\
\255\255\255\255\040\001\041\001\042\001\043\001\044\001\045\001\
\046\001\047\001\048\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\061\001\
\062\001\255\255\064\001\255\255\255\255\067\001\068\001\069\001\
\255\255\071\001\072\001\073\001\074\001\075\001\255\255\255\255\
\255\255\255\255\255\255\255\255\082\001\255\255\084\001\085\001\
\086\001\087\001\088\001\255\255\255\255\255\255\255\255\093\001\
\094\001\255\255\096\001\097\001\098\001\255\255\000\000\255\255\
\102\001\255\255\255\255\105\001\255\255\107\001\255\255\255\255\
\110\001\255\255\255\255\113\001\255\255\255\255\255\255\117\001\
\255\255\255\255\000\001\001\001\002\001\003\001\255\255\255\255\
\255\255\255\255\008\001\009\001\010\001\255\255\255\255\013\001\
\014\001\015\001\016\001\017\001\255\255\019\001\020\001\021\001\
\255\255\255\255\024\001\025\001\026\001\027\001\028\001\029\001\
\255\255\255\255\255\255\255\255\255\255\255\255\036\001\037\001\
\255\255\255\255\040\001\041\001\042\001\043\001\044\001\045\001\
\046\001\047\001\048\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\061\001\
\062\001\255\255\064\001\255\255\255\255\067\001\068\001\069\001\
\255\255\071\001\072\001\073\001\074\001\075\001\255\255\255\255\
\255\255\255\255\255\255\255\255\082\001\255\255\084\001\085\001\
\086\001\087\001\088\001\255\255\255\255\255\255\255\255\093\001\
\094\001\255\255\096\001\097\001\098\001\099\001\000\000\255\255\
\102\001\255\255\255\255\105\001\255\255\107\001\255\255\255\255\
\110\001\255\255\255\255\113\001\255\255\255\255\255\255\117\001\
\000\001\001\001\002\001\003\001\255\255\255\255\255\255\255\255\
\008\001\009\001\010\001\255\255\255\255\013\001\014\001\015\001\
\016\001\017\001\018\001\019\001\020\001\021\001\255\255\255\255\
\024\001\025\001\026\001\027\001\028\001\029\001\255\255\255\255\
\255\255\255\255\255\255\255\255\036\001\037\001\255\255\255\255\
\040\001\041\001\042\001\043\001\044\001\045\001\046\001\047\001\
\048\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\061\001\062\001\255\255\
\064\001\255\255\255\255\067\001\068\001\069\001\255\255\071\001\
\072\001\073\001\074\001\075\001\255\255\255\255\255\255\255\255\
\255\255\255\255\082\001\255\255\084\001\085\001\086\001\087\001\
\088\001\255\255\255\255\255\255\255\255\093\001\094\001\255\255\
\096\001\097\001\098\001\255\255\000\000\255\255\102\001\255\255\
\255\255\105\001\255\255\107\001\255\255\255\255\110\001\255\255\
\255\255\113\001\255\255\255\255\255\255\117\001\000\001\001\001\
\002\001\003\001\255\255\255\255\255\255\255\255\008\001\009\001\
\010\001\255\255\255\255\013\001\014\001\015\001\016\001\017\001\
\018\001\019\001\020\001\021\001\255\255\255\255\024\001\025\001\
\026\001\027\001\028\001\029\001\255\255\255\255\255\255\255\255\
\255\255\255\255\036\001\037\001\255\255\255\255\040\001\041\001\
\042\001\043\001\044\001\045\001\046\001\047\001\048\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\061\001\062\001\255\255\064\001\255\255\
\255\255\067\001\068\001\069\001\255\255\071\001\072\001\073\001\
\074\001\075\001\255\255\255\255\255\255\255\255\255\255\255\255\
\082\001\255\255\084\001\085\001\086\001\087\001\088\001\255\255\
\255\255\255\255\255\255\093\001\094\001\255\255\096\001\097\001\
\098\001\255\255\000\000\255\255\102\001\255\255\255\255\105\001\
\255\255\107\001\255\255\255\255\110\001\255\255\255\255\113\001\
\255\255\255\255\255\255\117\001\255\255\255\255\000\001\001\001\
\002\001\003\001\255\255\255\255\255\255\255\255\008\001\009\001\
\010\001\255\255\255\255\013\001\014\001\015\001\016\001\017\001\
\018\001\019\001\020\001\021\001\255\255\255\255\024\001\025\001\
\026\001\027\001\028\001\029\001\255\255\255\255\255\255\255\255\
\255\255\255\255\036\001\037\001\255\255\255\255\040\001\041\001\
\042\001\043\001\044\001\045\001\046\001\047\001\048\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\061\001\062\001\255\255\064\001\255\255\
\255\255\067\001\068\001\069\001\255\255\071\001\072\001\073\001\
\074\001\075\001\255\255\255\255\255\255\255\255\255\255\255\255\
\082\001\255\255\084\001\085\001\086\001\087\001\088\001\255\255\
\255\255\255\255\255\255\093\001\094\001\255\255\096\001\097\001\
\098\001\000\000\255\255\255\255\102\001\255\255\255\255\105\001\
\255\255\107\001\255\255\255\255\110\001\255\255\255\255\113\001\
\255\255\255\255\255\255\117\001\000\001\001\001\002\001\003\001\
\255\255\255\255\255\255\255\255\008\001\009\001\010\001\255\255\
\255\255\013\001\014\001\015\001\016\001\017\001\018\001\019\001\
\020\001\021\001\255\255\255\255\024\001\025\001\026\001\027\001\
\028\001\029\001\255\255\255\255\255\255\255\255\255\255\255\255\
\036\001\037\001\255\255\255\255\040\001\041\001\042\001\043\001\
\044\001\045\001\046\001\047\001\048\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\061\001\062\001\255\255\064\001\255\255\255\255\067\001\
\068\001\069\001\255\255\071\001\072\001\073\001\074\001\075\001\
\255\255\255\255\255\255\255\255\255\255\255\255\082\001\255\255\
\084\001\085\001\086\001\087\001\088\001\255\255\255\255\255\255\
\255\255\093\001\094\001\255\255\096\001\097\001\098\001\000\000\
\255\255\255\255\102\001\255\255\255\255\105\001\255\255\107\001\
\255\255\255\255\110\001\255\255\255\255\113\001\255\255\255\255\
\255\255\117\001\000\001\001\001\002\001\003\001\255\255\255\255\
\255\255\255\255\008\001\009\001\010\001\255\255\255\255\013\001\
\014\001\015\001\016\001\017\001\018\001\019\001\020\001\021\001\
\255\255\255\255\024\001\025\001\026\001\027\001\028\001\029\001\
\255\255\255\255\255\255\255\255\255\255\255\255\036\001\037\001\
\255\255\255\255\040\001\041\001\042\001\043\001\044\001\045\001\
\255\255\047\001\048\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\061\001\
\062\001\255\255\064\001\255\255\255\255\067\001\068\001\069\001\
\255\255\071\001\072\001\073\001\074\001\075\001\255\255\255\255\
\255\255\255\255\255\255\255\255\082\001\255\255\084\001\085\001\
\086\001\087\001\088\001\255\255\255\255\255\255\255\255\093\001\
\094\001\255\255\096\001\097\001\098\001\099\001\000\000\255\255\
\102\001\255\255\255\255\105\001\255\255\107\001\255\255\255\255\
\110\001\255\255\255\255\113\001\255\255\255\255\255\255\117\001\
\255\255\000\001\001\001\002\001\003\001\255\255\255\255\255\255\
\255\255\008\001\009\001\010\001\255\255\255\255\013\001\014\001\
\015\001\016\001\017\001\018\001\019\001\020\001\021\001\255\255\
\255\255\024\001\025\001\026\001\027\001\028\001\029\001\255\255\
\255\255\255\255\255\255\255\255\255\255\036\001\037\001\255\255\
\255\255\040\001\041\001\042\001\043\001\044\001\045\001\255\255\
\047\001\048\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\061\001\062\001\
\255\255\064\001\255\255\255\255\067\001\068\001\069\001\255\255\
\071\001\072\001\073\001\074\001\075\001\255\255\255\255\255\255\
\255\255\255\255\255\255\082\001\255\255\084\001\085\001\086\001\
\087\001\088\001\255\255\255\255\255\255\255\255\093\001\094\001\
\255\255\096\001\097\001\098\001\099\001\000\000\255\255\102\001\
\255\255\255\255\105\001\255\255\107\001\255\255\255\255\110\001\
\255\255\255\255\113\001\255\255\255\255\255\255\117\001\000\001\
\001\001\002\001\003\001\255\255\255\255\255\255\255\255\008\001\
\009\001\010\001\255\255\255\255\013\001\014\001\015\001\016\001\
\017\001\018\001\019\001\020\001\021\001\255\255\255\255\024\001\
\025\001\026\001\027\001\028\001\029\001\255\255\255\255\255\255\
\255\255\255\255\255\255\036\001\037\001\255\255\255\255\040\001\
\041\001\042\001\043\001\044\001\045\001\255\255\047\001\048\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\061\001\062\001\255\255\064\001\
\255\255\255\255\067\001\068\001\069\001\255\255\071\001\072\001\
\073\001\074\001\075\001\255\255\255\255\255\255\255\255\255\255\
\255\255\082\001\255\255\084\001\085\001\086\001\087\001\088\001\
\255\255\255\255\255\255\255\255\093\001\094\001\255\255\096\001\
\097\001\098\001\099\001\000\000\255\255\102\001\255\255\255\255\
\105\001\255\255\107\001\255\255\255\255\110\001\255\255\255\255\
\113\001\255\255\255\255\255\255\117\001\255\255\000\001\001\001\
\002\001\003\001\255\255\255\255\255\255\255\255\008\001\009\001\
\010\001\255\255\255\255\013\001\014\001\015\001\016\001\017\001\
\018\001\019\001\020\001\021\001\255\255\255\255\024\001\025\001\
\026\001\027\001\028\001\029\001\255\255\255\255\255\255\255\255\
\255\255\255\255\036\001\037\001\255\255\255\255\040\001\041\001\
\042\001\043\001\044\001\045\001\255\255\047\001\048\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\061\001\062\001\255\255\064\001\255\255\
\255\255\067\001\068\001\069\001\255\255\071\001\072\001\073\001\
\074\001\075\001\255\255\255\255\255\255\255\255\255\255\255\255\
\082\001\255\255\084\001\085\001\086\001\087\001\088\001\255\255\
\255\255\255\255\255\255\093\001\094\001\255\255\096\001\097\001\
\098\001\099\001\000\000\255\255\102\001\255\255\255\255\105\001\
\255\255\107\001\255\255\255\255\110\001\255\255\255\255\113\001\
\255\255\255\255\255\255\117\001\255\255\000\001\001\001\002\001\
\003\001\255\255\255\255\255\255\255\255\255\255\009\001\010\001\
\255\255\255\255\013\001\014\001\015\001\016\001\017\001\018\001\
\019\001\020\001\021\001\255\255\255\255\024\001\025\001\026\001\
\027\001\028\001\029\001\255\255\255\255\255\255\255\255\255\255\
\255\255\036\001\037\001\255\255\255\255\040\001\041\001\042\001\
\043\001\044\001\045\001\046\001\047\001\048\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\061\001\062\001\255\255\064\001\255\255\255\255\
\067\001\068\001\069\001\255\255\071\001\072\001\073\001\074\001\
\075\001\255\255\255\255\255\255\255\255\255\255\255\255\082\001\
\255\255\084\001\085\001\086\001\087\001\088\001\255\255\255\255\
\255\255\255\255\093\001\094\001\255\255\096\001\097\001\098\001\
\099\001\000\000\255\255\102\001\255\255\255\255\105\001\255\255\
\107\001\255\255\255\255\110\001\255\255\255\255\113\001\255\255\
\255\255\255\255\117\001\000\001\001\001\002\001\003\001\255\255\
\255\255\255\255\255\255\255\255\009\001\010\001\255\255\255\255\
\013\001\014\001\015\001\016\001\017\001\018\001\019\001\020\001\
\021\001\255\255\255\255\024\001\025\001\026\001\027\001\028\001\
\029\001\255\255\255\255\255\255\255\255\255\255\255\255\036\001\
\037\001\255\255\255\255\040\001\041\001\042\001\043\001\044\001\
\045\001\046\001\047\001\048\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\061\001\062\001\255\255\064\001\255\255\255\255\067\001\068\001\
\069\001\255\255\071\001\072\001\073\001\074\001\075\001\255\255\
\255\255\255\255\255\255\255\255\255\255\082\001\255\255\084\001\
\085\001\086\001\087\001\088\001\255\255\255\255\255\255\255\255\
\093\001\094\001\255\255\096\001\097\001\098\001\099\001\000\000\
\255\255\102\001\255\255\255\255\105\001\255\255\107\001\255\255\
\255\255\110\001\255\255\255\255\113\001\255\255\255\255\255\255\
\117\001\255\255\000\001\001\001\002\001\003\001\255\255\255\255\
\255\255\255\255\255\255\009\001\010\001\255\255\255\255\013\001\
\014\001\015\001\016\001\017\001\018\001\019\001\020\001\021\001\
\255\255\255\255\024\001\025\001\026\001\027\001\028\001\029\001\
\255\255\255\255\255\255\255\255\255\255\255\255\036\001\037\001\
\255\255\255\255\040\001\041\001\042\001\043\001\044\001\045\001\
\046\001\047\001\048\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\061\001\
\062\001\255\255\064\001\255\255\255\255\067\001\068\001\069\001\
\255\255\071\001\072\001\073\001\074\001\075\001\255\255\255\255\
\255\255\255\255\255\255\255\255\082\001\255\255\084\001\085\001\
\086\001\087\001\088\001\255\255\255\255\255\255\255\255\093\001\
\094\001\255\255\096\001\097\001\098\001\099\001\000\000\255\255\
\102\001\255\255\255\255\105\001\255\255\107\001\255\255\255\255\
\110\001\255\255\255\255\113\001\255\255\255\255\255\255\117\001\
\255\255\000\001\001\001\002\001\003\001\255\255\255\255\255\255\
\255\255\008\001\009\001\010\001\255\255\255\255\013\001\014\001\
\015\001\016\001\017\001\018\001\019\001\020\001\021\001\255\255\
\255\255\024\001\025\001\026\001\027\001\028\001\029\001\255\255\
\255\255\255\255\255\255\255\255\255\255\036\001\037\001\255\255\
\255\255\040\001\041\001\042\001\043\001\044\001\255\255\255\255\
\047\001\048\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\061\001\062\001\
\255\255\064\001\255\255\255\255\067\001\068\001\069\001\255\255\
\071\001\072\001\073\001\074\001\075\001\255\255\255\255\255\255\
\255\255\255\255\255\255\082\001\255\255\084\001\255\255\086\001\
\087\001\088\001\255\255\255\255\255\255\255\255\093\001\094\001\
\255\255\096\001\097\001\098\001\099\001\000\000\255\255\255\255\
\255\255\255\255\105\001\255\255\107\001\255\255\255\255\110\001\
\255\255\255\255\113\001\255\255\255\255\255\255\117\001\000\001\
\001\001\002\001\003\001\255\255\255\255\255\255\255\255\008\001\
\009\001\010\001\255\255\255\255\013\001\014\001\015\001\016\001\
\017\001\018\001\019\001\020\001\021\001\255\255\255\255\024\001\
\025\001\026\001\027\001\028\001\029\001\255\255\255\255\255\255\
\255\255\255\255\255\255\036\001\037\001\255\255\255\255\040\001\
\041\001\042\001\043\001\044\001\255\255\255\255\047\001\048\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\061\001\062\001\255\255\064\001\
\255\255\255\255\067\001\068\001\069\001\255\255\071\001\072\001\
\073\001\074\001\075\001\255\255\255\255\255\255\255\255\255\255\
\255\255\082\001\255\255\084\001\255\255\086\001\087\001\088\001\
\255\255\255\255\255\255\255\255\093\001\094\001\255\255\096\001\
\097\001\098\001\099\001\000\000\255\255\255\255\255\255\255\255\
\105\001\255\255\107\001\255\255\255\255\110\001\255\255\255\255\
\113\001\255\255\255\255\255\255\117\001\255\255\000\001\001\001\
\002\001\003\001\255\255\255\255\255\255\255\255\008\001\009\001\
\010\001\255\255\255\255\013\001\014\001\015\001\016\001\017\001\
\018\001\019\001\020\001\021\001\255\255\255\255\024\001\025\001\
\026\001\027\001\028\001\029\001\255\255\255\255\255\255\255\255\
\255\255\255\255\036\001\037\001\255\255\255\255\040\001\041\001\
\042\001\043\001\044\001\255\255\255\255\047\001\048\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\061\001\062\001\255\255\064\001\255\255\
\255\255\067\001\068\001\069\001\255\255\071\001\072\001\073\001\
\074\001\075\001\255\255\255\255\255\255\255\255\255\255\255\255\
\082\001\255\255\084\001\255\255\086\001\087\001\088\001\255\255\
\255\255\255\255\255\255\093\001\094\001\255\255\096\001\097\001\
\098\001\099\001\000\000\255\255\255\255\255\255\255\255\105\001\
\255\255\107\001\255\255\255\255\110\001\255\255\255\255\113\001\
\255\255\255\255\255\255\117\001\255\255\000\001\001\001\002\001\
\003\001\255\255\255\255\255\255\255\255\008\001\009\001\010\001\
\255\255\255\255\013\001\014\001\015\001\016\001\017\001\018\001\
\019\001\020\001\021\001\255\255\255\255\024\001\025\001\026\001\
\027\001\028\001\029\001\255\255\255\255\255\255\255\255\255\255\
\255\255\036\001\037\001\255\255\255\255\040\001\041\001\042\001\
\043\001\044\001\255\255\255\255\047\001\048\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\061\001\062\001\255\255\064\001\255\255\255\255\
\067\001\068\001\069\001\255\255\071\001\072\001\073\001\074\001\
\075\001\255\255\255\255\255\255\255\255\255\255\255\255\082\001\
\255\255\084\001\255\255\086\001\087\001\088\001\255\255\255\255\
\255\255\255\255\093\001\094\001\255\255\096\001\097\001\098\001\
\099\001\000\000\255\255\255\255\255\255\255\255\105\001\255\255\
\107\001\255\255\255\255\110\001\255\255\255\255\113\001\255\255\
\255\255\255\255\117\001\000\001\001\001\002\001\003\001\255\255\
\255\255\255\255\255\255\008\001\009\001\010\001\255\255\255\255\
\013\001\014\001\015\001\016\001\017\001\018\001\019\001\020\001\
\021\001\255\255\255\255\024\001\025\001\026\001\027\001\028\001\
\029\001\255\255\255\255\255\255\255\255\255\255\255\255\036\001\
\037\001\255\255\255\255\040\001\041\001\042\001\043\001\044\001\
\255\255\255\255\047\001\048\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\061\001\062\001\255\255\064\001\255\255\255\255\067\001\068\001\
\069\001\255\255\071\001\072\001\073\001\074\001\075\001\255\255\
\255\255\255\255\255\255\255\255\255\255\082\001\255\255\084\001\
\255\255\086\001\087\001\088\001\255\255\255\255\255\255\255\255\
\093\001\094\001\255\255\096\001\097\001\098\001\099\001\000\000\
\255\255\255\255\255\255\255\255\105\001\255\255\107\001\255\255\
\255\255\110\001\255\255\255\255\113\001\255\255\255\255\255\255\
\117\001\255\255\000\001\001\001\002\001\003\001\255\255\255\255\
\255\255\255\255\008\001\009\001\010\001\255\255\255\255\013\001\
\014\001\015\001\016\001\017\001\018\001\019\001\020\001\021\001\
\255\255\255\255\024\001\025\001\026\001\027\001\028\001\029\001\
\255\255\255\255\255\255\255\255\255\255\255\255\036\001\037\001\
\255\255\255\255\040\001\041\001\042\001\043\001\044\001\255\255\
\255\255\047\001\048\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\061\001\
\062\001\255\255\064\001\255\255\255\255\067\001\068\001\069\001\
\255\255\071\001\072\001\073\001\074\001\075\001\255\255\255\255\
\255\255\255\255\255\255\255\255\082\001\255\255\084\001\255\255\
\086\001\087\001\088\001\255\255\255\255\255\255\255\255\093\001\
\094\001\255\255\096\001\097\001\098\001\099\001\000\000\255\255\
\255\255\255\255\255\255\105\001\255\255\107\001\255\255\255\255\
\110\001\255\255\255\255\113\001\255\255\255\255\255\255\117\001\
\255\255\000\001\001\001\002\001\003\001\255\255\255\255\255\255\
\255\255\008\001\009\001\010\001\255\255\255\255\013\001\014\001\
\015\001\016\001\017\001\018\001\019\001\020\001\021\001\255\255\
\255\255\024\001\025\001\026\001\027\001\028\001\029\001\255\255\
\255\255\255\255\255\255\255\255\255\255\036\001\037\001\255\255\
\255\255\040\001\041\001\042\001\043\001\044\001\045\001\046\001\
\047\001\048\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\061\001\062\001\
\255\255\255\255\255\255\255\255\067\001\068\001\069\001\255\255\
\071\001\255\255\255\255\074\001\075\001\255\255\255\255\255\255\
\255\255\255\255\255\255\082\001\255\255\084\001\085\001\255\255\
\255\255\088\001\255\255\255\255\255\255\255\255\093\001\094\001\
\255\255\096\001\097\001\098\001\099\001\000\000\255\255\102\001\
\255\255\255\255\105\001\255\255\107\001\255\255\255\255\110\001\
\255\255\255\255\113\001\255\255\255\255\255\255\117\001\000\001\
\001\001\002\001\003\001\255\255\255\255\255\255\255\255\008\001\
\009\001\010\001\255\255\255\255\013\001\014\001\255\255\016\001\
\017\001\018\001\019\001\020\001\021\001\255\255\255\255\024\001\
\025\001\026\001\027\001\028\001\029\001\255\255\255\255\255\255\
\255\255\255\255\255\255\036\001\037\001\255\255\255\255\040\001\
\041\001\042\001\255\255\255\255\255\255\255\255\047\001\048\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\061\001\062\001\255\255\064\001\
\255\255\255\255\255\255\068\001\069\001\255\255\071\001\255\255\
\255\255\074\001\075\001\255\255\255\255\255\255\255\255\255\255\
\255\255\082\001\255\255\084\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\093\001\094\001\255\255\096\001\
\097\001\098\001\099\001\000\000\255\255\255\255\255\255\255\255\
\105\001\255\255\107\001\255\255\255\255\110\001\255\255\255\255\
\113\001\255\255\255\255\255\255\117\001\255\255\000\001\001\001\
\002\001\003\001\255\255\255\255\255\255\255\255\008\001\009\001\
\010\001\255\255\255\255\013\001\014\001\255\255\016\001\017\001\
\018\001\019\001\020\001\021\001\255\255\255\255\024\001\025\001\
\026\001\027\001\028\001\029\001\255\255\255\255\255\255\255\255\
\255\255\255\255\036\001\037\001\255\255\255\255\040\001\041\001\
\042\001\255\255\255\255\255\255\255\255\047\001\048\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\061\001\062\001\255\255\064\001\255\255\
\255\255\255\255\068\001\069\001\255\255\071\001\255\255\255\255\
\074\001\075\001\255\255\255\255\255\255\255\255\255\255\255\255\
\082\001\255\255\084\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\093\001\094\001\255\255\096\001\097\001\
\098\001\099\001\000\000\255\255\255\255\255\255\255\255\105\001\
\255\255\107\001\255\255\255\255\110\001\255\255\255\255\113\001\
\255\255\255\255\255\255\117\001\255\255\000\001\001\001\002\001\
\003\001\255\255\255\255\255\255\255\255\008\001\009\001\010\001\
\255\255\255\255\013\001\014\001\255\255\016\001\017\001\018\001\
\019\001\020\001\021\001\255\255\255\255\024\001\025\001\026\001\
\027\001\028\001\029\001\255\255\255\255\255\255\255\255\255\255\
\255\255\036\001\037\001\255\255\255\255\040\001\041\001\042\001\
\255\255\255\255\255\255\255\255\047\001\048\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\061\001\062\001\255\255\064\001\255\255\255\255\
\255\255\068\001\069\001\255\255\071\001\255\255\255\255\074\001\
\075\001\255\255\255\255\255\255\255\255\255\255\255\255\082\001\
\255\255\084\001\255\255\255\255\000\000\255\255\255\255\255\255\
\255\255\255\255\093\001\094\001\255\255\096\001\097\001\098\001\
\099\001\255\255\255\255\255\255\255\255\255\255\105\001\255\255\
\107\001\255\255\255\255\110\001\255\255\255\255\113\001\255\255\
\255\255\255\255\117\001\000\001\001\001\002\001\003\001\255\255\
\255\255\255\255\255\255\008\001\009\001\010\001\255\255\255\255\
\013\001\014\001\255\255\016\001\017\001\018\001\019\001\020\001\
\021\001\255\255\255\255\024\001\025\001\026\001\027\001\028\001\
\029\001\255\255\255\255\255\255\255\255\255\255\255\255\036\001\
\037\001\255\255\255\255\040\001\041\001\042\001\255\255\255\255\
\255\255\255\255\047\001\048\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\061\001\062\001\255\255\064\001\255\255\255\255\255\255\068\001\
\069\001\255\255\071\001\255\255\255\255\074\001\075\001\255\255\
\255\255\255\255\255\255\000\000\255\255\082\001\255\255\084\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\093\001\094\001\255\255\096\001\097\001\098\001\099\001\255\255\
\255\255\255\255\255\255\255\255\105\001\255\255\107\001\255\255\
\255\255\110\001\255\255\255\255\113\001\255\255\255\255\255\255\
\117\001\255\255\000\001\001\001\002\001\003\001\255\255\255\255\
\255\255\255\255\008\001\009\001\010\001\255\255\255\255\013\001\
\014\001\255\255\016\001\017\001\018\001\019\001\020\001\021\001\
\255\255\255\255\024\001\025\001\026\001\027\001\028\001\029\001\
\255\255\255\255\255\255\255\255\255\255\255\255\036\001\037\001\
\255\255\255\255\040\001\041\001\042\001\255\255\255\255\255\255\
\255\255\047\001\048\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\061\001\
\062\001\255\255\064\001\255\255\255\255\000\000\068\001\069\001\
\255\255\071\001\255\255\255\255\074\001\075\001\255\255\255\255\
\255\255\255\255\255\255\255\255\082\001\255\255\084\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\093\001\
\094\001\255\255\096\001\097\001\098\001\099\001\255\255\255\255\
\255\255\255\255\255\255\105\001\000\001\107\001\255\255\003\001\
\110\001\255\255\255\255\113\001\008\001\009\001\010\001\117\001\
\255\255\013\001\014\001\255\255\016\001\017\001\018\001\019\001\
\020\001\021\001\255\255\255\255\024\001\025\001\026\001\255\255\
\028\001\029\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\037\001\255\255\255\255\040\001\041\001\255\255\255\255\
\255\255\255\255\255\255\047\001\048\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\061\001\255\255\255\255\064\001\255\255\255\255\000\000\
\068\001\069\001\255\255\071\001\255\255\255\255\074\001\075\001\
\255\255\255\255\255\255\255\255\255\255\255\255\082\001\255\255\
\084\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\093\001\094\001\255\255\096\001\097\001\098\001\099\001\
\255\255\255\255\255\255\255\255\255\255\105\001\255\255\107\001\
\255\255\255\255\110\001\000\001\255\255\113\001\003\001\255\255\
\255\255\117\001\255\255\008\001\009\001\010\001\255\255\255\255\
\013\001\014\001\255\255\016\001\017\001\018\001\019\001\020\001\
\021\001\255\255\255\255\024\001\025\001\026\001\255\255\028\001\
\029\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\037\001\255\255\255\255\040\001\041\001\255\255\255\255\255\255\
\255\255\255\255\047\001\048\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\061\001\000\000\255\255\064\001\255\255\255\255\255\255\068\001\
\069\001\255\255\071\001\255\255\255\255\074\001\075\001\255\255\
\255\255\255\255\255\255\255\255\255\255\082\001\255\255\084\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\093\001\094\001\255\255\096\001\097\001\098\001\099\001\255\255\
\255\255\255\255\255\255\255\255\105\001\000\001\107\001\255\255\
\003\001\110\001\255\255\255\255\113\001\008\001\255\255\010\001\
\117\001\255\255\013\001\014\001\255\255\016\001\017\001\018\001\
\019\001\020\001\021\001\255\255\255\255\024\001\025\001\026\001\
\255\255\028\001\029\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\037\001\255\255\255\255\040\001\041\001\255\255\
\255\255\255\255\255\255\255\255\047\001\048\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\000\000\255\255\
\255\255\255\255\061\001\255\255\255\255\064\001\255\255\255\255\
\255\255\068\001\069\001\255\255\071\001\255\255\255\255\074\001\
\075\001\255\255\255\255\255\255\255\255\255\255\255\255\082\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\093\001\094\001\255\255\096\001\097\001\098\001\
\099\001\255\255\255\255\255\255\255\255\255\255\105\001\000\001\
\107\001\255\255\003\001\110\001\255\255\255\255\113\001\008\001\
\255\255\010\001\117\001\255\255\013\001\014\001\255\255\016\001\
\017\001\018\001\019\001\020\001\021\001\255\255\255\255\024\001\
\025\001\026\001\255\255\028\001\029\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\037\001\255\255\255\255\040\001\
\041\001\255\255\255\255\255\255\255\255\255\255\047\001\048\001\
\255\255\255\255\255\255\000\000\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\061\001\255\255\255\255\064\001\
\255\255\255\255\255\255\068\001\069\001\255\255\071\001\255\255\
\255\255\074\001\075\001\255\255\255\255\255\255\255\255\255\255\
\255\255\082\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\093\001\094\001\255\255\096\001\
\097\001\098\001\099\001\255\255\255\255\255\255\255\255\255\255\
\105\001\000\001\107\001\255\255\003\001\110\001\255\255\255\255\
\113\001\008\001\255\255\010\001\117\001\255\255\013\001\014\001\
\255\255\016\001\017\001\018\001\019\001\020\001\021\001\255\255\
\255\255\024\001\025\001\026\001\255\255\028\001\029\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\037\001\255\255\
\255\255\040\001\041\001\255\255\255\255\255\255\255\255\255\255\
\047\001\048\001\255\255\255\255\255\255\000\000\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\061\001\255\255\
\255\255\064\001\255\255\255\255\255\255\068\001\069\001\255\255\
\071\001\255\255\255\255\074\001\075\001\255\255\255\255\255\255\
\255\255\255\255\255\255\082\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\093\001\094\001\
\255\255\096\001\097\001\098\001\099\001\255\255\000\001\255\255\
\255\255\003\001\105\001\255\255\107\001\255\255\008\001\110\001\
\010\001\255\255\113\001\013\001\014\001\255\255\117\001\017\001\
\255\255\019\001\020\001\021\001\255\255\255\255\024\001\025\001\
\026\001\255\255\028\001\029\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\037\001\255\255\255\255\040\001\041\001\
\255\255\255\255\255\255\255\255\255\255\047\001\048\001\255\255\
\255\255\255\255\000\000\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\061\001\255\255\255\255\064\001\255\255\
\255\255\255\255\068\001\069\001\255\255\071\001\255\255\255\255\
\074\001\075\001\255\255\255\255\255\255\255\255\255\255\255\255\
\082\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\093\001\094\001\255\255\096\001\097\001\
\098\001\099\001\255\255\000\001\255\255\255\255\003\001\105\001\
\255\255\107\001\255\255\008\001\110\001\010\001\255\255\113\001\
\013\001\014\001\255\255\117\001\017\001\255\255\019\001\020\001\
\021\001\255\255\255\255\024\001\025\001\026\001\255\255\028\001\
\029\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\037\001\255\255\255\255\040\001\041\001\255\255\255\255\255\255\
\255\255\255\255\047\001\048\001\255\255\255\255\255\255\000\000\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\061\001\255\255\255\255\064\001\255\255\255\255\255\255\068\001\
\069\001\255\255\071\001\255\255\255\255\074\001\075\001\255\255\
\255\255\255\255\255\255\255\255\255\255\082\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\093\001\094\001\255\255\096\001\097\001\098\001\099\001\255\255\
\255\255\255\255\255\255\255\255\105\001\000\001\107\001\255\255\
\003\001\110\001\255\255\255\255\113\001\008\001\255\255\010\001\
\117\001\255\255\013\001\014\001\255\255\255\255\017\001\255\255\
\019\001\020\001\021\001\255\255\255\255\024\001\025\001\026\001\
\255\255\028\001\029\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\037\001\255\255\255\255\040\001\041\001\255\255\
\255\255\255\255\255\255\255\255\047\001\048\001\255\255\255\255\
\255\255\000\000\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\061\001\255\255\255\255\064\001\255\255\255\255\
\255\255\068\001\069\001\255\255\071\001\255\255\255\255\074\001\
\075\001\255\255\255\255\255\255\255\255\255\255\255\255\082\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\093\001\094\001\255\255\096\001\097\001\098\001\
\099\001\255\255\000\001\255\255\255\255\003\001\105\001\255\255\
\107\001\255\255\008\001\110\001\010\001\255\255\113\001\013\001\
\014\001\255\255\117\001\017\001\255\255\019\001\020\001\021\001\
\255\255\255\255\024\001\025\001\026\001\255\255\028\001\029\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\037\001\
\255\255\255\255\040\001\041\001\255\255\255\255\255\255\255\255\
\255\255\047\001\048\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\061\001\
\255\255\000\000\064\001\255\255\255\255\255\255\068\001\069\001\
\255\255\071\001\000\000\255\255\074\001\075\001\255\255\255\255\
\255\255\255\255\255\255\255\255\082\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\093\001\
\094\001\255\255\096\001\097\001\098\001\099\001\255\255\000\001\
\255\255\255\255\003\001\105\001\255\255\107\001\255\255\008\001\
\110\001\010\001\255\255\113\001\013\001\014\001\255\255\117\001\
\017\001\255\255\019\001\020\001\021\001\255\255\255\255\024\001\
\025\001\026\001\255\255\028\001\029\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\037\001\255\255\255\255\040\001\
\041\001\255\255\255\255\255\255\255\255\255\255\047\001\048\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\061\001\255\255\255\255\064\001\
\255\255\255\255\255\255\068\001\069\001\255\255\071\001\255\255\
\255\255\074\001\075\001\255\255\000\000\255\255\255\255\255\255\
\255\255\082\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\093\001\094\001\255\255\096\001\
\097\001\098\001\099\001\255\255\255\255\255\255\255\255\255\255\
\105\001\000\001\107\001\255\255\003\001\110\001\255\255\255\255\
\113\001\008\001\255\255\010\001\117\001\255\255\013\001\014\001\
\255\255\255\255\017\001\255\255\019\001\020\001\021\001\255\255\
\255\255\024\001\025\001\026\001\255\255\028\001\029\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\037\001\255\255\
\255\255\040\001\041\001\255\255\255\255\255\255\255\255\255\255\
\047\001\048\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\061\001\255\255\
\255\255\064\001\255\255\255\255\255\255\068\001\069\001\255\255\
\071\001\255\255\255\255\074\001\075\001\255\255\255\255\255\255\
\255\255\255\255\255\255\082\001\000\000\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\093\001\094\001\
\255\255\096\001\255\255\098\001\099\001\255\255\255\255\255\255\
\255\255\255\255\105\001\255\255\107\001\255\255\255\255\110\001\
\255\255\000\001\113\001\002\001\003\001\004\001\117\001\255\255\
\255\255\008\001\000\001\255\255\255\255\255\255\013\001\255\255\
\255\255\255\255\017\001\018\001\019\001\255\255\255\255\013\001\
\255\255\255\255\255\255\026\001\027\001\028\001\029\001\255\255\
\255\255\255\255\255\255\255\255\026\001\036\001\028\001\029\001\
\255\255\255\255\041\001\255\255\255\255\255\255\255\255\255\255\
\047\001\048\001\056\001\041\001\058\001\059\001\060\001\255\255\
\062\001\255\255\255\255\065\001\066\001\255\255\061\001\255\255\
\255\255\064\001\065\001\255\255\067\001\068\001\069\001\061\001\
\071\001\000\000\064\001\074\001\075\001\255\255\068\001\069\001\
\255\255\255\255\255\255\082\001\255\255\075\001\092\001\255\255\
\255\255\255\255\255\255\255\255\082\001\099\001\093\001\094\001\
\255\255\096\001\097\001\098\001\099\001\255\255\255\255\102\001\
\094\001\111\001\112\001\255\255\098\001\099\001\255\255\110\001\
\111\001\255\255\113\001\255\255\000\001\255\255\117\001\003\001\
\110\001\255\255\255\255\113\001\008\001\255\255\010\001\255\255\
\255\255\013\001\014\001\255\255\255\255\017\001\255\255\019\001\
\020\001\021\001\255\255\255\255\024\001\255\255\026\001\255\255\
\028\001\029\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\037\001\255\255\255\255\040\001\041\001\255\255\255\255\
\255\255\255\255\255\255\047\001\048\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\000\000\255\255\
\255\255\061\001\255\255\255\255\064\001\255\255\255\255\255\255\
\068\001\069\001\255\255\071\001\255\255\255\255\074\001\075\001\
\255\255\255\255\255\255\255\255\255\255\255\255\082\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\093\001\094\001\255\255\096\001\097\001\098\001\099\001\
\255\255\255\255\255\255\255\255\255\255\105\001\255\255\107\001\
\255\255\255\255\110\001\255\255\000\001\113\001\002\001\003\001\
\004\001\117\001\255\255\255\255\008\001\255\255\255\255\255\255\
\255\255\013\001\255\255\255\255\255\255\017\001\018\001\019\001\
\255\255\255\255\255\255\255\255\255\255\255\255\026\001\027\001\
\028\001\029\001\255\255\255\255\255\255\255\255\255\255\255\255\
\036\001\255\255\255\255\255\255\255\255\041\001\255\255\255\255\
\255\255\255\255\255\255\047\001\048\001\000\000\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\061\001\255\255\255\255\064\001\255\255\255\255\067\001\
\068\001\069\001\255\255\071\001\255\255\255\255\074\001\075\001\
\255\255\255\255\255\255\255\255\255\255\255\255\082\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\093\001\094\001\255\255\096\001\097\001\098\001\099\001\
\255\255\000\001\255\255\002\001\003\001\004\001\255\255\255\255\
\255\255\008\001\110\001\255\255\255\255\113\001\013\001\255\255\
\255\255\117\001\017\001\018\001\019\001\255\255\255\255\255\255\
\255\255\255\255\255\255\026\001\027\001\028\001\029\001\255\255\
\255\255\255\255\255\255\255\255\255\255\036\001\255\255\255\255\
\255\255\255\255\041\001\255\255\255\255\255\255\255\255\255\255\
\047\001\048\001\000\000\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\061\001\255\255\
\255\255\064\001\255\255\255\255\067\001\068\001\069\001\255\255\
\071\001\255\255\255\255\074\001\075\001\255\255\255\255\255\255\
\255\255\255\255\255\255\082\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\093\001\094\001\
\255\255\096\001\097\001\098\001\255\255\255\255\000\001\102\001\
\002\001\003\001\004\001\255\255\255\255\255\255\008\001\110\001\
\255\255\255\255\113\001\013\001\255\255\255\255\117\001\017\001\
\018\001\019\001\255\255\255\255\255\255\255\255\255\255\255\255\
\026\001\027\001\028\001\029\001\255\255\255\255\255\255\255\255\
\255\255\255\255\036\001\255\255\255\255\255\255\255\255\041\001\
\255\255\255\255\255\255\255\255\255\255\047\001\048\001\000\000\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\061\001\255\255\255\255\064\001\255\255\
\255\255\067\001\068\001\069\001\255\255\071\001\255\255\255\255\
\074\001\075\001\255\255\255\255\255\255\255\255\255\255\255\255\
\082\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\093\001\094\001\255\255\096\001\097\001\
\098\001\255\255\255\255\255\255\102\001\000\001\255\255\002\001\
\003\001\004\001\255\255\255\255\110\001\008\001\255\255\113\001\
\255\255\255\255\013\001\117\001\255\255\255\255\017\001\018\001\
\019\001\255\255\255\255\255\255\255\255\255\255\255\255\026\001\
\027\001\028\001\029\001\255\255\255\255\255\255\255\255\255\255\
\255\255\036\001\255\255\255\255\255\255\255\255\041\001\255\255\
\255\255\255\255\255\255\255\255\047\001\048\001\000\000\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\061\001\255\255\255\255\064\001\255\255\255\255\
\067\001\068\001\069\001\255\255\071\001\255\255\255\255\074\001\
\075\001\255\255\255\255\255\255\255\255\255\255\255\255\082\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\093\001\094\001\255\255\096\001\097\001\098\001\
\099\001\255\255\000\001\255\255\002\001\003\001\004\001\255\255\
\255\255\255\255\008\001\110\001\255\255\255\255\113\001\013\001\
\255\255\255\255\117\001\017\001\018\001\019\001\255\255\255\255\
\255\255\255\255\255\255\255\255\026\001\027\001\028\001\029\001\
\255\255\255\255\255\255\255\255\255\255\255\255\036\001\255\255\
\255\255\255\255\255\255\041\001\255\255\255\255\255\255\255\255\
\255\255\047\001\048\001\000\000\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\061\001\
\255\255\255\255\064\001\255\255\255\255\067\001\068\001\069\001\
\255\255\071\001\255\255\255\255\255\255\075\001\255\255\255\255\
\255\255\255\255\255\255\255\255\082\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\093\001\
\094\001\255\255\096\001\097\001\098\001\099\001\255\255\000\001\
\255\255\002\001\003\001\004\001\255\255\255\255\000\000\008\001\
\110\001\255\255\255\255\113\001\013\001\255\255\255\255\117\001\
\017\001\018\001\019\001\255\255\255\255\255\255\255\255\255\255\
\255\255\026\001\027\001\028\001\029\001\255\255\255\255\255\255\
\255\255\255\255\255\255\036\001\255\255\255\255\255\255\255\255\
\041\001\255\255\255\255\255\255\255\255\255\255\047\001\048\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\000\000\255\255\255\255\255\255\061\001\255\255\255\255\064\001\
\255\255\255\255\067\001\068\001\069\001\255\255\071\001\255\255\
\255\255\255\255\075\001\255\255\255\255\255\255\255\255\255\255\
\255\255\082\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\093\001\094\001\255\255\096\001\
\097\001\098\001\099\001\255\255\255\255\255\255\000\001\255\255\
\002\001\003\001\004\001\255\255\255\255\110\001\008\001\255\255\
\113\001\255\255\255\255\013\001\117\001\255\255\255\255\017\001\
\018\001\019\001\255\255\255\255\255\255\255\255\255\255\255\255\
\026\001\027\001\028\001\029\001\255\255\255\255\255\255\255\255\
\255\255\255\255\036\001\255\255\255\255\255\255\255\255\041\001\
\255\255\255\255\255\255\255\255\255\255\047\001\048\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\061\001\255\255\255\255\064\001\255\255\
\255\255\067\001\068\001\069\001\000\000\071\001\255\255\255\255\
\255\255\075\001\255\255\255\255\255\255\255\255\255\255\255\255\
\082\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\093\001\094\001\255\255\096\001\097\001\
\098\001\099\001\255\255\000\001\255\255\002\001\003\001\004\001\
\255\255\255\255\255\255\008\001\110\001\255\255\255\255\113\001\
\013\001\255\255\255\255\117\001\017\001\018\001\019\001\255\255\
\255\255\255\255\255\255\255\255\255\255\026\001\027\001\028\001\
\029\001\255\255\255\255\255\255\255\255\255\255\255\255\036\001\
\255\255\255\255\255\255\255\255\041\001\255\255\255\255\255\255\
\255\255\255\255\047\001\048\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\000\001\255\255\
\061\001\003\001\255\255\064\001\255\255\255\255\067\001\068\001\
\069\001\255\255\071\001\013\001\255\255\255\255\075\001\255\255\
\255\255\019\001\255\255\255\255\000\000\082\001\255\255\255\255\
\026\001\027\001\028\001\029\001\255\255\255\255\255\255\255\255\
\093\001\094\001\255\255\096\001\097\001\098\001\099\001\041\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\000\001\110\001\255\255\003\001\113\001\255\255\255\255\255\255\
\117\001\255\255\255\255\061\001\255\255\013\001\064\001\255\255\
\255\255\255\255\068\001\069\001\255\255\255\255\255\255\255\255\
\255\255\075\001\026\001\027\001\028\001\029\001\255\255\255\255\
\082\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\041\001\255\255\255\255\094\001\255\255\096\001\255\255\
\098\001\099\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\110\001\061\001\255\255\113\001\
\064\001\255\255\255\255\117\001\068\001\069\001\255\255\255\255\
\255\255\255\255\255\255\075\001\255\255\255\255\255\255\000\000\
\255\255\255\255\082\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\094\001\255\255\
\096\001\255\255\098\001\099\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\110\001\255\255\
\255\255\113\001\255\255\255\255\000\001\117\001\255\255\003\001\
\255\255\005\001\006\001\007\001\008\001\255\255\255\255\011\001\
\012\001\013\001\255\255\255\255\255\255\255\255\255\255\019\001\
\255\255\255\255\255\255\255\255\255\255\255\255\026\001\255\255\
\028\001\029\001\030\001\031\001\032\001\033\001\034\001\255\255\
\036\001\255\255\255\255\039\001\255\255\041\001\255\255\255\255\
\255\255\255\255\255\255\047\001\048\001\049\001\050\001\051\001\
\052\001\053\001\054\001\055\001\056\001\057\001\255\255\255\255\
\060\001\061\001\255\255\255\255\064\001\065\001\066\001\255\255\
\068\001\069\001\070\001\071\001\072\001\073\001\255\255\075\001\
\076\001\077\001\078\001\000\000\080\001\255\255\082\001\083\001\
\255\255\255\255\086\001\087\001\255\255\089\001\255\255\091\001\
\255\255\093\001\094\001\095\001\255\255\097\001\098\001\099\001\
\255\255\255\255\255\255\103\001\255\255\255\255\106\001\255\255\
\108\001\109\001\110\001\111\001\112\001\113\001\255\255\255\255\
\116\001\005\001\006\001\007\001\255\255\255\255\255\255\011\001\
\012\001\013\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\028\001\029\001\030\001\031\001\032\001\033\001\034\001\255\255\
\255\255\255\255\255\255\039\001\255\255\041\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\049\001\050\001\051\001\
\255\255\053\001\054\001\055\001\056\001\057\001\255\255\255\255\
\060\001\061\001\255\255\255\255\064\001\065\001\066\001\255\255\
\255\255\069\001\070\001\255\255\072\001\073\001\255\255\075\001\
\255\255\077\001\078\001\255\255\080\001\000\000\082\001\255\255\
\255\255\255\255\086\001\087\001\255\255\089\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\098\001\099\001\
\255\255\255\255\255\255\103\001\255\255\255\255\255\255\255\255\
\108\001\109\001\110\001\111\001\005\001\006\001\007\001\255\255\
\116\001\255\255\011\001\012\001\013\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\028\001\029\001\030\001\031\001\032\001\
\033\001\034\001\255\255\255\255\255\255\255\255\039\001\255\255\
\041\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\049\001\050\001\051\001\255\255\053\001\054\001\055\001\056\001\
\057\001\255\255\255\255\060\001\061\001\255\255\255\255\064\001\
\065\001\066\001\255\255\255\255\069\001\070\001\255\255\072\001\
\073\001\255\255\075\001\255\255\077\001\078\001\255\255\080\001\
\255\255\082\001\255\255\255\255\255\255\086\001\087\001\000\000\
\089\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\099\001\255\255\255\255\255\255\103\001\255\255\
\255\255\255\255\255\255\108\001\109\001\110\001\111\001\255\255\
\255\255\255\255\255\255\116\001\255\255\255\255\255\255\255\255\
\005\001\006\001\007\001\255\255\255\255\255\255\011\001\012\001\
\013\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\028\001\
\029\001\030\001\031\001\032\001\033\001\034\001\255\255\255\255\
\255\255\255\255\039\001\255\255\041\001\255\255\255\255\255\255\
\255\255\255\255\255\255\000\000\049\001\050\001\051\001\255\255\
\053\001\054\001\055\001\056\001\057\001\255\255\255\255\060\001\
\061\001\255\255\255\255\064\001\065\001\066\001\255\255\255\255\
\069\001\070\001\255\255\072\001\073\001\255\255\075\001\255\255\
\077\001\078\001\255\255\080\001\255\255\082\001\255\255\255\255\
\255\255\086\001\087\001\255\255\089\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\099\001\255\255\
\255\255\255\255\103\001\255\255\255\255\255\255\000\000\108\001\
\109\001\110\001\111\001\255\255\255\255\000\001\255\255\116\001\
\255\255\004\001\255\255\006\001\255\255\008\001\255\255\010\001\
\255\255\012\001\013\001\014\001\015\001\255\255\017\001\018\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\026\001\
\027\001\028\001\029\001\030\001\031\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\041\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\049\001\050\001\
\051\001\052\001\053\001\054\001\255\255\056\001\057\001\255\255\
\255\255\060\001\061\001\255\255\255\255\064\001\065\001\066\001\
\067\001\068\001\069\001\255\255\000\000\072\001\255\255\074\001\
\075\001\255\255\077\001\255\255\255\255\255\255\255\255\082\001\
\083\001\255\255\255\255\086\001\255\255\255\255\255\255\255\255\
\091\001\255\255\093\001\094\001\255\255\096\001\097\001\098\001\
\099\001\255\255\255\255\255\255\103\001\255\255\255\255\106\001\
\255\255\108\001\255\255\110\001\111\001\112\001\255\255\000\001\
\115\001\255\255\255\255\004\001\255\255\006\001\255\255\008\001\
\255\255\010\001\255\255\012\001\255\255\014\001\015\001\000\000\
\017\001\018\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\027\001\255\255\255\255\030\001\031\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\049\001\050\001\051\001\052\001\255\255\054\001\255\255\056\001\
\057\001\255\255\255\255\060\001\255\255\255\255\255\255\255\255\
\065\001\066\001\067\001\255\255\255\255\255\255\255\255\072\001\
\255\255\074\001\000\000\000\001\077\001\255\255\003\001\004\001\
\255\255\255\255\083\001\255\255\255\255\086\001\255\255\255\255\
\013\001\014\001\091\001\255\255\093\001\094\001\019\001\096\001\
\097\001\255\255\099\001\255\255\255\255\026\001\103\001\028\001\
\029\001\106\001\255\255\108\001\255\255\255\255\111\001\112\001\
\255\255\255\255\115\001\255\255\041\001\255\255\255\255\255\255\
\255\255\255\255\047\001\048\001\000\000\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\000\001\255\255\
\061\001\003\001\004\001\064\001\255\255\255\255\067\001\068\001\
\069\001\255\255\071\001\013\001\014\001\255\255\075\001\255\255\
\255\255\019\001\255\255\255\255\255\255\082\001\255\255\255\255\
\026\001\255\255\028\001\029\001\255\255\255\255\255\255\255\255\
\255\255\094\001\255\255\096\001\255\255\098\001\099\001\041\001\
\255\255\255\255\255\255\255\255\255\255\047\001\048\001\000\000\
\255\255\110\001\255\255\255\255\113\001\255\255\255\255\255\255\
\255\255\255\255\255\255\061\001\255\255\255\255\064\001\255\255\
\255\255\067\001\068\001\069\001\255\255\071\001\255\255\255\255\
\255\255\075\001\255\255\255\255\000\001\255\255\255\255\003\001\
\082\001\255\255\255\255\255\255\008\001\255\255\255\255\255\255\
\255\255\013\001\014\001\255\255\094\001\255\255\096\001\019\001\
\098\001\099\001\022\001\255\255\255\255\255\255\026\001\255\255\
\028\001\029\001\000\000\255\255\110\001\255\255\255\255\113\001\
\255\255\255\255\255\255\255\255\056\001\041\001\058\001\059\001\
\060\001\255\255\062\001\255\255\255\255\065\001\066\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\000\001\
\255\255\061\001\003\001\004\001\064\001\255\255\066\001\067\001\
\068\001\069\001\255\255\255\255\013\001\014\001\255\255\075\001\
\092\001\255\255\019\001\255\255\255\255\081\001\082\001\099\001\
\255\255\026\001\255\255\028\001\029\001\255\255\000\000\255\255\
\255\255\255\255\094\001\111\001\112\001\255\255\098\001\099\001\
\041\001\255\255\255\255\255\255\255\255\255\255\047\001\048\001\
\255\255\255\255\110\001\255\255\255\255\113\001\255\255\255\255\
\255\255\255\255\000\001\255\255\061\001\003\001\004\001\064\001\
\255\255\255\255\255\255\068\001\069\001\255\255\071\001\013\001\
\014\001\255\255\075\001\255\255\255\255\019\001\255\255\255\255\
\255\255\082\001\255\255\255\255\026\001\000\000\028\001\029\001\
\255\255\255\255\255\255\255\255\255\255\094\001\255\255\096\001\
\255\255\098\001\099\001\041\001\255\255\255\255\255\255\255\255\
\255\255\047\001\048\001\255\255\000\001\110\001\255\255\003\001\
\113\001\255\255\255\255\255\255\255\255\255\255\255\255\061\001\
\255\255\013\001\064\001\255\255\255\255\255\255\068\001\069\001\
\255\255\071\001\255\255\255\255\255\255\075\001\026\001\027\001\
\028\001\029\001\255\255\255\255\082\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\041\001\255\255\255\255\
\094\001\255\255\096\001\255\255\098\001\099\001\255\255\255\255\
\255\255\000\000\255\255\255\255\255\255\255\255\255\255\000\001\
\110\001\061\001\003\001\113\001\255\255\065\001\255\255\067\001\
\068\001\069\001\000\000\255\255\013\001\255\255\074\001\075\001\
\255\255\255\255\255\255\255\255\255\255\255\255\082\001\255\255\
\255\255\026\001\027\001\028\001\029\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\096\001\255\255\098\001\099\001\
\041\001\255\255\102\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\110\001\111\001\255\255\113\001\255\255\255\255\
\255\255\255\255\000\001\255\255\061\001\003\001\255\255\255\255\
\065\001\255\255\067\001\068\001\069\001\255\255\255\255\013\001\
\255\255\074\001\075\001\255\255\255\255\255\255\255\255\255\255\
\255\255\082\001\255\255\255\255\026\001\027\001\028\001\029\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\096\001\
\255\255\098\001\099\001\041\001\255\255\102\001\000\000\255\255\
\255\255\255\255\255\255\255\255\255\255\110\001\111\001\255\255\
\113\001\255\255\255\255\255\255\255\255\255\255\000\001\061\001\
\255\255\003\001\255\255\065\001\255\255\067\001\068\001\069\001\
\255\255\255\255\255\255\013\001\074\001\075\001\255\255\255\255\
\255\255\019\001\255\255\255\255\082\001\255\255\255\255\255\255\
\026\001\255\255\028\001\029\001\255\255\255\255\255\255\255\255\
\255\255\255\255\096\001\255\255\098\001\099\001\040\001\041\001\
\102\001\255\255\255\255\255\255\255\255\047\001\048\001\255\255\
\110\001\111\001\255\255\113\001\255\255\000\001\255\255\255\255\
\003\001\255\255\255\255\061\001\000\000\008\001\064\001\255\255\
\255\255\255\255\013\001\069\001\255\255\071\001\000\000\255\255\
\019\001\075\001\255\255\255\255\255\255\255\255\255\255\026\001\
\082\001\028\001\029\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\094\001\255\255\041\001\255\255\
\098\001\099\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\110\001\255\255\255\255\113\001\
\255\255\255\255\061\001\255\255\255\255\064\001\255\255\255\255\
\067\001\068\001\069\001\255\255\255\255\255\255\255\255\074\001\
\075\001\000\001\255\255\255\255\003\001\255\255\255\255\082\001\
\255\255\008\001\000\000\255\255\255\255\255\255\013\001\255\255\
\255\255\255\255\000\001\094\001\019\001\003\001\255\255\098\001\
\099\001\255\255\008\001\026\001\255\255\028\001\029\001\013\001\
\255\255\255\255\255\255\110\001\255\255\019\001\113\001\255\255\
\255\255\255\255\041\001\255\255\026\001\255\255\028\001\029\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\041\001\000\000\255\255\061\001\255\255\
\255\255\064\001\255\255\255\255\067\001\068\001\069\001\255\255\
\255\255\255\255\255\255\074\001\075\001\255\255\255\255\061\001\
\255\255\255\255\064\001\082\001\000\000\067\001\068\001\069\001\
\255\255\255\255\255\255\255\255\074\001\075\001\255\255\094\001\
\255\255\255\255\255\255\098\001\082\001\255\255\255\255\102\001\
\255\255\255\255\255\255\255\255\255\255\255\255\000\001\110\001\
\094\001\003\001\113\001\255\255\098\001\255\255\008\001\255\255\
\102\001\255\255\255\255\013\001\255\255\255\255\255\255\255\255\
\110\001\019\001\255\255\113\001\255\255\255\255\000\000\255\255\
\026\001\255\255\028\001\029\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\041\001\
\255\255\255\255\056\001\255\255\058\001\059\001\060\001\255\255\
\062\001\255\255\255\255\065\001\066\001\255\255\255\255\255\255\
\255\255\255\255\255\255\061\001\255\255\075\001\064\001\255\255\
\255\255\067\001\068\001\069\001\255\255\083\001\255\255\255\255\
\074\001\075\001\255\255\255\255\000\001\091\001\092\001\003\001\
\082\001\000\000\096\001\255\255\008\001\099\001\000\001\255\255\
\255\255\013\001\255\255\255\255\094\001\255\255\255\255\019\001\
\098\001\111\001\112\001\013\001\102\001\255\255\026\001\255\255\
\028\001\029\001\255\255\255\255\110\001\255\255\255\255\113\001\
\026\001\255\255\028\001\029\001\255\255\041\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\041\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\061\001\255\255\255\255\064\001\000\000\255\255\067\001\
\068\001\069\001\255\255\061\001\255\255\255\255\074\001\075\001\
\255\255\255\255\000\001\069\001\255\255\003\001\082\001\255\255\
\255\255\075\001\008\001\255\255\255\255\255\255\255\255\013\001\
\082\001\255\255\094\001\255\255\255\255\019\001\098\001\255\255\
\255\255\255\255\102\001\255\255\026\001\255\255\028\001\029\001\
\098\001\255\255\110\001\255\255\255\255\113\001\255\255\255\255\
\255\255\255\255\255\255\041\001\110\001\255\255\255\255\113\001\
\000\000\255\255\255\255\255\255\000\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\061\001\
\255\255\013\001\064\001\255\255\255\255\067\001\068\001\069\001\
\255\255\255\255\255\255\255\255\000\001\075\001\026\001\003\001\
\028\001\029\001\255\255\255\255\082\001\255\255\255\255\255\255\
\255\255\013\001\255\255\255\255\255\255\041\001\255\255\019\001\
\094\001\255\255\255\255\255\255\098\001\099\001\026\001\255\255\
\028\001\029\001\255\255\000\000\255\255\255\255\255\255\000\000\
\110\001\061\001\255\255\113\001\255\255\041\001\255\255\255\255\
\255\255\069\001\255\255\255\255\255\255\255\255\000\001\075\001\
\255\255\003\001\255\255\255\255\255\255\255\255\082\001\255\255\
\255\255\061\001\255\255\013\001\064\001\255\255\255\255\255\255\
\068\001\069\001\255\255\255\255\255\255\255\255\098\001\075\001\
\026\001\027\001\028\001\029\001\255\255\255\255\082\001\255\255\
\255\255\255\255\110\001\255\255\088\001\113\001\000\000\041\001\
\255\255\255\255\094\001\255\255\255\255\255\255\098\001\099\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\000\001\110\001\061\001\003\001\113\001\064\001\255\255\
\255\255\008\001\068\001\069\001\255\255\255\255\013\001\255\255\
\255\255\075\001\255\255\255\255\019\001\255\255\255\255\255\255\
\082\001\255\255\255\255\026\001\255\255\028\001\029\001\255\255\
\000\000\255\255\255\255\255\255\094\001\255\255\096\001\255\255\
\098\001\099\001\041\001\255\255\255\255\255\255\255\255\255\255\
\255\255\000\000\255\255\255\255\110\001\255\255\255\255\113\001\
\255\255\255\255\255\255\255\255\255\255\000\001\061\001\255\255\
\003\001\064\001\255\255\255\255\255\255\068\001\069\001\255\255\
\255\255\255\255\013\001\255\255\075\001\255\255\255\255\255\255\
\019\001\255\255\255\255\082\001\255\255\255\255\255\255\026\001\
\255\255\028\001\029\001\255\255\255\255\255\255\255\255\094\001\
\255\255\255\255\255\255\098\001\099\001\255\255\041\001\255\255\
\255\255\255\255\255\255\255\255\000\000\255\255\255\255\110\001\
\255\255\255\255\113\001\255\255\255\255\255\255\255\255\255\255\
\000\001\255\255\061\001\003\001\255\255\064\001\255\255\255\255\
\255\255\068\001\069\001\255\255\255\255\013\001\255\255\255\255\
\075\001\255\255\255\255\019\001\255\255\255\255\255\255\082\001\
\255\255\255\255\026\001\255\255\028\001\029\001\255\255\255\255\
\255\255\255\255\255\255\094\001\255\255\255\255\000\000\098\001\
\099\001\041\001\255\255\255\255\255\255\255\255\255\255\000\000\
\255\255\255\255\255\255\110\001\255\255\255\255\113\001\255\255\
\255\255\255\255\255\255\000\001\255\255\061\001\003\001\000\001\
\064\001\255\255\255\255\255\255\068\001\069\001\255\255\255\255\
\013\001\255\255\255\255\075\001\013\001\255\255\019\001\255\255\
\255\255\255\255\082\001\255\255\255\255\026\001\255\255\028\001\
\029\001\026\001\255\255\028\001\029\001\255\255\094\001\255\255\
\255\255\000\000\098\001\099\001\041\001\255\255\255\255\255\255\
\041\001\255\255\255\255\255\255\255\255\255\255\110\001\255\255\
\255\255\113\001\255\255\255\255\255\255\255\255\000\001\255\255\
\061\001\003\001\255\255\064\001\061\001\255\255\255\255\068\001\
\069\001\255\255\255\255\013\001\069\001\255\255\075\001\255\255\
\255\255\019\001\075\001\255\255\255\255\082\001\255\255\255\255\
\026\001\082\001\028\001\029\001\255\255\255\255\255\255\255\255\
\255\255\094\001\255\255\255\255\000\000\098\001\099\001\041\001\
\255\255\098\001\255\255\255\255\255\255\255\255\255\255\255\255\
\000\001\110\001\255\255\255\255\113\001\110\001\255\255\255\255\
\113\001\255\255\255\255\061\001\255\255\013\001\064\001\255\255\
\255\255\000\001\068\001\069\001\003\001\255\255\255\255\255\255\
\255\255\075\001\026\001\255\255\028\001\029\001\013\001\255\255\
\082\001\000\000\255\255\255\255\019\001\255\255\255\255\255\255\
\255\255\041\001\255\255\026\001\094\001\028\001\029\001\255\255\
\098\001\099\001\255\255\255\255\255\255\255\255\255\255\000\000\
\255\255\255\255\041\001\255\255\110\001\061\001\255\255\113\001\
\255\255\255\255\255\255\255\255\255\255\069\001\255\255\255\255\
\255\255\255\255\255\255\075\001\000\001\255\255\061\001\003\001\
\255\255\064\001\082\001\255\255\255\255\068\001\069\001\255\255\
\255\255\013\001\255\255\255\255\075\001\255\255\255\255\019\001\
\255\255\255\255\098\001\082\001\000\000\255\255\026\001\255\255\
\028\001\029\001\255\255\255\255\255\255\255\255\110\001\094\001\
\255\255\113\001\255\255\098\001\099\001\041\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\000\001\110\001\
\255\255\255\255\113\001\255\255\255\255\255\255\008\001\000\001\
\255\255\061\001\255\255\013\001\064\001\255\255\255\255\255\255\
\068\001\069\001\255\255\255\255\013\001\255\255\000\000\075\001\
\026\001\255\255\028\001\029\001\255\255\255\255\082\001\000\000\
\255\255\026\001\255\255\028\001\029\001\255\255\255\255\041\001\
\255\255\255\255\094\001\255\255\255\255\255\255\098\001\099\001\
\041\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\000\001\110\001\061\001\255\255\113\001\064\001\255\255\
\255\255\255\255\068\001\069\001\061\001\255\255\013\001\064\001\
\255\255\075\001\255\255\068\001\069\001\255\255\255\255\255\255\
\082\001\255\255\075\001\026\001\255\255\028\001\029\001\255\255\
\255\255\082\001\255\255\255\255\094\001\255\255\255\255\255\255\
\098\001\099\001\041\001\255\255\255\255\094\001\255\255\255\255\
\255\255\098\001\099\001\255\255\110\001\000\000\255\255\113\001\
\255\255\255\255\255\255\255\255\000\001\110\001\061\001\003\001\
\113\001\064\001\255\255\255\255\255\255\068\001\069\001\255\255\
\255\255\013\001\255\255\000\000\075\001\255\255\255\255\255\255\
\255\255\255\255\255\255\082\001\255\255\255\255\026\001\255\255\
\028\001\029\001\255\255\255\255\255\255\255\255\255\255\094\001\
\255\255\000\000\255\255\098\001\099\001\041\001\255\255\255\255\
\255\255\000\001\255\255\255\255\255\255\255\255\255\255\110\001\
\255\255\255\255\113\001\255\255\255\255\255\255\013\001\255\255\
\255\255\061\001\255\255\255\255\064\001\255\255\255\255\000\001\
\255\255\069\001\003\001\026\001\255\255\028\001\029\001\075\001\
\255\255\255\255\255\255\255\255\013\001\255\255\082\001\255\255\
\255\255\255\255\041\001\255\255\255\255\255\255\255\255\255\255\
\255\255\026\001\094\001\028\001\029\001\255\255\098\001\099\001\
\255\255\255\255\255\255\255\255\255\255\255\255\061\001\040\001\
\041\001\064\001\110\001\255\255\000\001\113\001\069\001\003\001\
\000\000\255\255\255\255\255\255\075\001\255\255\255\255\255\255\
\255\255\013\001\000\000\082\001\061\001\255\255\255\255\064\001\
\255\255\255\255\255\255\068\001\069\001\255\255\026\001\094\001\
\028\001\029\001\075\001\098\001\099\001\255\255\255\255\255\255\
\255\255\082\001\255\255\255\255\040\001\041\001\255\255\110\001\
\255\255\255\255\113\001\255\255\255\255\094\001\000\001\255\255\
\255\255\098\001\099\001\255\255\255\255\255\255\008\001\000\001\
\255\255\061\001\255\255\013\001\064\001\110\001\255\255\255\255\
\068\001\069\001\255\255\255\255\013\001\255\255\255\255\075\001\
\026\001\255\255\028\001\029\001\255\255\000\000\082\001\255\255\
\255\255\026\001\255\255\028\001\029\001\255\255\255\255\041\001\
\255\255\255\255\094\001\255\255\255\255\255\255\098\001\099\001\
\041\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\110\001\061\001\255\255\255\255\064\001\255\255\
\255\255\067\001\068\001\069\001\061\001\255\255\255\255\064\001\
\255\255\075\001\067\001\068\001\069\001\255\255\255\255\000\000\
\082\001\255\255\075\001\255\255\255\255\000\001\255\255\255\255\
\003\001\082\001\255\255\255\255\094\001\255\255\255\255\255\255\
\098\001\099\001\013\001\255\255\255\255\094\001\255\255\255\255\
\255\255\098\001\099\001\000\001\110\001\255\255\003\001\026\001\
\255\255\028\001\029\001\255\255\255\255\110\001\000\000\255\255\
\013\001\255\255\255\255\255\255\255\255\040\001\041\001\255\255\
\255\255\000\001\255\255\255\255\003\001\026\001\255\255\028\001\
\029\001\255\255\255\255\255\255\255\255\255\255\013\001\255\255\
\255\255\255\255\061\001\255\255\041\001\064\001\255\255\255\255\
\255\255\255\255\069\001\026\001\255\255\028\001\029\001\255\255\
\075\001\255\255\000\000\255\255\255\255\255\255\255\255\082\001\
\061\001\255\255\041\001\064\001\255\255\255\255\255\255\068\001\
\069\001\255\255\255\255\094\001\255\255\255\255\075\001\098\001\
\099\001\255\255\255\255\255\255\255\255\082\001\061\001\255\255\
\255\255\064\001\255\255\110\001\255\255\068\001\069\001\255\255\
\255\255\094\001\255\255\255\255\075\001\098\001\099\001\000\000\
\000\001\255\255\255\255\082\001\255\255\255\255\255\255\255\255\
\008\001\110\001\000\001\255\255\255\255\013\001\255\255\094\001\
\255\255\255\255\255\255\098\001\099\001\000\000\255\255\013\001\
\255\255\255\255\026\001\255\255\028\001\029\001\000\000\110\001\
\255\255\255\255\255\255\255\255\026\001\255\255\028\001\029\001\
\255\255\041\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\041\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\061\001\255\255\255\255\
\064\001\255\255\255\255\255\255\068\001\069\001\255\255\061\001\
\255\255\255\255\064\001\075\001\255\255\000\001\068\001\069\001\
\003\001\255\255\082\001\255\255\255\255\075\001\255\255\255\255\
\255\255\255\255\013\001\255\255\082\001\255\255\094\001\255\255\
\255\255\255\255\098\001\099\001\255\255\255\255\255\255\026\001\
\094\001\028\001\029\001\255\255\098\001\099\001\110\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\041\001\255\255\
\110\001\255\255\056\001\255\255\058\001\059\001\060\001\000\001\
\062\001\255\255\255\255\065\001\066\001\255\255\255\255\255\255\
\255\255\255\255\061\001\255\255\013\001\064\001\255\255\255\255\
\255\255\255\255\069\001\255\255\255\255\083\001\255\255\255\255\
\075\001\026\001\255\255\028\001\029\001\091\001\092\001\082\001\
\255\255\255\255\255\255\255\255\255\255\099\001\000\001\255\255\
\041\001\255\255\255\255\094\001\255\255\255\255\255\255\098\001\
\099\001\111\001\112\001\013\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\110\001\061\001\255\255\255\255\064\001\
\026\001\255\255\028\001\029\001\069\001\255\255\255\255\255\255\
\255\255\255\255\075\001\255\255\255\255\255\255\255\255\041\001\
\255\255\082\001\000\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\094\001\255\255\013\001\
\255\255\098\001\099\001\061\001\255\255\255\255\064\001\255\255\
\255\255\255\255\255\255\069\001\026\001\110\001\028\001\029\001\
\255\255\075\001\255\255\255\255\255\255\255\255\255\255\255\255\
\082\001\255\255\255\255\041\001\255\255\255\255\255\255\000\001\
\255\255\255\255\255\255\255\255\094\001\255\255\255\255\255\255\
\098\001\099\001\255\255\255\255\013\001\255\255\255\255\061\001\
\255\255\255\255\064\001\255\255\110\001\000\001\255\255\069\001\
\255\255\026\001\255\255\028\001\029\001\075\001\000\001\255\255\
\255\255\255\255\013\001\255\255\082\001\255\255\255\255\255\255\
\041\001\255\255\255\255\013\001\255\255\255\255\255\255\026\001\
\094\001\028\001\029\001\255\255\098\001\099\001\255\255\255\255\
\026\001\255\255\028\001\029\001\061\001\255\255\041\001\064\001\
\110\001\255\255\255\255\255\255\069\001\255\255\255\255\041\001\
\255\255\255\255\075\001\255\255\255\255\255\255\255\255\255\255\
\255\255\082\001\061\001\255\255\255\255\064\001\255\255\255\255\
\255\255\255\255\069\001\061\001\255\255\094\001\064\001\255\255\
\075\001\098\001\099\001\069\001\255\255\255\255\255\255\082\001\
\255\255\075\001\255\255\255\255\255\255\110\001\255\255\255\255\
\082\001\255\255\255\255\094\001\255\255\255\255\255\255\098\001\
\099\001\255\255\255\255\255\255\094\001\255\255\255\255\255\255\
\098\001\099\001\000\001\110\001\255\255\255\255\255\255\005\001\
\006\001\007\001\008\001\255\255\110\001\011\001\012\001\013\001\
\014\001\255\255\255\255\255\255\255\255\019\001\255\255\255\255\
\255\255\255\255\255\255\255\255\026\001\255\255\028\001\029\001\
\030\001\031\001\032\001\033\001\034\001\255\255\255\255\255\255\
\255\255\039\001\255\255\041\001\255\255\255\255\255\255\255\255\
\255\255\047\001\048\001\049\001\050\001\051\001\052\001\053\001\
\054\001\055\001\056\001\057\001\255\255\255\255\060\001\061\001\
\255\255\255\255\064\001\065\001\066\001\067\001\255\255\069\001\
\070\001\071\001\072\001\073\001\255\255\075\001\255\255\077\001\
\078\001\255\255\080\001\255\255\082\001\083\001\255\255\255\255\
\086\001\087\001\255\255\089\001\255\255\091\001\255\255\255\255\
\094\001\095\001\255\255\255\255\098\001\099\001\255\255\255\255\
\255\255\103\001\255\255\255\255\106\001\255\255\108\001\109\001\
\110\001\111\001\112\001\113\001\255\255\255\255\116\001\000\001\
\001\001\002\001\255\255\255\255\005\001\006\001\007\001\255\255\
\009\001\255\255\011\001\012\001\255\255\255\255\015\001\016\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\027\001\255\255\255\255\030\001\031\001\032\001\
\033\001\034\001\255\255\036\001\255\255\255\255\039\001\255\255\
\255\255\042\001\043\001\044\001\045\001\046\001\255\255\255\255\
\049\001\050\001\051\001\255\255\053\001\054\001\055\001\056\001\
\057\001\255\255\255\255\060\001\255\255\062\001\255\255\064\001\
\065\001\066\001\255\255\255\255\255\255\070\001\255\255\072\001\
\073\001\255\255\075\001\255\255\077\001\078\001\255\255\080\001\
\255\255\255\255\255\255\084\001\085\001\086\001\087\001\088\001\
\089\001\255\255\255\255\255\255\255\255\255\255\255\255\096\001\
\255\255\255\255\255\255\100\001\255\255\102\001\103\001\255\255\
\255\255\255\255\255\255\108\001\109\001\255\255\111\001\000\001\
\001\001\002\001\255\255\116\001\005\001\006\001\007\001\255\255\
\009\001\255\255\011\001\012\001\255\255\255\255\255\255\016\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\027\001\255\255\255\255\030\001\031\001\032\001\
\033\001\034\001\255\255\036\001\255\255\255\255\039\001\255\255\
\255\255\042\001\043\001\044\001\045\001\046\001\255\255\255\255\
\049\001\050\001\051\001\255\255\053\001\054\001\055\001\056\001\
\057\001\255\255\255\255\060\001\255\255\062\001\255\255\064\001\
\065\001\066\001\255\255\255\255\255\255\070\001\255\255\072\001\
\073\001\255\255\075\001\255\255\077\001\078\001\255\255\080\001\
\255\255\255\255\255\255\084\001\085\001\086\001\087\001\088\001\
\089\001\255\255\255\255\255\255\255\255\255\255\255\255\096\001\
\255\255\255\255\255\255\100\001\255\255\102\001\103\001\255\255\
\255\255\255\255\255\255\108\001\109\001\255\255\111\001\000\001\
\001\001\002\001\255\255\116\001\005\001\006\001\007\001\255\255\
\009\001\255\255\011\001\012\001\255\255\255\255\255\255\016\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\027\001\255\255\255\255\030\001\031\001\032\001\
\033\001\034\001\255\255\036\001\255\255\255\255\039\001\255\255\
\255\255\042\001\043\001\044\001\045\001\046\001\255\255\255\255\
\049\001\050\001\051\001\255\255\053\001\054\001\055\001\056\001\
\057\001\255\255\255\255\060\001\255\255\062\001\255\255\064\001\
\065\001\066\001\255\255\255\255\255\255\070\001\255\255\072\001\
\073\001\255\255\075\001\255\255\077\001\078\001\255\255\080\001\
\255\255\255\255\255\255\084\001\085\001\086\001\087\001\088\001\
\089\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\100\001\255\255\102\001\103\001\255\255\
\255\255\255\255\000\001\108\001\109\001\255\255\111\001\005\001\
\006\001\007\001\008\001\116\001\255\255\011\001\012\001\255\255\
\255\255\255\255\255\255\255\255\255\255\019\001\255\255\255\255\
\255\255\255\255\255\255\255\255\026\001\255\255\028\001\255\255\
\030\001\031\001\032\001\033\001\034\001\255\255\255\255\255\255\
\255\255\039\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\047\001\048\001\049\001\050\001\051\001\052\001\053\001\
\054\001\055\001\056\001\057\001\255\255\255\255\060\001\061\001\
\255\255\255\255\064\001\065\001\066\001\255\255\255\255\069\001\
\070\001\071\001\072\001\073\001\255\255\255\255\255\255\077\001\
\078\001\255\255\080\001\255\255\255\255\083\001\255\255\255\255\
\086\001\087\001\255\255\089\001\255\255\091\001\255\255\255\255\
\255\255\095\001\255\255\255\255\255\255\099\001\255\255\255\255\
\255\255\103\001\255\255\255\255\106\001\255\255\108\001\109\001\
\255\255\111\001\112\001\113\001\000\001\255\255\116\001\255\255\
\255\255\005\001\006\001\007\001\255\255\255\255\255\255\011\001\
\012\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\030\001\031\001\032\001\033\001\034\001\255\255\
\255\255\255\255\255\255\039\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\049\001\050\001\051\001\
\255\255\053\001\054\001\055\001\056\001\057\001\255\255\255\255\
\060\001\255\255\255\255\255\255\064\001\065\001\066\001\255\255\
\255\255\255\255\070\001\255\255\072\001\073\001\255\255\255\255\
\255\255\077\001\078\001\255\255\080\001\255\255\255\255\255\255\
\255\255\255\255\086\001\087\001\000\001\089\001\255\255\255\255\
\255\255\005\001\006\001\007\001\096\001\255\255\255\255\011\001\
\012\001\255\255\255\255\103\001\255\255\255\255\255\255\255\255\
\108\001\109\001\255\255\111\001\255\255\255\255\255\255\255\255\
\116\001\255\255\030\001\031\001\032\001\033\001\034\001\255\255\
\255\255\255\255\255\255\039\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\049\001\050\001\051\001\
\255\255\053\001\054\001\055\001\056\001\057\001\255\255\255\255\
\060\001\255\255\255\255\255\255\064\001\065\001\066\001\255\255\
\255\255\255\255\070\001\255\255\072\001\073\001\255\255\255\255\
\255\255\077\001\078\001\255\255\080\001\255\255\255\255\255\255\
\255\255\255\255\086\001\087\001\000\001\089\001\255\255\255\255\
\255\255\005\001\006\001\007\001\096\001\255\255\255\255\011\001\
\012\001\255\255\255\255\103\001\255\255\255\255\255\255\255\255\
\108\001\109\001\255\255\111\001\255\255\255\255\255\255\255\255\
\116\001\255\255\030\001\031\001\032\001\033\001\034\001\255\255\
\255\255\255\255\255\255\039\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\049\001\050\001\051\001\
\255\255\053\001\054\001\055\001\056\001\057\001\255\255\255\255\
\060\001\255\255\255\255\255\255\064\001\065\001\066\001\255\255\
\255\255\255\255\070\001\255\255\072\001\073\001\255\255\255\255\
\255\255\077\001\078\001\255\255\080\001\255\255\255\255\255\255\
\255\255\255\255\086\001\087\001\000\001\089\001\255\255\255\255\
\255\255\005\001\006\001\007\001\096\001\255\255\255\255\011\001\
\012\001\255\255\255\255\103\001\255\255\255\255\255\255\255\255\
\108\001\109\001\255\255\111\001\255\255\255\255\255\255\255\255\
\116\001\255\255\030\001\031\001\032\001\033\001\034\001\255\255\
\255\255\255\255\255\255\039\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\049\001\050\001\051\001\
\255\255\053\001\054\001\055\001\056\001\057\001\255\255\255\255\
\060\001\255\255\255\255\255\255\064\001\065\001\066\001\255\255\
\255\255\255\255\070\001\255\255\072\001\073\001\255\255\255\255\
\255\255\077\001\078\001\255\255\080\001\255\255\255\255\255\255\
\255\255\255\255\086\001\087\001\255\255\089\001\255\255\255\255\
\255\255\255\255\255\255\255\255\096\001\003\001\004\001\005\001\
\255\255\255\255\255\255\103\001\255\255\011\001\255\255\013\001\
\108\001\109\001\255\255\111\001\255\255\019\001\020\001\021\001\
\116\001\255\255\024\001\025\001\026\001\255\255\028\001\029\001\
\030\001\255\255\032\001\033\001\034\001\035\001\255\255\255\255\
\255\255\039\001\040\001\041\001\255\255\255\255\255\255\255\255\
\255\255\047\001\048\001\255\255\255\255\255\255\255\255\053\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\064\001\065\001\255\255\255\255\255\255\255\255\
\070\001\071\001\255\255\255\255\255\255\075\001\076\001\255\255\
\078\001\255\255\080\001\081\001\082\001\255\255\084\001\255\255\
\255\255\255\255\255\255\255\255\090\001\255\255\255\255\255\255\
\255\255\095\001\255\255\255\255\255\255\255\255\255\255\101\001\
\000\001\255\255\104\001\105\001\004\001\107\001\108\001\109\001\
\110\001\111\001\255\255\113\001\114\001\115\001\116\001\117\001\
\255\255\017\001\255\255\019\001\255\255\255\255\022\001\255\255\
\255\255\255\255\026\001\027\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\036\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\047\001\
\048\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\061\001\255\255\255\255\
\255\255\065\001\255\255\067\001\068\001\069\001\255\255\071\001\
\255\255\255\255\074\001\255\255\255\255\255\255\255\255\000\001\
\001\001\002\001\255\255\255\255\255\255\006\001\007\001\255\255\
\009\001\255\255\255\255\012\001\092\001\093\001\015\001\016\001\
\255\255\097\001\255\255\099\001\255\255\255\255\102\001\255\255\
\255\255\255\255\027\001\028\001\255\255\030\001\031\001\111\001\
\255\255\113\001\255\255\036\001\255\255\255\255\255\255\255\255\
\255\255\042\001\043\001\044\001\045\001\046\001\255\255\255\255\
\049\001\050\001\051\001\255\255\053\001\054\001\255\255\056\001\
\057\001\255\255\255\255\060\001\255\255\062\001\255\255\255\255\
\065\001\066\001\255\255\255\255\255\255\255\255\255\255\072\001\
\073\001\255\255\075\001\255\255\077\001\255\255\255\255\255\255\
\255\255\255\255\255\255\084\001\085\001\086\001\087\001\088\001\
\089\001\255\255\255\255\255\255\255\255\255\255\255\255\096\001\
\255\255\255\255\099\001\100\001\255\255\102\001\103\001\255\255\
\255\255\255\255\255\255\108\001\255\255\255\255\111\001\112\001\
\000\001\001\001\002\001\255\255\255\255\255\255\006\001\007\001\
\255\255\009\001\255\255\255\255\012\001\255\255\255\255\255\255\
\016\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\027\001\028\001\255\255\030\001\031\001\
\255\255\255\255\255\255\255\255\036\001\255\255\255\255\255\255\
\255\255\255\255\042\001\043\001\044\001\045\001\046\001\255\255\
\255\255\049\001\050\001\051\001\255\255\053\001\054\001\255\255\
\056\001\057\001\255\255\255\255\060\001\255\255\062\001\255\255\
\255\255\065\001\066\001\255\255\255\255\255\255\255\255\255\255\
\072\001\073\001\255\255\075\001\255\255\077\001\255\255\255\255\
\255\255\255\255\255\255\255\255\084\001\085\001\086\001\087\001\
\088\001\089\001\255\255\255\255\255\255\255\255\255\255\255\255\
\096\001\255\255\255\255\099\001\100\001\255\255\102\001\103\001\
\255\255\255\255\255\255\255\255\108\001\255\255\110\001\111\001\
\112\001\000\001\001\001\002\001\255\255\255\255\255\255\006\001\
\007\001\255\255\009\001\255\255\255\255\012\001\255\255\255\255\
\255\255\016\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\027\001\028\001\255\255\030\001\
\031\001\255\255\255\255\255\255\255\255\036\001\255\255\255\255\
\255\255\255\255\255\255\042\001\043\001\044\001\045\001\046\001\
\255\255\255\255\049\001\050\001\051\001\255\255\053\001\054\001\
\255\255\056\001\057\001\255\255\255\255\060\001\255\255\062\001\
\255\255\255\255\065\001\066\001\255\255\255\255\255\255\255\255\
\255\255\072\001\073\001\255\255\075\001\255\255\077\001\255\255\
\255\255\255\255\255\255\255\255\255\255\084\001\085\001\086\001\
\087\001\088\001\089\001\255\255\255\255\255\255\255\255\255\255\
\255\255\096\001\255\255\255\255\099\001\100\001\255\255\102\001\
\103\001\255\255\255\255\255\255\255\255\108\001\255\255\110\001\
\111\001\112\001\000\001\001\001\002\001\255\255\255\255\255\255\
\006\001\007\001\255\255\009\001\255\255\255\255\012\001\255\255\
\255\255\255\255\016\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\027\001\028\001\255\255\
\030\001\031\001\255\255\255\255\255\255\255\255\036\001\255\255\
\255\255\255\255\255\255\255\255\042\001\043\001\044\001\045\001\
\046\001\255\255\255\255\049\001\050\001\051\001\255\255\053\001\
\054\001\255\255\056\001\057\001\255\255\255\255\060\001\255\255\
\062\001\255\255\255\255\065\001\066\001\255\255\255\255\255\255\
\255\255\255\255\072\001\073\001\255\255\075\001\255\255\077\001\
\255\255\255\255\255\255\255\255\255\255\255\255\084\001\085\001\
\086\001\087\001\088\001\089\001\255\255\255\255\255\255\255\255\
\255\255\255\255\096\001\255\255\255\255\099\001\100\001\255\255\
\102\001\103\001\255\255\255\255\255\255\255\255\108\001\255\255\
\110\001\111\001\112\001\000\001\001\001\002\001\255\255\255\255\
\255\255\006\001\007\001\255\255\009\001\255\255\255\255\012\001\
\255\255\255\255\255\255\016\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\027\001\028\001\
\255\255\030\001\031\001\255\255\255\255\255\255\255\255\036\001\
\255\255\255\255\255\255\255\255\255\255\042\001\043\001\044\001\
\045\001\046\001\255\255\255\255\049\001\050\001\051\001\255\255\
\053\001\054\001\255\255\056\001\057\001\255\255\255\255\060\001\
\255\255\062\001\255\255\000\001\065\001\066\001\255\255\255\255\
\255\255\006\001\255\255\072\001\073\001\255\255\075\001\012\001\
\077\001\255\255\255\255\255\255\255\255\255\255\255\255\084\001\
\085\001\086\001\087\001\088\001\089\001\255\255\255\255\028\001\
\255\255\030\001\031\001\096\001\255\255\255\255\099\001\100\001\
\255\255\102\001\103\001\255\255\255\255\255\255\255\255\108\001\
\255\255\255\255\111\001\112\001\049\001\050\001\051\001\255\255\
\053\001\054\001\255\255\056\001\057\001\255\255\255\255\060\001\
\255\255\255\255\255\255\000\001\065\001\066\001\255\255\255\255\
\255\255\006\001\255\255\072\001\255\255\255\255\255\255\012\001\
\077\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\086\001\255\255\255\255\255\255\255\255\255\255\028\001\
\255\255\030\001\031\001\255\255\255\255\255\255\099\001\255\255\
\255\255\255\255\103\001\255\255\255\255\255\255\255\255\108\001\
\255\255\255\255\111\001\112\001\049\001\050\001\051\001\255\255\
\053\001\054\001\255\255\056\001\057\001\255\255\255\255\060\001\
\255\255\255\255\255\255\000\001\065\001\066\001\255\255\255\255\
\255\255\006\001\255\255\072\001\255\255\255\255\255\255\012\001\
\077\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\086\001\255\255\255\255\255\255\255\255\255\255\028\001\
\255\255\030\001\031\001\255\255\255\255\255\255\099\001\255\255\
\255\255\255\255\103\001\255\255\255\255\255\255\255\255\108\001\
\255\255\255\255\111\001\112\001\049\001\050\001\051\001\255\255\
\053\001\054\001\255\255\056\001\057\001\255\255\255\255\060\001\
\255\255\255\255\255\255\255\255\065\001\066\001\255\255\255\255\
\255\255\255\255\255\255\072\001\255\255\255\255\255\255\255\255\
\077\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\086\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\099\001\255\255\
\255\255\255\255\103\001\255\255\255\255\255\255\255\255\108\001\
\255\255\255\255\111\001\112\001\005\001\006\001\007\001\255\255\
\255\255\255\255\011\001\012\001\013\001\014\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\028\001\029\001\030\001\031\001\032\001\
\033\001\034\001\255\255\255\255\255\255\255\255\039\001\255\255\
\041\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\049\001\050\001\051\001\255\255\053\001\054\001\055\001\056\001\
\057\001\255\255\255\255\060\001\061\001\255\255\255\255\064\001\
\065\001\066\001\255\255\255\255\069\001\070\001\255\255\072\001\
\073\001\255\255\075\001\255\255\077\001\078\001\255\255\080\001\
\255\255\082\001\255\255\255\255\255\255\086\001\087\001\255\255\
\089\001\255\255\091\001\255\255\255\255\005\001\006\001\007\001\
\255\255\098\001\255\255\011\001\012\001\013\001\103\001\255\255\
\255\255\255\255\255\255\108\001\109\001\110\001\111\001\255\255\
\255\255\255\255\255\255\116\001\028\001\029\001\030\001\031\001\
\032\001\033\001\034\001\255\255\255\255\255\255\255\255\039\001\
\255\255\041\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\049\001\050\001\051\001\255\255\053\001\054\001\055\001\
\056\001\057\001\255\255\255\255\060\001\061\001\255\255\255\255\
\064\001\065\001\066\001\255\255\255\255\069\001\070\001\255\255\
\072\001\073\001\255\255\075\001\255\255\077\001\078\001\255\255\
\080\001\255\255\082\001\255\255\255\255\255\255\086\001\087\001\
\255\255\089\001\255\255\255\255\255\255\005\001\006\001\007\001\
\255\255\255\255\098\001\011\001\012\001\255\255\255\255\103\001\
\255\255\255\255\255\255\255\255\108\001\109\001\110\001\111\001\
\255\255\255\255\255\255\255\255\116\001\255\255\030\001\031\001\
\032\001\033\001\034\001\255\255\255\255\255\255\255\255\039\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\049\001\050\001\051\001\255\255\053\001\054\001\055\001\
\056\001\057\001\255\255\255\255\060\001\255\255\255\255\255\255\
\064\001\065\001\066\001\255\255\255\255\255\255\070\001\255\255\
\072\001\073\001\255\255\255\255\255\255\077\001\078\001\255\255\
\080\001\255\255\255\255\255\255\255\255\255\255\086\001\087\001\
\255\255\089\001\255\255\255\255\255\255\255\255\094\001\005\001\
\006\001\007\001\255\255\255\255\010\001\011\001\012\001\103\001\
\255\255\255\255\255\255\255\255\108\001\109\001\255\255\111\001\
\255\255\255\255\255\255\255\255\116\001\255\255\255\255\255\255\
\030\001\031\001\032\001\033\001\034\001\255\255\255\255\255\255\
\255\255\039\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\049\001\050\001\051\001\255\255\053\001\
\054\001\055\001\056\001\057\001\255\255\255\255\060\001\255\255\
\255\255\255\255\064\001\065\001\066\001\255\255\255\255\255\255\
\070\001\255\255\072\001\073\001\255\255\255\255\255\255\077\001\
\078\001\255\255\080\001\255\255\255\255\255\255\255\255\255\255\
\086\001\087\001\255\255\089\001\255\255\255\255\005\001\006\001\
\007\001\255\255\255\255\255\255\011\001\012\001\255\255\255\255\
\255\255\103\001\255\255\255\255\255\255\255\255\108\001\109\001\
\255\255\111\001\255\255\026\001\255\255\255\255\116\001\030\001\
\031\001\032\001\033\001\034\001\255\255\255\255\255\255\255\255\
\039\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\049\001\050\001\051\001\255\255\053\001\054\001\
\055\001\056\001\057\001\255\255\255\255\060\001\255\255\255\255\
\255\255\064\001\065\001\066\001\255\255\255\255\255\255\070\001\
\255\255\072\001\073\001\255\255\255\255\255\255\077\001\078\001\
\255\255\080\001\255\255\255\255\255\255\255\255\255\255\086\001\
\087\001\255\255\089\001\255\255\255\255\005\001\006\001\007\001\
\255\255\255\255\255\255\011\001\012\001\255\255\255\255\255\255\
\103\001\255\255\255\255\255\255\255\255\108\001\109\001\255\255\
\111\001\255\255\026\001\255\255\255\255\116\001\030\001\031\001\
\032\001\033\001\034\001\255\255\255\255\255\255\255\255\039\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\049\001\050\001\051\001\255\255\053\001\054\001\055\001\
\056\001\057\001\255\255\255\255\060\001\255\255\255\255\255\255\
\064\001\065\001\066\001\255\255\255\255\255\255\070\001\255\255\
\072\001\073\001\255\255\255\255\255\255\077\001\078\001\255\255\
\080\001\255\255\255\255\255\255\255\255\255\255\086\001\087\001\
\255\255\089\001\255\255\255\255\005\001\006\001\007\001\255\255\
\255\255\255\255\011\001\012\001\255\255\255\255\255\255\103\001\
\255\255\255\255\255\255\255\255\108\001\109\001\255\255\111\001\
\255\255\255\255\255\255\255\255\116\001\030\001\031\001\032\001\
\033\001\034\001\255\255\255\255\255\255\255\255\039\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\049\001\050\001\051\001\255\255\053\001\054\001\055\001\056\001\
\057\001\255\255\255\255\060\001\255\255\255\255\255\255\064\001\
\065\001\066\001\255\255\255\255\255\255\070\001\255\255\072\001\
\073\001\255\255\255\255\255\255\077\001\078\001\255\255\080\001\
\255\255\255\255\255\255\255\255\255\255\086\001\087\001\255\255\
\089\001\255\255\255\255\005\001\006\001\007\001\255\255\255\255\
\255\255\011\001\012\001\255\255\255\255\255\255\103\001\255\255\
\255\255\255\255\255\255\108\001\109\001\255\255\111\001\255\255\
\255\255\255\255\255\255\116\001\030\001\031\001\032\001\033\001\
\034\001\255\255\255\255\255\255\255\255\039\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\049\001\
\050\001\051\001\255\255\053\001\054\001\055\001\056\001\057\001\
\255\255\255\255\060\001\255\255\255\255\255\255\064\001\065\001\
\066\001\255\255\255\255\255\255\070\001\255\255\072\001\073\001\
\255\255\255\255\255\255\077\001\078\001\255\255\080\001\255\255\
\255\255\255\255\255\255\255\255\086\001\087\001\255\255\089\001\
\255\255\255\255\255\255\006\001\255\255\255\255\255\255\255\255\
\255\255\012\001\255\255\014\001\255\255\103\001\017\001\255\255\
\255\255\255\255\108\001\109\001\255\255\111\001\255\255\255\255\
\027\001\255\255\116\001\030\001\031\001\056\001\255\255\058\001\
\059\001\060\001\255\255\062\001\255\255\255\255\065\001\066\001\
\255\255\255\255\255\255\255\255\255\255\255\255\049\001\050\001\
\051\001\052\001\255\255\054\001\255\255\056\001\057\001\255\255\
\083\001\060\001\255\255\255\255\255\255\255\255\065\001\066\001\
\091\001\092\001\255\255\255\255\255\255\072\001\006\001\255\255\
\099\001\255\255\077\001\255\255\012\001\255\255\014\001\255\255\
\083\001\017\001\255\255\086\001\111\001\112\001\255\255\255\255\
\091\001\255\255\255\255\027\001\255\255\255\255\030\001\031\001\
\099\001\255\255\255\255\255\255\103\001\255\255\255\255\106\001\
\255\255\108\001\255\255\255\255\111\001\112\001\255\255\255\255\
\255\255\049\001\050\001\051\001\052\001\255\255\054\001\255\255\
\056\001\057\001\255\255\255\255\060\001\255\255\255\255\255\255\
\255\255\065\001\066\001\255\255\255\255\255\255\255\255\255\255\
\072\001\006\001\255\255\255\255\255\255\077\001\255\255\012\001\
\255\255\014\001\255\255\083\001\255\255\255\255\086\001\255\255\
\255\255\255\255\255\255\091\001\255\255\255\255\027\001\255\255\
\255\255\030\001\031\001\099\001\255\255\255\255\255\255\103\001\
\255\255\255\255\106\001\255\255\108\001\255\255\255\255\111\001\
\112\001\255\255\255\255\255\255\049\001\050\001\051\001\052\001\
\255\255\054\001\255\255\056\001\057\001\255\255\255\255\060\001\
\255\255\255\255\255\255\255\255\065\001\066\001\255\255\255\255\
\255\255\255\255\255\255\072\001\006\001\255\255\255\255\255\255\
\077\001\255\255\012\001\255\255\014\001\255\255\083\001\255\255\
\255\255\086\001\255\255\255\255\255\255\255\255\091\001\255\255\
\255\255\027\001\255\255\255\255\030\001\031\001\099\001\255\255\
\255\255\255\255\103\001\255\255\255\255\106\001\255\255\108\001\
\255\255\255\255\111\001\112\001\255\255\255\255\255\255\049\001\
\050\001\051\001\052\001\255\255\054\001\255\255\056\001\057\001\
\255\255\255\255\060\001\255\255\255\255\255\255\255\255\065\001\
\066\001\255\255\255\255\255\255\006\001\255\255\072\001\255\255\
\255\255\255\255\012\001\077\001\255\255\255\255\255\255\255\255\
\255\255\083\001\255\255\255\255\086\001\255\255\255\255\255\255\
\255\255\091\001\255\255\255\255\030\001\031\001\255\255\255\255\
\255\255\099\001\255\255\255\255\255\255\103\001\255\255\255\255\
\106\001\255\255\108\001\255\255\255\255\111\001\112\001\049\001\
\050\001\051\001\052\001\255\255\054\001\255\255\056\001\057\001\
\255\255\255\255\060\001\255\255\255\255\255\255\255\255\065\001\
\066\001\255\255\255\255\255\255\006\001\255\255\072\001\255\255\
\074\001\255\255\012\001\077\001\255\255\255\255\255\255\255\255\
\255\255\083\001\255\255\255\255\086\001\255\255\255\255\255\255\
\255\255\091\001\255\255\255\255\030\001\031\001\255\255\255\255\
\255\255\099\001\255\255\255\255\255\255\103\001\255\255\255\255\
\106\001\255\255\108\001\255\255\255\255\111\001\112\001\049\001\
\050\001\051\001\052\001\255\255\054\001\255\255\056\001\057\001\
\255\255\255\255\060\001\255\255\255\255\255\255\255\255\065\001\
\066\001\255\255\255\255\255\255\006\001\255\255\072\001\255\255\
\074\001\255\255\012\001\077\001\255\255\255\255\255\255\255\255\
\255\255\083\001\255\255\255\255\086\001\255\255\255\255\255\255\
\255\255\091\001\255\255\255\255\030\001\031\001\255\255\255\255\
\255\255\099\001\255\255\255\255\255\255\103\001\255\255\255\255\
\106\001\255\255\108\001\255\255\255\255\111\001\112\001\049\001\
\050\001\051\001\052\001\255\255\054\001\255\255\056\001\057\001\
\255\255\255\255\060\001\255\255\255\255\255\255\255\255\065\001\
\066\001\255\255\255\255\255\255\006\001\255\255\072\001\255\255\
\255\255\255\255\012\001\077\001\255\255\255\255\255\255\255\255\
\255\255\083\001\255\255\255\255\086\001\255\255\255\255\255\255\
\255\255\091\001\255\255\255\255\030\001\031\001\255\255\255\255\
\255\255\099\001\255\255\255\255\255\255\103\001\255\255\255\255\
\106\001\255\255\108\001\255\255\255\255\111\001\112\001\049\001\
\050\001\051\001\052\001\255\255\054\001\255\255\056\001\057\001\
\255\255\255\255\060\001\255\255\255\255\255\255\255\255\065\001\
\066\001\255\255\255\255\255\255\006\001\255\255\072\001\255\255\
\255\255\255\255\012\001\077\001\255\255\255\255\255\255\255\255\
\255\255\083\001\255\255\255\255\086\001\255\255\255\255\255\255\
\255\255\091\001\255\255\255\255\030\001\031\001\255\255\255\255\
\255\255\099\001\255\255\255\255\255\255\103\001\255\255\255\255\
\106\001\255\255\108\001\255\255\255\255\111\001\112\001\049\001\
\050\001\051\001\052\001\255\255\054\001\255\255\056\001\057\001\
\255\255\255\255\060\001\255\255\255\255\255\255\255\255\065\001\
\066\001\255\255\255\255\255\255\006\001\255\255\072\001\255\255\
\255\255\255\255\012\001\077\001\255\255\255\255\255\255\255\255\
\255\255\083\001\255\255\255\255\086\001\255\255\255\255\255\255\
\255\255\091\001\028\001\255\255\030\001\031\001\255\255\255\255\
\255\255\099\001\255\255\255\255\255\255\103\001\255\255\255\255\
\106\001\255\255\108\001\255\255\255\255\111\001\112\001\049\001\
\050\001\051\001\255\255\053\001\054\001\255\255\056\001\057\001\
\255\255\255\255\060\001\255\255\255\255\255\255\255\255\065\001\
\066\001\255\255\255\255\255\255\255\255\255\255\072\001\255\255\
\255\255\255\255\006\001\077\001\255\255\255\255\010\001\255\255\
\012\001\255\255\255\255\255\255\086\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\094\001\255\255\255\255\255\255\
\028\001\099\001\030\001\031\001\255\255\103\001\255\255\255\255\
\255\255\255\255\108\001\255\255\255\255\111\001\112\001\255\255\
\255\255\255\255\255\255\255\255\255\255\049\001\050\001\051\001\
\255\255\053\001\054\001\255\255\056\001\057\001\255\255\255\255\
\060\001\255\255\255\255\255\255\255\255\065\001\066\001\255\255\
\255\255\255\255\255\255\255\255\072\001\006\001\255\255\008\001\
\255\255\077\001\255\255\012\001\255\255\255\255\255\255\255\255\
\255\255\255\255\086\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\028\001\255\255\030\001\031\001\099\001\
\255\255\255\255\255\255\103\001\255\255\255\255\255\255\255\255\
\108\001\255\255\255\255\111\001\112\001\255\255\255\255\255\255\
\049\001\050\001\051\001\255\255\053\001\054\001\255\255\056\001\
\057\001\255\255\255\255\060\001\255\255\255\255\255\255\255\255\
\065\001\066\001\255\255\255\255\255\255\006\001\255\255\072\001\
\255\255\255\255\255\255\012\001\077\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\086\001\255\255\255\255\
\255\255\255\255\255\255\028\001\255\255\030\001\031\001\255\255\
\255\255\255\255\099\001\255\255\255\255\255\255\103\001\255\255\
\255\255\255\255\255\255\108\001\255\255\255\255\111\001\112\001\
\049\001\050\001\051\001\255\255\053\001\054\001\255\255\056\001\
\057\001\255\255\255\255\060\001\255\255\255\255\255\255\255\255\
\065\001\066\001\255\255\255\255\255\255\255\255\255\255\072\001\
\255\255\255\255\255\255\006\001\077\001\255\255\255\255\255\255\
\255\255\012\001\255\255\255\255\255\255\086\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\095\001\255\255\
\255\255\028\001\099\001\030\001\031\001\255\255\103\001\255\255\
\255\255\255\255\255\255\108\001\255\255\255\255\111\001\112\001\
\255\255\255\255\255\255\255\255\255\255\255\255\049\001\050\001\
\051\001\255\255\053\001\054\001\255\255\056\001\057\001\255\255\
\255\255\060\001\255\255\255\255\255\255\255\255\065\001\066\001\
\255\255\255\255\255\255\006\001\255\255\072\001\255\255\255\255\
\255\255\012\001\077\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\086\001\255\255\255\255\255\255\255\255\
\255\255\028\001\255\255\030\001\031\001\255\255\255\255\255\255\
\099\001\255\255\255\255\255\255\103\001\255\255\255\255\255\255\
\255\255\108\001\255\255\255\255\111\001\112\001\049\001\050\001\
\051\001\255\255\053\001\054\001\255\255\056\001\057\001\255\255\
\255\255\060\001\255\255\255\255\255\255\255\255\065\001\066\001\
\255\255\255\255\255\255\006\001\255\255\072\001\255\255\255\255\
\255\255\012\001\077\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\086\001\255\255\255\255\255\255\255\255\
\255\255\028\001\255\255\030\001\031\001\255\255\255\255\255\255\
\099\001\255\255\255\255\255\255\103\001\255\255\255\255\255\255\
\255\255\108\001\255\255\255\255\111\001\112\001\049\001\050\001\
\051\001\255\255\053\001\054\001\255\255\056\001\057\001\255\255\
\255\255\060\001\255\255\255\255\255\255\255\255\065\001\066\001\
\255\255\255\255\255\255\006\001\255\255\072\001\255\255\255\255\
\255\255\012\001\077\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\086\001\255\255\255\255\255\255\255\255\
\255\255\028\001\255\255\030\001\031\001\255\255\255\255\255\255\
\099\001\255\255\255\255\255\255\103\001\255\255\255\255\255\255\
\255\255\108\001\255\255\255\255\111\001\112\001\049\001\050\001\
\051\001\255\255\053\001\054\001\255\255\056\001\057\001\255\255\
\255\255\060\001\255\255\255\255\255\255\255\255\065\001\066\001\
\255\255\255\255\255\255\006\001\255\255\072\001\255\255\255\255\
\255\255\012\001\077\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\086\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\030\001\031\001\255\255\255\255\255\255\
\099\001\255\255\255\255\255\255\103\001\255\255\255\255\255\255\
\255\255\108\001\255\255\255\255\111\001\112\001\049\001\050\001\
\051\001\255\255\255\255\054\001\255\255\056\001\057\001\255\255\
\255\255\060\001\255\255\255\255\255\255\255\255\065\001\066\001\
\255\255\255\255\255\255\255\255\255\255\072\001\006\001\007\001\
\255\255\255\255\077\001\011\001\012\001\255\255\255\255\255\255\
\255\255\255\255\255\255\086\001\255\255\255\255\022\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\030\001\031\001\
\099\001\255\255\255\255\255\255\103\001\255\255\255\255\255\255\
\255\255\108\001\255\255\255\255\111\001\112\001\255\255\255\255\
\255\255\049\001\050\001\051\001\052\001\255\255\054\001\055\001\
\056\001\057\001\255\255\255\255\060\001\255\255\255\255\255\255\
\255\255\065\001\066\001\255\255\255\255\006\001\007\001\255\255\
\255\255\255\255\011\001\012\001\255\255\077\001\078\001\255\255\
\255\255\255\255\255\255\083\001\255\255\255\255\255\255\255\255\
\255\255\089\001\255\255\091\001\255\255\030\001\031\001\255\255\
\255\255\255\255\255\255\099\001\100\001\255\255\255\255\103\001\
\255\255\255\255\106\001\255\255\108\001\255\255\255\255\111\001\
\049\001\050\001\051\001\052\001\255\255\054\001\055\001\056\001\
\057\001\255\255\255\255\060\001\255\255\255\255\255\255\255\255\
\065\001\066\001\255\255\255\255\006\001\007\001\255\255\255\255\
\255\255\011\001\012\001\255\255\077\001\078\001\255\255\255\255\
\255\255\255\255\083\001\255\255\255\255\255\255\255\255\255\255\
\089\001\255\255\091\001\255\255\030\001\031\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\103\001\255\255\
\255\255\106\001\255\255\108\001\255\255\255\255\111\001\049\001\
\050\001\051\001\255\255\255\255\054\001\055\001\056\001\057\001\
\255\255\255\255\060\001\255\255\255\255\255\255\255\255\065\001\
\066\001\255\255\255\255\006\001\007\001\255\255\255\255\255\255\
\011\001\012\001\255\255\077\001\078\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\089\001\
\255\255\255\255\255\255\030\001\031\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\103\001\255\255\255\255\
\255\255\255\255\108\001\255\255\255\255\111\001\049\001\050\001\
\051\001\255\255\255\255\054\001\055\001\056\001\057\001\255\255\
\255\255\060\001\255\255\255\255\255\255\255\255\065\001\066\001\
\255\255\255\255\006\001\007\001\255\255\255\255\255\255\011\001\
\012\001\255\255\077\001\078\001\255\255\255\255\255\255\255\255\
\255\255\255\255\008\001\255\255\255\255\255\255\089\001\255\255\
\255\255\015\001\030\001\031\001\056\001\255\255\058\001\059\001\
\060\001\023\001\062\001\255\255\103\001\065\001\066\001\255\255\
\030\001\108\001\255\255\255\255\111\001\049\001\050\001\051\001\
\255\255\255\255\054\001\055\001\056\001\057\001\255\255\083\001\
\060\001\255\255\255\255\255\255\255\255\065\001\066\001\091\001\
\092\001\255\255\056\001\255\255\058\001\059\001\060\001\099\001\
\062\001\077\001\078\001\065\001\066\001\255\255\255\255\255\255\
\255\255\008\001\110\001\111\001\112\001\089\001\255\255\255\255\
\015\001\255\255\255\255\255\255\255\255\083\001\255\255\255\255\
\255\255\255\255\255\255\103\001\090\001\091\001\092\001\030\001\
\108\001\255\255\255\255\111\001\255\255\099\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\108\001\255\255\
\255\255\111\001\112\001\255\255\255\255\255\255\255\255\255\255\
\255\255\056\001\255\255\058\001\059\001\060\001\255\255\062\001\
\255\255\255\255\065\001\066\001\255\255\255\255\255\255\255\255\
\000\001\001\001\002\001\255\255\255\255\255\255\255\255\255\255\
\255\255\009\001\255\255\255\255\083\001\255\255\014\001\015\001\
\016\001\017\001\018\001\255\255\091\001\092\001\255\255\255\255\
\255\255\255\255\255\255\027\001\099\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\036\001\108\001\255\255\255\255\
\111\001\112\001\042\001\043\001\044\001\045\001\046\001\000\001\
\001\001\002\001\255\255\255\255\255\255\255\255\007\001\255\255\
\009\001\255\255\255\255\255\255\255\255\255\255\062\001\016\001\
\255\255\255\255\255\255\067\001\255\255\255\255\255\255\255\255\
\072\001\073\001\027\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\036\001\084\001\085\001\086\001\087\001\
\088\001\042\001\043\001\044\001\045\001\046\001\255\255\255\255\
\096\001\255\255\255\255\255\255\255\255\255\255\102\001\255\255\
\255\255\255\255\255\255\255\255\255\255\062\001\255\255\255\255\
\255\255\001\001\002\001\255\255\255\255\255\255\255\255\072\001\
\073\001\009\001\075\001\255\255\255\255\255\255\255\255\015\001\
\016\001\255\255\018\001\084\001\085\001\086\001\087\001\088\001\
\089\001\255\255\255\255\027\001\255\255\255\255\255\255\255\255\
\255\255\001\001\002\001\100\001\036\001\102\001\255\255\255\255\
\255\255\009\001\042\001\043\001\044\001\045\001\046\001\015\001\
\016\001\255\255\018\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\027\001\255\255\255\255\062\001\255\255\
\255\255\255\255\255\255\067\001\036\001\255\255\255\255\255\255\
\072\001\073\001\042\001\043\001\044\001\045\001\046\001\255\255\
\255\255\255\255\255\255\255\255\084\001\085\001\086\001\087\001\
\088\001\255\255\255\255\255\255\255\255\255\255\062\001\001\001\
\002\001\097\001\255\255\067\001\255\255\255\255\102\001\009\001\
\072\001\073\001\255\255\255\255\255\255\015\001\016\001\255\255\
\018\001\255\255\255\255\255\255\084\001\085\001\086\001\087\001\
\088\001\027\001\255\255\255\255\255\255\093\001\255\255\001\001\
\002\001\255\255\036\001\255\255\255\255\255\255\102\001\009\001\
\042\001\043\001\044\001\045\001\046\001\015\001\016\001\255\255\
\018\001\255\255\255\255\255\255\255\255\255\255\255\255\025\001\
\255\255\027\001\255\255\255\255\062\001\255\255\255\255\255\255\
\255\255\067\001\036\001\255\255\255\255\255\255\072\001\073\001\
\042\001\043\001\044\001\045\001\046\001\255\255\255\255\255\255\
\255\255\255\255\084\001\085\001\086\001\087\001\088\001\255\255\
\255\255\255\255\255\255\093\001\062\001\001\001\002\001\255\255\
\255\255\067\001\255\255\255\255\102\001\009\001\072\001\073\001\
\255\255\255\255\255\255\015\001\016\001\255\255\018\001\255\255\
\255\255\255\255\084\001\085\001\086\001\087\001\088\001\027\001\
\255\255\255\255\255\255\255\255\255\255\001\001\002\001\255\255\
\036\001\255\255\255\255\255\255\102\001\009\001\042\001\043\001\
\044\001\045\001\046\001\015\001\016\001\255\255\018\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\027\001\
\255\255\255\255\062\001\255\255\255\255\255\255\255\255\067\001\
\036\001\255\255\255\255\255\255\072\001\073\001\042\001\043\001\
\044\001\045\001\046\001\255\255\255\255\255\255\255\255\255\255\
\084\001\085\001\086\001\087\001\088\001\255\255\255\255\255\255\
\255\255\255\255\062\001\001\001\002\001\255\255\255\255\067\001\
\255\255\255\255\102\001\009\001\072\001\073\001\255\255\255\255\
\255\255\015\001\016\001\255\255\255\255\255\255\255\255\255\255\
\084\001\085\001\086\001\087\001\088\001\027\001\255\255\255\255\
\255\255\255\255\255\255\001\001\002\001\255\255\036\001\255\255\
\255\255\255\255\102\001\009\001\042\001\043\001\044\001\045\001\
\046\001\015\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\027\001\255\255\255\255\
\062\001\255\255\255\255\255\255\255\255\067\001\036\001\255\255\
\255\255\255\255\072\001\073\001\042\001\043\001\044\001\045\001\
\046\001\255\255\255\255\255\255\255\255\255\255\084\001\085\001\
\086\001\087\001\088\001\255\255\255\255\255\255\255\255\093\001\
\062\001\001\001\002\001\255\255\255\255\067\001\255\255\255\255\
\102\001\009\001\072\001\073\001\255\255\255\255\255\255\015\001\
\255\255\255\255\255\255\255\255\255\255\255\255\084\001\085\001\
\086\001\087\001\088\001\027\001\255\255\255\255\255\255\255\255\
\255\255\255\255\096\001\255\255\036\001\255\255\255\255\255\255\
\102\001\255\255\042\001\043\001\044\001\045\001\046\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\001\001\002\001\
\255\255\255\255\255\255\255\255\255\255\255\255\062\001\255\255\
\255\255\255\255\255\255\067\001\015\001\255\255\255\255\255\255\
\072\001\073\001\255\255\255\255\255\255\255\255\255\255\255\255\
\027\001\255\255\255\255\255\255\084\001\085\001\086\001\087\001\
\088\001\036\001\255\255\255\255\255\255\255\255\255\255\042\001\
\043\001\044\001\045\001\046\001\255\255\255\255\102\001\255\255\
\255\255\255\255\255\255\255\255\056\001\255\255\058\001\059\001\
\060\001\255\255\062\001\062\001\255\255\065\001\066\001\255\255\
\067\001\255\255\255\255\255\255\255\255\072\001\073\001\075\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\083\001\
\255\255\255\255\085\001\086\001\087\001\088\001\255\255\091\001\
\092\001\255\255\255\255\255\255\255\255\255\255\255\255\099\001\
\255\255\255\255\255\255\102\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\111\001\112\001"

let yynames_const = "\
  AMPERAMPER\000\
  AMPERSAND\000\
  AND\000\
  AS\000\
  ASSERT\000\
  BACKQUOTE\000\
  BANG\000\
  BAR\000\
  BARBAR\000\
  BARRBRACKET\000\
  BEGIN\000\
  CLASS\000\
  COLON\000\
  COLONCOLON\000\
  COLONEQUAL\000\
  COLONGREATER\000\
  COMMA\000\
  CONSTRAINT\000\
  DO\000\
  DONE\000\
  DOT\000\
  DOTDOT\000\
  DOWNTO\000\
  ELSE\000\
  END\000\
  EOF\000\
  EQUAL\000\
  EXCEPTION\000\
  EXTERNAL\000\
  FALSE\000\
  FOR\000\
  FUN\000\
  FUNCTION\000\
  FUNCTOR\000\
  GREATER\000\
  GREATERRBRACE\000\
  GREATERRBRACKET\000\
  IF\000\
  IN\000\
  INCLUDE\000\
  INHERIT\000\
  INITIALIZER\000\
  LAZY\000\
  LBRACE\000\
  LBRACELESS\000\
  LBRACKET\000\
  LBRACKETBAR\000\
  LBRACKETLESS\000\
  LBRACKETGREATER\000\
  LBRACKETPERCENT\000\
  LBRACKETPERCENTPERCENT\000\
  LESS\000\
  LESSMINUS\000\
  LET\000\
  LPAREN\000\
  LBRACKETAT\000\
  LBRACKETATAT\000\
  LBRACKETATATAT\000\
  MATCH\000\
  METHOD\000\
  MINUS\000\
  MINUSDOT\000\
  MINUSGREATER\000\
  MODULE\000\
  MUTABLE\000\
  NEW\000\
  NONREC\000\
  OBJECT\000\
  OF\000\
  OPEN\000\
  OR\000\
  PERCENT\000\
  PLUS\000\
  PLUSDOT\000\
  PLUSEQ\000\
  PRIVATE\000\
  QUESTION\000\
  QUOTE\000\
  RBRACE\000\
  RBRACKET\000\
  REC\000\
  RPAREN\000\
  SEMI\000\
  SEMISEMI\000\
  SHARP\000\
  SIG\000\
  STAR\000\
  STRUCT\000\
  THEN\000\
  TILDE\000\
  TO\000\
  TRUE\000\
  TRY\000\
  TYPE\000\
  UNDERSCORE\000\
  VAL\000\
  VIRTUAL\000\
  WHEN\000\
  WHILE\000\
  WITH\000\
  EOL\000\
  "

let yynames_block = "\
  CHAR\000\
  FLOAT\000\
  INFIXOP0\000\
  INFIXOP1\000\
  INFIXOP2\000\
  INFIXOP3\000\
  INFIXOP4\000\
  INT\000\
  INT32\000\
  INT64\000\
  LABEL\000\
  LIDENT\000\
  NATIVEINT\000\
  OPTLABEL\000\
  PREFIXOP\000\
  SHARPOP\000\
  STRING\000\
  UIDENT\000\
  COMMENT\000\
  DOCSTRING\000\
  "

let yyact = [|
  (fun _ -> failwith "parser")
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'structure) in
    Obj.repr(
# 614 "parsing/parser.mly"
                                         ( extra_str 1 _1 )
# 6402 "parsing/parser.ml"
               : Parsetree.structure))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'signature) in
    Obj.repr(
# 617 "parsing/parser.mly"
                                         ( extra_sig 1 _1 )
# 6409 "parsing/parser.ml"
               : Parsetree.signature))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'top_structure) in
    Obj.repr(
# 620 "parsing/parser.mly"
                                         ( Ptop_def (extra_str 1 _1) )
# 6416 "parsing/parser.ml"
               : Parsetree.toplevel_phrase))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'toplevel_directive) in
    Obj.repr(
# 621 "parsing/parser.mly"
                                         ( _1 )
# 6423 "parsing/parser.ml"
               : Parsetree.toplevel_phrase))
; (fun __caml_parser_env ->
    Obj.repr(
# 622 "parsing/parser.mly"
                                         ( raise End_of_file )
# 6429 "parsing/parser.ml"
               : Parsetree.toplevel_phrase))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 626 "parsing/parser.mly"
      ( (text_str 1) @ [mkstrexp _1 _2] )
# 6437 "parsing/parser.ml"
               : 'top_structure))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'top_structure_tail) in
    Obj.repr(
# 628 "parsing/parser.mly"
      ( _1 )
# 6444 "parsing/parser.ml"
               : 'top_structure))
; (fun __caml_parser_env ->
    Obj.repr(
# 631 "parsing/parser.mly"
                                         ( [] )
# 6450 "parsing/parser.ml"
               : 'top_structure_tail))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'structure_item) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'top_structure_tail) in
    Obj.repr(
# 632 "parsing/parser.mly"
                                         ( (text_str 1) @ _1 :: _2 )
# 6458 "parsing/parser.ml"
               : 'top_structure_tail))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'use_file_body) in
    Obj.repr(
# 635 "parsing/parser.mly"
                                         ( extra_def 1 _1 )
# 6465 "parsing/parser.ml"
               : Parsetree.toplevel_phrase list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'use_file_tail) in
    Obj.repr(
# 638 "parsing/parser.mly"
                                         ( _1 )
# 6472 "parsing/parser.ml"
               : 'use_file_body))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'seq_expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'post_item_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'use_file_tail) in
    Obj.repr(
# 640 "parsing/parser.mly"
      ( (text_def 1) @ Ptop_def[mkstrexp _1 _2] :: _3 )
# 6481 "parsing/parser.ml"
               : 'use_file_body))
; (fun __caml_parser_env ->
    Obj.repr(
# 644 "parsing/parser.mly"
      ( [] )
# 6487 "parsing/parser.ml"
               : 'use_file_tail))
; (fun __caml_parser_env ->
    Obj.repr(
# 646 "parsing/parser.mly"
      ( text_def 1 )
# 6493 "parsing/parser.ml"
               : 'use_file_tail))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'seq_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'post_item_attributes) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'use_file_tail) in
    Obj.repr(
# 648 "parsing/parser.mly"
      (  mark_rhs_docs 2 3;
        (text_def 1) @ (text_def 2) @ Ptop_def[mkstrexp _2 _3] :: _4 )
# 6503 "parsing/parser.ml"
               : 'use_file_tail))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'structure_item) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'use_file_tail) in
    Obj.repr(
# 651 "parsing/parser.mly"
      ( (text_def 1) @ (text_def 2) @ Ptop_def[_2] :: _3 )
# 6511 "parsing/parser.ml"
               : 'use_file_tail))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'toplevel_directive) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'use_file_tail) in
    Obj.repr(
# 653 "parsing/parser.mly"
      (  mark_rhs_docs 2 3;
        (text_def 1) @ (text_def 2) @ _2 :: _3 )
# 6520 "parsing/parser.ml"
               : 'use_file_tail))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'structure_item) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'use_file_tail) in
    Obj.repr(
# 656 "parsing/parser.mly"
      ( (text_def 1) @ Ptop_def[_1] :: _2 )
# 6528 "parsing/parser.ml"
               : 'use_file_tail))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'toplevel_directive) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'use_file_tail) in
    Obj.repr(
# 658 "parsing/parser.mly"
      ( mark_rhs_docs 1 1;
        (text_def 1) @ _1 :: _2 )
# 6537 "parsing/parser.ml"
               : 'use_file_tail))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'core_type) in
    Obj.repr(
# 662 "parsing/parser.mly"
                  ( _1 )
# 6544 "parsing/parser.ml"
               : Parsetree.core_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    Obj.repr(
# 665 "parsing/parser.mly"
                 ( _1 )
# 6551 "parsing/parser.ml"
               : Parsetree.expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'pattern) in
    Obj.repr(
# 668 "parsing/parser.mly"
                ( _1 )
# 6558 "parsing/parser.ml"
               : Parsetree.pattern))
; (fun __caml_parser_env ->
    Obj.repr(
# 675 "parsing/parser.mly"
      ( mkrhs "*" 2, None )
# 6564 "parsing/parser.ml"
               : 'functor_arg))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'functor_arg_name) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'module_type) in
    Obj.repr(
# 677 "parsing/parser.mly"
      ( mkrhs _2 2, Some _4 )
# 6572 "parsing/parser.ml"
               : 'functor_arg))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 681 "parsing/parser.mly"
               ( _1 )
# 6579 "parsing/parser.ml"
               : 'functor_arg_name))
; (fun __caml_parser_env ->
    Obj.repr(
# 682 "parsing/parser.mly"
               ( "_" )
# 6585 "parsing/parser.ml"
               : 'functor_arg_name))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'functor_args) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'functor_arg) in
    Obj.repr(
# 687 "parsing/parser.mly"
      ( _2 :: _1 )
# 6593 "parsing/parser.ml"
               : 'functor_args))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'functor_arg) in
    Obj.repr(
# 689 "parsing/parser.mly"
      ( [ _1 ] )
# 6600 "parsing/parser.ml"
               : 'functor_args))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'mod_longident) in
    Obj.repr(
# 694 "parsing/parser.mly"
      ( mkmod(Pmod_ident (mkrhs _1 1)) )
# 6607 "parsing/parser.ml"
               : 'module_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'structure) in
    Obj.repr(
# 696 "parsing/parser.mly"
      ( mkmod(Pmod_structure(extra_str 2 _2)) )
# 6614 "parsing/parser.ml"
               : 'module_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'structure) in
    Obj.repr(
# 698 "parsing/parser.mly"
      ( unclosed "struct" 1 "end" 3 )
# 6621 "parsing/parser.ml"
               : 'module_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'functor_args) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'module_expr) in
    Obj.repr(
# 700 "parsing/parser.mly"
      ( List.fold_left (fun acc (n, t) -> mkmod(Pmod_functor(n, t, acc)))
                       _4 _2 )
# 6630 "parsing/parser.ml"
               : 'module_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'module_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'module_expr) in
    Obj.repr(
# 703 "parsing/parser.mly"
      ( mkmod(Pmod_apply(_1, _3)) )
# 6638 "parsing/parser.ml"
               : 'module_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'module_expr) in
    Obj.repr(
# 705 "parsing/parser.mly"
      ( mkmod(Pmod_apply(_1, mkmod (Pmod_structure []))) )
# 6645 "parsing/parser.ml"
               : 'module_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'module_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'module_expr) in
    Obj.repr(
# 707 "parsing/parser.mly"
      ( unclosed "(" 2 ")" 4 )
# 6653 "parsing/parser.ml"
               : 'module_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'module_expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'module_type) in
    Obj.repr(
# 709 "parsing/parser.mly"
      ( mkmod(Pmod_constraint(_2, _4)) )
# 6661 "parsing/parser.ml"
               : 'module_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'module_expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'module_type) in
    Obj.repr(
# 711 "parsing/parser.mly"
      ( unclosed "(" 1 ")" 5 )
# 6669 "parsing/parser.ml"
               : 'module_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'module_expr) in
    Obj.repr(
# 713 "parsing/parser.mly"
      ( _2 )
# 6676 "parsing/parser.ml"
               : 'module_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'module_expr) in
    Obj.repr(
# 715 "parsing/parser.mly"
      ( unclosed "(" 1 ")" 3 )
# 6683 "parsing/parser.ml"
               : 'module_expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'expr) in
    Obj.repr(
# 717 "parsing/parser.mly"
      ( mkmod(Pmod_unpack _3) )
# 6690 "parsing/parser.ml"
               : 'module_expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'expr) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'package_type) in
    Obj.repr(
# 719 "parsing/parser.mly"
      ( mkmod(Pmod_unpack(
              ghexp(Pexp_constraint(_3, ghtyp(Ptyp_package _5))))) )
# 6699 "parsing/parser.ml"
               : 'module_expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 5 : 'expr) in
    let _5 = (Parsing.peek_val __caml_parser_env 3 : 'package_type) in
    let _7 = (Parsing.peek_val __caml_parser_env 1 : 'package_type) in
    Obj.repr(
# 722 "parsing/parser.mly"
      ( mkmod(Pmod_unpack(
              ghexp(Pexp_coerce(_3, Some(ghtyp(Ptyp_package _5)),
                                    ghtyp(Ptyp_package _7))))) )
# 6710 "parsing/parser.ml"
               : 'module_expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'expr) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'package_type) in
    Obj.repr(
# 726 "parsing/parser.mly"
      ( mkmod(Pmod_unpack(
              ghexp(Pexp_coerce(_3, None, ghtyp(Ptyp_package _5))))) )
# 6719 "parsing/parser.ml"
               : 'module_expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    Obj.repr(
# 729 "parsing/parser.mly"
      ( unclosed "(" 1 ")" 5 )
# 6726 "parsing/parser.ml"
               : 'module_expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    Obj.repr(
# 731 "parsing/parser.mly"
      ( unclosed "(" 1 ")" 5 )
# 6733 "parsing/parser.ml"
               : 'module_expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'expr) in
    Obj.repr(
# 733 "parsing/parser.mly"
      ( unclosed "(" 1 ")" 4 )
# 6740 "parsing/parser.ml"
               : 'module_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'module_expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'attribute) in
    Obj.repr(
# 735 "parsing/parser.mly"
      ( Mod.attr _1 _2 )
# 6748 "parsing/parser.ml"
               : 'module_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'extension) in
    Obj.repr(
# 737 "parsing/parser.mly"
      ( mkmod(Pmod_extension _1) )
# 6755 "parsing/parser.ml"
               : 'module_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'seq_expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'post_item_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'structure_tail) in
    Obj.repr(
# 742 "parsing/parser.mly"
      ( mark_rhs_docs 1 2;
        (text_str 1) @ mkstrexp _1 _2 :: _3 )
# 6765 "parsing/parser.ml"
               : 'structure))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'structure_tail) in
    Obj.repr(
# 744 "parsing/parser.mly"
                   ( _1 )
# 6772 "parsing/parser.ml"
               : 'structure))
; (fun __caml_parser_env ->
    Obj.repr(
# 747 "parsing/parser.mly"
                         ( [] )
# 6778 "parsing/parser.ml"
               : 'structure_tail))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'structure) in
    Obj.repr(
# 748 "parsing/parser.mly"
                         ( (text_str 1) @ _2 )
# 6785 "parsing/parser.ml"
               : 'structure_tail))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'structure_item) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'structure_tail) in
    Obj.repr(
# 749 "parsing/parser.mly"
                                  ( (text_str 1) @ _1 :: _2 )
# 6793 "parsing/parser.ml"
               : 'structure_tail))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'let_bindings) in
    Obj.repr(
# 753 "parsing/parser.mly"
      ( val_of_let_bindings _1 )
# 6800 "parsing/parser.ml"
               : 'structure_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'primitive_declaration) in
    Obj.repr(
# 755 "parsing/parser.mly"
      ( mkstr (Pstr_primitive _1) )
# 6807 "parsing/parser.ml"
               : 'structure_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'type_declarations) in
    Obj.repr(
# 757 "parsing/parser.mly"
      ( mkstr(Pstr_type (List.rev _1)) )
# 6814 "parsing/parser.ml"
               : 'structure_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'str_type_extension) in
    Obj.repr(
# 759 "parsing/parser.mly"
      ( mkstr(Pstr_typext _1) )
# 6821 "parsing/parser.ml"
               : 'structure_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'str_exception_declaration) in
    Obj.repr(
# 761 "parsing/parser.mly"
      ( mkstr(Pstr_exception _1) )
# 6828 "parsing/parser.ml"
               : 'structure_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'module_binding) in
    Obj.repr(
# 763 "parsing/parser.mly"
      ( mkstr(Pstr_module _1) )
# 6835 "parsing/parser.ml"
               : 'structure_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'rec_module_bindings) in
    Obj.repr(
# 765 "parsing/parser.mly"
      ( mkstr(Pstr_recmodule(List.rev _1)) )
# 6842 "parsing/parser.ml"
               : 'structure_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'module_type_declaration) in
    Obj.repr(
# 767 "parsing/parser.mly"
      ( mkstr(Pstr_modtype _1) )
# 6849 "parsing/parser.ml"
               : 'structure_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'open_statement) in
    Obj.repr(
# 768 "parsing/parser.mly"
                   ( mkstr(Pstr_open _1) )
# 6856 "parsing/parser.ml"
               : 'structure_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'class_declarations) in
    Obj.repr(
# 770 "parsing/parser.mly"
      ( mkstr(Pstr_class (List.rev _1)) )
# 6863 "parsing/parser.ml"
               : 'structure_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'class_type_declarations) in
    Obj.repr(
# 772 "parsing/parser.mly"
      ( mkstr(Pstr_class_type (List.rev _1)) )
# 6870 "parsing/parser.ml"
               : 'structure_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'str_include_statement) in
    Obj.repr(
# 774 "parsing/parser.mly"
      ( mkstr(Pstr_include _1) )
# 6877 "parsing/parser.ml"
               : 'structure_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'item_extension) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 776 "parsing/parser.mly"
      ( mkstr(Pstr_extension (_1, (add_docs_attrs (symbol_docs ()) _2))) )
# 6885 "parsing/parser.ml"
               : 'structure_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'floating_attribute) in
    Obj.repr(
# 778 "parsing/parser.mly"
      ( mark_symbol_docs ();
        mkstr(Pstr_attribute _1) )
# 6893 "parsing/parser.ml"
               : 'structure_item))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'module_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 783 "parsing/parser.mly"
      ( Incl.mk _2 ~attrs:_3
                ~loc:(symbol_rloc()) ~docs:(symbol_docs ()) )
# 6902 "parsing/parser.ml"
               : 'str_include_statement))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'module_expr) in
    Obj.repr(
# 788 "parsing/parser.mly"
      ( _2 )
# 6909 "parsing/parser.ml"
               : 'module_binding_body))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'module_type) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'module_expr) in
    Obj.repr(
# 790 "parsing/parser.mly"
      ( mkmod(Pmod_constraint(_4, _2)) )
# 6917 "parsing/parser.ml"
               : 'module_binding_body))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'functor_arg) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'module_binding_body) in
    Obj.repr(
# 792 "parsing/parser.mly"
      ( mkmod(Pmod_functor(fst _1, snd _1, _2)) )
# 6925 "parsing/parser.ml"
               : 'module_binding_body))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'module_binding_body) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 796 "parsing/parser.mly"
      ( Mb.mk (mkrhs _2 2) _3 ~attrs:_4
              ~loc:(symbol_rloc ()) ~docs:(symbol_docs ()) )
# 6935 "parsing/parser.ml"
               : 'module_binding))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'rec_module_binding) in
    Obj.repr(
# 800 "parsing/parser.mly"
                                                  ( [_1] )
# 6942 "parsing/parser.ml"
               : 'rec_module_bindings))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'rec_module_bindings) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'and_module_binding) in
    Obj.repr(
# 801 "parsing/parser.mly"
                                                  ( _2 :: _1 )
# 6950 "parsing/parser.ml"
               : 'rec_module_bindings))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'module_binding_body) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 805 "parsing/parser.mly"
      ( Mb.mk (mkrhs _3 3) _4 ~attrs:_5
              ~loc:(symbol_rloc ()) ~docs:(symbol_docs ()) )
# 6960 "parsing/parser.ml"
               : 'rec_module_binding))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'module_binding_body) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 810 "parsing/parser.mly"
      ( Mb.mk (mkrhs _2 2) _3 ~attrs:_4 ~loc:(symbol_rloc ())
               ~text:(symbol_text ()) ~docs:(symbol_docs ()) )
# 6970 "parsing/parser.ml"
               : 'and_module_binding))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'mty_longident) in
    Obj.repr(
# 818 "parsing/parser.mly"
      ( mkmty(Pmty_ident (mkrhs _1 1)) )
# 6977 "parsing/parser.ml"
               : 'module_type))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'signature) in
    Obj.repr(
# 820 "parsing/parser.mly"
      ( mkmty(Pmty_signature (extra_sig 2 _2)) )
# 6984 "parsing/parser.ml"
               : 'module_type))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'signature) in
    Obj.repr(
# 822 "parsing/parser.mly"
      ( unclosed "sig" 1 "end" 3 )
# 6991 "parsing/parser.ml"
               : 'module_type))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'functor_args) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'module_type) in
    Obj.repr(
# 825 "parsing/parser.mly"
      ( List.fold_left (fun acc (n, t) -> mkmty(Pmty_functor(n, t, acc)))
                       _4 _2 )
# 7000 "parsing/parser.ml"
               : 'module_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'module_type) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'with_constraints) in
    Obj.repr(
# 828 "parsing/parser.mly"
      ( mkmty(Pmty_with(_1, List.rev _3)) )
# 7008 "parsing/parser.ml"
               : 'module_type))
; (fun __caml_parser_env ->
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'module_expr) in
    Obj.repr(
# 830 "parsing/parser.mly"
      ( mkmty(Pmty_typeof _4) )
# 7015 "parsing/parser.ml"
               : 'module_type))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'module_type) in
    Obj.repr(
# 834 "parsing/parser.mly"
      ( _2 )
# 7022 "parsing/parser.ml"
               : 'module_type))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'module_type) in
    Obj.repr(
# 836 "parsing/parser.mly"
      ( unclosed "(" 1 ")" 3 )
# 7029 "parsing/parser.ml"
               : 'module_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'extension) in
    Obj.repr(
# 838 "parsing/parser.mly"
      ( mkmty(Pmty_extension _1) )
# 7036 "parsing/parser.ml"
               : 'module_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'module_type) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'attribute) in
    Obj.repr(
# 840 "parsing/parser.mly"
      ( Mty.attr _1 _2 )
# 7044 "parsing/parser.ml"
               : 'module_type))
; (fun __caml_parser_env ->
    Obj.repr(
# 843 "parsing/parser.mly"
                         ( [] )
# 7050 "parsing/parser.ml"
               : 'signature))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'signature) in
    Obj.repr(
# 844 "parsing/parser.mly"
                         ( (text_sig 1) @ _2 )
# 7057 "parsing/parser.ml"
               : 'signature))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'signature_item) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'signature) in
    Obj.repr(
# 845 "parsing/parser.mly"
                             ( (text_sig 1) @ _1 :: _2 )
# 7065 "parsing/parser.ml"
               : 'signature))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'value_description) in
    Obj.repr(
# 849 "parsing/parser.mly"
      ( mksig(Psig_value _1) )
# 7072 "parsing/parser.ml"
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'primitive_declaration) in
    Obj.repr(
# 851 "parsing/parser.mly"
      ( mksig(Psig_value _1) )
# 7079 "parsing/parser.ml"
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'type_declarations) in
    Obj.repr(
# 853 "parsing/parser.mly"
      ( mksig(Psig_type (List.rev _1)) )
# 7086 "parsing/parser.ml"
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'sig_type_extension) in
    Obj.repr(
# 855 "parsing/parser.mly"
      ( mksig(Psig_typext _1) )
# 7093 "parsing/parser.ml"
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'sig_exception_declaration) in
    Obj.repr(
# 857 "parsing/parser.mly"
      ( mksig(Psig_exception _1) )
# 7100 "parsing/parser.ml"
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'module_declaration) in
    Obj.repr(
# 859 "parsing/parser.mly"
      ( mksig(Psig_module _1) )
# 7107 "parsing/parser.ml"
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'module_alias) in
    Obj.repr(
# 861 "parsing/parser.mly"
      ( mksig(Psig_module _1) )
# 7114 "parsing/parser.ml"
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'rec_module_declarations) in
    Obj.repr(
# 863 "parsing/parser.mly"
      ( mksig(Psig_recmodule (List.rev _1)) )
# 7121 "parsing/parser.ml"
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'module_type_declaration) in
    Obj.repr(
# 865 "parsing/parser.mly"
      ( mksig(Psig_modtype _1) )
# 7128 "parsing/parser.ml"
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'open_statement) in
    Obj.repr(
# 867 "parsing/parser.mly"
      ( mksig(Psig_open _1) )
# 7135 "parsing/parser.ml"
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'sig_include_statement) in
    Obj.repr(
# 869 "parsing/parser.mly"
      ( mksig(Psig_include _1) )
# 7142 "parsing/parser.ml"
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'class_descriptions) in
    Obj.repr(
# 871 "parsing/parser.mly"
      ( mksig(Psig_class (List.rev _1)) )
# 7149 "parsing/parser.ml"
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'class_type_declarations) in
    Obj.repr(
# 873 "parsing/parser.mly"
      ( mksig(Psig_class_type (List.rev _1)) )
# 7156 "parsing/parser.ml"
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'item_extension) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 875 "parsing/parser.mly"
      ( mksig(Psig_extension (_1, (add_docs_attrs (symbol_docs ()) _2))) )
# 7164 "parsing/parser.ml"
               : 'signature_item))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'floating_attribute) in
    Obj.repr(
# 877 "parsing/parser.mly"
      ( mark_symbol_docs ();
        mksig(Psig_attribute _1) )
# 7172 "parsing/parser.ml"
               : 'signature_item))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'override_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 882 "parsing/parser.mly"
      ( Opn.mk (mkrhs _3 3) ~override:_2 ~attrs:_4
          ~loc:(symbol_rloc()) ~docs:(symbol_docs ()) )
# 7182 "parsing/parser.ml"
               : 'open_statement))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'module_type) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 887 "parsing/parser.mly"
      ( Incl.mk _2 ~attrs:_3
                ~loc:(symbol_rloc()) ~docs:(symbol_docs ()) )
# 7191 "parsing/parser.ml"
               : 'sig_include_statement))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'module_type) in
    Obj.repr(
# 892 "parsing/parser.mly"
      ( _2 )
# 7198 "parsing/parser.ml"
               : 'module_declaration_body))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'module_type) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'module_declaration_body) in
    Obj.repr(
# 894 "parsing/parser.mly"
      ( mkmty(Pmty_functor(mkrhs _2 2, Some _4, _6)) )
# 7207 "parsing/parser.ml"
               : 'module_declaration_body))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'module_declaration_body) in
    Obj.repr(
# 896 "parsing/parser.mly"
      ( mkmty(Pmty_functor(mkrhs "*" 1, None, _3)) )
# 7214 "parsing/parser.ml"
               : 'module_declaration_body))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'module_declaration_body) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 900 "parsing/parser.mly"
      ( Md.mk (mkrhs _2 2) _3 ~attrs:_4
          ~loc:(symbol_rloc()) ~docs:(symbol_docs ()) )
# 7224 "parsing/parser.ml"
               : 'module_declaration))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'mod_longident) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 905 "parsing/parser.mly"
      ( Md.mk (mkrhs _2 2)
          (Mty.alias ~loc:(rhs_loc 4) (mkrhs _4 4)) ~attrs:_5
             ~loc:(symbol_rloc()) ~docs:(symbol_docs ()) )
# 7235 "parsing/parser.ml"
               : 'module_alias))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'rec_module_declaration) in
    Obj.repr(
# 910 "parsing/parser.mly"
                                                    ( [_1] )
# 7242 "parsing/parser.ml"
               : 'rec_module_declarations))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'rec_module_declarations) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'and_module_declaration) in
    Obj.repr(
# 911 "parsing/parser.mly"
                                                    ( _2 :: _1 )
# 7250 "parsing/parser.ml"
               : 'rec_module_declarations))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'module_type) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 915 "parsing/parser.mly"
      ( Md.mk (mkrhs _3 3) _5 ~attrs:_6
              ~loc:(symbol_rloc()) ~docs:(symbol_docs ()) )
# 7260 "parsing/parser.ml"
               : 'rec_module_declaration))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'module_type) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 920 "parsing/parser.mly"
      ( Md.mk (mkrhs _2 2) _4 ~attrs:_5 ~loc:(symbol_rloc())
              ~text:(symbol_text()) ~docs:(symbol_docs()) )
# 7270 "parsing/parser.ml"
               : 'and_module_declaration))
; (fun __caml_parser_env ->
    Obj.repr(
# 924 "parsing/parser.mly"
                              ( None )
# 7276 "parsing/parser.ml"
               : 'module_type_declaration_body))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'module_type) in
    Obj.repr(
# 925 "parsing/parser.mly"
                              ( Some _2 )
# 7283 "parsing/parser.ml"
               : 'module_type_declaration_body))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'ident) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'module_type_declaration_body) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 929 "parsing/parser.mly"
      ( Mtd.mk (mkrhs _3 3) ?typ:_4 ~attrs:_5
          ~loc:(symbol_rloc()) ~docs:(symbol_docs ()) )
# 7293 "parsing/parser.ml"
               : 'module_type_declaration))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'class_declaration) in
    Obj.repr(
# 935 "parsing/parser.mly"
                                                ( [_1] )
# 7300 "parsing/parser.ml"
               : 'class_declarations))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'class_declarations) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'and_class_declaration) in
    Obj.repr(
# 936 "parsing/parser.mly"
                                                ( _2 :: _1 )
# 7308 "parsing/parser.ml"
               : 'class_declarations))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : 'virtual_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'class_type_parameters) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'class_fun_binding) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 941 "parsing/parser.mly"
      ( Ci.mk (mkrhs _4 4) _5 ~virt:_2 ~params:_3 ~attrs:_6
              ~loc:(symbol_rloc ()) ~docs:(symbol_docs ()) )
# 7320 "parsing/parser.ml"
               : 'class_declaration))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : 'virtual_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'class_type_parameters) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'class_fun_binding) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 947 "parsing/parser.mly"
      ( Ci.mk (mkrhs _4 4) _5 ~virt:_2 ~params:_3
         ~attrs:_6 ~loc:(symbol_rloc ())
         ~text:(symbol_text ()) ~docs:(symbol_docs ()) )
# 7333 "parsing/parser.ml"
               : 'and_class_declaration))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'class_expr) in
    Obj.repr(
# 953 "parsing/parser.mly"
      ( _2 )
# 7340 "parsing/parser.ml"
               : 'class_fun_binding))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'class_type) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'class_expr) in
    Obj.repr(
# 955 "parsing/parser.mly"
      ( mkclass(Pcl_constraint(_4, _2)) )
# 7348 "parsing/parser.ml"
               : 'class_fun_binding))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'labeled_simple_pattern) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'class_fun_binding) in
    Obj.repr(
# 957 "parsing/parser.mly"
      ( let (l,o,p) = _1 in mkclass(Pcl_fun(l, o, p, _2)) )
# 7356 "parsing/parser.ml"
               : 'class_fun_binding))
; (fun __caml_parser_env ->
    Obj.repr(
# 960 "parsing/parser.mly"
                                                ( [] )
# 7362 "parsing/parser.ml"
               : 'class_type_parameters))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'type_parameter_list) in
    Obj.repr(
# 961 "parsing/parser.mly"
                                                ( List.rev _2 )
# 7369 "parsing/parser.ml"
               : 'class_type_parameters))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'labeled_simple_pattern) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'class_expr) in
    Obj.repr(
# 965 "parsing/parser.mly"
      ( let (l,o,p) = _1 in mkclass(Pcl_fun(l, o, p, _3)) )
# 7377 "parsing/parser.ml"
               : 'class_fun_def))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'labeled_simple_pattern) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'class_fun_def) in
    Obj.repr(
# 967 "parsing/parser.mly"
      ( let (l,o,p) = _1 in mkclass(Pcl_fun(l, o, p, _2)) )
# 7385 "parsing/parser.ml"
               : 'class_fun_def))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'class_simple_expr) in
    Obj.repr(
# 971 "parsing/parser.mly"
      ( _1 )
# 7392 "parsing/parser.ml"
               : 'class_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'class_fun_def) in
    Obj.repr(
# 973 "parsing/parser.mly"
      ( _2 )
# 7399 "parsing/parser.ml"
               : 'class_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'class_simple_expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'simple_labeled_expr_list) in
    Obj.repr(
# 975 "parsing/parser.mly"
      ( mkclass(Pcl_apply(_1, List.rev _2)) )
# 7407 "parsing/parser.ml"
               : 'class_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'let_bindings) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'class_expr) in
    Obj.repr(
# 977 "parsing/parser.mly"
      ( class_of_let_bindings _1 _3 )
# 7415 "parsing/parser.ml"
               : 'class_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'class_expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'attribute) in
    Obj.repr(
# 979 "parsing/parser.mly"
      ( Cl.attr _1 _2 )
# 7423 "parsing/parser.ml"
               : 'class_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'extension) in
    Obj.repr(
# 981 "parsing/parser.mly"
      ( mkclass(Pcl_extension _1) )
# 7430 "parsing/parser.ml"
               : 'class_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'core_type_comma_list) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'class_longident) in
    Obj.repr(
# 985 "parsing/parser.mly"
      ( mkclass(Pcl_constr(mkloc _4 (rhs_loc 4), List.rev _2)) )
# 7438 "parsing/parser.ml"
               : 'class_simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'class_longident) in
    Obj.repr(
# 987 "parsing/parser.mly"
      ( mkclass(Pcl_constr(mkrhs _1 1, [])) )
# 7445 "parsing/parser.ml"
               : 'class_simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'class_structure) in
    Obj.repr(
# 989 "parsing/parser.mly"
      ( mkclass(Pcl_structure _2) )
# 7452 "parsing/parser.ml"
               : 'class_simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'class_structure) in
    Obj.repr(
# 991 "parsing/parser.mly"
      ( unclosed "object" 1 "end" 3 )
# 7459 "parsing/parser.ml"
               : 'class_simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'class_expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'class_type) in
    Obj.repr(
# 993 "parsing/parser.mly"
      ( mkclass(Pcl_constraint(_2, _4)) )
# 7467 "parsing/parser.ml"
               : 'class_simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'class_expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'class_type) in
    Obj.repr(
# 995 "parsing/parser.mly"
      ( unclosed "(" 1 ")" 5 )
# 7475 "parsing/parser.ml"
               : 'class_simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'class_expr) in
    Obj.repr(
# 997 "parsing/parser.mly"
      ( _2 )
# 7482 "parsing/parser.ml"
               : 'class_simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'class_expr) in
    Obj.repr(
# 999 "parsing/parser.mly"
      ( unclosed "(" 1 ")" 3 )
# 7489 "parsing/parser.ml"
               : 'class_simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'class_self_pattern) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'class_fields) in
    Obj.repr(
# 1003 "parsing/parser.mly"
       ( Cstr.mk _1 (extra_cstr 2 (List.rev _2)) )
# 7497 "parsing/parser.ml"
               : 'class_structure))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'pattern) in
    Obj.repr(
# 1007 "parsing/parser.mly"
      ( reloc_pat _2 )
# 7504 "parsing/parser.ml"
               : 'class_self_pattern))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'pattern) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'core_type) in
    Obj.repr(
# 1009 "parsing/parser.mly"
      ( mkpat(Ppat_constraint(_2, _4)) )
# 7512 "parsing/parser.ml"
               : 'class_self_pattern))
; (fun __caml_parser_env ->
    Obj.repr(
# 1011 "parsing/parser.mly"
      ( ghpat(Ppat_any) )
# 7518 "parsing/parser.ml"
               : 'class_self_pattern))
; (fun __caml_parser_env ->
    Obj.repr(
# 1015 "parsing/parser.mly"
      ( [] )
# 7524 "parsing/parser.ml"
               : 'class_fields))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'class_fields) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'class_field) in
    Obj.repr(
# 1017 "parsing/parser.mly"
      ( _2 :: (text_cstr 2) @ _1 )
# 7532 "parsing/parser.ml"
               : 'class_fields))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'override_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'class_expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'parent_binder) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1021 "parsing/parser.mly"
      ( mkcf (Pcf_inherit (_2, _3, _4)) ~attrs:_5 ~docs:(symbol_docs ()) )
# 7542 "parsing/parser.ml"
               : 'class_field))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'value) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1023 "parsing/parser.mly"
      ( mkcf (Pcf_val _2) ~attrs:_3 ~docs:(symbol_docs ()) )
# 7550 "parsing/parser.ml"
               : 'class_field))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'method_) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1025 "parsing/parser.mly"
      ( mkcf (Pcf_method _2) ~attrs:_3 ~docs:(symbol_docs ()) )
# 7558 "parsing/parser.ml"
               : 'class_field))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'constrain_field) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1027 "parsing/parser.mly"
      ( mkcf (Pcf_constraint _2) ~attrs:_3 ~docs:(symbol_docs ()) )
# 7566 "parsing/parser.ml"
               : 'class_field))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1029 "parsing/parser.mly"
      ( mkcf (Pcf_initializer _2) ~attrs:_3 ~docs:(symbol_docs ()) )
# 7574 "parsing/parser.ml"
               : 'class_field))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'item_extension) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1031 "parsing/parser.mly"
      ( mkcf (Pcf_extension _1) ~attrs:_2 ~docs:(symbol_docs ()) )
# 7582 "parsing/parser.ml"
               : 'class_field))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'floating_attribute) in
    Obj.repr(
# 1033 "parsing/parser.mly"
      ( mark_symbol_docs ();
        mkcf (Pcf_attribute _1) )
# 7590 "parsing/parser.ml"
               : 'class_field))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1038 "parsing/parser.mly"
          ( Some _2 )
# 7597 "parsing/parser.ml"
               : 'parent_binder))
; (fun __caml_parser_env ->
    Obj.repr(
# 1040 "parsing/parser.mly"
          ( None )
# 7603 "parsing/parser.ml"
               : 'parent_binder))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 5 : 'override_flag) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'label) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 1045 "parsing/parser.mly"
      ( if _1 = Override then syntax_error ();
        mkloc _4 (rhs_loc 4), Mutable, Cfk_virtual _6 )
# 7613 "parsing/parser.ml"
               : 'value))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'mutable_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'label) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 1048 "parsing/parser.mly"
      ( mkrhs _3 3, _2, Cfk_virtual _5 )
# 7622 "parsing/parser.ml"
               : 'value))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'override_flag) in
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'mutable_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'label) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 1050 "parsing/parser.mly"
      ( mkrhs _3 3, _2, Cfk_concrete (_1, _5) )
# 7632 "parsing/parser.ml"
               : 'value))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 5 : 'override_flag) in
    let _2 = (Parsing.peek_val __caml_parser_env 4 : 'mutable_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'label) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'type_constraint) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 1052 "parsing/parser.mly"
      (
       let e = mkexp_constraint _6 _4 in
       mkrhs _3 3, _2, Cfk_concrete (_1, e)
      )
# 7646 "parsing/parser.ml"
               : 'value))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 5 : 'override_flag) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'label) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'poly_type) in
    Obj.repr(
# 1060 "parsing/parser.mly"
      ( if _1 = Override then syntax_error ();
        mkloc _4 (rhs_loc 4), Private, Cfk_virtual _6 )
# 7656 "parsing/parser.ml"
               : 'method_))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 5 : 'override_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'private_flag) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'label) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'poly_type) in
    Obj.repr(
# 1063 "parsing/parser.mly"
      ( if _1 = Override then syntax_error ();
        mkloc _4 (rhs_loc 4), _3, Cfk_virtual _6 )
# 7667 "parsing/parser.ml"
               : 'method_))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'override_flag) in
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'private_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'label) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'strict_binding) in
    Obj.repr(
# 1066 "parsing/parser.mly"
      ( mkloc _3 (rhs_loc 3), _2,
        Cfk_concrete (_1, ghexp(Pexp_poly (_4, None))) )
# 7678 "parsing/parser.ml"
               : 'method_))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 6 : 'override_flag) in
    let _2 = (Parsing.peek_val __caml_parser_env 5 : 'private_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'label) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'poly_type) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 1069 "parsing/parser.mly"
      ( mkloc _3 (rhs_loc 3), _2,
        Cfk_concrete (_1, ghexp(Pexp_poly(_7, Some _5))) )
# 7690 "parsing/parser.ml"
               : 'method_))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 9 : 'override_flag) in
    let _2 = (Parsing.peek_val __caml_parser_env 8 : 'private_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 7 : 'label) in
    let _6 = (Parsing.peek_val __caml_parser_env 4 : 'lident_list) in
    let _8 = (Parsing.peek_val __caml_parser_env 2 : 'core_type) in
    let _10 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 1073 "parsing/parser.mly"
      ( let exp, poly = wrap_type_annotation _6 _8 _10 in
        mkloc _3 (rhs_loc 3), _2,
        Cfk_concrete (_1, ghexp(Pexp_poly(exp, Some poly))) )
# 7704 "parsing/parser.ml"
               : 'method_))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'class_signature) in
    Obj.repr(
# 1082 "parsing/parser.mly"
      ( _1 )
# 7711 "parsing/parser.ml"
               : 'class_type))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'simple_core_type_or_tuple_no_attr) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'class_type) in
    Obj.repr(
# 1085 "parsing/parser.mly"
      ( mkcty(Pcty_arrow("?" ^ _2 , mkoption _4, _6)) )
# 7720 "parsing/parser.ml"
               : 'class_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'simple_core_type_or_tuple_no_attr) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'class_type) in
    Obj.repr(
# 1087 "parsing/parser.mly"
      ( mkcty(Pcty_arrow("?" ^ _1, mkoption _2, _4)) )
# 7729 "parsing/parser.ml"
               : 'class_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'simple_core_type_or_tuple_no_attr) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'class_type) in
    Obj.repr(
# 1089 "parsing/parser.mly"
      ( mkcty(Pcty_arrow(_1, _3, _5)) )
# 7738 "parsing/parser.ml"
               : 'class_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'simple_core_type_or_tuple_no_attr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'class_type) in
    Obj.repr(
# 1091 "parsing/parser.mly"
      ( mkcty(Pcty_arrow("", _1, _3)) )
# 7746 "parsing/parser.ml"
               : 'class_type))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'core_type_comma_list) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'clty_longident) in
    Obj.repr(
# 1095 "parsing/parser.mly"
      ( mkcty(Pcty_constr (mkloc _4 (rhs_loc 4), List.rev _2)) )
# 7754 "parsing/parser.ml"
               : 'class_signature))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'clty_longident) in
    Obj.repr(
# 1097 "parsing/parser.mly"
      ( mkcty(Pcty_constr (mkrhs _1 1, [])) )
# 7761 "parsing/parser.ml"
               : 'class_signature))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'class_sig_body) in
    Obj.repr(
# 1099 "parsing/parser.mly"
      ( mkcty(Pcty_signature _2) )
# 7768 "parsing/parser.ml"
               : 'class_signature))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'class_sig_body) in
    Obj.repr(
# 1101 "parsing/parser.mly"
      ( unclosed "object" 1 "end" 3 )
# 7775 "parsing/parser.ml"
               : 'class_signature))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'class_signature) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'attribute) in
    Obj.repr(
# 1103 "parsing/parser.mly"
      ( Cty.attr _1 _2 )
# 7783 "parsing/parser.ml"
               : 'class_signature))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'extension) in
    Obj.repr(
# 1105 "parsing/parser.mly"
      ( mkcty(Pcty_extension _1) )
# 7790 "parsing/parser.ml"
               : 'class_signature))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'class_self_type) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'class_sig_fields) in
    Obj.repr(
# 1109 "parsing/parser.mly"
      ( Csig.mk _1 (extra_csig 2 (List.rev _2)) )
# 7798 "parsing/parser.ml"
               : 'class_sig_body))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'core_type) in
    Obj.repr(
# 1113 "parsing/parser.mly"
      ( _2 )
# 7805 "parsing/parser.ml"
               : 'class_self_type))
; (fun __caml_parser_env ->
    Obj.repr(
# 1115 "parsing/parser.mly"
      ( mktyp(Ptyp_any) )
# 7811 "parsing/parser.ml"
               : 'class_self_type))
; (fun __caml_parser_env ->
    Obj.repr(
# 1118 "parsing/parser.mly"
                                                ( [] )
# 7817 "parsing/parser.ml"
               : 'class_sig_fields))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'class_sig_fields) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'class_sig_field) in
    Obj.repr(
# 1119 "parsing/parser.mly"
                                       ( _2 :: (text_csig 2) @ _1 )
# 7825 "parsing/parser.ml"
               : 'class_sig_fields))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'class_signature) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1123 "parsing/parser.mly"
      ( mkctf (Pctf_inherit _2) ~attrs:_3 ~docs:(symbol_docs ()) )
# 7833 "parsing/parser.ml"
               : 'class_sig_field))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'value_type) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1125 "parsing/parser.mly"
      ( mkctf (Pctf_val _2) ~attrs:_3 ~docs:(symbol_docs ()) )
# 7841 "parsing/parser.ml"
               : 'class_sig_field))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : 'private_virtual_flags) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'label) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'poly_type) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1127 "parsing/parser.mly"
      (
       let (p, v) = _2 in
       mkctf (Pctf_method (_3, p, v, _5)) ~attrs:_6 ~docs:(symbol_docs ())
      )
# 7854 "parsing/parser.ml"
               : 'class_sig_field))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'constrain_field) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1132 "parsing/parser.mly"
      ( mkctf (Pctf_constraint _2) ~attrs:_3 ~docs:(symbol_docs ()) )
# 7862 "parsing/parser.ml"
               : 'class_sig_field))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'item_extension) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1134 "parsing/parser.mly"
      ( mkctf (Pctf_extension _1) ~attrs:_2 ~docs:(symbol_docs ()) )
# 7870 "parsing/parser.ml"
               : 'class_sig_field))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'floating_attribute) in
    Obj.repr(
# 1136 "parsing/parser.mly"
      ( mark_symbol_docs ();
        mkctf(Pctf_attribute _1) )
# 7878 "parsing/parser.ml"
               : 'class_sig_field))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'mutable_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'label) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 1141 "parsing/parser.mly"
      ( _3, _2, Virtual, _5 )
# 7887 "parsing/parser.ml"
               : 'value_type))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'virtual_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'label) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 1143 "parsing/parser.mly"
      ( _3, Mutable, _2, _5 )
# 7896 "parsing/parser.ml"
               : 'value_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'label) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 1145 "parsing/parser.mly"
      ( _1, Immutable, Concrete, _3 )
# 7904 "parsing/parser.ml"
               : 'value_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'core_type) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 1148 "parsing/parser.mly"
                                           ( _1, _3, symbol_rloc() )
# 7912 "parsing/parser.ml"
               : 'constrain))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'core_type) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 1151 "parsing/parser.mly"
                                           ( _1, _3 )
# 7920 "parsing/parser.ml"
               : 'constrain_field))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'class_description) in
    Obj.repr(
# 1154 "parsing/parser.mly"
                                                ( [_1] )
# 7927 "parsing/parser.ml"
               : 'class_descriptions))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'class_descriptions) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'and_class_description) in
    Obj.repr(
# 1155 "parsing/parser.mly"
                                                ( _2 :: _1 )
# 7935 "parsing/parser.ml"
               : 'class_descriptions))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 5 : 'virtual_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'class_type_parameters) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _6 = (Parsing.peek_val __caml_parser_env 1 : 'class_type) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1160 "parsing/parser.mly"
      ( Ci.mk (mkrhs _4 4) _6 ~virt:_2 ~params:_3 ~attrs:_7
              ~loc:(symbol_rloc ()) ~docs:(symbol_docs ()) )
# 7947 "parsing/parser.ml"
               : 'class_description))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 5 : 'virtual_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'class_type_parameters) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _6 = (Parsing.peek_val __caml_parser_env 1 : 'class_type) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1166 "parsing/parser.mly"
      ( Ci.mk (mkrhs _4 4) _6 ~virt:_2 ~params:_3
              ~attrs:_7 ~loc:(symbol_rloc ())
              ~text:(symbol_text ()) ~docs:(symbol_docs ()) )
# 7960 "parsing/parser.ml"
               : 'and_class_description))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'class_type_declaration) in
    Obj.repr(
# 1171 "parsing/parser.mly"
                                                        ( [_1] )
# 7967 "parsing/parser.ml"
               : 'class_type_declarations))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'class_type_declarations) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'and_class_type_declaration) in
    Obj.repr(
# 1172 "parsing/parser.mly"
                                                        ( _2 :: _1 )
# 7975 "parsing/parser.ml"
               : 'class_type_declarations))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 5 : 'virtual_flag) in
    let _4 = (Parsing.peek_val __caml_parser_env 4 : 'class_type_parameters) in
    let _5 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _7 = (Parsing.peek_val __caml_parser_env 1 : 'class_signature) in
    let _8 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1177 "parsing/parser.mly"
      ( Ci.mk (mkrhs _5 5) _7 ~virt:_3 ~params:_4 ~attrs:_8
              ~loc:(symbol_rloc ()) ~docs:(symbol_docs ()) )
# 7987 "parsing/parser.ml"
               : 'class_type_declaration))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 5 : 'virtual_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'class_type_parameters) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _6 = (Parsing.peek_val __caml_parser_env 1 : 'class_signature) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1183 "parsing/parser.mly"
      ( Ci.mk (mkrhs _4 4) _6 ~virt:_2 ~params:_3
         ~attrs:_7 ~loc:(symbol_rloc ())
         ~text:(symbol_text ()) ~docs:(symbol_docs ()) )
# 8000 "parsing/parser.ml"
               : 'and_class_type_declaration))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1191 "parsing/parser.mly"
                                  ( _1 )
# 8007 "parsing/parser.ml"
               : 'seq_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'expr) in
    Obj.repr(
# 1192 "parsing/parser.mly"
                                  ( reloc_exp _1 )
# 8014 "parsing/parser.ml"
               : 'seq_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 1193 "parsing/parser.mly"
                                  ( mkexp(Pexp_sequence(_1, _3)) )
# 8022 "parsing/parser.ml"
               : 'seq_expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'label_let_pattern) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'opt_default) in
    Obj.repr(
# 1197 "parsing/parser.mly"
      ( ("?" ^ fst _3, _4, snd _3) )
# 8030 "parsing/parser.ml"
               : 'labeled_simple_pattern))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'label_var) in
    Obj.repr(
# 1199 "parsing/parser.mly"
      ( ("?" ^ fst _2, None, snd _2) )
# 8037 "parsing/parser.ml"
               : 'labeled_simple_pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'let_pattern) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'opt_default) in
    Obj.repr(
# 1201 "parsing/parser.mly"
      ( ("?" ^ _1, _4, _3) )
# 8046 "parsing/parser.ml"
               : 'labeled_simple_pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'pattern_var) in
    Obj.repr(
# 1203 "parsing/parser.mly"
      ( ("?" ^ _1, None, _2) )
# 8054 "parsing/parser.ml"
               : 'labeled_simple_pattern))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'label_let_pattern) in
    Obj.repr(
# 1205 "parsing/parser.mly"
      ( (fst _3, None, snd _3) )
# 8061 "parsing/parser.ml"
               : 'labeled_simple_pattern))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'label_var) in
    Obj.repr(
# 1207 "parsing/parser.mly"
      ( (fst _2, None, snd _2) )
# 8068 "parsing/parser.ml"
               : 'labeled_simple_pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'simple_pattern) in
    Obj.repr(
# 1209 "parsing/parser.mly"
      ( (_1, None, _2) )
# 8076 "parsing/parser.ml"
               : 'labeled_simple_pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_pattern) in
    Obj.repr(
# 1211 "parsing/parser.mly"
      ( ("", None, _1) )
# 8083 "parsing/parser.ml"
               : 'labeled_simple_pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1214 "parsing/parser.mly"
                      ( mkpat(Ppat_var (mkrhs _1 1)) )
# 8090 "parsing/parser.ml"
               : 'pattern_var))
; (fun __caml_parser_env ->
    Obj.repr(
# 1215 "parsing/parser.mly"
                      ( mkpat Ppat_any )
# 8096 "parsing/parser.ml"
               : 'pattern_var))
; (fun __caml_parser_env ->
    Obj.repr(
# 1218 "parsing/parser.mly"
                                        ( None )
# 8102 "parsing/parser.ml"
               : 'opt_default))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 1219 "parsing/parser.mly"
                                        ( Some _2 )
# 8109 "parsing/parser.ml"
               : 'opt_default))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'label_var) in
    Obj.repr(
# 1223 "parsing/parser.mly"
      ( _1 )
# 8116 "parsing/parser.ml"
               : 'label_let_pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'label_var) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 1225 "parsing/parser.mly"
      ( let (lab, pat) = _1 in (lab, mkpat(Ppat_constraint(pat, _3))) )
# 8124 "parsing/parser.ml"
               : 'label_let_pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1228 "parsing/parser.mly"
              ( (_1, mkpat(Ppat_var (mkrhs _1 1))) )
# 8131 "parsing/parser.ml"
               : 'label_var))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
# 1232 "parsing/parser.mly"
      ( _1 )
# 8138 "parsing/parser.ml"
               : 'let_pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 1234 "parsing/parser.mly"
      ( mkpat(Ppat_constraint(_1, _3)) )
# 8146 "parsing/parser.ml"
               : 'let_pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_expr) in
    Obj.repr(
# 1238 "parsing/parser.mly"
      ( _1 )
# 8153 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'simple_expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'simple_labeled_expr_list) in
    Obj.repr(
# 1240 "parsing/parser.mly"
      ( mkexp(Pexp_apply(_1, List.rev _2)) )
# 8161 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'let_bindings) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 1242 "parsing/parser.mly"
      ( expr_of_let_bindings _1 _3 )
# 8169 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'ext_attributes) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'module_binding_body) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 1244 "parsing/parser.mly"
      ( mkexp_attrs (Pexp_letmodule(mkrhs _4 4, _5, _7)) _3 )
# 8179 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'override_flag) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'ext_attributes) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'mod_longident) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 1246 "parsing/parser.mly"
      ( mkexp_attrs (Pexp_open(_3, mkrhs _5 5, _7)) _4 )
# 8189 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'opt_bar) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'match_cases) in
    Obj.repr(
# 1248 "parsing/parser.mly"
      ( mkexp_attrs (Pexp_function(List.rev _4)) _2 )
# 8198 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'labeled_simple_pattern) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'fun_def) in
    Obj.repr(
# 1250 "parsing/parser.mly"
      ( let (l,o,p) = _3 in
        mkexp_attrs (Pexp_fun(l, o, p, _4)) _2 )
# 8208 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 5 : 'ext_attributes) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'fun_def) in
    Obj.repr(
# 1253 "parsing/parser.mly"
      ( mkexp_attrs (Pexp_newtype(_5, _7)) _2 )
# 8217 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'seq_expr) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'opt_bar) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'match_cases) in
    Obj.repr(
# 1255 "parsing/parser.mly"
      ( mkexp_attrs (Pexp_match(_3, List.rev _6)) _2 )
# 8227 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'seq_expr) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'opt_bar) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'match_cases) in
    Obj.repr(
# 1257 "parsing/parser.mly"
      ( mkexp_attrs (Pexp_try(_3, List.rev _6)) _2 )
# 8237 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'seq_expr) in
    Obj.repr(
# 1259 "parsing/parser.mly"
      ( syntax_error() )
# 8245 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'expr_comma_list) in
    Obj.repr(
# 1261 "parsing/parser.mly"
      ( mkexp(Pexp_tuple(List.rev _1)) )
# 8252 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'constr_longident) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'simple_expr) in
    Obj.repr(
# 1263 "parsing/parser.mly"
      ( mkexp(Pexp_construct(mkrhs _1 1, Some _2)) )
# 8260 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'name_tag) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'simple_expr) in
    Obj.repr(
# 1265 "parsing/parser.mly"
      ( mkexp(Pexp_variant(_1, Some _2)) )
# 8268 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 5 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'seq_expr) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1267 "parsing/parser.mly"
      ( mkexp_attrs(Pexp_ifthenelse(_3, _5, Some _7)) _2 )
# 8278 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'seq_expr) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1269 "parsing/parser.mly"
      ( mkexp_attrs (Pexp_ifthenelse(_3, _5, None)) _2 )
# 8287 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'seq_expr) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    Obj.repr(
# 1271 "parsing/parser.mly"
      ( mkexp_attrs (Pexp_while(_3, _5)) _2 )
# 8296 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 8 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 7 : 'pattern) in
    let _5 = (Parsing.peek_val __caml_parser_env 5 : 'seq_expr) in
    let _6 = (Parsing.peek_val __caml_parser_env 4 : 'direction_flag) in
    let _7 = (Parsing.peek_val __caml_parser_env 3 : 'seq_expr) in
    let _9 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    Obj.repr(
# 1274 "parsing/parser.mly"
      ( mkexp_attrs(Pexp_for(_3, _5, _7, _6, _9)) _2 )
# 8308 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1276 "parsing/parser.mly"
      ( mkexp_cons (rhs_loc 2) (ghexp(Pexp_tuple[_1;_3])) (symbol_rloc()) )
# 8316 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _5 = (Parsing.peek_val __caml_parser_env 3 : 'expr) in
    let _7 = (Parsing.peek_val __caml_parser_env 1 : 'expr) in
    Obj.repr(
# 1278 "parsing/parser.mly"
      ( mkexp_cons (rhs_loc 2) (ghexp(Pexp_tuple[_5;_7])) (symbol_rloc()) )
# 8324 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1280 "parsing/parser.mly"
      ( mkinfix _1 _2 _3 )
# 8333 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1282 "parsing/parser.mly"
      ( mkinfix _1 _2 _3 )
# 8342 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1284 "parsing/parser.mly"
      ( mkinfix _1 _2 _3 )
# 8351 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1286 "parsing/parser.mly"
      ( mkinfix _1 _2 _3 )
# 8360 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1288 "parsing/parser.mly"
      ( mkinfix _1 _2 _3 )
# 8369 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1290 "parsing/parser.mly"
      ( mkinfix _1 "+" _3 )
# 8377 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1292 "parsing/parser.mly"
      ( mkinfix _1 "+." _3 )
# 8385 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1294 "parsing/parser.mly"
      ( mkinfix _1 "+=" _3 )
# 8393 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1296 "parsing/parser.mly"
      ( mkinfix _1 "-" _3 )
# 8401 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1298 "parsing/parser.mly"
      ( mkinfix _1 "-." _3 )
# 8409 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1300 "parsing/parser.mly"
      ( mkinfix _1 "*" _3 )
# 8417 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1302 "parsing/parser.mly"
      ( mkinfix _1 "%" _3 )
# 8425 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1304 "parsing/parser.mly"
      ( mkinfix _1 "=" _3 )
# 8433 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1306 "parsing/parser.mly"
      ( mkinfix _1 "<" _3 )
# 8441 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1308 "parsing/parser.mly"
      ( mkinfix _1 ">" _3 )
# 8449 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1310 "parsing/parser.mly"
      ( mkinfix _1 "or" _3 )
# 8457 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1312 "parsing/parser.mly"
      ( mkinfix _1 "||" _3 )
# 8465 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1314 "parsing/parser.mly"
      ( mkinfix _1 "&" _3 )
# 8473 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1316 "parsing/parser.mly"
      ( mkinfix _1 "&&" _3 )
# 8481 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1318 "parsing/parser.mly"
      ( mkinfix _1 ":=" _3 )
# 8489 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'subtractive) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1320 "parsing/parser.mly"
      ( mkuminus _1 _2 )
# 8497 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'additive) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1322 "parsing/parser.mly"
      ( mkuplus _1 _2 )
# 8505 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'simple_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'label_longident) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1324 "parsing/parser.mly"
      ( mkexp(Pexp_setfield(_1, mkrhs _3 3, _5)) )
# 8514 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 6 : 'simple_expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'seq_expr) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1326 "parsing/parser.mly"
      ( mkexp(Pexp_apply(ghexp(Pexp_ident(array_function "Array" "set")),
                         ["",_1; "",_4; "",_7])) )
# 8524 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 6 : 'simple_expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'seq_expr) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1329 "parsing/parser.mly"
      ( mkexp(Pexp_apply(ghexp(Pexp_ident(array_function "String" "set")),
                         ["",_1; "",_4; "",_7])) )
# 8534 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 6 : 'simple_expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'expr) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1332 "parsing/parser.mly"
      ( bigarray_set _1 _4 _7 )
# 8543 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'label) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1334 "parsing/parser.mly"
      ( mkexp(Pexp_setinstvar(mkrhs _1 1, _3)) )
# 8551 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'simple_expr) in
    Obj.repr(
# 1336 "parsing/parser.mly"
      ( mkexp_attrs (Pexp_assert _3) _2 )
# 8559 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'simple_expr) in
    Obj.repr(
# 1338 "parsing/parser.mly"
      ( mkexp_attrs (Pexp_lazy _3) _2 )
# 8567 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'class_structure) in
    Obj.repr(
# 1340 "parsing/parser.mly"
      ( mkexp_attrs (Pexp_object _3) _2 )
# 8575 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'class_structure) in
    Obj.repr(
# 1342 "parsing/parser.mly"
      ( unclosed "object" 1 "end" 4 )
# 8583 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'attribute) in
    Obj.repr(
# 1344 "parsing/parser.mly"
      ( Exp.attr _1 _2 )
# 8591 "parsing/parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'val_longident) in
    Obj.repr(
# 1348 "parsing/parser.mly"
      ( mkexp(Pexp_ident (mkrhs _1 1)) )
# 8598 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'constant) in
    Obj.repr(
# 1350 "parsing/parser.mly"
      ( mkexp(Pexp_constant _1) )
# 8605 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'constr_longident) in
    Obj.repr(
# 1352 "parsing/parser.mly"
      ( mkexp(Pexp_construct(mkrhs _1 1, None)) )
# 8612 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'name_tag) in
    Obj.repr(
# 1354 "parsing/parser.mly"
      ( mkexp(Pexp_variant(_1, None)) )
# 8619 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    Obj.repr(
# 1356 "parsing/parser.mly"
      ( reloc_exp _2 )
# 8626 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    Obj.repr(
# 1358 "parsing/parser.mly"
      ( unclosed "(" 1 ")" 3 )
# 8633 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    Obj.repr(
# 1360 "parsing/parser.mly"
      ( wrap_exp_attrs (reloc_exp _3) _2 (* check location *) )
# 8641 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'ext_attributes) in
    Obj.repr(
# 1362 "parsing/parser.mly"
      ( mkexp_attrs (Pexp_construct (mkloc (Lident "()") (symbol_rloc ()),
                               None)) _2 )
# 8649 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    Obj.repr(
# 1365 "parsing/parser.mly"
      ( unclosed "begin" 1 "end" 3 )
# 8657 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'seq_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'type_constraint) in
    Obj.repr(
# 1367 "parsing/parser.mly"
      ( mkexp_constraint _2 _3 )
# 8665 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'simple_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'label_longident) in
    Obj.repr(
# 1369 "parsing/parser.mly"
      ( mkexp(Pexp_field(_1, mkrhs _3 3)) )
# 8673 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    Obj.repr(
# 1371 "parsing/parser.mly"
      ( mkexp(Pexp_open(Fresh, mkrhs _1 1, _4)) )
# 8681 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    Obj.repr(
# 1373 "parsing/parser.mly"
      ( unclosed "(" 3 ")" 5 )
# 8689 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'simple_expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    Obj.repr(
# 1375 "parsing/parser.mly"
      ( mkexp(Pexp_apply(ghexp(Pexp_ident(array_function "Array" "get")),
                         ["",_1; "",_4])) )
# 8698 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'simple_expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    Obj.repr(
# 1378 "parsing/parser.mly"
      ( unclosed "(" 3 ")" 5 )
# 8706 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'simple_expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    Obj.repr(
# 1380 "parsing/parser.mly"
      ( mkexp(Pexp_apply(ghexp(Pexp_ident(array_function "String" "get")),
                         ["",_1; "",_4])) )
# 8715 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'simple_expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'seq_expr) in
    Obj.repr(
# 1383 "parsing/parser.mly"
      ( unclosed "[" 3 "]" 5 )
# 8723 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'simple_expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'expr) in
    Obj.repr(
# 1385 "parsing/parser.mly"
      ( bigarray_get _1 _4 )
# 8731 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'simple_expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'expr_comma_list) in
    Obj.repr(
# 1387 "parsing/parser.mly"
      ( unclosed "{" 3 "}" 5 )
# 8739 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'record_expr) in
    Obj.repr(
# 1389 "parsing/parser.mly"
      ( let (exten, fields) = _2 in mkexp (Pexp_record(fields, exten)) )
# 8746 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'record_expr) in
    Obj.repr(
# 1391 "parsing/parser.mly"
      ( unclosed "{" 1 "}" 3 )
# 8753 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'record_expr) in
    Obj.repr(
# 1393 "parsing/parser.mly"
      ( let (exten, fields) = _4 in
        let rec_exp = mkexp(Pexp_record(fields, exten)) in
        mkexp(Pexp_open(Fresh, mkrhs _1 1, rec_exp)) )
# 8763 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'record_expr) in
    Obj.repr(
# 1397 "parsing/parser.mly"
      ( unclosed "{" 3 "}" 5 )
# 8771 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'expr_semi_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
# 1399 "parsing/parser.mly"
      ( mkexp (Pexp_array(List.rev _2)) )
# 8779 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'expr_semi_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
# 1401 "parsing/parser.mly"
      ( unclosed "[|" 1 "|]" 4 )
# 8787 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    Obj.repr(
# 1403 "parsing/parser.mly"
      ( mkexp (Pexp_array []) )
# 8793 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 5 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'expr_semi_list) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
# 1405 "parsing/parser.mly"
      ( mkexp(Pexp_open(Fresh, mkrhs _1 1, mkexp(Pexp_array(List.rev _4)))) )
# 8802 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 5 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'expr_semi_list) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
# 1407 "parsing/parser.mly"
      ( unclosed "[|" 3 "|]" 6 )
# 8811 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'expr_semi_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
# 1409 "parsing/parser.mly"
      ( reloc_exp (mktailexp (rhs_loc 4) (List.rev _2)) )
# 8819 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'expr_semi_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
# 1411 "parsing/parser.mly"
      ( unclosed "[" 1 "]" 4 )
# 8827 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 5 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'expr_semi_list) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
# 1413 "parsing/parser.mly"
      ( let list_exp = reloc_exp (mktailexp (rhs_loc 6) (List.rev _4)) in
        mkexp(Pexp_open(Fresh, mkrhs _1 1, list_exp)) )
# 8837 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 5 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'expr_semi_list) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
# 1416 "parsing/parser.mly"
      ( unclosed "[" 3 "]" 6 )
# 8846 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'simple_expr) in
    Obj.repr(
# 1418 "parsing/parser.mly"
      ( mkexp(Pexp_apply(mkoperator _1 1, ["",_2])) )
# 8854 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'simple_expr) in
    Obj.repr(
# 1420 "parsing/parser.mly"
      ( mkexp(Pexp_apply(mkoperator "!" 1, ["",_2])) )
# 8861 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'class_longident) in
    Obj.repr(
# 1422 "parsing/parser.mly"
      ( mkexp_attrs (Pexp_new(mkrhs _3 3)) _2 )
# 8869 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'field_expr_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
# 1424 "parsing/parser.mly"
      ( mkexp (Pexp_override(List.rev _2)) )
# 8877 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'field_expr_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
# 1426 "parsing/parser.mly"
      ( unclosed "{<" 1 ">}" 4 )
# 8885 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    Obj.repr(
# 1428 "parsing/parser.mly"
      ( mkexp (Pexp_override []))
# 8891 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 5 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'field_expr_list) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
# 1430 "parsing/parser.mly"
      ( mkexp(Pexp_open(Fresh, mkrhs _1 1, mkexp (Pexp_override(List.rev _4)))))
# 8900 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 5 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'field_expr_list) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
# 1432 "parsing/parser.mly"
      ( unclosed "{<" 3 ">}" 6 )
# 8909 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'simple_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'label) in
    Obj.repr(
# 1434 "parsing/parser.mly"
      ( mkexp(Pexp_send(_1, _3)) )
# 8917 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'simple_expr) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'simple_expr) in
    Obj.repr(
# 1436 "parsing/parser.mly"
      ( mkinfix _1 _2 _3 )
# 8926 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'module_expr) in
    Obj.repr(
# 1438 "parsing/parser.mly"
      ( mkexp (Pexp_pack _3) )
# 8933 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'module_expr) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'package_type) in
    Obj.repr(
# 1440 "parsing/parser.mly"
      ( mkexp (Pexp_constraint (ghexp (Pexp_pack _3),
                                ghtyp (Ptyp_package _5))) )
# 8942 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'module_expr) in
    Obj.repr(
# 1443 "parsing/parser.mly"
      ( unclosed "(" 1 ")" 5 )
# 8949 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 7 : 'mod_longident) in
    let _5 = (Parsing.peek_val __caml_parser_env 3 : 'module_expr) in
    let _7 = (Parsing.peek_val __caml_parser_env 1 : 'package_type) in
    Obj.repr(
# 1445 "parsing/parser.mly"
      ( mkexp(Pexp_open(Fresh, mkrhs _1 1,
        mkexp (Pexp_constraint (ghexp (Pexp_pack _5),
                                ghtyp (Ptyp_package _7))))) )
# 8960 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 6 : 'mod_longident) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'module_expr) in
    Obj.repr(
# 1449 "parsing/parser.mly"
      ( unclosed "(" 3 ")" 7 )
# 8968 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'extension) in
    Obj.repr(
# 1451 "parsing/parser.mly"
      ( mkexp (Pexp_extension _1) )
# 8975 "parsing/parser.ml"
               : 'simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'labeled_simple_expr) in
    Obj.repr(
# 1455 "parsing/parser.mly"
      ( [_1] )
# 8982 "parsing/parser.ml"
               : 'simple_labeled_expr_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'simple_labeled_expr_list) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'labeled_simple_expr) in
    Obj.repr(
# 1457 "parsing/parser.mly"
      ( _2 :: _1 )
# 8990 "parsing/parser.ml"
               : 'simple_labeled_expr_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_expr) in
    Obj.repr(
# 1461 "parsing/parser.mly"
      ( ("", _1) )
# 8997 "parsing/parser.ml"
               : 'labeled_simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'label_expr) in
    Obj.repr(
# 1463 "parsing/parser.mly"
      ( _1 )
# 9004 "parsing/parser.ml"
               : 'labeled_simple_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'simple_expr) in
    Obj.repr(
# 1467 "parsing/parser.mly"
      ( (_1, _2) )
# 9012 "parsing/parser.ml"
               : 'label_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'label_ident) in
    Obj.repr(
# 1469 "parsing/parser.mly"
      ( _2 )
# 9019 "parsing/parser.ml"
               : 'label_expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'label_ident) in
    Obj.repr(
# 1471 "parsing/parser.mly"
      ( ("?" ^ fst _2, snd _2) )
# 9026 "parsing/parser.ml"
               : 'label_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'simple_expr) in
    Obj.repr(
# 1473 "parsing/parser.mly"
      ( ("?" ^ _1, _2) )
# 9034 "parsing/parser.ml"
               : 'label_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1476 "parsing/parser.mly"
             ( (_1, mkexp(Pexp_ident(mkrhs (Lident _1) 1))) )
# 9041 "parsing/parser.ml"
               : 'label_ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1479 "parsing/parser.mly"
                                      ( [_1] )
# 9048 "parsing/parser.ml"
               : 'lident_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'lident_list) in
    Obj.repr(
# 1480 "parsing/parser.mly"
                                      ( _1 :: _2 )
# 9056 "parsing/parser.ml"
               : 'lident_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'val_ident) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'fun_binding) in
    Obj.repr(
# 1484 "parsing/parser.mly"
      ( (mkpatvar _1 1, _2) )
# 9064 "parsing/parser.ml"
               : 'let_binding_body))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 6 : 'val_ident) in
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'typevar_list) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'core_type) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 1486 "parsing/parser.mly"
      ( (ghpat(Ppat_constraint(mkpatvar _1 1,
                               ghtyp(Ptyp_poly(List.rev _3,_5)))),
         _7) )
# 9076 "parsing/parser.ml"
               : 'let_binding_body))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 7 : 'val_ident) in
    let _4 = (Parsing.peek_val __caml_parser_env 4 : 'lident_list) in
    let _6 = (Parsing.peek_val __caml_parser_env 2 : 'core_type) in
    let _8 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 1490 "parsing/parser.mly"
      ( let exp, poly = wrap_type_annotation _4 _6 _8 in
        (ghpat(Ppat_constraint(mkpatvar _1 1, poly)), exp) )
# 9087 "parsing/parser.ml"
               : 'let_binding_body))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 1493 "parsing/parser.mly"
      ( (_1, _3) )
# 9095 "parsing/parser.ml"
               : 'let_binding_body))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'simple_pattern_not_ident) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'core_type) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 1495 "parsing/parser.mly"
      ( (ghpat(Ppat_constraint(_1, _3)), _5) )
# 9104 "parsing/parser.ml"
               : 'let_binding_body))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'let_binding) in
    Obj.repr(
# 1498 "parsing/parser.mly"
                                                ( _1 )
# 9111 "parsing/parser.ml"
               : 'let_bindings))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'let_bindings) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'and_let_binding) in
    Obj.repr(
# 1499 "parsing/parser.mly"
                                                ( addlb _1 _2 )
# 9119 "parsing/parser.ml"
               : 'let_bindings))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'ext_attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'rec_flag) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'let_binding_body) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1503 "parsing/parser.mly"
      ( mklbs _2 _3 (mklb _4 _5) )
# 9129 "parsing/parser.ml"
               : 'let_binding))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'let_binding_body) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1507 "parsing/parser.mly"
      ( mklb _2 _3 )
# 9137 "parsing/parser.ml"
               : 'and_let_binding))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'strict_binding) in
    Obj.repr(
# 1511 "parsing/parser.mly"
      ( _1 )
# 9144 "parsing/parser.ml"
               : 'fun_binding))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'type_constraint) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 1513 "parsing/parser.mly"
      ( mkexp_constraint _3 _1 )
# 9152 "parsing/parser.ml"
               : 'fun_binding))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 1517 "parsing/parser.mly"
      ( _2 )
# 9159 "parsing/parser.ml"
               : 'strict_binding))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'labeled_simple_pattern) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'fun_binding) in
    Obj.repr(
# 1519 "parsing/parser.mly"
      ( let (l, o, p) = _1 in ghexp(Pexp_fun(l, o, p, _2)) )
# 9167 "parsing/parser.ml"
               : 'strict_binding))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'fun_binding) in
    Obj.repr(
# 1521 "parsing/parser.mly"
      ( mkexp(Pexp_newtype(_3, _5)) )
# 9175 "parsing/parser.ml"
               : 'strict_binding))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'match_case) in
    Obj.repr(
# 1524 "parsing/parser.mly"
               ( [_1] )
# 9182 "parsing/parser.ml"
               : 'match_cases))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'match_cases) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'match_case) in
    Obj.repr(
# 1525 "parsing/parser.mly"
                               ( _3 :: _1 )
# 9190 "parsing/parser.ml"
               : 'match_cases))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 1529 "parsing/parser.mly"
      ( Exp.case _1 _3 )
# 9198 "parsing/parser.ml"
               : 'match_case))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'pattern) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'seq_expr) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 1531 "parsing/parser.mly"
      ( Exp.case _1 ~guard:_3 _5 )
# 9207 "parsing/parser.ml"
               : 'match_case))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 1534 "parsing/parser.mly"
                                                ( _2 )
# 9214 "parsing/parser.ml"
               : 'fun_def))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'labeled_simple_pattern) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'fun_def) in
    Obj.repr(
# 1537 "parsing/parser.mly"
      (
       let (l,o,p) = _1 in
       ghexp(Pexp_fun(l, o, p, _2))
      )
# 9225 "parsing/parser.ml"
               : 'fun_def))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'fun_def) in
    Obj.repr(
# 1542 "parsing/parser.mly"
      ( mkexp(Pexp_newtype(_3, _5)) )
# 9233 "parsing/parser.ml"
               : 'fun_def))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr_comma_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1545 "parsing/parser.mly"
                                                ( _3 :: _1 )
# 9241 "parsing/parser.ml"
               : 'expr_comma_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1546 "parsing/parser.mly"
                                                ( [_3; _1] )
# 9249 "parsing/parser.ml"
               : 'expr_comma_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'simple_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'lbl_expr_list) in
    Obj.repr(
# 1549 "parsing/parser.mly"
                                                ( (Some _1, _3) )
# 9257 "parsing/parser.ml"
               : 'record_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'lbl_expr_list) in
    Obj.repr(
# 1550 "parsing/parser.mly"
                                                ( (None, _1) )
# 9264 "parsing/parser.ml"
               : 'record_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'lbl_expr) in
    Obj.repr(
# 1553 "parsing/parser.mly"
              ( [_1] )
# 9271 "parsing/parser.ml"
               : 'lbl_expr_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'lbl_expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'lbl_expr_list) in
    Obj.repr(
# 1554 "parsing/parser.mly"
                                 ( _1 :: _3 )
# 9279 "parsing/parser.ml"
               : 'lbl_expr_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'lbl_expr) in
    Obj.repr(
# 1555 "parsing/parser.mly"
                   ( [_1] )
# 9286 "parsing/parser.ml"
               : 'lbl_expr_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'label_longident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1559 "parsing/parser.mly"
      ( (mkrhs _1 1,_3) )
# 9294 "parsing/parser.ml"
               : 'lbl_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'label_longident) in
    Obj.repr(
# 1561 "parsing/parser.mly"
      ( (mkrhs _1 1, exp_of_label _1 1) )
# 9301 "parsing/parser.ml"
               : 'lbl_expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'label) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1565 "parsing/parser.mly"
      ( [mkrhs _1 1,_3] )
# 9309 "parsing/parser.ml"
               : 'field_expr_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'field_expr_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'label) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1567 "parsing/parser.mly"
      ( (mkrhs _3 3, _5) :: _1 )
# 9318 "parsing/parser.ml"
               : 'field_expr_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1570 "parsing/parser.mly"
                                                ( [_1] )
# 9325 "parsing/parser.ml"
               : 'expr_semi_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr_semi_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1571 "parsing/parser.mly"
                                                ( _3 :: _1 )
# 9333 "parsing/parser.ml"
               : 'expr_semi_list))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 1574 "parsing/parser.mly"
                                                ( (Some _2, None) )
# 9340 "parsing/parser.ml"
               : 'type_constraint))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'core_type) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 1575 "parsing/parser.mly"
                                                ( (Some _2, Some _4) )
# 9348 "parsing/parser.ml"
               : 'type_constraint))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 1576 "parsing/parser.mly"
                                                ( (None, Some _2) )
# 9355 "parsing/parser.ml"
               : 'type_constraint))
; (fun __caml_parser_env ->
    Obj.repr(
# 1577 "parsing/parser.mly"
                                                ( syntax_error() )
# 9361 "parsing/parser.ml"
               : 'type_constraint))
; (fun __caml_parser_env ->
    Obj.repr(
# 1578 "parsing/parser.mly"
                                                ( syntax_error() )
# 9367 "parsing/parser.ml"
               : 'type_constraint))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_pattern) in
    Obj.repr(
# 1585 "parsing/parser.mly"
      ( _1 )
# 9374 "parsing/parser.ml"
               : 'pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'val_ident) in
    Obj.repr(
# 1587 "parsing/parser.mly"
      ( mkpat(Ppat_alias(_1, mkrhs _3 3)) )
# 9382 "parsing/parser.ml"
               : 'pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern) in
    Obj.repr(
# 1589 "parsing/parser.mly"
      ( expecting 3 "identifier" )
# 9389 "parsing/parser.ml"
               : 'pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'pattern_comma_list) in
    Obj.repr(
# 1591 "parsing/parser.mly"
      ( mkpat(Ppat_tuple(List.rev _1)) )
# 9396 "parsing/parser.ml"
               : 'pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'constr_longident) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
# 1593 "parsing/parser.mly"
      ( mkpat(Ppat_construct(mkrhs _1 1, Some _2)) )
# 9404 "parsing/parser.ml"
               : 'pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'name_tag) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
# 1595 "parsing/parser.mly"
      ( mkpat(Ppat_variant(_1, Some _2)) )
# 9412 "parsing/parser.ml"
               : 'pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
# 1597 "parsing/parser.mly"
      ( mkpat_cons (rhs_loc 2) (ghpat(Ppat_tuple[_1;_3])) (symbol_rloc()) )
# 9420 "parsing/parser.ml"
               : 'pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern) in
    Obj.repr(
# 1599 "parsing/parser.mly"
      ( expecting 3 "pattern" )
# 9427 "parsing/parser.ml"
               : 'pattern))
; (fun __caml_parser_env ->
    let _5 = (Parsing.peek_val __caml_parser_env 3 : 'pattern) in
    let _7 = (Parsing.peek_val __caml_parser_env 1 : 'pattern) in
    Obj.repr(
# 1601 "parsing/parser.mly"
      ( mkpat_cons (rhs_loc 2) (ghpat(Ppat_tuple[_5;_7])) (symbol_rloc()) )
# 9435 "parsing/parser.ml"
               : 'pattern))
; (fun __caml_parser_env ->
    let _5 = (Parsing.peek_val __caml_parser_env 3 : 'pattern) in
    let _7 = (Parsing.peek_val __caml_parser_env 1 : 'pattern) in
    Obj.repr(
# 1603 "parsing/parser.mly"
      ( unclosed "(" 4 ")" 8 )
# 9443 "parsing/parser.ml"
               : 'pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
# 1605 "parsing/parser.mly"
      ( mkpat(Ppat_or(_1, _3)) )
# 9451 "parsing/parser.ml"
               : 'pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern) in
    Obj.repr(
# 1607 "parsing/parser.mly"
      ( expecting 3 "pattern" )
# 9458 "parsing/parser.ml"
               : 'pattern))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'simple_pattern) in
    Obj.repr(
# 1609 "parsing/parser.mly"
      ( mkpat(Ppat_lazy _2) )
# 9465 "parsing/parser.ml"
               : 'pattern))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
# 1611 "parsing/parser.mly"
      ( mkpat(Ppat_exception _2) )
# 9472 "parsing/parser.ml"
               : 'pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'pattern) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'attribute) in
    Obj.repr(
# 1613 "parsing/parser.mly"
      ( Pat.attr _1 _2 )
# 9480 "parsing/parser.ml"
               : 'pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'val_ident) in
    Obj.repr(
# 1617 "parsing/parser.mly"
      ( mkpat(Ppat_var (mkrhs _1 1)) )
# 9487 "parsing/parser.ml"
               : 'simple_pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_pattern_not_ident) in
    Obj.repr(
# 1618 "parsing/parser.mly"
                             ( _1 )
# 9494 "parsing/parser.ml"
               : 'simple_pattern))
; (fun __caml_parser_env ->
    Obj.repr(
# 1622 "parsing/parser.mly"
      ( mkpat(Ppat_any) )
# 9500 "parsing/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'signed_constant) in
    Obj.repr(
# 1624 "parsing/parser.mly"
      ( mkpat(Ppat_constant _1) )
# 9507 "parsing/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'signed_constant) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'signed_constant) in
    Obj.repr(
# 1626 "parsing/parser.mly"
      ( mkpat(Ppat_interval (_1, _3)) )
# 9515 "parsing/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'constr_longident) in
    Obj.repr(
# 1628 "parsing/parser.mly"
      ( mkpat(Ppat_construct(mkrhs _1 1, None)) )
# 9522 "parsing/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'name_tag) in
    Obj.repr(
# 1630 "parsing/parser.mly"
      ( mkpat(Ppat_variant(_1, None)) )
# 9529 "parsing/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'type_longident) in
    Obj.repr(
# 1632 "parsing/parser.mly"
      ( mkpat(Ppat_type (mkrhs _2 2)) )
# 9536 "parsing/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'lbl_pattern_list) in
    Obj.repr(
# 1634 "parsing/parser.mly"
      ( let (fields, closed) = _2 in mkpat(Ppat_record(fields, closed)) )
# 9543 "parsing/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'lbl_pattern_list) in
    Obj.repr(
# 1636 "parsing/parser.mly"
      ( unclosed "{" 1 "}" 3 )
# 9550 "parsing/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'pattern_semi_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
# 1638 "parsing/parser.mly"
      ( reloc_pat (mktailpat (rhs_loc 4) (List.rev _2)) )
# 9558 "parsing/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'pattern_semi_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
# 1640 "parsing/parser.mly"
      ( unclosed "[" 1 "]" 4 )
# 9566 "parsing/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'pattern_semi_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
# 1642 "parsing/parser.mly"
      ( mkpat(Ppat_array(List.rev _2)) )
# 9574 "parsing/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    Obj.repr(
# 1644 "parsing/parser.mly"
      ( mkpat(Ppat_array []) )
# 9580 "parsing/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'pattern_semi_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'opt_semi) in
    Obj.repr(
# 1646 "parsing/parser.mly"
      ( unclosed "[|" 1 "|]" 4 )
# 9588 "parsing/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'pattern) in
    Obj.repr(
# 1648 "parsing/parser.mly"
      ( reloc_pat _2 )
# 9595 "parsing/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'pattern) in
    Obj.repr(
# 1650 "parsing/parser.mly"
      ( unclosed "(" 1 ")" 3 )
# 9602 "parsing/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'pattern) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'core_type) in
    Obj.repr(
# 1652 "parsing/parser.mly"
      ( mkpat(Ppat_constraint(_2, _4)) )
# 9610 "parsing/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'pattern) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'core_type) in
    Obj.repr(
# 1654 "parsing/parser.mly"
      ( unclosed "(" 1 ")" 5 )
# 9618 "parsing/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'pattern) in
    Obj.repr(
# 1656 "parsing/parser.mly"
      ( expecting 4 "type" )
# 9625 "parsing/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : string) in
    Obj.repr(
# 1658 "parsing/parser.mly"
      ( mkpat(Ppat_unpack (mkrhs _3 3)) )
# 9632 "parsing/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'package_type) in
    Obj.repr(
# 1660 "parsing/parser.mly"
      ( mkpat(Ppat_constraint(mkpat(Ppat_unpack (mkrhs _3 3)),
                              ghtyp(Ptyp_package _5))) )
# 9641 "parsing/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'package_type) in
    Obj.repr(
# 1663 "parsing/parser.mly"
      ( unclosed "(" 1 ")" 6 )
# 9649 "parsing/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'extension) in
    Obj.repr(
# 1665 "parsing/parser.mly"
      ( mkpat(Ppat_extension _1) )
# 9656 "parsing/parser.ml"
               : 'simple_pattern_not_ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern_comma_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
# 1669 "parsing/parser.mly"
                                                ( _3 :: _1 )
# 9664 "parsing/parser.ml"
               : 'pattern_comma_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
# 1670 "parsing/parser.mly"
                                                ( [_3; _1] )
# 9672 "parsing/parser.ml"
               : 'pattern_comma_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern) in
    Obj.repr(
# 1671 "parsing/parser.mly"
                                                ( expecting 3 "pattern" )
# 9679 "parsing/parser.ml"
               : 'pattern_comma_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
# 1674 "parsing/parser.mly"
                                                ( [_1] )
# 9686 "parsing/parser.ml"
               : 'pattern_semi_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pattern_semi_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
# 1675 "parsing/parser.mly"
                                                ( _3 :: _1 )
# 9694 "parsing/parser.ml"
               : 'pattern_semi_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'lbl_pattern) in
    Obj.repr(
# 1678 "parsing/parser.mly"
                ( [_1], Closed )
# 9701 "parsing/parser.ml"
               : 'lbl_pattern_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'lbl_pattern) in
    Obj.repr(
# 1679 "parsing/parser.mly"
                     ( [_1], Closed )
# 9708 "parsing/parser.ml"
               : 'lbl_pattern_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'lbl_pattern) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'opt_semi) in
    Obj.repr(
# 1680 "parsing/parser.mly"
                                         ( [_1], Open )
# 9716 "parsing/parser.ml"
               : 'lbl_pattern_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'lbl_pattern) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'lbl_pattern_list) in
    Obj.repr(
# 1682 "parsing/parser.mly"
      ( let (fields, closed) = _3 in _1 :: fields, closed )
# 9724 "parsing/parser.ml"
               : 'lbl_pattern_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'label_longident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
# 1686 "parsing/parser.mly"
      ( (mkrhs _1 1,_3) )
# 9732 "parsing/parser.ml"
               : 'lbl_pattern))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'label_longident) in
    Obj.repr(
# 1688 "parsing/parser.mly"
      ( (mkrhs _1 1, pat_of_label _1 1) )
# 9739 "parsing/parser.ml"
               : 'lbl_pattern))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'val_ident) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'core_type) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1695 "parsing/parser.mly"
      ( Val.mk (mkrhs _2 2) _4 ~attrs:_5
               ~loc:(symbol_rloc()) ~docs:(symbol_docs ()) )
# 9749 "parsing/parser.ml"
               : 'value_description))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string * string option) in
    Obj.repr(
# 1702 "parsing/parser.mly"
                                                ( [fst _1] )
# 9756 "parsing/parser.ml"
               : 'primitive_declaration_body))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : string * string option) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'primitive_declaration_body) in
    Obj.repr(
# 1703 "parsing/parser.mly"
                                                ( fst _1 :: _2 )
# 9764 "parsing/parser.ml"
               : 'primitive_declaration_body))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 5 : 'val_ident) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'core_type) in
    let _6 = (Parsing.peek_val __caml_parser_env 1 : 'primitive_declaration_body) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1708 "parsing/parser.mly"
      ( Val.mk (mkrhs _2 2) _4 ~prim:_6 ~attrs:_7
               ~loc:(symbol_rloc ()) ~docs:(symbol_docs ()) )
# 9775 "parsing/parser.ml"
               : 'primitive_declaration))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'type_declaration) in
    Obj.repr(
# 1715 "parsing/parser.mly"
                                                ( [_1] )
# 9782 "parsing/parser.ml"
               : 'type_declarations))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'type_declarations) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'and_type_declaration) in
    Obj.repr(
# 1716 "parsing/parser.mly"
                                                ( _2 :: _1 )
# 9790 "parsing/parser.ml"
               : 'type_declarations))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 5 : 'nonrec_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'optional_type_parameters) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'type_kind) in
    let _6 = (Parsing.peek_val __caml_parser_env 1 : 'constraints) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1722 "parsing/parser.mly"
      ( let (kind, priv, manifest) = _5 in
          Type.mk (mkrhs _4 4) ~params:_3 ~cstrs:(List.rev _6) ~kind
            ~priv ?manifest ~attrs:(add_nonrec _2 _7 2)
            ~loc:(symbol_rloc ()) ~docs:(symbol_docs ()) )
# 9805 "parsing/parser.ml"
               : 'type_declaration))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : 'optional_type_parameters) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'type_kind) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'constraints) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1730 "parsing/parser.mly"
      ( let (kind, priv, manifest) = _4 in
          Type.mk (mkrhs _3 3) ~params:_2 ~cstrs:(List.rev _5)
            ~kind ~priv ?manifest ~attrs:_6 ~loc:(symbol_rloc ())
            ~text:(symbol_text ()) ~docs:(symbol_docs ()) )
# 9819 "parsing/parser.ml"
               : 'and_type_declaration))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'constraints) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'constrain) in
    Obj.repr(
# 1736 "parsing/parser.mly"
                                                ( _3 :: _1 )
# 9827 "parsing/parser.ml"
               : 'constraints))
; (fun __caml_parser_env ->
    Obj.repr(
# 1737 "parsing/parser.mly"
                                                ( [] )
# 9833 "parsing/parser.ml"
               : 'constraints))
; (fun __caml_parser_env ->
    Obj.repr(
# 1741 "parsing/parser.mly"
      ( (Ptype_abstract, Public, None) )
# 9839 "parsing/parser.ml"
               : 'type_kind))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 1743 "parsing/parser.mly"
      ( (Ptype_abstract, Public, Some _2) )
# 9846 "parsing/parser.ml"
               : 'type_kind))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 1745 "parsing/parser.mly"
      ( (Ptype_abstract, Private, Some _3) )
# 9853 "parsing/parser.ml"
               : 'type_kind))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'constructor_declarations) in
    Obj.repr(
# 1747 "parsing/parser.mly"
      ( (Ptype_variant(List.rev _2), Public, None) )
# 9860 "parsing/parser.ml"
               : 'type_kind))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'constructor_declarations) in
    Obj.repr(
# 1749 "parsing/parser.mly"
      ( (Ptype_variant(List.rev _3), Private, None) )
# 9867 "parsing/parser.ml"
               : 'type_kind))
; (fun __caml_parser_env ->
    Obj.repr(
# 1751 "parsing/parser.mly"
      ( (Ptype_open, Public, None) )
# 9873 "parsing/parser.ml"
               : 'type_kind))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'private_flag) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'label_declarations) in
    Obj.repr(
# 1753 "parsing/parser.mly"
      ( (Ptype_record _4, _2, None) )
# 9881 "parsing/parser.ml"
               : 'type_kind))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'core_type) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'private_flag) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'constructor_declarations) in
    Obj.repr(
# 1755 "parsing/parser.mly"
      ( (Ptype_variant(List.rev _5), _4, Some _2) )
# 9890 "parsing/parser.ml"
               : 'type_kind))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'core_type) in
    Obj.repr(
# 1757 "parsing/parser.mly"
      ( (Ptype_open, Public, Some _2) )
# 9897 "parsing/parser.ml"
               : 'type_kind))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 5 : 'core_type) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'private_flag) in
    let _6 = (Parsing.peek_val __caml_parser_env 1 : 'label_declarations) in
    Obj.repr(
# 1759 "parsing/parser.mly"
      ( (Ptype_record _6, _4, Some _2) )
# 9906 "parsing/parser.ml"
               : 'type_kind))
; (fun __caml_parser_env ->
    Obj.repr(
# 1762 "parsing/parser.mly"
                                                ( [] )
# 9912 "parsing/parser.ml"
               : 'optional_type_parameters))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'optional_type_parameter) in
    Obj.repr(
# 1763 "parsing/parser.mly"
                                                ( [_1] )
# 9919 "parsing/parser.ml"
               : 'optional_type_parameters))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'optional_type_parameter_list) in
    Obj.repr(
# 1764 "parsing/parser.mly"
                                                ( List.rev _2 )
# 9926 "parsing/parser.ml"
               : 'optional_type_parameters))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'type_variance) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'optional_type_variable) in
    Obj.repr(
# 1767 "parsing/parser.mly"
                                                ( _2, _1 )
# 9934 "parsing/parser.ml"
               : 'optional_type_parameter))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'optional_type_parameter) in
    Obj.repr(
# 1770 "parsing/parser.mly"
                                                         ( [_1] )
# 9941 "parsing/parser.ml"
               : 'optional_type_parameter_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'optional_type_parameter_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'optional_type_parameter) in
    Obj.repr(
# 1771 "parsing/parser.mly"
                                                                  ( _3 :: _1 )
# 9949 "parsing/parser.ml"
               : 'optional_type_parameter_list))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'ident) in
    Obj.repr(
# 1774 "parsing/parser.mly"
                                                ( mktyp(Ptyp_var _2) )
# 9956 "parsing/parser.ml"
               : 'optional_type_variable))
; (fun __caml_parser_env ->
    Obj.repr(
# 1775 "parsing/parser.mly"
                                                ( mktyp(Ptyp_any) )
# 9962 "parsing/parser.ml"
               : 'optional_type_variable))
; (fun __caml_parser_env ->
    Obj.repr(
# 1780 "parsing/parser.mly"
                                                ( [] )
# 9968 "parsing/parser.ml"
               : 'type_parameters))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'type_parameter) in
    Obj.repr(
# 1781 "parsing/parser.mly"
                                                ( [_1] )
# 9975 "parsing/parser.ml"
               : 'type_parameters))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'type_parameter_list) in
    Obj.repr(
# 1782 "parsing/parser.mly"
                                                ( List.rev _2 )
# 9982 "parsing/parser.ml"
               : 'type_parameters))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'type_variance) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'type_variable) in
    Obj.repr(
# 1785 "parsing/parser.mly"
                                                  ( _2, _1 )
# 9990 "parsing/parser.ml"
               : 'type_parameter))
; (fun __caml_parser_env ->
    Obj.repr(
# 1788 "parsing/parser.mly"
                                                ( Invariant )
# 9996 "parsing/parser.ml"
               : 'type_variance))
; (fun __caml_parser_env ->
    Obj.repr(
# 1789 "parsing/parser.mly"
                                                ( Covariant )
# 10002 "parsing/parser.ml"
               : 'type_variance))
; (fun __caml_parser_env ->
    Obj.repr(
# 1790 "parsing/parser.mly"
                                                ( Contravariant )
# 10008 "parsing/parser.ml"
               : 'type_variance))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'ident) in
    Obj.repr(
# 1793 "parsing/parser.mly"
                                                ( mktyp(Ptyp_var _2) )
# 10015 "parsing/parser.ml"
               : 'type_variable))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'type_parameter) in
    Obj.repr(
# 1796 "parsing/parser.mly"
                                                ( [_1] )
# 10022 "parsing/parser.ml"
               : 'type_parameter_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'type_parameter_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'type_parameter) in
    Obj.repr(
# 1797 "parsing/parser.mly"
                                                ( _3 :: _1 )
# 10030 "parsing/parser.ml"
               : 'type_parameter_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'constructor_declaration) in
    Obj.repr(
# 1800 "parsing/parser.mly"
                                                         ( [_1] )
# 10037 "parsing/parser.ml"
               : 'constructor_declarations))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'bar_constructor_declaration) in
    Obj.repr(
# 1801 "parsing/parser.mly"
                                                         ( [_1] )
# 10044 "parsing/parser.ml"
               : 'constructor_declarations))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'constructor_declarations) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'bar_constructor_declaration) in
    Obj.repr(
# 1802 "parsing/parser.mly"
                                                         ( _2 :: _1 )
# 10052 "parsing/parser.ml"
               : 'constructor_declarations))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'constr_ident) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'generalized_constructor_arguments) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
# 1806 "parsing/parser.mly"
      (
       let args,res = _2 in
       Type.constructor (mkrhs _1 1) ~args ?res ~attrs:_3
         ~loc:(symbol_rloc()) ~info:(symbol_info ())
      )
# 10065 "parsing/parser.ml"
               : 'constructor_declaration))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'constr_ident) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'generalized_constructor_arguments) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
# 1814 "parsing/parser.mly"
      (
       let args,res = _3 in
       Type.constructor (mkrhs _2 2) ~args ?res ~attrs:_4
         ~loc:(symbol_rloc()) ~info:(symbol_info ())
      )
# 10078 "parsing/parser.ml"
               : 'bar_constructor_declaration))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'sig_exception_declaration) in
    Obj.repr(
# 1821 "parsing/parser.mly"
                                                 ( _1 )
# 10085 "parsing/parser.ml"
               : 'str_exception_declaration))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : 'constr_ident) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'constr_longident) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'attributes) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1824 "parsing/parser.mly"
      ( Te.rebind (mkrhs _2 2) (mkrhs _4 4) ~attrs:(_5 @ _6)
          ~loc:(symbol_rloc()) ~docs:(symbol_docs ()) )
# 10096 "parsing/parser.ml"
               : 'str_exception_declaration))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'constr_ident) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'generalized_constructor_arguments) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'attributes) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1830 "parsing/parser.mly"
      ( let args, res = _3 in
          Te.decl (mkrhs _2 2) ~args ?res ~attrs:(_4 @ _5)
            ~loc:(symbol_rloc()) ~docs:(symbol_docs ()) )
# 10108 "parsing/parser.ml"
               : 'sig_exception_declaration))
; (fun __caml_parser_env ->
    Obj.repr(
# 1835 "parsing/parser.mly"
                                                ( ([],None) )
# 10114 "parsing/parser.ml"
               : 'generalized_constructor_arguments))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'core_type_list_no_attr) in
    Obj.repr(
# 1836 "parsing/parser.mly"
                                                ( (List.rev _2,None) )
# 10121 "parsing/parser.ml"
               : 'generalized_constructor_arguments))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'core_type_list_no_attr) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'simple_core_type_no_attr) in
    Obj.repr(
# 1838 "parsing/parser.mly"
                                                ( (List.rev _2,Some _4) )
# 10129 "parsing/parser.ml"
               : 'generalized_constructor_arguments))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'simple_core_type_no_attr) in
    Obj.repr(
# 1840 "parsing/parser.mly"
                                                ( ([],Some _2) )
# 10136 "parsing/parser.ml"
               : 'generalized_constructor_arguments))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'label_declaration) in
    Obj.repr(
# 1846 "parsing/parser.mly"
                                                ( [_1] )
# 10143 "parsing/parser.ml"
               : 'label_declarations))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'label_declaration_semi) in
    Obj.repr(
# 1847 "parsing/parser.mly"
                                                ( [_1] )
# 10150 "parsing/parser.ml"
               : 'label_declarations))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'label_declaration_semi) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'label_declarations) in
    Obj.repr(
# 1848 "parsing/parser.mly"
                                                ( _1 :: _2 )
# 10158 "parsing/parser.ml"
               : 'label_declarations))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'mutable_flag) in
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'label) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'poly_type_no_attr) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
# 1852 "parsing/parser.mly"
      (
       Type.field (mkrhs _2 2) _4 ~mut:_1 ~attrs:_5
         ~loc:(symbol_rloc()) ~info:(symbol_info ())
      )
# 10171 "parsing/parser.ml"
               : 'label_declaration))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 6 : 'mutable_flag) in
    let _2 = (Parsing.peek_val __caml_parser_env 5 : 'label) in
    let _4 = (Parsing.peek_val __caml_parser_env 3 : 'poly_type_no_attr) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'attributes) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
# 1859 "parsing/parser.mly"
      (
       let info =
         match rhs_info 5 with
         | Some _ as info_before_semi -> info_before_semi
         | None -> symbol_info ()
       in
       Type.field (mkrhs _2 2) _4 ~mut:_1 ~attrs:(_5 @ _7)
         ~loc:(symbol_rloc()) ~info
      )
# 10190 "parsing/parser.ml"
               : 'label_declaration_semi))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 6 : 'nonrec_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 5 : 'optional_type_parameters) in
    let _4 = (Parsing.peek_val __caml_parser_env 4 : 'type_longident) in
    let _6 = (Parsing.peek_val __caml_parser_env 2 : 'private_flag) in
    let _7 = (Parsing.peek_val __caml_parser_env 1 : 'str_extension_constructors) in
    let _8 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1875 "parsing/parser.mly"
      ( if _2 <> Recursive then not_expecting 2 "nonrec flag";
        Te.mk (mkrhs _4 4) (List.rev _7) ~params:_3 ~priv:_6
          ~attrs:_8 ~docs:(symbol_docs ()) )
# 10204 "parsing/parser.ml"
               : 'str_type_extension))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 6 : 'nonrec_flag) in
    let _3 = (Parsing.peek_val __caml_parser_env 5 : 'optional_type_parameters) in
    let _4 = (Parsing.peek_val __caml_parser_env 4 : 'type_longident) in
    let _6 = (Parsing.peek_val __caml_parser_env 2 : 'private_flag) in
    let _7 = (Parsing.peek_val __caml_parser_env 1 : 'sig_extension_constructors) in
    let _8 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 1882 "parsing/parser.mly"
      ( if _2 <> Recursive then not_expecting 2 "nonrec flag";
        Te.mk (mkrhs _4 4) (List.rev _7) ~params:_3 ~priv:_6
          ~attrs:_8 ~docs:(symbol_docs ()) )
# 10218 "parsing/parser.ml"
               : 'sig_type_extension))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'extension_constructor_declaration) in
    Obj.repr(
# 1887 "parsing/parser.mly"
                                                          ( [_1] )
# 10225 "parsing/parser.ml"
               : 'str_extension_constructors))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'bar_extension_constructor_declaration) in
    Obj.repr(
# 1888 "parsing/parser.mly"
                                                          ( [_1] )
# 10232 "parsing/parser.ml"
               : 'str_extension_constructors))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'extension_constructor_rebind) in
    Obj.repr(
# 1889 "parsing/parser.mly"
                                                          ( [_1] )
# 10239 "parsing/parser.ml"
               : 'str_extension_constructors))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'bar_extension_constructor_rebind) in
    Obj.repr(
# 1890 "parsing/parser.mly"
                                                          ( [_1] )
# 10246 "parsing/parser.ml"
               : 'str_extension_constructors))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'str_extension_constructors) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'bar_extension_constructor_declaration) in
    Obj.repr(
# 1892 "parsing/parser.mly"
      ( _2 :: _1 )
# 10254 "parsing/parser.ml"
               : 'str_extension_constructors))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'str_extension_constructors) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'bar_extension_constructor_rebind) in
    Obj.repr(
# 1894 "parsing/parser.mly"
      ( _2 :: _1 )
# 10262 "parsing/parser.ml"
               : 'str_extension_constructors))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'extension_constructor_declaration) in
    Obj.repr(
# 1897 "parsing/parser.mly"
                                                          ( [_1] )
# 10269 "parsing/parser.ml"
               : 'sig_extension_constructors))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'bar_extension_constructor_declaration) in
    Obj.repr(
# 1898 "parsing/parser.mly"
                                                          ( [_1] )
# 10276 "parsing/parser.ml"
               : 'sig_extension_constructors))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'sig_extension_constructors) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'bar_extension_constructor_declaration) in
    Obj.repr(
# 1900 "parsing/parser.mly"
      ( _2 :: _1 )
# 10284 "parsing/parser.ml"
               : 'sig_extension_constructors))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'constr_ident) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'generalized_constructor_arguments) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
# 1904 "parsing/parser.mly"
      ( let args, res = _2 in
        Te.decl (mkrhs _1 1) ~args ?res ~attrs:_3
          ~loc:(symbol_rloc()) ~info:(symbol_info ()) )
# 10295 "parsing/parser.ml"
               : 'extension_constructor_declaration))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'constr_ident) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'generalized_constructor_arguments) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
# 1910 "parsing/parser.mly"
      ( let args, res = _3 in
        Te.decl (mkrhs _2 2) ~args ?res ~attrs:_4
           ~loc:(symbol_rloc()) ~info:(symbol_info ()) )
# 10306 "parsing/parser.ml"
               : 'bar_extension_constructor_declaration))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'constr_ident) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'constr_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
# 1916 "parsing/parser.mly"
      ( Te.rebind (mkrhs _1 1) (mkrhs _3 3) ~attrs:_4
          ~loc:(symbol_rloc()) ~info:(symbol_info ()) )
# 10316 "parsing/parser.ml"
               : 'extension_constructor_rebind))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'constr_ident) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'constr_longident) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
# 1921 "parsing/parser.mly"
      ( Te.rebind (mkrhs _2 2) (mkrhs _4 4) ~attrs:_5
          ~loc:(symbol_rloc()) ~info:(symbol_info ()) )
# 10326 "parsing/parser.ml"
               : 'bar_extension_constructor_rebind))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'with_constraint) in
    Obj.repr(
# 1928 "parsing/parser.mly"
                                                ( [_1] )
# 10333 "parsing/parser.ml"
               : 'with_constraints))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'with_constraints) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'with_constraint) in
    Obj.repr(
# 1929 "parsing/parser.mly"
                                                ( _3 :: _1 )
# 10341 "parsing/parser.ml"
               : 'with_constraints))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : 'type_parameters) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'label_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'with_type_binder) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'core_type_no_attr) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'constraints) in
    Obj.repr(
# 1933 "parsing/parser.mly"
      ( Pwith_type
          (mkrhs _3 3,
           (Type.mk (mkrhs (Longident.last _3) 3)
              ~params:_2
              ~cstrs:(List.rev _6)
              ~manifest:_5
              ~priv:_4
              ~loc:(symbol_rloc()))) )
# 10359 "parsing/parser.ml"
               : 'with_constraint))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'type_parameters) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'label) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'core_type_no_attr) in
    Obj.repr(
# 1944 "parsing/parser.mly"
      ( Pwith_typesubst
          (Type.mk (mkrhs _3 3)
             ~params:_2
             ~manifest:_5
             ~loc:(symbol_rloc())) )
# 10372 "parsing/parser.ml"
               : 'with_constraint))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'mod_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'mod_ext_longident) in
    Obj.repr(
# 1950 "parsing/parser.mly"
      ( Pwith_module (mkrhs _2 2, mkrhs _4 4) )
# 10380 "parsing/parser.ml"
               : 'with_constraint))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'mod_ext_longident) in
    Obj.repr(
# 1952 "parsing/parser.mly"
      ( Pwith_modsubst (mkrhs _2 2, mkrhs _4 4) )
# 10388 "parsing/parser.ml"
               : 'with_constraint))
; (fun __caml_parser_env ->
    Obj.repr(
# 1955 "parsing/parser.mly"
                   ( Public )
# 10394 "parsing/parser.ml"
               : 'with_type_binder))
; (fun __caml_parser_env ->
    Obj.repr(
# 1956 "parsing/parser.mly"
                   ( Private )
# 10400 "parsing/parser.ml"
               : 'with_type_binder))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'ident) in
    Obj.repr(
# 1962 "parsing/parser.mly"
                                                ( [_2] )
# 10407 "parsing/parser.ml"
               : 'typevar_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'typevar_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'ident) in
    Obj.repr(
# 1963 "parsing/parser.mly"
                                                ( _3 :: _1 )
# 10415 "parsing/parser.ml"
               : 'typevar_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 1967 "parsing/parser.mly"
          ( _1 )
# 10422 "parsing/parser.ml"
               : 'poly_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'typevar_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 1969 "parsing/parser.mly"
          ( mktyp(Ptyp_poly(List.rev _1, _3)) )
# 10430 "parsing/parser.ml"
               : 'poly_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'core_type_no_attr) in
    Obj.repr(
# 1973 "parsing/parser.mly"
          ( _1 )
# 10437 "parsing/parser.ml"
               : 'poly_type_no_attr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'typevar_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'core_type_no_attr) in
    Obj.repr(
# 1975 "parsing/parser.mly"
          ( mktyp(Ptyp_poly(List.rev _1, _3)) )
# 10445 "parsing/parser.ml"
               : 'poly_type_no_attr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'core_type_no_attr) in
    Obj.repr(
# 1982 "parsing/parser.mly"
      ( _1 )
# 10452 "parsing/parser.ml"
               : 'core_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'core_type) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'attribute) in
    Obj.repr(
# 1984 "parsing/parser.mly"
      ( Typ.attr _1 _2 )
# 10460 "parsing/parser.ml"
               : 'core_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'core_type2) in
    Obj.repr(
# 1988 "parsing/parser.mly"
      ( _1 )
# 10467 "parsing/parser.ml"
               : 'core_type_no_attr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'core_type2) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'ident) in
    Obj.repr(
# 1990 "parsing/parser.mly"
      ( mktyp(Ptyp_alias(_1, _4)) )
# 10475 "parsing/parser.ml"
               : 'core_type_no_attr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_core_type_or_tuple) in
    Obj.repr(
# 1994 "parsing/parser.mly"
      ( _1 )
# 10482 "parsing/parser.ml"
               : 'core_type2))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'core_type2) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'core_type2) in
    Obj.repr(
# 1996 "parsing/parser.mly"
      ( mktyp(Ptyp_arrow("?" ^ _2 , mkoption _4, _6)) )
# 10491 "parsing/parser.ml"
               : 'core_type2))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'core_type2) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'core_type2) in
    Obj.repr(
# 1998 "parsing/parser.mly"
      ( mktyp(Ptyp_arrow("?" ^ _1 , mkoption _2, _4)) )
# 10500 "parsing/parser.ml"
               : 'core_type2))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'core_type2) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'core_type2) in
    Obj.repr(
# 2000 "parsing/parser.mly"
      ( mktyp(Ptyp_arrow(_1, _3, _5)) )
# 10509 "parsing/parser.ml"
               : 'core_type2))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'core_type2) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'core_type2) in
    Obj.repr(
# 2002 "parsing/parser.mly"
      ( mktyp(Ptyp_arrow("", _1, _3)) )
# 10517 "parsing/parser.ml"
               : 'core_type2))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_core_type2) in
    Obj.repr(
# 2007 "parsing/parser.mly"
      ( _1 )
# 10524 "parsing/parser.ml"
               : 'simple_core_type))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'core_type_comma_list) in
    Obj.repr(
# 2009 "parsing/parser.mly"
      ( match _2 with [sty] -> sty | _ -> raise Parse_error )
# 10531 "parsing/parser.ml"
               : 'simple_core_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_core_type2) in
    Obj.repr(
# 2014 "parsing/parser.mly"
      ( _1 )
# 10538 "parsing/parser.ml"
               : 'simple_core_type_no_attr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'core_type_comma_list) in
    Obj.repr(
# 2016 "parsing/parser.mly"
      ( match _2 with [sty] -> sty | _ -> raise Parse_error )
# 10545 "parsing/parser.ml"
               : 'simple_core_type_no_attr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'ident) in
    Obj.repr(
# 2021 "parsing/parser.mly"
      ( mktyp(Ptyp_var _2) )
# 10552 "parsing/parser.ml"
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    Obj.repr(
# 2023 "parsing/parser.mly"
      ( mktyp(Ptyp_any) )
# 10558 "parsing/parser.ml"
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'type_longident) in
    Obj.repr(
# 2025 "parsing/parser.mly"
      ( mktyp(Ptyp_constr(mkrhs _1 1, [])) )
# 10565 "parsing/parser.ml"
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'simple_core_type2) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'type_longident) in
    Obj.repr(
# 2027 "parsing/parser.mly"
      ( mktyp(Ptyp_constr(mkrhs _2 2, [_1])) )
# 10573 "parsing/parser.ml"
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'core_type_comma_list) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'type_longident) in
    Obj.repr(
# 2029 "parsing/parser.mly"
      ( mktyp(Ptyp_constr(mkrhs _4 4, List.rev _2)) )
# 10581 "parsing/parser.ml"
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'meth_list) in
    Obj.repr(
# 2031 "parsing/parser.mly"
      ( let (f, c) = _2 in mktyp(Ptyp_object (f, c)) )
# 10588 "parsing/parser.ml"
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    Obj.repr(
# 2033 "parsing/parser.mly"
      ( mktyp(Ptyp_object ([], Closed)) )
# 10594 "parsing/parser.ml"
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'class_longident) in
    Obj.repr(
# 2035 "parsing/parser.mly"
      ( mktyp(Ptyp_class(mkrhs _2 2, [])) )
# 10601 "parsing/parser.ml"
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'simple_core_type2) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'class_longident) in
    Obj.repr(
# 2037 "parsing/parser.mly"
      ( mktyp(Ptyp_class(mkrhs _3 3, [_1])) )
# 10609 "parsing/parser.ml"
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'core_type_comma_list) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'class_longident) in
    Obj.repr(
# 2039 "parsing/parser.mly"
      ( mktyp(Ptyp_class(mkrhs _5 5, List.rev _2)) )
# 10617 "parsing/parser.ml"
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'tag_field) in
    Obj.repr(
# 2041 "parsing/parser.mly"
      ( mktyp(Ptyp_variant([_2], Closed, None)) )
# 10624 "parsing/parser.ml"
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'row_field_list) in
    Obj.repr(
# 2047 "parsing/parser.mly"
      ( mktyp(Ptyp_variant(List.rev _3, Closed, None)) )
# 10631 "parsing/parser.ml"
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'row_field) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'row_field_list) in
    Obj.repr(
# 2049 "parsing/parser.mly"
      ( mktyp(Ptyp_variant(_2 :: List.rev _4, Closed, None)) )
# 10639 "parsing/parser.ml"
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'opt_bar) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'row_field_list) in
    Obj.repr(
# 2051 "parsing/parser.mly"
      ( mktyp(Ptyp_variant(List.rev _3, Open, None)) )
# 10647 "parsing/parser.ml"
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    Obj.repr(
# 2053 "parsing/parser.mly"
      ( mktyp(Ptyp_variant([], Open, None)) )
# 10653 "parsing/parser.ml"
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'opt_bar) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'row_field_list) in
    Obj.repr(
# 2055 "parsing/parser.mly"
      ( mktyp(Ptyp_variant(List.rev _3, Closed, Some [])) )
# 10661 "parsing/parser.ml"
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : 'opt_bar) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'row_field_list) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'name_tag_list) in
    Obj.repr(
# 2057 "parsing/parser.mly"
      ( mktyp(Ptyp_variant(List.rev _3, Closed, Some (List.rev _5))) )
# 10670 "parsing/parser.ml"
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'package_type) in
    Obj.repr(
# 2059 "parsing/parser.mly"
      ( mktyp(Ptyp_package _3) )
# 10677 "parsing/parser.ml"
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'extension) in
    Obj.repr(
# 2061 "parsing/parser.mly"
      ( mktyp (Ptyp_extension _1) )
# 10684 "parsing/parser.ml"
               : 'simple_core_type2))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'mty_longident) in
    Obj.repr(
# 2064 "parsing/parser.mly"
                  ( (mkrhs _1 1, []) )
# 10691 "parsing/parser.ml"
               : 'package_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'mty_longident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'package_type_cstrs) in
    Obj.repr(
# 2065 "parsing/parser.mly"
                                          ( (mkrhs _1 1, _3) )
# 10699 "parsing/parser.ml"
               : 'package_type))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'label_longident) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 2068 "parsing/parser.mly"
                                         ( (mkrhs _2 2, _4) )
# 10707 "parsing/parser.ml"
               : 'package_type_cstr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'package_type_cstr) in
    Obj.repr(
# 2071 "parsing/parser.mly"
                      ( [_1] )
# 10714 "parsing/parser.ml"
               : 'package_type_cstrs))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'package_type_cstr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'package_type_cstrs) in
    Obj.repr(
# 2072 "parsing/parser.mly"
                                             ( _1::_3 )
# 10722 "parsing/parser.ml"
               : 'package_type_cstrs))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'row_field) in
    Obj.repr(
# 2075 "parsing/parser.mly"
                                                ( [_1] )
# 10729 "parsing/parser.ml"
               : 'row_field_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'row_field_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'row_field) in
    Obj.repr(
# 2076 "parsing/parser.mly"
                                                ( _3 :: _1 )
# 10737 "parsing/parser.ml"
               : 'row_field_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'tag_field) in
    Obj.repr(
# 2079 "parsing/parser.mly"
                                                ( _1 )
# 10744 "parsing/parser.ml"
               : 'row_field))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_core_type) in
    Obj.repr(
# 2080 "parsing/parser.mly"
                                                ( Rinherit _1 )
# 10751 "parsing/parser.ml"
               : 'row_field))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'name_tag) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'opt_ampersand) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'amper_type_list) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
# 2084 "parsing/parser.mly"
      ( Rtag (_1, _5, _3, List.rev _4) )
# 10761 "parsing/parser.ml"
               : 'tag_field))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'name_tag) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
# 2086 "parsing/parser.mly"
      ( Rtag (_1, _2, true, []) )
# 10769 "parsing/parser.ml"
               : 'tag_field))
; (fun __caml_parser_env ->
    Obj.repr(
# 2089 "parsing/parser.mly"
                                                ( true )
# 10775 "parsing/parser.ml"
               : 'opt_ampersand))
; (fun __caml_parser_env ->
    Obj.repr(
# 2090 "parsing/parser.mly"
                                                ( false )
# 10781 "parsing/parser.ml"
               : 'opt_ampersand))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'core_type_no_attr) in
    Obj.repr(
# 2093 "parsing/parser.mly"
                                                ( [_1] )
# 10788 "parsing/parser.ml"
               : 'amper_type_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'amper_type_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'core_type_no_attr) in
    Obj.repr(
# 2094 "parsing/parser.mly"
                                                ( _3 :: _1 )
# 10796 "parsing/parser.ml"
               : 'amper_type_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'name_tag) in
    Obj.repr(
# 2097 "parsing/parser.mly"
                                                ( [_1] )
# 10803 "parsing/parser.ml"
               : 'name_tag_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'name_tag_list) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'name_tag) in
    Obj.repr(
# 2098 "parsing/parser.mly"
                                                ( _2 :: _1 )
# 10811 "parsing/parser.ml"
               : 'name_tag_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_core_type) in
    Obj.repr(
# 2101 "parsing/parser.mly"
                                             ( _1 )
# 10818 "parsing/parser.ml"
               : 'simple_core_type_or_tuple))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'simple_core_type) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'core_type_list) in
    Obj.repr(
# 2103 "parsing/parser.mly"
      ( mktyp(Ptyp_tuple(_1 :: List.rev _3)) )
# 10826 "parsing/parser.ml"
               : 'simple_core_type_or_tuple))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_core_type_no_attr) in
    Obj.repr(
# 2107 "parsing/parser.mly"
      ( _1 )
# 10833 "parsing/parser.ml"
               : 'simple_core_type_or_tuple_no_attr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'simple_core_type_no_attr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'core_type_list_no_attr) in
    Obj.repr(
# 2109 "parsing/parser.mly"
      ( mktyp(Ptyp_tuple(_1 :: List.rev _3)) )
# 10841 "parsing/parser.ml"
               : 'simple_core_type_or_tuple_no_attr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 2112 "parsing/parser.mly"
                                                ( [_1] )
# 10848 "parsing/parser.ml"
               : 'core_type_comma_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'core_type_comma_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 2113 "parsing/parser.mly"
                                                ( _3 :: _1 )
# 10856 "parsing/parser.ml"
               : 'core_type_comma_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_core_type) in
    Obj.repr(
# 2116 "parsing/parser.mly"
                                             ( [_1] )
# 10863 "parsing/parser.ml"
               : 'core_type_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'core_type_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'simple_core_type) in
    Obj.repr(
# 2117 "parsing/parser.mly"
                                                ( _3 :: _1 )
# 10871 "parsing/parser.ml"
               : 'core_type_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_core_type_no_attr) in
    Obj.repr(
# 2120 "parsing/parser.mly"
                                                 ( [_1] )
# 10878 "parsing/parser.ml"
               : 'core_type_list_no_attr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'core_type_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'simple_core_type_no_attr) in
    Obj.repr(
# 2121 "parsing/parser.mly"
                                                 ( _3 :: _1 )
# 10886 "parsing/parser.ml"
               : 'core_type_list_no_attr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'field) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'meth_list) in
    Obj.repr(
# 2124 "parsing/parser.mly"
                                             ( let (f, c) = _3 in (_1 :: f, c) )
# 10894 "parsing/parser.ml"
               : 'meth_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'field) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'opt_semi) in
    Obj.repr(
# 2125 "parsing/parser.mly"
                                                ( [_1], Closed )
# 10902 "parsing/parser.ml"
               : 'meth_list))
; (fun __caml_parser_env ->
    Obj.repr(
# 2126 "parsing/parser.mly"
                                                ( [], Open )
# 10908 "parsing/parser.ml"
               : 'meth_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'label) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'poly_type_no_attr) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
# 2129 "parsing/parser.mly"
                                                ( (_1, _4, _3) )
# 10917 "parsing/parser.ml"
               : 'field))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2132 "parsing/parser.mly"
                                                ( _1 )
# 10924 "parsing/parser.ml"
               : 'label))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in
    Obj.repr(
# 2138 "parsing/parser.mly"
                                      ( Const_int _1 )
# 10931 "parsing/parser.ml"
               : 'constant))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : char) in
    Obj.repr(
# 2139 "parsing/parser.mly"
                                      ( Const_char _1 )
# 10938 "parsing/parser.ml"
               : 'constant))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string * string option) in
    Obj.repr(
# 2140 "parsing/parser.mly"
                                      ( let (s, d) = _1 in Const_string (s, d) )
# 10945 "parsing/parser.ml"
               : 'constant))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2141 "parsing/parser.mly"
                                      ( Const_float _1 )
# 10952 "parsing/parser.ml"
               : 'constant))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : int32) in
    Obj.repr(
# 2142 "parsing/parser.mly"
                                      ( Const_int32 _1 )
# 10959 "parsing/parser.ml"
               : 'constant))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : int64) in
    Obj.repr(
# 2143 "parsing/parser.mly"
                                      ( Const_int64 _1 )
# 10966 "parsing/parser.ml"
               : 'constant))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : nativeint) in
    Obj.repr(
# 2144 "parsing/parser.mly"
                                      ( Const_nativeint _1 )
# 10973 "parsing/parser.ml"
               : 'constant))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'constant) in
    Obj.repr(
# 2147 "parsing/parser.mly"
                                           ( _1 )
# 10980 "parsing/parser.ml"
               : 'signed_constant))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : int) in
    Obj.repr(
# 2148 "parsing/parser.mly"
                                           ( Const_int(- _2) )
# 10987 "parsing/parser.ml"
               : 'signed_constant))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2149 "parsing/parser.mly"
                                           ( Const_float("-" ^ _2) )
# 10994 "parsing/parser.ml"
               : 'signed_constant))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : int32) in
    Obj.repr(
# 2150 "parsing/parser.mly"
                                           ( Const_int32(Int32.neg _2) )
# 11001 "parsing/parser.ml"
               : 'signed_constant))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : int64) in
    Obj.repr(
# 2151 "parsing/parser.mly"
                                           ( Const_int64(Int64.neg _2) )
# 11008 "parsing/parser.ml"
               : 'signed_constant))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : nativeint) in
    Obj.repr(
# 2152 "parsing/parser.mly"
                                           ( Const_nativeint(Nativeint.neg _2) )
# 11015 "parsing/parser.ml"
               : 'signed_constant))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : int) in
    Obj.repr(
# 2153 "parsing/parser.mly"
                                           ( Const_int _2 )
# 11022 "parsing/parser.ml"
               : 'signed_constant))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2154 "parsing/parser.mly"
                                           ( Const_float _2 )
# 11029 "parsing/parser.ml"
               : 'signed_constant))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : int32) in
    Obj.repr(
# 2155 "parsing/parser.mly"
                                           ( Const_int32 _2 )
# 11036 "parsing/parser.ml"
               : 'signed_constant))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : int64) in
    Obj.repr(
# 2156 "parsing/parser.mly"
                                           ( Const_int64 _2 )
# 11043 "parsing/parser.ml"
               : 'signed_constant))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : nativeint) in
    Obj.repr(
# 2157 "parsing/parser.mly"
                                           ( Const_nativeint _2 )
# 11050 "parsing/parser.ml"
               : 'signed_constant))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2163 "parsing/parser.mly"
                                                ( _1 )
# 11057 "parsing/parser.ml"
               : 'ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2164 "parsing/parser.mly"
                                                ( _1 )
# 11064 "parsing/parser.ml"
               : 'ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2167 "parsing/parser.mly"
                                                ( _1 )
# 11071 "parsing/parser.ml"
               : 'val_ident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'operator) in
    Obj.repr(
# 2168 "parsing/parser.mly"
                                                ( _2 )
# 11078 "parsing/parser.ml"
               : 'val_ident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'operator) in
    Obj.repr(
# 2169 "parsing/parser.mly"
                                                ( unclosed "(" 1 ")" 3 )
# 11085 "parsing/parser.ml"
               : 'val_ident))
; (fun __caml_parser_env ->
    Obj.repr(
# 2170 "parsing/parser.mly"
                                                ( expecting 2 "operator" )
# 11091 "parsing/parser.ml"
               : 'val_ident))
; (fun __caml_parser_env ->
    Obj.repr(
# 2171 "parsing/parser.mly"
                                                ( expecting 3 "module-expr" )
# 11097 "parsing/parser.ml"
               : 'val_ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2174 "parsing/parser.mly"
                                                ( _1 )
# 11104 "parsing/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2175 "parsing/parser.mly"
                                                ( _1 )
# 11111 "parsing/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2176 "parsing/parser.mly"
                                                ( _1 )
# 11118 "parsing/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2177 "parsing/parser.mly"
                                                ( _1 )
# 11125 "parsing/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2178 "parsing/parser.mly"
                                                ( _1 )
# 11132 "parsing/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2179 "parsing/parser.mly"
                                                ( _1 )
# 11139 "parsing/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2180 "parsing/parser.mly"
                                                ( _1 )
# 11146 "parsing/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
# 2181 "parsing/parser.mly"
                                                ( "!" )
# 11152 "parsing/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
# 2182 "parsing/parser.mly"
                                                ( "+" )
# 11158 "parsing/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
# 2183 "parsing/parser.mly"
                                                ( "+." )
# 11164 "parsing/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
# 2184 "parsing/parser.mly"
                                                ( "-" )
# 11170 "parsing/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
# 2185 "parsing/parser.mly"
                                                ( "-." )
# 11176 "parsing/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
# 2186 "parsing/parser.mly"
                                                ( "*" )
# 11182 "parsing/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
# 2187 "parsing/parser.mly"
                                                ( "=" )
# 11188 "parsing/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
# 2188 "parsing/parser.mly"
                                                ( "<" )
# 11194 "parsing/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
# 2189 "parsing/parser.mly"
                                                ( ">" )
# 11200 "parsing/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
# 2190 "parsing/parser.mly"
                                                ( "or" )
# 11206 "parsing/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
# 2191 "parsing/parser.mly"
                                                ( "||" )
# 11212 "parsing/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
# 2192 "parsing/parser.mly"
                                                ( "&" )
# 11218 "parsing/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
# 2193 "parsing/parser.mly"
                                                ( "&&" )
# 11224 "parsing/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
# 2194 "parsing/parser.mly"
                                                ( ":=" )
# 11230 "parsing/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
# 2195 "parsing/parser.mly"
                                                ( "+=" )
# 11236 "parsing/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    Obj.repr(
# 2196 "parsing/parser.mly"
                                                ( "%" )
# 11242 "parsing/parser.ml"
               : 'operator))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2199 "parsing/parser.mly"
                                                ( _1 )
# 11249 "parsing/parser.ml"
               : 'constr_ident))
; (fun __caml_parser_env ->
    Obj.repr(
# 2201 "parsing/parser.mly"
                                                ( "()" )
# 11255 "parsing/parser.ml"
               : 'constr_ident))
; (fun __caml_parser_env ->
    Obj.repr(
# 2202 "parsing/parser.mly"
                                                ( "::" )
# 11261 "parsing/parser.ml"
               : 'constr_ident))
; (fun __caml_parser_env ->
    Obj.repr(
# 2204 "parsing/parser.mly"
                                                ( "false" )
# 11267 "parsing/parser.ml"
               : 'constr_ident))
; (fun __caml_parser_env ->
    Obj.repr(
# 2205 "parsing/parser.mly"
                                                ( "true" )
# 11273 "parsing/parser.ml"
               : 'constr_ident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'val_ident) in
    Obj.repr(
# 2209 "parsing/parser.mly"
                                                ( Lident _1 )
# 11280 "parsing/parser.ml"
               : 'val_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'mod_longident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'val_ident) in
    Obj.repr(
# 2210 "parsing/parser.mly"
                                                ( Ldot(_1, _3) )
# 11288 "parsing/parser.ml"
               : 'val_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'mod_longident) in
    Obj.repr(
# 2213 "parsing/parser.mly"
                                                ( _1 )
# 11295 "parsing/parser.ml"
               : 'constr_longident))
; (fun __caml_parser_env ->
    Obj.repr(
# 2214 "parsing/parser.mly"
                                                ( Lident "[]" )
# 11301 "parsing/parser.ml"
               : 'constr_longident))
; (fun __caml_parser_env ->
    Obj.repr(
# 2215 "parsing/parser.mly"
                                                ( Lident "()" )
# 11307 "parsing/parser.ml"
               : 'constr_longident))
; (fun __caml_parser_env ->
    Obj.repr(
# 2216 "parsing/parser.mly"
                                                ( Lident "false" )
# 11313 "parsing/parser.ml"
               : 'constr_longident))
; (fun __caml_parser_env ->
    Obj.repr(
# 2217 "parsing/parser.mly"
                                                ( Lident "true" )
# 11319 "parsing/parser.ml"
               : 'constr_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2220 "parsing/parser.mly"
                                                ( Lident _1 )
# 11326 "parsing/parser.ml"
               : 'label_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'mod_longident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2221 "parsing/parser.mly"
                                                ( Ldot(_1, _3) )
# 11334 "parsing/parser.ml"
               : 'label_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2224 "parsing/parser.mly"
                                                ( Lident _1 )
# 11341 "parsing/parser.ml"
               : 'type_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'mod_ext_longident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2225 "parsing/parser.mly"
                                                ( Ldot(_1, _3) )
# 11349 "parsing/parser.ml"
               : 'type_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2228 "parsing/parser.mly"
                                                ( Lident _1 )
# 11356 "parsing/parser.ml"
               : 'mod_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'mod_longident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2229 "parsing/parser.mly"
                                                ( Ldot(_1, _3) )
# 11364 "parsing/parser.ml"
               : 'mod_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2232 "parsing/parser.mly"
                                                ( Lident _1 )
# 11371 "parsing/parser.ml"
               : 'mod_ext_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'mod_ext_longident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2233 "parsing/parser.mly"
                                                ( Ldot(_1, _3) )
# 11379 "parsing/parser.ml"
               : 'mod_ext_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'mod_ext_longident) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'mod_ext_longident) in
    Obj.repr(
# 2234 "parsing/parser.mly"
                                                      ( lapply _1 _3 )
# 11387 "parsing/parser.ml"
               : 'mod_ext_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'ident) in
    Obj.repr(
# 2237 "parsing/parser.mly"
                                                ( Lident _1 )
# 11394 "parsing/parser.ml"
               : 'mty_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'mod_ext_longident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'ident) in
    Obj.repr(
# 2238 "parsing/parser.mly"
                                                ( Ldot(_1, _3) )
# 11402 "parsing/parser.ml"
               : 'mty_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2241 "parsing/parser.mly"
                                                ( Lident _1 )
# 11409 "parsing/parser.ml"
               : 'clty_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'mod_ext_longident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2242 "parsing/parser.mly"
                                                ( Ldot(_1, _3) )
# 11417 "parsing/parser.ml"
               : 'clty_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2245 "parsing/parser.mly"
                                                ( Lident _1 )
# 11424 "parsing/parser.ml"
               : 'class_longident))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'mod_longident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2246 "parsing/parser.mly"
                                                ( Ldot(_1, _3) )
# 11432 "parsing/parser.ml"
               : 'class_longident))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'ident) in
    Obj.repr(
# 2252 "parsing/parser.mly"
                                ( Ptop_dir(_2, Pdir_none) )
# 11439 "parsing/parser.ml"
               : 'toplevel_directive))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'ident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : string * string option) in
    Obj.repr(
# 2253 "parsing/parser.mly"
                                ( Ptop_dir(_2, Pdir_string (fst _3)) )
# 11447 "parsing/parser.ml"
               : 'toplevel_directive))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'ident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : int) in
    Obj.repr(
# 2254 "parsing/parser.mly"
                                ( Ptop_dir(_2, Pdir_int _3) )
# 11455 "parsing/parser.ml"
               : 'toplevel_directive))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'ident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'val_longident) in
    Obj.repr(
# 2255 "parsing/parser.mly"
                                ( Ptop_dir(_2, Pdir_ident _3) )
# 11463 "parsing/parser.ml"
               : 'toplevel_directive))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'ident) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'mod_longident) in
    Obj.repr(
# 2256 "parsing/parser.mly"
                                ( Ptop_dir(_2, Pdir_ident _3) )
# 11471 "parsing/parser.ml"
               : 'toplevel_directive))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'ident) in
    Obj.repr(
# 2257 "parsing/parser.mly"
                                ( Ptop_dir(_2, Pdir_bool false) )
# 11478 "parsing/parser.ml"
               : 'toplevel_directive))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'ident) in
    Obj.repr(
# 2258 "parsing/parser.mly"
                                ( Ptop_dir(_2, Pdir_bool true) )
# 11485 "parsing/parser.ml"
               : 'toplevel_directive))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'ident) in
    Obj.repr(
# 2264 "parsing/parser.mly"
                                                ( _2 )
# 11492 "parsing/parser.ml"
               : 'name_tag))
; (fun __caml_parser_env ->
    Obj.repr(
# 2267 "parsing/parser.mly"
                                                ( Nonrecursive )
# 11498 "parsing/parser.ml"
               : 'rec_flag))
; (fun __caml_parser_env ->
    Obj.repr(
# 2268 "parsing/parser.mly"
                                                ( Recursive )
# 11504 "parsing/parser.ml"
               : 'rec_flag))
; (fun __caml_parser_env ->
    Obj.repr(
# 2271 "parsing/parser.mly"
                                                ( Recursive )
# 11510 "parsing/parser.ml"
               : 'nonrec_flag))
; (fun __caml_parser_env ->
    Obj.repr(
# 2272 "parsing/parser.mly"
                                                ( Nonrecursive )
# 11516 "parsing/parser.ml"
               : 'nonrec_flag))
; (fun __caml_parser_env ->
    Obj.repr(
# 2275 "parsing/parser.mly"
                                                ( Upto )
# 11522 "parsing/parser.ml"
               : 'direction_flag))
; (fun __caml_parser_env ->
    Obj.repr(
# 2276 "parsing/parser.mly"
                                                ( Downto )
# 11528 "parsing/parser.ml"
               : 'direction_flag))
; (fun __caml_parser_env ->
    Obj.repr(
# 2279 "parsing/parser.mly"
                                                ( Public )
# 11534 "parsing/parser.ml"
               : 'private_flag))
; (fun __caml_parser_env ->
    Obj.repr(
# 2280 "parsing/parser.mly"
                                                ( Private )
# 11540 "parsing/parser.ml"
               : 'private_flag))
; (fun __caml_parser_env ->
    Obj.repr(
# 2283 "parsing/parser.mly"
                                                ( Immutable )
# 11546 "parsing/parser.ml"
               : 'mutable_flag))
; (fun __caml_parser_env ->
    Obj.repr(
# 2284 "parsing/parser.mly"
                                                ( Mutable )
# 11552 "parsing/parser.ml"
               : 'mutable_flag))
; (fun __caml_parser_env ->
    Obj.repr(
# 2287 "parsing/parser.mly"
                                                ( Concrete )
# 11558 "parsing/parser.ml"
               : 'virtual_flag))
; (fun __caml_parser_env ->
    Obj.repr(
# 2288 "parsing/parser.mly"
                                                ( Virtual )
# 11564 "parsing/parser.ml"
               : 'virtual_flag))
; (fun __caml_parser_env ->
    Obj.repr(
# 2291 "parsing/parser.mly"
                 ( Public, Concrete )
# 11570 "parsing/parser.ml"
               : 'private_virtual_flags))
; (fun __caml_parser_env ->
    Obj.repr(
# 2292 "parsing/parser.mly"
            ( Private, Concrete )
# 11576 "parsing/parser.ml"
               : 'private_virtual_flags))
; (fun __caml_parser_env ->
    Obj.repr(
# 2293 "parsing/parser.mly"
            ( Public, Virtual )
# 11582 "parsing/parser.ml"
               : 'private_virtual_flags))
; (fun __caml_parser_env ->
    Obj.repr(
# 2294 "parsing/parser.mly"
                    ( Private, Virtual )
# 11588 "parsing/parser.ml"
               : 'private_virtual_flags))
; (fun __caml_parser_env ->
    Obj.repr(
# 2295 "parsing/parser.mly"
                    ( Private, Virtual )
# 11594 "parsing/parser.ml"
               : 'private_virtual_flags))
; (fun __caml_parser_env ->
    Obj.repr(
# 2298 "parsing/parser.mly"
                                                ( Fresh )
# 11600 "parsing/parser.ml"
               : 'override_flag))
; (fun __caml_parser_env ->
    Obj.repr(
# 2299 "parsing/parser.mly"
                                                ( Override )
# 11606 "parsing/parser.ml"
               : 'override_flag))
; (fun __caml_parser_env ->
    Obj.repr(
# 2302 "parsing/parser.mly"
                                                ( () )
# 11612 "parsing/parser.ml"
               : 'opt_bar))
; (fun __caml_parser_env ->
    Obj.repr(
# 2303 "parsing/parser.mly"
                                                ( () )
# 11618 "parsing/parser.ml"
               : 'opt_bar))
; (fun __caml_parser_env ->
    Obj.repr(
# 2306 "parsing/parser.mly"
                                                ( () )
# 11624 "parsing/parser.ml"
               : 'opt_semi))
; (fun __caml_parser_env ->
    Obj.repr(
# 2307 "parsing/parser.mly"
                                                ( () )
# 11630 "parsing/parser.ml"
               : 'opt_semi))
; (fun __caml_parser_env ->
    Obj.repr(
# 2310 "parsing/parser.mly"
                                                ( "-" )
# 11636 "parsing/parser.ml"
               : 'subtractive))
; (fun __caml_parser_env ->
    Obj.repr(
# 2311 "parsing/parser.mly"
                                                ( "-." )
# 11642 "parsing/parser.ml"
               : 'subtractive))
; (fun __caml_parser_env ->
    Obj.repr(
# 2314 "parsing/parser.mly"
                                                ( "+" )
# 11648 "parsing/parser.ml"
               : 'additive))
; (fun __caml_parser_env ->
    Obj.repr(
# 2315 "parsing/parser.mly"
                                                ( "+." )
# 11654 "parsing/parser.ml"
               : 'additive))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2321 "parsing/parser.mly"
           ( _1 )
# 11661 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 2322 "parsing/parser.mly"
           ( _1 )
# 11668 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2323 "parsing/parser.mly"
        ( "and" )
# 11674 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2324 "parsing/parser.mly"
       ( "as" )
# 11680 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2325 "parsing/parser.mly"
           ( "assert" )
# 11686 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2326 "parsing/parser.mly"
          ( "begin" )
# 11692 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2327 "parsing/parser.mly"
          ( "class" )
# 11698 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2328 "parsing/parser.mly"
               ( "constraint" )
# 11704 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2329 "parsing/parser.mly"
       ( "do" )
# 11710 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2330 "parsing/parser.mly"
         ( "done" )
# 11716 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2331 "parsing/parser.mly"
           ( "downto" )
# 11722 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2332 "parsing/parser.mly"
         ( "else" )
# 11728 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2333 "parsing/parser.mly"
        ( "end" )
# 11734 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2334 "parsing/parser.mly"
              ( "exception" )
# 11740 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2335 "parsing/parser.mly"
             ( "external" )
# 11746 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2336 "parsing/parser.mly"
          ( "false" )
# 11752 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2337 "parsing/parser.mly"
        ( "for" )
# 11758 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2338 "parsing/parser.mly"
        ( "fun" )
# 11764 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2339 "parsing/parser.mly"
             ( "function" )
# 11770 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2340 "parsing/parser.mly"
            ( "functor" )
# 11776 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2341 "parsing/parser.mly"
       ( "if" )
# 11782 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2342 "parsing/parser.mly"
       ( "in" )
# 11788 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2343 "parsing/parser.mly"
            ( "include" )
# 11794 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2344 "parsing/parser.mly"
            ( "inherit" )
# 11800 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2345 "parsing/parser.mly"
                ( "initializer" )
# 11806 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2346 "parsing/parser.mly"
         ( "lazy" )
# 11812 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2347 "parsing/parser.mly"
        ( "let" )
# 11818 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2348 "parsing/parser.mly"
          ( "match" )
# 11824 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2349 "parsing/parser.mly"
           ( "method" )
# 11830 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2350 "parsing/parser.mly"
           ( "module" )
# 11836 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2351 "parsing/parser.mly"
            ( "mutable" )
# 11842 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2352 "parsing/parser.mly"
        ( "new" )
# 11848 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2353 "parsing/parser.mly"
           ( "object" )
# 11854 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2354 "parsing/parser.mly"
       ( "of" )
# 11860 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2355 "parsing/parser.mly"
         ( "open" )
# 11866 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2356 "parsing/parser.mly"
       ( "or" )
# 11872 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2357 "parsing/parser.mly"
            ( "private" )
# 11878 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2358 "parsing/parser.mly"
        ( "rec" )
# 11884 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2359 "parsing/parser.mly"
        ( "sig" )
# 11890 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2360 "parsing/parser.mly"
           ( "struct" )
# 11896 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2361 "parsing/parser.mly"
         ( "then" )
# 11902 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2362 "parsing/parser.mly"
       ( "to" )
# 11908 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2363 "parsing/parser.mly"
         ( "true" )
# 11914 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2364 "parsing/parser.mly"
        ( "try" )
# 11920 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2365 "parsing/parser.mly"
         ( "type" )
# 11926 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2366 "parsing/parser.mly"
        ( "val" )
# 11932 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2367 "parsing/parser.mly"
            ( "virtual" )
# 11938 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2368 "parsing/parser.mly"
         ( "when" )
# 11944 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2369 "parsing/parser.mly"
          ( "while" )
# 11950 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    Obj.repr(
# 2370 "parsing/parser.mly"
         ( "with" )
# 11956 "parsing/parser.ml"
               : 'single_attr_id))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'single_attr_id) in
    Obj.repr(
# 2375 "parsing/parser.mly"
                   ( mkloc _1 (symbol_rloc()) )
# 11963 "parsing/parser.ml"
               : 'attr_id))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'single_attr_id) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'attr_id) in
    Obj.repr(
# 2376 "parsing/parser.mly"
                               ( mkloc (_1 ^ "." ^ _3.txt) (symbol_rloc()))
# 11971 "parsing/parser.ml"
               : 'attr_id))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'attr_id) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'payload) in
    Obj.repr(
# 2379 "parsing/parser.mly"
                                      ( (_2, _3) )
# 11979 "parsing/parser.ml"
               : 'attribute))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'attr_id) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'payload) in
    Obj.repr(
# 2382 "parsing/parser.mly"
                                        ( (_2, _3) )
# 11987 "parsing/parser.ml"
               : 'post_item_attribute))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'attr_id) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'payload) in
    Obj.repr(
# 2385 "parsing/parser.mly"
                                          ( (_2, _3) )
# 11995 "parsing/parser.ml"
               : 'floating_attribute))
; (fun __caml_parser_env ->
    Obj.repr(
# 2388 "parsing/parser.mly"
                 ( [] )
# 12001 "parsing/parser.ml"
               : 'post_item_attributes))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'post_item_attribute) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'post_item_attributes) in
    Obj.repr(
# 2389 "parsing/parser.mly"
                                             ( _1 :: _2 )
# 12009 "parsing/parser.ml"
               : 'post_item_attributes))
; (fun __caml_parser_env ->
    Obj.repr(
# 2392 "parsing/parser.mly"
               ( [] )
# 12015 "parsing/parser.ml"
               : 'attributes))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'attribute) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
# 2393 "parsing/parser.mly"
                         ( _1 :: _2 )
# 12023 "parsing/parser.ml"
               : 'attributes))
; (fun __caml_parser_env ->
    Obj.repr(
# 2396 "parsing/parser.mly"
                 ( None, [] )
# 12029 "parsing/parser.ml"
               : 'ext_attributes))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'attribute) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
# 2397 "parsing/parser.mly"
                         ( None, _1 :: _2 )
# 12037 "parsing/parser.ml"
               : 'ext_attributes))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'attr_id) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
# 2398 "parsing/parser.mly"
                               ( Some _2, _3 )
# 12045 "parsing/parser.ml"
               : 'ext_attributes))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'attr_id) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'payload) in
    Obj.repr(
# 2401 "parsing/parser.mly"
                                           ( (_2, _3) )
# 12053 "parsing/parser.ml"
               : 'extension))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'attr_id) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'payload) in
    Obj.repr(
# 2404 "parsing/parser.mly"
                                                  ( (_2, _3) )
# 12061 "parsing/parser.ml"
               : 'item_extension))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'structure) in
    Obj.repr(
# 2407 "parsing/parser.mly"
              ( PStr _1 )
# 12068 "parsing/parser.ml"
               : 'payload))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'core_type) in
    Obj.repr(
# 2408 "parsing/parser.mly"
                    ( PTyp _2 )
# 12075 "parsing/parser.ml"
               : 'payload))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'pattern) in
    Obj.repr(
# 2409 "parsing/parser.mly"
                     ( PPat (_2, None) )
# 12082 "parsing/parser.ml"
               : 'payload))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'pattern) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'seq_expr) in
    Obj.repr(
# 2410 "parsing/parser.mly"
                                   ( PPat (_2, Some _4) )
# 12090 "parsing/parser.ml"
               : 'payload))
(* Entry implementation *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
(* Entry interface *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
(* Entry toplevel_phrase *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
(* Entry use_file *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
(* Entry parse_core_type *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
(* Entry parse_expression *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
(* Entry parse_pattern *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
|]
let yytables =
  { Parsing.actions=yyact;
    Parsing.transl_const=yytransl_const;
    Parsing.transl_block=yytransl_block;
    Parsing.lhs=yylhs;
    Parsing.len=yylen;
    Parsing.defred=yydefred;
    Parsing.dgoto=yydgoto;
    Parsing.sindex=yysindex;
    Parsing.rindex=yyrindex;
    Parsing.gindex=yygindex;
    Parsing.tablesize=yytablesize;
    Parsing.table=yytable;
    Parsing.check=yycheck;
    Parsing.error_function=parse_error;
    Parsing.names_const=yynames_const;
    Parsing.names_block=yynames_block }
let implementation (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 1 lexfun lexbuf : Parsetree.structure)
let interface (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 2 lexfun lexbuf : Parsetree.signature)
let toplevel_phrase (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 3 lexfun lexbuf : Parsetree.toplevel_phrase)
let use_file (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 4 lexfun lexbuf : Parsetree.toplevel_phrase list)
let parse_core_type (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 5 lexfun lexbuf : Parsetree.core_type)
let parse_expression (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 6 lexfun lexbuf : Parsetree.expression)
let parse_pattern (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 7 lexfun lexbuf : Parsetree.pattern)
;;

end
module Lexer : sig 
#1 "lexer.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* The lexical analyzer *)

val init : unit -> unit
val token: Lexing.lexbuf -> Parser.token
val skip_sharp_bang: Lexing.lexbuf -> unit

type directive_type 

(* type directive_value = *)
(*   | Dir_bool of bool  *)
(*   | Dir_float of float *)
(*   | Dir_int of int *)
(*   | Dir_string of string *)
(*   | Dir_null *)

type error =
  | Illegal_character of char
  | Illegal_escape of string
  | Unterminated_comment of Location.t
  | Unterminated_string
  | Unterminated_string_in_comment of Location.t * Location.t
  | Keyword_as_label of string
  | Literal_overflow of string
  | Unterminated_paren_in_conditional
  | Unterminated_if
  | Unterminated_else 
  | Unexpected_token_in_conditional 
  | Expect_hash_then_in_conditional
  | Illegal_semver of string
  | Unexpected_directive
  | Conditional_expr_expected_type of directive_type * directive_type
;;

exception Error of error * Location.t

open Format

val report_error: formatter -> error -> unit
 (* Deprecated.  Use Location.{error_of_exn, report_error}. *)

val in_comment : unit -> bool;;
val in_string : unit -> bool;;


val print_warnings : bool ref
val comments : unit -> (string * Location.t) list
val token_with_comments : Lexing.lexbuf -> Parser.token

(*
  [set_preprocessor init preprocessor] registers [init] as the function
to call to initialize the preprocessor when the lexer is initialized,
and [preprocessor] a function that is called when a new token is needed
by the parser, as [preprocessor lexer lexbuf] where [lexer] is the
lexing function.

When a preprocessor is configured by calling [set_preprocessor], the lexer
changes its behavior to accept backslash-newline as a token-separating blank.
*)

val set_preprocessor :
  (unit -> unit) ->
  ((Lexing.lexbuf -> Parser.token) -> Lexing.lexbuf -> Parser.token) ->
  unit


(* val replace_directive_built_in_value :  *)
(*   string ->  directive_value -> unit *)

(** Raises Not_found *)
(* val find_directive_built_in_value : *)
(*   string -> directive_value *)

(* val iter_directive_built_in_value :  *)
(*   (string -> directive_value -> unit) -> unit *)


(** semantic version predicate *)
val semver : Location.t ->   string -> string -> bool

val filter_directive_from_lexbuf : Lexing.lexbuf -> (int * int) list

val replace_directive_int : string -> int -> unit
val replace_directive_string : string -> string -> unit
val replace_directive_bool : string -> bool -> unit 
val remove_directive_built_in_value : string -> unit

(** @return false means failed to define *)
val define_key_value : string -> string -> bool
val list_variables : Format.formatter -> unit

end = struct
#1 "lexer.ml"
# 15 "parsing/lexer.mll"
 
open Lexing
open Misc
open Parser

type directive_value =
  | Dir_bool of bool 
  | Dir_float of float
  | Dir_int of int
  | Dir_string of string
  | Dir_null 

type directive_type = 
  | Dir_type_bool 
  | Dir_type_float 
  | Dir_type_int 
  | Dir_type_string 
  | Dir_type_null 

let type_of_directive x =
  match x with 
  | Dir_bool _ -> Dir_type_bool
  | Dir_float _ -> Dir_type_float
  | Dir_int _ -> Dir_type_int
  | Dir_string _ -> Dir_type_string
  | Dir_null -> Dir_type_null

let string_of_type_directive x = 
  match x with 
  | Dir_type_bool  -> "bool"
  | Dir_type_float  -> "float"
  | Dir_type_int  -> "int"
  | Dir_type_string  -> "string"
  | Dir_type_null -> "null"

type error =
  | Illegal_character of char
  | Illegal_escape of string
  | Unterminated_comment of Location.t
  | Unterminated_string
  | Unterminated_string_in_comment of Location.t * Location.t
  | Keyword_as_label of string
  | Literal_overflow of string
  | Unterminated_paren_in_conditional
  | Unterminated_if
  | Unterminated_else 
  | Unexpected_token_in_conditional 
  | Expect_hash_then_in_conditional
  | Illegal_semver of string
  | Unexpected_directive 
  | Conditional_expr_expected_type of directive_type * directive_type

;;

exception Error of error * Location.t;;

let assert_same_type  lexbuf x y = 
  let lhs = type_of_directive x in let rhs =  type_of_directive y  in
  if lhs <> rhs then 
    raise (Error(Conditional_expr_expected_type(lhs,rhs), Location.curr lexbuf))
  else y

let directive_built_in_values  =
  Hashtbl.create 51


let replace_directive_built_in_value k v = 
  Hashtbl.replace directive_built_in_values k v 

let remove_directive_built_in_value k  = 
  Hashtbl.replace directive_built_in_values k Dir_null

let replace_directive_int k v = 
  Hashtbl.replace directive_built_in_values k (Dir_int v)

let replace_directive_bool k v = 
  Hashtbl.replace directive_built_in_values k (Dir_bool v)

let replace_directive_string k v = 
  Hashtbl.replace directive_built_in_values k (Dir_string v)

let () =
  (* Note we use {!Config} instead of {!Sys} becasue 
     we want to overwrite in some cases with the 
     same stdlib
  *)
  let version = 
 
    Config.version (* so that it can be overridden*)

  in
  replace_directive_built_in_value "OCAML_VERSION" 
    (Dir_string version);
  replace_directive_built_in_value "OCAML_PATCH"
    (Dir_string 
       (match String.rindex version '+' with 
       | exception Not_found -> ""
       | i -> 
           String.sub version (i + 1)
             (String.length version - i - 1)))
  ;
  replace_directive_built_in_value "OS_TYPE" 
    (Dir_string Sys.os_type);
  replace_directive_built_in_value "BIG_ENDIAN" 
    (Dir_bool Sys.big_endian);
  replace_directive_built_in_value "WORD_SIZE" 
    (Dir_int Sys.word_size)

let find_directive_built_in_value k =
  Hashtbl.find directive_built_in_values k 

let iter_directive_built_in_value f = Hashtbl.iter f directive_built_in_values

(*
   {[
     # semver 0 "12";;
     - : int * int * int * string = (12, 0, 0, "");;
     # semver 0 "12.3";;
     - : int * int * int * string = (12, 3, 0, "");;
       semver 0 "12.3.10";;
     - : int * int * int * string = (12, 3, 10, "");;
     # semver 0 "12.3.10+x";;
     - : int * int * int * string = (12, 3, 10, "+x")
   ]}
*)    
let zero = Char.code '0' 
let dot = Char.code '.'
let semantic_version_parse str start  last_index = 
  let rec aux start  acc last_index =
    if start <= last_index then
      let c = Char.code (String.unsafe_get str start) in
      if c = dot then (acc, start + 1) (* consume [4.] instead of [4]*)
      else 
        let v =  c - zero in
        if v >=0 && v <= 9  then
          aux (start + 1) (acc * 10 + v) last_index
        else (acc , start)
    else (acc, start)
  in
  let major, major_end =  aux start 0 last_index  in
  let minor, minor_end = aux major_end 0 last_index in
  let patch, patch_end = aux minor_end 0 last_index in 
  let additional = String.sub str patch_end (last_index - patch_end  +1) in
  (major, minor, patch), additional

(** 
   {[
     semver Location.none "1.2.3" "~1.3.0" = false;;
     semver Location.none "1.2.3" "^1.3.0" = true ;;
     semver Location.none "1.2.3" ">1.3.0" = false ;;
     semver Location.none "1.2.3" ">=1.3.0" = false ;;
     semver Location.none "1.2.3" "<1.3.0" = true ;;
     semver Location.none "1.2.3" "<=1.3.0" = true ;;
   ]}
*)
let semver loc lhs str =
  let last_index = String.length str - 1 in 
  if last_index < 0 then raise (Error(Illegal_semver str, loc))
  else 
    let pred, ((major, minor,patch) as version, _) = 
      let v = String.unsafe_get str 0 in 
      match v with
      | '>' -> 
          if last_index = 0 then raise (Error(Illegal_semver str, loc)) else 
          if String.unsafe_get str 1 = '=' then 
            `Ge, semantic_version_parse str 2 last_index
          else `Gt, semantic_version_parse str 1 last_index
      | '<' 
        ->
          if last_index = 0 then raise (Error(Illegal_semver str, loc)) else 
          if String.unsafe_get str 1 = '=' then 
            `Le, semantic_version_parse str 2 last_index
          else `Lt, semantic_version_parse str 1 last_index
      | '^' 
        -> `Compatible, semantic_version_parse str 1 last_index
      | '~' ->  `Approximate, semantic_version_parse str 1 last_index
      | _ -> `Exact, semantic_version_parse str 0 last_index 
    in 
    let ((l_major, l_minor, l_patch) as lversion,_) =
      semantic_version_parse lhs 0 (String.length lhs - 1) in 
    match pred with 
    | `Ge -> lversion >= version 
    | `Gt -> lversion > version 
    | `Le -> lversion <= version
    | `Lt -> lversion < version 
    | `Approximate -> major = l_major && minor = l_minor 
    |  `Compatible -> major = l_major
    | `Exact -> lversion = version 


let pp_directive_value fmt (x : directive_value) =
  match x with
  | Dir_bool b -> Format.pp_print_bool fmt b
  | Dir_int b -> Format.pp_print_int fmt b
  | Dir_float b -> Format.pp_print_float fmt b
  | Dir_string s  -> Format.fprintf fmt "%S" s
  | Dir_null -> Format.pp_print_string fmt "null"    

let list_variables fmt = 
  iter_directive_built_in_value 
    (fun s  dir_value ->
       Format.fprintf
         fmt "@[%s@ %a@]@."
         s pp_directive_value dir_value
    )

let defined str =
  begin match  find_directive_built_in_value str with 
  |  Dir_null -> false 
  | _ ->  true
  | exception _ -> 
      try ignore @@ Sys.getenv str; true with _ ->  false 
  end

let query loc str =
  begin match find_directive_built_in_value str with
  | Dir_null -> Dir_bool false
  | v -> v
  | exception Not_found ->
      begin match Sys.getenv str with 
      | v -> 
          begin 
            try Dir_bool (bool_of_string v) with 
              _ -> 
                begin 
                  try Dir_int (int_of_string v )
                  with 
                    _ -> 
                      begin try (Dir_float (float_of_string v)) 
                      with _ -> Dir_string v
                      end
                end
          end
      | exception Not_found -> 
          Dir_bool false
      end
  end


let define_key_value key v  =
  if String.length key > 0
      && Char.uppercase (key.[0]) = key.[0] then 
    begin 
      replace_directive_built_in_value key
      begin
        (* NEED Sync up across {!lexer.mll} {!bspp.ml} and here,
           TODO: put it in {!lexer.mll}
        *)
        try Dir_bool (bool_of_string v) with 
          _ -> 
          begin 
            try Dir_int (int_of_string v )
            with 
              _ -> 
              begin try (Dir_float (float_of_string v)) 
                with _ -> Dir_string v
              end
          end
      end;
    true
    end
  else false 


let value_of_token loc (t : Parser.token)  = 
  match t with 
  | INT i -> Dir_int i 
  | STRING (s,_) -> Dir_string s 
  | FLOAT s  -> Dir_float (float_of_string s)
  | TRUE -> Dir_bool true
  | FALSE -> Dir_bool false
  | UIDENT s -> query loc s 
  | _ -> raise (Error (Unexpected_token_in_conditional, loc))


let directive_parse token_with_comments lexbuf =
  let look_ahead = ref None in
  let token () : Parser.token =
    let v = !look_ahead in
    match v with 
    | Some v -> 
        look_ahead := None ;
        v
    | None ->
       let rec skip () = 
        match token_with_comments lexbuf  with
        | COMMENT _ -> skip ()

        | DOCSTRING _ -> skip ()

        | EOL -> skip ()
        | EOF -> raise (Error (Unterminated_if, Location.curr lexbuf)) 
        | t -> t 
        in  skip ()
  in
  let push e =
    (* INVARIANT: only look at most one token *)
    assert (!look_ahead = None);
    look_ahead := Some e 
  in
  let rec
    token_op calc   ~no  lhs   =
    match token () with 
    | (LESS 
    | GREATER 
    | INFIXOP0 "<=" 
    | INFIXOP0 ">=" 
    | EQUAL
    | INFIXOP0 "<>" as op) ->
        let f =  
          match op with 
          | LESS -> (<) 
          | GREATER -> (>)
          | INFIXOP0 "<=" -> (<=)
          | EQUAL -> (=)
          | INFIXOP0 "<>" -> (<>) 
          | _ -> assert false
        in 
        let curr_loc = Location.curr lexbuf in 
        let rhs = value_of_token curr_loc (token ()) in 
        not calc ||
        f lhs (assert_same_type lexbuf lhs rhs)
    | INFIXOP0 "=~" -> 
        not calc ||
        begin match lhs with 
        | Dir_string s ->
            let curr_loc = Location.curr lexbuf in 
            let rhs = value_of_token curr_loc (token ()) in 
            begin match rhs with 
            | Dir_string rhs -> 
                semver curr_loc s rhs
            | _ -> 
                raise
                  (Error
                     ( Conditional_expr_expected_type
                         (Dir_type_string, type_of_directive lhs), Location.curr lexbuf))
            end
        | _ -> raise
                 (Error
                    ( Conditional_expr_expected_type
                        (Dir_type_string, type_of_directive lhs), Location.curr lexbuf))
        end
    | e -> no e 
  and
    parse_or calc : bool =
    parse_or_aux calc (parse_and calc)
  and  (* a || (b || (c || d))*)
    parse_or_aux calc v : bool =
    (* let l = v  in *)
    match token () with
    | BARBAR ->
        let b =   parse_or (calc && not v)  in
        v || b 
    | e -> push e ; v
  and parse_and calc = 
    parse_and_aux calc (parse_relation calc)
  and parse_and_aux calc v = (* a && (b && (c && d)) *)
    (* let l = v  in *)
    match token () with
    | AMPERAMPER ->
        let b =  parse_and (calc && v) in
        v && b
    | e -> push e ; v
  and parse_relation (calc : bool) : bool  =
    let curr_token = token () in
    let curr_loc = Location.curr lexbuf in
    match curr_token with
    | TRUE -> true 
    | FALSE -> false
    | UIDENT v ->
        let value_v = query curr_loc v in
        token_op calc 
          ~no:(fun e -> push e ;
                match value_v with 
                | Dir_bool b -> b 
                | _ -> 
                    let ty = type_of_directive value_v in
                    raise
                      (Error(Conditional_expr_expected_type (Dir_type_bool, ty),
                             curr_loc)))
          value_v
    | INT v -> 
        token_op calc
          ~no:(fun e -> 
              raise(Error(Conditional_expr_expected_type(Dir_type_bool,Dir_type_int), 
                          curr_loc)))
          (Dir_int v)
    | FLOAT v -> 
        token_op calc
          ~no:(fun e -> 
              raise (Error(Conditional_expr_expected_type(Dir_type_bool, Dir_type_float),
                           curr_loc)))
          (Dir_float (float_of_string v))
    | STRING (v,_) -> 
        token_op calc
          ~no:(fun e ->
              raise (Error
                       (Conditional_expr_expected_type(Dir_type_bool, Dir_type_string),
                        curr_loc)))
          (Dir_string v)
    | LIDENT ("defined" | "undefined" as r) ->
        let t = token () in 
        let loc = Location.curr lexbuf in
        begin match t with
        | UIDENT s -> 
            not calc || 
            if r.[0] = 'u' then 
              not @@ defined s
            else defined s 
        | _ -> raise (Error (Unexpected_token_in_conditional, loc))
        end
    | LPAREN ->
        let v = parse_or calc in
        begin match token () with
        | RPAREN ->  v
        | _ -> raise (Error(Unterminated_paren_in_conditional, Location.curr lexbuf))
        end 

    | _ -> raise (Error (Unexpected_token_in_conditional, curr_loc))
  in
  let v = parse_or true in
  begin match token () with
  | THEN ->  v 
  | _ -> raise (Error (Expect_hash_then_in_conditional, Location.curr lexbuf))
  end


type dir_conditional =
  | Dir_if_true
  | Dir_if_false
  | Dir_out 

let string_of_dir_conditional (x : dir_conditional) =
  match x with 
  | Dir_if_true -> "Dir_if_true"
  | Dir_if_false -> "Dir_if_false"
  | Dir_out -> "Dir_out"

let is_elif (i : Parser.token ) =
  match i with
  | LIDENT "elif" -> true
  | _ -> false (* avoid polymorphic equal *)


(* The table of keywords *)

let keyword_table =
  create_hashtable 149 [
    "and", AND;
    "as", AS;
    "assert", ASSERT;
    "begin", BEGIN;
    "class", CLASS;
    "constraint", CONSTRAINT;
    "do", DO;
    "done", DONE;
    "downto", DOWNTO;
    "else", ELSE;
    "end", END;
    "exception", EXCEPTION;
    "external", EXTERNAL;
    "false", FALSE;
    "for", FOR;
    "fun", FUN;
    "function", FUNCTION;
    "functor", FUNCTOR;
    "if", IF;
    "in", IN;
    "include", INCLUDE;
    "inherit", INHERIT;
    "initializer", INITIALIZER;
    "lazy", LAZY;
    "let", LET;
    "match", MATCH;
    "method", METHOD;
    "module", MODULE;
    "mutable", MUTABLE;
    "new", NEW;
    "nonrec", NONREC;
    "object", OBJECT;
    "of", OF;
    "open", OPEN;
    "or", OR;
(*  "parser", PARSER; *)
    "private", PRIVATE;
    "rec", REC;
    "sig", SIG;
    "struct", STRUCT;
    "then", THEN;
    "to", TO;
    "true", TRUE;
    "try", TRY;
    "type", TYPE;
    "val", VAL;
    "virtual", VIRTUAL;
    "when", WHEN;
    "while", WHILE;
    "with", WITH;

    "mod", INFIXOP3("mod");
    "land", INFIXOP3("land");
    "lor", INFIXOP3("lor");
    "lxor", INFIXOP3("lxor");
    "lsl", INFIXOP4("lsl");
    "lsr", INFIXOP4("lsr");
    "asr", INFIXOP4("asr")
]

(* To buffer string literals *)

let initial_string_buffer = Bytes.create 256
let string_buff = ref initial_string_buffer
let string_index = ref 0

let reset_string_buffer () =
  string_buff := initial_string_buffer;
  string_index := 0

let store_string_char c =
  if !string_index >= Bytes.length !string_buff then begin
    let new_buff = Bytes.create (Bytes.length (!string_buff) * 2) in
    Bytes.blit !string_buff 0 new_buff 0 (Bytes.length !string_buff);
    string_buff := new_buff
  end;
  Bytes.unsafe_set !string_buff !string_index c;
  incr string_index

let store_string s =
  for i = 0 to String.length s - 1 do
    store_string_char s.[i];
  done

let store_lexeme lexbuf =
  store_string (Lexing.lexeme lexbuf)

let get_stored_string () =
  let s = Bytes.sub_string !string_buff 0 !string_index in
  string_buff := initial_string_buffer;
  s

(* To store the position of the beginning of a string and comment *)
let string_start_loc = ref Location.none;;
let comment_start_loc = ref [];;
let in_comment () = !comment_start_loc <> [];;
let is_in_string = ref false
let in_string () = !is_in_string
let print_warnings = ref true
let if_then_else = ref Dir_out
let sharp_look_ahead = ref None
let update_if_then_else v = 
  (* Format.fprintf Format.err_formatter "@[update %s \n@]@." (string_of_dir_conditional v); *)
  if_then_else := v
    
let with_comment_buffer comment lexbuf =
  let start_loc = Location.curr lexbuf  in
  comment_start_loc := [start_loc];
  reset_string_buffer ();
  let end_loc = comment lexbuf in
  let s = get_stored_string () in
  reset_string_buffer ();
  let loc = { start_loc with Location.loc_end = end_loc.Location.loc_end } in
  s, loc

(* To translate escape sequences *)

let char_for_backslash = function
  | 'n' -> '\010'
  | 'r' -> '\013'
  | 'b' -> '\008'
  | 't' -> '\009'
  | c   -> c

let char_for_decimal_code lexbuf i =
  let c = 100 * (Char.code(Lexing.lexeme_char lexbuf i) - 48) +
           10 * (Char.code(Lexing.lexeme_char lexbuf (i+1)) - 48) +
                (Char.code(Lexing.lexeme_char lexbuf (i+2)) - 48) in
  if (c < 0 || c > 255) then
    if in_comment ()
    then 'x'
    else raise (Error(Illegal_escape (Lexing.lexeme lexbuf),
                      Location.curr lexbuf))
  else Char.chr c

let char_for_hexadecimal_code lexbuf i =
  let d1 = Char.code (Lexing.lexeme_char lexbuf i) in
  let val1 = if d1 >= 97 then d1 - 87
             else if d1 >= 65 then d1 - 55
             else d1 - 48
  in
  let d2 = Char.code (Lexing.lexeme_char lexbuf (i+1)) in
  let val2 = if d2 >= 97 then d2 - 87
             else if d2 >= 65 then d2 - 55
             else d2 - 48
  in
  Char.chr (val1 * 16 + val2)

(* To convert integer literals, allowing max_int + 1 (PR#4210) *)

let cvt_int_literal s =
  - int_of_string ("-" ^ s)
let cvt_int32_literal s =
  Int32.neg (Int32.of_string ("-" ^ String.sub s 0 (String.length s - 1)))
let cvt_int64_literal s =
  Int64.neg (Int64.of_string ("-" ^ String.sub s 0 (String.length s - 1)))
let cvt_nativeint_literal s =
  Nativeint.neg (Nativeint.of_string ("-" ^ String.sub s 0
                                                       (String.length s - 1)))

(* Remove underscores from float literals *)

let remove_underscores s =
  let l = String.length s in
  let b = Bytes.create l in
  let rec remove src dst =
    if src >= l then
      if dst >= l then s else Bytes.sub_string b 0 dst
    else
      match s.[src] with
        '_' -> remove (src + 1) dst
      |  c  -> Bytes.set b dst c; remove (src + 1) (dst + 1)
  in remove 0 0

(* recover the name from a LABEL or OPTLABEL token *)

let get_label_name lexbuf =
  let s = Lexing.lexeme lexbuf in
  let name = String.sub s 1 (String.length s - 2) in
  if Hashtbl.mem keyword_table name then
    raise (Error(Keyword_as_label name, Location.curr lexbuf));
  name
;;

(* Update the current location with file name and line number. *)

let update_loc lexbuf file line absolute chars =
  let pos = lexbuf.lex_curr_p in
  let new_file = match file with
                 | None -> pos.pos_fname
                 | Some s -> s
  in
  lexbuf.lex_curr_p <- { pos with
    pos_fname = new_file;
    pos_lnum = if absolute then line else pos.pos_lnum + line;
    pos_bol = pos.pos_cnum - chars;
  }
;;

let preprocessor = ref None

let escaped_newlines = ref false

(* Warn about Latin-1 characters used in idents *)

let warn_latin1 lexbuf =
  Location.prerr_warning (Location.curr lexbuf)
    (Warnings.Deprecated "ISO-Latin1 characters in identifiers")
;;

let comment_list = ref []

let add_comment com =
  comment_list := com :: !comment_list

let add_docstring_comment ds =

  let com = (Docstrings.docstring_body ds, Docstrings.docstring_loc ds) in
    add_comment com


let comments () = List.rev !comment_list

(* Error report *)

open Format

let report_error ppf = function
  | Illegal_character c ->
      fprintf ppf "Illegal character (%s)" (Char.escaped c)
  | Illegal_escape s ->
      fprintf ppf "Illegal backslash escape in string or character (%s)" s
  | Unterminated_comment _ ->
      fprintf ppf "Comment not terminated"
  | Unterminated_string ->
      fprintf ppf "String literal not terminated"
  | Unterminated_string_in_comment (_, loc) ->
      fprintf ppf "This comment contains an unterminated string literal@.\
                   %aString literal begins here"
              Location.print_error loc
  | Keyword_as_label kwd ->
      fprintf ppf "`%s' is a keyword, it cannot be used as label name" kwd
  | Literal_overflow ty ->
      fprintf ppf "Integer literal exceeds the range of representable \
                   integers of type %s" ty
  | Unterminated_if -> 
      fprintf ppf "#if not terminated"
  | Unterminated_else -> 
      fprintf ppf "#else not terminated"
  | Unexpected_directive -> fprintf ppf "Unexpected directive"
  | Unexpected_token_in_conditional -> 
      fprintf ppf "Unexpected token in conditional predicate"
  | Unterminated_paren_in_conditional ->
    fprintf ppf "Unterminated parens in conditional predicate"
  | Expect_hash_then_in_conditional -> 
      fprintf ppf "Expect `then` after conditioal predicate"
  | Conditional_expr_expected_type (a,b) -> 
      fprintf ppf "Conditional expression type mismatch (%s,%s)" 
        (string_of_type_directive a )
        (string_of_type_directive b )
  | Illegal_semver s -> 
      fprintf ppf "Illegal semantic version string %s" s
let () =
  Location.register_error_of_exn
    (function
      | Error (err, loc) ->
          Some (Location.error_of_printer loc report_error err)
      | _ ->
          None
    )


# 727 "parsing/lexer.ml"
let __ocaml_lex_tables = {
  Lexing.lex_base = 
   "\000\000\164\255\165\255\224\000\003\001\038\001\073\001\108\001\
    \143\001\188\255\178\001\215\001\196\255\091\000\252\001\031\002\
    \068\000\071\000\084\000\066\002\213\255\215\255\218\255\101\002\
    \196\002\231\002\089\000\255\000\005\003\236\255\082\003\115\003\
    \188\003\140\004\092\005\044\006\011\007\103\007\055\008\125\000\
    \254\255\001\000\005\000\255\255\006\000\007\000\022\009\052\009\
    \004\010\250\255\249\255\212\010\164\011\247\255\246\255\237\255\
    \238\255\239\255\093\000\118\002\091\000\110\000\231\002\007\004\
    \215\004\101\002\254\002\118\000\194\255\235\255\120\005\132\012\
    \096\000\113\000\011\000\234\255\233\255\229\255\229\004\128\000\
    \115\000\232\255\224\000\117\000\231\255\119\006\147\000\230\255\
    \146\000\225\255\148\000\224\255\217\000\132\012\223\255\171\012\
    \175\008\174\006\222\255\012\000\024\001\044\001\080\001\045\001\
    \222\255\013\000\217\012\000\013\035\013\073\013\210\255\206\255\
    \207\255\208\255\204\255\108\013\154\000\183\000\197\255\198\255\
    \199\255\199\000\182\255\184\255\191\255\143\013\187\255\189\255\
    \178\013\213\013\248\013\027\014\235\005\243\255\244\255\017\000\
    \245\255\062\002\172\007\253\255\223\000\241\000\255\255\254\255\
    \252\255\200\007\045\014\250\000\252\000\018\000\251\255\250\255\
    \249\255\128\009\030\003\003\001\248\255\092\003\004\001\247\255\
    \079\010\005\001\246\255\043\001\199\001\247\255\248\255\249\255\
    \059\001\118\014\255\255\250\255\031\011\036\004\253\255\038\001\
    \069\001\094\001\252\004\252\255\239\011\251\255\095\001\181\001\
    \252\255\238\006\254\255\255\255\111\001\112\001\253\255\074\007\
    \016\001\019\001\050\001\063\001\026\001\107\001\033\001\019\000\
    \255\255";
  Lexing.lex_backtrk = 
   "\255\255\255\255\255\255\088\000\087\000\084\000\083\000\076\000\
    \074\000\255\255\065\000\062\000\255\255\055\000\054\000\052\000\
    \050\000\046\000\044\000\079\000\255\255\255\255\255\255\035\000\
    \034\000\041\000\039\000\038\000\060\000\255\255\014\000\014\000\
    \013\000\012\000\011\000\010\000\007\000\004\000\003\000\002\000\
    \255\255\091\000\091\000\255\255\255\255\255\255\082\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\015\000\255\255\255\255\255\255\014\000\
    \014\000\014\000\015\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\026\000\026\000\
    \026\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \027\000\255\255\028\000\255\255\029\000\086\000\255\255\089\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\036\000\085\000\080\000\043\000\255\255\255\255\
    \255\255\255\255\255\255\053\000\070\000\069\000\255\255\255\255\
    \255\255\072\000\255\255\255\255\255\255\063\000\255\255\255\255\
    \081\000\075\000\078\000\077\000\255\255\255\255\255\255\012\000\
    \255\255\012\000\012\000\255\255\012\000\012\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \008\000\008\000\255\255\255\255\005\000\005\000\255\255\001\000\
    \005\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\003\000\255\255\255\255\003\000\255\255\255\255\255\255\
    \002\000\255\255\255\255\001\000\255\255\255\255\255\255\255\255\
    \255\255";
  Lexing.lex_default = 
   "\001\000\000\000\000\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\255\255\255\255\000\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\000\000\000\000\000\000\255\255\
    \255\255\255\255\255\255\072\000\255\255\000\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\255\255\255\255\000\000\255\255\255\255\255\255\255\255\
    \255\255\000\000\000\000\255\255\255\255\000\000\000\000\000\000\
    \000\000\000\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\000\000\000\000\255\255\077\000\
    \255\255\255\255\255\255\000\000\000\000\000\000\255\255\255\255\
    \255\255\000\000\255\255\255\255\000\000\255\255\255\255\000\000\
    \255\255\000\000\255\255\000\000\255\255\255\255\000\000\255\255\
    \100\000\255\255\000\000\255\255\100\000\101\000\100\000\103\000\
    \000\000\255\255\255\255\255\255\255\255\255\255\000\000\000\000\
    \000\000\000\000\000\000\255\255\255\255\255\255\000\000\000\000\
    \000\000\255\255\000\000\000\000\000\000\255\255\000\000\000\000\
    \255\255\255\255\255\255\255\255\133\000\000\000\000\000\255\255\
    \000\000\147\000\255\255\000\000\255\255\255\255\000\000\000\000\
    \000\000\255\255\255\255\255\255\255\255\255\255\000\000\000\000\
    \000\000\255\255\255\255\255\255\000\000\255\255\255\255\000\000\
    \255\255\255\255\000\000\255\255\165\000\000\000\000\000\000\000\
    \255\255\171\000\000\000\000\000\255\255\255\255\000\000\255\255\
    \255\255\255\255\255\255\000\000\255\255\000\000\255\255\184\000\
    \000\000\255\255\000\000\000\000\255\255\255\255\000\000\255\255\
    \255\255\255\255\194\000\197\000\255\255\197\000\255\255\255\255\
    \000\000";
  Lexing.lex_trans = 
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\039\000\040\000\040\000\039\000\041\000\045\000\043\000\
    \043\000\040\000\044\000\044\000\045\000\073\000\098\000\104\000\
    \074\000\099\000\105\000\134\000\148\000\200\000\163\000\149\000\
    \039\000\008\000\029\000\024\000\006\000\004\000\023\000\027\000\
    \026\000\021\000\025\000\007\000\020\000\019\000\018\000\003\000\
    \031\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\017\000\016\000\015\000\014\000\010\000\036\000\
    \005\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\013\000\042\000\012\000\005\000\038\000\
    \022\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\028\000\011\000\009\000\037\000\114\000\
    \116\000\113\000\110\000\088\000\112\000\111\000\039\000\076\000\
    \067\000\039\000\067\000\065\000\065\000\066\000\066\000\066\000\
    \066\000\066\000\066\000\066\000\066\000\066\000\066\000\119\000\
    \075\000\118\000\081\000\117\000\084\000\039\000\064\000\064\000\
    \064\000\064\000\064\000\064\000\064\000\064\000\066\000\066\000\
    \066\000\066\000\066\000\066\000\066\000\066\000\066\000\066\000\
    \082\000\082\000\082\000\082\000\082\000\082\000\082\000\082\000\
    \082\000\082\000\087\000\089\000\090\000\091\000\092\000\123\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\120\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\121\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \002\000\003\000\091\000\092\000\003\000\003\000\003\000\122\000\
    \143\000\073\000\003\000\003\000\074\000\003\000\003\000\003\000\
    \083\000\083\000\083\000\083\000\083\000\083\000\083\000\083\000\
    \083\000\083\000\003\000\142\000\003\000\003\000\003\000\003\000\
    \003\000\152\000\098\000\151\000\003\000\099\000\255\255\003\000\
    \003\000\003\000\156\000\159\000\162\000\003\000\003\000\175\000\
    \003\000\003\000\003\000\193\000\194\000\134\000\098\000\104\000\
    \163\000\099\000\105\000\198\000\195\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\199\000\167\000\175\000\005\000\
    \182\000\196\000\005\000\005\000\005\000\000\000\103\000\175\000\
    \005\000\005\000\177\000\005\000\005\000\005\000\000\000\000\000\
    \000\000\102\000\098\000\071\000\003\000\099\000\003\000\000\000\
    \005\000\003\000\005\000\005\000\005\000\005\000\005\000\000\000\
    \175\000\167\000\006\000\177\000\182\000\006\000\006\000\006\000\
    \102\000\000\000\101\000\006\000\006\000\196\000\006\000\006\000\
    \006\000\187\000\187\000\000\000\189\000\189\000\000\000\003\000\
    \000\000\003\000\000\000\006\000\005\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\107\000\000\000\000\000\
    \107\000\107\000\107\000\000\000\000\000\000\000\107\000\107\000\
    \000\000\107\000\131\000\107\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\005\000\000\000\005\000\000\000\107\000\006\000\
    \107\000\130\000\107\000\107\000\107\000\000\000\000\000\000\000\
    \128\000\000\000\000\000\128\000\128\000\128\000\000\000\000\000\
    \000\000\128\000\128\000\000\000\128\000\128\000\128\000\187\000\
    \000\000\000\000\188\000\000\000\000\000\006\000\000\000\006\000\
    \000\000\128\000\107\000\128\000\129\000\128\000\128\000\128\000\
    \000\000\167\000\000\000\006\000\168\000\000\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \107\000\170\000\107\000\000\000\006\000\128\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\000\000\000\000\
    \006\000\000\000\000\000\006\000\006\000\006\000\000\000\255\255\
    \000\000\006\000\006\000\000\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\000\000\128\000\000\000\128\000\000\000\127\000\
    \006\000\006\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \255\255\000\000\000\000\000\000\000\000\006\000\000\000\000\000\
    \006\000\006\000\006\000\169\000\000\000\000\000\006\000\006\000\
    \000\000\006\000\006\000\006\000\255\255\255\255\006\000\126\000\
    \006\000\185\000\255\255\000\000\124\000\006\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\255\255\
    \006\000\000\000\000\000\006\000\006\000\006\000\000\000\000\000\
    \148\000\006\000\006\000\149\000\115\000\006\000\006\000\000\000\
    \255\255\000\000\000\000\125\000\000\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\107\000\000\000\150\000\107\000\107\000\
    \107\000\000\000\000\000\255\255\107\000\107\000\000\000\107\000\
    \108\000\107\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \006\000\000\000\006\000\000\000\107\000\006\000\107\000\107\000\
    \109\000\107\000\107\000\000\000\000\000\000\000\006\000\000\000\
    \000\000\006\000\006\000\106\000\000\000\000\000\000\000\006\000\
    \006\000\000\000\006\000\006\000\006\000\065\000\065\000\000\000\
    \000\000\000\000\146\000\006\000\000\000\006\000\000\000\006\000\
    \107\000\006\000\006\000\006\000\006\000\006\000\059\000\059\000\
    \059\000\059\000\059\000\059\000\059\000\059\000\059\000\059\000\
    \000\000\056\000\000\000\000\000\000\000\186\000\000\000\000\000\
    \000\000\000\000\000\000\058\000\000\000\000\000\107\000\000\000\
    \107\000\000\000\000\000\006\000\065\000\000\000\000\000\166\000\
    \000\000\000\000\000\000\000\000\000\000\097\000\000\000\000\000\
    \000\000\057\000\000\000\055\000\000\000\059\000\000\000\000\000\
    \000\000\000\000\000\000\058\000\000\000\000\000\000\000\000\000\
    \000\000\006\000\000\000\006\000\097\000\095\000\000\000\095\000\
    \095\000\095\000\095\000\000\000\000\000\000\000\095\000\095\000\
    \000\000\095\000\095\000\095\000\096\000\096\000\096\000\096\000\
    \096\000\096\000\096\000\096\000\096\000\096\000\095\000\000\000\
    \095\000\095\000\095\000\095\000\095\000\000\000\000\000\000\000\
    \003\000\000\000\000\000\003\000\003\000\003\000\000\000\000\000\
    \094\000\093\000\003\000\000\000\003\000\003\000\003\000\063\000\
    \063\000\063\000\063\000\063\000\063\000\063\000\063\000\063\000\
    \063\000\003\000\095\000\003\000\003\000\003\000\003\000\003\000\
    \063\000\063\000\063\000\063\000\063\000\063\000\066\000\066\000\
    \066\000\066\000\066\000\066\000\066\000\066\000\066\000\066\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\255\255\000\000\
    \095\000\068\000\095\000\000\000\000\000\003\000\000\000\000\000\
    \063\000\063\000\063\000\063\000\063\000\063\000\157\000\157\000\
    \157\000\157\000\157\000\157\000\157\000\157\000\157\000\157\000\
    \000\000\000\000\000\000\000\000\000\000\066\000\000\000\000\000\
    \000\000\000\000\000\000\003\000\070\000\003\000\070\000\070\000\
    \070\000\070\000\070\000\070\000\070\000\070\000\070\000\070\000\
    \070\000\070\000\070\000\070\000\070\000\070\000\070\000\070\000\
    \070\000\070\000\070\000\070\000\070\000\070\000\070\000\070\000\
    \059\000\069\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\158\000\158\000\158\000\158\000\
    \158\000\158\000\158\000\158\000\158\000\158\000\000\000\058\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\056\000\000\000\
    \000\000\059\000\000\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\000\000\000\000\000\000\
    \000\000\030\000\000\000\000\000\000\000\060\000\000\000\058\000\
    \058\000\000\000\000\000\000\000\000\000\000\000\057\000\056\000\
    \055\000\000\000\061\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\062\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\030\000\000\000\000\000\060\000\000\000\000\000\
    \058\000\000\000\000\000\000\000\000\000\000\000\000\000\057\000\
    \000\000\055\000\061\000\032\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\062\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\000\000\
    \000\000\000\000\000\000\032\000\000\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\063\000\
    \063\000\063\000\063\000\063\000\063\000\063\000\063\000\063\000\
    \063\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \063\000\063\000\063\000\063\000\063\000\063\000\000\000\000\000\
    \000\000\000\000\000\000\056\000\178\000\178\000\178\000\178\000\
    \178\000\178\000\178\000\178\000\178\000\178\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\063\000\000\000\
    \063\000\063\000\063\000\063\000\063\000\063\000\000\000\000\000\
    \000\000\000\000\000\000\057\000\000\000\055\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\000\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\033\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\000\000\
    \000\000\000\000\000\000\033\000\000\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\064\000\
    \064\000\064\000\064\000\064\000\064\000\064\000\064\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\085\000\085\000\085\000\
    \085\000\085\000\085\000\085\000\085\000\085\000\085\000\000\000\
    \000\000\000\000\000\000\056\000\000\000\000\000\085\000\085\000\
    \085\000\085\000\085\000\085\000\179\000\179\000\179\000\179\000\
    \179\000\179\000\179\000\179\000\179\000\179\000\064\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\057\000\000\000\055\000\085\000\085\000\
    \085\000\085\000\085\000\085\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\000\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\034\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\000\000\
    \000\000\000\000\000\000\034\000\000\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\070\000\
    \000\000\070\000\070\000\070\000\070\000\070\000\070\000\070\000\
    \070\000\070\000\070\000\070\000\070\000\070\000\070\000\070\000\
    \070\000\070\000\070\000\070\000\070\000\070\000\070\000\070\000\
    \070\000\070\000\070\000\000\000\069\000\134\000\000\000\000\000\
    \135\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\139\000\000\000\000\000\
    \000\000\000\000\137\000\141\000\000\000\140\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\000\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\035\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\138\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\000\000\
    \000\000\000\000\000\000\035\000\000\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\086\000\
    \086\000\086\000\086\000\086\000\086\000\086\000\086\000\086\000\
    \086\000\000\000\000\000\000\000\000\000\000\000\000\000\097\000\
    \086\000\086\000\086\000\086\000\086\000\086\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\097\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \086\000\086\000\086\000\086\000\086\000\086\000\096\000\096\000\
    \096\000\096\000\096\000\096\000\096\000\096\000\096\000\096\000\
    \000\000\000\000\000\000\136\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\000\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\000\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\046\000\000\000\000\000\046\000\
    \046\000\046\000\000\000\000\000\000\000\046\000\046\000\000\000\
    \046\000\046\000\046\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\046\000\000\000\046\000\
    \046\000\046\000\046\000\046\000\000\000\191\000\000\000\191\000\
    \191\000\191\000\191\000\191\000\191\000\191\000\191\000\191\000\
    \191\000\191\000\191\000\191\000\191\000\191\000\191\000\191\000\
    \191\000\191\000\191\000\191\000\191\000\191\000\191\000\191\000\
    \191\000\046\000\052\000\190\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\000\000\046\000\
    \046\000\046\000\000\000\046\000\046\000\046\000\000\000\000\000\
    \000\000\046\000\046\000\000\000\046\000\046\000\046\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\046\000\000\000\046\000\046\000\046\000\046\000\046\000\
    \000\000\191\000\000\000\191\000\191\000\191\000\191\000\191\000\
    \191\000\191\000\191\000\191\000\191\000\191\000\191\000\191\000\
    \191\000\191\000\191\000\191\000\191\000\191\000\191\000\191\000\
    \191\000\191\000\191\000\191\000\191\000\046\000\048\000\190\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\000\000\046\000\000\000\046\000\000\000\000\000\
    \000\000\000\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\000\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\145\000\000\000\145\000\145\000\145\000\
    \145\000\145\000\145\000\145\000\145\000\145\000\145\000\145\000\
    \145\000\145\000\145\000\145\000\145\000\145\000\145\000\145\000\
    \145\000\145\000\145\000\145\000\145\000\145\000\145\000\145\000\
    \144\000\145\000\145\000\145\000\145\000\145\000\145\000\145\000\
    \145\000\145\000\145\000\145\000\145\000\145\000\145\000\145\000\
    \145\000\145\000\145\000\145\000\145\000\145\000\145\000\145\000\
    \145\000\145\000\145\000\000\000\144\000\000\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\035\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\000\000\000\000\000\000\000\000\035\000\000\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \102\000\098\000\000\000\000\000\099\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\102\000\
    \000\000\101\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\096\000\
    \096\000\096\000\096\000\096\000\096\000\096\000\096\000\096\000\
    \096\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\000\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\000\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\046\000\
    \000\000\000\000\046\000\046\000\046\000\000\000\000\000\000\000\
    \046\000\046\000\000\000\046\000\046\000\046\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \046\000\000\000\046\000\046\000\046\000\046\000\046\000\000\000\
    \000\000\000\000\000\000\047\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\050\000\000\000\
    \000\000\000\000\000\000\000\000\046\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\000\000\
    \000\000\000\000\046\000\047\000\046\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\255\255\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\160\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\160\000\160\000\160\000\160\000\160\000\160\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\160\000\160\000\160\000\160\000\160\000\160\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\000\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\048\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\049\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\000\000\
    \000\000\000\000\000\000\048\000\000\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\161\000\
    \161\000\161\000\161\000\161\000\161\000\161\000\161\000\161\000\
    \161\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \161\000\161\000\161\000\161\000\161\000\161\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \161\000\161\000\161\000\161\000\161\000\161\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\000\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\051\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\054\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\000\000\
    \000\000\000\000\000\000\051\000\000\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\180\000\
    \180\000\180\000\180\000\180\000\180\000\180\000\180\000\180\000\
    \180\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \180\000\180\000\180\000\180\000\180\000\180\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \180\000\180\000\180\000\180\000\180\000\180\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\000\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\052\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\053\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\000\000\
    \000\000\000\000\000\000\052\000\000\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\181\000\
    \181\000\181\000\181\000\181\000\181\000\181\000\181\000\181\000\
    \181\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \181\000\181\000\181\000\181\000\181\000\181\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \181\000\181\000\181\000\181\000\181\000\181\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\000\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\000\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\080\000\093\000\080\000\000\000\
    \093\000\093\000\093\000\080\000\000\000\000\000\093\000\093\000\
    \000\000\093\000\093\000\093\000\079\000\079\000\079\000\079\000\
    \079\000\079\000\079\000\079\000\079\000\079\000\093\000\000\000\
    \093\000\093\000\093\000\093\000\093\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\095\000\000\000\095\000\095\000\
    \095\000\095\000\000\000\000\000\000\000\095\000\095\000\000\000\
    \095\000\095\000\095\000\000\000\000\000\000\000\000\000\000\000\
    \080\000\000\000\093\000\000\000\000\000\095\000\080\000\095\000\
    \095\000\095\000\095\000\095\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\080\000\000\000\000\000\000\000\080\000\000\000\
    \080\000\000\000\006\000\000\000\078\000\006\000\006\000\006\000\
    \093\000\000\000\093\000\006\000\006\000\000\000\006\000\006\000\
    \006\000\095\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\006\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\107\000\000\000\000\000\107\000\107\000\107\000\095\000\
    \000\000\095\000\107\000\107\000\000\000\107\000\107\000\107\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\006\000\
    \000\000\000\000\107\000\000\000\107\000\107\000\107\000\107\000\
    \107\000\000\000\000\000\000\000\107\000\000\000\000\000\107\000\
    \107\000\107\000\000\000\000\000\000\000\107\000\107\000\000\000\
    \107\000\107\000\107\000\000\000\000\000\006\000\000\000\006\000\
    \000\000\000\000\000\000\000\000\000\000\107\000\107\000\107\000\
    \107\000\107\000\107\000\107\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\107\000\000\000\000\000\107\000\107\000\107\000\
    \000\000\000\000\000\000\107\000\107\000\000\000\107\000\107\000\
    \107\000\000\000\000\000\000\000\107\000\000\000\107\000\000\000\
    \000\000\107\000\000\000\107\000\255\255\107\000\107\000\107\000\
    \107\000\107\000\000\000\000\000\000\000\006\000\000\000\000\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\006\000\006\000\
    \000\000\006\000\006\000\006\000\000\000\000\000\000\000\107\000\
    \000\000\107\000\000\000\000\000\000\000\000\000\006\000\107\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \006\000\000\000\000\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\000\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\107\000\000\000\107\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\128\000\000\000\000\000\128\000\128\000\
    \128\000\000\000\000\000\000\000\128\000\128\000\000\000\128\000\
    \128\000\128\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \006\000\000\000\006\000\000\000\128\000\006\000\128\000\128\000\
    \128\000\128\000\128\000\000\000\000\000\000\000\128\000\000\000\
    \000\000\128\000\128\000\128\000\000\000\000\000\000\000\128\000\
    \128\000\000\000\128\000\128\000\128\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\006\000\000\000\006\000\000\000\128\000\
    \128\000\128\000\128\000\128\000\128\000\128\000\000\000\000\000\
    \000\000\107\000\000\000\000\000\107\000\107\000\107\000\000\000\
    \000\000\000\000\107\000\107\000\000\000\107\000\107\000\107\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\128\000\000\000\
    \128\000\000\000\107\000\128\000\107\000\107\000\107\000\107\000\
    \107\000\000\000\000\000\000\000\107\000\000\000\000\000\107\000\
    \107\000\107\000\000\000\000\000\000\000\107\000\107\000\000\000\
    \107\000\107\000\107\000\000\000\000\000\155\000\000\000\155\000\
    \000\000\128\000\000\000\128\000\155\000\107\000\107\000\107\000\
    \107\000\107\000\107\000\107\000\000\000\154\000\154\000\154\000\
    \154\000\154\000\154\000\154\000\154\000\154\000\154\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\107\000\000\000\107\000\000\000\
    \000\000\107\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \175\000\000\000\000\000\176\000\000\000\000\000\000\000\000\000\
    \000\000\155\000\000\000\000\000\000\000\000\000\000\000\155\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\174\000\107\000\
    \174\000\107\000\000\000\155\000\000\000\174\000\000\000\155\000\
    \000\000\155\000\000\000\000\000\000\000\153\000\173\000\173\000\
    \173\000\173\000\173\000\173\000\173\000\173\000\173\000\173\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\174\000\000\000\000\000\000\000\000\000\000\000\
    \174\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\174\000\000\000\000\000\000\000\
    \174\000\000\000\174\000\000\000\000\000\000\000\172\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\255\255";
  Lexing.lex_check = 
   "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\000\000\041\000\000\000\000\000\041\000\042\000\
    \044\000\045\000\042\000\044\000\045\000\074\000\099\000\105\000\
    \074\000\099\000\105\000\135\000\149\000\199\000\135\000\149\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\
    \013\000\017\000\018\000\026\000\017\000\017\000\039\000\072\000\
    \058\000\039\000\058\000\060\000\060\000\058\000\058\000\058\000\
    \058\000\058\000\058\000\058\000\058\000\058\000\058\000\013\000\
    \073\000\013\000\080\000\013\000\083\000\039\000\061\000\061\000\
    \061\000\061\000\061\000\061\000\061\000\061\000\067\000\067\000\
    \067\000\067\000\067\000\067\000\067\000\067\000\067\000\067\000\
    \079\000\079\000\079\000\079\000\079\000\079\000\079\000\079\000\
    \079\000\079\000\086\000\088\000\088\000\090\000\090\000\116\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\013\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\117\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\003\000\092\000\092\000\003\000\003\000\003\000\121\000\
    \140\000\027\000\003\000\003\000\027\000\003\000\003\000\003\000\
    \082\000\082\000\082\000\082\000\082\000\082\000\082\000\082\000\
    \082\000\082\000\003\000\141\000\003\000\003\000\003\000\003\000\
    \003\000\147\000\100\000\148\000\004\000\100\000\027\000\004\000\
    \004\000\004\000\155\000\158\000\161\000\004\000\004\000\175\000\
    \004\000\004\000\004\000\192\000\193\000\163\000\101\000\103\000\
    \163\000\101\000\103\000\196\000\194\000\004\000\003\000\004\000\
    \004\000\004\000\004\000\004\000\198\000\168\000\175\000\005\000\
    \168\000\195\000\005\000\005\000\005\000\255\255\101\000\176\000\
    \005\000\005\000\176\000\005\000\005\000\005\000\255\255\255\255\
    \255\255\102\000\102\000\027\000\003\000\102\000\003\000\255\255\
    \005\000\004\000\005\000\005\000\005\000\005\000\005\000\255\255\
    \177\000\182\000\006\000\177\000\182\000\006\000\006\000\006\000\
    \102\000\255\255\102\000\006\000\006\000\197\000\006\000\006\000\
    \006\000\188\000\189\000\255\255\188\000\189\000\255\255\004\000\
    \255\255\004\000\255\255\006\000\005\000\006\000\006\000\006\000\
    \006\000\006\000\255\255\255\255\255\255\007\000\255\255\255\255\
    \007\000\007\000\007\000\255\255\255\255\255\255\007\000\007\000\
    \255\255\007\000\007\000\007\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\005\000\255\255\005\000\255\255\007\000\006\000\
    \007\000\007\000\007\000\007\000\007\000\255\255\255\255\255\255\
    \008\000\255\255\255\255\008\000\008\000\008\000\255\255\255\255\
    \255\255\008\000\008\000\255\255\008\000\008\000\008\000\183\000\
    \255\255\255\255\183\000\255\255\255\255\006\000\255\255\006\000\
    \255\255\008\000\007\000\008\000\008\000\008\000\008\000\008\000\
    \255\255\164\000\255\255\010\000\164\000\255\255\010\000\010\000\
    \010\000\255\255\255\255\255\255\010\000\010\000\255\255\010\000\
    \010\000\010\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \007\000\164\000\007\000\255\255\010\000\008\000\010\000\010\000\
    \010\000\010\000\010\000\255\255\255\255\255\255\255\255\255\255\
    \011\000\255\255\255\255\011\000\011\000\011\000\255\255\027\000\
    \255\255\011\000\011\000\255\255\011\000\011\000\011\000\255\255\
    \255\255\255\255\255\255\008\000\255\255\008\000\255\255\010\000\
    \010\000\011\000\255\255\011\000\011\000\011\000\011\000\011\000\
    \100\000\255\255\255\255\255\255\255\255\014\000\255\255\255\255\
    \014\000\014\000\014\000\164\000\255\255\255\255\014\000\014\000\
    \255\255\014\000\014\000\014\000\101\000\103\000\010\000\010\000\
    \010\000\183\000\194\000\255\255\011\000\011\000\014\000\255\255\
    \014\000\014\000\014\000\014\000\014\000\255\255\255\255\195\000\
    \015\000\255\255\255\255\015\000\015\000\015\000\255\255\255\255\
    \137\000\015\000\015\000\137\000\015\000\015\000\015\000\255\255\
    \102\000\255\255\255\255\011\000\255\255\011\000\255\255\255\255\
    \255\255\015\000\014\000\015\000\015\000\015\000\015\000\015\000\
    \255\255\255\255\255\255\019\000\255\255\137\000\019\000\019\000\
    \019\000\255\255\255\255\197\000\019\000\019\000\255\255\019\000\
    \019\000\019\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \014\000\255\255\014\000\255\255\019\000\015\000\019\000\019\000\
    \019\000\019\000\019\000\255\255\255\255\255\255\023\000\255\255\
    \255\255\023\000\023\000\023\000\255\255\255\255\255\255\023\000\
    \023\000\255\255\023\000\023\000\023\000\065\000\065\000\255\255\
    \255\255\255\255\137\000\015\000\255\255\015\000\255\255\023\000\
    \019\000\023\000\023\000\023\000\023\000\023\000\059\000\059\000\
    \059\000\059\000\059\000\059\000\059\000\059\000\059\000\059\000\
    \255\255\065\000\255\255\255\255\255\255\183\000\255\255\255\255\
    \255\255\255\255\255\255\059\000\255\255\255\255\019\000\255\255\
    \019\000\255\255\255\255\023\000\065\000\255\255\255\255\164\000\
    \255\255\255\255\255\255\255\255\255\255\024\000\255\255\255\255\
    \255\255\065\000\255\255\065\000\255\255\059\000\255\255\255\255\
    \255\255\255\255\255\255\059\000\255\255\255\255\255\255\255\255\
    \255\255\023\000\255\255\023\000\024\000\024\000\255\255\024\000\
    \024\000\024\000\024\000\255\255\255\255\255\255\024\000\024\000\
    \255\255\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\024\000\024\000\024\000\024\000\024\000\255\255\
    \024\000\024\000\024\000\024\000\024\000\255\255\255\255\255\255\
    \025\000\255\255\255\255\025\000\025\000\025\000\255\255\255\255\
    \025\000\025\000\025\000\255\255\025\000\025\000\025\000\062\000\
    \062\000\062\000\062\000\062\000\062\000\062\000\062\000\062\000\
    \062\000\025\000\024\000\025\000\025\000\025\000\025\000\025\000\
    \062\000\062\000\062\000\062\000\062\000\062\000\066\000\066\000\
    \066\000\066\000\066\000\066\000\066\000\066\000\066\000\066\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\137\000\255\255\
    \024\000\028\000\024\000\255\255\255\255\025\000\255\255\255\255\
    \062\000\062\000\062\000\062\000\062\000\062\000\154\000\154\000\
    \154\000\154\000\154\000\154\000\154\000\154\000\154\000\154\000\
    \255\255\255\255\255\255\255\255\255\255\066\000\255\255\255\255\
    \255\255\255\255\255\255\025\000\028\000\025\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\
    \028\000\028\000\028\000\028\000\028\000\028\000\028\000\028\000\
    \030\000\028\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\157\000\157\000\157\000\157\000\
    \157\000\157\000\157\000\157\000\157\000\157\000\255\255\030\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\030\000\255\255\
    \255\255\031\000\255\255\031\000\031\000\031\000\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\255\255\255\255\255\255\
    \255\255\030\000\255\255\255\255\255\255\031\000\255\255\030\000\
    \031\000\255\255\255\255\255\255\255\255\255\255\030\000\031\000\
    \030\000\255\255\031\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\031\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\031\000\255\255\255\255\031\000\255\255\255\255\
    \031\000\255\255\255\255\255\255\255\255\255\255\255\255\031\000\
    \255\255\031\000\031\000\032\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\031\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\255\255\
    \255\255\255\255\255\255\032\000\255\255\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\063\000\
    \063\000\063\000\063\000\063\000\063\000\063\000\063\000\063\000\
    \063\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \063\000\063\000\063\000\063\000\063\000\063\000\255\255\255\255\
    \255\255\255\255\255\255\063\000\173\000\173\000\173\000\173\000\
    \173\000\173\000\173\000\173\000\173\000\173\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\063\000\255\255\
    \063\000\063\000\063\000\063\000\063\000\063\000\255\255\255\255\
    \255\255\255\255\255\255\063\000\255\255\063\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\255\255\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\033\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\255\255\
    \255\255\255\255\255\255\033\000\255\255\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\064\000\
    \064\000\064\000\064\000\064\000\064\000\064\000\064\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\078\000\078\000\078\000\
    \078\000\078\000\078\000\078\000\078\000\078\000\078\000\255\255\
    \255\255\255\255\255\255\064\000\255\255\255\255\078\000\078\000\
    \078\000\078\000\078\000\078\000\178\000\178\000\178\000\178\000\
    \178\000\178\000\178\000\178\000\178\000\178\000\064\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\064\000\255\255\064\000\078\000\078\000\
    \078\000\078\000\078\000\078\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\255\255\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\034\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\255\255\
    \255\255\255\255\255\255\034\000\255\255\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\070\000\
    \255\255\070\000\070\000\070\000\070\000\070\000\070\000\070\000\
    \070\000\070\000\070\000\070\000\070\000\070\000\070\000\070\000\
    \070\000\070\000\070\000\070\000\070\000\070\000\070\000\070\000\
    \070\000\070\000\070\000\255\255\070\000\132\000\255\255\255\255\
    \132\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\132\000\255\255\255\255\
    \255\255\255\255\132\000\132\000\255\255\132\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\255\255\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\035\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\132\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\255\255\
    \255\255\255\255\255\255\035\000\255\255\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\085\000\
    \085\000\085\000\085\000\085\000\085\000\085\000\085\000\085\000\
    \085\000\255\255\255\255\255\255\255\255\255\255\255\255\097\000\
    \085\000\085\000\085\000\085\000\085\000\085\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\097\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \085\000\085\000\085\000\085\000\085\000\085\000\097\000\097\000\
    \097\000\097\000\097\000\097\000\097\000\097\000\097\000\097\000\
    \255\255\255\255\255\255\132\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\255\255\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\255\255\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\035\000\036\000\255\255\255\255\036\000\
    \036\000\036\000\255\255\255\255\255\255\036\000\036\000\255\255\
    \036\000\036\000\036\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\036\000\255\255\036\000\
    \036\000\036\000\036\000\036\000\255\255\185\000\255\255\185\000\
    \185\000\185\000\185\000\185\000\185\000\185\000\185\000\185\000\
    \185\000\185\000\185\000\185\000\185\000\185\000\185\000\185\000\
    \185\000\185\000\185\000\185\000\185\000\185\000\185\000\185\000\
    \185\000\036\000\036\000\185\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\255\255\036\000\
    \037\000\036\000\255\255\037\000\037\000\037\000\255\255\255\255\
    \255\255\037\000\037\000\255\255\037\000\037\000\037\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\037\000\255\255\037\000\037\000\037\000\037\000\037\000\
    \255\255\191\000\255\255\191\000\191\000\191\000\191\000\191\000\
    \191\000\191\000\191\000\191\000\191\000\191\000\191\000\191\000\
    \191\000\191\000\191\000\191\000\191\000\191\000\191\000\191\000\
    \191\000\191\000\191\000\191\000\191\000\037\000\037\000\191\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\255\255\037\000\255\255\037\000\255\255\255\255\
    \255\255\255\255\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\255\255\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\138\000\255\255\138\000\138\000\138\000\
    \138\000\138\000\138\000\138\000\138\000\138\000\138\000\138\000\
    \138\000\138\000\138\000\138\000\138\000\138\000\138\000\138\000\
    \138\000\138\000\138\000\138\000\138\000\138\000\138\000\145\000\
    \138\000\145\000\145\000\145\000\145\000\145\000\145\000\145\000\
    \145\000\145\000\145\000\145\000\145\000\145\000\145\000\145\000\
    \145\000\145\000\145\000\145\000\145\000\145\000\145\000\145\000\
    \145\000\145\000\145\000\255\255\145\000\255\255\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\038\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\038\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\038\000\255\255\255\255\255\255\255\255\038\000\255\255\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\038\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \096\000\096\000\255\255\255\255\096\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\096\000\
    \255\255\096\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\096\000\
    \096\000\096\000\096\000\096\000\096\000\096\000\096\000\096\000\
    \096\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\038\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\255\255\038\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\255\255\038\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\046\000\
    \255\255\255\255\046\000\046\000\046\000\255\255\255\255\255\255\
    \046\000\046\000\255\255\046\000\046\000\046\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \046\000\255\255\046\000\046\000\046\000\046\000\046\000\255\255\
    \255\255\255\255\255\255\047\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\255\255\
    \255\255\255\255\255\255\255\255\046\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\255\255\
    \255\255\255\255\046\000\047\000\046\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\096\000\
    \153\000\153\000\153\000\153\000\153\000\153\000\153\000\153\000\
    \153\000\153\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\153\000\153\000\153\000\153\000\153\000\153\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\153\000\153\000\153\000\153\000\153\000\153\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\255\255\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\048\000\047\000\047\000\047\000\047\000\
    \047\000\047\000\047\000\047\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\255\255\
    \255\255\255\255\255\255\048\000\255\255\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\160\000\
    \160\000\160\000\160\000\160\000\160\000\160\000\160\000\160\000\
    \160\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \160\000\160\000\160\000\160\000\160\000\160\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \160\000\160\000\160\000\160\000\160\000\160\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\255\255\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\051\000\048\000\048\000\048\000\048\000\
    \048\000\048\000\048\000\048\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\255\255\
    \255\255\255\255\255\255\051\000\255\255\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\172\000\
    \172\000\172\000\172\000\172\000\172\000\172\000\172\000\172\000\
    \172\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \172\000\172\000\172\000\172\000\172\000\172\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \172\000\172\000\172\000\172\000\172\000\172\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\255\255\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\052\000\051\000\051\000\051\000\051\000\
    \051\000\051\000\051\000\051\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\255\255\
    \255\255\255\255\255\255\052\000\255\255\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\180\000\
    \180\000\180\000\180\000\180\000\180\000\180\000\180\000\180\000\
    \180\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \180\000\180\000\180\000\180\000\180\000\180\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \180\000\180\000\180\000\180\000\180\000\180\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\255\255\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\255\255\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\052\000\071\000\093\000\071\000\255\255\
    \093\000\093\000\093\000\071\000\255\255\255\255\093\000\093\000\
    \255\255\093\000\093\000\093\000\071\000\071\000\071\000\071\000\
    \071\000\071\000\071\000\071\000\071\000\071\000\093\000\255\255\
    \093\000\093\000\093\000\093\000\093\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\095\000\255\255\095\000\095\000\
    \095\000\095\000\255\255\255\255\255\255\095\000\095\000\255\255\
    \095\000\095\000\095\000\255\255\255\255\255\255\255\255\255\255\
    \071\000\255\255\093\000\255\255\255\255\095\000\071\000\095\000\
    \095\000\095\000\095\000\095\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\071\000\255\255\255\255\255\255\071\000\255\255\
    \071\000\255\255\106\000\255\255\071\000\106\000\106\000\106\000\
    \093\000\255\255\093\000\106\000\106\000\255\255\106\000\106\000\
    \106\000\095\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\106\000\255\255\106\000\106\000\106\000\
    \106\000\106\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\107\000\255\255\255\255\107\000\107\000\107\000\095\000\
    \255\255\095\000\107\000\107\000\255\255\107\000\107\000\107\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\106\000\
    \255\255\255\255\107\000\255\255\107\000\107\000\107\000\107\000\
    \107\000\255\255\255\255\255\255\108\000\255\255\255\255\108\000\
    \108\000\108\000\255\255\255\255\255\255\108\000\108\000\255\255\
    \108\000\108\000\108\000\255\255\255\255\106\000\255\255\106\000\
    \255\255\255\255\255\255\255\255\255\255\108\000\107\000\108\000\
    \108\000\108\000\108\000\108\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\109\000\255\255\255\255\109\000\109\000\109\000\
    \255\255\255\255\255\255\109\000\109\000\255\255\109\000\109\000\
    \109\000\255\255\255\255\255\255\107\000\255\255\107\000\255\255\
    \255\255\108\000\255\255\109\000\071\000\109\000\109\000\109\000\
    \109\000\109\000\255\255\255\255\255\255\115\000\255\255\255\255\
    \115\000\115\000\115\000\255\255\255\255\255\255\115\000\115\000\
    \255\255\115\000\115\000\115\000\255\255\255\255\255\255\108\000\
    \255\255\108\000\255\255\255\255\255\255\255\255\115\000\109\000\
    \115\000\115\000\115\000\115\000\115\000\255\255\255\255\255\255\
    \125\000\255\255\255\255\125\000\125\000\125\000\255\255\255\255\
    \255\255\125\000\125\000\255\255\125\000\125\000\125\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\109\000\255\255\109\000\
    \255\255\125\000\115\000\125\000\125\000\125\000\125\000\125\000\
    \255\255\255\255\255\255\128\000\255\255\255\255\128\000\128\000\
    \128\000\255\255\255\255\255\255\128\000\128\000\255\255\128\000\
    \128\000\128\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \115\000\255\255\115\000\255\255\128\000\125\000\128\000\128\000\
    \128\000\128\000\128\000\255\255\255\255\255\255\129\000\255\255\
    \255\255\129\000\129\000\129\000\255\255\255\255\255\255\129\000\
    \129\000\255\255\129\000\129\000\129\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\125\000\255\255\125\000\255\255\129\000\
    \128\000\129\000\129\000\129\000\129\000\129\000\255\255\255\255\
    \255\255\130\000\255\255\255\255\130\000\130\000\130\000\255\255\
    \255\255\255\255\130\000\130\000\255\255\130\000\130\000\130\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\128\000\255\255\
    \128\000\255\255\130\000\129\000\130\000\130\000\130\000\130\000\
    \130\000\255\255\255\255\255\255\131\000\255\255\255\255\131\000\
    \131\000\131\000\255\255\255\255\255\255\131\000\131\000\255\255\
    \131\000\131\000\131\000\255\255\255\255\146\000\255\255\146\000\
    \255\255\129\000\255\255\129\000\146\000\131\000\130\000\131\000\
    \131\000\131\000\131\000\131\000\255\255\146\000\146\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\130\000\255\255\130\000\255\255\
    \255\255\131\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \169\000\255\255\255\255\169\000\255\255\255\255\255\255\255\255\
    \255\255\146\000\255\255\255\255\255\255\255\255\255\255\146\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\169\000\131\000\
    \169\000\131\000\255\255\146\000\255\255\169\000\255\255\146\000\
    \255\255\146\000\255\255\255\255\255\255\146\000\169\000\169\000\
    \169\000\169\000\169\000\169\000\169\000\169\000\169\000\169\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\169\000\255\255\255\255\255\255\255\255\255\255\
    \169\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\169\000\255\255\255\255\255\255\
    \169\000\255\255\169\000\255\255\255\255\255\255\169\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\169\000";
  Lexing.lex_base_code = 
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \010\000\036\000\012\000\000\000\000\000\000\000\002\000\000\000\
    \027\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \002\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000";
  Lexing.lex_backtrk_code = 
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\039\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000";
  Lexing.lex_default_code = 
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\019\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000";
  Lexing.lex_trans_code = 
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\001\000\000\000\036\000\036\000\000\000\036\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \001\000\000\000\000\000\001\000\022\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\007\000\001\000\000\000\000\000\
    \004\000\004\000\004\000\004\000\004\000\004\000\004\000\004\000\
    \004\000\004\000\004\000\004\000\004\000\004\000\004\000\004\000\
    \004\000\004\000\004\000\004\000\001\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\004\000\004\000\004\000\004\000\
    \004\000\004\000\004\000\004\000\004\000\004\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000";
  Lexing.lex_check_code = 
   "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\024\000\101\000\169\000\176\000\101\000\177\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \024\000\255\255\101\000\000\000\102\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\096\000\097\000\255\255\255\255\
    \024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\096\000\096\000\096\000\096\000\096\000\096\000\
    \096\000\096\000\096\000\096\000\097\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\097\000\097\000\097\000\097\000\
    \097\000\097\000\097\000\097\000\097\000\097\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \101\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255";
  Lexing.lex_code = 
   "\255\004\255\255\005\255\255\007\255\006\255\255\003\255\000\004\
    \001\005\255\007\255\255\006\255\007\255\255\000\004\001\005\003\
    \006\002\007\255\001\255\255\000\001\255";
}

let rec token lexbuf =
  lexbuf.Lexing.lex_mem <- Array.make 8 (-1) ;   __ocaml_lex_token_rec lexbuf 0
and __ocaml_lex_token_rec lexbuf __ocaml_lex_state =
  match Lexing.new_engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 767 "parsing/lexer.mll"
                 (
      if not !escaped_newlines then
        raise (Error(Illegal_character (Lexing.lexeme_char lexbuf 0),
                     Location.curr lexbuf));
      update_loc lexbuf None 1 false 0;
      token lexbuf )
# 1977 "parsing/lexer.ml"

  | 1 ->
# 774 "parsing/lexer.mll"
      ( update_loc lexbuf None 1 false 0;
        EOL )
# 1983 "parsing/lexer.ml"

  | 2 ->
# 777 "parsing/lexer.mll"
      ( token lexbuf )
# 1988 "parsing/lexer.ml"

  | 3 ->
# 779 "parsing/lexer.mll"
      ( UNDERSCORE )
# 1993 "parsing/lexer.ml"

  | 4 ->
# 781 "parsing/lexer.mll"
      ( TILDE )
# 1998 "parsing/lexer.ml"

  | 5 ->
# 783 "parsing/lexer.mll"
      ( LABEL (get_label_name lexbuf) )
# 2003 "parsing/lexer.ml"

  | 6 ->
# 785 "parsing/lexer.mll"
      ( warn_latin1 lexbuf; LABEL (get_label_name lexbuf) )
# 2008 "parsing/lexer.ml"

  | 7 ->
# 787 "parsing/lexer.mll"
      ( QUESTION )
# 2013 "parsing/lexer.ml"

  | 8 ->
# 789 "parsing/lexer.mll"
      ( OPTLABEL (get_label_name lexbuf) )
# 2018 "parsing/lexer.ml"

  | 9 ->
# 791 "parsing/lexer.mll"
      ( warn_latin1 lexbuf; OPTLABEL (get_label_name lexbuf) )
# 2023 "parsing/lexer.ml"

  | 10 ->
# 793 "parsing/lexer.mll"
      ( let s = Lexing.lexeme lexbuf in
        try Hashtbl.find keyword_table s
        with Not_found -> LIDENT s )
# 2030 "parsing/lexer.ml"

  | 11 ->
# 797 "parsing/lexer.mll"
      ( warn_latin1 lexbuf; LIDENT (Lexing.lexeme lexbuf) )
# 2035 "parsing/lexer.ml"

  | 12 ->
# 799 "parsing/lexer.mll"
      ( UIDENT(Lexing.lexeme lexbuf) )
# 2040 "parsing/lexer.ml"

  | 13 ->
# 801 "parsing/lexer.mll"
      ( warn_latin1 lexbuf; UIDENT(Lexing.lexeme lexbuf) )
# 2045 "parsing/lexer.ml"

  | 14 ->
# 803 "parsing/lexer.mll"
      ( try
          INT (cvt_int_literal (Lexing.lexeme lexbuf))
        with Failure _ ->
          raise (Error(Literal_overflow "int", Location.curr lexbuf))
      )
# 2054 "parsing/lexer.ml"

  | 15 ->
# 809 "parsing/lexer.mll"
      ( FLOAT (remove_underscores(Lexing.lexeme lexbuf)) )
# 2059 "parsing/lexer.ml"

  | 16 ->
# 811 "parsing/lexer.mll"
      ( try
          INT32 (cvt_int32_literal (Lexing.lexeme lexbuf))
        with Failure _ ->
          raise (Error(Literal_overflow "int32", Location.curr lexbuf)) )
# 2067 "parsing/lexer.ml"

  | 17 ->
# 816 "parsing/lexer.mll"
      ( try
          INT64 (cvt_int64_literal (Lexing.lexeme lexbuf))
        with Failure _ ->
          raise (Error(Literal_overflow "int64", Location.curr lexbuf)) )
# 2075 "parsing/lexer.ml"

  | 18 ->
# 821 "parsing/lexer.mll"
      ( try
          NATIVEINT (cvt_nativeint_literal (Lexing.lexeme lexbuf))
        with Failure _ ->
          raise (Error(Literal_overflow "nativeint", Location.curr lexbuf)) )
# 2083 "parsing/lexer.ml"

  | 19 ->
# 826 "parsing/lexer.mll"
      ( reset_string_buffer();
        is_in_string := true;
        let string_start = lexbuf.lex_start_p in
        string_start_loc := Location.curr lexbuf;
        string lexbuf;
        is_in_string := false;
        lexbuf.lex_start_p <- string_start;
        STRING (get_stored_string(), None) )
# 2095 "parsing/lexer.ml"

  | 20 ->
# 835 "parsing/lexer.mll"
      ( reset_string_buffer();
        let delim = Lexing.lexeme lexbuf in
        let delim = String.sub delim 1 (String.length delim - 2) in
        is_in_string := true;
        let string_start = lexbuf.lex_start_p in
        string_start_loc := Location.curr lexbuf;
        quoted_string delim lexbuf;
        is_in_string := false;
        lexbuf.lex_start_p <- string_start;
        STRING (get_stored_string(), Some delim) )
# 2109 "parsing/lexer.ml"

  | 21 ->
# 846 "parsing/lexer.mll"
      ( update_loc lexbuf None 1 false 1;
        CHAR (Lexing.lexeme_char lexbuf 1) )
# 2115 "parsing/lexer.ml"

  | 22 ->
# 849 "parsing/lexer.mll"
      ( CHAR(Lexing.lexeme_char lexbuf 1) )
# 2120 "parsing/lexer.ml"

  | 23 ->
# 851 "parsing/lexer.mll"
      ( CHAR(char_for_backslash (Lexing.lexeme_char lexbuf 2)) )
# 2125 "parsing/lexer.ml"

  | 24 ->
# 853 "parsing/lexer.mll"
      ( CHAR(char_for_decimal_code lexbuf 2) )
# 2130 "parsing/lexer.ml"

  | 25 ->
# 855 "parsing/lexer.mll"
      ( CHAR(char_for_hexadecimal_code lexbuf 3) )
# 2135 "parsing/lexer.ml"

  | 26 ->
# 857 "parsing/lexer.mll"
      ( let l = Lexing.lexeme lexbuf in
        let esc = String.sub l 1 (String.length l - 1) in
        raise (Error(Illegal_escape esc, Location.curr lexbuf))
      )
# 2143 "parsing/lexer.ml"

  | 27 ->
# 862 "parsing/lexer.mll"
      ( let s, loc = with_comment_buffer comment lexbuf in
        COMMENT (s, loc) )
# 2149 "parsing/lexer.ml"

  | 28 ->
# 865 "parsing/lexer.mll"
      ( let s, loc = with_comment_buffer comment lexbuf in

        DOCSTRING (Docstrings.docstring s loc) 

)
# 2160 "parsing/lexer.ml"

  | 29 ->
let
# 872 "parsing/lexer.mll"
                    stars
# 2166 "parsing/lexer.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in
# 873 "parsing/lexer.mll"
      ( let s, loc =
          with_comment_buffer
            (fun lexbuf ->
               store_string ("*" ^ stars);
               comment lexbuf)
            lexbuf
        in
        COMMENT (s, loc) )
# 2177 "parsing/lexer.ml"

  | 30 ->
# 882 "parsing/lexer.mll"
      ( if !print_warnings then
          Location.prerr_warning (Location.curr lexbuf) Warnings.Comment_start;
        let s, loc = with_comment_buffer comment lexbuf in
        COMMENT (s, loc) )
# 2185 "parsing/lexer.ml"

  | 31 ->
let
# 886 "parsing/lexer.mll"
                   stars
# 2191 "parsing/lexer.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos (lexbuf.Lexing.lex_curr_pos + -2) in
# 887 "parsing/lexer.mll"
      ( COMMENT (stars, Location.curr lexbuf) )
# 2195 "parsing/lexer.ml"

  | 32 ->
# 889 "parsing/lexer.mll"
      ( let loc = Location.curr lexbuf in
        Location.prerr_warning loc Warnings.Comment_not_end;
        lexbuf.Lexing.lex_curr_pos <- lexbuf.Lexing.lex_curr_pos - 1;
        let curpos = lexbuf.lex_curr_p in
        lexbuf.lex_curr_p <- { curpos with pos_cnum = curpos.pos_cnum - 1 };
        STAR
      )
# 2206 "parsing/lexer.ml"

  | 33 ->
let
# 896 "parsing/lexer.mll"
                                   num
# 2212 "parsing/lexer.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_mem.(0) lexbuf.Lexing.lex_mem.(1)
and
# 897 "parsing/lexer.mll"
                                           name
# 2217 "parsing/lexer.ml"
= Lexing.sub_lexeme_opt lexbuf lexbuf.Lexing.lex_mem.(3) lexbuf.Lexing.lex_mem.(2) in
# 899 "parsing/lexer.mll"
      ( update_loc lexbuf name (int_of_string num) true 0;
        token lexbuf
      )
# 2223 "parsing/lexer.ml"

  | 34 ->
# 902 "parsing/lexer.mll"
         ( SHARP )
# 2228 "parsing/lexer.ml"

  | 35 ->
# 903 "parsing/lexer.mll"
         ( AMPERSAND )
# 2233 "parsing/lexer.ml"

  | 36 ->
# 904 "parsing/lexer.mll"
         ( AMPERAMPER )
# 2238 "parsing/lexer.ml"

  | 37 ->
# 905 "parsing/lexer.mll"
         ( BACKQUOTE )
# 2243 "parsing/lexer.ml"

  | 38 ->
# 906 "parsing/lexer.mll"
         ( QUOTE )
# 2248 "parsing/lexer.ml"

  | 39 ->
# 907 "parsing/lexer.mll"
         ( LPAREN )
# 2253 "parsing/lexer.ml"

  | 40 ->
# 908 "parsing/lexer.mll"
         ( RPAREN )
# 2258 "parsing/lexer.ml"

  | 41 ->
# 909 "parsing/lexer.mll"
         ( STAR )
# 2263 "parsing/lexer.ml"

  | 42 ->
# 910 "parsing/lexer.mll"
         ( COMMA )
# 2268 "parsing/lexer.ml"

  | 43 ->
# 911 "parsing/lexer.mll"
         ( MINUSGREATER )
# 2273 "parsing/lexer.ml"

  | 44 ->
# 912 "parsing/lexer.mll"
         ( DOT )
# 2278 "parsing/lexer.ml"

  | 45 ->
# 913 "parsing/lexer.mll"
         ( DOTDOT )
# 2283 "parsing/lexer.ml"

  | 46 ->
# 914 "parsing/lexer.mll"
         ( COLON )
# 2288 "parsing/lexer.ml"

  | 47 ->
# 915 "parsing/lexer.mll"
         ( COLONCOLON )
# 2293 "parsing/lexer.ml"

  | 48 ->
# 916 "parsing/lexer.mll"
         ( COLONEQUAL )
# 2298 "parsing/lexer.ml"

  | 49 ->
# 917 "parsing/lexer.mll"
         ( COLONGREATER )
# 2303 "parsing/lexer.ml"

  | 50 ->
# 918 "parsing/lexer.mll"
         ( SEMI )
# 2308 "parsing/lexer.ml"

  | 51 ->
# 919 "parsing/lexer.mll"
         ( SEMISEMI )
# 2313 "parsing/lexer.ml"

  | 52 ->
# 920 "parsing/lexer.mll"
         ( LESS )
# 2318 "parsing/lexer.ml"

  | 53 ->
# 921 "parsing/lexer.mll"
         ( LESSMINUS )
# 2323 "parsing/lexer.ml"

  | 54 ->
# 922 "parsing/lexer.mll"
         ( EQUAL )
# 2328 "parsing/lexer.ml"

  | 55 ->
# 923 "parsing/lexer.mll"
         ( LBRACKET )
# 2333 "parsing/lexer.ml"

  | 56 ->
# 924 "parsing/lexer.mll"
         ( LBRACKETBAR )
# 2338 "parsing/lexer.ml"

  | 57 ->
# 925 "parsing/lexer.mll"
         ( LBRACKETLESS )
# 2343 "parsing/lexer.ml"

  | 58 ->
# 926 "parsing/lexer.mll"
         ( LBRACKETGREATER )
# 2348 "parsing/lexer.ml"

  | 59 ->
# 927 "parsing/lexer.mll"
         ( RBRACKET )
# 2353 "parsing/lexer.ml"

  | 60 ->
# 928 "parsing/lexer.mll"
         ( LBRACE )
# 2358 "parsing/lexer.ml"

  | 61 ->
# 929 "parsing/lexer.mll"
         ( LBRACELESS )
# 2363 "parsing/lexer.ml"

  | 62 ->
# 930 "parsing/lexer.mll"
         ( BAR )
# 2368 "parsing/lexer.ml"

  | 63 ->
# 931 "parsing/lexer.mll"
         ( BARBAR )
# 2373 "parsing/lexer.ml"

  | 64 ->
# 932 "parsing/lexer.mll"
         ( BARRBRACKET )
# 2378 "parsing/lexer.ml"

  | 65 ->
# 933 "parsing/lexer.mll"
         ( GREATER )
# 2383 "parsing/lexer.ml"

  | 66 ->
# 934 "parsing/lexer.mll"
         ( GREATERRBRACKET )
# 2388 "parsing/lexer.ml"

  | 67 ->
# 935 "parsing/lexer.mll"
         ( RBRACE )
# 2393 "parsing/lexer.ml"

  | 68 ->
# 936 "parsing/lexer.mll"
         ( GREATERRBRACE )
# 2398 "parsing/lexer.ml"

  | 69 ->
# 937 "parsing/lexer.mll"
         ( LBRACKETAT )
# 2403 "parsing/lexer.ml"

  | 70 ->
# 938 "parsing/lexer.mll"
         ( LBRACKETPERCENT )
# 2408 "parsing/lexer.ml"

  | 71 ->
# 939 "parsing/lexer.mll"
          ( LBRACKETPERCENTPERCENT )
# 2413 "parsing/lexer.ml"

  | 72 ->
# 940 "parsing/lexer.mll"
          ( LBRACKETATAT )
# 2418 "parsing/lexer.ml"

  | 73 ->
# 941 "parsing/lexer.mll"
           ( LBRACKETATATAT )
# 2423 "parsing/lexer.ml"

  | 74 ->
# 942 "parsing/lexer.mll"
         ( BANG )
# 2428 "parsing/lexer.ml"

  | 75 ->
# 943 "parsing/lexer.mll"
         ( INFIXOP0 "!=" )
# 2433 "parsing/lexer.ml"

  | 76 ->
# 944 "parsing/lexer.mll"
         ( PLUS )
# 2438 "parsing/lexer.ml"

  | 77 ->
# 945 "parsing/lexer.mll"
         ( PLUSDOT )
# 2443 "parsing/lexer.ml"

  | 78 ->
# 946 "parsing/lexer.mll"
         ( PLUSEQ )
# 2448 "parsing/lexer.ml"

  | 79 ->
# 947 "parsing/lexer.mll"
         ( MINUS )
# 2453 "parsing/lexer.ml"

  | 80 ->
# 948 "parsing/lexer.mll"
         ( MINUSDOT )
# 2458 "parsing/lexer.ml"

  | 81 ->
# 951 "parsing/lexer.mll"
            ( PREFIXOP(Lexing.lexeme lexbuf) )
# 2463 "parsing/lexer.ml"

  | 82 ->
# 953 "parsing/lexer.mll"
            ( PREFIXOP(Lexing.lexeme lexbuf) )
# 2468 "parsing/lexer.ml"

  | 83 ->
# 955 "parsing/lexer.mll"
            ( INFIXOP0(Lexing.lexeme lexbuf) )
# 2473 "parsing/lexer.ml"

  | 84 ->
# 957 "parsing/lexer.mll"
            ( INFIXOP1(Lexing.lexeme lexbuf) )
# 2478 "parsing/lexer.ml"

  | 85 ->
# 959 "parsing/lexer.mll"
            ( INFIXOP2(Lexing.lexeme lexbuf) )
# 2483 "parsing/lexer.ml"

  | 86 ->
# 961 "parsing/lexer.mll"
            ( INFIXOP4(Lexing.lexeme lexbuf) )
# 2488 "parsing/lexer.ml"

  | 87 ->
# 962 "parsing/lexer.mll"
            ( PERCENT )
# 2493 "parsing/lexer.ml"

  | 88 ->
# 964 "parsing/lexer.mll"
            ( INFIXOP3(Lexing.lexeme lexbuf) )
# 2498 "parsing/lexer.ml"

  | 89 ->
# 966 "parsing/lexer.mll"
            ( SHARPOP(Lexing.lexeme lexbuf) )
# 2503 "parsing/lexer.ml"

  | 90 ->
# 967 "parsing/lexer.mll"
        (
      if !if_then_else <> Dir_out then
        if !if_then_else = Dir_if_true then
          raise (Error (Unterminated_if, Location.curr lexbuf))
        else raise (Error(Unterminated_else, Location.curr lexbuf))
      else 
        EOF
        
    )
# 2516 "parsing/lexer.ml"

  | 91 ->
# 977 "parsing/lexer.mll"
      ( raise (Error(Illegal_character (Lexing.lexeme_char lexbuf 0),
                     Location.curr lexbuf))
      )
# 2523 "parsing/lexer.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; 
      __ocaml_lex_token_rec lexbuf __ocaml_lex_state

and comment lexbuf =
    __ocaml_lex_comment_rec lexbuf 132
and __ocaml_lex_comment_rec lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 983 "parsing/lexer.mll"
      ( comment_start_loc := (Location.curr lexbuf) :: !comment_start_loc;
        store_lexeme lexbuf;
        comment lexbuf;
      )
# 2538 "parsing/lexer.ml"

  | 1 ->
# 988 "parsing/lexer.mll"
      ( match !comment_start_loc with
        | [] -> assert false
        | [_] -> comment_start_loc := []; Location.curr lexbuf
        | _ :: l -> comment_start_loc := l;
                  store_lexeme lexbuf;
                  comment lexbuf;
       )
# 2549 "parsing/lexer.ml"

  | 2 ->
# 996 "parsing/lexer.mll"
      (
        string_start_loc := Location.curr lexbuf;
        store_string_char '"';
        is_in_string := true;
        begin try string lexbuf
        with Error (Unterminated_string, str_start) ->
          match !comment_start_loc with
          | [] -> assert false
          | loc :: _ ->
            let start = List.hd (List.rev !comment_start_loc) in
            comment_start_loc := [];
            raise (Error (Unterminated_string_in_comment (start, str_start),
                          loc))
        end;
        is_in_string := false;
        store_string_char '"';
        comment lexbuf )
# 2570 "parsing/lexer.ml"

  | 3 ->
# 1014 "parsing/lexer.mll"
      (
        let delim = Lexing.lexeme lexbuf in
        let delim = String.sub delim 1 (String.length delim - 2) in
        string_start_loc := Location.curr lexbuf;
        store_lexeme lexbuf;
        is_in_string := true;
        begin try quoted_string delim lexbuf
        with Error (Unterminated_string, str_start) ->
          match !comment_start_loc with
          | [] -> assert false
          | loc :: _ ->
            let start = List.hd (List.rev !comment_start_loc) in
            comment_start_loc := [];
            raise (Error (Unterminated_string_in_comment (start, str_start),
                          loc))
        end;
        is_in_string := false;
        store_string_char '|';
        store_string delim;
        store_string_char '}';
        comment lexbuf )
# 2595 "parsing/lexer.ml"

  | 4 ->
# 1037 "parsing/lexer.mll"
      ( store_lexeme lexbuf; comment lexbuf )
# 2600 "parsing/lexer.ml"

  | 5 ->
# 1039 "parsing/lexer.mll"
      ( update_loc lexbuf None 1 false 1;
        store_lexeme lexbuf;
        comment lexbuf
      )
# 2608 "parsing/lexer.ml"

  | 6 ->
# 1044 "parsing/lexer.mll"
      ( store_lexeme lexbuf; comment lexbuf )
# 2613 "parsing/lexer.ml"

  | 7 ->
# 1046 "parsing/lexer.mll"
      ( store_lexeme lexbuf; comment lexbuf )
# 2618 "parsing/lexer.ml"

  | 8 ->
# 1048 "parsing/lexer.mll"
      ( store_lexeme lexbuf; comment lexbuf )
# 2623 "parsing/lexer.ml"

  | 9 ->
# 1050 "parsing/lexer.mll"
      ( store_lexeme lexbuf; comment lexbuf )
# 2628 "parsing/lexer.ml"

  | 10 ->
# 1052 "parsing/lexer.mll"
      ( match !comment_start_loc with
        | [] -> assert false
        | loc :: _ ->
          let start = List.hd (List.rev !comment_start_loc) in
          comment_start_loc := [];
          raise (Error (Unterminated_comment start, loc))
      )
# 2639 "parsing/lexer.ml"

  | 11 ->
# 1060 "parsing/lexer.mll"
      ( update_loc lexbuf None 1 false 0;
        store_lexeme lexbuf;
        comment lexbuf
      )
# 2647 "parsing/lexer.ml"

  | 12 ->
# 1065 "parsing/lexer.mll"
      ( store_lexeme lexbuf; comment lexbuf )
# 2652 "parsing/lexer.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; 
      __ocaml_lex_comment_rec lexbuf __ocaml_lex_state

and string lexbuf =
  lexbuf.Lexing.lex_mem <- Array.make 2 (-1) ;   __ocaml_lex_string_rec lexbuf 164
and __ocaml_lex_string_rec lexbuf __ocaml_lex_state =
  match Lexing.new_engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 1069 "parsing/lexer.mll"
      ( () )
# 2664 "parsing/lexer.ml"

  | 1 ->
let
# 1070 "parsing/lexer.mll"
                                  space
# 2670 "parsing/lexer.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_mem.(0) lexbuf.Lexing.lex_curr_pos in
# 1071 "parsing/lexer.mll"
      ( update_loc lexbuf None 1 false (String.length space);
        string lexbuf
      )
# 2676 "parsing/lexer.ml"

  | 2 ->
# 1075 "parsing/lexer.mll"
      ( store_string_char(char_for_backslash(Lexing.lexeme_char lexbuf 1));
        string lexbuf )
# 2682 "parsing/lexer.ml"

  | 3 ->
# 1078 "parsing/lexer.mll"
      ( store_string_char(char_for_decimal_code lexbuf 1);
         string lexbuf )
# 2688 "parsing/lexer.ml"

  | 4 ->
# 1081 "parsing/lexer.mll"
      ( store_string_char(char_for_hexadecimal_code lexbuf 2);
         string lexbuf )
# 2694 "parsing/lexer.ml"

  | 5 ->
# 1084 "parsing/lexer.mll"
      ( if in_comment ()
        then string lexbuf
        else begin
(*  Should be an error, but we are very lax.
          raise (Error (Illegal_escape (Lexing.lexeme lexbuf),
                        Location.curr lexbuf))
*)
          let loc = Location.curr lexbuf in
          Location.prerr_warning loc Warnings.Illegal_backslash;
          store_string_char (Lexing.lexeme_char lexbuf 0);
          store_string_char (Lexing.lexeme_char lexbuf 1);
          string lexbuf
        end
      )
# 2712 "parsing/lexer.ml"

  | 6 ->
# 1099 "parsing/lexer.mll"
      ( if not (in_comment ()) then
          Location.prerr_warning (Location.curr lexbuf) Warnings.Eol_in_string;
        update_loc lexbuf None 1 false 0;
        store_lexeme lexbuf;
        string lexbuf
      )
# 2722 "parsing/lexer.ml"

  | 7 ->
# 1106 "parsing/lexer.mll"
      ( is_in_string := false;
        raise (Error (Unterminated_string, !string_start_loc)) )
# 2728 "parsing/lexer.ml"

  | 8 ->
# 1109 "parsing/lexer.mll"
      ( store_string_char(Lexing.lexeme_char lexbuf 0);
        string lexbuf )
# 2734 "parsing/lexer.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; 
      __ocaml_lex_string_rec lexbuf __ocaml_lex_state

and quoted_string delim lexbuf =
    __ocaml_lex_quoted_string_rec delim lexbuf 183
and __ocaml_lex_quoted_string_rec delim lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 1114 "parsing/lexer.mll"
      ( update_loc lexbuf None 1 false 0;
        store_lexeme lexbuf;
        quoted_string delim lexbuf
      )
# 2749 "parsing/lexer.ml"

  | 1 ->
# 1119 "parsing/lexer.mll"
      ( is_in_string := false;
        raise (Error (Unterminated_string, !string_start_loc)) )
# 2755 "parsing/lexer.ml"

  | 2 ->
# 1122 "parsing/lexer.mll"
      (
        let edelim = Lexing.lexeme lexbuf in
        let edelim = String.sub edelim 1 (String.length edelim - 2) in
        if delim = edelim then ()
        else (store_lexeme lexbuf; quoted_string delim lexbuf)
      )
# 2765 "parsing/lexer.ml"

  | 3 ->
# 1129 "parsing/lexer.mll"
      ( store_string_char(Lexing.lexeme_char lexbuf 0);
        quoted_string delim lexbuf )
# 2771 "parsing/lexer.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; 
      __ocaml_lex_quoted_string_rec delim lexbuf __ocaml_lex_state

and skip_sharp_bang lexbuf =
    __ocaml_lex_skip_sharp_bang_rec lexbuf 192
and __ocaml_lex_skip_sharp_bang_rec lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 1134 "parsing/lexer.mll"
       ( update_loc lexbuf None 3 false 0 )
# 2783 "parsing/lexer.ml"

  | 1 ->
# 1136 "parsing/lexer.mll"
       ( update_loc lexbuf None 1 false 0 )
# 2788 "parsing/lexer.ml"

  | 2 ->
# 1137 "parsing/lexer.mll"
       ( () )
# 2793 "parsing/lexer.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; 
      __ocaml_lex_skip_sharp_bang_rec lexbuf __ocaml_lex_state

;;

# 1139 "parsing/lexer.mll"
 

  let at_bol lexbuf = 
    let pos = Lexing.lexeme_start_p lexbuf in 
    pos.pos_cnum = pos.pos_bol 

  let token_with_comments lexbuf =
    match !preprocessor with
    | None -> token lexbuf
    | Some (_init, preprocess) -> preprocess token lexbuf

  type newline_state =
    | NoLine (* There have been no blank lines yet. *)
    | NewLine
        (* There have been no blank lines, and the previous
           token was a newline. *)
    | BlankLine (* There have been blank lines. *)

  type doc_state =
    | Initial  (* There have been no docstrings yet *)

    | After of docstring list
        (* There have been docstrings, none of which were
           preceeded by a blank line *)
    | Before of docstring list * docstring list * docstring list
        (* There have been docstrings, some of which were
           preceeded by a blank line *)

  and docstring = Docstrings.docstring

  let interpret_directive lexbuf cont look_ahead = 
    let if_then_else = !if_then_else in
    begin match token_with_comments lexbuf, if_then_else with 
    |  IF, Dir_out  ->
        let rec skip_from_if_false () = 
          let token = token_with_comments lexbuf in
          if token = EOF then 
            raise (Error (Unterminated_if, Location.curr lexbuf)) else
          if token = SHARP && at_bol lexbuf then 
            begin 
              let token = token_with_comments lexbuf in
              match token with
              | END -> 
                  begin
                    update_if_then_else Dir_out;
                    cont lexbuf
                  end
              | ELSE -> 
                  begin
                    update_if_then_else Dir_if_false;
                    cont lexbuf
                  end
              | IF ->
                  raise (Error (Unexpected_directive, Location.curr lexbuf))
              | _ -> 
                  if is_elif token &&
                     directive_parse token_with_comments lexbuf then
                    begin
                      update_if_then_else Dir_if_true;
                      cont lexbuf
                    end
                  else skip_from_if_false ()                               
            end
          else skip_from_if_false () in 
        if directive_parse token_with_comments lexbuf then
          begin 
            update_if_then_else Dir_if_true (* Next state: ELSE *);
            cont lexbuf
          end
        else
          skip_from_if_false ()
    | IF,  (Dir_if_false | Dir_if_true)->
        raise (Error(Unexpected_directive, Location.curr lexbuf))
    | LIDENT "elif", (Dir_if_false | Dir_out)
      -> (* when the predicate is false, it will continue eating `elif` *)
        raise (Error(Unexpected_directive, Location.curr lexbuf))
    | (LIDENT "elif" | ELSE as token), Dir_if_true ->           
        (* looking for #end, however, it can not see #if anymore *)
        let rec skip_from_if_true else_seen = 
          let token = token_with_comments lexbuf in
          if token = EOF then 
            raise (Error (Unterminated_else, Location.curr lexbuf)) else
          if token = SHARP && at_bol lexbuf then 
            begin 
              let token = token_with_comments lexbuf in 
              match token with  
              | END -> 
                  begin
                    update_if_then_else Dir_out;
                    cont lexbuf
                  end  
              | IF ->  
                  raise (Error (Unexpected_directive, Location.curr lexbuf)) 
              | ELSE ->
                  if else_seen then 
                    raise (Error (Unexpected_directive, Location.curr lexbuf))
                  else 
                    skip_from_if_true true
              | _ ->
                  if else_seen && is_elif token then  
                    raise (Error (Unexpected_directive, Location.curr lexbuf))
                  else 
                    skip_from_if_true else_seen
            end
          else skip_from_if_true else_seen in 
        skip_from_if_true (token = ELSE)
    | ELSE, Dir_if_false 
    | ELSE, Dir_out -> 
        raise (Error(Unexpected_directive, Location.curr lexbuf))
    | END, (Dir_if_false | Dir_if_true ) -> 
        update_if_then_else  Dir_out;
        cont lexbuf
    | END,  Dir_out  -> 
        raise (Error(Unexpected_directive, Location.curr lexbuf))
    | token, (Dir_if_true | Dir_if_false | Dir_out) ->
        look_ahead token 
    end

  let token lexbuf =
    let post_pos = lexeme_end_p lexbuf in

    let attach lines docs pre_pos =
      let open Docstrings in
        match docs, lines with
        | Initial, _ -> ()
        | After a, (NoLine | NewLine) ->
            set_post_docstrings post_pos (List.rev a);
            set_pre_docstrings pre_pos a;
        | After a, BlankLine ->
            set_post_docstrings post_pos (List.rev a);
            set_pre_extra_docstrings pre_pos (List.rev a)
        | Before(a, f, b), (NoLine | NewLine) ->
            set_post_docstrings post_pos (List.rev a);
            set_post_extra_docstrings post_pos
              (List.rev_append f (List.rev b));
            set_floating_docstrings pre_pos (List.rev f);
            set_pre_extra_docstrings pre_pos (List.rev a);
            set_pre_docstrings pre_pos b
        | Before(a, f, b), BlankLine ->
            set_post_docstrings post_pos (List.rev a);
            set_post_extra_docstrings post_pos
              (List.rev_append f (List.rev b));
            set_floating_docstrings pre_pos
              (List.rev_append f (List.rev b));
            set_pre_extra_docstrings pre_pos (List.rev a)
    in

    let rec loop lines docs lexbuf : Parser.token =
      match token_with_comments lexbuf with
      | COMMENT (s, loc) ->
          add_comment (s, loc);
          let lines' =
            match lines with
            | NoLine -> NoLine
            | NewLine -> NoLine
            | BlankLine -> BlankLine
          in
          loop lines' docs lexbuf
      | EOL ->
          let lines' =
            match lines with
            | NoLine -> NewLine
            | NewLine -> BlankLine
            | BlankLine -> BlankLine
          in
          loop lines' docs lexbuf
      | SHARP when at_bol lexbuf -> 
          interpret_directive lexbuf 
            (fun lexbuf -> loop lines docs lexbuf)
            (fun token -> sharp_look_ahead := Some token; SHARP)

      | DOCSTRING doc ->
          add_docstring_comment doc;
          let docs' =
            match docs, lines with
            | Initial, (NoLine | NewLine) -> After [doc]
            | Initial, BlankLine -> Before([], [], [doc])
            | After a, (NoLine | NewLine) -> After (doc :: a)
            | After a, BlankLine -> Before (a, [], [doc])
            | Before(a, f, b), (NoLine | NewLine) -> Before(a, f, doc :: b)
            | Before(a, f, b), BlankLine -> Before(a, b @ f, [doc])
          in
          loop NoLine docs' lexbuf

      | tok ->

          attach lines docs (lexeme_start_p lexbuf);

          tok

          
    in
      match !sharp_look_ahead with
      | None -> 
           loop NoLine Initial lexbuf
      | Some token -> 
           sharp_look_ahead := None ;
           token

  let init () =
    sharp_look_ahead := None;
    update_if_then_else  Dir_out;
    is_in_string := false;
    comment_start_loc := [];
    comment_list := [];
    match !preprocessor with
    | None -> ()
    | Some (init, _preprocess) -> init ()

  let rec filter_directive pos   acc lexbuf : (int * int ) list =
    match token_with_comments lexbuf with
    | SHARP when at_bol lexbuf ->
        (* ^[start_pos]#if ... #then^[end_pos] *)
        let start_pos = Lexing.lexeme_start lexbuf in 
        interpret_directive lexbuf 
          (fun lexbuf -> 
             filter_directive 
               (Lexing.lexeme_end lexbuf)
               ((pos, start_pos) :: acc)
               lexbuf
          
          )
          (fun _token -> filter_directive pos acc lexbuf  )
    | EOF -> (pos, Lexing.lexeme_end lexbuf) :: acc
    | _ -> filter_directive pos  acc lexbuf

  let filter_directive_from_lexbuf lexbuf = 
    List.rev (filter_directive 0 [] lexbuf )

  let set_preprocessor init preprocess =
    escaped_newlines := true;
    preprocessor := Some (init, preprocess)


# 3035 "parsing/lexer.ml"

end
module Bs_conditional_initial : sig 
#1 "bs_conditional_initial.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

(** This function set up built in compile time variables used in 
    conditional compilation so that 
    {[
        #if  BS then 
        #elif .. then 
        #end
    ]}
    Is understood, also make sure the playground do the same initialization. 
*)
val setup_env : unit -> unit

end = struct
#1 "bs_conditional_initial.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


let setup_env () = 
  Lexer.replace_directive_bool "BS" true;
  Lexer.replace_directive_string "BS_VERSION"  Bs_version.version

end
module Compenv : sig 
#1 "compenv.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*      Fabrice Le Fessant, EPI Gallium, INRIA Paris-Rocquencourt      *)
(*                                                                     *)
(*  Copyright 2013 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

val module_of_filename : Format.formatter -> string -> string -> string

val output_prefix : string -> string
val extract_output : string option -> string
val default_output : string option -> string

val print_version_and_library : string -> 'a
val print_version_string : unit -> 'a
val print_standard_library : unit -> 'a
val fatal : string -> 'a

val first_ccopts : string list ref
val first_ppx : string list ref
val first_include_dirs : string list ref
val last_include_dirs : string list ref
val implicit_modules : string list ref

(* return the list of objfiles, after OCAMLPARAM and List.rev *)
val get_objfiles : unit -> string list

type readenv_position =
  Before_args | Before_compile | Before_link

val readenv : Format.formatter -> readenv_position -> unit

(* [is_unit_name name] returns true only if [name] can be used as a
   correct module name *)
val is_unit_name : string -> bool
(* [check_unit_name ppf filename name] prints a warning in [filename]
   on [ppf] if [name] should not be used as a module name. *)
val check_unit_name : Format.formatter -> string -> string -> unit

end = struct
#1 "compenv.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*      Fabrice Le Fessant, EPI Gallium, INRIA Paris-Rocquencourt      *)
(*                                                                     *)
(*  Copyright 2013 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Clflags

let output_prefix name =
  let oname =
    match !output_name with
    | None -> name
    | Some n -> if !compile_only then (output_name := None; n) else name in
  Misc.chop_extension_if_any oname

let print_version_and_library compiler =
  Printf.printf "The OCaml %s, version " compiler;
  print_string Config.version; print_newline();
  print_string "Standard library directory: ";
  print_string Config.standard_library; print_newline();
  exit 0

let print_version_string () =
  print_string Config.version; print_newline(); exit 0

let print_standard_library () =
  print_string Config.standard_library; print_newline(); exit 0

let fatal err =
  prerr_endline err;
  exit 2

let extract_output = function
  | Some s -> s
  | None ->
      fatal "Please specify the name of the output file, using option -o"

let default_output = function
  | Some s -> s
  | None -> Config.default_executable_name

let implicit_modules = ref []
let first_include_dirs = ref []
let last_include_dirs = ref []
let first_ccopts = ref []
let last_ccopts = ref []
let first_ppx = ref []
let last_ppx = ref []
let first_objfiles = ref []
let last_objfiles = ref []

(* Check validity of module name *)
let is_unit_name name =
  try
    begin match name.[0] with
    | 'A'..'Z' -> ()
    | _ ->
       raise Exit;
    end;
    for i = 1 to String.length name - 1 do
      match name.[i] with
      | 'A'..'Z' | 'a'..'z' | '0'..'9' | '_' | '\'' -> ()
      | _ ->
         raise Exit;
    done;
    true
  with Exit -> false
;;

let check_unit_name ppf filename name =
  
  ()

(* Compute name of module from output file name *)
let module_of_filename ppf inputfile outputprefix =
  let basename = Filename.basename outputprefix in
  let name =
    try
      let pos = String.index basename '.' in
      String.sub basename 0 pos
    with Not_found -> basename
  in
  let name = String.capitalize name in
  check_unit_name ppf inputfile name;
  name
;;


type readenv_position =
  Before_args | Before_compile | Before_link

(* Syntax of OCAMLPARAM: (name=VALUE,)* _ (,name=VALUE)*
   where VALUE should not contain ',' *)
exception SyntaxError of string

let parse_args s =
  let args = Misc.split s ',' in
  let rec iter is_after args before after =
    match args with
      [] ->
      if not is_after then
        raise (SyntaxError "no '_' separator found")
      else
      (List.rev before, List.rev after)
    | "_" :: _ when is_after -> raise (SyntaxError "too many '_' separators")
    | "_" :: tail -> iter true tail before after
    | arg :: tail ->
      let binding = try
        Misc.cut_at arg '='
      with Not_found ->
        raise (SyntaxError ("missing '=' in " ^ arg))
      in
      if is_after then
        iter is_after tail before (binding :: after)
      else
        iter is_after tail (binding :: before) after
  in
  iter false args [] []

let setter ppf f name options s =
  try
    let bool = match s with
      | "0" -> false
      | "1" -> true
      | _ -> raise Not_found
    in
    List.iter (fun b -> b := f bool) options
  with Not_found ->
    Location.print_warning Location.none ppf
      (Warnings.Bad_env_variable ("OCAMLPARAM",
                                  Printf.sprintf "bad value for %s" name))

(* 'can-discard=' specifies which arguments can be discarded without warning
   because they are not understood by some versions of OCaml. *)
let can_discard = ref []

let read_OCAMLPARAM ppf position =
  try
    let s = Sys.getenv "OCAMLPARAM" in
    let (before, after) =
      try
        parse_args s
      with SyntaxError s ->
         Location.print_warning Location.none ppf
           (Warnings.Bad_env_variable ("OCAMLPARAM", s));
         [],[]
    in
    let set name options s =  setter ppf (fun b -> b) name options s in
    let clear name options s = setter ppf (fun b -> not b) name options s in
    List.iter (fun (name, v) ->
      match name with
      | "g" -> set "g" [ Clflags.debug ] v
      | "p" -> set "p" [ Clflags.gprofile ] v
      | "bin-annot" -> set "bin-annot" [ Clflags.binary_annotations ] v
      | "annot" -> set "annot" [ Clflags.annotations ] v
      | "absname" -> set "absname" [ Location.absname ] v
      | "compat-32" -> set "compat-32" [ bytecode_compatible_32 ] v
      | "noassert" -> set "noassert" [ noassert ] v
      | "noautolink" -> set "noautolink" [ no_auto_link ] v
      | "nostdlib" -> set "nostdlib" [ no_std_include ] v
      | "linkall" -> set "linkall" [ link_everything ] v
      | "nolabels" -> set "nolabels" [ classic ] v
      | "principal" -> set "principal"  [ principal ] v
      | "rectypes" -> set "rectypes" [ recursive_types ] v
      | "safe-string" -> clear "safe-string" [ unsafe_string ] v
      | "strict-sequence" -> set "strict-sequence" [ strict_sequence ] v
      | "strict-formats" -> set "strict-formats" [ strict_formats ] v
      | "thread" -> set "thread" [ use_threads ] v
      | "unsafe" -> set "unsafe" [ fast ] v
      | "verbose" -> set "verbose" [ verbose ] v
      | "nopervasives" -> set "nopervasives" [ nopervasives ] v
      | "slash" -> set "slash" [ force_slash ] v (* for ocamldep *)
      | "keep-docs" -> set "keep-docs" [ Clflags.keep_docs ] v
      | "keep-locs" -> set "keep-locs" [ Clflags.keep_locs ] v

      | "compact" -> clear "compact" [ optimize_for_speed ] v
      | "no-app-funct" -> clear "no-app-funct" [ applicative_functors ] v
      | "nodynlink" -> clear "nodynlink" [ dlcode ] v
      | "short-paths" -> clear "short-paths" [ real_paths ] v
      | "trans-mod" -> set "trans-mod" [ transparent_modules ] v

      | "pp" -> preprocessor := Some v
      | "runtime-variant" -> runtime_variant := v
      | "cc" -> c_compiler := Some v

      (* assembly sources *)
      |  "s" ->
        set "s" [ Clflags.keep_asm_file ; Clflags.keep_startup_file ] v
      |  "S" -> set "S" [ Clflags.keep_asm_file ] v
      |  "dstartup" -> set "dstartup" [ Clflags.keep_startup_file ] v

      (* warn-errors *)
      | "we" | "warn-error" -> Warnings.parse_options true v
      (* warnings *)
      |  "w"  ->               Warnings.parse_options false v
      (* warn-errors *)
      | "wwe" ->               Warnings.parse_options false v

      (* inlining *)
      | "inline" -> begin try
          inline_threshold := 8 * int_of_string v
        with _ ->
          Location.print_warning Location.none ppf
            (Warnings.Bad_env_variable ("OCAMLPARAM",
                                        "non-integer parameter for \"inline\""))
        end

      (* color output *)
      | "color" ->
          begin match parse_color_setting v with
          | None ->
            Location.print_warning Location.none ppf
              (Warnings.Bad_env_variable ("OCAMLPARAM",
               "bad value for \"color\", \
                (expected \"auto\", \"always\" or \"never\")"))
          | Some setting -> color := setting
          end

      | "intf-suffix" -> Config.interface_suffix := v

      | "I" -> begin
          match position with
          | Before_args -> first_include_dirs := v :: !first_include_dirs
          | Before_link | Before_compile ->
            last_include_dirs := v :: !last_include_dirs
        end

      | "cclib" ->
        begin
          match position with
          | Before_compile -> ()
          | Before_link | Before_args ->
            ccobjs := Misc.rev_split_words v @ !ccobjs
        end

      | "ccopts" ->
        begin
          match position with
          | Before_link | Before_compile ->
            last_ccopts := v :: !last_ccopts
          | Before_args ->
            first_ccopts := v :: !first_ccopts
        end

      | "ppx" ->
        begin
          match position with
          | Before_link | Before_compile ->
            last_ppx := v :: !last_ppx
          | Before_args ->
            first_ppx := v :: !first_ppx
        end


      | "cmo" | "cma" ->
        if not !native_code then
        begin
          match position with
          | Before_link | Before_compile ->
            last_objfiles := v ::! last_objfiles
          | Before_args ->
            first_objfiles := v :: !first_objfiles
        end

      | "cmx" | "cmxa" ->
        if !native_code then
        begin
          match position with
          | Before_link | Before_compile ->
            last_objfiles := v ::! last_objfiles
          | Before_args ->
            first_objfiles := v :: !first_objfiles
        end

      | "can-discard" ->
        can_discard := v ::!can_discard

      | _ ->
        if not (List.mem name !can_discard) then begin
          can_discard := name :: !can_discard;
          Printf.eprintf
            "Warning: discarding value of variable %S in OCAMLPARAM\n%!"
            name
        end
    ) (match position with
        Before_args -> before
      | Before_compile | Before_link -> after)
  with Not_found -> ()

let readenv ppf position =
  last_include_dirs := [];
  last_ccopts := [];
  last_ppx := [];
  last_objfiles := [];
  read_OCAMLPARAM ppf position;
  all_ccopts := !last_ccopts @ !first_ccopts;
  all_ppx := !last_ppx @ !first_ppx

let get_objfiles () =
  List.rev (!last_objfiles @ !objfiles @ !first_objfiles)

end
module Ext_bytes : sig 
#1 "ext_bytes.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)







(** Port the {!Bytes.escaped} from trunk to make it not locale sensitive *)

val escaped : bytes -> bytes

end = struct
#1 "ext_bytes.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








external char_code: char -> int = "%identity"
external char_chr: int -> char = "%identity"

let escaped s =
  let n = Pervasives.ref 0 in
  for i = 0 to Bytes.length s - 1 do
    n := !n +
      (match Bytes.unsafe_get s i with
       | '"' | '\\' | '\n' | '\t' | '\r' | '\b' -> 2
       | ' ' .. '~' -> 1
       | _ -> 4)
  done;
  if !n = Bytes.length s then Bytes.copy s else begin
    let s' = Bytes.create !n in
    n := 0;
    for i = 0 to Bytes.length s - 1 do
      begin match Bytes.unsafe_get s i with
      | ('"' | '\\') as c ->
          Bytes.unsafe_set s' !n '\\'; incr n; Bytes.unsafe_set s' !n c
      | '\n' ->
          Bytes.unsafe_set s' !n '\\'; incr n; Bytes.unsafe_set s' !n 'n'
      | '\t' ->
          Bytes.unsafe_set s' !n '\\'; incr n; Bytes.unsafe_set s' !n 't'
      | '\r' ->
          Bytes.unsafe_set s' !n '\\'; incr n; Bytes.unsafe_set s' !n 'r'
      | '\b' ->
          Bytes.unsafe_set s' !n '\\'; incr n; Bytes.unsafe_set s' !n 'b'
      | (' ' .. '~') as c -> Bytes.unsafe_set s' !n c
      | c ->
          let a = char_code c in
          Bytes.unsafe_set s' !n '\\';
          incr n;
          Bytes.unsafe_set s' !n (char_chr (48 + a / 100));
          incr n;
          Bytes.unsafe_set s' !n (char_chr (48 + (a / 10) mod 10));
          incr n;
          Bytes.unsafe_set s' !n (char_chr (48 + a mod 10));
      end;
      incr n
    done;
    s'
  end

end
module Ext_string : sig 
#1 "ext_string.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Extension to the standard library [String] module, avoid locale sensitivity *) 


val trim : string -> string 

val split_by : ?keep_empty:bool -> (char -> bool) -> string -> string list
(** default is false *)

val split : ?keep_empty:bool -> string -> char -> string list
(** default is false *)

val quick_split_by_ws : string -> string list 
(** split by space chars for quick scripting *)


val starts_with : string -> string -> bool

(**
   return [-1] when not found, the returned index is useful 
   see [ends_with_then_chop]
*)
val ends_with_index : string -> string -> int

val ends_with : string -> string -> bool

(**
   {[
     ends_with_then_chop "a.cmj" ".cmj"
     "a"
   ]}
   This is useful in controlled or file case sensitve system
*)
val ends_with_then_chop : string -> string -> string option


val escaped : string -> string

(** the range is [start, finish]
*)
val for_all_range : 
  string -> start:int -> finish:int -> (char -> bool) -> bool 

val for_all : (char -> bool) -> string -> bool

val is_empty : string -> bool

val repeat : int -> string -> string 

val equal : string -> string -> bool

val find : ?start:int -> sub:string -> string -> int

val contain_substring : string -> string -> bool 

val non_overlap_count : sub:string -> string -> int 

val rfind : sub:string -> string -> int

val tail_from : string -> int -> string

val digits_of_str : string -> offset:int -> int -> int

val starts_with_and_number : string -> offset:int -> string -> int

val unsafe_concat_with_length : int -> string -> string list -> string


(** returns negative number if not found *)
val rindex_neg : string -> char -> int 

val rindex_opt : string -> char -> int option

type check_result = 
    | Good | Invalid_module_name | Suffix_mismatch

val is_valid_source_name :
   string -> check_result

(* TODO handle cases like 
   '@angular/core'
   its directory structure is like 
   {[
     @angular
     |-------- core
   ]}
*)
val is_valid_npm_package_name : string -> bool 



val no_char : string -> char -> int -> int -> bool 


val no_slash : string -> bool 

(** return negative means no slash, otherwise [i] means the place for first slash *)
val no_slash_idx : string -> int 

(** if no conversion happens, reference equality holds *)
val replace_slash_backward : string -> string 

(** if no conversion happens, reference equality holds *)
val replace_backward_slash : string -> string 

val empty : string 


external compare : string -> string -> int = "caml_string_length_based_compare" "noalloc";;
  
val single_space : string

val concat3 : string -> string -> string -> string 
val concat4 : string -> string -> string -> string -> string 
val concat5 : string -> string -> string -> string -> string -> string  
val inter2 : string -> string -> string
val inter3 : string -> string -> string -> string 
val inter4 : string -> string -> string -> string -> string
val concat_array : string -> string array -> string 

val single_colon : string 

val parent_dir_lit : string
val current_dir_lit : string

val capitalize_ascii : string -> string

(** return [Some xx] means the original *)
(* val capitalize_ascii_opt : string -> string option *)
end = struct
#1 "ext_string.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)







(*
   {[ split " test_unsafe_obj_ffi_ppx.cmi" ~keep_empty:false ' ']}
*)
let split_by ?(keep_empty=false) is_delim str =
  let len = String.length str in
  let rec loop acc last_pos pos =
    if pos = -1 then
      if last_pos = 0 && not keep_empty then

        acc
      else 
        String.sub str 0 last_pos :: acc
    else
    if is_delim str.[pos] then
      let new_len = (last_pos - pos - 1) in
      if new_len <> 0 || keep_empty then 
        let v = String.sub str (pos + 1) new_len in
        loop ( v :: acc)
          pos (pos - 1)
      else loop acc pos (pos - 1)
    else loop acc last_pos (pos - 1)
  in
  loop [] len (len - 1)

let trim s = 
  let i = ref 0  in
  let j = String.length s in 
  while !i < j &&  
        let u = String.unsafe_get s !i in 
        u = '\t' || u = '\n' || u = ' ' 
  do 
    incr i;
  done;
  let k = ref (j - 1)  in 
  while !k >= !i && 
        let u = String.unsafe_get s !k in 
        u = '\t' || u = '\n' || u = ' ' do 
    decr k ;
  done;
  String.sub s !i (!k - !i + 1)

let split ?keep_empty  str on = 
  if str = "" then [] else 
    split_by ?keep_empty (fun x -> (x : char) = on) str  ;;

let quick_split_by_ws str : string list = 
  split_by ~keep_empty:false (fun x -> x = '\t' || x = '\n' || x = ' ') str

let starts_with s beg = 
  let beg_len = String.length beg in
  let s_len = String.length s in
  beg_len <=  s_len &&
  (let i = ref 0 in
   while !i <  beg_len 
         && String.unsafe_get s !i =
            String.unsafe_get beg !i do 
     incr i 
   done;
   !i = beg_len
  )


(** return an index which is minus when [s] does not 
    end with [beg]
*)
let ends_with_index s end_ = 
  let s_finish = String.length s - 1 in
  let s_beg = String.length end_ - 1 in
  if s_beg > s_finish then -1
  else
    let rec aux j k = 
      if k < 0 then (j + 1)
      else if String.unsafe_get s j = String.unsafe_get end_ k then 
        aux (j - 1) (k - 1)
      else  -1 in 
    aux s_finish s_beg

let ends_with s end_ = ends_with_index s end_ >= 0 

let ends_with_then_chop s beg = 
  let i =  ends_with_index s beg in 
  if i >= 0 then Some (String.sub s 0 i) 
  else None

let check_suffix_case = ends_with 
let check_suffix_case_then_chop = ends_with_then_chop

let check_any_suffix_case s suffixes = 
  List.exists (fun x -> check_suffix_case s x) suffixes

let check_any_suffix_case_then_chop s suffixes = 
  let rec aux suffixes = 
    match suffixes with 
    | [] -> None 
    | x::xs -> 
      let id = ends_with_index s x in 
      if id >= 0 then Some (String.sub s 0 id)
      else aux xs in 
  aux suffixes    



(**  In OCaml 4.02.3, {!String.escaped} is locale senstive, 
     this version try to make it not locale senstive, this bug is fixed
     in the compiler trunk     
*)
let escaped s =
  let rec needs_escape i =
    if i >= String.length s then false else
      match String.unsafe_get s i with
      | '"' | '\\' | '\n' | '\t' | '\r' | '\b' -> true
      | ' ' .. '~' -> needs_escape (i+1)
      | _ -> true
  in
  if needs_escape 0 then
    Bytes.unsafe_to_string (Ext_bytes.escaped (Bytes.unsafe_of_string s))
  else
    s

(* it is unsafe to expose such API as unsafe since 
   user can provide bad input range 

*)
let rec unsafe_for_all_range s ~start ~finish p =     
  start > finish ||
  p (String.unsafe_get s start) && 
  unsafe_for_all_range s ~start:(start + 1) ~finish p

let for_all_range s ~start ~finish p = 
  let len = String.length s in 
  if start < 0 || finish >= len then invalid_arg "Ext_string.for_all_range"
  else unsafe_for_all_range s ~start ~finish p 

let for_all (p : char -> bool) s =   
  unsafe_for_all_range s ~start:0  ~finish:(String.length s - 1) p 

let is_empty s = String.length s = 0


let repeat n s  =
  let len = String.length s in
  let res = Bytes.create(n * len) in
  for i = 0 to pred n do
    String.blit s 0 res (i * len) len
  done;
  Bytes.to_string res

let equal (x : string) y  = x = y



let unsafe_is_sub ~sub i s j ~len =
  let rec check k =
    if k = len
    then true
    else 
      String.unsafe_get sub (i+k) = 
      String.unsafe_get s (j+k) && check (k+1)
  in
  j+len <= String.length s && check 0


exception Local_exit 
let find ?(start=0) ~sub s =
  let n = String.length sub in
  let s_len = String.length s in 
  let i = ref start in  
  try
    while !i + n <= s_len do
      if unsafe_is_sub ~sub 0 s !i ~len:n then
        raise_notrace Local_exit;
      incr i
    done;
    -1
  with Local_exit ->
    !i

let contain_substring s sub = 
  find s ~sub >= 0 

(** TODO: optimize 
    avoid nonterminating when string is empty 
*)
let non_overlap_count ~sub s = 
  let sub_len = String.length sub in 
  let rec aux  acc off = 
    let i = find ~start:off ~sub s  in 
    if i < 0 then acc 
    else aux (acc + 1) (i + sub_len) in
  if String.length sub = 0 then invalid_arg "Ext_string.non_overlap_count"
  else aux 0 0  


let rfind ~sub s =
  let n = String.length sub in
  let i = ref (String.length s - n) in
  let module M = struct exception Exit end in 
  try
    while !i >= 0 do
      if unsafe_is_sub ~sub 0 s !i ~len:n then 
        raise_notrace Local_exit;
      decr i
    done;
    -1
  with Local_exit ->
    !i

let tail_from s x = 
  let len = String.length s  in 
  if  x > len then invalid_arg ("Ext_string.tail_from " ^s ^ " : "^ string_of_int x )
  else String.sub s x (len - x)


(**
   {[ 
     digits_of_str "11_js" 2 == 11     
   ]}
*)
let digits_of_str s ~offset x = 
  let rec aux i acc s x  = 
    if i >= x then acc 
    else aux (i + 1) (10 * acc + Char.code s.[offset + i] - 48 (* Char.code '0' *)) s x in 
  aux 0 0 s x 



(*
   {[
     starts_with_and_number "js_fn_mk_01" 0 "js_fn_mk_" = 1 ;;
     starts_with_and_number "js_fn_run_02" 0 "js_fn_mk_" = -1 ;;
     starts_with_and_number "js_fn_mk_03" 6 "mk_" = 3 ;;
     starts_with_and_number "js_fn_mk_04" 6 "run_" = -1;;
     starts_with_and_number "js_fn_run_04" 6 "run_" = 4;;
     (starts_with_and_number "js_fn_run_04" 6 "run_" = 3) = false ;;
   ]}
*)
let starts_with_and_number s ~offset beg =
  let beg_len = String.length beg in
  let s_len = String.length s in
  let finish_delim = offset + beg_len in 

  if finish_delim >  s_len  then -1 
  else 
    let i = ref offset  in
    while !i <  finish_delim
          && String.unsafe_get s !i =
             String.unsafe_get beg (!i - offset) do 
      incr i 
    done;
    if !i = finish_delim then 
      digits_of_str ~offset:finish_delim s 2 
    else 
      -1 

let equal (x : string) y  = x = y

let unsafe_concat_with_length len sep l =
  match l with 
  | [] -> ""
  | hd :: tl -> (* num is positive *)
    let r = Bytes.create len in
    let hd_len = String.length hd in 
    let sep_len = String.length sep in 
    String.unsafe_blit hd 0 r 0 hd_len;
    let pos = ref hd_len in
    List.iter
      (fun s ->
         let s_len = String.length s in
         String.unsafe_blit sep 0 r !pos sep_len;
         pos := !pos +  sep_len;
         String.unsafe_blit s 0 r !pos s_len;
         pos := !pos + s_len)
      tl;
    Bytes.unsafe_to_string r


let rec rindex_rec s i c =
  if i < 0 then i else
  if String.unsafe_get s i = c then i else rindex_rec s (i - 1) c;;

let rec rindex_rec_opt s i c =
  if i < 0 then None else
  if String.unsafe_get s i = c then Some i else rindex_rec_opt s (i - 1) c;;

let rindex_neg s c = 
  rindex_rec s (String.length s - 1) c;;

let rindex_opt s c = 
  rindex_rec_opt s (String.length s - 1) c;;

let is_valid_module_file (s : string) = 
  let len = String.length s in 
  len > 0 &&
  match String.unsafe_get s 0 with 
  | 'A' .. 'Z'
  | 'a' .. 'z' -> 
    unsafe_for_all_range s ~start:1 ~finish:(len - 1)
      (fun x -> 
         match x with 
         | 'A'..'Z' | 'a'..'z' | '0'..'9' | '_' | '\'' -> true
         | _ -> false )
  | _ -> false 


(* https://docs.npmjs.com/files/package.json 
   Some rules:
   The name must be less than or equal to 214 characters. This includes the scope for scoped packages.
   The name can't start with a dot or an underscore.
   New packages must not have uppercase letters in the name.
   The name ends up being part of a URL, an argument on the command line, and a folder name. Therefore, the name can't contain any non-URL-safe characters.
*)
let is_valid_npm_package_name (s : string) = 
  let len = String.length s in 
  len <= 214 && (* magic number forced by npm *)
  len > 0 &&
  match String.unsafe_get s 0 with 
  | 'a' .. 'z' | '@' -> 
    unsafe_for_all_range s ~start:1 ~finish:(len - 1)
      (fun x -> 
         match x with 
         |  'a'..'z' | '0'..'9' | '_' | '-' -> true
         | _ -> false )
  | _ -> false 


type check_result = 
  | Good 
  | Invalid_module_name 
  | Suffix_mismatch
  (** 
     TODO: move to another module 
     Make {!Ext_filename} not stateful
  *)
let is_valid_source_name name : check_result =
  match check_any_suffix_case_then_chop name [
      ".ml"; 
      ".re";
      ".mli"; 
      ".rei"
    ] with 
  | None -> Suffix_mismatch
  | Some x -> 
    if is_valid_module_file  x then
      Good
    else Invalid_module_name  

(** TODO: can be improved to return a positive integer instead *)
let rec unsafe_no_char x ch i  last_idx = 
  i > last_idx  || 
  (String.unsafe_get x i <> ch && unsafe_no_char x ch (i + 1)  last_idx)

let rec unsafe_no_char_idx x ch i last_idx = 
  if i > last_idx  then -1 
  else 
  if String.unsafe_get x i <> ch then 
    unsafe_no_char_idx x ch (i + 1)  last_idx
  else i

let no_char x ch i len  : bool =
  let str_len = String.length x in 
  if i < 0 || i >= str_len || len >= str_len then invalid_arg "Ext_string.no_char"   
  else unsafe_no_char x ch i len 


let no_slash x = 
  unsafe_no_char x '/' 0 (String.length x - 1)

let no_slash_idx x = 
  unsafe_no_char_idx x '/' 0 (String.length x - 1)

let replace_slash_backward (x : string ) = 
  let len = String.length x in 
  if unsafe_no_char x '/' 0  (len - 1) then x 
  else 
    String.map (function 
        | '/' -> '\\'
        | x -> x ) x 

let replace_backward_slash (x : string)=
  let len = String.length x in
  if unsafe_no_char x '\\' 0  (len -1) then x 
  else  
    String.map (function 
        |'\\'-> '/'
        | x -> x) x

let empty = ""

    
external compare : string -> string -> int = "caml_string_length_based_compare" "noalloc";;

let single_space = " "
let single_colon = ":"

let concat_array sep (s : string array) =   
  let s_len = Array.length s in 
  match s_len with 
  | 0 -> empty 
  | 1 -> Array.unsafe_get s 0
  | _ ->     
    let sep_len = String.length sep in 
    let len = ref 0 in 
    for i = 0 to  s_len - 1 do 
      len := !len + String.length (Array.unsafe_get s i)
    done;
    let target = 
      Bytes.create 
        (!len + (s_len - 1) * sep_len ) in    
    let hd = (Array.unsafe_get s 0) in     
    let hd_len = String.length hd in 
    String.unsafe_blit hd  0  target 0 hd_len;   
    let current_offset = ref hd_len in     
    for i = 1 to s_len - 1 do 
      String.unsafe_blit sep 0 target  !current_offset sep_len;
      let cur = Array.unsafe_get s i in 
      let cur_len = String.length cur in     
      let new_off_set = (!current_offset + sep_len ) in
      String.unsafe_blit cur 0 target new_off_set cur_len; 
      current_offset := 
        new_off_set + cur_len ; 
    done;
    Bytes.unsafe_to_string target   

let concat3 a b c = 
  let a_len = String.length a in 
  let b_len = String.length b in 
  let c_len = String.length c in 
  let len = a_len + b_len + c_len in 
  let target = Bytes.create len in 
  String.unsafe_blit a 0 target 0 a_len ; 
  String.unsafe_blit b 0 target a_len b_len;
  String.unsafe_blit c 0 target (a_len + b_len) c_len;
  Bytes.unsafe_to_string target

let concat4 a b c d =
  let a_len = String.length a in 
  let b_len = String.length b in 
  let c_len = String.length c in 
  let d_len = String.length d in 
  let len = a_len + b_len + c_len + d_len in 

  let target = Bytes.create len in 
  String.unsafe_blit a 0 target 0 a_len ; 
  String.unsafe_blit b 0 target a_len b_len;
  String.unsafe_blit c 0 target (a_len + b_len) c_len;
  String.unsafe_blit d 0 target (a_len + b_len + c_len) d_len;
  Bytes.unsafe_to_string target


let concat5 a b c d e =
  let a_len = String.length a in 
  let b_len = String.length b in 
  let c_len = String.length c in 
  let d_len = String.length d in 
  let e_len = String.length e in 
  let len = a_len + b_len + c_len + d_len + e_len in 

  let target = Bytes.create len in 
  String.unsafe_blit a 0 target 0 a_len ; 
  String.unsafe_blit b 0 target a_len b_len;
  String.unsafe_blit c 0 target (a_len + b_len) c_len;
  String.unsafe_blit d 0 target (a_len + b_len + c_len) d_len;
  String.unsafe_blit e 0 target (a_len + b_len + c_len + d_len) e_len;
  Bytes.unsafe_to_string target



let inter2 a b = 
  concat3 a single_space b 


let inter3 a b c = 
  concat5 a  single_space  b  single_space  c 





let inter4 a b c d =
  concat_array single_space [| a; b ; c; d|]


let parent_dir_lit = ".."    
let current_dir_lit = "."


(* reference {!Bytes.unppercase} *)
let capitalize_ascii (s : string) : string = 
  if String.length s = 0 then s 
  else 
    begin
      let c = String.unsafe_get s 0 in 
      if (c >= 'a' && c <= 'z')
      || (c >= '\224' && c <= '\246')
      || (c >= '\248' && c <= '\254') then 
        let uc = Char.unsafe_chr (Char.code c - 32) in 
        let bytes = Bytes.of_string s in
        Bytes.unsafe_set bytes 0 uc;
        Bytes.unsafe_to_string bytes 
      else s 
    end

let capitalize_ascii_opt (s : string) : string option = 
  if String.length s = 0 then None
  else 
    begin
      let c = String.unsafe_get s 0 in 
      if (c >= 'a' && c <= 'z')
      || (c >= '\224' && c <= '\246')
      || (c >= '\248' && c <= '\254') then 
        let uc = Char.unsafe_chr (Char.code c - 32) in 
        let bytes = Bytes.of_string s in
        Bytes.unsafe_set bytes 0 uc;
        Some (Bytes.unsafe_to_string bytes)
      else None
    end
    



end
module Js_config : sig 
#1 "js_config.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)





(* val get_packages_info :
   unit -> Js_packages_info.t *)


(** set/get header *)
val no_version_header : bool ref 


(** return [package_name] and [path] 
    when in script mode: 
*)

(* val get_current_package_name_and_path : 
  Js_packages_info.module_system -> 
  Js_packages_info.info_query *)


(* val set_package_name : string -> unit  
val get_package_name : unit -> string option *)

(** corss module inline option *)
val cross_module_inline : bool ref
val set_cross_module_inline : bool -> unit
val get_cross_module_inline : unit -> bool
  
(** diagnose option *)
val diagnose : bool ref 
val get_diagnose : unit -> bool 
val set_diagnose : bool -> unit 


(** generate tds option *)
val default_gen_tds : bool ref

(** options for builtion ppx *)
val no_builtin_ppx_ml : bool ref 
val no_builtin_ppx_mli : bool ref 
val no_warn_ffi_type : bool ref 
val no_warn_unused_bs_attribute : bool ref 
val no_error_unused_bs_attribute : bool ref 
(** check-div-by-zero option *)
val check_div_by_zero : bool ref 
val get_check_div_by_zero : unit -> bool 

(* It will imply [-noassert] be set too, note from the implmentation point of view, 
   in the lambda layer, it is impossible to tell whehther it is [assert (3 <> 2)] or 
   [if (3<>2) then assert false]
 *)
val no_any_assert : bool ref 
val set_no_any_assert : unit -> unit
val get_no_any_assert : unit -> bool 



(** Debugging utilies *)
val set_current_file : string -> unit 
val get_current_file : unit -> string
val get_module_name : unit -> string

val iset_debug_file : string -> unit
val set_debug_file : string -> unit
val get_debug_file : unit -> string

val is_same_file : unit -> bool 

val tool_name : string


val sort_imports : bool ref 
val dump_js : bool ref
val syntax_only  : bool ref
val binary_ast : bool ref



end = struct
#1 "js_config.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






(* let add_npm_package_path s =
  match !packages_info  with
  | Empty ->
    Ext_pervasives.bad_argf "please set package name first using -bs-package-name ";
  | NonBrowser(name,  envs) ->
    let env, path =
      match Ext_string.split ~keep_empty:false s ':' with
      | [ package_name; path]  ->
        (match Js_packages_info.module_system_of_string package_name with
         | Some x -> x
         | None ->
           Ext_pervasives.bad_argf "invalid module system %s" package_name), path
      | [path] ->
        NodeJS, path
      | _ ->
        Ext_pervasives.bad_argf "invalid npm package path: %s" s
    in
    packages_info := NonBrowser (name,  ((env,path) :: envs)) *)
(** Browser is not set via command line only for internal use *)


let no_version_header = ref false

let cross_module_inline = ref false

let get_cross_module_inline () = !cross_module_inline
let set_cross_module_inline b =
  cross_module_inline := b


let diagnose = ref false
let get_diagnose () = !diagnose
let set_diagnose b = diagnose := b

let (//) = Filename.concat

(* let get_packages_info () = !packages_info *)

let default_gen_tds = ref false
let no_builtin_ppx_ml = ref false
let no_builtin_ppx_mli = ref false
let no_warn_ffi_type = ref false

(** TODO: will flip the option when it is ready *)
let no_warn_unused_bs_attribute = ref false
let no_error_unused_bs_attribute = ref false 

let current_file = ref ""
let debug_file = ref ""

let set_current_file f  = current_file := f
let get_current_file () = !current_file
let get_module_name () =
  Filename.chop_extension
    (Filename.basename (String.uncapitalize !current_file))

let iset_debug_file _ = ()
let set_debug_file  f = debug_file := f
let get_debug_file  () = !debug_file


let is_same_file () =
  !debug_file <> "" &&  !debug_file = !current_file

let tool_name = "BuckleScript"

let check_div_by_zero = ref true
let get_check_div_by_zero () = !check_div_by_zero

let no_any_assert = ref false

let set_no_any_assert () = no_any_assert := true
let get_no_any_assert () = !no_any_assert

let sort_imports = ref true
let dump_js = ref false



let syntax_only = ref false
let binary_ast = ref false


end
module Bs_exception : sig 
#1 "bs_exception.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type error =
  | Cmj_not_found of string
  | Js_not_found of string
  | Bs_cyclic_depends of string  list
  | Bs_duplicated_module of string * string
  | Bs_duplicate_exports of string (* gpr_974 *)
  | Bs_package_not_found of string                                                        
  | Bs_main_not_exist of string 
  | Bs_invalid_path of string
  | Missing_ml_dependency of string 
  | Dependency_script_module_dependent_not  of string
(*
TODO: In the futrue, we should refine dependency [bsb] 
should not rely on such exception, it should have its own exception handling
*)

(* exception Error of error *)

(* val report_error : Format.formatter -> error -> unit *)

val error : error -> 'a 

end = struct
#1 "bs_exception.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


type error =
  | Cmj_not_found of string
  | Js_not_found of string 
  | Bs_cyclic_depends of string  list
  | Bs_duplicated_module of string * string
  | Bs_duplicate_exports of string (* gpr_974 *)
  | Bs_package_not_found of string                            
  | Bs_main_not_exist of string 
  | Bs_invalid_path of string
  | Missing_ml_dependency of string 
  | Dependency_script_module_dependent_not  of string 
  (** TODO: we need add location handling *)    
exception Error of error

let error err = raise (Error err)

let report_error ppf = function
  | Dependency_script_module_dependent_not s
    -> 
    Format.fprintf ppf 
      "%s is compiled in script mode while its dependent is not"
      s
  | Missing_ml_dependency s -> 
    Format.fprintf ppf "Missing dependency %s in search path" s 
  | Cmj_not_found s ->
    Format.fprintf ppf "%s not found, cmj format is generated by BuckleScript" s
  | Js_not_found s -> 
    Format.fprintf ppf "%s not found, needed in script mode " s
  | Bs_cyclic_depends  str
    ->
    Format.fprintf ppf "Cyclic depends : @[%a@]"
      (Format.pp_print_list ~pp_sep:Format.pp_print_space
         Format.pp_print_string)
      str
  | Bs_duplicate_exports str -> 
    Format.fprintf ppf "%s are exported as twice" str 
  | Bs_duplicated_module (a,b)
    ->
    Format.fprintf ppf "The build system does not support two files with same names yet %s, %s" a b
  | Bs_main_not_exist main
    ->
    Format.fprintf ppf "File %s not found " main

  | Bs_package_not_found package
    ->
    Format.fprintf ppf "Package %s not found or %s/lib/ocaml does not exist or please set npm_config_prefix correctly"
      package package
  | Bs_invalid_path path
    ->  Format.pp_print_string ppf ("Invalid path: " ^ path )


let () =
  Location.register_error_of_exn
    (function
      | Error err
        -> Some (Location.error_of_printer_file report_error err)
      | _ -> None
    )

end
module Depend : sig 
#1 "depend.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1999 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(** Module dependencies. *)

module StringSet : Set.S with type elt = string

val free_structure_names : StringSet.t ref

val open_module : StringSet.t -> Longident.t -> unit

val add_use_file : StringSet.t -> Parsetree.toplevel_phrase list -> unit

val add_signature : StringSet.t -> Parsetree.signature -> unit

val add_implementation : StringSet.t -> Parsetree.structure -> unit

end = struct
#1 "depend.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1999 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Asttypes
open Location
open Longident
open Parsetree

module StringSet = Set.Make(struct type t = string let compare = compare end)

(* Collect free module identifiers in the a.s.t. *)

let free_structure_names = ref StringSet.empty

let rec add_path bv = function
  | Lident s ->
      if not (StringSet.mem s bv)
      then free_structure_names := StringSet.add s !free_structure_names
  | Ldot(l, _s) -> add_path bv l
  | Lapply(l1, l2) -> add_path bv l1; add_path bv l2

let open_module bv lid = add_path bv lid

let add bv lid =
  match lid.txt with
    Ldot(l, _s) -> add_path bv l
  | _ -> ()

let addmodule bv lid = add_path bv lid.txt

let rec add_type bv ty =
  match ty.ptyp_desc with
    Ptyp_any -> ()
  | Ptyp_var _ -> ()
  | Ptyp_arrow(_, t1, t2) -> add_type bv t1; add_type bv t2
  | Ptyp_tuple tl -> List.iter (add_type bv) tl
  | Ptyp_constr(c, tl) -> add bv c; List.iter (add_type bv) tl
  | Ptyp_object (fl, _) -> List.iter (fun (_, _, t) -> add_type bv t) fl
  | Ptyp_class(c, tl) -> add bv c; List.iter (add_type bv) tl
  | Ptyp_alias(t, _) -> add_type bv t
  | Ptyp_variant(fl, _, _) ->
      List.iter
        (function Rtag(_,_,_,stl) -> List.iter (add_type bv) stl
          | Rinherit sty -> add_type bv sty)
        fl
  | Ptyp_poly(_, t) -> add_type bv t
  | Ptyp_package pt -> add_package_type bv pt
  | Ptyp_extension _ -> ()

and add_package_type bv (lid, l) =
  add bv lid;
  List.iter (add_type bv) (List.map (fun (_, e) -> e) l)

let add_opt add_fn bv = function
    None -> ()
  | Some x -> add_fn bv x

let add_constructor_decl bv pcd =
  List.iter (add_type bv) pcd.pcd_args; Misc.may (add_type bv) pcd.pcd_res

let add_type_declaration bv td =
  List.iter
    (fun (ty1, ty2, _) -> add_type bv ty1; add_type bv ty2)
    td.ptype_cstrs;
  add_opt add_type bv td.ptype_manifest;
  let add_tkind = function
    Ptype_abstract -> ()
  | Ptype_variant cstrs ->
      List.iter (add_constructor_decl bv) cstrs
  | Ptype_record lbls ->
      List.iter (fun pld -> add_type bv pld.pld_type) lbls
  | Ptype_open -> () in
  add_tkind td.ptype_kind

let add_extension_constructor bv ext =
  match ext.pext_kind with
      Pext_decl(args, rty) ->
        List.iter (add_type bv) args; Misc.may (add_type bv) rty
    | Pext_rebind lid -> add bv lid

let add_type_extension bv te =
  add bv te.ptyext_path;
  List.iter (add_extension_constructor bv) te.ptyext_constructors

let rec add_class_type bv cty =
  match cty.pcty_desc with
    Pcty_constr(l, tyl) ->
      add bv l; List.iter (add_type bv) tyl
  | Pcty_signature { pcsig_self = ty; pcsig_fields = fieldl } ->
      add_type bv ty;
      List.iter (add_class_type_field bv) fieldl
  | Pcty_arrow(_, ty1, cty2) ->
      add_type bv ty1; add_class_type bv cty2
  | Pcty_extension _ -> ()

and add_class_type_field bv pctf =
  match pctf.pctf_desc with
    Pctf_inherit cty -> add_class_type bv cty
  | Pctf_val(_, _, _, ty) -> add_type bv ty
  | Pctf_method(_, _, _, ty) -> add_type bv ty
  | Pctf_constraint(ty1, ty2) -> add_type bv ty1; add_type bv ty2
  | Pctf_attribute _ -> ()
  | Pctf_extension _ -> ()

let add_class_description bv infos =
  add_class_type bv infos.pci_expr

let add_class_type_declaration = add_class_description

let pattern_bv = ref StringSet.empty

let rec add_pattern bv pat =
  match pat.ppat_desc with
    Ppat_any -> ()
  | Ppat_var _ -> ()
  | Ppat_alias(p, _) -> add_pattern bv p
  | Ppat_interval _
  | Ppat_constant _ -> ()
  | Ppat_tuple pl -> List.iter (add_pattern bv) pl
  | Ppat_construct(c, op) -> add bv c; add_opt add_pattern bv op
  | Ppat_record(pl, _) ->
      List.iter (fun (lbl, p) -> add bv lbl; add_pattern bv p) pl
  | Ppat_array pl -> List.iter (add_pattern bv) pl
  | Ppat_or(p1, p2) -> add_pattern bv p1; add_pattern bv p2
  | Ppat_constraint(p, ty) -> add_pattern bv p; add_type bv ty
  | Ppat_variant(_, op) -> add_opt add_pattern bv op
  | Ppat_type li -> add bv li
  | Ppat_lazy p -> add_pattern bv p
  | Ppat_unpack id -> pattern_bv := StringSet.add id.txt !pattern_bv
  | Ppat_exception p -> add_pattern bv p
  | Ppat_extension _ -> ()

let add_pattern bv pat =
  pattern_bv := bv;
  add_pattern bv pat;
  !pattern_bv

let rec add_expr bv exp =
  match exp.pexp_desc with
    Pexp_ident l -> add bv l
  | Pexp_constant _ -> ()
  | Pexp_let(rf, pel, e) ->
      let bv = add_bindings rf bv pel in add_expr bv e
  | Pexp_fun (_, opte, p, e) ->
      add_opt add_expr bv opte; add_expr (add_pattern bv p) e
  | Pexp_function pel ->
      add_cases bv pel
  | Pexp_apply(e, el) ->
      add_expr bv e; List.iter (fun (_,e) -> add_expr bv e) el
  | Pexp_match(e, pel) -> add_expr bv e; add_cases bv pel
  | Pexp_try(e, pel) -> add_expr bv e; add_cases bv pel
  | Pexp_tuple el -> List.iter (add_expr bv) el
  | Pexp_construct(c, opte) -> add bv c; add_opt add_expr bv opte
  | Pexp_variant(_, opte) -> add_opt add_expr bv opte
  | Pexp_record(lblel, opte) ->
      List.iter (fun (lbl, e) -> add bv lbl; add_expr bv e) lblel;
      add_opt add_expr bv opte
  | Pexp_field(e, fld) -> add_expr bv e; add bv fld
  | Pexp_setfield(e1, fld, e2) -> add_expr bv e1; add bv fld; add_expr bv e2
  | Pexp_array el -> List.iter (add_expr bv) el
  | Pexp_ifthenelse(e1, e2, opte3) ->
      add_expr bv e1; add_expr bv e2; add_opt add_expr bv opte3
  | Pexp_sequence(e1, e2) -> add_expr bv e1; add_expr bv e2
  | Pexp_while(e1, e2) -> add_expr bv e1; add_expr bv e2
  | Pexp_for( _, e1, e2, _, e3) ->
      add_expr bv e1; add_expr bv e2; add_expr bv e3
  | Pexp_coerce(e1, oty2, ty3) ->
      add_expr bv e1;
      add_opt add_type bv oty2;
      add_type bv ty3
  | Pexp_constraint(e1, ty2) ->
      add_expr bv e1;
      add_type bv ty2
  | Pexp_send(e, _m) -> add_expr bv e
  | Pexp_new li -> add bv li
  | Pexp_setinstvar(_v, e) -> add_expr bv e
  | Pexp_override sel -> List.iter (fun (_s, e) -> add_expr bv e) sel
  | Pexp_letmodule(id, m, e) ->
      add_module bv m; add_expr (StringSet.add id.txt bv) e
  | Pexp_assert (e) -> add_expr bv e
  | Pexp_lazy (e) -> add_expr bv e
  | Pexp_poly (e, t) -> add_expr bv e; add_opt add_type bv t
  | Pexp_object { pcstr_self = pat; pcstr_fields = fieldl } ->
      let bv = add_pattern bv pat in List.iter (add_class_field bv) fieldl
  | Pexp_newtype (_, e) -> add_expr bv e
  | Pexp_pack m -> add_module bv m
  | Pexp_open (_ovf, m, e) -> open_module bv m.txt; add_expr bv e
  | Pexp_extension _ -> ()

and add_cases bv cases =
  List.iter (add_case bv) cases

and add_case bv {pc_lhs; pc_guard; pc_rhs} =
  let bv = add_pattern bv pc_lhs in
  add_opt add_expr bv pc_guard;
  add_expr bv pc_rhs

and add_bindings recf bv pel =
  let bv' = List.fold_left (fun bv x -> add_pattern bv x.pvb_pat) bv pel in
  let bv = if recf = Recursive then bv' else bv in
  List.iter (fun x -> add_expr bv x.pvb_expr) pel;
  bv'

and add_modtype bv mty =
  match mty.pmty_desc with
    Pmty_ident l -> add bv l
  | Pmty_alias l -> addmodule bv l
  | Pmty_signature s -> add_signature bv s
  | Pmty_functor(id, mty1, mty2) ->
      Misc.may (add_modtype bv) mty1;
      add_modtype (StringSet.add id.txt bv) mty2
  | Pmty_with(mty, cstrl) ->
      add_modtype bv mty;
      List.iter
        (function
          | Pwith_type (_, td) -> add_type_declaration bv td
          | Pwith_module (_, lid) -> addmodule bv lid
          | Pwith_typesubst td -> add_type_declaration bv td
          | Pwith_modsubst (_, lid) -> addmodule bv lid
        )
        cstrl
  | Pmty_typeof m -> add_module bv m
  | Pmty_extension _ -> ()

and add_signature bv = function
    [] -> ()
  | item :: rem -> add_signature (add_sig_item bv item) rem

and add_sig_item bv item =
  match item.psig_desc with
    Psig_value vd ->
      add_type bv vd.pval_type; bv
  | Psig_type dcls ->
      List.iter (add_type_declaration bv) dcls; bv
  | Psig_typext te ->
      add_type_extension bv te; bv
  | Psig_exception pext ->
      add_extension_constructor bv pext; bv
  | Psig_module pmd ->
      add_modtype bv pmd.pmd_type; StringSet.add pmd.pmd_name.txt bv
  | Psig_recmodule decls ->
      let bv' =
        List.fold_right StringSet.add
                        (List.map (fun pmd -> pmd.pmd_name.txt) decls) bv
      in
      List.iter (fun pmd -> add_modtype bv' pmd.pmd_type) decls;
      bv'
  | Psig_modtype x ->
      begin match x.pmtd_type with
        None -> ()
      | Some mty -> add_modtype bv mty
      end;
      bv
  | Psig_open od ->
      open_module bv od.popen_lid.txt; bv
  | Psig_include incl ->
      add_modtype bv incl.pincl_mod; bv
  | Psig_class cdl ->
      List.iter (add_class_description bv) cdl; bv
  | Psig_class_type cdtl ->
      List.iter (add_class_type_declaration bv) cdtl; bv
  | Psig_attribute _ | Psig_extension _ ->
      bv

and add_module bv modl =
  match modl.pmod_desc with
    Pmod_ident l -> addmodule bv l
  | Pmod_structure s -> ignore (add_structure bv s)
  | Pmod_functor(id, mty, modl) ->
      Misc.may (add_modtype bv) mty;
      add_module (StringSet.add id.txt bv) modl
  | Pmod_apply(mod1, mod2) ->
      add_module bv mod1; add_module bv mod2
  | Pmod_constraint(modl, mty) ->
      add_module bv modl; add_modtype bv mty
  | Pmod_unpack(e) ->
      add_expr bv e
  | Pmod_extension _ ->
      ()

and add_structure bv item_list =
  List.fold_left add_struct_item bv item_list

and add_struct_item bv item =
  match item.pstr_desc with
    Pstr_eval (e, _attrs) ->
      add_expr bv e; bv
  | Pstr_value(rf, pel) ->
      let bv = add_bindings rf bv pel in bv
  | Pstr_primitive vd ->
      add_type bv vd.pval_type; bv
  | Pstr_type dcls ->
      List.iter (add_type_declaration bv) dcls; bv
  | Pstr_typext te ->
      add_type_extension bv te;
      bv
  | Pstr_exception pext ->
      add_extension_constructor bv pext; bv
  | Pstr_module x ->
      add_module bv x.pmb_expr; StringSet.add x.pmb_name.txt bv
  | Pstr_recmodule bindings ->
      let bv' =
        List.fold_right StringSet.add
          (List.map (fun x -> x.pmb_name.txt) bindings) bv in
      List.iter
        (fun x -> add_module bv' x.pmb_expr)
        bindings;
      bv'
  | Pstr_modtype x ->
      begin match x.pmtd_type with
        None -> ()
      | Some mty -> add_modtype bv mty
      end;
      bv
  | Pstr_open od ->
      open_module bv od.popen_lid.txt; bv
  | Pstr_class cdl ->
      List.iter (add_class_declaration bv) cdl; bv
  | Pstr_class_type cdtl ->
      List.iter (add_class_type_declaration bv) cdtl; bv
  | Pstr_include incl ->
      add_module bv incl.pincl_mod; bv
  | Pstr_attribute _ | Pstr_extension _ ->
      bv

and add_use_file bv top_phrs =
  ignore (List.fold_left add_top_phrase bv top_phrs)

and add_implementation bv l =
  ignore (add_structure bv l)

and add_top_phrase bv = function
  | Ptop_def str -> add_structure bv str
  | Ptop_dir (_, _) -> bv

and add_class_expr bv ce =
  match ce.pcl_desc with
    Pcl_constr(l, tyl) ->
      add bv l; List.iter (add_type bv) tyl
  | Pcl_structure { pcstr_self = pat; pcstr_fields = fieldl } ->
      let bv = add_pattern bv pat in List.iter (add_class_field bv) fieldl
  | Pcl_fun(_, opte, pat, ce) ->
      add_opt add_expr bv opte;
      let bv = add_pattern bv pat in add_class_expr bv ce
  | Pcl_apply(ce, exprl) ->
      add_class_expr bv ce; List.iter (fun (_,e) -> add_expr bv e) exprl
  | Pcl_let(rf, pel, ce) ->
      let bv = add_bindings rf bv pel in add_class_expr bv ce
  | Pcl_constraint(ce, ct) ->
      add_class_expr bv ce; add_class_type bv ct
  | Pcl_extension _ -> ()

and add_class_field bv pcf =
  match pcf.pcf_desc with
    Pcf_inherit(_, ce, _) -> add_class_expr bv ce
  | Pcf_val(_, _, Cfk_concrete (_, e))
  | Pcf_method(_, _, Cfk_concrete (_, e)) -> add_expr bv e
  | Pcf_val(_, _, Cfk_virtual ty)
  | Pcf_method(_, _, Cfk_virtual ty) -> add_type bv ty
  | Pcf_constraint(ty1, ty2) -> add_type bv ty1; add_type bv ty2
  | Pcf_initializer e -> add_expr bv e
  | Pcf_attribute _ | Pcf_extension _ -> ()

and add_class_declaration bv decl =
  add_class_expr bv decl.pci_expr

end
module Ext_format : sig 
#1 "ext_format.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Simplified wrapper module for the standard library [Format] module. 
  *) 

type t = private Format.formatter

val string : t -> string -> unit

val break : t -> unit

val break1 : t -> unit

val space :  t -> unit

val group : t -> int -> (unit -> 'a) -> 'a
(** [group] will record current indentation 
    and indent futher
 *)

val vgroup : t -> int -> (unit -> 'a) -> 'a

val paren : t -> (unit -> 'a) -> 'a

val paren_group : t -> int -> (unit -> 'a) -> 'a

val brace_group : t -> int -> (unit -> 'a) -> 'a

val brace_vgroup : t -> int -> (unit -> 'a) -> 'a

val bracket_group : t -> int -> (unit -> 'a) -> 'a

val newline : t -> unit

val to_out_channel : out_channel -> t

val flush : t -> unit -> unit

val pp_print_queue :
  ?pp_sep:(Format.formatter -> unit -> unit) ->
  (Format.formatter -> 'a -> unit) -> Format.formatter -> 'a Queue.t -> unit

end = struct
#1 "ext_format.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








open Format

type t = formatter

let string = pp_print_string

let break = fun fmt -> pp_print_break fmt 0 0

let break1 =
  fun fmt -> pp_print_break fmt 0 1 

let space  fmt  = 
  pp_print_break fmt 1 0

let vgroup fmt indent u = 
  pp_open_vbox fmt indent; 
  let v = u () in
  pp_close_box fmt ();
  v

let group fmt indent u = 
  pp_open_hovbox fmt indent; 
  let v = u () in
  pp_close_box fmt ();
  v
  
let paren fmt u = 
  string fmt "(";
  let v = u () in
  string fmt ")";
  v

let brace fmt u = 
  string fmt "{";
  (* break1 fmt ; *)
  let v = u () in
  string fmt "}";
  v 

let bracket fmt u = 
  string fmt "[";
  let v = u () in
  string fmt "]";
  v 

let paren_group st n action = 
  group st n (fun _ -> paren st action)

let brace_group st n action = 
  group st n (fun _ -> brace st action )

let brace_vgroup st n action = 
  vgroup st n (fun _ -> 
    string st "{";
    pp_print_break st 0 2;
    let v = vgroup st 0 action in
    pp_print_break st 0 0;
    string st "}";
    v
              )
let bracket_group st n action = 
  group st n (fun _ -> bracket st action)

let newline fmt = pp_print_newline fmt ()

let to_out_channel = formatter_of_out_channel

(* let non_breaking_space  fmt = string fmt " " *)
(* let set_needed_space_function _ _ = () *)
let flush = pp_print_flush

let list = pp_print_list

let rec pp_print_queue ?(pp_sep = pp_print_cut) pp_v ppf q =
  Queue.iter (fun q -> pp_v ppf q ;  pp_sep ppf ()) q 

end
module Ext_list : sig 
#1 "ext_list.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


val map : ('a -> 'b) -> 'a list -> 'b list 

val append : 'a list -> 'a list -> 'a list 



(** Extension to the standard library [List] module *)
    
(** TODO some function are no efficiently implemented. *) 

val filter_map : ('a -> 'b option) -> 'a list -> 'b list 

val excludes : ('a -> bool) -> 'a list -> bool * 'a list

val exclude_with_fact : ('a -> bool) -> 'a list -> 'a option * 'a list

val exclude_with_fact2 : 
  ('a -> bool) -> ('a -> bool) -> 'a list -> 'a option * 'a option * 'a list

val same_length : 'a list -> 'b list -> bool

val init : int -> (int -> 'a) -> 'a list

val take : int -> 'a list -> 'a list * 'a list

(* val try_take : int -> 'a list -> 'a list * int * 'a list  *)

val exclude_tail : 'a list -> 'a * 'a list

val length_compare : 'a list -> int -> [`Gt | `Eq | `Lt ]

val length_ge : 'a list -> int -> bool
(**

  {[length xs = length ys + n ]}
  input n should be positive 
  TODO: input checking
*)

val length_larger_than_n : 
  int -> 'a list -> 'a list -> bool

val filter_map2 : ('a -> 'b -> 'c option) -> 'a list -> 'b list -> 'c list

val filter_map2i : (int -> 'a -> 'b -> 'c option) -> 'a list -> 'b list -> 'c list

val filter_mapi : (int -> 'a -> 'b option) -> 'a list -> 'b list

val flat_map2 : ('a -> 'b -> 'c list) -> 'a list -> 'b list -> 'c list

val flat_map_acc : ('a -> 'b list) -> 'b list -> 'a list ->  'b list
val flat_map : ('a -> 'b list) -> 'a list -> 'b list


(** for the last element the first element will be passed [true] *)

(* val fold_right2_last : (bool -> 'a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'c *)

val map_last : (bool -> 'a -> 'b) -> 'a list -> 'b list

val stable_group : ('a -> 'a -> bool) -> 'a list -> 'a list list 

val drop : int -> 'a list -> 'a list 

(** [for_all_ret p lst ]
    if all elements in [lst] pass, return [None] 
    otherwise return the first element [e] as [Some e] which
    fails the predicate
*)
val for_all_ret : ('a -> bool) -> 'a list -> 'a option 

(** [find_opt f l] returns [None] if all return [None],  
    otherwise returns the first one. 
 *)

val find_opt : ('a -> 'b option) -> 'a list -> 'b option

(** same as [List.fold_left] except the argument order
    Provide an api so that list can be easily swapped by other containers  
 *)
val fold : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b

val rev_map_append : ('a -> 'b) -> 'a list -> 'b list -> 'b list

val rev_map_acc : 'a list -> ('b -> 'a) -> 'b list -> 'a list

val map_acc : 'a list -> ('b -> 'a) -> 'b list -> 'a list

val rev_iter : ('a -> unit) -> 'a list -> unit

val for_all2_no_exn : ('a -> 'b -> bool) -> 'a list -> 'b list -> bool



(** [f] is applied follow the list order *)
val split_map : ('a -> 'b * 'c) -> 'a list -> 'b list * 'c list       


val reduce_from_right : ('a -> 'a -> 'a) -> 'a list -> 'a

(** [fn] is applied from left to right *)
val reduce_from_left : ('a -> 'a -> 'a) -> 'a list -> 'a


type 'a t = 'a list ref

val create_ref_empty : unit -> 'a t

val ref_top : 'a t -> 'a 

val ref_empty : 'a t -> bool

val ref_push : 'a -> 'a t -> unit

val ref_pop : 'a t -> 'a

val rev_except_last : 'a list -> 'a list * 'a

val sort_via_array :
  ('a -> 'a -> int) -> 'a list -> 'a list

val last : 'a list -> 'a


(** [assoc_by_string default key lst]
  if  [key] is found in the list  return that val,
  other unbox the [default], 
  otherwise [assert false ]
 *)
 val assoc_by_string : 
  'a  option -> string -> (string * 'a) list -> 'a  

val assoc_by_int : 
  'a  option -> int -> (int * 'a) list -> 'a   


val nth_opt : 'a list -> int -> 'a option  
end = struct
#1 "ext_list.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)




let rec map f l =
  match l with
  | [] ->
    []
  | [x1] ->
    let y1 = f x1 in
    [y1]
  | [x1; x2] ->
    let y1 = f x1 in
    let y2 = f x2 in
    [y1; y2]
  | [x1; x2; x3] ->
    let y1 = f x1 in
    let y2 = f x2 in
    let y3 = f x3 in
    [y1; y2; y3]
  | [x1; x2; x3; x4] ->
    let y1 = f x1 in
    let y2 = f x2 in
    let y3 = f x3 in
    let y4 = f x4 in
    [y1; y2; y3; y4]
  | x1::x2::x3::x4::x5::tail ->
    let y1 = f x1 in
    let y2 = f x2 in
    let y3 = f x3 in
    let y4 = f x4 in
    let y5 = f x5 in
    y1::y2::y3::y4::y5::(map f tail)

let rec append l1 l2 = 
  match l1 with
  | a0::a1::a2::a3::a4::a5 -> a0::a1::a2::a3::a4::(append a5 l2)
  | a0::a1::a2::a3::a4 -> a0::a1::a2::a3::(append a4 l2)
  | a0::a1::a2::a3 -> a0::a1::a2::(append a3 l2)
  | a0::a1::a2-> a0::a1::(append a2 l2)
  | a0::a1 -> a0::(append a1 l2)    
  | [] -> l2




let rec filter_map (f: 'a -> 'b option) xs = 
  match xs with 
  | [] -> []
  | y :: ys -> 
    begin match f y with 
      | None -> filter_map f ys
      | Some z -> z :: filter_map f ys
    end

let excludes (p : 'a -> bool ) l : bool * 'a list=
  let excluded = ref false in 
  let rec aux accu = function
    | [] -> List.rev accu
    | x :: l -> 
      if p x then 
        begin 
          excluded := true ;
          aux accu l
        end
      else aux (x :: accu) l in
  let v = aux [] l in 
  if !excluded then true, v else false,l

let exclude_with_fact p l =
  let excluded = ref None in 
  let rec aux accu = function
    | [] -> List.rev accu
    | x :: l -> 
      if p x then 
        begin 
          excluded := Some x ;
          aux accu l
        end
      else aux (x :: accu) l in
  let v = aux [] l in 
  !excluded , if !excluded <> None then v else l 


(** Make sure [p2 x] and [p1 x] will not hold at the same time *)
let exclude_with_fact2 p1 p2 l =
  let excluded1 = ref None in 
  let excluded2 = ref None in 
  let rec aux accu = function
    | [] -> List.rev accu
    | x :: l -> 
      if p1 x then 
        begin 
          excluded1 := Some x ;
          aux accu l
        end
      else if p2 x then 
        begin 
          excluded2 := Some x ; 
          aux accu l 
        end
      else aux (x :: accu) l in
  let v = aux [] l in 
  !excluded1, !excluded2 , if !excluded1 <> None && !excluded2 <> None then v else l 



let rec same_length xs ys = 
  match xs, ys with 
  | [], [] -> true
  | _::xs, _::ys -> same_length xs ys 
  | _, _ -> false 

let  filter_mapi (f: int -> 'a -> 'b option) xs = 
  let rec aux i xs = 
    match xs with 
    | [] -> []
    | y :: ys -> 
      begin match f i y with 
        | None -> aux (i + 1) ys
        | Some z -> z :: aux (i + 1) ys
      end in
  aux 0 xs 

let rec filter_map2 (f: 'a -> 'b -> 'c option) xs ys = 
  match xs,ys with 
  | [],[] -> []
  | u::us, v :: vs -> 
    begin match f u v with 
      | None -> filter_map2 f us vs (* idea: rec f us vs instead? *)
      | Some z -> z :: filter_map2 f us vs
    end
  | _ -> invalid_arg "Ext_list.filter_map2"

let filter_map2i (f: int ->  'a -> 'b -> 'c option) xs ys = 
  let rec aux i xs ys = 
    match xs,ys with 
    | [],[] -> []
    | u::us, v :: vs -> 
      begin match f i u v with 
        | None -> aux (i + 1) us vs (* idea: rec f us vs instead? *)
        | Some z -> z :: aux (i + 1) us vs
      end
    | _ -> invalid_arg "Ext_list.filter_map2i" in
  aux 0 xs ys

let rec rev_map_append  f l1 l2 =
  match l1 with
  | [] -> l2
  | a :: l -> rev_map_append f l (f a :: l2)

let flat_map2 f lx ly = 
  let rec aux acc lx ly = 
    match lx, ly with 
    | [], [] 
      -> List.rev acc
    | x::xs, y::ys 
      ->  aux (List.rev_append (f x y) acc) xs ys
    | _, _ -> invalid_arg "Ext_list.flat_map2" in
  aux [] lx ly

let rec flat_map_aux f acc append lx =
  match lx with
  | [] -> List.rev_append acc append
  | y::ys -> flat_map_aux f (List.rev_append ( f y)  acc ) append ys 

let flat_map f lx =
  flat_map_aux f [] [] lx

let flat_map_acc f append lx = flat_map_aux f [] append lx  

let rec map2_last f l1 l2 =
  match (l1, l2) with
  | ([], []) -> []
  | [u], [v] -> [f true u v ]
  | (a1::l1, a2::l2) -> let r = f false  a1 a2 in r :: map2_last f l1 l2
  | (_, _) -> invalid_arg "Ext_list.map2_last"

let rec map_last f l1 =
  match l1 with
  | [] -> []
  | [u]-> [f true u ]
  | a1::l1 -> let r = f false  a1 in r :: map_last f l1


(* let rec fold_right2_last f l1 l2 accu  = 
  match (l1, l2) with
  | ([], []) -> accu
  | [last1], [last2] -> f true  last1 last2 accu
  | (a1::l1, a2::l2) -> f false a1 a2 (fold_right2_last f l1 l2 accu)
  | (_, _) -> invalid_arg "List.fold_right2" *)


let init n f = 
  Array.to_list (Array.init n f)

let take n l = 
  let arr = Array.of_list l in 
  let arr_length =  Array.length arr in
  if arr_length  < n then invalid_arg "Ext_list.take"
  else (Array.to_list (Array.sub arr 0 n ), 
        Array.to_list (Array.sub arr n (arr_length - n)))

(* let try_take n l = 
  let arr = Array.of_list l in 
  let arr_length =  Array.length arr in
  if arr_length  <= n then 
    l,  arr_length, []
  else Array.to_list (Array.sub arr 0 n ), n, (Array.to_list (Array.sub arr n (arr_length - n))) *)


let rec length_compare l n = 
  if n < 0 then `Gt 
  else 
    begin match l with 
      | _ ::xs -> length_compare xs (n - 1)
      | [] ->  
        if n = 0 then `Eq 
        else `Lt 
    end

let rec length_ge l n =   
  if n > 0 then
    match l with 
    | _ :: tl -> length_ge tl (n - 1)
    | [] -> false
  else true
(**

   {[length xs = length ys + n ]}
*)
let rec length_larger_than_n n xs ys =
  match xs, ys with 
  | _, [] -> length_compare xs n = `Eq   
  | _::xs, _::ys -> 
    length_larger_than_n n xs ys
  | [], _ -> false 



let exclude_tail (x : 'a list) = 
  let rec aux acc x = 
    match x with 
    | [] -> invalid_arg "Ext_list.exclude_tail"
    | [ x ] ->  x, List.rev acc
    | y0::ys -> aux (y0::acc) ys in
  aux [] x

(* For small list, only need partial equality 
   {[
     group (=) [1;2;3;4;3]
     ;;
     - : int list list = [[3; 3]; [4]; [2]; [1]]
                         # group (=) [];;
     - : 'a list list = []
   ]}
*)
let rec group (cmp : 'a -> 'a -> bool) (lst : 'a list) : 'a list list =
  match lst with 
  | [] -> []
  | x::xs -> 
    aux cmp x (group cmp xs )

and aux cmp (x : 'a)  (xss : 'a list list) : 'a list list = 
  match xss with 
  | [] -> [[x]]
  | y::ys -> 
    if cmp x (List.hd y) (* cannot be null*) then
      (x::y) :: ys 
    else
      y :: aux cmp x ys                                 

 let stable_group cmp lst =  group cmp lst |> List.rev  

let rec drop n h = 
  if n < 0 then invalid_arg "Ext_list.drop"
  else if n = 0 then h 
  else if h = [] then invalid_arg "Ext_list.drop"
  else 
    drop (n - 1) (List.tl h)

let rec for_all_ret  p = function
  | [] -> None
  | a::l -> 
    if p a 
    then for_all_ret p l
    else Some a 



let fold f l init = 
  List.fold_left (fun acc i -> f  i init) init l 

let rev_map_acc  acc f l = 
  let rec rmap_f accu = function
    | [] -> accu
    | a::l -> rmap_f (f a :: accu) l
  in
  rmap_f acc l

let rec map_acc acc f l =   
  match l with 
  | [] -> acc 
  | h::hs -> f h :: map_acc  acc  f hs 



let rec rev_iter f xs =
  match xs with    
  | [] -> ()
  | y :: ys -> 
    rev_iter f ys ;
    f y      

let rec for_all2_no_exn p l1 l2 = 
  match (l1, l2) with
  | ([], []) -> true
  | (a1::l1, a2::l2) -> p a1 a2 && for_all2_no_exn p l1 l2
  | (_, _) -> false


let rec find_no_exn p = function
  | [] -> None
  | x :: l -> if p x then Some x else find_no_exn p l


let rec find_opt p = function
  | [] -> None
  | x :: l -> 
    match  p x with 
    | Some _ as v  ->  v
    | None -> find_opt p l


let split_map 
    ( f : 'a -> ('b * 'c)) (xs : 'a list ) : 'b list  * 'c list = 
  let rec aux bs cs xs =
    match xs with 
    | [] -> List.rev bs, List.rev cs 
    | u::us -> 
      let b,c =  f u in aux (b::bs) (c ::cs) us in 

  aux [] [] xs 


(*
   {[
     reduce_from_right (-) [1;2;3];;
     - : int = 2
               # reduce_from_right (-) [1;2;3; 4];;
     - : int = -2
                # reduce_from_right (-) [1];;
     - : int = 1
               # reduce_from_right (-) [1;2;3; 4; 5];;
     - : int = 3
   ]} 
*)
let reduce_from_right fn lst = 
  begin match List.rev lst with
    | last :: rest -> 
      List.fold_left  (fun x y -> fn y x) last rest 
    | _ -> invalid_arg "Ext_list.reduce" 
  end
let reduce_from_left fn lst = 
  match lst with 
  | first :: rest ->  List.fold_left fn first rest 
  | _ -> invalid_arg "Ext_list.reduce_from_left"


type 'a t = 'a list ref

let create_ref_empty () = ref []

let ref_top x = 
  match !x with 
  | y::_ -> y 
  | _ -> invalid_arg "Ext_list.ref_top"

let ref_empty x = 
  match !x with [] -> true | _ -> false 

let ref_push x refs = 
  refs := x :: !refs

let ref_pop refs = 
  match !refs with 
  | [] -> invalid_arg "Ext_list.ref_pop"
  | x::rest -> 
    refs := rest ; 
    x     

let rev_except_last xs =
  let rec aux acc xs =
    match xs with
    | [ ] -> invalid_arg "Ext_list.rev_except_last"
    | [ x ] -> acc ,x
    | x :: xs -> aux (x::acc) xs in
  aux [] xs   

let sort_via_array cmp lst =
  let arr = Array.of_list lst  in
  Array.sort cmp arr;
  Array.to_list arr

let rec last xs =
  match xs with 
  | [x] -> x 
  | _ :: tl -> last tl 
  | [] -> invalid_arg "Ext_list.last"


let rec assoc_by_string def (k : string) lst = 
  match lst with 
  | [] -> 
    begin match def with 
      | None -> assert false 
      | Some x -> x end
  | (k1,v1)::rest -> 
    if Ext_string.equal k1 k then v1 else 
      assoc_by_string def k rest 

let rec assoc_by_int def (k : int) lst = 
  match lst with 
  | [] -> 
    begin match def with
      | None -> assert false 
      | Some x -> x end
  | (k1,v1)::rest -> 
    if k1 = k then v1 else 
      assoc_by_int def k rest     

(** `modulo [1;2;3;4] [1;2;3]` => [1;2;3], Some [4] `
    modulo [1;2;3] [1;2;3;4] => [1;2;3] None 
    modulo [1;2;3] [1;2;3] => [1;2;3] Some []
*)


let nth_opt l n =
  if n < 0 then None else
    let rec nth_aux l n =
      match l with
      | [] -> None
      | a::l -> if n = 0 then Some a else nth_aux l (n-1)
    in nth_aux l n
end
module Ext_pervasives : sig 
#1 "ext_pervasives.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Extension to standard library [Pervavives] module, safe to open 
  *)

external reraise: exn -> 'a = "%reraise"

val finally : 'a -> ('a -> 'c) -> ('a -> 'b) -> 'b

val with_file_as_chan : string -> (out_channel -> 'a) -> 'a

val with_file_as_pp : string -> (Format.formatter -> 'a) -> 'a

val is_pos_pow : Int32.t -> int

val failwithf : loc:string -> ('a, unit, string, 'b) format4 -> 'a

val invalid_argf : ('a, unit, string, 'b) format4 -> 'a

val bad_argf : ('a, unit, string, 'b) format4 -> 'a



val dump : 'a -> string 
val pp_any : Format.formatter -> 'a -> unit 
external id : 'a -> 'a = "%identity"

(** Copied from {!Btype.hash_variant}:
    need sync up and add test case
 *)
val hash_variant : string -> int

end = struct
#1 "ext_pervasives.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






external reraise: exn -> 'a = "%reraise"

let finally v action f   = 
  match f v with
  | exception e -> 
      action v ;
      reraise e 
  | e ->  action v ; e 

let with_file_as_chan filename f = 
  finally (open_out_bin filename) close_out f 

let with_file_as_pp filename f = 
  finally (open_out_bin filename) close_out
    (fun chan -> 
      let fmt = Format.formatter_of_out_channel chan in
      let v = f  fmt in
      Format.pp_print_flush fmt ();
      v
    ) 


let  is_pos_pow n = 
  let module M = struct exception E end in 
  let rec aux c (n : Int32.t) = 
    if n <= 0l then -2 
    else if n = 1l then c 
    else if Int32.logand n 1l =  0l then   
      aux (c + 1) (Int32.shift_right n 1 )
    else raise M.E in 
  try aux 0 n  with M.E -> -1

let failwithf ~loc fmt = Format.ksprintf (fun s -> failwith (loc ^ s))
    fmt
    
let invalid_argf fmt = Format.ksprintf invalid_arg fmt

let bad_argf fmt = Format.ksprintf (fun x -> raise (Arg.Bad x ) ) fmt


let rec dump r =
  if Obj.is_int r then
    string_of_int (Obj.magic r : int)
  else (* Block. *)
    let rec get_fields acc = function
      | 0 -> acc
      | n -> let n = n-1 in get_fields (Obj.field r n :: acc) n
    in
    let rec is_list r =
      if Obj.is_int r then
        r = Obj.repr 0 (* [] *)
      else
        let s = Obj.size r and t = Obj.tag r in
        t = 0 && s = 2 && is_list (Obj.field r 1) (* h :: t *)
    in
    let rec get_list r =
      if Obj.is_int r then
        []
      else
        let h = Obj.field r 0 and t = get_list (Obj.field r 1) in
        h :: t
    in
    let opaque name =
      (* XXX In future, print the address of value 'r'.  Not possible
       * in pure OCaml at the moment.  *)
      "<" ^ name ^ ">"
    in
    let s = Obj.size r and t = Obj.tag r in
    (* From the tag, determine the type of block. *)
    match t with
    | _ when is_list r ->
      let fields = get_list r in
      "[" ^ String.concat "; " (Ext_list.map dump fields) ^ "]"
    | 0 ->
      let fields = get_fields [] s in
      "(" ^ String.concat ", " (Ext_list.map dump fields) ^ ")"
    | x when x = Obj.lazy_tag ->
      (* Note that [lazy_tag .. forward_tag] are < no_scan_tag.  Not
         * clear if very large constructed values could have the same
         * tag. XXX *)
      opaque "lazy"
    | x when x = Obj.closure_tag ->
      opaque "closure"
    | x when x = Obj.object_tag ->
      let fields = get_fields [] s in
      let _clasz, id, slots =
        match fields with
        | h::h'::t -> h, h', t
        | _ -> assert false
      in
      (* No information on decoding the class (first field).  So just print
         * out the ID and the slots. *)
      "Object #" ^ dump id ^ " (" ^ String.concat ", " (Ext_list.map dump slots) ^ ")"
    | x when x = Obj.infix_tag ->
      opaque "infix"
    | x when x = Obj.forward_tag ->
      opaque "forward"
    | x when x < Obj.no_scan_tag ->
      let fields = get_fields [] s in
      "Tag" ^ string_of_int t ^
      " (" ^ String.concat ", " (Ext_list.map dump fields) ^ ")"
    | x when x = Obj.string_tag ->
      "\"" ^ String.escaped (Obj.magic r : string) ^ "\""
    | x when x = Obj.double_tag ->
      string_of_float (Obj.magic r : float)
    | x when x = Obj.abstract_tag ->
      opaque "abstract"
    | x when x = Obj.custom_tag ->
      opaque "custom"
    | x when x = Obj.custom_tag ->
      opaque "final"
    | x when x = Obj.double_array_tag ->
      "[|"^
      String.concat ";"
        (Array.to_list (Array.map string_of_float (Obj.magic r : float array))) ^
      "|]"
    | _ ->
      opaque (Printf.sprintf "unknown: tag %d size %d" t s)

let dump v = dump (Obj.repr v)

let pp_any fmt v = 
  Format.fprintf fmt "@[%s@]"
  (dump v )
external id : 'a -> 'a = "%identity"


let hash_variant s =
  let accu = ref 0 in
  for i = 0 to String.length s - 1 do
    accu := 223 * !accu + Char.code s.[i]
  done;
  (* reduce to 31 bits *)
  accu := !accu land (1 lsl 31 - 1);
  (* make it signed for 64 bits architectures *)
  if !accu > 0x3FFFFFFF then !accu - (1 lsl 31) else !accu


end
module Literals : sig 
#1 "literals.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






val js_array_ctor : string 
val js_type_number : string
val js_type_string : string
val js_type_object : string
val js_undefined : string
val js_prop_length : string

val param : string
val partial_arg : string
val prim : string

(**temporary varaible used in {!Js_ast_util} *)
val tmp : string 

val create : string 

val app : string
val app_array : string

val runtime : string
val stdlib : string
val imul : string

val setter_suffix : string
val setter_suffix_len : int


val debugger : string
val raw_expr : string
val raw_stmt : string
val unsafe_downgrade : string
val fn_run : string
val method_run : string
val fn_method : string
val fn_mk : string

(** callback actually, not exposed to user yet *)
(* val js_fn_runmethod : string *)

val bs_deriving : string
val bs_deriving_dot : string
val bs_type : string

(** nodejs *)

val node_modules : string
val node_modules_length : int
val package_json : string
val bsconfig_json : string
val build_ninja : string

(* Name of the library file created for each external dependency. *)
val library_file : string

val suffix_a : string
val suffix_cmj : string
val suffix_cmo : string
val suffix_cma : string
val suffix_cmi : string
val suffix_cmx : string
val suffix_cmxa : string
val suffix_ml : string
val suffix_mlast : string 
val suffix_mlast_simple : string
val suffix_mliast : string
val suffix_mliast_simple : string
val suffix_mlmap : string
val suffix_mll : string
val suffix_re : string
val suffix_rei : string 

val suffix_d : string
val suffix_mlastd : string
val suffix_mliastd : string
val suffix_js : string
val suffix_mli : string 
val suffix_cmt : string 
val suffix_cmti : string 

val commonjs : string 
val amdjs : string 
val es6 : string 
val es6_global : string
val amdjs_global : string 
val unused_attribute : string 
val dash_nostdlib : string

val reactjs_jsx_ppx_exe : string 
val reactjs_jsx_ppx_2_exe : string 
val unescaped_j_delimiter : string 
val escaped_j_delimiter : string 

val unescaped_js_delimiter : string 

val native : string
val bytecode : string
val js : string

val node_sep : string 
val node_parent : string 
val node_current : string 
end = struct
#1 "literals.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)







let js_array_ctor = "Array"
let js_type_number = "number"
let js_type_string = "string"
let js_type_object = "object" 
let js_undefined = "undefined"
let js_prop_length = "length"

let prim = "prim"
let param = "param"
let partial_arg = "partial_arg"
let tmp = "tmp"

let create = "create" (* {!Caml_exceptions.create}*)

let app = "_"
let app_array = "app" (* arguments are an array*)

let runtime = "runtime" (* runtime directory *)

let stdlib = "stdlib"

let imul = "imul" (* signed int32 mul *)

let setter_suffix = "#="
let setter_suffix_len = String.length setter_suffix

let debugger = "debugger"
let raw_expr = "raw_expr"
let raw_stmt = "raw_stmt"
let unsafe_downgrade = "unsafe_downgrade"
let fn_run = "fn_run"
let method_run = "method_run"

let fn_method = "fn_method"
let fn_mk = "fn_mk"
(*let js_fn_runmethod = "js_fn_runmethod"*)

let bs_deriving = "bs.deriving"
let bs_deriving_dot = "bs.deriving."
let bs_type = "bs.type"


(** nodejs *)
let node_modules = "node_modules"
let node_modules_length = String.length "node_modules"
let package_json = "package.json"
let bsconfig_json = "bsconfig.json"
let build_ninja = "build.ninja"

(* Name of the library file created for each external dependency. *)
let library_file = "lib"

let suffix_a = ".a"
let suffix_cmj = ".cmj"
let suffix_cmo = ".cmo"
let suffix_cma = ".cma"
let suffix_cmi = ".cmi"
let suffix_cmx = ".cmx"
let suffix_cmxa = ".cmxa"
let suffix_mll = ".mll"
let suffix_ml = ".ml"
let suffix_mli = ".mli"
let suffix_re = ".re"
let suffix_rei = ".rei"
let suffix_mlmap = ".mlmap"

let suffix_cmt = ".cmt" 
let suffix_cmti = ".cmti" 
let suffix_mlast = ".mlast"
let suffix_mlast_simple = ".mlast_simple"
let suffix_mliast = ".mliast"
let suffix_mliast_simple = ".mliast_simple"
let suffix_d = ".d"
let suffix_mlastd = ".mlast.d"
let suffix_mliastd = ".mliast.d"
let suffix_js = ".js"

let commonjs = "commonjs" 
let amdjs = "amdjs"
let es6 = "es6"
let es6_global = "es6-global"
let amdjs_global = "amdjs-global"
let unused_attribute = "Unused attribute " 
let dash_nostdlib = "-nostdlib"

let reactjs_jsx_ppx_exe  = "reactjs_jsx_ppx.exe"
let reactjs_jsx_ppx_2_exe = "reactjs_jsx_ppx_2.exe"
let unescaped_j_delimiter = "j"
let unescaped_js_delimiter = "js"
let escaped_j_delimiter =  "*j" (* not user level syntax allowed *)

let native = "native"
let bytecode = "bytecode"
let js = "js"



(** Used when produce node compatible paths *)
let node_sep = "/"
let node_parent = ".."
let node_current = "."


end
module Ext_path : sig 
#1 "ext_path.mli"
(* Copyright (C) 2017 Authors of BuckleScript
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type t 





(**
   1. add some simplifications when concatenating
   2. when the second one is absolute, drop the first one
*)  
val combine : 
  string -> 
  string -> 
  string    



val chop_extension : ?loc:string -> string -> string 


val chop_extension_if_any : string -> string


(**
   {[
     get_extension "a.txt" = ".txt"
       get_extension "a" = ""
   ]}
*)
val get_extension : string -> string




val node_rebase_file :
  from:string -> 
  to_:string ->
  string -> 
  string 

(** 
   TODO: could be highly optimized
   if [from] and [to] resolve to the same path, a zero-length string is returned 
   Given that two paths are directory

   A typical use case is 
   {[
     Filename.concat 
       (rel_normalized_absolute_path cwd (Filename.dirname a))
       (Filename.basename a)
   ]}
*)
val rel_normalized_absolute_path : from:string -> string -> string 


val normalize_absolute_path : string -> string 

val absolute_path : string Lazy.t -> string -> string


end = struct
#1 "ext_path.ml"
(* Copyright (C) 2017 Authors of BuckleScript
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type t = 
  | File of string 
  | Dir of string 





let sep_char = String.unsafe_get Filename.dir_sep 0 


(** example
    {[
      "/bb/mbigc/mbig2899/bgit/bucklescript/jscomp/stdlib/external/pervasives.cmj"
        "/bb/mbigc/mbig2899/bgit/bucklescript/jscomp/stdlib/ocaml_array.ml"
    ]}

    The other way
    {[

      "/bb/mbigc/mbig2899/bgit/bucklescript/jscomp/stdlib/ocaml_array.ml"
        "/bb/mbigc/mbig2899/bgit/bucklescript/jscomp/stdlib/external/pervasives.cmj"
    ]}
    {[
      "/bb/mbigc/mbig2899/bgit/bucklescript/jscomp/stdlib//ocaml_array.ml"
    ]}
    {[
      /a/b
      /c/d
    ]}
*)
let node_relative_path 
    ~from:(file_or_dir_2 : t )
    (file_or_dir_1 : t) 
  = 
  let relevant_dir1 = 
    match file_or_dir_1 with 
    | Dir x -> x 
    | File file1 ->  Filename.dirname file1 in
  let relevant_dir2 = 
    match file_or_dir_2 with 
    | Dir x -> x 
    | File file2 -> Filename.dirname file2  in
  let dir1 = Ext_string.split relevant_dir1 sep_char   in
  let dir2 = Ext_string.split relevant_dir2 sep_char  in
  let rec go (dir1 : string list) (dir2 : string list) = 
    match dir1, dir2 with 
    | "." :: xs, ys -> go xs ys 
    | xs , "." :: ys -> go xs ys 
    | x::xs , y :: ys when x = y
      -> go xs ys 
    | _, _ -> 
      Ext_list.append (Ext_list.map (fun _ ->  Literals.node_parent) dir2)  dir1 
  in
  match go dir1 dir2 with
  | (x :: _ ) as ys when x = Literals.node_parent -> 
    String.concat Literals.node_sep ys
  | ys -> 
    String.concat Literals.node_sep  
    @@ Literals.node_current :: ys


let node_concat ~dir base =
  dir ^ Literals.node_sep ^ base 

let node_rebase_file ~from ~to_ file = 
  
  node_concat
    ~dir:(
      if from = to_ then Literals.node_current
      else node_relative_path ~from:(Dir from) (Dir to_)) 
    file
    
    
(***
   {[
     Filename.concat "." "";;
     "./"
   ]}
*)
let combine path1 path2 =  
  if Filename.is_relative path2 then
    if Ext_string.is_empty path2 then 
      path1
    else 
    if path1 = Filename.current_dir_name then 
      path2
    else
    if path2 = Filename.current_dir_name 
    then path1
    else
      Filename.concat path1 path2 
  else
    path2


let chop_extension ?(loc="") name =
  try Filename.chop_extension name 
  with Invalid_argument _ -> 
    Ext_pervasives.invalid_argf 
      "Filename.chop_extension ( %s : %s )"  loc name

let chop_extension_if_any fname =
  try Filename.chop_extension fname with Invalid_argument _ -> fname

let get_extension x =
  let pos = Ext_string.rindex_neg x '.' in 
  if pos < 0 then ""
  else Ext_string.tail_from x pos 


let (//) x y =
  if x = Filename.current_dir_name then y
  else if y = Filename.current_dir_name then x 
  else Filename.concat x y 

(**
   {[
     split_aux "//ghosg//ghsogh/";;
     - : string * string list = ("/", ["ghosg"; "ghsogh"])
   ]}
   Note that 
   {[
     Filename.dirname "/a/" = "/"
       Filename.dirname "/a/b/" = Filename.dirname "/a/b" = "/a"
   ]}
   Special case:
   {[
     basename "//" = "/"
       basename "///"  = "/"
   ]}
   {[
     basename "" =  "."
       basename "" = "."
       dirname "" = "."
       dirname "" =  "."
   ]}  
*)
let split_aux p =
  let rec go p acc =
    let dir = Filename.dirname p in
    if dir = p then dir, acc
    else
      let new_path = Filename.basename p in 
      if Ext_string.equal new_path Filename.dir_sep then 
        go dir acc 
        (* We could do more path simplification here
           leave to [rel_normalized_absolute_path]
        *)
      else 
        go dir (new_path :: acc)

  in go p []





(** 
   TODO: optimization
   if [from] and [to] resolve to the same path, a zero-length string is returned 

   This function is useed in [es6-global] and 
   [amdjs-global] format and tailored for `rollup`
*)
let rel_normalized_absolute_path ~from to_ =
  let root1, paths1 = split_aux from in 
  let root2, paths2 = split_aux to_ in 
  if root1 <> root2 then root2
  else
    let rec go xss yss =
      match xss, yss with 
      | x::xs, y::ys -> 
        if Ext_string.equal x  y then go xs ys 
        else if x = Filename.current_dir_name then go xs yss 
        else if y = Filename.current_dir_name then go xss ys
        else 
          let start = 
            List.fold_left (fun acc _ -> acc // Ext_string.parent_dir_lit )
              Ext_string.parent_dir_lit  xs in 
          List.fold_left (fun acc v -> acc // v) start yss
      | [], [] -> Ext_string.empty
      | [], y::ys -> List.fold_left (fun acc x -> acc // x) y ys
      | x::xs, [] ->
        List.fold_left (fun acc _ -> acc // Ext_string.parent_dir_lit )
          Ext_string.parent_dir_lit xs in
    let v =  go paths1 paths2  in 

    if Ext_string.is_empty v then  Literals.node_current
    else 
    if
      v = "."
      || v = ".."
      || Ext_string.starts_with v "./"  
      || Ext_string.starts_with v "../" 
    then v 
    else "./" ^ v 

(*TODO: could be hgighly optimized later 
  {[
    normalize_absolute_path "/gsho/./..";;

    normalize_absolute_path "/a/b/../c../d/e/f";;

    normalize_absolute_path "/gsho/./..";;

    normalize_absolute_path "/gsho/./../..";;

    normalize_absolute_path "/a/b/c/d";;

    normalize_absolute_path "/a/b/c/d/";;

    normalize_absolute_path "/a/";;

    normalize_absolute_path "/a";;
  ]}
*)
(** See tests in {!Ounit_path_tests} *)
let normalize_absolute_path x =
  let drop_if_exist xs =
    match xs with 
    | [] -> []
    | _ :: xs -> xs in 
  let rec normalize_list acc paths =
    match paths with 
    | [] -> acc 
    | x :: xs -> 
      if Ext_string.equal x Ext_string.current_dir_lit then 
        normalize_list acc xs 
      else if Ext_string.equal x Ext_string.parent_dir_lit then 
        normalize_list (drop_if_exist acc ) xs 
      else   
        normalize_list (x::acc) xs 
  in
  let root, paths = split_aux x in
  let rev_paths =  normalize_list [] paths in 
  let rec go acc rev_paths =
    match rev_paths with 
    | [] -> Filename.concat root acc 
    | last::rest ->  go (Filename.concat last acc ) rest  in 
  match rev_paths with 
  | [] -> root 
  | last :: rest -> go last rest 




let absolute_path cwd s = 
  let process s = 
    let s = 
      if Filename.is_relative s then
        Lazy.force cwd // s 
      else s in
    (* Now simplify . and .. components *)
    let rec aux s =
      let base,dir  = Filename.basename s, Filename.dirname s  in
      if dir = s then dir
      else if base = Filename.current_dir_name then aux dir
      else if base = Filename.parent_dir_name then Filename.dirname (aux dir)
      else aux dir // base
    in aux s  in 
  process s 


let absolute cwd s =   
  match s with 
  | File x -> File (absolute_path cwd x )
  | Dir x -> Dir (absolute_path cwd x)

end
module Ext_modulename : sig 
#1 "ext_modulename.mli"
(* Copyright (C) 2017 Authors of BuckleScript
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)




val module_name_of_file : string -> string


val module_name_of_file_if_any : string -> string

(** [modulename, upper]
  if [upper = true] then it means it is indeed uppercase
*)
val module_name_of_file_if_any_with_upper : string -> string * bool
end = struct
#1 "ext_modulename.ml"
(* Copyright (C) 2017 Authors of BuckleScript
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


 let module_name_of_file file =
  Ext_string.capitalize_ascii 
    (Filename.chop_extension @@ Filename.basename file)  

let module_name_of_file_if_any file = 
  let v = Ext_path.chop_extension_if_any @@ Filename.basename file in
  Ext_string.capitalize_ascii v 
    
let module_name_of_file_if_any_with_upper file = 
  let v = Ext_path.chop_extension_if_any @@ Filename.basename file in
  let res = Ext_string.capitalize_ascii v in 
  res, res == v 

end
module Ml_binary : sig 
#1 "ml_binary.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)



type _ kind = 
  | Ml : Parsetree.structure kind 
  | Mli : Parsetree.signature kind


val read_ast : 'a kind -> in_channel -> 'a 

val write_ast :
   'a kind -> string -> 'a -> out_channel -> unit
end = struct
#1 "ml_binary.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


type _ kind = 
  | Ml : Parsetree.structure kind 
  | Mli : Parsetree.signature kind

(** [read_ast kind ic] assume [ic] channel is 
    in the right position *)
let read_ast (type t ) (kind : t  kind) ic : t  =
  let magic =
    match kind with 
    | Ml -> Config.ast_impl_magic_number
    | Mli -> Config.ast_intf_magic_number in 
  let buffer = really_input_string ic (String.length magic) in
  assert(buffer = magic); (* already checked by apply_rewriter *)
  Location.input_name := input_value ic;
  input_value ic 

let write_ast (type t) (kind : t kind) 
    (fname : string)
    (pt : t) oc = 
  let magic = 
    match kind with 
    | Ml -> Config.ast_impl_magic_number
    | Mli -> Config.ast_intf_magic_number in
  output_string oc magic ;
  output_value oc fname;
  output_value oc pt
end
module Bs_hash_stubs
= struct
#1 "bs_hash_stubs.ml"


external hash_string :  string -> int = "caml_bs_hash_string" "noalloc";;

external hash_string_int :  string -> int  -> int = "caml_bs_hash_string_and_int" "noalloc";;

external hash_string_small_int :  string -> int  -> int = "caml_bs_hash_string_and_small_int" "noalloc";;

external hash_stamp_and_name : int -> string -> int = "caml_bs_hash_stamp_and_name" "noalloc";;

external hash_small_int : int -> int = "caml_bs_hash_small_int" "noalloc";;

external hash_int :  int  -> int = "caml_bs_hash_int" "noalloc";;

external string_length_based_compare : string -> string -> int  = "caml_string_length_based_compare" "noalloc";;


external    
    int_unsafe_blit : 
    int array -> int -> int array -> int -> int -> unit = "caml_int_array_blit" "noalloc";;
    

end
module Ext_util : sig 
#1 "ext_util.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


 
val power_2_above : int -> int -> int


val stats_to_string : Hashtbl.statistics -> string 
end = struct
#1 "ext_util.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

(**
   {[
     (power_2_above 16 63 = 64)
       (power_2_above 16 76 = 128)
   ]}
*)
let rec power_2_above x n =
  if x >= n then x
  else if x * 2 > Sys.max_array_length then x
  else power_2_above (x * 2) n


let stats_to_string ({num_bindings; num_buckets; max_bucket_length; bucket_histogram} : Hashtbl.statistics) = 
  Printf.sprintf 
    "bindings: %d,buckets: %d, longest: %d, hist:[%s]" 
    num_bindings 
    num_buckets 
    max_bucket_length
    (String.concat "," (Array.to_list (Array.map string_of_int bucket_histogram)))
end
module Hashtbl_gen
= struct
#1 "hashtbl_gen.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the GNU Library General Public License, with    *)
(*  the special exception on linking described in file ../LICENSE.     *)
(*                                                                     *)
(***********************************************************************)

(* Hash tables *)



module type S = sig 
  type key
  type 'a t
  val create: int -> 'a t
  val clear: 'a t -> unit
  val reset: 'a t -> unit
  val copy: 'a t -> 'a t
  val add: 'a t -> key -> 'a -> unit
  val modify_or_init: 'a t -> key -> ('a -> unit) -> (unit -> 'a) -> unit 
  val remove: 'a t -> key -> unit
  val find_exn: 'a t -> key -> 'a
  val find_all: 'a t -> key -> 'a list
  val find_opt: 'a t -> key  -> 'a option
  
  (** return the key found in the hashtbl.
    Use case: when you find the key existed in hashtbl, 
    you want to use the one stored in the hashtbl. 
    (they are semantically equivlanent, but may have other information different) 
   *)
  val find_key_opt: 'a t -> key -> key option 

  val find_default: 'a t -> key -> 'a -> 'a 

  val replace: 'a t -> key -> 'a -> unit
  val mem: 'a t -> key -> bool
  val iter: (key -> 'a -> unit) -> 'a t -> unit
  val fold: (key -> 'a -> 'b -> 'b) -> 'a t -> 'b -> 'b
  val length: 'a t -> int
  val stats: 'a t -> Hashtbl.statistics
  val of_list2: key list -> 'a list -> 'a t
end

(* We do dynamic hashing, and resize the table and rehash the elements
   when buckets become too long. *)

type ('a, 'b) t =
  { mutable size: int;                        (* number of entries *)
    mutable data: ('a, 'b) bucketlist array;  (* the buckets *)
    mutable seed: int;                        (* for randomization *)
    initial_size: int;                        (* initial array size *)
  }

and ('a, 'b) bucketlist =
  | Empty
  | Cons of 'a * 'b * ('a, 'b) bucketlist


let create  initial_size =
  let s = Ext_util.power_2_above 16 initial_size in
  { initial_size = s; size = 0; seed = 0; data = Array.make s Empty }

let clear h =
  h.size <- 0;
  let len = Array.length h.data in
  for i = 0 to len - 1 do
    h.data.(i) <- Empty
  done

let reset h =
  h.size <- 0;
  h.data <- Array.make h.initial_size Empty


let copy h = { h with data = Array.copy h.data }

let length h = h.size

let resize indexfun h =
  let odata = h.data in
  let osize = Array.length odata in
  let nsize = osize * 2 in
  if nsize < Sys.max_array_length then begin
    let ndata = Array.make nsize Empty in
    h.data <- ndata;          (* so that indexfun sees the new bucket count *)
    let rec insert_bucket = function
        Empty -> ()
      | Cons(key, data, rest) ->
        insert_bucket rest; (* preserve original order of elements *)
        let nidx = indexfun h key in
        ndata.(nidx) <- Cons(key, data, ndata.(nidx)) in
    for i = 0 to osize - 1 do
      insert_bucket (Array.unsafe_get odata i)
    done
  end



let iter f h =
  let rec do_bucket = function
    | Empty ->
      ()
    | Cons(k, d, rest) ->
      f k d; do_bucket rest in
  let d = h.data in
  for i = 0 to Array.length d - 1 do
    do_bucket (Array.unsafe_get d i)
  done

let fold f h init =
  let rec do_bucket b accu =
    match b with
      Empty ->
      accu
    | Cons(k, d, rest) ->
      do_bucket rest (f k d accu) in
  let d = h.data in
  let accu = ref init in
  for i = 0 to Array.length d - 1 do
    accu := do_bucket d.(i) !accu
  done;
  !accu

let rec bucket_length accu = function
  | Empty -> accu
  | Cons(_, _, rest) -> bucket_length (accu + 1) rest

let stats h =
  let mbl =
    Array.fold_left (fun m b -> max m (bucket_length 0 b)) 0 h.data in
  let histo = Array.make (mbl + 1) 0 in
  Array.iter
    (fun b ->
       let l = bucket_length 0 b in
       histo.(l) <- histo.(l) + 1)
    h.data;
  {Hashtbl.
    num_bindings = h.size;
    num_buckets = Array.length h.data;
    max_bucket_length = mbl;
    bucket_histogram = histo }



let rec small_bucket_mem eq key (lst : _ bucketlist) =
  match lst with 
  | Empty -> false 
  | Cons(k1,_,rest1) -> 
    eq  key k1 ||
    match rest1 with
    | Empty -> false 
    | Cons(k2,_,rest2) -> 
      eq key k2  || 
      match rest2 with 
      | Empty -> false 
      | Cons(k3,_,rest3) -> 
        eq key k3  ||
        small_bucket_mem eq key rest3 


let rec small_bucket_opt eq key (lst : _ bucketlist) : _ option =
  match lst with 
  | Empty -> None 
  | Cons(k1,d1,rest1) -> 
    if eq  key k1 then Some d1 else 
      match rest1 with
      | Empty -> None 
      | Cons(k2,d2,rest2) -> 
        if eq key k2 then Some d2 else 
          match rest2 with 
          | Empty -> None 
          | Cons(k3,d3,rest3) -> 
            if eq key k3  then Some d3 else 
              small_bucket_opt eq key rest3 


let rec small_bucket_key_opt eq key (lst : _ bucketlist) : _ option =
  match lst with 
  | Empty -> None 
  | Cons(k1,d1,rest1) -> 
    if eq  key k1 then Some k1 else 
      match rest1 with
      | Empty -> None 
      | Cons(k2,d2,rest2) -> 
        if eq key k2 then Some k2 else 
          match rest2 with 
          | Empty -> None 
          | Cons(k3,d3,rest3) -> 
            if eq key k3  then Some k3 else 
              small_bucket_key_opt eq key rest3


let rec small_bucket_default eq key default (lst : _ bucketlist) =
  match lst with 
  | Empty -> default 
  | Cons(k1,d1,rest1) -> 
    if eq  key k1 then  d1 else 
      match rest1 with
      | Empty -> default 
      | Cons(k2,d2,rest2) -> 
        if eq key k2 then  d2 else 
          match rest2 with 
          | Empty -> default 
          | Cons(k3,d3,rest3) -> 
            if eq key k3  then  d3 else 
              small_bucket_default eq key default rest3 

end
module String_hashtbl : sig 
#1 "string_hashtbl.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


include Hashtbl_gen.S with type key = string




end = struct
#1 "string_hashtbl.ml"
# 9 "ext/hashtbl.cppo.ml"
type key = string
type 'a t = (key, 'a)  Hashtbl_gen.t 
let key_index (h : _ t ) (key : key) =
  (Bs_hash_stubs.hash_string  key ) land (Array.length h.data - 1)
let eq_key = Ext_string.equal 

# 33
type ('a, 'b) bucketlist = ('a,'b) Hashtbl_gen.bucketlist
let create = Hashtbl_gen.create
let clear = Hashtbl_gen.clear
let reset = Hashtbl_gen.reset
let copy = Hashtbl_gen.copy
let iter = Hashtbl_gen.iter
let fold = Hashtbl_gen.fold
let length = Hashtbl_gen.length
let stats = Hashtbl_gen.stats



let add (h : _ t) key info =
  let i = key_index h key in
  let h_data = h.data in   
  Array.unsafe_set h_data i (Cons(key, info, (Array.unsafe_get h_data i)));
  h.size <- h.size + 1;
  if h.size > Array.length h_data lsl 1 then Hashtbl_gen.resize key_index h

(* after upgrade to 4.04 we should provide an efficient [replace_or_init] *)
let modify_or_init (h : _ t) key modf default =
  let rec find_bucket (bucketlist : _ bucketlist)  =
    match bucketlist with
    | Cons(k,i,next) ->
      if eq_key k key then begin modf i; false end
      else find_bucket next 
    | Empty -> true in
  let i = key_index h key in 
  let h_data = h.data in 
  if find_bucket (Array.unsafe_get h_data i) then
    begin 
      Array.unsafe_set h_data i  (Cons(key,default (), Array.unsafe_get h_data i));
      h.size <- h.size + 1 ;
      if h.size > Array.length h_data lsl 1 then Hashtbl_gen.resize key_index h 
    end


let rec remove_bucket key (h : _ t) (bucketlist : _ bucketlist) : _ bucketlist = 
  match bucketlist with  
  | Empty ->
    Empty
  | Cons(k, i, next) ->
    if eq_key k key 
    then begin h.size <- h.size - 1; next end
    else Cons(k, i, remove_bucket key h next) 

let remove (h : _ t ) key =
  let i = key_index h key in
  let h_data = h.data in 
  let old_h_szie = h.size in 
  let new_bucket = remove_bucket key h (Array.unsafe_get h_data i) in  
  if old_h_szie <> h.size then 
    Array.unsafe_set h_data i  new_bucket

let rec find_rec key (bucketlist : _ bucketlist) = match bucketlist with  
  | Empty ->
    raise Not_found
  | Cons(k, d, rest) ->
    if eq_key key k then d else find_rec key rest

let find_exn (h : _ t) key =
  match Array.unsafe_get h.data (key_index h key) with
  | Empty -> raise Not_found
  | Cons(k1, d1, rest1) ->
    if eq_key key k1 then d1 else
      match rest1 with
      | Empty -> raise Not_found
      | Cons(k2, d2, rest2) ->
        if eq_key key k2 then d2 else
          match rest2 with
          | Empty -> raise Not_found
          | Cons(k3, d3, rest3) ->
            if eq_key key k3  then d3 else find_rec key rest3

let find_opt (h : _ t) key =
  Hashtbl_gen.small_bucket_opt eq_key key (Array.unsafe_get h.data (key_index h key))

let find_key_opt (h : _ t) key =
  Hashtbl_gen.small_bucket_key_opt eq_key key (Array.unsafe_get h.data (key_index h key))
  
let find_default (h : _ t) key default = 
  Hashtbl_gen.small_bucket_default eq_key key default (Array.unsafe_get h.data (key_index h key))
let find_all (h : _ t) key =
  let rec find_in_bucket (bucketlist : _ bucketlist) = match bucketlist with 
    | Empty ->
      []
    | Cons(k, d, rest) ->
      if eq_key k key 
      then d :: find_in_bucket rest
      else find_in_bucket rest in
  find_in_bucket (Array.unsafe_get h.data (key_index h key))

let replace h key info =
  let rec replace_bucket (bucketlist : _ bucketlist) : _ bucketlist = match bucketlist with 
    | Empty ->
      raise_notrace Not_found
    | Cons(k, i, next) ->
      if eq_key k key
      then Cons(key, info, next)
      else Cons(k, i, replace_bucket next) in
  let i = key_index h key in
  let h_data = h.data in 
  let l = Array.unsafe_get h_data i in
  try
    Array.unsafe_set h_data i  (replace_bucket l)
  with Not_found ->
    begin 
      Array.unsafe_set h_data i (Cons(key, info, l));
      h.size <- h.size + 1;
      if h.size > Array.length h_data lsl 1 then Hashtbl_gen.resize key_index h;
    end 

let mem (h : _ t) key =
  let rec mem_in_bucket (bucketlist : _ bucketlist) = match bucketlist with 
    | Empty ->
      false
    | Cons(k, d, rest) ->
      eq_key k key  || mem_in_bucket rest in
  mem_in_bucket (Array.unsafe_get h.data (key_index h key))


let of_list2 ks vs = 
  let len = List.length ks in 
  let map = create len in 
  List.iter2 (fun k v -> add map k v) ks vs ; 
  map


end
module Map_gen
= struct
#1 "map_gen.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the GNU Library General Public License, with    *)
(*  the special exception on linking described in file ../LICENSE.     *)
(*                                                                     *)
(***********************************************************************)
(** adapted from stdlib *)

type ('key,'a) t =
  | Empty
  | Node of ('key,'a) t * 'key * 'a * ('key,'a) t * int

type ('key,'a) enumeration =
  | End
  | More of 'key * 'a * ('key,'a) t * ('key, 'a) enumeration

let rec cardinal_aux acc  = function
  | Empty -> acc 
  | Node (l,_,_,r, _) -> 
    cardinal_aux  (cardinal_aux (acc + 1)  r ) l 

let cardinal s = cardinal_aux 0 s 

let rec bindings_aux accu = function
  | Empty -> accu
  | Node(l, v, d, r, _) -> bindings_aux ((v, d) :: bindings_aux accu r) l

let bindings s =
  bindings_aux [] s

let rec keys_aux accu = function
    Empty -> accu
  | Node(l, v, _, r, _) -> keys_aux (v :: keys_aux accu r) l

let keys s = keys_aux [] s



let rec cons_enum m e =
  match m with
    Empty -> e
  | Node(l, v, d, r, _) -> cons_enum l (More(v, d, r, e))


let height = function
  | Empty -> 0
  | Node(_,_,_,_,h) -> h

let create l x d r =
  let hl = height l and hr = height r in
  Node(l, x, d, r, (if hl >= hr then hl + 1 else hr + 1))

let singleton x d = Node(Empty, x, d, Empty, 1)

let bal l x d r =
  let hl = match l with Empty -> 0 | Node(_,_,_,_,h) -> h in
  let hr = match r with Empty -> 0 | Node(_,_,_,_,h) -> h in
  if hl > hr + 2 then begin
    match l with
      Empty -> invalid_arg "Map.bal"
    | Node(ll, lv, ld, lr, _) ->
      if height ll >= height lr then
        create ll lv ld (create lr x d r)
      else begin
        match lr with
          Empty -> invalid_arg "Map.bal"
        | Node(lrl, lrv, lrd, lrr, _)->
          create (create ll lv ld lrl) lrv lrd (create lrr x d r)
      end
  end else if hr > hl + 2 then begin
    match r with
      Empty -> invalid_arg "Map.bal"
    | Node(rl, rv, rd, rr, _) ->
      if height rr >= height rl then
        create (create l x d rl) rv rd rr
      else begin
        match rl with
          Empty -> invalid_arg "Map.bal"
        | Node(rll, rlv, rld, rlr, _) ->
          create (create l x d rll) rlv rld (create rlr rv rd rr)
      end
  end else
    Node(l, x, d, r, (if hl >= hr then hl + 1 else hr + 1))

let empty = Empty

let is_empty = function Empty -> true | _ -> false

let rec min_binding_exn = function
    Empty -> raise Not_found
  | Node(Empty, x, d, r, _) -> (x, d)
  | Node(l, x, d, r, _) -> min_binding_exn l

let choose = min_binding_exn

let rec max_binding_exn = function
    Empty -> raise Not_found
  | Node(l, x, d, Empty, _) -> (x, d)
  | Node(l, x, d, r, _) -> max_binding_exn r

let rec remove_min_binding = function
    Empty -> invalid_arg "Map.remove_min_elt"
  | Node(Empty, x, d, r, _) -> r
  | Node(l, x, d, r, _) -> bal (remove_min_binding l) x d r

let merge t1 t2 =
  match (t1, t2) with
    (Empty, t) -> t
  | (t, Empty) -> t
  | (_, _) ->
    let (x, d) = min_binding_exn t2 in
    bal t1 x d (remove_min_binding t2)


let rec iter f = function
    Empty -> ()
  | Node(l, v, d, r, _) ->
    iter f l; f v d; iter f r

let rec map f = function
    Empty ->
    Empty
  | Node(l, v, d, r, h) ->
    let l' = map f l in
    let d' = f d in
    let r' = map f r in
    Node(l', v, d', r', h)

let rec mapi f = function
    Empty ->
    Empty
  | Node(l, v, d, r, h) ->
    let l' = mapi f l in
    let d' = f v d in
    let r' = mapi f r in
    Node(l', v, d', r', h)

let rec fold f m accu =
  match m with
    Empty -> accu
  | Node(l, v, d, r, _) ->
    fold f r (f v d (fold f l accu))

let rec for_all p = function
    Empty -> true
  | Node(l, v, d, r, _) -> p v d && for_all p l && for_all p r

let rec exists p = function
    Empty -> false
  | Node(l, v, d, r, _) -> p v d || exists p l || exists p r

(* Beware: those two functions assume that the added k is *strictly*
   smaller (or bigger) than all the present keys in the tree; it
   does not test for equality with the current min (or max) key.

   Indeed, they are only used during the "join" operation which
   respects this precondition.
*)

let rec add_min_binding k v = function
  | Empty -> singleton k v
  | Node (l, x, d, r, h) ->
    bal (add_min_binding k v l) x d r

let rec add_max_binding k v = function
  | Empty -> singleton k v
  | Node (l, x, d, r, h) ->
    bal l x d (add_max_binding k v r)

(* Same as create and bal, but no assumptions are made on the
   relative heights of l and r. *)

let rec join l v d r =
  match (l, r) with
    (Empty, _) -> add_min_binding v d r
  | (_, Empty) -> add_max_binding v d l
  | (Node(ll, lv, ld, lr, lh), Node(rl, rv, rd, rr, rh)) ->
    if lh > rh + 2 then bal ll lv ld (join lr v d r) else
    if rh > lh + 2 then bal (join l v d rl) rv rd rr else
      create l v d r

(* Merge two trees l and r into one.
   All elements of l must precede the elements of r.
   No assumption on the heights of l and r. *)

let concat t1 t2 =
  match (t1, t2) with
    (Empty, t) -> t
  | (t, Empty) -> t
  | (_, _) ->
    let (x, d) = min_binding_exn t2 in
    join t1 x d (remove_min_binding t2)

let concat_or_join t1 v d t2 =
  match d with
  | Some d -> join t1 v d t2
  | None -> concat t1 t2

let rec filter p = function
    Empty -> Empty
  | Node(l, v, d, r, _) ->
    (* call [p] in the expected left-to-right order *)
    let l' = filter p l in
    let pvd = p v d in
    let r' = filter p r in
    if pvd then join l' v d r' else concat l' r'

let rec partition p = function
    Empty -> (Empty, Empty)
  | Node(l, v, d, r, _) ->
    (* call [p] in the expected left-to-right order *)
    let (lt, lf) = partition p l in
    let pvd = p v d in
    let (rt, rf) = partition p r in
    if pvd
    then (join lt v d rt, concat lf rf)
    else (concat lt rt, join lf v d rf)

let compare compare_key cmp_val m1 m2 =
  let rec compare_aux e1  e2 =
    match (e1, e2) with
      (End, End) -> 0
    | (End, _)  -> -1
    | (_, End) -> 1
    | (More(v1, d1, r1, e1), More(v2, d2, r2, e2)) ->
      let c = compare_key v1 v2 in
      if c <> 0 then c else
        let c = cmp_val d1 d2 in
        if c <> 0 then c else
          compare_aux (cons_enum r1 e1) (cons_enum r2 e2)
  in compare_aux (cons_enum m1 End) (cons_enum m2 End)

let equal compare_key cmp m1 m2 =
  let rec equal_aux e1 e2 =
    match (e1, e2) with
      (End, End) -> true
    | (End, _)  -> false
    | (_, End) -> false
    | (More(v1, d1, r1, e1), More(v2, d2, r2, e2)) ->
      compare_key v1 v2 = 0 && cmp d1 d2 &&
      equal_aux (cons_enum r1 e1) (cons_enum r2 e2)
  in equal_aux (cons_enum m1 End) (cons_enum m2 End)



    
module type S =
  sig
    type key
    type +'a t
    val empty: 'a t
    val is_empty: 'a t -> bool
    val mem: key -> 'a t -> bool

    val add: key -> 'a -> 'a t -> 'a t
    (** [add x y m] 
        If [x] was already bound in [m], its previous binding disappears. *)
    val adjust: key -> (unit -> 'a)  -> ('a ->  'a) -> 'a t -> 'a t 
    (** [adjust k v f map] if not exist [add k v], otherwise 
        [add k v (f old)]
    *)
    val singleton: key -> 'a -> 'a t

    val remove: key -> 'a t -> 'a t
    (** [remove x m] returns a map containing the same bindings as
       [m], except for [x] which is unbound in the returned map. *)

    val merge:
         (key -> 'a option -> 'b option -> 'c option) -> 'a t -> 'b t -> 'c t
    (** [merge f m1 m2] computes a map whose keys is a subset of keys of [m1]
        and of [m2]. The presence of each such binding, and the corresponding
        value, is determined with the function [f].
        @since 3.12.0
     *)

     val disjoint_merge : 'a t -> 'a t -> 'a t
     (* merge two maps, will raise if they have the same key *)
    val compare: ('a -> 'a -> int) -> 'a t -> 'a t -> int
    (** Total ordering between maps.  The first argument is a total ordering
        used to compare data associated with equal keys in the two maps. *)

    val equal: ('a -> 'a -> bool) -> 'a t -> 'a t -> bool

    val iter: (key -> 'a -> unit) -> 'a t -> unit
    (** [iter f m] applies [f] to all bindings in map [m].
        The bindings are passed to [f] in increasing order. *)

    val fold: (key -> 'a -> 'b -> 'b) -> 'a t -> 'b -> 'b
    (** [fold f m a] computes [(f kN dN ... (f k1 d1 a)...)],
       where [k1 ... kN] are the keys of all bindings in [m]
       (in increasing order) *)

    val for_all: (key -> 'a -> bool) -> 'a t -> bool
    (** [for_all p m] checks if all the bindings of the map.
        order unspecified
     *)

    val exists: (key -> 'a -> bool) -> 'a t -> bool
    (** [exists p m] checks if at least one binding of the map
        satisfy the predicate [p]. 
        order unspecified
     *)

    val filter: (key -> 'a -> bool) -> 'a t -> 'a t
    (** [filter p m] returns the map with all the bindings in [m]
        that satisfy predicate [p].
        order unspecified
     *)

    val partition: (key -> 'a -> bool) -> 'a t -> 'a t * 'a t
    (** [partition p m] returns a pair of maps [(m1, m2)], where
        [m1] contains all the bindings of [s] that satisfy the
        predicate [p], and [m2] is the map with all the bindings of
        [s] that do not satisfy [p].
     *)

    val cardinal: 'a t -> int
    (** Return the number of bindings of a map. *)

    val bindings: 'a t -> (key * 'a) list
    (** Return the list of all bindings of the given map.
       The returned list is sorted in increasing order with respect
       to the ordering *)
    val keys : 'a t -> key list 
    (* Increasing order *)

    val min_binding_exn: 'a t -> (key * 'a)
    (** raise [Not_found] if the map is empty. *)

    val max_binding_exn: 'a t -> (key * 'a)
    (** Same as {!Map.S.min_binding} *)

    val choose: 'a t -> (key * 'a)
    (** Return one binding of the given map, or raise [Not_found] if
       the map is empty. Which binding is chosen is unspecified,
       but equal bindings will be chosen for equal maps.
     *)

    val split: key -> 'a t -> 'a t * 'a option * 'a t
    (** [split x m] returns a triple [(l, data, r)], where
          [l] is the map with all the bindings of [m] whose key
        is strictly less than [x];
          [r] is the map with all the bindings of [m] whose key
        is strictly greater than [x];
          [data] is [None] if [m] contains no binding for [x],
          or [Some v] if [m] binds [v] to [x].
        @since 3.12.0
     *)

    val find_exn: key -> 'a t -> 'a
    (** [find x m] returns the current binding of [x] in [m],
       or raises [Not_found] if no such binding exists. *)
    val find_opt: key -> 'a t -> 'a option
    val find_default: key  -> 'a t -> 'a  -> 'a 
    val map: ('a -> 'b) -> 'a t -> 'b t
    (** [map f m] returns a map with same domain as [m], where the
       associated value [a] of all bindings of [m] has been
       replaced by the result of the application of [f] to [a].
       The bindings are passed to [f] in increasing order
       with respect to the ordering over the type of the keys. *)

    val mapi: (key -> 'a -> 'b) -> 'a t -> 'b t
    (** Same as {!Map.S.map}, but the function receives as arguments both the
       key and the associated value for each binding of the map. *)

    val of_list : (key * 'a) list -> 'a t 
    val of_array : (key * 'a ) array -> 'a t 
    val add_list : (key * 'b) list -> 'b t -> 'b t

  end

end
module String_map : sig 
#1 "string_map.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


include Map_gen.S with type key = string

end = struct
#1 "string_map.ml"

# 2 "ext/map.cppo.ml"
(* we don't create [map_poly], since some operations require raise an exception which carries [key] *)


  
# 10
  type key = string 
  let compare_key = Ext_string.compare

# 22
type 'a t = (key,'a) Map_gen.t
exception Duplicate_key of key 

let empty = Map_gen.empty 
let is_empty = Map_gen.is_empty
let iter = Map_gen.iter
let fold = Map_gen.fold
let for_all = Map_gen.for_all 
let exists = Map_gen.exists 
let singleton = Map_gen.singleton 
let cardinal = Map_gen.cardinal
let bindings = Map_gen.bindings
let keys = Map_gen.keys
let choose = Map_gen.choose 
let partition = Map_gen.partition 
let filter = Map_gen.filter 
let map = Map_gen.map 
let mapi = Map_gen.mapi
let bal = Map_gen.bal 
let height = Map_gen.height 
let max_binding_exn = Map_gen.max_binding_exn
let min_binding_exn = Map_gen.min_binding_exn


let rec add x data (tree : _ Map_gen.t as 'a) : 'a = match tree with 
  | Empty ->
    Node(Empty, x, data, Empty, 1)
  | Node(l, v, d, r, h) ->
    let c = compare_key x v in
    if c = 0 then
      Node(l, x, data, r, h)
    else if c < 0 then
      bal (add x data l) v d r
    else
      bal l v d (add x data r)


let rec adjust x data replace (tree : _ Map_gen.t as 'a) : 'a = 
  match tree with 
  | Empty ->
    Node(Empty, x, data (), Empty, 1)
  | Node(l, v, d, r, h) ->
    let c = compare_key x v in
    if c = 0 then
      Node(l, x, replace  d , r, h)
    else if c < 0 then
      bal (adjust x data replace l) v d r
    else
      bal l v d (adjust x data replace r)


let rec find_exn x (tree : _ Map_gen.t )  = match tree with 
  | Empty ->
    raise Not_found
  | Node(l, v, d, r, _) ->
    let c = compare_key x v in
    if c = 0 then d
    else find_exn x (if c < 0 then l else r)

let rec find_opt x (tree : _ Map_gen.t )  = match tree with 
  | Empty -> None 
  | Node(l, v, d, r, _) ->
    let c = compare_key x v in
    if c = 0 then Some d
    else find_opt x (if c < 0 then l else r)

let rec find_default x (tree : _ Map_gen.t ) default     = match tree with 
  | Empty -> default  
  | Node(l, v, d, r, _) ->
    let c = compare_key x v in
    if c = 0 then  d
    else find_default x   (if c < 0 then l else r) default

let rec mem x (tree : _ Map_gen.t )   = match tree with 
  | Empty ->
    false
  | Node(l, v, d, r, _) ->
    let c = compare_key x v in
    c = 0 || mem x (if c < 0 then l else r)

let rec remove x (tree : _ Map_gen.t as 'a) : 'a = match tree with 
  | Empty ->
    Empty
  | Node(l, v, d, r, h) ->
    let c = compare_key x v in
    if c = 0 then
      Map_gen.merge l r
    else if c < 0 then
      bal (remove x l) v d r
    else
      bal l v d (remove x r)


let rec split x (tree : _ Map_gen.t as 'a) : 'a * _ option * 'a  = match tree with 
  | Empty ->
    (Empty, None, Empty)
  | Node(l, v, d, r, _) ->
    let c = compare_key x v in
    if c = 0 then (l, Some d, r)
    else if c < 0 then
      let (ll, pres, rl) = split x l in (ll, pres, Map_gen.join rl v d r)
    else
      let (lr, pres, rr) = split x r in (Map_gen.join l v d lr, pres, rr)

let rec merge f (s1 : _ Map_gen.t) (s2  : _ Map_gen.t) : _ Map_gen.t =
  match (s1, s2) with
  | (Empty, Empty) -> Empty
  | (Node (l1, v1, d1, r1, h1), _) when h1 >= height s2 ->
    let (l2, d2, r2) = split v1 s2 in
    Map_gen.concat_or_join (merge f l1 l2) v1 (f v1 (Some d1) d2) (merge f r1 r2)
  | (_, Node (l2, v2, d2, r2, h2)) ->
    let (l1, d1, r1) = split v2 s1 in
    Map_gen.concat_or_join (merge f l1 l2) v2 (f v2 d1 (Some d2)) (merge f r1 r2)
  | _ ->
    assert false

let rec disjoint_merge  (s1 : _ Map_gen.t) (s2  : _ Map_gen.t) : _ Map_gen.t =
  match (s1, s2) with
  | (Empty, Empty) -> Empty
  | (Node (l1, v1, d1, r1, h1), _) when h1 >= height s2 ->
    begin match split v1 s2 with 
    | l2, None, r2 -> 
      Map_gen.join (disjoint_merge  l1 l2) v1 d1 (disjoint_merge r1 r2)
    | _, Some _, _ ->
      raise (Duplicate_key  v1)
    end        
  | (_, Node (l2, v2, d2, r2, h2)) ->
    begin match  split v2 s1 with 
    | (l1, None, r1) -> 
      Map_gen.join (disjoint_merge  l1 l2) v2 d2 (disjoint_merge  r1 r2)
    | (_, Some _, _) -> 
      raise (Duplicate_key v2)
    end
  | _ ->
    assert false



let compare cmp m1 m2 = Map_gen.compare compare_key cmp m1 m2

let equal cmp m1 m2 = Map_gen.equal compare_key cmp m1 m2 

let add_list (xs : _ list ) init = 
  List.fold_left (fun acc (k,v) -> add k v acc) init xs 

let of_list xs = add_list xs empty

let of_array xs = 
  Array.fold_left (fun acc (k,v) -> add k v acc) empty xs

end
module Ast_extract : sig 
#1 "ast_extract.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)









module String_set = Depend.StringSet

val read_parse_and_extract : 'a Ml_binary.kind -> 'a -> String_set.t

type ('a,'b) t 

val sort_files_by_dependencies :
  domain:String_set.t -> String_set.t String_map.t -> string Queue.t


val sort :
  ('a -> Parsetree.structure) ->
  ('b -> Parsetree.signature) ->
  ('a, 'b) t String_map.t -> string Queue.t  



(**
   [build fmt files parse_implementation parse_interface]
   Given a list of files return an ast table 
*)
val collect_ast_map :
  Format.formatter ->
  string list ->
  (Format.formatter -> string -> 'a) ->
  (Format.formatter -> string -> 'b) ->
  ('a, 'b) t String_map.t

type dir_spec = 
  { dir : string ;
    mutable  excludes : string list 
  }

(** If the genereated queue is empty, it means 
    1. The main module  does not exist (does not exist due to typo)
    2. It does exist but not in search path
    The order matters from head to tail 
*)
val collect_from_main :
  ?extra_dirs:dir_spec list -> 
  ?excludes : string list -> 
  ?alias_map: string String_hashtbl.t ->
  Format.formatter ->
  (Format.formatter -> string -> 'a) ->
  (Format.formatter -> string -> 'b) ->
  ('a -> Parsetree.structure) ->
  ('b -> Parsetree.signature) ->
  string -> ('a, 'b) t String_map.t * string Queue.t

val build_queue :
  Format.formatter ->
  string Queue.t ->
  ('b, 'c) t String_map.t ->
  (Format.formatter -> string -> string -> 'b -> unit) ->
  (Format.formatter -> string -> string -> 'c -> unit) -> unit
  
val handle_queue :
  Format.formatter ->
  string Queue.t ->
  ('a, 'b) t String_map.t ->
  (string -> string -> 'a -> unit) ->
  (string -> string -> 'b  -> unit) ->
  (string -> string -> string -> 'b -> 'a -> unit) -> unit


val build_lazy_queue :
  Format.formatter ->
  string Queue.t ->
  (Parsetree.structure lazy_t, Parsetree.signature lazy_t) t String_map.t ->
  (Format.formatter -> string -> string -> Parsetree.structure -> unit) ->
  (Format.formatter -> string -> string -> Parsetree.signature -> unit) -> unit  



end = struct
#1 "ast_extract.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type module_name = private string

module String_set = Depend.StringSet

type 'a kind = 'a Ml_binary.kind 

let read_parse_and_extract (type t) (k : t kind) (ast : t) : String_set.t =
  Depend.free_structure_names := String_set.empty;
  let bound_vars = String_set.empty in
  List.iter
    (fun modname  ->
       Depend.open_module bound_vars (Longident.Lident modname))
    (!Clflags.open_modules);
  (match k with
   | Ml_binary.Ml  -> Depend.add_implementation bound_vars ast
   | Ml_binary.Mli  -> Depend.add_signature bound_vars ast  ); 
  !Depend.free_structure_names


type ('a,'b) ast_info =
  | Ml of
      string * (* sourcefile *)
      'a *
      string (* opref *)      
  | Mli of string * (* sourcefile *)
           'b *
           string (* opref *)
  | Ml_mli of
      string * (* sourcefile *)
      'a *
      string  * (* opref1 *)
      string * (* sourcefile *)      
      'b *
      string (* opref2*)

type ('a,'b) t =
  { module_name : string ; ast_info : ('a,'b) ast_info }


(* only visit nodes that are currently in the domain *)
(* https://en.wikipedia.org/wiki/Topological_sorting *)
(* dfs   *)
let sort_files_by_dependencies ~domain dependency_graph =
  let next current =
    (String_map.find_exn  current dependency_graph) in    
  let worklist = ref domain in
  let result = Queue.create () in
  let rec visit visiting path current =
    if String_set.mem current visiting then
      Bs_exception.error (Bs_cyclic_depends (current::path))
    else if String_set.mem current !worklist then
      begin
        next current |>        
        String_set.iter
          (fun node ->
             if  String_map.mem node  dependency_graph then
               visit (String_set.add current visiting) (current::path) node)
        ;
        worklist := String_set.remove  current !worklist;
        Queue.push current result ;
      end in        
  while not (String_set.is_empty !worklist) do 
    visit String_set.empty []  (String_set.choose !worklist)
  done;
  if Js_config.get_diagnose () then
    Format.fprintf Format.err_formatter
      "Order: @[%a@]@."    
      (Ext_format.pp_print_queue
         ~pp_sep:Format.pp_print_space
         Format.pp_print_string)
      result ;       
  result
;;



let sort  project_ml project_mli (ast_table : _ t String_map.t) = 
  let domain =
    String_map.fold
      (fun k _ acc -> String_set.add k acc)
      ast_table String_set.empty in
  let h =
    String_map.map
      (fun
        ({ast_info})
        ->
          match ast_info with
          | Ml (_, ast,  _)
            ->
            read_parse_and_extract Ml (project_ml ast)            
          | Mli (_, ast, _)
            ->
            read_parse_and_extract Mli (project_mli ast)
          | Ml_mli (_, impl, _, _, intf, _)
            ->
            String_set.union
              (read_parse_and_extract Ml (project_ml impl))
              (read_parse_and_extract Mli (project_mli intf))              
      ) ast_table in    
  sort_files_by_dependencies  ~domain h

(** same as {!Ocaml_parse.check_suffix} but does not care with [-c -o] option*)
let check_suffix  name  = 
  if Filename.check_suffix name ".ml"
  || Filename.check_suffix name ".mlt" then 
    `Ml,
    Ext_path.chop_extension_if_any  name 
  else if Filename.check_suffix name !Config.interface_suffix then 
    `Mli,   Ext_path.chop_extension_if_any  name 
  else 
    raise(Arg.Bad("don't know what to do with " ^ name))


let collect_ast_map ppf files parse_implementation parse_interface  =
  List.fold_left
    (fun (acc : _ t String_map.t)
      source_file ->
      match check_suffix source_file with
      | `Ml, opref ->
        let module_name = Ext_modulename.module_name_of_file source_file in
        begin match String_map.find_exn module_name acc with
          | exception Not_found ->
            String_map.add module_name
              {ast_info =
                 (Ml (source_file, parse_implementation
                        ppf source_file, opref));
               module_name ;
              } acc
          | {ast_info = (Ml (source_file2, _, _)
                        | Ml_mli(source_file2, _, _,_,_,_))} ->
            Bs_exception.error
              (Bs_duplicated_module (source_file, source_file2))
          | {ast_info =  Mli (source_file2, intf, opref2)}
            ->
            String_map.add module_name
              {ast_info =
                 Ml_mli (source_file,
                         parse_implementation ppf source_file,
                         opref,
                         source_file2,
                         intf,
                         opref2
                        );
               module_name} acc
        end
      | `Mli, opref ->
        let module_name = Ext_modulename.module_name_of_file source_file in
        begin match String_map.find_exn module_name acc with
          | exception Not_found ->
            String_map.add module_name
              {ast_info = (Mli (source_file, parse_interface
                                  ppf source_file, opref));
               module_name } acc
          | {ast_info =
               (Mli (source_file2, _, _) |
                Ml_mli(_,_,_,source_file2,_,_)) } ->
            Bs_exception.error
              (Bs_duplicated_module (source_file, source_file2))
          | {ast_info = Ml (source_file2, impl, opref2)}
            ->
            String_map.add module_name
              {ast_info =
                 Ml_mli
                   (source_file2,
                    impl,
                    opref2,
                    source_file,
                    parse_interface ppf source_file,
                    opref
                   );
               module_name} acc
        end
    ) String_map.empty files
;;
type dir_spec = 
  { dir : string ;
    mutable  excludes : string list 
  }

let collect_from_main 
    ?(extra_dirs=[])
    ?(excludes=[])
    ?alias_map
    (ppf : Format.formatter)
    parse_implementation
    parse_interface
    project_impl 
    project_intf 
    main_module =
  let files = 
    List.fold_left (fun acc dir_spec -> 
        let  dirname, excludes = 
          match dir_spec with 
          | { dir =  dirname; excludes = dir_excludes} ->
            (*   dirname, excludes *)
            (* | `Dir_with_excludes (dirname, dir_excludes) -> *)
            dirname,
            Ext_list.append (Ext_list.flat_map 
              (fun x -> [x ^ ".ml" ; x ^ ".mli" ])
              dir_excludes)  excludes
        in 
        Array.fold_left (fun acc source_file -> 
            if (Ext_string.ends_with source_file ".ml" ||
                Ext_string.ends_with source_file ".mli" )
            && (* not_excluded source_file *) (not (List.mem source_file excludes))
            then 
              (Filename.concat dirname source_file) :: acc else acc
          ) acc (Sys.readdir dirname))
      [] extra_dirs in
  let ast_table = collect_ast_map ppf files parse_implementation parse_interface in 
  let visited = String_hashtbl.create 31 in
  let result = Queue.create () in  
  let next module_name : String_set.t =
    let module_set = 
      match String_map.find_exn module_name ast_table with
      | exception _ -> String_set.empty
      | {ast_info = Ml (_,  impl, _)} ->
        read_parse_and_extract Ml (project_impl impl)
      | {ast_info = Mli (_,  intf,_)} ->
        read_parse_and_extract Mli (project_intf intf)
      | {ast_info = Ml_mli(_, impl, _, _,  intf, _)}
        -> 
        String_set.union
          (read_parse_and_extract Ml (project_impl impl))
          (read_parse_and_extract Mli (project_intf intf))
    in 
    match alias_map with 
    | None -> module_set 
    | Some map -> 
      String_set.fold (fun x acc -> String_set.add (String_hashtbl.find_default map x x) acc  ) module_set String_set.empty
  in
  let rec visit visiting path current =
    if String_set.mem current visiting  then
      Bs_exception.error (Bs_cyclic_depends (current::path))
    else
    if not (String_hashtbl.mem visited current)
    && String_map.mem current ast_table then
      begin
        String_set.iter
          (visit
             (String_set.add current visiting)
             (current::path))
          (next current) ;
        Queue.push current result;
        String_hashtbl.add visited current ();
      end in
  visit (String_set.empty) [] main_module ;
  ast_table, result   


let build_queue ppf queue
    (ast_table : _ t String_map.t)
    after_parsing_impl
    after_parsing_sig    
  =
  queue
  |> Queue.iter
    (fun modname -> 
       match String_map.find_exn modname ast_table  with
       | {ast_info = Ml(source_file,ast, opref)}
         -> 
         after_parsing_impl ppf source_file 
           opref ast 
       | {ast_info = Mli (source_file,ast,opref) ; }  
         ->
         after_parsing_sig ppf source_file 
           opref ast 
       | {ast_info = Ml_mli(source_file1,impl,opref1,source_file2,intf,opref2)}
         -> 
         after_parsing_sig ppf source_file1 opref1 intf ;
         after_parsing_impl ppf source_file2 opref2 impl
       | exception Not_found -> assert false 
    )


let handle_queue 
  ppf 
  queue ast_table 
  decorate_module_only 
  decorate_interface_only 
  decorate_module = 
  queue 
  |> Queue.iter
    (fun base ->
       match (String_map.find_exn  base ast_table).ast_info with
       | exception Not_found -> assert false
       | Ml (ml_name,  ml_content, _)
         ->
         decorate_module_only  base ml_name ml_content
       | Mli (mli_name , mli_content, _) ->
         decorate_interface_only base  mli_name mli_content
       | Ml_mli (ml_name, ml_content, _, mli_name,   mli_content, _)
         ->
         decorate_module  base mli_name ml_name mli_content ml_content

    )



let build_lazy_queue ppf queue (ast_table : _ t String_map.t)
    after_parsing_impl
    after_parsing_sig    
  =
  queue |> Queue.iter (fun modname -> 
      match String_map.find_exn modname ast_table  with
      | {ast_info = Ml(source_file,lazy ast, opref)}
        -> 
        after_parsing_impl ppf source_file opref ast 
      | {ast_info = Mli (source_file,lazy ast,opref) ; }  
        ->
        after_parsing_sig ppf source_file opref ast 
      | {ast_info = Ml_mli(source_file1,lazy impl,opref1,source_file2,lazy intf,opref2)}
        -> 
        after_parsing_sig ppf source_file1 opref1 intf ;
        after_parsing_impl ppf source_file2 opref2 impl
      | exception Not_found -> assert false 
    )


end
module Binary_ast : sig 
#1 "binary_ast.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


val read_ast : 'a Ml_binary.kind -> string -> 'a 



(**
   Check out {!Bsb_depfile_gen} for set decoding
   The [.ml] file can be recognized as an ast directly, the format
   is
   {
   magic number;
   filename;
   ast
   }
   when [fname] is "-" it means the file is from an standard input or pipe.
   An empty name would marshallized.

   Use case cat - | fan -printer -impl -
   redirect the standard input to fan
 *)
val write_ast : fname:string -> output:string -> 'a Ml_binary.kind -> 'a -> unit


end = struct
#1 "binary_ast.ml"

(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

module String_set = Ast_extract.String_set






let read_ast (type t ) (kind : t  Ml_binary.kind) fn : t  =
  let ic = open_in_bin fn in
  try
    let dep_size = input_binary_int ic in 
    seek_in  ic (pos_in ic + dep_size) ; 
    let ast = Ml_binary.read_ast kind ic in 
    close_in ic;
    ast
  with exn ->
    close_in ic;
    raise exn


(*
   Reasons that we don't [output_value] the set:
   1. for performance , easy skipping and calcuate the length 
   2. cut dependency, otherwise its type is {!Ast_extract.String_set.t}
*)      
let write_ast (type t) ~(fname : string) ~output (kind : t Ml_binary.kind) ( pt : t) : unit =
  let oc = open_out_bin output in 

  let output_set = Ast_extract.read_parse_and_extract kind pt in
  let buf = Buffer.create 64 in
  let number = String_set.cardinal output_set in 
  Buffer.add_string buf (string_of_int number) ;
  Buffer.add_char buf '\t';
  String_set.iter (fun s -> Buffer.add_string buf s ; Buffer.add_char buf '\t') output_set ;
  let buf_contents = Buffer.contents buf in 
  output_binary_int oc (String.length buf_contents);
  output_string oc buf_contents; 
  Ml_binary.write_ast kind fname pt oc;
  close_out oc 


end
module Ast_literal : sig 
#1 "ast_literal.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


type 'a  lit = ?loc: Location.t -> unit -> 'a
module Lid : sig
  type t = Longident.t 
  val val_unit : t 
  val type_unit : t 
  val type_int : t 
  val js_fn : t 
  val js_meth : t 
  val js_meth_callback : t 
  val js_obj : t 

  val ignore_id : t 
  val js_null : t 
  val js_undefined : t
  val js_null_undefined : t 
  val js_re_id : t 
  val js_unsafe : t 
end

type expression_lit = Parsetree.expression lit 
type core_type_lit = Parsetree.core_type lit 
type pattern_lit = Parsetree.pattern lit 

val val_unit : expression_lit

val type_unit : core_type_lit
val type_exn : core_type_lit
val type_string : core_type_lit
val type_int : core_type_lit 
val type_any : core_type_lit

val pat_unit : pattern_lit

end = struct
#1 "ast_literal.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

open Ast_helper


module Lid = struct 
  type t = Longident.t 
  let val_unit : t = Lident "()"
  let type_unit : t = Lident "unit"
  let type_string : t = Lident "string"
  let type_int : t = Lident "int" (* use *predef* *)
  let type_exn : t = Lident "exn" (* use *predef* *)
  (* TODO should be renamed in to {!Js.fn} *)
  (* TODO should be moved into {!Js.t} Later *)
  let js_fn : t = 
      Ldot (Ldot (Lident "Js", "Internal"),  "fn")
  let js_meth : t = 
      Ldot (Ldot (Lident "Js", "Internal") , "meth")
  let js_meth_callback : t = 
      Ldot (Ldot (Lident "Js", "Internal"), "meth_callback")
  let js_obj : t = Ldot (Lident "Js", "t") 
  let ignore_id : t = Ldot (Lident "Pervasives", "ignore")
  let js_null  : t = Ldot (Lident "Js", "null")
  let js_undefined : t = Ldot (Lident "Js", "undefined")
  let js_null_undefined : t = Ldot (Lident "Js", "null_undefined")
  let js_re_id : t = Ldot (Ldot (Lident "Js", "Re"), "t")
  let js_unsafe : t = Lident "Js_unsafe"
end

module No_loc = struct 
  let loc = Location.none
  let val_unit = 
    Ast_helper.Exp.construct {txt = Lid.val_unit; loc }  None

  let type_unit =   
    Ast_helper.Typ.mk  (Ptyp_constr ({ txt = Lid.type_unit; loc}, []))
  let type_exn =   
    Ast_helper.Typ.mk  (Ptyp_constr ({ txt = Lid.type_unit; loc}, []))

  let type_int = 
    Ast_helper.Typ.mk (Ptyp_constr ({txt = Lid.type_int; loc}, []))  
  let type_string =   
    Ast_helper.Typ.mk  (Ptyp_constr ({ txt = Lid.type_string; loc}, []))

  let type_any = Ast_helper.Typ.any ()
  let pat_unit = Pat.construct {txt = Lid.val_unit; loc} None
end 

type 'a  lit = ?loc: Location.t -> unit -> 'a
type expression_lit = Parsetree.expression lit 
type core_type_lit = Parsetree.core_type lit 
type pattern_lit = Parsetree.pattern lit 

let val_unit ?loc () = 
  match loc with 
  | None -> No_loc.val_unit
  | Some loc -> Ast_helper.Exp.construct {txt = Lid.val_unit; loc}  None


let type_unit ?loc () = 
  match loc with
  | None ->     
    No_loc.type_unit
  | Some loc -> 
    Ast_helper.Typ.mk ~loc  (Ptyp_constr ({ txt = Lid.type_unit; loc}, []))

let type_exn ?loc () = 
  match loc with
  | None ->     
    No_loc.type_exn
  | Some loc -> 
    Ast_helper.Typ.mk ~loc  (Ptyp_constr ({ txt = Lid.type_exn; loc}, []))


let type_string ?loc () = 
  match loc with 
  | None -> No_loc.type_string 
  | Some loc ->     
    Ast_helper.Typ.mk ~loc  (Ptyp_constr ({ txt = Lid.type_string; loc}, []))

let type_int ?loc () = 
  match loc with 
  | None -> No_loc.type_int
  | Some loc ->     
    Ast_helper.Typ.mk ~loc  (Ptyp_constr ({ txt = Lid.type_int; loc}, []))

let type_any ?loc () = 
  match loc with 
  | None -> No_loc.type_any
  | Some loc -> Ast_helper.Typ.any ~loc ()

let pat_unit ?loc () = 
  match loc with 
  | None -> No_loc.pat_unit
  | Some loc -> 
    Pat.construct ~loc {txt = Lid.val_unit; loc} None

end
module Ast_comb : sig 
#1 "ast_comb.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


val exp_apply_no_label : 
  ?loc:Location.t ->
  ?attrs:Parsetree.attributes ->
  Parsetree.expression -> Parsetree.expression list -> Parsetree.expression

val fun_no_label : 
  ?loc:Location.t ->
  ?attrs:Parsetree.attributes ->
  Parsetree.pattern -> Parsetree.expression -> Parsetree.expression

val arrow_no_label : 
  ?loc:Location.t ->
  ?attrs:Parsetree.attributes ->
  Parsetree.core_type -> Parsetree.core_type -> Parsetree.core_type

(* note we first declare its type is [unit], 
   then [ignore] it, [ignore] is necessary since 
   the js value  maybe not be of type [unit] and 
   we can use [unit] value (though very little chance) 
   sometimes
*)
val discard_exp_as_unit : 
  Location.t -> Parsetree.expression -> Parsetree.expression


val tuple_type_pair : 
  ?loc:Ast_helper.loc ->
  [< `Make | `Run ] ->
  int -> Parsetree.core_type * Parsetree.core_type list * Parsetree.core_type

val to_js_type :
  Location.t -> Parsetree.core_type -> Parsetree.core_type


(** TODO: make it work for browser too *)
val to_undefined_type :
  Location.t -> Parsetree.core_type -> Parsetree.core_type  

val to_js_re_type : Location.t -> Parsetree.core_type

end = struct
#1 "ast_comb.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


open Ast_helper 

let exp_apply_no_label ?loc ?attrs a b = 
  Exp.apply ?loc ?attrs a (Ext_list.map (fun x -> "", x) b)

let fun_no_label ?loc ?attrs  pat body = 
  Exp.fun_ ?loc ?attrs "" None pat body

let arrow_no_label ?loc ?attrs b c = 
  Typ.arrow ?loc ?attrs "" b c 

let discard_exp_as_unit loc e = 
  exp_apply_no_label ~loc     
    (Exp.ident ~loc {txt = Ast_literal.Lid.ignore_id; loc})
    [Exp.constraint_ ~loc e 
       (Ast_literal.type_unit ~loc ())]


let tuple_type_pair ?loc kind arity = 
  let prefix  = "a" in
  if arity = 0 then 
    let ty = Typ.var ?loc ( prefix ^ "0") in 
    match kind with 
    | `Run -> ty,  [], ty 
    | `Make -> 
      (Typ.arrow "" ?loc
         (Ast_literal.type_unit ?loc ())
         ty ,
       [], ty)
  else
    let number = arity + 1 in
    let tys = Ext_list.init number (fun i -> 
        Typ.var ?loc (prefix ^ string_of_int (number - i - 1))
      )  in
    match tys with 
    | result :: rest -> 
      Ext_list.reduce_from_left (fun r arg -> Typ.arrow "" ?loc arg r) tys, 
      List.rev rest , result
    | [] -> assert false
    
    

let js_obj_type_id  = 
  Ast_literal.Lid.js_obj 

let re_id  = 
  Ast_literal.Lid.js_re_id 

let to_js_type loc  x  = 
  Typ.constr ~loc {txt = js_obj_type_id; loc} [x]

let to_js_re_type loc  =
  Typ.constr ~loc { txt = re_id ; loc} []
    
let to_undefined_type loc x =
  Typ.constr ~loc
    {txt = Ast_literal.Lid.js_undefined ; loc}
    [x]  


end
module Bs_syntaxerr : sig 
#1 "bs_syntaxerr.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type error 
  = Unsupported_predicates
  | Conflict_bs_bs_this_bs_meth  
  | Duplicated_bs_deriving
  | Conflict_attributes

  | Duplicated_bs_as 
  | Expect_int_literal
  | Expect_string_literal
  | Expect_int_or_string_or_json_literal
  | Unhandled_poly_type
  | Unregistered of string 
  | Invalid_underscore_type_in_external
  | Invalid_bs_string_type 
  | Invalid_bs_int_type 
  | Invalid_bs_unwrap_type
  | Conflict_ffi_attribute of string
  | Not_supported_in_bs_deriving
  | Canot_infer_arity_by_syntax
  | Illegal_attribute
  | Inconsistent_arity of int * int 
  (* we still rqeuire users to have explicit annotation to avoid
     {[ (((int -> int) -> int) -> int )]}
  *)
  | Not_supported_directive_in_bs_return
  | Expect_opt_in_bs_return_to_opt
  | Label_in_uncurried_bs_attribute

  | Bs_this_simple_pattern


val err : Location.t -> error -> 'a

end = struct
#1 "bs_syntaxerr.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)



type error 
  = Unsupported_predicates
  | Conflict_bs_bs_this_bs_meth  
  | Duplicated_bs_deriving
  | Conflict_attributes

  | Duplicated_bs_as 
  | Expect_int_literal
  | Expect_string_literal
  | Expect_int_or_string_or_json_literal
  | Unhandled_poly_type
  | Unregistered of string 
  | Invalid_underscore_type_in_external
  | Invalid_bs_string_type 
  | Invalid_bs_int_type 
  | Invalid_bs_unwrap_type
  | Conflict_ffi_attribute of string
  | Not_supported_in_bs_deriving
  | Canot_infer_arity_by_syntax
  | Illegal_attribute
  | Inconsistent_arity of int * int 
  (* we still rqeuire users to have explicit annotation to avoid
     {[ (((int -> int) -> int) -> int )]}
  *)
  | Not_supported_directive_in_bs_return
  | Expect_opt_in_bs_return_to_opt
  | Label_in_uncurried_bs_attribute

  | Bs_this_simple_pattern

let pp_error fmt err =
  Format.pp_print_string fmt @@ match err with
  | Label_in_uncurried_bs_attribute 
    -> "label is not allowed here, it is due to `bs.` attribute indicate uncurried calling convention which does not support label argument yet"
  | Expect_opt_in_bs_return_to_opt
      ->
        "bs.return directive *_to_opt expect return type to be \n\
         syntax wise `_ option` for safety"

  | Not_supported_directive_in_bs_return
    ->
    "Not supported return directive"                
  | Illegal_attribute ->
    "Illegal attributes"
  | Canot_infer_arity_by_syntax
    ->   "Can not infer the arity by syntax, either [@bs.uncurry n] or \n\
              write it in arrow syntax "
  | Inconsistent_arity (arity,n)
      -> Printf.sprintf "Inconsistent arity %d vs %d" arity n 
  | Not_supported_in_bs_deriving
    ->
    "not supported in deriving"
  | Unsupported_predicates 
    ->
     "unsupported predicates"
  | Conflict_bs_bs_this_bs_meth -> 
     "[@bs.this], [@bs], [@bs.meth] can not be applied at the same time"
  | Duplicated_bs_deriving
    -> "duplicated bs.deriving attribute"
  | Conflict_attributes
    -> "conflicting attributes " 
  | Expect_string_literal
    -> "expect string literal "
  | Duplicated_bs_as 
    -> 
    "duplicated bs.as "
  | Expect_int_literal 
    -> 
    "expect int literal "
  | Expect_int_or_string_or_json_literal
    ->
    "expect int or string literal or json literal ({json||json}) "
  | Unhandled_poly_type 
    -> 
    "Unhandled poly type"
  | Unregistered str 
    -> "Unregistered " ^ str 
  | Invalid_underscore_type_in_external
    ->
    "_ is not allowed in combination with external optional type"
  | Invalid_bs_string_type
    -> 
    "Not a valid  type for [@bs.string]"
  | Invalid_bs_int_type 
    -> 
    "Not a valid  type for [@bs.int]"
  | Invalid_bs_unwrap_type
    ->
    "Not a valid type for [@bs.unwrap]. Type must be an inline variant (closed), and\n\
     each constructor must have an argument."
  | Conflict_ffi_attribute str
    ->
    "Conflicting FFI attributes found: " ^ str
  | Bs_this_simple_pattern
    -> 
    "[@bs.this] expect its pattern variable to be simple form"

type exn +=  Error of Location.t * error


let () = 
  Location.register_error_of_exn (function
    | Error(loc,err) -> 
      Some (Location.error_of_printer loc pp_error err)
    | _ -> None
    )

let err loc error = raise (Error(loc, error))

end
module Ast_core_type : sig 
#1 "ast_core_type.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type t = Parsetree.core_type 


val extract_option_type_exn : t -> t 
val lift_option_type : t -> t 
val is_any : t -> bool 
val replace_result : t -> t -> t

val is_unit : t -> bool 
val is_array : t -> bool 
type arg_label =
  | Label of string 
  | Optional of string 
  | Empty


(** for 
       [x:t] -> "x"
       [?x:t] -> "?x"
*)
val label_name : string -> arg_label





(** return a function type 
    [from_labels ~loc tyvars labels]
    example output:
    {[x:'a0 -> y:'a1 -> < x :'a0 ;y :'a1  > Js.t]}
*)
val from_labels :
  loc:Location.t -> int ->  string Asttypes.loc list -> t

val make_obj :
  loc:Location.t ->
  (string * Parsetree.attributes * t) list ->
  t

val is_user_option : t -> bool 

val is_user_bool : t -> bool

val is_user_int : t -> bool

val is_optional_label : string -> bool 

(** 
  returns 0 when it can not tell arity from the syntax 
*)
val get_uncurry_arity : t -> [`Arity of int | `Not_function ]


(** fails when Ptyp_poly *)
val list_of_arrow : 
  t -> 
  t *  (Asttypes.label * t * Parsetree.attributes * Location.t) list

val is_arity_one : t -> bool 

end = struct
#1 "ast_core_type.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type t = Parsetree.core_type 

type arg_label =
  | Label of string 
  | Optional of string 
  | Empty (* it will be ignored , side effect will be recorded *)



let extract_option_type_exn (ty : t) = 
  begin match ty with
    | {ptyp_desc =
         Ptyp_constr({txt =
                        Ldot (Lident "*predef*", "option") },
                     [ty])}
      ->                
      ty
    | _ -> assert false                 
  end      

let predef_option : Longident.t = Longident.Ldot (Lident "*predef*", "option")
let predef_int : Longident.t = Ldot (Lident "*predef*", "int")


let lift_option_type (ty:t) : t = 
  {ptyp_desc =
     Ptyp_constr(
       {txt = predef_option;
        loc = ty.ptyp_loc} 
        , [ty]);
        ptyp_loc = ty.ptyp_loc;
      ptyp_attributes = []
    }

let is_any (ty : t) = 
  match ty with {ptyp_desc = Ptyp_any} -> true | _ -> false

open Ast_helper

let replace_result ty result = 
  let rec aux (ty : Parsetree.core_type) = 
    match ty with 
    | { ptyp_desc = 
          Ptyp_arrow (label,t1,t2)
      } -> { ty with ptyp_desc = Ptyp_arrow(label,t1, aux t2)}
    | {ptyp_desc = Ptyp_poly(fs,ty)} 
      ->  {ty with ptyp_desc = Ptyp_poly(fs, aux ty)}
    | _ -> result in 
  aux ty 

let is_unit (ty : t ) = 
  match ty.ptyp_desc with 
  | Ptyp_constr({txt =Lident "unit"}, []) -> true
  | _ -> false 

let is_array (ty : t) = 
  match ty.ptyp_desc with 
  | Ptyp_constr({txt =Lident "array"}, [_]) -> true
  | _ -> false 

let is_user_option (ty : t) = 
  match ty.ptyp_desc with 
  | Ptyp_constr({txt = Lident "option"},[_]) -> true 
  | _ -> false 

let is_user_bool (ty : t) = 
  match ty.ptyp_desc with 
  | Ptyp_constr({txt = Lident "bool"},[]) -> true 
  | _ -> false 

let is_user_int (ty : t) = 
  match ty.ptyp_desc with 
  | Ptyp_constr({txt = Lident "int"},[]) -> true 
  | _ -> false 

let is_optional_label l =
  String.length l > 0 && l.[0] = '?'

let label_name l : arg_label =
  if l = "" then Empty else 
  if is_optional_label l 
  then Optional (String.sub l 1 (String.length l - 1))
  else Label l


(* Note that OCaml type checker will not allow arbitrary 
   name as type variables, for example:
   {[
     '_x'_
   ]}
   will be recognized as a invalid program
*)
let from_labels ~loc arity labels 
  : t =
  let tyvars = 
    ((Ext_list.init arity (fun i ->      
         Typ.var ~loc ("a" ^ string_of_int i)))) in
  let result_type =
    Ast_comb.to_js_type loc  
      (Typ.object_ ~loc
         (List.map2 (fun x y -> x.Asttypes.txt ,[], y) labels tyvars) Closed)
  in 
  List.fold_right2 
    (fun {Asttypes.loc ; txt = label }
      tyvar acc -> Typ.arrow ~loc label tyvar acc) labels tyvars  result_type


let make_obj ~loc xs =
  Ast_comb.to_js_type loc @@
  Ast_helper.Typ.object_  ~loc xs   Closed



(** 

{[ 'a . 'a -> 'b ]} 
OCaml does not support such syntax yet
{[ 'a -> ('a. 'a -> 'b) ]}

*)
let rec get_uncurry_arity_aux  (ty : t) acc = 
    match ty.ptyp_desc with 
    | Ptyp_arrow(_, _ , new_ty) -> 
      get_uncurry_arity_aux new_ty (succ acc)
    | Ptyp_poly (_,ty) -> 
      get_uncurry_arity_aux ty acc 
    | _ -> acc 

(**
   {[ unit -> 'a1 -> a2']}  arity 2 
   {[ unit -> 'b ]} return arity 0 
   {[ 'a1 -> 'a2 -> ... 'aN -> 'b ]} return arity N   
*)
let get_uncurry_arity (ty : t ) = 
  match ty.ptyp_desc  with 
  | Ptyp_arrow("", {ptyp_desc = (Ptyp_constr ({txt = Lident "unit"}, []))}, 
    ({ptyp_desc = Ptyp_arrow _ } as rest  )) -> `Arity (get_uncurry_arity_aux rest 1 )
  | Ptyp_arrow("", {ptyp_desc = (Ptyp_constr ({txt = Lident "unit"}, []))}, _) -> `Arity 0
  | Ptyp_arrow(_,_,rest ) -> 
    `Arity(get_uncurry_arity_aux rest 1)
  | _ -> `Not_function 

let get_curry_arity  ty =
  get_uncurry_arity_aux ty 0

let is_arity_one ty = get_curry_arity ty =  1
                      
let list_of_arrow (ty : t) = 
  let rec aux (ty : t) acc = 
    match ty.ptyp_desc with 
    | Ptyp_arrow(label,t1,t2) -> 
      aux t2 ((label,t1,ty.ptyp_attributes,ty.ptyp_loc) ::acc)
    | Ptyp_poly(_, ty) -> (* should not happen? *)
      Bs_syntaxerr.err ty.ptyp_loc Unhandled_poly_type
    | return_type -> ty, List.rev acc
  in aux ty []

end
module Bs_ast_iterator : sig 
#1 "bs_ast_iterator.mli"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*                      Nicolas Ojeda Bar, LexiFi                         *)
(*                                                                        *)
(*   Copyright 2012 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(** {!iterator} allows to implement AST inspection using open recursion.  A
    typical mapper would be based on {!default_iterator}, a trivial iterator,
    and will fall back on it for handling the syntax it does not modify. *)

open Parsetree

(** {2 A generic Parsetree iterator} *)

type iterator = {
  attribute: iterator -> attribute -> unit;
  attributes: iterator -> attribute list -> unit;
  case: iterator -> case -> unit;
  cases: iterator -> case list -> unit;
  class_declaration: iterator -> class_declaration -> unit;
  class_description: iterator -> class_description -> unit;
  class_expr: iterator -> class_expr -> unit;
  class_field: iterator -> class_field -> unit;
  class_signature: iterator -> class_signature -> unit;
  class_structure: iterator -> class_structure -> unit;
  class_type: iterator -> class_type -> unit;
  class_type_declaration: iterator -> class_type_declaration -> unit;
  class_type_field: iterator -> class_type_field -> unit;
  constructor_declaration: iterator -> constructor_declaration -> unit;
  expr: iterator -> expression -> unit;
  extension: iterator -> extension -> unit;
  extension_constructor: iterator -> extension_constructor -> unit;
  include_declaration: iterator -> include_declaration -> unit;
  include_description: iterator -> include_description -> unit;
  label_declaration: iterator -> label_declaration -> unit;
  location: iterator -> Location.t -> unit;
  module_binding: iterator -> module_binding -> unit;
  module_declaration: iterator -> module_declaration -> unit;
  module_expr: iterator -> module_expr -> unit;
  module_type: iterator -> module_type -> unit;
  module_type_declaration: iterator -> module_type_declaration -> unit;
  open_description: iterator -> open_description -> unit;
  pat: iterator -> pattern -> unit;
  payload: iterator -> payload -> unit;
  signature: iterator -> signature -> unit;
  signature_item: iterator -> signature_item -> unit;
  structure: iterator -> structure -> unit;
  structure_item: iterator -> structure_item -> unit;
  typ: iterator -> core_type -> unit;
  type_declaration: iterator -> type_declaration -> unit;
  type_extension: iterator -> type_extension -> unit;
  type_kind: iterator -> type_kind -> unit;
  value_binding: iterator -> value_binding -> unit;
  value_description: iterator -> value_description -> unit;
  with_constraint: iterator -> with_constraint -> unit;
}
(** A [iterator] record implements one "method" per syntactic category,
    using an open recursion style: each method takes as its first
    argument the iterator to be applied to children in the syntax
    tree. *)

val default_iterator: iterator
(** A default iterator, which implements a "do not do anything" mapping. *)

end = struct
#1 "bs_ast_iterator.ml"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*                      Nicolas Ojeda Bar, LexiFi                         *)
(*                                                                        *)
(*   Copyright 2012 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)
[@@@ocaml.warning "+9"]
(* A generic Parsetree mapping class *)
(* Back-ported from 4.04 By Hongbo ZHang, after grading to 4.04, we will remove this file  *)
(*

  (* Ensure that record patterns don't miss any field. *)
*)


open Parsetree
open Location

type iterator = {
  attribute: iterator -> attribute -> unit;
  attributes: iterator -> attribute list -> unit;
  case: iterator -> case -> unit;
  cases: iterator -> case list -> unit;
  class_declaration: iterator -> class_declaration -> unit;
  class_description: iterator -> class_description -> unit;
  class_expr: iterator -> class_expr -> unit;
  class_field: iterator -> class_field -> unit;
  class_signature: iterator -> class_signature -> unit;
  class_structure: iterator -> class_structure -> unit;
  class_type: iterator -> class_type -> unit;
  class_type_declaration: iterator -> class_type_declaration -> unit;
  class_type_field: iterator -> class_type_field -> unit;
  constructor_declaration: iterator -> constructor_declaration -> unit;
  expr: iterator -> expression -> unit;
  extension: iterator -> extension -> unit;
  extension_constructor: iterator -> extension_constructor -> unit;
  include_declaration: iterator -> include_declaration -> unit;
  include_description: iterator -> include_description -> unit;
  label_declaration: iterator -> label_declaration -> unit;
  location: iterator -> Location.t -> unit;
  module_binding: iterator -> module_binding -> unit;
  module_declaration: iterator -> module_declaration -> unit;
  module_expr: iterator -> module_expr -> unit;
  module_type: iterator -> module_type -> unit;
  module_type_declaration: iterator -> module_type_declaration -> unit;
  open_description: iterator -> open_description -> unit;
  pat: iterator -> pattern -> unit;
  payload: iterator -> payload -> unit;
  signature: iterator -> signature -> unit;
  signature_item: iterator -> signature_item -> unit;
  structure: iterator -> structure -> unit;
  structure_item: iterator -> structure_item -> unit;
  typ: iterator -> core_type -> unit;
  type_declaration: iterator -> type_declaration -> unit;
  type_extension: iterator -> type_extension -> unit;
  type_kind: iterator -> type_kind -> unit;
  value_binding: iterator -> value_binding -> unit;
  value_description: iterator -> value_description -> unit;
  with_constraint: iterator -> with_constraint -> unit;
}
(** A [iterator] record implements one "method" per syntactic category,
    using an open recursion style: each method takes as its first
    argument the iterator to be applied to children in the syntax
    tree. *)

let iter_fst f (x, _) = f x
let iter_snd f (_, y) = f y
let iter_tuple f1 f2 (x, y) = f1 x; f2 y
let iter_tuple3 f1 f2 f3 (x, y, z) = f1 x; f2 y; f3 z
let iter_opt f = function None -> () | Some x -> f x

let iter_loc sub {loc; txt = _} = sub.location sub loc

module T = struct
  (* Type expressions for the core language *)

  let row_field sub = function
    | Rtag (_, attrs, _, tl) ->
        sub.attributes sub attrs; List.iter (sub.typ sub) tl
    | Rinherit t -> sub.typ sub t

  let iter sub {ptyp_desc = desc; ptyp_loc = loc; ptyp_attributes = attrs} =
    sub.location sub loc;
    sub.attributes sub attrs;
    match desc with
    | Ptyp_any
    | Ptyp_var _ -> ()
    | Ptyp_arrow (_lab, t1, t2) ->
        sub.typ sub t1; sub.typ sub t2
    | Ptyp_tuple tyl -> List.iter (sub.typ sub) tyl
    | Ptyp_constr (lid, tl) ->
        iter_loc sub lid; List.iter (sub.typ sub) tl
    | Ptyp_object (l, _o) ->
        let f (_, a, t) = sub.attributes sub a; sub.typ sub t in
        List.iter f l
    | Ptyp_class (lid, tl) ->
        iter_loc sub lid; List.iter (sub.typ sub) tl
    | Ptyp_alias (t, _) -> sub.typ sub t
    | Ptyp_variant (rl, _b, _ll) ->
        List.iter (row_field sub) rl
    | Ptyp_poly (_, t) -> sub.typ sub t
    | Ptyp_package (lid, l) ->
        iter_loc sub lid;
        List.iter (iter_tuple (iter_loc sub) (sub.typ sub)) l
    | Ptyp_extension x -> sub.extension sub x

  let iter_type_declaration sub
      {ptype_name; ptype_params; ptype_cstrs;
       ptype_kind;
       ptype_private = _;
       ptype_manifest;
       ptype_attributes;
       ptype_loc} =
    iter_loc sub ptype_name;
    List.iter (iter_fst (sub.typ sub)) ptype_params;
    List.iter
      (iter_tuple3 (sub.typ sub) (sub.typ sub) (sub.location sub))
      ptype_cstrs;
    sub.type_kind sub ptype_kind;
    iter_opt (sub.typ sub) ptype_manifest;
    sub.location sub ptype_loc;
    sub.attributes sub ptype_attributes

  let iter_type_kind sub = function
    | Ptype_abstract -> ()
    | Ptype_variant l ->
        List.iter (sub.constructor_declaration sub) l
    | Ptype_record l -> List.iter (sub.label_declaration sub) l
    | Ptype_open -> ()

  let iter_constructor_arguments sub l = List.iter (sub.typ sub) l
      (*# no inline record in 4.02.3*)
  let iter_type_extension sub
      {ptyext_path; ptyext_params;
       ptyext_constructors;
       ptyext_private = _;
       ptyext_attributes} =
    iter_loc sub ptyext_path;
    List.iter (sub.extension_constructor sub) ptyext_constructors;
    List.iter (iter_fst (sub.typ sub)) ptyext_params;
    sub.attributes sub ptyext_attributes

  let iter_extension_constructor_kind sub = function
      Pext_decl(ctl, cto) ->
        iter_constructor_arguments sub ctl; iter_opt (sub.typ sub) cto
    | Pext_rebind li ->
        iter_loc sub li

  let iter_extension_constructor sub
      {pext_name;
       pext_kind;
       pext_loc;
       pext_attributes} =
    iter_loc sub pext_name;
    iter_extension_constructor_kind sub pext_kind;
    sub.location sub pext_loc;
    sub.attributes sub pext_attributes

end

module CT = struct
  (* Type expressions for the class language *)

  let iter sub {pcty_loc = loc; pcty_desc = desc; pcty_attributes = attrs} =
    sub.location sub loc;
    sub.attributes sub attrs;
    match desc with
    | Pcty_constr (lid, tys) ->
        iter_loc sub lid; List.iter (sub.typ sub) tys
    | Pcty_signature x -> sub.class_signature sub x
    | Pcty_arrow (_lab, t, ct) ->
        sub.typ sub t; sub.class_type sub ct
    | Pcty_extension x -> sub.extension sub x

  let iter_field sub {pctf_desc = desc; pctf_loc = loc; pctf_attributes = attrs}
    =
    sub.location sub loc;
    sub.attributes sub attrs;
    match desc with
    | Pctf_inherit ct -> sub.class_type sub ct
    | Pctf_val (_s, _m, _v, t) -> sub.typ sub t
    | Pctf_method (_s, _p, _v, t) -> sub.typ sub t
    | Pctf_constraint (t1, t2) ->
        sub.typ sub t1; sub.typ sub t2
    | Pctf_attribute x -> sub.attribute sub x
    | Pctf_extension x -> sub.extension sub x

  let iter_signature sub {pcsig_self; pcsig_fields} =
    sub.typ sub pcsig_self;
    List.iter (sub.class_type_field sub) pcsig_fields
end

module MT = struct
  (* Type expressions for the module language *)

  let iter sub {pmty_desc = desc; pmty_loc = loc; pmty_attributes = attrs} =
    sub.location sub loc;
    sub.attributes sub attrs;
    match desc with
    | Pmty_ident s -> iter_loc sub s
    | Pmty_alias s -> iter_loc sub s
    | Pmty_signature sg -> sub.signature sub sg
    | Pmty_functor (s, mt1, mt2) ->
        iter_loc sub s;
        iter_opt (sub.module_type sub) mt1;
        sub.module_type sub mt2
    | Pmty_with (mt, l) ->
        sub.module_type sub mt;
        List.iter (sub.with_constraint sub) l
    | Pmty_typeof me -> sub.module_expr sub me
    | Pmty_extension x -> sub.extension sub x

  let iter_with_constraint sub = function
    | Pwith_type (lid, d) ->
        iter_loc sub lid; sub.type_declaration sub d
    | Pwith_module (lid, lid2) ->
        iter_loc sub lid; iter_loc sub lid2
    | Pwith_typesubst d -> sub.type_declaration sub d
    | Pwith_modsubst (s, lid) ->
        iter_loc sub s; iter_loc sub lid

  let iter_signature_item sub {psig_desc = desc; psig_loc = loc} =
    sub.location sub loc;
    match desc with
    | Psig_value vd -> sub.value_description sub vd
    | Psig_type ( l) -> List.iter (sub.type_declaration sub) l
    (*#2 no rec_flag in 4.02.3*)
    | Psig_typext te -> sub.type_extension sub te
    | Psig_exception ed -> sub.extension_constructor sub ed
    | Psig_module x -> sub.module_declaration sub x
    | Psig_recmodule l ->
        List.iter (sub.module_declaration sub) l
    | Psig_modtype x -> sub.module_type_declaration sub x
    | Psig_open x -> sub.open_description sub x
    | Psig_include x -> sub.include_description sub x
    | Psig_class l -> List.iter (sub.class_description sub) l
    | Psig_class_type l ->
        List.iter (sub.class_type_declaration sub) l
    | Psig_extension (x, attrs) ->
        sub.extension sub x; sub.attributes sub attrs
    | Psig_attribute x -> sub.attribute sub x
end


module M = struct
  (* Value expressions for the module language *)

  let iter sub {pmod_loc = loc; pmod_desc = desc; pmod_attributes = attrs} =
    sub.location sub loc;
    sub.attributes sub attrs;
    match desc with
    | Pmod_ident x -> iter_loc sub x
    | Pmod_structure str -> sub.structure sub str
    | Pmod_functor (arg, arg_ty, body) ->
        iter_loc sub arg;
        iter_opt (sub.module_type sub) arg_ty;
        sub.module_expr sub body
    | Pmod_apply (m1, m2) ->
        sub.module_expr sub m1; sub.module_expr sub m2
    | Pmod_constraint (m, mty) ->
        sub.module_expr sub m; sub.module_type sub mty
    | Pmod_unpack e -> sub.expr sub e
    | Pmod_extension x -> sub.extension sub x

  let iter_structure_item sub {pstr_loc = loc; pstr_desc = desc} =
    sub.location sub loc;
    match desc with
    | Pstr_eval (x, attrs) ->
        sub.expr sub x; sub.attributes sub attrs
    | Pstr_value (_r, vbs) -> List.iter (sub.value_binding sub) vbs
    | Pstr_primitive vd -> sub.value_description sub vd
    | Pstr_type ( l) -> List.iter (sub.type_declaration sub) l
    (*#3 no rec flag in 4.02.3*)
    | Pstr_typext te -> sub.type_extension sub te
    | Pstr_exception ed -> sub.extension_constructor sub ed
    | Pstr_module x -> sub.module_binding sub x
    | Pstr_recmodule l -> List.iter (sub.module_binding sub) l
    | Pstr_modtype x -> sub.module_type_declaration sub x
    | Pstr_open x -> sub.open_description sub x
    | Pstr_class l -> List.iter (sub.class_declaration sub) l
    | Pstr_class_type l ->
        List.iter (sub.class_type_declaration sub) l
    | Pstr_include x -> sub.include_declaration sub x
    | Pstr_extension (x, attrs) ->
        sub.extension sub x; sub.attributes sub attrs
    | Pstr_attribute x -> sub.attribute sub x
end

module E = struct
  (* Value expressions for the core language *)

  let iter sub {pexp_loc = loc; pexp_desc = desc; pexp_attributes = attrs} =
    sub.location sub loc;
    sub.attributes sub attrs;
    match desc with
    | Pexp_ident x -> iter_loc sub x
    | Pexp_constant _ -> ()
    | Pexp_let (_r, vbs, e) ->
        List.iter (sub.value_binding sub) vbs;
        sub.expr sub e
    | Pexp_fun (_lab, def, p, e) ->
        iter_opt (sub.expr sub) def;
        sub.pat sub p;
        sub.expr sub e
    | Pexp_function pel -> sub.cases sub pel
    | Pexp_apply (e, l) ->
        sub.expr sub e; List.iter (iter_snd (sub.expr sub)) l
    | Pexp_match (e, pel) ->
        sub.expr sub e; sub.cases sub pel
    | Pexp_try (e, pel) -> sub.expr sub e; sub.cases sub pel
    | Pexp_tuple el -> List.iter (sub.expr sub) el
    | Pexp_construct (lid, arg) ->
        iter_loc sub lid; iter_opt (sub.expr sub) arg
    | Pexp_variant (_lab, eo) ->
        iter_opt (sub.expr sub) eo
    | Pexp_record (l, eo) ->
        List.iter (iter_tuple (iter_loc sub) (sub.expr sub)) l;
        iter_opt (sub.expr sub) eo
    | Pexp_field (e, lid) ->
        sub.expr sub e; iter_loc sub lid
    | Pexp_setfield (e1, lid, e2) ->
        sub.expr sub e1; iter_loc sub lid;
        sub.expr sub e2
    | Pexp_array el -> List.iter (sub.expr sub) el
    | Pexp_ifthenelse (e1, e2, e3) ->
        sub.expr sub e1; sub.expr sub e2;
        iter_opt (sub.expr sub) e3
    | Pexp_sequence (e1, e2) ->
        sub.expr sub e1; sub.expr sub e2
    | Pexp_while (e1, e2) ->
        sub.expr sub e1; sub.expr sub e2
    | Pexp_for (p, e1, e2, _d, e3) ->
        sub.pat sub p; sub.expr sub e1; sub.expr sub e2;
        sub.expr sub e3
    | Pexp_coerce (e, t1, t2) ->
        sub.expr sub e; iter_opt (sub.typ sub) t1;
        sub.typ sub t2
    | Pexp_constraint (e, t) ->
        sub.expr sub e; sub.typ sub t
    | Pexp_send (e, _s) -> sub.expr sub e
    | Pexp_new lid -> iter_loc sub lid
    | Pexp_setinstvar (s, e) ->
        iter_loc sub s; sub.expr sub e
    | Pexp_override sel ->
        List.iter (iter_tuple (iter_loc sub) (sub.expr sub)) sel
    | Pexp_letmodule (s, me, e) ->
        iter_loc sub s; sub.module_expr sub me;
        sub.expr sub e
    (* | Pexp_letexception (cd, e) -> *)
    (*     sub.extension_constructor sub cd; *)
    (*     sub.expr sub e *)
    (* no local exception *)
    | Pexp_assert e -> sub.expr sub e
    | Pexp_lazy e -> sub.expr sub e
    | Pexp_poly (e, t) ->
        sub.expr sub e; iter_opt (sub.typ sub) t
    | Pexp_object cls -> sub.class_structure sub cls
    | Pexp_newtype (_s, e) -> sub.expr sub e
    | Pexp_pack me -> sub.module_expr sub me
    | Pexp_open (_ovf, lid, e) ->
        iter_loc sub lid; sub.expr sub e
    | Pexp_extension x -> sub.extension sub x
    (* | Pexp_unreachable -> () *)
end

module P = struct
  (* Patterns *)

  let iter sub {ppat_desc = desc; ppat_loc = loc; ppat_attributes = attrs} =
    sub.location sub loc;
    sub.attributes sub attrs;
    match desc with
    | Ppat_any -> ()
    | Ppat_var s -> iter_loc sub s
    | Ppat_alias (p, s) -> sub.pat sub p; iter_loc sub s
    | Ppat_constant _ -> ()
    | Ppat_interval _ -> ()
    | Ppat_tuple pl -> List.iter (sub.pat sub) pl
    | Ppat_construct (l, p) ->
        iter_loc sub l; iter_opt (sub.pat sub) p
    | Ppat_variant (_l, p) -> iter_opt (sub.pat sub) p
    | Ppat_record (lpl, _cf) ->
        List.iter (iter_tuple (iter_loc sub) (sub.pat sub)) lpl
    | Ppat_array pl -> List.iter (sub.pat sub) pl
    | Ppat_or (p1, p2) -> sub.pat sub p1; sub.pat sub p2
    | Ppat_constraint (p, t) ->
        sub.pat sub p; sub.typ sub t
    | Ppat_type s -> iter_loc sub s
    | Ppat_lazy p -> sub.pat sub p
    | Ppat_unpack s -> iter_loc sub s
    | Ppat_exception p -> sub.pat sub p
    | Ppat_extension x -> sub.extension sub x
    (* | Ppat_open (lid, p) -> *)
    (*     iter_loc sub lid; sub.pat sub p *)

end

module CE = struct
  (* Value expressions for the class language *)

  let iter sub {pcl_loc = loc; pcl_desc = desc; pcl_attributes = attrs} =
    sub.location sub loc;
    sub.attributes sub attrs;
    match desc with
    | Pcl_constr (lid, tys) ->
        iter_loc sub lid; List.iter (sub.typ sub) tys
    | Pcl_structure s ->
        sub.class_structure sub s
    | Pcl_fun (_lab, e, p, ce) ->
        iter_opt (sub.expr sub) e;
        sub.pat sub p;
        sub.class_expr sub ce
    | Pcl_apply (ce, l) ->
        sub.class_expr sub ce;
        List.iter (iter_snd (sub.expr sub)) l
    | Pcl_let (_r, vbs, ce) ->
        List.iter (sub.value_binding sub) vbs;
        sub.class_expr sub ce
    | Pcl_constraint (ce, ct) ->
        sub.class_expr sub ce; sub.class_type sub ct
    | Pcl_extension x -> sub.extension sub x

  let iter_kind sub = function
    | Cfk_concrete (_o, e) -> sub.expr sub e
    | Cfk_virtual t -> sub.typ sub t

  let iter_field sub {pcf_desc = desc; pcf_loc = loc; pcf_attributes = attrs} =
    sub.location sub loc;
    sub.attributes sub attrs;
    match desc with
    | Pcf_inherit (_o, ce, _s) -> sub.class_expr sub ce
    | Pcf_val (s, _m, k) -> iter_loc sub s; iter_kind sub k
    | Pcf_method (s, _p, k) ->
        iter_loc sub s; iter_kind sub k
    | Pcf_constraint (t1, t2) ->
        sub.typ sub t1; sub.typ sub t2
    | Pcf_initializer e -> sub.expr sub e
    | Pcf_attribute x -> sub.attribute sub x
    | Pcf_extension x -> sub.extension sub x

  let iter_structure sub {pcstr_self; pcstr_fields} =
    sub.pat sub pcstr_self;
    List.iter (sub.class_field sub) pcstr_fields

  let class_infos sub f {pci_virt = _; pci_params = pl; pci_name; pci_expr;
                         pci_loc; pci_attributes} =
    List.iter (iter_fst (sub.typ sub)) pl;
    iter_loc sub pci_name;
    f pci_expr;
    sub.location sub pci_loc;
    sub.attributes sub pci_attributes
end

(* Now, a generic AST mapper, to be extended to cover all kinds and
   cases of the OCaml grammar.  The default behavior of the mapper is
   the identity. *)

let default_iterator =
  {
    structure = (fun this l -> List.iter (this.structure_item this) l);
    structure_item = M.iter_structure_item;
    module_expr = M.iter;
    signature = (fun this l -> List.iter (this.signature_item this) l);
    signature_item = MT.iter_signature_item;
    module_type = MT.iter;
    with_constraint = MT.iter_with_constraint;
    class_declaration =
      (fun this -> CE.class_infos this (this.class_expr this));
    class_expr = CE.iter;
    class_field = CE.iter_field;
    class_structure = CE.iter_structure;
    class_type = CT.iter;
    class_type_field = CT.iter_field;
    class_signature = CT.iter_signature;
    class_type_declaration =
      (fun this -> CE.class_infos this (this.class_type this));
    class_description =
      (fun this -> CE.class_infos this (this.class_type this));
    type_declaration = T.iter_type_declaration;
    type_kind = T.iter_type_kind;
    typ = T.iter;
    type_extension = T.iter_type_extension;
    extension_constructor = T.iter_extension_constructor;
    value_description =
      (fun this {pval_name; pval_type; pval_prim = _; pval_loc;
                 pval_attributes} ->
        iter_loc this pval_name;
        this.typ this pval_type;
        this.attributes this pval_attributes;
        this.location this pval_loc
      );

    pat = P.iter;
    expr = E.iter;

    module_declaration =
      (fun this {pmd_name; pmd_type; pmd_attributes; pmd_loc} ->
         iter_loc this pmd_name;
         this.module_type this pmd_type;
         this.attributes this pmd_attributes;
         this.location this pmd_loc
      );

    module_type_declaration =
      (fun this {pmtd_name; pmtd_type; pmtd_attributes; pmtd_loc} ->
         iter_loc this pmtd_name;
         iter_opt (this.module_type this) pmtd_type;
         this.attributes this pmtd_attributes;
         this.location this pmtd_loc
      );

    module_binding =
      (fun this {pmb_name; pmb_expr; pmb_attributes; pmb_loc} ->
         iter_loc this pmb_name; this.module_expr this pmb_expr;
         this.attributes this pmb_attributes;
         this.location this pmb_loc
      );


    open_description =
      (fun this {popen_lid; popen_override = _; popen_attributes; popen_loc} ->
         iter_loc this popen_lid;
         this.location this popen_loc;
         this.attributes this popen_attributes
      );


    include_description =
      (fun this {pincl_mod; pincl_attributes; pincl_loc} ->
         this.module_type this pincl_mod;
         this.location this pincl_loc;
         this.attributes this pincl_attributes
      );

    include_declaration =
      (fun this {pincl_mod; pincl_attributes; pincl_loc} ->
         this.module_expr this pincl_mod;
         this.location this pincl_loc;
         this.attributes this pincl_attributes
      );


    value_binding =
      (fun this {pvb_pat; pvb_expr; pvb_attributes; pvb_loc} ->
         this.pat this pvb_pat;
         this.expr this pvb_expr;
         this.location this pvb_loc;
         this.attributes this pvb_attributes
      );


    constructor_declaration =
      (fun this {pcd_name; pcd_args; pcd_res; pcd_loc; pcd_attributes} ->
         iter_loc this pcd_name;
         T.iter_constructor_arguments this pcd_args;
         iter_opt (this.typ this) pcd_res;
         this.location this pcd_loc;
         this.attributes this pcd_attributes
      );

    label_declaration =
      (fun this {pld_name; pld_type; pld_loc; pld_mutable = _; pld_attributes}->
         iter_loc this pld_name;
         this.typ this pld_type;
         this.location this pld_loc;
         this.attributes this pld_attributes
      );

    cases = (fun this l -> List.iter (this.case this) l);
    case =
      (fun this {pc_lhs; pc_guard; pc_rhs} ->
         this.pat this pc_lhs;
         iter_opt (this.expr this) pc_guard;
         this.expr this pc_rhs
      );

    location = (fun _this _l -> ());

    extension = (fun this (s, e) -> iter_loc this s; this.payload this e);
    attribute = (fun this (s, e) -> iter_loc this s; this.payload this e);
    attributes = (fun this l -> List.iter (this.attribute this) l);
    payload =
      (fun this -> function
         | PStr x -> this.structure this x
         (* | PSig x -> this.signature this x *)
         | PTyp x -> this.typ this x
         | PPat (x, g) -> this.pat this x; iter_opt (this.expr this) g
      );
  }

end
module Bs_warnings : sig 
#1 "bs_warnings.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


type t = 
  | Unsafe_ffi_bool_type
  | Unsafe_poly_variant_type

(* val print_string_warning : Location.t -> string -> unit *)

val prerr_warning : Location.t -> t -> unit

(**It will always warn not relevant to whether {!Js_config.warn_unused_attribute} set or not
   User should check it first. 
   The reason is that we will do a global check first, then start warning later
*)
val warn_unused_attribute : Location.t -> string -> unit

val error_unescaped_delimiter : 
  Location.t -> string  -> unit 
end = struct
#1 "bs_warnings.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)



type t = 
  | Unsafe_ffi_bool_type

  | Unsafe_poly_variant_type
  (* for users write code like this:
     {[ external f : [`a of int ] -> string = ""]}
     Here users forget about `[@bs.string]` or `[@bs.int]`
  *)    



let to_string t =
  match t with
  | Unsafe_ffi_bool_type
    ->   
    "You are passing a OCaml bool type into JS, probably you want to pass Js.boolean"
  | Unsafe_poly_variant_type 
    -> 
    "Here a OCaml polymorphic variant type passed into JS, probably you forgot annotations like `[@bs.int]` or `[@bs.string]`  "

let warning_formatter = Format.err_formatter

let print_string_warning loc x = 
  Location.print warning_formatter loc ; 
  Format.pp_print_string warning_formatter "Warning: ";
  Format.pp_print_string warning_formatter x;
  Format.pp_print_string warning_formatter "\n"

let prerr_warning loc x =
  if not (!Js_config.no_warn_ffi_type ) then
    print_string_warning loc (to_string x) 


type error = 
  | Unused_attribute of string
  | Uninterpreted_delimiters of string

exception  Error of Location.t * error

let pp_error fmt x =
  match x with 
  | Unused_attribute str ->
    Format.pp_print_string fmt Literals.unused_attribute;
    Format.pp_print_string fmt str
  | Uninterpreted_delimiters str -> 
    Format.pp_print_string fmt "Uninterpreted delimiters" ;
    Format.pp_print_string fmt str



let () = 
  Location.register_error_of_exn (function 
    | Error (loc,err) -> 
      Some (Location.error_of_printer loc pp_error err)
    | _ -> None
    )



let warn_unused_attribute loc txt =
  if !Js_config.no_error_unused_bs_attribute then 
    begin 
      print_string_warning loc ( Literals.unused_attribute  ^ txt ^ " \n" );
      Format.pp_print_flush warning_formatter ()
    end
  else 
    raise (Error(loc, Unused_attribute txt))

let error_unescaped_delimiter loc txt = 
  raise (Error(loc, Uninterpreted_delimiters txt))






(**
Note the standard way of reporting error in compiler:

val Location.register_error_of_exn : (exn -> Location.error option) -> unit 
val Location.error_of_printer : Location.t ->
  (Format.formatter -> error -> unit) -> error -> Location.error

Define an error type

type error 
exception Error of Location.t * error 

Provide a printer to error

{[
  let () = 
    Location.register_error_of_exn
      (function 
        | Error(loc,err) -> 
          Some (Location.error_of_printer loc pp_error err)
        | _ -> None
      )
]}
*)

end
module Bs_ast_invariant : sig 
#1 "bs_ast_invariant.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


(** Ast invariant checking for detecting errors *)
val emit_external_warnings : Bs_ast_iterator.iterator

end = struct
#1 "bs_ast_invariant.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


let is_bs_attribute txt = 
  let len = String.length txt  in
  len >= 2 &&
  (*TODO: check the stringing padding rule, this preciate may not be needed *)
  String.unsafe_get txt 0 = 'b'&& 
  String.unsafe_get txt 1 = 's' &&
  (len = 2 ||
   String.unsafe_get txt 2 = '.'
  )


let emit_external_warnings : Bs_ast_iterator .iterator=
  {
    Bs_ast_iterator.default_iterator with
    attribute = (fun _ a ->
        match a with
        | {txt ; loc}, _ ->
          if is_bs_attribute txt  then
            Bs_warnings.warn_unused_attribute loc txt 
      );
    expr = (fun self a -> 
      match a.Parsetree.pexp_desc with 
      | Pexp_constant (Const_string (_, Some s)) 
        when Ext_string.equal s Literals.unescaped_j_delimiter 
        || Ext_string.equal s Literals.unescaped_js_delimiter -> 
        Bs_warnings.error_unescaped_delimiter a.pexp_loc s 
      | _ -> Bs_ast_iterator.default_iterator.expr self a 
    );
    value_description =
    (fun self v -> 
       match v with 
       | ( {
            pval_loc;
            pval_prim =
               "%identity"::_;
            pval_type
        } : Parsetree.value_description)
         when not
             (Ast_core_type.is_arity_one pval_type)
         -> 
           Location.raise_errorf
             ~loc:pval_loc
             "%%identity expect its type to be of form 'a -> 'b (arity 1)"
       | _ ->
         Bs_ast_iterator.default_iterator.value_description self v 
         
      )
  }

end
module Ident : sig 
#1 "ident.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Identifiers (unique names) *)

type t = { stamp: int; name: string; mutable flags: int }

val create: string -> t
val create_persistent: string -> t
val create_predef_exn: string -> t
val rename: t -> t
val name: t -> string
val unique_name: t -> string
val unique_toplevel_name: t -> string
val persistent: t -> bool
val equal: t -> t -> bool
        (* Compare identifiers by name. *)
val same: t -> t -> bool
        (* Compare identifiers by binding location.
           Two identifiers are the same either if they are both
           non-persistent and have been created by the same call to
           [new], or if they are both persistent and have the same
           name. *)
val hide: t -> t
        (* Return an identifier with same name as the given identifier,
           but stamp different from any stamp returned by new.
           When put in a 'a tbl, this identifier can only be looked
           up by name. *)

val make_global: t -> unit
val global: t -> bool
val is_predef_exn: t -> bool

val binding_time: t -> int
val current_time: unit -> int
val set_current_time: int -> unit
val reinit: unit -> unit

val print: Format.formatter -> t -> unit

type 'a tbl
        (* Association tables from identifiers to type 'a. *)

val empty: 'a tbl
val add: t -> 'a -> 'a tbl -> 'a tbl
val find_same: t -> 'a tbl -> 'a
val find_name: string -> 'a tbl -> 'a
val find_all: string -> 'a tbl -> 'a list
val fold_name: (t -> 'a -> 'b -> 'b) -> 'a tbl -> 'b -> 'b
val fold_all: (t -> 'a -> 'b -> 'b) -> 'a tbl -> 'b -> 'b
val iter: (t -> 'a -> unit) -> 'a tbl -> unit


(* Idents for sharing keys *)

val make_key_generator : unit -> (t -> t)

end = struct
#1 "ident.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Format

type t = { stamp: int; name: string; mutable flags: int }

let global_flag = 1
let predef_exn_flag = 2

(* A stamp of 0 denotes a persistent identifier *)

let currentstamp = ref 0

let create s =
  incr currentstamp;
  { name = s; stamp = !currentstamp; flags = 0 }

let create_predef_exn s =
  incr currentstamp;
  { name = s; stamp = !currentstamp; flags = predef_exn_flag }

let create_persistent s =
  { name = s; stamp = 0; flags = global_flag }

let rename i =
  incr currentstamp;
  { i with stamp = !currentstamp }

let name i = i.name

let stamp i = i.stamp

let unique_name i = i.name ^ "_" ^ string_of_int i.stamp

let unique_toplevel_name i = i.name ^ "/" ^ string_of_int i.stamp

let persistent i = (i.stamp = 0)

let equal i1 i2 = i1.name = i2.name

let same i1 i2 = i1 = i2
  (* Possibly more efficient version (with a real compiler, at least):
       if i1.stamp <> 0
       then i1.stamp = i2.stamp
       else i2.stamp = 0 && i1.name = i2.name *)

let binding_time i = i.stamp

let current_time() = !currentstamp
let set_current_time t = currentstamp := max !currentstamp t

let reinit_level = ref (-1)

let reinit () =
  if !reinit_level < 0
  then reinit_level := !currentstamp
  else currentstamp := !reinit_level

let hide i =
  { i with stamp = -1 }

let make_global i =
  i.flags <- i.flags lor global_flag

let global i =
  (i.flags land global_flag) <> 0

let is_predef_exn i =
  (i.flags land predef_exn_flag) <> 0

let print ppf i =
  match i.stamp with
  | 0 -> fprintf ppf "%s!" i.name
  | -1 -> fprintf ppf "%s#" i.name
  | n -> fprintf ppf "%s/%i%s" i.name n (if global i then "g" else "")

type 'a tbl =
    Empty
  | Node of 'a tbl * 'a data * 'a tbl * int

and 'a data =
  { ident: t;
    data: 'a;
    previous: 'a data option }

let empty = Empty

(* Inline expansion of height for better speed
 * let height = function
 *     Empty -> 0
 *   | Node(_,_,_,h) -> h
 *)

let mknode l d r =
  let hl = match l with Empty -> 0 | Node(_,_,_,h) -> h
  and hr = match r with Empty -> 0 | Node(_,_,_,h) -> h in
  Node(l, d, r, (if hl >= hr then hl + 1 else hr + 1))

let balance l d r =
  let hl = match l with Empty -> 0 | Node(_,_,_,h) -> h
  and hr = match r with Empty -> 0 | Node(_,_,_,h) -> h in
  if hl > hr + 1 then
    match l with
    | Node (ll, ld, lr, _)
      when (match ll with Empty -> 0 | Node(_,_,_,h) -> h) >=
           (match lr with Empty -> 0 | Node(_,_,_,h) -> h) ->
        mknode ll ld (mknode lr d r)
    | Node (ll, ld, Node(lrl, lrd, lrr, _), _) ->
        mknode (mknode ll ld lrl) lrd (mknode lrr d r)
    | _ -> assert false
  else if hr > hl + 1 then
    match r with
    | Node (rl, rd, rr, _)
      when (match rr with Empty -> 0 | Node(_,_,_,h) -> h) >=
           (match rl with Empty -> 0 | Node(_,_,_,h) -> h) ->
        mknode (mknode l d rl) rd rr
    | Node (Node (rll, rld, rlr, _), rd, rr, _) ->
        mknode (mknode l d rll) rld (mknode rlr rd rr)
    | _ -> assert false
  else
    mknode l d r

let rec add id data = function
    Empty ->
      Node(Empty, {ident = id; data = data; previous = None}, Empty, 1)
  | Node(l, k, r, h) ->
      let c = compare id.name k.ident.name in
      if c = 0 then
        Node(l, {ident = id; data = data; previous = Some k}, r, h)
      else if c < 0 then
        balance (add id data l) k r
      else
        balance l k (add id data r)

let rec find_stamp s = function
    None ->
      raise Not_found
  | Some k ->
      if k.ident.stamp = s then k.data else find_stamp s k.previous

let rec find_same id = function
    Empty ->
      raise Not_found
  | Node(l, k, r, _) ->
      let c = compare id.name k.ident.name in
      if c = 0 then
        if id.stamp = k.ident.stamp
        then k.data
        else find_stamp id.stamp k.previous
      else
        find_same id (if c < 0 then l else r)

let rec find_name name = function
    Empty ->
      raise Not_found
  | Node(l, k, r, _) ->
      let c = compare name k.ident.name in
      if c = 0 then
        k.data
      else
        find_name name (if c < 0 then l else r)

let rec get_all = function
  | None -> []
  | Some k -> k.data :: get_all k.previous

let rec find_all name = function
    Empty ->
      []
  | Node(l, k, r, _) ->
      let c = compare name k.ident.name in
      if c = 0 then
        k.data :: get_all k.previous
      else
        find_all name (if c < 0 then l else r)

let rec fold_aux f stack accu = function
    Empty ->
      begin match stack with
        [] -> accu
      | a :: l -> fold_aux f l accu a
      end
  | Node(l, k, r, _) ->
      fold_aux f (l :: stack) (f k accu) r

let fold_name f tbl accu = fold_aux (fun k -> f k.ident k.data) [] accu tbl

let rec fold_data f d accu =
  match d with
    None -> accu
  | Some k -> f k.ident k.data (fold_data f k.previous accu)

let fold_all f tbl accu =
  fold_aux (fun k -> fold_data f (Some k)) [] accu tbl

(* let keys tbl = fold_name (fun k _ accu -> k::accu) tbl [] *)

let rec iter f = function
    Empty -> ()
  | Node(l, k, r, _) ->
      iter f l; f k.ident k.data; iter f r

(* Idents for sharing keys *)

(* They should be 'totally fresh' -> neg numbers *)
let key_name = ""

let make_key_generator () =
  let c = ref 1 in
  fun id ->
    let stamp = !c in
    decr c ;
    { id with name = key_name; stamp = stamp; }

end
module Path : sig 
#1 "path.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Access paths *)

type t =
    Pident of Ident.t
  | Pdot of t * string * int
  | Papply of t * t

val same: t -> t -> bool
val isfree: Ident.t -> t -> bool
val binding_time: t -> int

val nopos: int

val name: ?paren:(string -> bool) -> t -> string
    (* [paren] tells whether a path suffix needs parentheses *)
val head: t -> Ident.t

val last: t -> string

end = struct
#1 "path.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

type t =
    Pident of Ident.t
  | Pdot of t * string * int
  | Papply of t * t

let nopos = -1

let rec same p1 p2 =
  match (p1, p2) with
    (Pident id1, Pident id2) -> Ident.same id1 id2
  | (Pdot(p1, s1, pos1), Pdot(p2, s2, pos2)) -> s1 = s2 && same p1 p2
  | (Papply(fun1, arg1), Papply(fun2, arg2)) ->
       same fun1 fun2 && same arg1 arg2
  | (_, _) -> false

let rec isfree id = function
    Pident id' -> Ident.same id id'
  | Pdot(p, s, pos) -> isfree id p
  | Papply(p1, p2) -> isfree id p1 || isfree id p2

let rec binding_time = function
    Pident id -> Ident.binding_time id
  | Pdot(p, s, pos) -> binding_time p
  | Papply(p1, p2) -> max (binding_time p1) (binding_time p2)

let kfalse x = false

let rec name ?(paren=kfalse) = function
    Pident id -> Ident.name id
  | Pdot(p, s, pos) ->
      name ~paren p ^ if paren s then ".( " ^ s ^ " )" else "." ^ s
  | Papply(p1, p2) -> name ~paren p1 ^ "(" ^ name ~paren p2 ^ ")"

let rec head = function
    Pident id -> id
  | Pdot(p, s, pos) -> head p
  | Papply(p1, p2) -> assert false

let rec last = function
  | Pident id -> Ident.name id
  | Pdot(_, s, _) -> s
  | Papply(_, p) -> last p

end
module Primitive : sig 
#1 "primitive.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Description of primitive functions *)

type description =
  { prim_name: string;         (* Name of primitive  or C function *)
    prim_arity: int;           (* Number of arguments *)
    prim_alloc: bool;          (* Does it allocates or raise? *)
    prim_native_name: string;  (* Name of C function for the nat. code gen. *)
    prim_native_float: bool }  (* Does the above operate on unboxed floats? *)

val parse_declaration: int -> string list -> description

val description_list: description -> string list

val native_name: description -> string
val byte_name: description -> string

end = struct
#1 "primitive.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Description of primitive functions *)

open Misc

type description =
  { prim_name: string;         (* Name of primitive  or C function *)
    prim_arity: int;           (* Number of arguments *)
    prim_alloc: bool;          (* Does it allocates or raise? *)
    prim_native_name: string;  (* Name of C function for the nat. code gen. *)
    prim_native_float: bool }  (* Does the above operate on unboxed floats? *)

let parse_declaration arity decl =
  match decl with
  | name :: "noalloc" :: name2 :: "float" :: _ ->
      {prim_name = name; prim_arity = arity; prim_alloc = false;
       prim_native_name = name2; prim_native_float = true}
  | name :: "noalloc" :: name2 :: _ ->
      {prim_name = name; prim_arity = arity; prim_alloc = false;
       prim_native_name = name2; prim_native_float = false}
  | name :: name2 :: "float" :: _ ->
      {prim_name = name; prim_arity = arity; prim_alloc = true;
       prim_native_name = name2; prim_native_float = true}
  | name :: "noalloc" :: _ ->
      {prim_name = name; prim_arity = arity; prim_alloc = false;
       prim_native_name = ""; prim_native_float = false}
  | name :: name2 :: _ ->
      {prim_name = name; prim_arity = arity; prim_alloc = true;
       prim_native_name = name2; prim_native_float = false}
  | name :: _ ->
      {prim_name = name; prim_arity = arity; prim_alloc = true;
       prim_native_name = ""; prim_native_float = false}
  | [] ->
      fatal_error "Primitive.parse_declaration"

let description_list p =
  let list = [p.prim_name] in
  let list = if not p.prim_alloc then "noalloc" :: list else list in
  let list =
    if p.prim_native_name <> "" then p.prim_native_name :: list else list
  in
  let list = if p.prim_native_float then "float" :: list else list in
  List.rev list

let native_name p =
  if p.prim_native_name <> ""
  then p.prim_native_name
  else p.prim_name

let byte_name p =
  p.prim_name

end
module Types : sig 
#1 "types.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Representation of types and declarations *)

open Asttypes

(* Type expressions for the core language *)

type type_expr =
  { mutable desc: type_desc;
    mutable level: int;
    mutable id: int }

and type_desc =
    Tvar of string option
  | Tarrow of label * type_expr * type_expr * commutable
  | Ttuple of type_expr list
  | Tconstr of Path.t * type_expr list * abbrev_memo ref
  | Tobject of type_expr * (Path.t * type_expr list) option ref
  | Tfield of string * field_kind * type_expr * type_expr
  | Tnil
  | Tlink of type_expr
  | Tsubst of type_expr         (* for copying *)
  | Tvariant of row_desc
  | Tunivar of string option
  | Tpoly of type_expr * type_expr list
  | Tpackage of Path.t * Longident.t list * type_expr list

and row_desc =
    { row_fields: (label * row_field) list;
      row_more: type_expr;
      row_bound: unit; (* kept for compatibility *)
      row_closed: bool;
      row_fixed: bool;
      row_name: (Path.t * type_expr list) option }

and row_field =
    Rpresent of type_expr option
  | Reither of bool * type_expr list * bool * row_field option ref
        (* 1st true denotes a constant constructor *)
        (* 2nd true denotes a tag in a pattern matching, and
           is erased later *)
  | Rabsent

and abbrev_memo =
    Mnil
  | Mcons of private_flag * Path.t * type_expr * type_expr * abbrev_memo
  | Mlink of abbrev_memo ref

and field_kind =
    Fvar of field_kind option ref
  | Fpresent
  | Fabsent

and commutable =
    Cok
  | Cunknown
  | Clink of commutable ref

module TypeOps : sig
  type t = type_expr
  val compare : t -> t -> int
  val equal : t -> t -> bool
  val hash : t -> int
end

(* Maps of methods and instance variables *)

module Meths : Map.S with type key = string
module Vars  : Map.S with type key = string

(* Value descriptions *)

type value_description =
  { val_type: type_expr;                (* Type of the value *)
    val_kind: value_kind;
    val_loc: Location.t;
    val_attributes: Parsetree.attributes;
   }

and value_kind =
    Val_reg                             (* Regular value *)
  | Val_prim of Primitive.description   (* Primitive *)
  | Val_ivar of mutable_flag * string   (* Instance variable (mutable ?) *)
  | Val_self of (Ident.t * type_expr) Meths.t ref *
                (Ident.t * mutable_flag * virtual_flag * type_expr) Vars.t ref *
                string * type_expr
                                        (* Self *)
  | Val_anc of (string * Ident.t) list * string
                                        (* Ancestor *)
  | Val_unbound                         (* Unbound variable *)

(* Constructor descriptions *)

type constructor_description =
  { cstr_name: string;                  (* Constructor name *)
    cstr_res: type_expr;                (* Type of the result *)
    cstr_existentials: type_expr list;  (* list of existentials *)
    cstr_args: type_expr list;          (* Type of the arguments *)
    cstr_arity: int;                    (* Number of arguments *)
    cstr_tag: constructor_tag;          (* Tag for heap blocks *)
    cstr_consts: int;                   (* Number of constant constructors *)
    cstr_nonconsts: int;                (* Number of non-const constructors *)
    cstr_normal: int;                   (* Number of non generalized constrs *)
    cstr_generalized: bool;             (* Constrained return type? *)
    cstr_private: private_flag;         (* Read-only constructor? *)
    cstr_loc: Location.t;
    cstr_attributes: Parsetree.attributes;
   }

and constructor_tag =
    Cstr_constant of int                (* Constant constructor (an int) *)
  | Cstr_block of int                   (* Regular constructor (a block) *)
  | Cstr_extension of Path.t * bool     (* Extension constructor
                                           true if a constant false if a block*)

(* Record label descriptions *)

type label_description =
  { lbl_name: string;                   (* Short name *)
    lbl_res: type_expr;                 (* Type of the result *)
    lbl_arg: type_expr;                 (* Type of the argument *)
    lbl_mut: mutable_flag;              (* Is this a mutable field? *)
    lbl_pos: int;                       (* Position in block *)
    lbl_all: label_description array;   (* All the labels in this type *)
    lbl_repres: record_representation;  (* Representation for this record *)
    lbl_private: private_flag;          (* Read-only field? *)
    lbl_loc: Location.t;
    lbl_attributes: Parsetree.attributes;
  }

and record_representation =
    Record_regular                      (* All fields are boxed / tagged *)
  | Record_float                        (* All fields are floats *)

(* Variance *)

module Variance : sig
  type t
  type f = May_pos | May_neg | May_weak | Inj | Pos | Neg | Inv
  val null : t                          (* no occurence *)
  val full : t                          (* strictly invariant *)
  val covariant : t                     (* strictly covariant *)
  val may_inv : t                       (* maybe invariant *)
  val union  : t -> t -> t
  val inter  : t -> t -> t
  val subset : t -> t -> bool
  val set : f -> bool -> t -> t
  val mem : f -> t -> bool
  val conjugate : t -> t                (* exchange positive and negative *)
  val get_upper : t -> bool * bool                  (* may_pos, may_neg   *)
  val get_lower : t -> bool * bool * bool * bool    (* pos, neg, inv, inj *)
end

(* Type definitions *)

type type_declaration =
  { type_params: type_expr list;
    type_arity: int;
    type_kind: type_kind;
    type_private: private_flag;
    type_manifest: type_expr option;
    type_variance: Variance.t list;
    (* covariant, contravariant, weakly contravariant, injective *)
    type_newtype_level: (int * int) option;
    (* definition level * expansion level *)
    type_loc: Location.t;
    type_attributes: Parsetree.attributes;
  }

and type_kind =
    Type_abstract
  | Type_record of label_declaration list  * record_representation
  | Type_variant of constructor_declaration list
  | Type_open

and label_declaration =
  {
    ld_id: Ident.t;
    ld_mutable: mutable_flag;
    ld_type: type_expr;
    ld_loc: Location.t;
    ld_attributes: Parsetree.attributes;
  }

and constructor_declaration =
  {
    cd_id: Ident.t;
    cd_args: type_expr list;
    cd_res: type_expr option;
    cd_loc: Location.t;
    cd_attributes: Parsetree.attributes;
  }

type extension_constructor =
    {
      ext_type_path: Path.t;
      ext_type_params: type_expr list;
      ext_args: type_expr list;
      ext_ret_type: type_expr option;
      ext_private: private_flag;
      ext_loc: Location.t;
      ext_attributes: Parsetree.attributes;
    }

and type_transparence =
    Type_public      (* unrestricted expansion *)
  | Type_new         (* "new" type *)
  | Type_private     (* private type *)

(* Type expressions for the class language *)

module Concr : Set.S with type elt = string

type class_type =
    Cty_constr of Path.t * type_expr list * class_type
  | Cty_signature of class_signature
  | Cty_arrow of label * type_expr * class_type

and class_signature =
  { csig_self: type_expr;
    csig_vars:
      (Asttypes.mutable_flag * Asttypes.virtual_flag * type_expr) Vars.t;
    csig_concr: Concr.t;
    csig_inher: (Path.t * type_expr list) list }

type class_declaration =
  { cty_params: type_expr list;
    mutable cty_type: class_type;
    cty_path: Path.t;
    cty_new: type_expr option;
    cty_variance: Variance.t list;
    cty_loc: Location.t;
    cty_attributes: Parsetree.attributes;
  }

type class_type_declaration =
  { clty_params: type_expr list;
    clty_type: class_type;
    clty_path: Path.t;
    clty_variance: Variance.t list;
    clty_loc: Location.t;
    clty_attributes: Parsetree.attributes;
  }

(* Type expressions for the module language *)

type module_type =
    Mty_ident of Path.t
  | Mty_signature of signature
  | Mty_functor of Ident.t * module_type option * module_type
  | Mty_alias of Path.t

and signature = signature_item list

and signature_item =
    Sig_value of Ident.t * value_description
  | Sig_type of Ident.t * type_declaration * rec_status
  | Sig_typext of Ident.t * extension_constructor * ext_status
  | Sig_module of Ident.t * module_declaration * rec_status
  | Sig_modtype of Ident.t * modtype_declaration
  | Sig_class of Ident.t * class_declaration * rec_status
  | Sig_class_type of Ident.t * class_type_declaration * rec_status

and module_declaration =
  {
    md_type: module_type;
    md_attributes: Parsetree.attributes;
    md_loc: Location.t;
  }

and modtype_declaration =
  {
    mtd_type: module_type option;  (* None: abstract *)
    mtd_attributes: Parsetree.attributes;
    mtd_loc: Location.t;
  }

and rec_status =
    Trec_not                            (* first in a nonrecursive group *)
  | Trec_first                          (* first in a recursive group *)
  | Trec_next                           (* not first in a recursive/nonrecursive group *)

and ext_status =
    Text_first                     (* first constructor in an extension *)
  | Text_next                      (* not first constructor in an extension *)
  | Text_exception

val equal_tag :  constructor_tag -> constructor_tag -> bool
end = struct
#1 "types.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Representation of types and declarations *)

open Asttypes

(* Type expressions for the core language *)

type type_expr =
  { mutable desc: type_desc;
    mutable level: int;
    mutable id: int }

and type_desc =
    Tvar of string option
  | Tarrow of label * type_expr * type_expr * commutable
  | Ttuple of type_expr list
  | Tconstr of Path.t * type_expr list * abbrev_memo ref
  | Tobject of type_expr * (Path.t * type_expr list) option ref
  | Tfield of string * field_kind * type_expr * type_expr
  | Tnil
  | Tlink of type_expr
  | Tsubst of type_expr         (* for copying *)
  | Tvariant of row_desc
  | Tunivar of string option
  | Tpoly of type_expr * type_expr list
  | Tpackage of Path.t * Longident.t list * type_expr list

and row_desc =
    { row_fields: (label * row_field) list;
      row_more: type_expr;
      row_bound: unit;
      row_closed: bool;
      row_fixed: bool;
      row_name: (Path.t * type_expr list) option }

and row_field =
    Rpresent of type_expr option
  | Reither of bool * type_expr list * bool * row_field option ref
        (* 1st true denotes a constant constructor *)
        (* 2nd true denotes a tag in a pattern matching, and
           is erased later *)
  | Rabsent

and abbrev_memo =
    Mnil
  | Mcons of private_flag * Path.t * type_expr * type_expr * abbrev_memo
  | Mlink of abbrev_memo ref

and field_kind =
    Fvar of field_kind option ref
  | Fpresent
  | Fabsent

and commutable =
    Cok
  | Cunknown
  | Clink of commutable ref

module TypeOps = struct
  type t = type_expr
  let compare t1 t2 = t1.id - t2.id
  let hash t = t.id
  let equal t1 t2 = t1 == t2
end

(* Maps of methods and instance variables *)

module OrderedString =
  struct type t = string let compare (x:t) y = compare x y end
module Meths = Map.Make(OrderedString)
module Vars = Meths

(* Value descriptions *)

type value_description =
  { val_type: type_expr;                (* Type of the value *)
    val_kind: value_kind;
    val_loc: Location.t;
    val_attributes: Parsetree.attributes;
 }

and value_kind =
    Val_reg                             (* Regular value *)
  | Val_prim of Primitive.description   (* Primitive *)
  | Val_ivar of mutable_flag * string   (* Instance variable (mutable ?) *)
  | Val_self of (Ident.t * type_expr) Meths.t ref *
                (Ident.t * Asttypes.mutable_flag *
                 Asttypes.virtual_flag * type_expr) Vars.t ref *
                string * type_expr
                                        (* Self *)
  | Val_anc of (string * Ident.t) list * string
                                        (* Ancestor *)
  | Val_unbound                         (* Unbound variable *)

(* Constructor descriptions *)

type constructor_description =
  { cstr_name: string;                  (* Constructor name *)
    cstr_res: type_expr;                (* Type of the result *)
    cstr_existentials: type_expr list;  (* list of existentials *)
    cstr_args: type_expr list;          (* Type of the arguments *)
    cstr_arity: int;                    (* Number of arguments *)
    cstr_tag: constructor_tag;          (* Tag for heap blocks *)
    cstr_consts: int;                   (* Number of constant constructors *)
    cstr_nonconsts: int;                (* Number of non-const constructors *)
    cstr_normal: int;                   (* Number of non generalized constrs *)
    cstr_generalized: bool;             (* Constrained return type? *)
    cstr_private: private_flag;         (* Read-only constructor? *)
    cstr_loc: Location.t;
    cstr_attributes: Parsetree.attributes;
   }

and constructor_tag =
    Cstr_constant of int                (* Constant constructor (an int) *)
  | Cstr_block of int                   (* Regular constructor (a block) *)
  | Cstr_extension of Path.t * bool     (* Extension constructor
                                           true if a constant false if a block*)

(* Record label descriptions *)

type label_description =
  { lbl_name: string;                   (* Short name *)
    lbl_res: type_expr;                 (* Type of the result *)
    lbl_arg: type_expr;                 (* Type of the argument *)
    lbl_mut: mutable_flag;              (* Is this a mutable field? *)
    lbl_pos: int;                       (* Position in block *)
    lbl_all: label_description array;   (* All the labels in this type *)
    lbl_repres: record_representation;  (* Representation for this record *)
    lbl_private: private_flag;          (* Read-only field? *)
    lbl_loc: Location.t;
    lbl_attributes: Parsetree.attributes;
   }

and record_representation =
    Record_regular                      (* All fields are boxed / tagged *)
  | Record_float                        (* All fields are floats *)

(* Variance *)

module Variance = struct
  type t = int
  type f = May_pos | May_neg | May_weak | Inj | Pos | Neg | Inv
  let single = function
    | May_pos -> 1
    | May_neg -> 2
    | May_weak -> 4
    | Inj -> 8
    | Pos -> 16
    | Neg -> 32
    | Inv -> 64
  let union v1 v2 = v1 lor v2
  let inter v1 v2 = v1 land v2
  let subset v1 v2 = (v1 land v2 = v1)
  let set x b v =
    if b then v lor single x else  v land (lnot (single x))
  let mem x = subset (single x)
  let null = 0
  let may_inv = 7
  let full = 127
  let covariant = single May_pos lor single Pos lor single Inj
  let swap f1 f2 v =
    let v' = set f1 (mem f2 v) v in set f2 (mem f1 v) v'
  let conjugate v = swap May_pos May_neg (swap Pos Neg v)
  let get_upper v = (mem May_pos v, mem May_neg v)
  let get_lower v = (mem Pos v, mem Neg v, mem Inv v, mem Inj v)
end

(* Type definitions *)

type type_declaration =
  { type_params: type_expr list;
    type_arity: int;
    type_kind: type_kind;
    type_private: private_flag;
    type_manifest: type_expr option;
    type_variance: Variance.t list;
    type_newtype_level: (int * int) option;
    type_loc: Location.t;
    type_attributes: Parsetree.attributes;
 }

and type_kind =
    Type_abstract
  | Type_record of label_declaration list  * record_representation
  | Type_variant of constructor_declaration list
  | Type_open

and label_declaration =
  {
    ld_id: Ident.t;
    ld_mutable: mutable_flag;
    ld_type: type_expr;
    ld_loc: Location.t;
    ld_attributes: Parsetree.attributes;
  }

and constructor_declaration =
  {
    cd_id: Ident.t;
    cd_args: type_expr list;
    cd_res: type_expr option;
    cd_loc: Location.t;
    cd_attributes: Parsetree.attributes;
  }

type extension_constructor =
    { ext_type_path: Path.t;
      ext_type_params: type_expr list;
      ext_args: type_expr list;
      ext_ret_type: type_expr option;
      ext_private: private_flag;
      ext_loc: Location.t;
      ext_attributes: Parsetree.attributes; }

and type_transparence =
    Type_public      (* unrestricted expansion *)
  | Type_new         (* "new" type *)
  | Type_private     (* private type *)

(* Type expressions for the class language *)

module Concr = Set.Make(OrderedString)

type class_type =
    Cty_constr of Path.t * type_expr list * class_type
  | Cty_signature of class_signature
  | Cty_arrow of label * type_expr * class_type

and class_signature =
  { csig_self: type_expr;
    csig_vars:
      (Asttypes.mutable_flag * Asttypes.virtual_flag * type_expr) Vars.t;
    csig_concr: Concr.t;
    csig_inher: (Path.t * type_expr list) list }

type class_declaration =
  { cty_params: type_expr list;
    mutable cty_type: class_type;
    cty_path: Path.t;
    cty_new: type_expr option;
    cty_variance: Variance.t list;
    cty_loc: Location.t;
    cty_attributes: Parsetree.attributes;
 }

type class_type_declaration =
  { clty_params: type_expr list;
    clty_type: class_type;
    clty_path: Path.t;
    clty_variance: Variance.t list;
    clty_loc: Location.t;
    clty_attributes: Parsetree.attributes;
  }

(* Type expressions for the module language *)

type module_type =
    Mty_ident of Path.t
  | Mty_signature of signature
  | Mty_functor of Ident.t * module_type option * module_type
  | Mty_alias of Path.t

and signature = signature_item list

and signature_item =
    Sig_value of Ident.t * value_description
  | Sig_type of Ident.t * type_declaration * rec_status
  | Sig_typext of Ident.t * extension_constructor * ext_status
  | Sig_module of Ident.t * module_declaration * rec_status
  | Sig_modtype of Ident.t * modtype_declaration
  | Sig_class of Ident.t * class_declaration * rec_status
  | Sig_class_type of Ident.t * class_type_declaration * rec_status

and module_declaration =
  {
    md_type: module_type;
    md_attributes: Parsetree.attributes;
    md_loc: Location.t;
  }

and modtype_declaration =
  {
    mtd_type: module_type option;  (* Nonte: abstract *)
    mtd_attributes: Parsetree.attributes;
    mtd_loc: Location.t;
  }

and rec_status =
    Trec_not                            (* first in a nonrecursive group *)
  | Trec_first                          (* first in a recursive group *)
  | Trec_next                           (* not first in a recursive/nonrecursive group *)

and ext_status =
    Text_first                     (* first constructor of an extension *)
  | Text_next                      (* not first constructor of an extension *)
  | Text_exception                 (* an exception *)

let equal_tag t1 t2 = 
   match (t1, t2) with
   | Cstr_constant i1, Cstr_constant i2 -> i2 = i1
   | Cstr_block i1, Cstr_block i2 -> i2 = i1
   | Cstr_extension (path1, b1), Cstr_extension (path2, b2) -> 
       Path.same path1 path2 && b1 = b2
   | (Cstr_constant _|Cstr_block _|Cstr_extension _), _ -> false
 

end
module Btype : sig 
#1 "btype.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Basic operations on core types *)

open Asttypes
open Types

(**** Sets, maps and hashtables of types ****)

module TypeSet  : Set.S with type elt = type_expr
module TypeMap  : Map.S with type key = type_expr
module TypeHash : Hashtbl.S with type key = type_expr

(**** Levels ****)

val generic_level: int

val newty2: int -> type_desc -> type_expr
        (* Create a type *)
val newgenty: type_desc -> type_expr
        (* Create a generic type *)
val newgenvar: ?name:string -> unit -> type_expr
        (* Return a fresh generic variable *)

(* Use Tsubst instead
val newmarkedvar: int -> type_expr
        (* Return a fresh marked variable *)
val newmarkedgenvar: unit -> type_expr
        (* Return a fresh marked generic variable *)
*)

(**** Types ****)

val is_Tvar: type_expr -> bool
val is_Tunivar: type_expr -> bool
val dummy_method: label
val default_mty: module_type option -> module_type

val repr: type_expr -> type_expr
        (* Return the canonical representative of a type. *)

val field_kind_repr: field_kind -> field_kind
        (* Return the canonical representative of an object field
           kind. *)

val commu_repr: commutable -> commutable
        (* Return the canonical representative of a commutation lock *)

(**** polymorphic variants ****)

val row_repr: row_desc -> row_desc
        (* Return the canonical representative of a row description *)
val row_field_repr: row_field -> row_field
val row_field: label -> row_desc -> row_field
        (* Return the canonical representative of a row field *)
val row_more: row_desc -> type_expr
        (* Return the extension variable of the row *)
val row_fixed: row_desc -> bool
        (* Return whether the row should be treated as fixed or not *)
val static_row: row_desc -> bool
        (* Return whether the row is static or not *)
val hash_variant: label -> int
        (* Hash function for variant tags *)

val proxy: type_expr -> type_expr
        (* Return the proxy representative of the type: either itself
           or a row variable *)

(**** Utilities for private abbreviations with fixed rows ****)
val has_constr_row: type_expr -> bool
val is_row_name: string -> bool
val is_constr_row: type_expr -> bool

(**** Utilities for type traversal ****)

val iter_type_expr: (type_expr -> unit) -> type_expr -> unit
        (* Iteration on types *)
val iter_row: (type_expr -> unit) -> row_desc -> unit
        (* Iteration on types in a row *)
val iter_abbrev: (type_expr -> unit) -> abbrev_memo -> unit
        (* Iteration on types in an abbreviation list *)

type type_iterators =
  { it_signature: type_iterators -> signature -> unit;
    it_signature_item: type_iterators -> signature_item -> unit;
    it_value_description: type_iterators -> value_description -> unit;
    it_type_declaration: type_iterators -> type_declaration -> unit;
    it_extension_constructor: type_iterators -> extension_constructor -> unit;
    it_module_declaration: type_iterators -> module_declaration -> unit;
    it_modtype_declaration: type_iterators -> modtype_declaration -> unit;
    it_class_declaration: type_iterators -> class_declaration -> unit;
    it_class_type_declaration: type_iterators -> class_type_declaration -> unit;
    it_module_type: type_iterators -> module_type -> unit;
    it_class_type: type_iterators -> class_type -> unit;
    it_type_kind: type_iterators -> type_kind -> unit;
    it_do_type_expr: type_iterators -> type_expr -> unit;
    it_type_expr: type_iterators -> type_expr -> unit;
    it_path: Path.t -> unit; }
val type_iterators: type_iterators
        (* Iteration on arbitrary type information.
           [it_type_expr] calls [mark_type_node] to avoid loops. *)
val unmark_iterators: type_iterators
        (* Unmark any structure containing types. See [unmark_type] below. *)

val copy_type_desc:
    ?keep_names:bool -> (type_expr -> type_expr) -> type_desc -> type_desc
        (* Copy on types *)
val copy_row:
    (type_expr -> type_expr) ->
    bool -> row_desc -> bool -> type_expr -> row_desc
val copy_kind: field_kind -> field_kind

val save_desc: type_expr -> type_desc -> unit
        (* Save a type description *)
val dup_kind: field_kind option ref -> unit
        (* Save a None field_kind, and make it point to a fresh Fvar *)
val cleanup_types: unit -> unit
        (* Restore type descriptions *)

val lowest_level: int
        (* Marked type: ty.level < lowest_level *)
val pivot_level: int
        (* Type marking: ty.level <- pivot_level - ty.level *)
val mark_type: type_expr -> unit
        (* Mark a type *)
val mark_type_node: type_expr -> unit
        (* Mark a type node (but not its sons) *)
val mark_type_params: type_expr -> unit
        (* Mark the sons of a type node *)
val unmark_type: type_expr -> unit
val unmark_type_decl: type_declaration -> unit
val unmark_extension_constructor: extension_constructor -> unit
val unmark_class_type: class_type -> unit
val unmark_class_signature: class_signature -> unit
        (* Remove marks from a type *)

(**** Memorization of abbreviation expansion ****)

val find_expans: private_flag -> Path.t -> abbrev_memo -> type_expr option
        (* Look up a memorized abbreviation *)
val cleanup_abbrev: unit -> unit
        (* Flush the cache of abbreviation expansions.
           When some types are saved (using [output_value]), this
           function MUST be called just before. *)
val memorize_abbrev:
        abbrev_memo ref ->
        private_flag -> Path.t -> type_expr -> type_expr -> unit
        (* Add an expansion in the cache *)
val forget_abbrev:
        abbrev_memo ref -> Path.t -> unit
        (* Remove an abbreviation from the cache *)

(**** Utilities for labels ****)

val is_optional : label -> bool
val label_name : label -> label

(* Returns the label name with first character '?' or '~' as appropriate. *)
val prefixed_label_name : label -> label

val extract_label :
    label -> (label * 'a) list ->
    label * 'a * (label * 'a) list * (label * 'a) list
    (* actual label, value, before list, after list *)

(**** Utilities for backtracking ****)

type snapshot
        (* A snapshot for backtracking *)
val snapshot: unit -> snapshot
        (* Make a snapshot for later backtracking. Costs nothing *)
val backtrack: snapshot -> unit
        (* Backtrack to a given snapshot. Only possible if you have
           not already backtracked to a previous snapshot.
           Calls [cleanup_abbrev] internally *)

(* Functions to use when modifying a type (only Ctype?) *)
val link_type: type_expr -> type_expr -> unit
        (* Set the desc field of [t1] to [Tlink t2], logging the old
           value if there is an active snapshot *)
val set_level: type_expr -> int -> unit
val set_name:
    (Path.t * type_expr list) option ref ->
    (Path.t * type_expr list) option -> unit
val set_row_field: row_field option ref -> row_field -> unit
val set_univar: type_expr option ref -> type_expr -> unit
val set_kind: field_kind option ref -> field_kind -> unit
val set_commu: commutable ref -> commutable -> unit
val set_typeset: TypeSet.t ref -> TypeSet.t -> unit
        (* Set references, logging the old value *)
val log_type: type_expr -> unit
        (* Log the old value of a type, before modifying it by hand *)

(**** Forward declarations ****)
val print_raw: (Format.formatter -> type_expr -> unit) ref

end = struct
#1 "btype.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(* Xavier Leroy and Jerome Vouillon, projet Cristal, INRIA Rocquencourt*)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Basic operations on core types *)

open Misc
open Types

(**** Sets, maps and hashtables of types ****)

module TypeSet = Set.Make(TypeOps)
module TypeMap = Map.Make (TypeOps)
module TypeHash = Hashtbl.Make(TypeOps)

(**** Forward declarations ****)

let print_raw =
  ref (fun _ -> assert false : Format.formatter -> type_expr -> unit)

(**** Type level management ****)

let generic_level = 100000000

(* Used to mark a type during a traversal. *)
let lowest_level = 0
let pivot_level = 2 * lowest_level - 1
    (* pivot_level - lowest_level < lowest_level *)

(**** Some type creators ****)

let new_id = ref (-1)

let newty2 level desc  =
  incr new_id; { desc; level; id = !new_id }
let newgenty desc      = newty2 generic_level desc
let newgenvar ?name () = newgenty (Tvar name)
(*
let newmarkedvar level =
  incr new_id; { desc = Tvar; level = pivot_level - level; id = !new_id }
let newmarkedgenvar () =
  incr new_id;
  { desc = Tvar; level = pivot_level - generic_level; id = !new_id }
*)

(**** Check some types ****)

let is_Tvar = function {desc=Tvar _} -> true | _ -> false
let is_Tunivar = function {desc=Tunivar _} -> true | _ -> false

let dummy_method = "*dummy method*"
let default_mty = function
    Some mty -> mty
  | None -> Mty_signature []

(**** Representative of a type ****)

let rec field_kind_repr =
  function
    Fvar {contents = Some kind} -> field_kind_repr kind
  | kind                        -> kind

let rec repr =
  function
    {desc = Tlink t'} ->
      (*
         We do no path compression. Path compression does not seem to
         improve notably efficiency, and it prevents from changing a
         [Tlink] into another type (for instance, for undoing a
         unification).
      *)
      repr t'
  | {desc = Tfield (_, k, _, t')} when field_kind_repr k = Fabsent ->
      repr t'
  | t -> t

let rec commu_repr = function
    Clink r when !r <> Cunknown -> commu_repr !r
  | c -> c

let rec row_field_repr_aux tl = function
    Reither(_, tl', _, {contents = Some fi}) ->
      row_field_repr_aux (tl@tl') fi
  | Reither(c, tl', m, r) ->
      Reither(c, tl@tl', m, r)
  | Rpresent (Some _) when tl <> [] ->
      Rpresent (Some (List.hd tl))
  | fi -> fi

let row_field_repr fi = row_field_repr_aux [] fi

let rec rev_concat l ll =
  match ll with
    [] -> l
  | l'::ll -> rev_concat (l'@l) ll

let rec row_repr_aux ll row =
  match (repr row.row_more).desc with
  | Tvariant row' ->
      let f = row.row_fields in
      row_repr_aux (if f = [] then ll else f::ll) row'
  | _ ->
      if ll = [] then row else
      {row with row_fields = rev_concat row.row_fields ll}

let row_repr row = row_repr_aux [] row

let rec row_field tag row =
  let rec find = function
    | (tag',f) :: fields ->
        if tag = tag' then row_field_repr f else find fields
    | [] ->
        match repr row.row_more with
        | {desc=Tvariant row'} -> row_field tag row'
        | _ -> Rabsent
  in find row.row_fields

let rec row_more row =
  match repr row.row_more with
  | {desc=Tvariant row'} -> row_more row'
  | ty -> ty

let row_fixed row =
  let row = row_repr row in
  row.row_fixed ||
  match (repr row.row_more).desc with
    Tvar _ | Tnil -> false
  | Tunivar _ | Tconstr _ -> true
  | _ -> assert false

let static_row row =
  let row = row_repr row in
  row.row_closed &&
  List.for_all
    (fun (_,f) -> match row_field_repr f with Reither _ -> false | _ -> true)
    row.row_fields

let hash_variant s =
  let accu = ref 0 in
  for i = 0 to String.length s - 1 do
    accu := 223 * !accu + Char.code s.[i]
  done;
  (* reduce to 31 bits *)
  accu := !accu land (1 lsl 31 - 1);
  (* make it signed for 64 bits architectures *)
  if !accu > 0x3FFFFFFF then !accu - (1 lsl 31) else !accu

let proxy ty =
  let ty0 = repr ty in
  match ty0.desc with
  | Tvariant row when not (static_row row) ->
      row_more row
  | Tobject (ty, _) ->
      let rec proxy_obj ty =
        match ty.desc with
          Tfield (_, _, _, ty) | Tlink ty -> proxy_obj ty
        | Tvar _ | Tunivar _ | Tconstr _ -> ty
        | Tnil -> ty0
        | _ -> assert false
      in proxy_obj ty
  | _ -> ty0

(**** Utilities for fixed row private types ****)

let has_constr_row t =
  match (repr t).desc with
    Tobject(t,_) ->
      let rec check_row t =
        match (repr t).desc with
          Tfield(_,_,_,t) -> check_row t
        | Tconstr _ -> true
        | _ -> false
      in check_row t
  | Tvariant row ->
      (match row_more row with {desc=Tconstr _} -> true | _ -> false)
  | _ ->
      false

let is_row_name s =
  let l = String.length s in
  if l < 4 then false else String.sub s (l-4) 4 = "#row"

let is_constr_row t =
  match t.desc with
    Tconstr (Path.Pident id, _, _) -> is_row_name (Ident.name id)
  | Tconstr (Path.Pdot (_, s, _), _, _) -> is_row_name s
  | _ -> false


                  (**********************************)
                  (*  Utilities for type traversal  *)
                  (**********************************)

let rec iter_row f row =
  List.iter
    (fun (_, fi) ->
      match row_field_repr fi with
      | Rpresent(Some ty) -> f ty
      | Reither(_, tl, _, _) -> List.iter f tl
      | _ -> ())
    row.row_fields;
  match (repr row.row_more).desc with
    Tvariant row -> iter_row f row
  | Tvar _ | Tunivar _ | Tsubst _ | Tconstr _ | Tnil ->
      Misc.may (fun (_,l) -> List.iter f l) row.row_name
  | _ -> assert false

let iter_type_expr f ty =
  match ty.desc with
    Tvar _              -> ()
  | Tarrow (_, ty1, ty2, _) -> f ty1; f ty2
  | Ttuple l            -> List.iter f l
  | Tconstr (_, l, _)   -> List.iter f l
  | Tobject(ty, {contents = Some (_, p)})
                        -> f ty; List.iter f p
  | Tobject (ty, _)     -> f ty
  | Tvariant row        -> iter_row f row; f (row_more row)
  | Tfield (_, _, ty1, ty2) -> f ty1; f ty2
  | Tnil                -> ()
  | Tlink ty            -> f ty
  | Tsubst ty           -> f ty
  | Tunivar _           -> ()
  | Tpoly (ty, tyl)     -> f ty; List.iter f tyl
  | Tpackage (_, _, l)  -> List.iter f l

let rec iter_abbrev f = function
    Mnil                   -> ()
  | Mcons(_, _, ty, ty', rem) -> f ty; f ty'; iter_abbrev f rem
  | Mlink rem              -> iter_abbrev f !rem

type type_iterators =
  { it_signature: type_iterators -> signature -> unit;
    it_signature_item: type_iterators -> signature_item -> unit;
    it_value_description: type_iterators -> value_description -> unit;
    it_type_declaration: type_iterators -> type_declaration -> unit;
    it_extension_constructor: type_iterators -> extension_constructor -> unit;
    it_module_declaration: type_iterators -> module_declaration -> unit;
    it_modtype_declaration: type_iterators -> modtype_declaration -> unit;
    it_class_declaration: type_iterators -> class_declaration -> unit;
    it_class_type_declaration: type_iterators -> class_type_declaration -> unit;
    it_module_type: type_iterators -> module_type -> unit;
    it_class_type: type_iterators -> class_type -> unit;
    it_type_kind: type_iterators -> type_kind -> unit;
    it_do_type_expr: type_iterators -> type_expr -> unit;
    it_type_expr: type_iterators -> type_expr -> unit;
    it_path: Path.t -> unit; }

let type_iterators =
  let it_signature it =
    List.iter (it.it_signature_item it)
  and it_signature_item it = function
      Sig_value (_, vd)     -> it.it_value_description it vd
    | Sig_type (_, td, _)   -> it.it_type_declaration it td
    | Sig_typext (_, td, _) -> it.it_extension_constructor it td
    | Sig_module (_, md, _) -> it.it_module_declaration it md
    | Sig_modtype (_, mtd)  -> it.it_modtype_declaration it mtd
    | Sig_class (_, cd, _)  -> it.it_class_declaration it cd
    | Sig_class_type (_, ctd, _) -> it.it_class_type_declaration it ctd
  and it_value_description it vd =
    it.it_type_expr it vd.val_type
  and it_type_declaration it td =
    List.iter (it.it_type_expr it) td.type_params;
    may (it.it_type_expr it) td.type_manifest;
    it.it_type_kind it td.type_kind
  and it_extension_constructor it td =
    it.it_path td.ext_type_path;
    List.iter (it.it_type_expr it) td.ext_type_params;
    List.iter (it.it_type_expr it) td.ext_args;
    may (it.it_type_expr it) td.ext_ret_type
  and it_module_declaration it md =
    it.it_module_type it md.md_type
  and it_modtype_declaration it mtd =
    may (it.it_module_type it) mtd.mtd_type
  and it_class_declaration it cd =
    List.iter (it.it_type_expr it) cd.cty_params;
    it.it_class_type it cd.cty_type;
    may (it.it_type_expr it) cd.cty_new;
    it.it_path cd.cty_path
  and it_class_type_declaration it ctd =
    List.iter (it.it_type_expr it) ctd.clty_params;
    it.it_class_type it ctd.clty_type;
    it.it_path ctd.clty_path
  and it_module_type it = function
      Mty_ident p
    | Mty_alias p -> it.it_path p
    | Mty_signature sg -> it.it_signature it sg
    | Mty_functor (_, mto, mt) ->
        may (it.it_module_type it) mto;
        it.it_module_type it mt
  and it_class_type it = function
      Cty_constr (p, tyl, cty) ->
        it.it_path p;
        List.iter (it.it_type_expr it) tyl;
        it.it_class_type it cty
    | Cty_signature cs ->
        it.it_type_expr it cs.csig_self;
        Vars.iter (fun _ (_,_,ty) -> it.it_type_expr it ty) cs.csig_vars;
        List.iter
          (fun (p, tl) -> it.it_path p; List.iter (it.it_type_expr it) tl)
          cs.csig_inher
    | Cty_arrow  (_, ty, cty) ->
        it.it_type_expr it ty;
        it.it_class_type it cty
  and it_type_kind it = function
      Type_abstract -> ()
    | Type_record (ll, _) ->
        List.iter (fun ld -> it.it_type_expr it ld.ld_type) ll
    | Type_variant cl ->
        List.iter (fun cd ->
          List.iter (it.it_type_expr it) cd.cd_args;
          may (it.it_type_expr it) cd.cd_res)
          cl
    | Type_open -> ()
  and it_do_type_expr it ty =
    iter_type_expr (it.it_type_expr it) ty;
    match ty.desc with
      Tconstr (p, _, _)
    | Tobject (_, {contents=Some (p, _)})
    | Tpackage (p, _, _) ->
        it.it_path p
    | Tvariant row ->
        may (fun (p,_) -> it.it_path p) (row_repr row).row_name
    | _ -> ()
  and it_path p = ()
  in
  { it_path; it_type_expr = it_do_type_expr; it_do_type_expr;
    it_type_kind; it_class_type; it_module_type;
    it_signature; it_class_type_declaration; it_class_declaration;
    it_modtype_declaration; it_module_declaration; it_extension_constructor;
    it_type_declaration; it_value_description; it_signature_item; }

let copy_row f fixed row keep more =
  let fields = List.map
      (fun (l, fi) -> l,
        match row_field_repr fi with
        | Rpresent(Some ty) -> Rpresent(Some(f ty))
        | Reither(c, tl, m, e) ->
            let e = if keep then e else ref None in
            let m = if row.row_fixed then fixed else m in
            let tl = List.map f tl in
            Reither(c, tl, m, e)
        | _ -> fi)
      row.row_fields in
  let name =
    match row.row_name with None -> None
    | Some (path, tl) -> Some (path, List.map f tl) in
  { row_fields = fields; row_more = more;
    row_bound = (); row_fixed = row.row_fixed && fixed;
    row_closed = row.row_closed; row_name = name; }

let rec copy_kind = function
    Fvar{contents = Some k} -> copy_kind k
  | Fvar _   -> Fvar (ref None)
  | Fpresent -> Fpresent
  | Fabsent  -> assert false

let copy_commu c =
  if commu_repr c = Cok then Cok else Clink (ref Cunknown)

(* Since univars may be used as row variables, we need to do some
   encoding during substitution *)
let rec norm_univar ty =
  match ty.desc with
    Tunivar _ | Tsubst _ -> ty
  | Tlink ty           -> norm_univar ty
  | Ttuple (ty :: _)   -> norm_univar ty
  | _                  -> assert false

let rec copy_type_desc ?(keep_names=false) f = function
    Tvar _ as ty        -> if keep_names then ty else Tvar None
  | Tarrow (p, ty1, ty2, c)-> Tarrow (p, f ty1, f ty2, copy_commu c)
  | Ttuple l            -> Ttuple (List.map f l)
  | Tconstr (p, l, _)   -> Tconstr (p, List.map f l, ref Mnil)
  | Tobject(ty, {contents = Some (p, tl)})
                        -> Tobject (f ty, ref (Some(p, List.map f tl)))
  | Tobject (ty, _)     -> Tobject (f ty, ref None)
  | Tvariant row        -> assert false (* too ambiguous *)
  | Tfield (p, k, ty1, ty2) -> (* the kind is kept shared *)
      Tfield (p, field_kind_repr k, f ty1, f ty2)
  | Tnil                -> Tnil
  | Tlink ty            -> copy_type_desc f ty.desc
  | Tsubst ty           -> assert false
  | Tunivar _ as ty     -> ty (* always keep the name *)
  | Tpoly (ty, tyl)     ->
      let tyl = List.map (fun x -> norm_univar (f x)) tyl in
      Tpoly (f ty, tyl)
  | Tpackage (p, n, l)  -> Tpackage (p, n, List.map f l)

(* Utilities for copying *)

let saved_desc = ref []
  (* Saved association of generic nodes with their description. *)

let save_desc ty desc =
  saved_desc := (ty, desc)::!saved_desc

let saved_kinds = ref [] (* duplicated kind variables *)
let new_kinds = ref []   (* new kind variables *)
let dup_kind r =
  (match !r with None -> () | Some _ -> assert false);
  if not (List.memq r !new_kinds) then begin
    saved_kinds := r :: !saved_kinds;
    let r' = ref None in
    new_kinds := r' :: !new_kinds;
    r := Some (Fvar r')
  end

(* Restored type descriptions. *)
let cleanup_types () =
  List.iter (fun (ty, desc) -> ty.desc <- desc) !saved_desc;
  List.iter (fun r -> r := None) !saved_kinds;
  saved_desc := []; saved_kinds := []; new_kinds := []

(* Mark a type. *)
let rec mark_type ty =
  let ty = repr ty in
  if ty.level >= lowest_level then begin
    ty.level <- pivot_level - ty.level;
    iter_type_expr mark_type ty
  end

let mark_type_node ty =
  let ty = repr ty in
  if ty.level >= lowest_level then begin
    ty.level <- pivot_level - ty.level;
  end

let mark_type_params ty =
  iter_type_expr mark_type ty

let type_iterators =
  let it_type_expr it ty =
    let ty = repr ty in
    if ty.level >= lowest_level then begin
      mark_type_node ty;
      it.it_do_type_expr it ty;
    end
  in
  {type_iterators with it_type_expr}


(* Remove marks from a type. *)
let rec unmark_type ty =
  let ty = repr ty in
  if ty.level < lowest_level then begin
    ty.level <- pivot_level - ty.level;
    iter_type_expr unmark_type ty
  end

let unmark_iterators =
  let it_type_expr it ty = unmark_type ty in
  {type_iterators with it_type_expr}

let unmark_type_decl decl =
  unmark_iterators.it_type_declaration unmark_iterators decl

let unmark_extension_constructor ext =
  List.iter unmark_type ext.ext_type_params;
  List.iter unmark_type ext.ext_args;
  Misc.may unmark_type ext.ext_ret_type

let unmark_class_signature sign =
  unmark_type sign.csig_self;
  Vars.iter (fun l (m, v, t) -> unmark_type t) sign.csig_vars

let unmark_class_type cty =
  unmark_iterators.it_class_type unmark_iterators cty


                  (*******************************************)
                  (*  Memorization of abbreviation expansion *)
                  (*******************************************)

(* Search whether the expansion has been memorized. *)
let rec find_expans priv p1 = function
    Mnil -> None
  | Mcons (priv', p2, ty0, ty, _)
    when priv' >= priv && Path.same p1 p2 -> Some ty
  | Mcons (_, _, _, _, rem)   -> find_expans priv p1 rem
  | Mlink {contents = rem} -> find_expans priv p1 rem

(* debug: check for cycles in abbreviation. only works with -principal
let rec check_expans visited ty =
  let ty = repr ty in
  assert (not (List.memq ty visited));
  match ty.desc with
    Tconstr (path, args, abbrev) ->
      begin match find_expans path !abbrev with
        Some ty' -> check_expans (ty :: visited) ty'
      | None -> ()
      end
  | _ -> ()
*)

let memo = ref []
        (* Contains the list of saved abbreviation expansions. *)

let cleanup_abbrev () =
        (* Remove all memorized abbreviation expansions. *)
  List.iter (fun abbr -> abbr := Mnil) !memo;
  memo := []

let memorize_abbrev mem priv path v v' =
        (* Memorize the expansion of an abbreviation. *)
  mem := Mcons (priv, path, v, v', !mem);
  (* check_expans [] v; *)
  memo := mem :: !memo

let rec forget_abbrev_rec mem path =
  match mem with
    Mnil ->
      assert false
  | Mcons (_, path', _, _, rem) when Path.same path path' ->
      rem
  | Mcons (priv, path', v, v', rem) ->
      Mcons (priv, path', v, v', forget_abbrev_rec rem path)
  | Mlink mem' ->
      mem' := forget_abbrev_rec !mem' path;
      raise Exit

let forget_abbrev mem path =
  try mem := forget_abbrev_rec !mem path with Exit -> ()

(* debug: check for invalid abbreviations
let rec check_abbrev_rec = function
    Mnil -> true
  | Mcons (_, ty1, ty2, rem) ->
      repr ty1 != repr ty2
  | Mlink mem' ->
      check_abbrev_rec !mem'

let check_memorized_abbrevs () =
  List.for_all (fun mem -> check_abbrev_rec !mem) !memo
*)

                  (**********************************)
                  (*  Utilities for labels          *)
                  (**********************************)

let is_optional l =
  String.length l > 0 && l.[0] = '?'

let label_name l =
  if is_optional l then String.sub l 1 (String.length l - 1)
                   else l

let prefixed_label_name l =
  if is_optional l then l else "~" ^ l

let rec extract_label_aux hd l = function
    [] -> raise Not_found
  | (l',t as p) :: ls ->
      if label_name l' = l then (l', t, List.rev hd, ls)
      else extract_label_aux (p::hd) l ls

let extract_label l ls = extract_label_aux [] l ls


                  (**********************************)
                  (*  Utilities for backtracking    *)
                  (**********************************)

type change =
    Ctype of type_expr * type_desc
  | Clevel of type_expr * int
  | Cname of
      (Path.t * type_expr list) option ref * (Path.t * type_expr list) option
  | Crow of row_field option ref * row_field option
  | Ckind of field_kind option ref * field_kind option
  | Ccommu of commutable ref * commutable
  | Cuniv of type_expr option ref * type_expr option
  | Ctypeset of TypeSet.t ref * TypeSet.t

let undo_change = function
    Ctype  (ty, desc) -> ty.desc <- desc
  | Clevel (ty, level) -> ty.level <- level
  | Cname  (r, v) -> r := v
  | Crow   (r, v) -> r := v
  | Ckind  (r, v) -> r := v
  | Ccommu (r, v) -> r := v
  | Cuniv  (r, v) -> r := v
  | Ctypeset (r, v) -> r := v

type changes =
    Change of change * changes ref
  | Unchanged
  | Invalid

type snapshot = changes ref * int

let trail = Weak.create 1
let last_snapshot = ref 0

let log_change ch =
  match Weak.get trail 0 with None -> ()
  | Some r ->
      let r' = ref Unchanged in
      r := Change (ch, r');
      Weak.set trail 0 (Some r')

let log_type ty =
  if ty.id <= !last_snapshot then log_change (Ctype (ty, ty.desc))
let link_type ty ty' =
  log_type ty;
  let desc = ty.desc in
  ty.desc <- Tlink ty';
  (* Name is a user-supplied name for this unification variable (obtained
   * through a type annotation for instance). *)
  match desc, ty'.desc with
    Tvar name, Tvar name' ->
      begin match name, name' with
      | Some _, None ->  log_type ty'; ty'.desc <- Tvar name
      | None, Some _ ->  ()
      | Some _, Some _ ->
          if ty.level < ty'.level then (log_type ty'; ty'.desc <- Tvar name)
      | None, None   ->  ()
      end
  | _ -> ()
  (* ; assert (check_memorized_abbrevs ()) *)
  (*  ; check_expans [] ty' *)
let set_level ty level =
  if ty.id <= !last_snapshot then log_change (Clevel (ty, ty.level));
  ty.level <- level
let set_univar rty ty =
  log_change (Cuniv (rty, !rty)); rty := Some ty
let set_name nm v =
  log_change (Cname (nm, !nm)); nm := v
let set_row_field e v =
  log_change (Crow (e, !e)); e := Some v
let set_kind rk k =
  log_change (Ckind (rk, !rk)); rk := Some k
let set_commu rc c =
  log_change (Ccommu (rc, !rc)); rc := c
let set_typeset rs s =
  log_change (Ctypeset (rs, !rs)); rs := s

let snapshot () =
  let old = !last_snapshot in
  last_snapshot := !new_id;
  match Weak.get trail 0 with Some r -> (r, old)
  | None ->
      let r = ref Unchanged in
      Weak.set trail 0 (Some r);
      (r, old)

let rec rev_log accu = function
    Unchanged -> accu
  | Invalid -> assert false
  | Change (ch, next) ->
      let d = !next in
      next := Invalid;
      rev_log (ch::accu) d

let backtrack (changes, old) =
  match !changes with
    Unchanged -> last_snapshot := old
  | Invalid -> failwith "Btype.backtrack"
  | Change _ as change ->
      cleanup_abbrev ();
      let backlog = rev_log [] change in
      List.iter undo_change backlog;
      changes := Unchanged;
      last_snapshot := old;
      Weak.set trail 0 (Some changes)

end
module Cmi_format : sig 
#1 "cmi_format.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*                  Fabrice Le Fessant, INRIA Saclay                   *)
(*                                                                     *)
(*  Copyright 2012 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

type pers_flags = Rectypes

type cmi_infos = {
    cmi_name : string;
    cmi_sign : Types.signature_item list;
    cmi_crcs : (string * Digest.t option) list;
    cmi_flags : pers_flags list;
}

(* write the magic + the cmi information *)
val output_cmi : string -> out_channel -> cmi_infos -> Digest.t

(* read the cmi information (the magic is supposed to have already been read) *)
val input_cmi : in_channel -> cmi_infos

(* read a cmi from a filename, checking the magic *)
val read_cmi : string -> cmi_infos

(* Error report *)

type error =
    Not_an_interface of string
  | Wrong_version_interface of string * string
  | Corrupted_interface of string

exception Error of error

open Format

val report_error: formatter -> error -> unit

end = struct
#1 "cmi_format.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*                  Fabrice Le Fessant, INRIA Saclay                   *)
(*                                                                     *)
(*  Copyright 2012 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

type pers_flags = Rectypes

type error =
    Not_an_interface of string
  | Wrong_version_interface of string * string
  | Corrupted_interface of string

exception Error of error

type cmi_infos = {
    cmi_name : string;
    cmi_sign : Types.signature_item list;
    cmi_crcs : (string * Digest.t option) list;
    cmi_flags : pers_flags list;
}

let input_cmi ic =
  let (name, sign) = input_value ic in
  let crcs = input_value ic in
  let flags = input_value ic in
  {
      cmi_name = name;
      cmi_sign = sign;
      cmi_crcs = crcs;
      cmi_flags = flags;
    }

let read_cmi filename =
  let ic = open_in_bin filename in
  try
    let buffer =
      really_input_string ic (String.length Config.cmi_magic_number)
    in
    if buffer <> Config.cmi_magic_number then begin
      close_in ic;
      let pre_len = String.length Config.cmi_magic_number - 3 in
      if String.sub buffer 0 pre_len
          = String.sub Config.cmi_magic_number 0 pre_len then
      begin
        let msg =
          if buffer < Config.cmi_magic_number then "an older" else "a newer" in
        raise (Error (Wrong_version_interface (filename, msg)))
      end else begin
        raise(Error(Not_an_interface filename))
      end
    end;
    let cmi = input_cmi ic in
    close_in ic;
    cmi
  with End_of_file | Failure _ ->
      close_in ic;
      raise(Error(Corrupted_interface(filename)))
    | Error e ->
      close_in ic;
      raise (Error e)

let output_cmi filename oc cmi =
(* beware: the provided signature must have been substituted for saving *)
  output_string oc Config.cmi_magic_number;
  output_value oc (cmi.cmi_name, cmi.cmi_sign);
  flush oc;
  let crc = Digest.file filename in
  let crcs = (cmi.cmi_name, Some crc) :: cmi.cmi_crcs in
  output_value oc crcs;
  output_value oc cmi.cmi_flags;
  crc

(* Error report *)

open Format

let report_error ppf = function
  | Not_an_interface filename ->
      fprintf ppf "%a@ is not a compiled interface"
        Location.print_filename filename
  | Wrong_version_interface (filename, older_newer) ->
      fprintf ppf
        "%a@ is not a compiled interface for this version of OCaml.@.\
         It seems to be for %s version of OCaml."
        Location.print_filename filename older_newer
  | Corrupted_interface filename ->
      fprintf ppf "Corrupted compiled interface@ %a"
        Location.print_filename filename

let () =
  Location.register_error_of_exn
    (function
      | Error err -> Some (Location.error_of_printer_file report_error err)
      | _ -> None
    )

end
module Consistbl : sig 
#1 "consistbl.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 2002 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Consistency tables: for checking consistency of module CRCs *)

type t

val create: unit -> t

val clear: t -> unit

val check: t -> string -> Digest.t -> string -> unit
      (* [check tbl name crc source]
           checks consistency of ([name], [crc]) with infos previously
           stored in [tbl].  If no CRC was previously associated with
           [name], record ([name], [crc]) in [tbl].
           [source] is the name of the file from which the information
           comes from.  This is used for error reporting. *)

val check_noadd: t -> string -> Digest.t -> string -> unit
      (* Same as [check], but raise [Not_available] if no CRC was previously
           associated with [name]. *)

val set: t -> string -> Digest.t -> string -> unit
      (* [set tbl name crc source] forcefully associates [name] with
         [crc] in [tbl], even if [name] already had a different CRC
         associated with [name] in [tbl]. *)

val source: t -> string -> string
      (* [source tbl name] returns the file name associated with [name]
         if the latter has an associated CRC in [tbl].
         Raise [Not_found] otherwise. *)

val extract: string list -> t -> (string * Digest.t option) list
      (* [extract tbl names] returns an associative list mapping each string
         in [names] to the CRC associated with it in [tbl]. If no CRC is
         associated with a name then it is mapped to [None]. *)

val filter: (string -> bool) -> t -> unit
      (* [filter pred tbl] removes from [tbl] table all (name, CRC) pairs
         such that [pred name] is [false]. *)

exception Inconsistency of string * string * string
      (* Raised by [check] when a CRC mismatch is detected.
         First string is the name of the compilation unit.
         Second string is the source that caused the inconsistency.
         Third string is the source that set the CRC. *)

exception Not_available of string
      (* Raised by [check_noadd] when a name doesn't have an associated CRC. *)

end = struct
#1 "consistbl.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 2002 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Consistency tables: for checking consistency of module CRCs *)

type t = (string, Digest.t * string) Hashtbl.t

let create () = Hashtbl.create 13

let clear = Hashtbl.clear

exception Inconsistency of string * string * string

exception Not_available of string

let check tbl name crc source =
  try
    let (old_crc, old_source) = Hashtbl.find tbl name in
    if crc <> old_crc then raise(Inconsistency(name, source, old_source))
  with Not_found ->
    Hashtbl.add tbl name (crc, source)

let check_noadd tbl name crc source =
  try
    let (old_crc, old_source) = Hashtbl.find tbl name in
    if crc <> old_crc then raise(Inconsistency(name, source, old_source))
  with Not_found ->
    raise (Not_available name)

let set tbl name crc source = Hashtbl.add tbl name (crc, source)

let source tbl name = snd (Hashtbl.find tbl name)

let extract l tbl =
  let l = List.sort_uniq String.compare l in
  List.fold_left
    (fun assc name ->
       try
         let (crc, _) = Hashtbl.find tbl name in
           (name, Some crc) :: assc
       with Not_found ->
         (name, None) :: assc)
    [] l

let filter p tbl =
  let to_remove = ref [] in
  Hashtbl.iter
    (fun name (crc, auth) ->
      if not (p name) then to_remove := name :: !to_remove)
    tbl;
  List.iter
    (fun name ->
       while Hashtbl.mem tbl name do Hashtbl.remove tbl name done)
    !to_remove

end
module Datarepr : sig 
#1 "datarepr.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Compute constructor and label descriptions from type declarations,
   determining their representation. *)

open Asttypes
open Types

val constructor_descrs:
  type_expr -> constructor_declaration list ->
  private_flag -> (Ident.t * constructor_description) list
val extension_descr:
  Path.t -> extension_constructor -> constructor_description
val label_descrs:
  type_expr -> label_declaration list ->
    record_representation -> private_flag ->
    (Ident.t * label_description) list

exception Constr_not_found

val find_constr_by_tag:
  constructor_tag -> constructor_declaration list ->
    constructor_declaration

end = struct
#1 "datarepr.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Compute constructor and label descriptions from type declarations,
   determining their representation. *)

open Asttypes
open Types
open Btype

(* Simplified version of Ctype.free_vars *)
let free_vars ty =
  let ret = ref TypeSet.empty in
  let rec loop ty =
    let ty = repr ty in
    if ty.level >= lowest_level then begin
      ty.level <- pivot_level - ty.level;
      match ty.desc with
      | Tvar _ ->
          ret := TypeSet.add ty !ret
      | Tvariant row ->
          let row = row_repr row in
          iter_row loop row;
          if not (static_row row) then loop row.row_more
      | _ ->
          iter_type_expr loop ty
    end
  in
  loop ty;
  unmark_type ty;
  !ret

let constructor_descrs ty_res cstrs priv =
  let num_consts = ref 0 and num_nonconsts = ref 0  and num_normal = ref 0 in
  List.iter
    (fun {cd_args; cd_res; _} ->
      if cd_args = [] then incr num_consts else incr num_nonconsts;
      if cd_res = None then incr num_normal)
    cstrs;
  let rec describe_constructors idx_const idx_nonconst = function
      [] -> []
    | {cd_id; cd_args; cd_res; cd_loc; cd_attributes} :: rem ->
        let ty_res =
          match cd_res with
          | Some ty_res' -> ty_res'
          | None -> ty_res
        in
        let (tag, descr_rem) =
          match cd_args with
            [] -> (Cstr_constant idx_const,
                   describe_constructors (idx_const+1) idx_nonconst rem)
          | _  -> (Cstr_block idx_nonconst,
                   describe_constructors idx_const (idx_nonconst+1) rem) in
        let existentials =
          match cd_res with
          | None -> []
          | Some type_ret ->
              let res_vars = free_vars type_ret in
              let arg_vars = free_vars (newgenty (Ttuple cd_args)) in
              TypeSet.elements (TypeSet.diff arg_vars res_vars)
        in
        let cstr =
          { cstr_name = Ident.name cd_id;
            cstr_res = ty_res;
            cstr_existentials = existentials;
            cstr_args = cd_args;
            cstr_arity = List.length cd_args;
            cstr_tag = tag;
            cstr_consts = !num_consts;
            cstr_nonconsts = !num_nonconsts;
            cstr_normal = !num_normal;
            cstr_private = priv;
            cstr_generalized = cd_res <> None;
            cstr_loc = cd_loc;
            cstr_attributes = cd_attributes;
          } in
        (cd_id, cstr) :: descr_rem in
  describe_constructors 0 0 cstrs

let extension_descr path_ext ext =
  let ty_res =
    match ext.ext_ret_type with
        Some type_ret -> type_ret
      | None ->
          newgenty (Tconstr(ext.ext_type_path, ext.ext_type_params, ref Mnil))
  in
  let tag = Cstr_extension(path_ext, ext.ext_args = []) in
  let existentials =
    match ext.ext_ret_type with
      | None -> []
      | Some type_ret ->
          let ret_vars = free_vars type_ret in
          let arg_vars = free_vars (newgenty (Ttuple ext.ext_args)) in
            TypeSet.elements (TypeSet.diff arg_vars ret_vars)
  in
    { cstr_name = Path.last path_ext;
      cstr_res = ty_res;
      cstr_existentials = existentials;
      cstr_args = ext.ext_args;
      cstr_arity = List.length ext.ext_args;
      cstr_tag = tag;
      cstr_consts = -1;
      cstr_nonconsts = -1;
      cstr_private = ext.ext_private;
      cstr_normal = -1;
      cstr_generalized = ext.ext_ret_type <> None;
      cstr_loc = ext.ext_loc;
      cstr_attributes = ext.ext_attributes;
    }

let none = {desc = Ttuple []; level = -1; id = -1}
                                        (* Clearly ill-formed type *)
let dummy_label =
  { lbl_name = ""; lbl_res = none; lbl_arg = none; lbl_mut = Immutable;
    lbl_pos = (-1); lbl_all = [||]; lbl_repres = Record_regular;
    lbl_private = Public;
    lbl_loc = Location.none;
    lbl_attributes = [];
  }

let label_descrs ty_res lbls repres priv =
  let all_labels = Array.make (List.length lbls) dummy_label in
  let rec describe_labels num = function
      [] -> []
    | l :: rest ->
        let lbl =
          { lbl_name = Ident.name l.ld_id;
            lbl_res = ty_res;
            lbl_arg = l.ld_type;
            lbl_mut = l.ld_mutable;
            lbl_pos = num;
            lbl_all = all_labels;
            lbl_repres = repres;
            lbl_private = priv;
            lbl_loc = l.ld_loc;
            lbl_attributes = l.ld_attributes;
          } in
        all_labels.(num) <- lbl;
        (l.ld_id, lbl) :: describe_labels (num+1) rest in
  describe_labels 0 lbls

exception Constr_not_found

let rec find_constr tag num_const num_nonconst = function
    [] ->
      raise Constr_not_found
  | {cd_args = []; _} as c  :: rem ->
      if tag = Cstr_constant num_const
      then c
      else find_constr tag (num_const + 1) num_nonconst rem
  | c :: rem ->
      if tag = Cstr_block num_nonconst
      then c
      else find_constr tag num_const (num_nonconst + 1) rem

let find_constr_by_tag tag cstrlist =
  find_constr tag 0 0 cstrlist

end
module Predef : sig 
#1 "predef.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Predefined type constructors (with special typing rules in typecore) *)

open Types

val type_int: type_expr
val type_char: type_expr
val type_string: type_expr
val type_bytes: type_expr
val type_float: type_expr
val type_bool: type_expr
val type_unit: type_expr
val type_exn: type_expr
val type_array: type_expr -> type_expr
val type_list: type_expr -> type_expr
val type_option: type_expr -> type_expr
val type_nativeint: type_expr
val type_int32: type_expr
val type_int64: type_expr
val type_lazy_t: type_expr -> type_expr

val path_int: Path.t
val path_char: Path.t
val path_string: Path.t
val path_bytes: Path.t
val path_float: Path.t
val path_bool: Path.t
val path_unit: Path.t
val path_exn: Path.t
val path_array: Path.t
val path_list: Path.t
val path_option: Path.t
val path_nativeint: Path.t
val path_int32: Path.t
val path_int64: Path.t
val path_lazy_t: Path.t

val path_match_failure: Path.t
val path_assert_failure : Path.t
val path_undefined_recursive_module : Path.t

(* To build the initial environment. Since there is a nasty mutual
   recursion between predef and env, we break it by parameterizing
   over Env.t, Env.add_type and Env.add_extension. *)

val build_initial_env:
  (Ident.t -> type_declaration -> 'a -> 'a) ->
  (Ident.t -> extension_constructor -> 'a -> 'a) ->
  'a -> 'a * 'a

(* To initialize linker tables *)

val builtin_values: (string * Ident.t) list
val builtin_idents: (string * Ident.t) list

end = struct
#1 "predef.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Predefined type constructors (with special typing rules in typecore) *)

open Path
open Types
open Btype

let builtin_idents = ref []

let wrap create s =
  let id = create s in
  builtin_idents := (s, id) :: !builtin_idents;
  id

let ident_create = wrap Ident.create
let ident_create_predef_exn = wrap Ident.create_predef_exn

let ident_int = ident_create "int"
and ident_char = ident_create "char"
and ident_string = ident_create "string"
and ident_float = ident_create "float"
and ident_bool = ident_create "bool"
and ident_unit = ident_create "unit"
and ident_exn = ident_create "exn"
and ident_array = ident_create "array"
and ident_list = ident_create "list"
and ident_option = ident_create "option"
and ident_nativeint = ident_create "nativeint"
and ident_int32 = ident_create "int32"
and ident_int64 = ident_create "int64"
and ident_lazy_t = ident_create "lazy_t"
and ident_bytes = ident_create "bytes"

let path_int = Pident ident_int
and path_char = Pident ident_char
and path_string = Pident ident_string
and path_float = Pident ident_float
and path_bool = Pident ident_bool
and path_unit = Pident ident_unit
and path_exn = Pident ident_exn
and path_array = Pident ident_array
and path_list = Pident ident_list
and path_option = Pident ident_option
and path_nativeint = Pident ident_nativeint
and path_int32 = Pident ident_int32
and path_int64 = Pident ident_int64
and path_lazy_t = Pident ident_lazy_t
and path_bytes = Pident ident_bytes

let type_int = newgenty (Tconstr(path_int, [], ref Mnil))
and type_char = newgenty (Tconstr(path_char, [], ref Mnil))
and type_string = newgenty (Tconstr(path_string, [], ref Mnil))
and type_float = newgenty (Tconstr(path_float, [], ref Mnil))
and type_bool = newgenty (Tconstr(path_bool, [], ref Mnil))
and type_unit = newgenty (Tconstr(path_unit, [], ref Mnil))
and type_exn = newgenty (Tconstr(path_exn, [], ref Mnil))
and type_array t = newgenty (Tconstr(path_array, [t], ref Mnil))
and type_list t = newgenty (Tconstr(path_list, [t], ref Mnil))
and type_option t = newgenty (Tconstr(path_option, [t], ref Mnil))
and type_nativeint = newgenty (Tconstr(path_nativeint, [], ref Mnil))
and type_int32 = newgenty (Tconstr(path_int32, [], ref Mnil))
and type_int64 = newgenty (Tconstr(path_int64, [], ref Mnil))
and type_lazy_t t = newgenty (Tconstr(path_lazy_t, [t], ref Mnil))
and type_bytes = newgenty (Tconstr(path_bytes, [], ref Mnil))

let ident_match_failure = ident_create_predef_exn "Match_failure"
and ident_out_of_memory = ident_create_predef_exn "Out_of_memory"
and ident_invalid_argument = ident_create_predef_exn "Invalid_argument"
and ident_failure = ident_create_predef_exn "Failure"
and ident_not_found = ident_create_predef_exn "Not_found"
and ident_sys_error = ident_create_predef_exn "Sys_error"
and ident_end_of_file = ident_create_predef_exn "End_of_file"
and ident_division_by_zero = ident_create_predef_exn "Division_by_zero"
and ident_stack_overflow = ident_create_predef_exn "Stack_overflow"
and ident_sys_blocked_io = ident_create_predef_exn "Sys_blocked_io"
and ident_assert_failure = ident_create_predef_exn "Assert_failure"
and ident_undefined_recursive_module =
        ident_create_predef_exn "Undefined_recursive_module"

let path_match_failure = Pident ident_match_failure
and path_assert_failure = Pident ident_assert_failure
and path_undefined_recursive_module = Pident ident_undefined_recursive_module

let decl_abstr =
  {type_params = [];
   type_arity = 0;
   type_kind = Type_abstract;
   type_loc = Location.none;
   type_private = Asttypes.Public;
   type_manifest = None;
   type_variance = [];
   type_newtype_level = None;
   type_attributes = [];
  }

let cstr id args =
  {
    cd_id = id;
    cd_args = args;
    cd_res = None;
    cd_loc = Location.none;
    cd_attributes = [];
  }

let ident_false = ident_create "false"
and ident_true = ident_create "true"
and ident_void = ident_create "()"
and ident_nil = ident_create "[]"
and ident_cons = ident_create "::"
and ident_none = ident_create "None"
and ident_some = ident_create "Some"
let common_initial_env add_type add_extension empty_env =
  let decl_bool =
    {decl_abstr with
     type_kind = Type_variant([cstr ident_false []; cstr ident_true []])}
  and decl_unit =
    {decl_abstr with
     type_kind = Type_variant([cstr ident_void []])}
  and decl_exn =
    {decl_abstr with
     type_kind = Type_open}
  and decl_array =
    let tvar = newgenvar() in
    {decl_abstr with
     type_params = [tvar];
     type_arity = 1;
     type_variance = [Variance.full]}
  and decl_list =
    let tvar = newgenvar() in
    {decl_abstr with
     type_params = [tvar];
     type_arity = 1;
     type_kind =
     Type_variant([cstr ident_nil []; cstr ident_cons [tvar; type_list tvar]]);
     type_variance = [Variance.covariant]}
  and decl_option =
    let tvar = newgenvar() in
    {decl_abstr with
     type_params = [tvar];
     type_arity = 1;
     type_kind = Type_variant([cstr ident_none []; cstr ident_some [tvar]]);
     type_variance = [Variance.covariant]}
  and decl_lazy_t =
    let tvar = newgenvar() in
    {decl_abstr with
     type_params = [tvar];
     type_arity = 1;
     type_variance = [Variance.covariant]}
  in

  let add_extension id l =
    add_extension id
      { ext_type_path = path_exn;
        ext_type_params = [];
        ext_args = l;
        ext_ret_type = None;
        ext_private = Asttypes.Public;
        ext_loc = Location.none;
        ext_attributes = [] }
  in
  add_extension ident_match_failure
                         [newgenty (Ttuple[type_string; type_int; type_int])] (
  add_extension ident_out_of_memory [] (
  add_extension ident_stack_overflow [] (
  add_extension ident_invalid_argument [type_string] (
  add_extension ident_failure [type_string] (
  add_extension ident_not_found [] (
  add_extension ident_sys_blocked_io [] (
  add_extension ident_sys_error [type_string] (
  add_extension ident_end_of_file [] (
  add_extension ident_division_by_zero [] (
  add_extension ident_assert_failure
                         [newgenty (Ttuple[type_string; type_int; type_int])] (
  add_extension ident_undefined_recursive_module
                         [newgenty (Ttuple[type_string; type_int; type_int])] (
  add_type ident_int64 decl_abstr (
  add_type ident_int32 decl_abstr (
  add_type ident_nativeint decl_abstr (
  add_type ident_lazy_t decl_lazy_t (
  add_type ident_option decl_option (
  add_type ident_list decl_list (
  add_type ident_array decl_array (
  add_type ident_exn decl_exn (
  add_type ident_unit decl_unit (
  add_type ident_bool decl_bool (
  add_type ident_float decl_abstr (
  add_type ident_string decl_abstr (
  add_type ident_char decl_abstr (
  add_type ident_int decl_abstr (
    empty_env))))))))))))))))))))))))))

let build_initial_env add_type add_exception empty_env =
  let common = common_initial_env add_type add_exception empty_env in
  let safe_string = add_type ident_bytes decl_abstr common in
  let decl_bytes_unsafe = {decl_abstr with type_manifest = Some type_string} in
  let unsafe_string = add_type ident_bytes decl_bytes_unsafe common in
  (safe_string, unsafe_string)

let builtin_values =
  List.map (fun id -> Ident.make_global id; (Ident.name id, id))
      [ident_match_failure; ident_out_of_memory; ident_stack_overflow;
       ident_invalid_argument;
       ident_failure; ident_not_found; ident_sys_error; ident_end_of_file;
       ident_division_by_zero; ident_sys_blocked_io;
       ident_assert_failure; ident_undefined_recursive_module ]

(* Start non-predef identifiers at 1000.  This way, more predefs can
   be defined in this file (above!) without breaking .cmi
   compatibility. *)

let _ = Ident.set_current_time 999
let builtin_idents = List.rev !builtin_idents

end
module Ast_mapper : sig 
#1 "ast_mapper.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*                        Alain Frisch, LexiFi                         *)
(*                                                                     *)
(*  Copyright 2012 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(** The interface of a -ppx rewriter

  A -ppx rewriter is a program that accepts a serialized abstract syntax
  tree and outputs another, possibly modified, abstract syntax tree.
  This module encapsulates the interface between the compiler and
  the -ppx rewriters, handling such details as the serialization format,
  forwarding of command-line flags, and storing state.

  {!mapper} allows to implement AST rewriting using open recursion.
  A typical mapper would be based on {!default_mapper}, a deep
  identity mapper, and will fall back on it for handling the syntax it
  does not modify. For example:

  {[
open Asttypes
open Parsetree
open Ast_mapper

let test_mapper argv =
  { default_mapper with
    expr = fun mapper expr ->
      match expr with
      | { pexp_desc = Pexp_extension ({ txt = "test" }, PStr [])} ->
        Ast_helper.Exp.constant (Const_int 42)
      | other -> default_mapper.expr mapper other; }

let () =
  register "ppx_test" test_mapper]}

  This -ppx rewriter, which replaces [[%test]] in expressions with
  the constant [42], can be compiled using
  [ocamlc -o ppx_test -I +compiler-libs ocamlcommon.cma ppx_test.ml].

  *)

open Parsetree

(** {2 A generic Parsetree mapper} *)

type mapper = {
  attribute: mapper -> attribute -> attribute;
  attributes: mapper -> attribute list -> attribute list;
  case: mapper -> case -> case;
  cases: mapper -> case list -> case list;
  class_declaration: mapper -> class_declaration -> class_declaration;
  class_description: mapper -> class_description -> class_description;
  class_expr: mapper -> class_expr -> class_expr;
  class_field: mapper -> class_field -> class_field;
  class_signature: mapper -> class_signature -> class_signature;
  class_structure: mapper -> class_structure -> class_structure;
  class_type: mapper -> class_type -> class_type;
  class_type_declaration: mapper -> class_type_declaration
                          -> class_type_declaration;
  class_type_field: mapper -> class_type_field -> class_type_field;
  constructor_declaration: mapper -> constructor_declaration
                           -> constructor_declaration;
  expr: mapper -> expression -> expression;
  extension: mapper -> extension -> extension;
  extension_constructor: mapper -> extension_constructor
                         -> extension_constructor;
  include_declaration: mapper -> include_declaration -> include_declaration;
  include_description: mapper -> include_description -> include_description;
  label_declaration: mapper -> label_declaration -> label_declaration;
  location: mapper -> Location.t -> Location.t;
  module_binding: mapper -> module_binding -> module_binding;
  module_declaration: mapper -> module_declaration -> module_declaration;
  module_expr: mapper -> module_expr -> module_expr;
  module_type: mapper -> module_type -> module_type;
  module_type_declaration: mapper -> module_type_declaration
                           -> module_type_declaration;
  open_description: mapper -> open_description -> open_description;
  pat: mapper -> pattern -> pattern;
  payload: mapper -> payload -> payload;
  signature: mapper -> signature -> signature;
  signature_item: mapper -> signature_item -> signature_item;
  structure: mapper -> structure -> structure;
  structure_item: mapper -> structure_item -> structure_item;
  typ: mapper -> core_type -> core_type;
  type_declaration: mapper -> type_declaration -> type_declaration;
  type_extension: mapper -> type_extension -> type_extension;
  type_kind: mapper -> type_kind -> type_kind;
  value_binding: mapper -> value_binding -> value_binding;
  value_description: mapper -> value_description -> value_description;
  with_constraint: mapper -> with_constraint -> with_constraint;
}
(** A mapper record implements one "method" per syntactic category,
    using an open recursion style: each method takes as its first
    argument the mapper to be applied to children in the syntax
    tree. *)

val default_mapper: mapper
(** A default mapper, which implements a "deep identity" mapping. *)

(** {2 Apply mappers to compilation units} *)

val tool_name: unit -> string
(** Can be used within a ppx preprocessor to know which tool is
    calling it ["ocamlc"], ["ocamlopt"], ["ocamldoc"], ["ocamldep"],
    ["ocaml"], ...  Some global variables that reflect command-line
    options are automatically synchronized between the calling tool
    and the ppx preprocessor: [Clflags.include_dirs],
    [Config.load_path], [Clflags.open_modules], [Clflags.for_package],
    [Clflags.debug]. *)


val apply: source:string -> target:string -> mapper -> unit
(** Apply a mapper (parametrized by the unit name) to a dumped
    parsetree found in the [source] file and put the result in the
    [target] file. The [structure] or [signature] field of the mapper
    is applied to the implementation or interface.  *)

val run_main: (string list -> mapper) -> unit
(** Entry point to call to implement a standalone -ppx rewriter from a
    mapper, parametrized by the command line arguments.  The current
    unit name can be obtained from [Location.input_name].  This
    function implements proper error reporting for uncaught
    exceptions. *)

(** {2 Registration API} *)

val register_function: (string -> (string list -> mapper) -> unit) ref

val register: string -> (string list -> mapper) -> unit
(** Apply the [register_function].  The default behavior is to run the
    mapper immediately, taking arguments from the process command
    line.  This is to support a scenario where a mapper is linked as a
    stand-alone executable.

    It is possible to overwrite the [register_function] to define
    "-ppx drivers", which combine several mappers in a single process.
    Typically, a driver starts by defining [register_function] to a
    custom implementation, then lets ppx rewriters (linked statically
    or dynamically) register themselves, and then run all or some of
    them.  It is also possible to have -ppx drivers apply rewriters to
    only specific parts of an AST.

    The first argument to [register] is a symbolic name to be used by
    the ppx driver.  *)


(** {2 Convenience functions to write mappers} *)

val map_opt: ('a -> 'b) -> 'a option -> 'b option

val extension_of_error: Location.error -> extension
(** Encode an error into an 'ocaml.error' extension node which can be
    inserted in a generated Parsetree.  The compiler will be
    responsible for reporting the error. *)

val attribute_of_warning: Location.t -> string -> attribute
(** Encode a warning message into an 'ocaml.ppwarning' attribute which can be
    inserted in a generated Parsetree.  The compiler will be
    responsible for reporting the warning. *)

(** {2 Helper functions to call external mappers} *)

val add_ppx_context_str: tool_name:string -> Parsetree.structure -> Parsetree.structure
(** Extract information from the current environment and encode it
    into an attribute which is prepended to the list of structure
    items in order to pass the information to an external
    processor. *)

val add_ppx_context_sig: tool_name:string -> Parsetree.signature -> Parsetree.signature
(** Same as [add_ppx_context_str], but for signatures. *)

val drop_ppx_context_str: restore:bool -> Parsetree.structure -> Parsetree.structure
(** Drop the ocaml.ppx.context attribute from a structure.  If
    [restore] is true, also restore the associated data in the current
    process. *)

val drop_ppx_context_sig: restore:bool -> Parsetree.signature -> Parsetree.signature
(** Same as [drop_ppx_context_str], but for signatures. *)

(** {2 Cookies} *)

(** Cookies are used to pass information from a ppx processor to
    a further invocation of itself, when called from the OCaml
    toplevel (or other tools that support cookies). *)

val set_cookie: string -> Parsetree.expression -> unit
val get_cookie: string -> Parsetree.expression option

end = struct
#1 "ast_mapper.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*                        Alain Frisch, LexiFi                         *)
(*                                                                     *)
(*  Copyright 2012 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* A generic Parsetree mapping class *)

(*
[@@@ocaml.warning "+9"]
  (* Ensure that record patterns don't miss any field. *)
*)


open Asttypes
open Parsetree
open Ast_helper
open Location

type mapper = {
  attribute: mapper -> attribute -> attribute;
  attributes: mapper -> attribute list -> attribute list;
  case: mapper -> case -> case;
  cases: mapper -> case list -> case list;
  class_declaration: mapper -> class_declaration -> class_declaration;
  class_description: mapper -> class_description -> class_description;
  class_expr: mapper -> class_expr -> class_expr;
  class_field: mapper -> class_field -> class_field;
  class_signature: mapper -> class_signature -> class_signature;
  class_structure: mapper -> class_structure -> class_structure;
  class_type: mapper -> class_type -> class_type;
  class_type_declaration: mapper -> class_type_declaration
                          -> class_type_declaration;
  class_type_field: mapper -> class_type_field -> class_type_field;
  constructor_declaration: mapper -> constructor_declaration
                           -> constructor_declaration;
  expr: mapper -> expression -> expression;
  extension: mapper -> extension -> extension;
  extension_constructor: mapper -> extension_constructor
                         -> extension_constructor;
  include_declaration: mapper -> include_declaration -> include_declaration;
  include_description: mapper -> include_description -> include_description;
  label_declaration: mapper -> label_declaration -> label_declaration;
  location: mapper -> Location.t -> Location.t;
  module_binding: mapper -> module_binding -> module_binding;
  module_declaration: mapper -> module_declaration -> module_declaration;
  module_expr: mapper -> module_expr -> module_expr;
  module_type: mapper -> module_type -> module_type;
  module_type_declaration: mapper -> module_type_declaration
                           -> module_type_declaration;
  open_description: mapper -> open_description -> open_description;
  pat: mapper -> pattern -> pattern;
  payload: mapper -> payload -> payload;
  signature: mapper -> signature -> signature;
  signature_item: mapper -> signature_item -> signature_item;
  structure: mapper -> structure -> structure;
  structure_item: mapper -> structure_item -> structure_item;
  typ: mapper -> core_type -> core_type;
  type_declaration: mapper -> type_declaration -> type_declaration;
  type_extension: mapper -> type_extension -> type_extension;
  type_kind: mapper -> type_kind -> type_kind;
  value_binding: mapper -> value_binding -> value_binding;
  value_description: mapper -> value_description -> value_description;
  with_constraint: mapper -> with_constraint -> with_constraint;
}

let map_fst f (x, y) = (f x, y)
let map_snd f (x, y) = (x, f y)
let map_tuple f1 f2 (x, y) = (f1 x, f2 y)
let map_tuple3 f1 f2 f3 (x, y, z) = (f1 x, f2 y, f3 z)
let map_opt f = function None -> None | Some x -> Some (f x)

let map_loc sub {loc; txt} = {loc = sub.location sub loc; txt}

module T = struct
  (* Type expressions for the core language *)

  let row_field sub = function
    | Rtag (l, attrs, b, tl) ->
        Rtag (l, sub.attributes sub attrs, b, List.map (sub.typ sub) tl)
    | Rinherit t -> Rinherit (sub.typ sub t)

  let map sub {ptyp_desc = desc; ptyp_loc = loc; ptyp_attributes = attrs} =
    let open Typ in
    let loc = sub.location sub loc in
    let attrs = sub.attributes sub attrs in
    match desc with
    | Ptyp_any -> any ~loc ~attrs ()
    | Ptyp_var s -> var ~loc ~attrs s
    | Ptyp_arrow (lab, t1, t2) ->
        arrow ~loc ~attrs lab (sub.typ sub t1) (sub.typ sub t2)
    | Ptyp_tuple tyl -> tuple ~loc ~attrs (List.map (sub.typ sub) tyl)
    | Ptyp_constr (lid, tl) ->
        constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tl)
    | Ptyp_object (l, o) ->
        let f (s, a, t) = (s, sub.attributes sub a, sub.typ sub t) in
        object_ ~loc ~attrs (List.map f l) o
    | Ptyp_class (lid, tl) ->
        class_ ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tl)
    | Ptyp_alias (t, s) -> alias ~loc ~attrs (sub.typ sub t) s
    | Ptyp_variant (rl, b, ll) ->
        variant ~loc ~attrs (List.map (row_field sub) rl) b ll
    | Ptyp_poly (sl, t) -> poly ~loc ~attrs sl (sub.typ sub t)
    | Ptyp_package (lid, l) ->
        package ~loc ~attrs (map_loc sub lid)
          (List.map (map_tuple (map_loc sub) (sub.typ sub)) l)
    | Ptyp_extension x -> extension ~loc ~attrs (sub.extension sub x)

  let map_type_declaration sub
      {ptype_name; ptype_params; ptype_cstrs;
       ptype_kind;
       ptype_private;
       ptype_manifest;
       ptype_attributes;
       ptype_loc} =
    Type.mk (map_loc sub ptype_name)
      ~params:(List.map (map_fst (sub.typ sub)) ptype_params)
      ~priv:ptype_private
      ~cstrs:(List.map
                (map_tuple3 (sub.typ sub) (sub.typ sub) (sub.location sub))
                ptype_cstrs)
      ~kind:(sub.type_kind sub ptype_kind)
      ?manifest:(map_opt (sub.typ sub) ptype_manifest)
      ~loc:(sub.location sub ptype_loc)
      ~attrs:(sub.attributes sub ptype_attributes)

  let map_type_kind sub = function
    | Ptype_abstract -> Ptype_abstract
    | Ptype_variant l ->
        Ptype_variant (List.map (sub.constructor_declaration sub) l)
    | Ptype_record l -> Ptype_record (List.map (sub.label_declaration sub) l)
    | Ptype_open -> Ptype_open

  let map_type_extension sub
      {ptyext_path; ptyext_params;
       ptyext_constructors;
       ptyext_private;
       ptyext_attributes} =
    Te.mk
      (map_loc sub ptyext_path)
      (List.map (sub.extension_constructor sub) ptyext_constructors)
      ~params:(List.map (map_fst (sub.typ sub)) ptyext_params)
      ~priv:ptyext_private
      ~attrs:(sub.attributes sub ptyext_attributes)

  let map_extension_constructor_kind sub = function
      Pext_decl(ctl, cto) ->
        Pext_decl(List.map (sub.typ sub) ctl, map_opt (sub.typ sub) cto)
    | Pext_rebind li ->
        Pext_rebind (map_loc sub li)

  let map_extension_constructor sub
      {pext_name;
       pext_kind;
       pext_loc;
       pext_attributes} =
    Te.constructor
      (map_loc sub pext_name)
      (map_extension_constructor_kind sub pext_kind)
      ~loc:(sub.location sub pext_loc)
      ~attrs:(sub.attributes sub pext_attributes)

end

module CT = struct
  (* Type expressions for the class language *)

  let map sub {pcty_loc = loc; pcty_desc = desc; pcty_attributes = attrs} =
    let open Cty in
    let loc = sub.location sub loc in
    let attrs = sub.attributes sub attrs in
    match desc with
    | Pcty_constr (lid, tys) ->
        constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tys)
    | Pcty_signature x -> signature ~loc ~attrs (sub.class_signature sub x)
    | Pcty_arrow (lab, t, ct) ->
        arrow ~loc ~attrs lab (sub.typ sub t) (sub.class_type sub ct)
    | Pcty_extension x -> extension ~loc ~attrs (sub.extension sub x)

  let map_field sub {pctf_desc = desc; pctf_loc = loc; pctf_attributes = attrs}
    =
    let open Ctf in
    let loc = sub.location sub loc in
    let attrs = sub.attributes sub attrs in
    match desc with
    | Pctf_inherit ct -> inherit_ ~loc ~attrs (sub.class_type sub ct)
    | Pctf_val (s, m, v, t) -> val_ ~loc ~attrs s m v (sub.typ sub t)
    | Pctf_method (s, p, v, t) -> method_ ~loc ~attrs s p v (sub.typ sub t)
    | Pctf_constraint (t1, t2) ->
        constraint_ ~loc ~attrs (sub.typ sub t1) (sub.typ sub t2)
    | Pctf_attribute x -> attribute ~loc (sub.attribute sub x)
    | Pctf_extension x -> extension ~loc ~attrs (sub.extension sub x)

  let map_signature sub {pcsig_self; pcsig_fields} =
    Csig.mk
      (sub.typ sub pcsig_self)
      (List.map (sub.class_type_field sub) pcsig_fields)
end

module MT = struct
  (* Type expressions for the module language *)

  let map sub {pmty_desc = desc; pmty_loc = loc; pmty_attributes = attrs} =
    let open Mty in
    let loc = sub.location sub loc in
    let attrs = sub.attributes sub attrs in
    match desc with
    | Pmty_ident s -> ident ~loc ~attrs (map_loc sub s)
    | Pmty_alias s -> alias ~loc ~attrs (map_loc sub s)
    | Pmty_signature sg -> signature ~loc ~attrs (sub.signature sub sg)
    | Pmty_functor (s, mt1, mt2) ->
        functor_ ~loc ~attrs (map_loc sub s)
          (Misc.may_map (sub.module_type sub) mt1)
          (sub.module_type sub mt2)
    | Pmty_with (mt, l) ->
        with_ ~loc ~attrs (sub.module_type sub mt)
          (List.map (sub.with_constraint sub) l)
    | Pmty_typeof me -> typeof_ ~loc ~attrs (sub.module_expr sub me)
    | Pmty_extension x -> extension ~loc ~attrs (sub.extension sub x)

  let map_with_constraint sub = function
    | Pwith_type (lid, d) ->
        Pwith_type (map_loc sub lid, sub.type_declaration sub d)
    | Pwith_module (lid, lid2) ->
        Pwith_module (map_loc sub lid, map_loc sub lid2)
    | Pwith_typesubst d -> Pwith_typesubst (sub.type_declaration sub d)
    | Pwith_modsubst (s, lid) ->
        Pwith_modsubst (map_loc sub s, map_loc sub lid)

  let map_signature_item sub {psig_desc = desc; psig_loc = loc} =
    let open Sig in
    let loc = sub.location sub loc in
    match desc with
    | Psig_value vd -> value ~loc (sub.value_description sub vd)
    | Psig_type l -> type_ ~loc (List.map (sub.type_declaration sub) l)
    | Psig_typext te -> type_extension ~loc (sub.type_extension sub te)
    | Psig_exception ed -> exception_ ~loc (sub.extension_constructor sub ed)
    | Psig_module x -> module_ ~loc (sub.module_declaration sub x)
    | Psig_recmodule l ->
        rec_module ~loc (List.map (sub.module_declaration sub) l)
    | Psig_modtype x -> modtype ~loc (sub.module_type_declaration sub x)
    | Psig_open x -> open_ ~loc (sub.open_description sub x)
    | Psig_include x -> include_ ~loc (sub.include_description sub x)
    | Psig_class l -> class_ ~loc (List.map (sub.class_description sub) l)
    | Psig_class_type l ->
        class_type ~loc (List.map (sub.class_type_declaration sub) l)
    | Psig_extension (x, attrs) ->
        extension ~loc (sub.extension sub x) ~attrs:(sub.attributes sub attrs)
    | Psig_attribute x -> attribute ~loc (sub.attribute sub x)
end


module M = struct
  (* Value expressions for the module language *)

  let map sub {pmod_loc = loc; pmod_desc = desc; pmod_attributes = attrs} =
    let open Mod in
    let loc = sub.location sub loc in
    let attrs = sub.attributes sub attrs in
    match desc with
    | Pmod_ident x -> ident ~loc ~attrs (map_loc sub x)
    | Pmod_structure str -> structure ~loc ~attrs (sub.structure sub str)
    | Pmod_functor (arg, arg_ty, body) ->
        functor_ ~loc ~attrs (map_loc sub arg)
          (Misc.may_map (sub.module_type sub) arg_ty)
          (sub.module_expr sub body)
    | Pmod_apply (m1, m2) ->
        apply ~loc ~attrs (sub.module_expr sub m1) (sub.module_expr sub m2)
    | Pmod_constraint (m, mty) ->
        constraint_ ~loc ~attrs (sub.module_expr sub m)
                    (sub.module_type sub mty)
    | Pmod_unpack e -> unpack ~loc ~attrs (sub.expr sub e)
    | Pmod_extension x -> extension ~loc ~attrs (sub.extension sub x)

  let map_structure_item sub {pstr_loc = loc; pstr_desc = desc} =
    let open Str in
    let loc = sub.location sub loc in
    match desc with
    | Pstr_eval (x, attrs) ->
        eval ~loc ~attrs:(sub.attributes sub attrs) (sub.expr sub x)
    | Pstr_value (r, vbs) -> value ~loc r (List.map (sub.value_binding sub) vbs)
    | Pstr_primitive vd -> primitive ~loc (sub.value_description sub vd)
    | Pstr_type l -> type_ ~loc (List.map (sub.type_declaration sub) l)
    | Pstr_typext te -> type_extension ~loc (sub.type_extension sub te)
    | Pstr_exception ed -> exception_ ~loc (sub.extension_constructor sub ed)
    | Pstr_module x -> module_ ~loc (sub.module_binding sub x)
    | Pstr_recmodule l -> rec_module ~loc (List.map (sub.module_binding sub) l)
    | Pstr_modtype x -> modtype ~loc (sub.module_type_declaration sub x)
    | Pstr_open x -> open_ ~loc (sub.open_description sub x)
    | Pstr_class l -> class_ ~loc (List.map (sub.class_declaration sub) l)
    | Pstr_class_type l ->
        class_type ~loc (List.map (sub.class_type_declaration sub) l)
    | Pstr_include x -> include_ ~loc (sub.include_declaration sub x)
    | Pstr_extension (x, attrs) ->
        extension ~loc (sub.extension sub x) ~attrs:(sub.attributes sub attrs)
    | Pstr_attribute x -> attribute ~loc (sub.attribute sub x)
end

module E = struct
  (* Value expressions for the core language *)

  let map sub {pexp_loc = loc; pexp_desc = desc; pexp_attributes = attrs} =
    let open Exp in
    let loc = sub.location sub loc in
    let attrs = sub.attributes sub attrs in
    match desc with
    | Pexp_ident x -> ident ~loc ~attrs (map_loc sub x)
    | Pexp_constant x -> constant ~loc ~attrs x
    | Pexp_let (r, vbs, e) ->
        let_ ~loc ~attrs r (List.map (sub.value_binding sub) vbs)
          (sub.expr sub e)
    | Pexp_fun (lab, def, p, e) ->
        fun_ ~loc ~attrs lab (map_opt (sub.expr sub) def) (sub.pat sub p)
          (sub.expr sub e)
    | Pexp_function pel -> function_ ~loc ~attrs (sub.cases sub pel)
    | Pexp_apply (e, l) ->
        apply ~loc ~attrs (sub.expr sub e) (List.map (map_snd (sub.expr sub)) l)
    | Pexp_match (e, pel) ->
        match_ ~loc ~attrs (sub.expr sub e) (sub.cases sub pel)
    | Pexp_try (e, pel) -> try_ ~loc ~attrs (sub.expr sub e) (sub.cases sub pel)
    | Pexp_tuple el -> tuple ~loc ~attrs (List.map (sub.expr sub) el)
    | Pexp_construct (lid, arg) ->
        construct ~loc ~attrs (map_loc sub lid) (map_opt (sub.expr sub) arg)
    | Pexp_variant (lab, eo) ->
        variant ~loc ~attrs lab (map_opt (sub.expr sub) eo)
    | Pexp_record (l, eo) ->
        record ~loc ~attrs (List.map (map_tuple (map_loc sub) (sub.expr sub)) l)
          (map_opt (sub.expr sub) eo)
    | Pexp_field (e, lid) ->
        field ~loc ~attrs (sub.expr sub e) (map_loc sub lid)
    | Pexp_setfield (e1, lid, e2) ->
        setfield ~loc ~attrs (sub.expr sub e1) (map_loc sub lid)
          (sub.expr sub e2)
    | Pexp_array el -> array ~loc ~attrs (List.map (sub.expr sub) el)
    | Pexp_ifthenelse (e1, e2, e3) ->
        ifthenelse ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)
          (map_opt (sub.expr sub) e3)
    | Pexp_sequence (e1, e2) ->
        sequence ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)
    | Pexp_while (e1, e2) ->
        while_ ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)
    | Pexp_for (p, e1, e2, d, e3) ->
        for_ ~loc ~attrs (sub.pat sub p) (sub.expr sub e1) (sub.expr sub e2) d
          (sub.expr sub e3)
    | Pexp_coerce (e, t1, t2) ->
        coerce ~loc ~attrs (sub.expr sub e) (map_opt (sub.typ sub) t1)
          (sub.typ sub t2)
    | Pexp_constraint (e, t) ->
        constraint_ ~loc ~attrs (sub.expr sub e) (sub.typ sub t)
    | Pexp_send (e, s) -> send ~loc ~attrs (sub.expr sub e) s
    | Pexp_new lid -> new_ ~loc ~attrs (map_loc sub lid)
    | Pexp_setinstvar (s, e) ->
        setinstvar ~loc ~attrs (map_loc sub s) (sub.expr sub e)
    | Pexp_override sel ->
        override ~loc ~attrs
          (List.map (map_tuple (map_loc sub) (sub.expr sub)) sel)
    | Pexp_letmodule (s, me, e) ->
        letmodule ~loc ~attrs (map_loc sub s) (sub.module_expr sub me)
          (sub.expr sub e)
    | Pexp_assert e -> assert_ ~loc ~attrs (sub.expr sub e)
    | Pexp_lazy e -> lazy_ ~loc ~attrs (sub.expr sub e)
    | Pexp_poly (e, t) ->
        poly ~loc ~attrs (sub.expr sub e) (map_opt (sub.typ sub) t)
    | Pexp_object cls -> object_ ~loc ~attrs (sub.class_structure sub cls)
    | Pexp_newtype (s, e) -> newtype ~loc ~attrs s (sub.expr sub e)
    | Pexp_pack me -> pack ~loc ~attrs (sub.module_expr sub me)
    | Pexp_open (ovf, lid, e) ->
        open_ ~loc ~attrs ovf (map_loc sub lid) (sub.expr sub e)
    | Pexp_extension x -> extension ~loc ~attrs (sub.extension sub x)
end

module P = struct
  (* Patterns *)

  let map sub {ppat_desc = desc; ppat_loc = loc; ppat_attributes = attrs} =
    let open Pat in
    let loc = sub.location sub loc in
    let attrs = sub.attributes sub attrs in
    match desc with
    | Ppat_any -> any ~loc ~attrs ()
    | Ppat_var s -> var ~loc ~attrs (map_loc sub s)
    | Ppat_alias (p, s) -> alias ~loc ~attrs (sub.pat sub p) (map_loc sub s)
    | Ppat_constant c -> constant ~loc ~attrs c
    | Ppat_interval (c1, c2) -> interval ~loc ~attrs c1 c2
    | Ppat_tuple pl -> tuple ~loc ~attrs (List.map (sub.pat sub) pl)
    | Ppat_construct (l, p) ->
        construct ~loc ~attrs (map_loc sub l) (map_opt (sub.pat sub) p)
    | Ppat_variant (l, p) -> variant ~loc ~attrs l (map_opt (sub.pat sub) p)
    | Ppat_record (lpl, cf) ->
        record ~loc ~attrs
               (List.map (map_tuple (map_loc sub) (sub.pat sub)) lpl) cf
    | Ppat_array pl -> array ~loc ~attrs (List.map (sub.pat sub) pl)
    | Ppat_or (p1, p2) -> or_ ~loc ~attrs (sub.pat sub p1) (sub.pat sub p2)
    | Ppat_constraint (p, t) ->
        constraint_ ~loc ~attrs (sub.pat sub p) (sub.typ sub t)
    | Ppat_type s -> type_ ~loc ~attrs (map_loc sub s)
    | Ppat_lazy p -> lazy_ ~loc ~attrs (sub.pat sub p)
    | Ppat_unpack s -> unpack ~loc ~attrs (map_loc sub s)
    | Ppat_exception p -> exception_ ~loc ~attrs (sub.pat sub p)
    | Ppat_extension x -> extension ~loc ~attrs (sub.extension sub x)
end

module CE = struct
  (* Value expressions for the class language *)

  let map sub {pcl_loc = loc; pcl_desc = desc; pcl_attributes = attrs} =
    let open Cl in
    let loc = sub.location sub loc in
    let attrs = sub.attributes sub attrs in
    match desc with
    | Pcl_constr (lid, tys) ->
        constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tys)
    | Pcl_structure s ->
        structure ~loc ~attrs (sub.class_structure sub s)
    | Pcl_fun (lab, e, p, ce) ->
        fun_ ~loc ~attrs lab
          (map_opt (sub.expr sub) e)
          (sub.pat sub p)
          (sub.class_expr sub ce)
    | Pcl_apply (ce, l) ->
        apply ~loc ~attrs (sub.class_expr sub ce)
          (List.map (map_snd (sub.expr sub)) l)
    | Pcl_let (r, vbs, ce) ->
        let_ ~loc ~attrs r (List.map (sub.value_binding sub) vbs)
          (sub.class_expr sub ce)
    | Pcl_constraint (ce, ct) ->
        constraint_ ~loc ~attrs (sub.class_expr sub ce) (sub.class_type sub ct)
    | Pcl_extension x -> extension ~loc ~attrs (sub.extension sub x)

  let map_kind sub = function
    | Cfk_concrete (o, e) -> Cfk_concrete (o, sub.expr sub e)
    | Cfk_virtual t -> Cfk_virtual (sub.typ sub t)

  let map_field sub {pcf_desc = desc; pcf_loc = loc; pcf_attributes = attrs} =
    let open Cf in
    let loc = sub.location sub loc in
    let attrs = sub.attributes sub attrs in
    match desc with
    | Pcf_inherit (o, ce, s) -> inherit_ ~loc ~attrs o (sub.class_expr sub ce) s
    | Pcf_val (s, m, k) -> val_ ~loc ~attrs (map_loc sub s) m (map_kind sub k)
    | Pcf_method (s, p, k) ->
        method_ ~loc ~attrs (map_loc sub s) p (map_kind sub k)
    | Pcf_constraint (t1, t2) ->
        constraint_ ~loc ~attrs (sub.typ sub t1) (sub.typ sub t2)
    | Pcf_initializer e -> initializer_ ~loc ~attrs (sub.expr sub e)
    | Pcf_attribute x -> attribute ~loc (sub.attribute sub x)
    | Pcf_extension x -> extension ~loc ~attrs (sub.extension sub x)

  let map_structure sub {pcstr_self; pcstr_fields} =
    {
      pcstr_self = sub.pat sub pcstr_self;
      pcstr_fields = List.map (sub.class_field sub) pcstr_fields;
    }

  let class_infos sub f {pci_virt; pci_params = pl; pci_name; pci_expr;
                         pci_loc; pci_attributes} =
    Ci.mk
     ~virt:pci_virt
     ~params:(List.map (map_fst (sub.typ sub)) pl)
      (map_loc sub pci_name)
      (f pci_expr)
      ~loc:(sub.location sub pci_loc)
      ~attrs:(sub.attributes sub pci_attributes)
end

(* Now, a generic AST mapper, to be extended to cover all kinds and
   cases of the OCaml grammar.  The default behavior of the mapper is
   the identity. *)

let default_mapper =
  {
    structure = (fun this l -> List.map (this.structure_item this) l);
    structure_item = M.map_structure_item;
    module_expr = M.map;
    signature = (fun this l -> List.map (this.signature_item this) l);
    signature_item = MT.map_signature_item;
    module_type = MT.map;
    with_constraint = MT.map_with_constraint;
    class_declaration =
      (fun this -> CE.class_infos this (this.class_expr this));
    class_expr = CE.map;
    class_field = CE.map_field;
    class_structure = CE.map_structure;
    class_type = CT.map;
    class_type_field = CT.map_field;
    class_signature = CT.map_signature;
    class_type_declaration =
      (fun this -> CE.class_infos this (this.class_type this));
    class_description =
      (fun this -> CE.class_infos this (this.class_type this));
    type_declaration = T.map_type_declaration;
    type_kind = T.map_type_kind;
    typ = T.map;
    type_extension = T.map_type_extension;
    extension_constructor = T.map_extension_constructor;
    value_description =
      (fun this {pval_name; pval_type; pval_prim; pval_loc;
                 pval_attributes} ->
        Val.mk
          (map_loc this pval_name)
          (this.typ this pval_type)
          ~attrs:(this.attributes this pval_attributes)
          ~loc:(this.location this pval_loc)
          ~prim:pval_prim
      );

    pat = P.map;
    expr = E.map;

    module_declaration =
      (fun this {pmd_name; pmd_type; pmd_attributes; pmd_loc} ->
         Md.mk
           (map_loc this pmd_name)
           (this.module_type this pmd_type)
           ~attrs:(this.attributes this pmd_attributes)
           ~loc:(this.location this pmd_loc)
      );

    module_type_declaration =
      (fun this {pmtd_name; pmtd_type; pmtd_attributes; pmtd_loc} ->
         Mtd.mk
           (map_loc this pmtd_name)
           ?typ:(map_opt (this.module_type this) pmtd_type)
           ~attrs:(this.attributes this pmtd_attributes)
           ~loc:(this.location this pmtd_loc)
      );

    module_binding =
      (fun this {pmb_name; pmb_expr; pmb_attributes; pmb_loc} ->
         Mb.mk (map_loc this pmb_name) (this.module_expr this pmb_expr)
           ~attrs:(this.attributes this pmb_attributes)
           ~loc:(this.location this pmb_loc)
      );


    open_description =
      (fun this {popen_lid; popen_override; popen_attributes; popen_loc} ->
         Opn.mk (map_loc this popen_lid)
           ~override:popen_override
           ~loc:(this.location this popen_loc)
           ~attrs:(this.attributes this popen_attributes)
      );


    include_description =
      (fun this {pincl_mod; pincl_attributes; pincl_loc} ->
         Incl.mk (this.module_type this pincl_mod)
           ~loc:(this.location this pincl_loc)
           ~attrs:(this.attributes this pincl_attributes)
      );

    include_declaration =
      (fun this {pincl_mod; pincl_attributes; pincl_loc} ->
         Incl.mk (this.module_expr this pincl_mod)
           ~loc:(this.location this pincl_loc)
           ~attrs:(this.attributes this pincl_attributes)
      );


    value_binding =
      (fun this {pvb_pat; pvb_expr; pvb_attributes; pvb_loc} ->
         Vb.mk
           (this.pat this pvb_pat)
           (this.expr this pvb_expr)
           ~loc:(this.location this pvb_loc)
           ~attrs:(this.attributes this pvb_attributes)
      );


    constructor_declaration =
      (fun this {pcd_name; pcd_args; pcd_res; pcd_loc; pcd_attributes} ->
        Type.constructor
          (map_loc this pcd_name)
          ~args:(List.map (this.typ this) pcd_args)
          ?res:(map_opt (this.typ this) pcd_res)
          ~loc:(this.location this pcd_loc)
          ~attrs:(this.attributes this pcd_attributes)
      );

    label_declaration =
      (fun this {pld_name; pld_type; pld_loc; pld_mutable; pld_attributes} ->
         Type.field
           (map_loc this pld_name)
           (this.typ this pld_type)
           ~mut:pld_mutable
           ~loc:(this.location this pld_loc)
           ~attrs:(this.attributes this pld_attributes)
      );

    cases = (fun this l -> List.map (this.case this) l);
    case =
      (fun this {pc_lhs; pc_guard; pc_rhs} ->
         {
           pc_lhs = this.pat this pc_lhs;
           pc_guard = map_opt (this.expr this) pc_guard;
           pc_rhs = this.expr this pc_rhs;
         }
      );



    location = (fun this l -> l);

    extension = (fun this (s, e) -> (map_loc this s, this.payload this e));
    attribute = (fun this (s, e) -> (map_loc this s, this.payload this e));
    attributes = (fun this l -> List.map (this.attribute this) l);
    payload =
      (fun this -> function
         | PStr x -> PStr (this.structure this x)
         | PTyp x -> PTyp (this.typ this x)
         | PPat (x, g) -> PPat (this.pat this x, map_opt (this.expr this) g)
      );
  }

let rec extension_of_error {loc; msg; if_highlight; sub} =
  { loc; txt = "ocaml.error" },
  PStr ([Str.eval (Exp.constant (Const_string (msg, None)));
         Str.eval (Exp.constant (Const_string (if_highlight, None)))] @
        (List.map (fun ext -> Str.extension (extension_of_error ext)) sub))

let attribute_of_warning loc s =
  { loc; txt = "ocaml.ppwarning" },
  PStr ([Str.eval ~loc (Exp.constant (Const_string (s, None)))])

module StringMap = Map.Make(struct
    type t = string
    let compare = compare
end)

let cookies = ref StringMap.empty

let get_cookie k =
  try Some (StringMap.find k !cookies)
  with Not_found -> None

let set_cookie k v =
  cookies := StringMap.add k v !cookies

let tool_name_ref = ref "_none_"

let tool_name () = !tool_name_ref


module PpxContext = struct
  open Longident
  open Asttypes
  open Ast_helper

  let lid name = { txt = Lident name; loc = Location.none }

  let make_string x = Exp.constant (Const_string (x, None))

  let make_bool x =
    if x
    then Exp.construct (lid "true") None
    else Exp.construct (lid "false") None

  let rec make_list f lst =
    match lst with
    | x :: rest ->
      Exp.construct (lid "::") (Some (Exp.tuple [f x; make_list f rest]))
    | [] ->
      Exp.construct (lid "[]") None

  let make_pair f1 f2 (x1, x2) =
    Exp.tuple [f1 x1; f2 x2]

  let make_option f opt =
    match opt with
    | Some x -> Exp.construct (lid "Some") (Some (f x))
    | None   -> Exp.construct (lid "None") None

  let get_cookies () =
    lid "cookies",
    make_list (make_pair make_string (fun x -> x))
      (StringMap.bindings !cookies)

  let mk fields =
    { txt = "ocaml.ppx.context"; loc = Location.none },
    Parsetree.PStr [Str.eval (Exp.record fields None)]

  let make ~tool_name () =
    let fields =
      [
        lid "tool_name",    make_string tool_name;
        lid "include_dirs", make_list make_string !Clflags.include_dirs;
        lid "load_path",    make_list make_string !Config.load_path;
        lid "open_modules", make_list make_string !Clflags.open_modules;
        lid "for_package",  make_option make_string !Clflags.for_package;
        lid "debug",        make_bool !Clflags.debug;
        get_cookies ()
      ]
    in
    mk fields

  let get_fields = function
    | PStr [{pstr_desc = Pstr_eval
                 ({ pexp_desc = Pexp_record (fields, None) }, [])}] ->
        fields
    | _ ->
        raise_errorf "Internal error: invalid [@@@ocaml.ppx.context] syntax"

  let restore fields =
    let field name payload =
      let rec get_string = function
        | { pexp_desc = Pexp_constant (Const_string (str, None)) } -> str
        | _ ->
            raise_errorf
              "Internal error: invalid [@@@ocaml.ppx.context { %s }] string syntax"
              name
      and get_bool pexp =
        match pexp with
        | {pexp_desc = Pexp_construct ({txt = Longident.Lident "true"}, None)} ->
            true
        | {pexp_desc = Pexp_construct ({txt = Longident.Lident "false"}, None)} ->
            false
        | _ ->
            raise_errorf
              "Internal error: invalid [@@@ocaml.ppx.context { %s }] bool syntax"
              name
      and get_list elem = function
        | {pexp_desc =
             Pexp_construct ({txt = Longident.Lident "::"},
                             Some {pexp_desc = Pexp_tuple [exp; rest]}) } ->
            elem exp :: get_list elem rest
        | {pexp_desc =
             Pexp_construct ({txt = Longident.Lident "[]"}, None)} ->
            []
        | _ ->
            raise_errorf
              "Internal error: invalid [@@@ocaml.ppx.context { %s }] list syntax"
              name
      and get_pair f1 f2 = function
        | {pexp_desc = Pexp_tuple [e1; e2]} ->
            (f1 e1, f2 e2)
        | _ ->
            raise_errorf
              "Internal error: invalid [@@@ocaml.ppx.context { %s }] pair syntax"
              name
      and get_option elem = function
        | { pexp_desc =
              Pexp_construct ({ txt = Longident.Lident "Some" }, Some exp) } ->
            Some (elem exp)
        | { pexp_desc =
              Pexp_construct ({ txt = Longident.Lident "None" }, None) } ->
            None
        | _ ->
            raise_errorf
              "Internal error: invalid [@@@ocaml.ppx.context { %s }] option syntax"
              name
      in
      match name with
      | "tool_name" ->
          tool_name_ref := get_string payload
      | "include_dirs" ->
          Clflags.include_dirs := get_list get_string payload
      | "load_path" ->
          Config.load_path := get_list get_string payload
      | "open_modules" ->
          Clflags.open_modules := get_list get_string payload
      | "for_package" ->
          Clflags.for_package := get_option get_string payload
      | "debug" ->
          Clflags.debug := get_bool payload
      | "cookies" ->
          let l = get_list (get_pair get_string (fun x -> x)) payload in
          cookies :=
            List.fold_left
              (fun s (k, v) -> StringMap.add k v s) StringMap.empty
              l
      | _ ->
          ()
    in
    List.iter (function ({txt=Lident name}, x) -> field name x | _ -> ()) fields

  let update_cookies fields =
    let fields =
      List.filter
        (function ({txt=Lident "cookies"}, _) -> false | _ -> true)
        fields
    in
    fields @ [get_cookies ()]
end

let ppx_context = PpxContext.make


let apply_lazy ~source ~target mapper =
  let ic = open_in_bin source in
  let magic =
    really_input_string ic (String.length Config.ast_impl_magic_number)
  in
  if magic <> Config.ast_impl_magic_number
  && magic <> Config.ast_intf_magic_number then
    failwith "Ast_mapper: OCaml version mismatch or malformed input";
  Location.input_name := input_value ic;
  let ast = input_value ic in
  close_in ic;

  let implem ast =
    try
      let fields, ast =
        match ast with
        | {pstr_desc = Pstr_attribute ({txt = "ocaml.ppx.context"}, x)} :: l ->
            PpxContext.get_fields x, l
        | _ -> [], ast
      in
      PpxContext.restore fields;
      let mapper = mapper () in
      let ast = mapper.structure mapper ast in
      let fields = PpxContext.update_cookies fields in
      Str.attribute (PpxContext.mk fields) :: ast
    with exn ->
      match error_of_exn exn with
      | Some error ->
          [{pstr_desc = Pstr_extension (extension_of_error error, []);
            pstr_loc  = Location.none}]
      | None -> raise exn
  in
  let iface ast =
    try
      let fields, ast =
        match ast with
        | {psig_desc = Psig_attribute ({txt = "ocaml.ppx.context"}, x)} :: l ->
            PpxContext.get_fields x, l
        | _ -> [], ast
      in
      PpxContext.restore fields;
      let mapper = mapper () in
      let ast = mapper.signature mapper ast in
      let fields = PpxContext.update_cookies fields in
      Sig.attribute (PpxContext.mk fields) :: ast
    with exn ->
      match error_of_exn exn with
      | Some error ->
          [{psig_desc = Psig_extension (extension_of_error error, []);
            psig_loc  = Location.none}]
      | None -> raise exn
  in
  let ast =
    if magic = Config.ast_impl_magic_number
    then Obj.magic (implem (Obj.magic ast))
    else Obj.magic (iface (Obj.magic ast))
  in
  let oc = open_out_bin target in
  output_string oc magic;
  output_value oc !Location.input_name;
  output_value oc ast;
  close_out oc

let drop_ppx_context_str ~restore = function
  | {pstr_desc = Pstr_attribute({Location.txt = "ocaml.ppx.context"}, a)}
    :: items ->
      if restore then
        PpxContext.restore (PpxContext.get_fields a);
      items
  | items -> items

let drop_ppx_context_sig ~restore = function
  | {psig_desc = Psig_attribute({Location.txt = "ocaml.ppx.context"}, a)}
    :: items ->
      if restore then
        PpxContext.restore (PpxContext.get_fields a);
      items
  | items -> items

let add_ppx_context_str ~tool_name ast =
  Ast_helper.Str.attribute (ppx_context ~tool_name ()) :: ast

let add_ppx_context_sig ~tool_name ast =
  Ast_helper.Sig.attribute (ppx_context ~tool_name ()) :: ast


let apply ~source ~target mapper =
  apply_lazy ~source ~target (fun () -> mapper)

let run_main mapper =
  try
    let a = Sys.argv in
    let n = Array.length a in
    if n > 2 then
      let mapper () =
        try mapper (Array.to_list (Array.sub a 1 (n - 3)))
        with exn ->
          (* PR #6463 *)
          let f _ _ = raise exn in
          {default_mapper with structure = f; signature = f}
      in
      apply_lazy ~source:a.(n - 2) ~target:a.(n - 1) mapper
    else begin
      Printf.eprintf "Usage: %s [extra_args] <infile> <outfile>\n%!"
                     Sys.executable_name;
      exit 2
    end
  with exn ->
    prerr_endline (Printexc.to_string exn);
    exit 2

let register_function = ref (fun _name f -> run_main f)
let register name f = !register_function name f

end
module Tbl : sig 
#1 "tbl.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Association tables from any ordered type to any type.
   We use the generic ordering to compare keys. *)

type ('a, 'b) t

val empty: ('a, 'b) t
val add: 'a -> 'b -> ('a, 'b) t -> ('a, 'b) t
val find: 'a -> ('a, 'b) t -> 'b
val mem: 'a -> ('a, 'b) t -> bool
val remove: 'a -> ('a,  'b) t -> ('a, 'b) t
val iter: ('a -> 'b -> unit) -> ('a, 'b) t -> unit
val map: ('a -> 'b -> 'c) -> ('a, 'b) t -> ('a, 'c) t
val fold: ('a -> 'b -> 'c -> 'c) -> ('a, 'b) t -> 'c -> 'c

open Format

val print: (formatter -> 'a -> unit) -> (formatter -> 'b -> unit) ->
           formatter -> ('a, 'b) t -> unit

end = struct
#1 "tbl.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

type ('a, 'b) t =
    Empty
  | Node of ('a, 'b) t * 'a * 'b * ('a, 'b) t * int

let empty = Empty

let height = function
    Empty -> 0
  | Node(_,_,_,_,h) -> h

let create l x d r =
  let hl = height l and hr = height r in
  Node(l, x, d, r, (if hl >= hr then hl + 1 else hr + 1))

let bal l x d r =
  let hl = height l and hr = height r in
  if hl > hr + 1 then
    match l with
    | Node (ll, lv, ld, lr, _) when height ll >= height lr ->
        create ll lv ld (create lr x d r)
    | Node (ll, lv, ld, Node (lrl, lrv, lrd, lrr, _), _) ->
        create (create ll lv ld lrl) lrv lrd (create lrr x d r)
    | _ -> assert false
  else if hr > hl + 1 then
    match r with
    | Node (rl, rv, rd, rr, _) when height rr >= height rl ->
        create (create l x d rl) rv rd rr
    | Node (Node (rll, rlv, rld, rlr, _), rv, rd, rr, _) ->
        create (create l x d rll) rlv rld (create rlr rv rd rr)
    | _ -> assert false
  else
    create l x d r

let rec add x data = function
    Empty ->
      Node(Empty, x, data, Empty, 1)
  | Node(l, v, d, r, h) ->
      let c = compare x v in
      if c = 0 then
        Node(l, x, data, r, h)
      else if c < 0 then
        bal (add x data l) v d r
      else
        bal l v d (add x data r)

let rec find x = function
    Empty ->
      raise Not_found
  | Node(l, v, d, r, _) ->
      let c = compare x v in
      if c = 0 then d
      else find x (if c < 0 then l else r)

let rec mem x = function
    Empty -> false
  | Node(l, v, d, r, _) ->
      let c = compare x v in
      c = 0 || mem x (if c < 0 then l else r)

let rec merge t1 t2 =
  match (t1, t2) with
    (Empty, t) -> t
  | (t, Empty) -> t
  | (Node(l1, v1, d1, r1, h1), Node(l2, v2, d2, r2, h2)) ->
      bal l1 v1 d1 (bal (merge r1 l2) v2 d2 r2)

let rec remove x = function
    Empty ->
      Empty
  | Node(l, v, d, r, h) ->
      let c = compare x v in
      if c = 0 then
        merge l r
      else if c < 0 then
        bal (remove x l) v d r
      else
        bal l v d (remove x r)

let rec iter f = function
    Empty -> ()
  | Node(l, v, d, r, _) ->
      iter f l; f v d; iter f r

let rec map f = function
    Empty -> Empty
  | Node(l, v, d, r, h) -> Node(map f l, v, f v d, map f r, h)

let rec fold f m accu =
  match m with
  | Empty -> accu
  | Node(l, v, d, r, _) ->
      fold f r (f v d (fold f l accu))

open Format

let print print_key print_data ppf tbl =
  let print_tbl ppf tbl =
    iter (fun k d -> fprintf ppf "@[<2>%a ->@ %a;@]@ " print_key k print_data d)
      tbl in
  fprintf ppf "@[<hv 2>[[%a]]@]" print_tbl tbl

end
module Subst : sig 
#1 "subst.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Substitutions *)

open Types

type t

(*
   Substitutions are used to translate a type from one context to
   another.  This requires substituing paths for identifiers, and
   possibly also lowering the level of non-generic variables so that
   it be inferior to the maximum level of the new context.

   Substitutions can also be used to create a "clean" copy of a type.
   Indeed, non-variable node of a type are duplicated, with their
   levels set to generic level.  That way, the resulting type is
   well-formed (decreasing levels), even if the original one was not.
*)

val identity: t

val add_type: Ident.t -> Path.t -> t -> t
val add_module: Ident.t -> Path.t -> t -> t
val add_modtype: Ident.t -> module_type -> t -> t
val for_saving: t -> t
val reset_for_saving: unit -> unit

val module_path: t -> Path.t -> Path.t
val type_path: t -> Path.t -> Path.t

val type_expr: t -> type_expr -> type_expr
val class_type: t -> class_type -> class_type
val value_description: t -> value_description -> value_description
val type_declaration: t -> type_declaration -> type_declaration
val extension_constructor:
        t -> extension_constructor -> extension_constructor
val class_declaration: t -> class_declaration -> class_declaration
val cltype_declaration: t -> class_type_declaration -> class_type_declaration
val modtype: t -> module_type -> module_type
val signature: t -> signature -> signature
val modtype_declaration: t -> modtype_declaration -> modtype_declaration
val module_declaration: t -> module_declaration -> module_declaration
val typexp : t -> Types.type_expr -> Types.type_expr
val class_signature: t -> class_signature -> class_signature

(* Composition of substitutions:
     apply (compose s1 s2) x = apply s2 (apply s1 x) *)
val compose: t -> t -> t

end = struct
#1 "subst.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Substitutions *)

open Misc
open Path
open Types
open Btype

type t =
  { types: (Ident.t, Path.t) Tbl.t;
    modules: (Ident.t, Path.t) Tbl.t;
    modtypes: (Ident.t, module_type) Tbl.t;
    for_saving: bool }

let identity =
  { types = Tbl.empty; modules = Tbl.empty; modtypes = Tbl.empty;
    for_saving = false }

let add_type id p s = { s with types = Tbl.add id p s.types }

let add_module id p s = { s with modules = Tbl.add id p s.modules }

let add_modtype id ty s = { s with modtypes = Tbl.add id ty s.modtypes }

let for_saving s = { s with for_saving = true }

let loc s x =
  if s.for_saving && not !Clflags.keep_locs then Location.none else x

let remove_loc =
  let open Ast_mapper in
  {default_mapper with location = (fun _this _loc -> Location.none)}

let is_not_doc = function
  | ({Location.txt = "ocaml.doc"}, _) -> false
  | ({Location.txt = "ocaml.text"}, _) -> false
  | ({Location.txt = "doc"}, _) -> false
  | ({Location.txt = "text"}, _) -> false
  | _ -> true

let attrs s x =
  let x =
    if s.for_saving && not !Clflags.keep_docs then
      List.filter is_not_doc x
    else x
  in
    if s.for_saving && not !Clflags.keep_locs
    then remove_loc.Ast_mapper.attributes remove_loc x
    else x

let rec module_path s = function
    Pident id as p ->
      begin try Tbl.find id s.modules with Not_found -> p end
  | Pdot(p, n, pos) ->
      Pdot(module_path s p, n, pos)
  | Papply(p1, p2) ->
      Papply(module_path s p1, module_path s p2)

let modtype_path s = function
    Pident id as p ->
      begin try
        match Tbl.find id s.modtypes with
          | Mty_ident p -> p
          | _ -> fatal_error "Subst.modtype_path"
      with Not_found -> p end
  | Pdot(p, n, pos) ->
      Pdot(module_path s p, n, pos)
  | Papply(p1, p2) ->
      fatal_error "Subst.modtype_path"

let type_path s = function
    Pident id as p ->
      begin try Tbl.find id s.types with Not_found -> p end
  | Pdot(p, n, pos) ->
      Pdot(module_path s p, n, pos)
  | Papply(p1, p2) ->
      fatal_error "Subst.type_path"

(* Special type ids for saved signatures *)

let new_id = ref (-1)
let reset_for_saving () = new_id := -1

let newpersty desc =
  decr new_id;
  { desc = desc; level = generic_level; id = !new_id }

(* ensure that all occurrences of 'Tvar None' are physically shared *)
let tvar_none = Tvar None
let tunivar_none = Tunivar None
let norm = function
  | Tvar None -> tvar_none
  | Tunivar None -> tunivar_none
  | d -> d

(* Similar to [Ctype.nondep_type_rec]. *)
let rec typexp s ty =
  let ty = repr ty in
  match ty.desc with
    Tvar _ | Tunivar _ as desc ->
      if s.for_saving || ty.id < 0 then
        let ty' =
          if s.for_saving then newpersty (norm desc)
          else newty2 ty.level desc
        in
        save_desc ty desc; ty.desc <- Tsubst ty'; ty'
      else ty
  | Tsubst ty ->
      ty
(* cannot do it, since it would omit subsitution
  | Tvariant row when not (static_row row) ->
      ty
*)
  | _ ->
    let desc = ty.desc in
    save_desc ty desc;
    (* Make a stub *)
    let ty' = if s.for_saving then newpersty (Tvar None) else newgenvar () in
    ty.desc <- Tsubst ty';
    ty'.desc <-
      begin match desc with
      | Tconstr(p, tl, abbrev) ->
          Tconstr(type_path s p, List.map (typexp s) tl, ref Mnil)
      | Tpackage(p, n, tl) ->
          Tpackage(modtype_path s p, n, List.map (typexp s) tl)
      | Tobject (t1, name) ->
          Tobject (typexp s t1,
                 ref (match !name with
                        None -> None
                      | Some (p, tl) ->
                          Some (type_path s p, List.map (typexp s) tl)))
      | Tfield (m, k, t1, t2)
        when s == identity && ty.level < generic_level && m = dummy_method ->
          (* not allowed to lower the level of the dummy method *)
          Tfield (m, k, t1, typexp s t2)
      | Tvariant row ->
          let row = row_repr row in
          let more = repr row.row_more in
          (* We must substitute in a subtle way *)
          (* Tsubst takes a tuple containing the row var and the variant *)
          begin match more.desc with
            Tsubst {desc = Ttuple [_;ty2]} ->
              (* This variant type has been already copied *)
              ty.desc <- Tsubst ty2; (* avoid Tlink in the new type *)
              Tlink ty2
          | _ ->
              let dup =
                s.for_saving || more.level = generic_level || static_row row ||
                match more.desc with Tconstr _ -> true | _ -> false in
              (* Various cases for the row variable *)
              let more' =
                match more.desc with
                  Tsubst ty -> ty
                | Tconstr _ | Tnil -> typexp s more
                | Tunivar _ | Tvar _ ->
                    save_desc more more.desc;
                    if s.for_saving then newpersty (norm more.desc) else
                    if dup && is_Tvar more then newgenty more.desc else more
                | _ -> assert false
              in
              (* Register new type first for recursion *)
              more.desc <- Tsubst(newgenty(Ttuple[more';ty']));
              (* Return a new copy *)
              let row =
                copy_row (typexp s) true row (not dup) more' in
              match row.row_name with
                Some (p, tl) ->
                  Tvariant {row with row_name = Some (type_path s p, tl)}
              | None ->
                  Tvariant row
          end
      | Tfield(label, kind, t1, t2) when field_kind_repr kind = Fabsent ->
          Tlink (typexp s t2)
      | _ -> copy_type_desc (typexp s) desc
      end;
    ty'

(*
   Always make a copy of the type. If this is not done, type levels
   might not be correct.
*)
let type_expr s ty =
  let ty' = typexp s ty in
  cleanup_types ();
  ty'

let type_declaration s decl =
  let decl =
    { type_params = List.map (typexp s) decl.type_params;
      type_arity = decl.type_arity;
      type_kind =
        begin match decl.type_kind with
          Type_abstract -> Type_abstract
        | Type_variant cstrs ->
            Type_variant
              (List.map
                 (fun c ->
                    {
                      cd_id = c.cd_id;
                      cd_args = List.map (typexp s) c.cd_args;
                      cd_res = may_map (typexp s) c.cd_res;
                      cd_loc = loc s c.cd_loc;
                      cd_attributes = attrs s c.cd_attributes;
                    }
                 )
                 cstrs)
        | Type_record(lbls, rep) ->
            Type_record
              (List.map (fun l ->
                   {
                     ld_id = l.ld_id;
                     ld_mutable = l.ld_mutable;
                     ld_type = typexp s l.ld_type;
                     ld_loc = loc s l.ld_loc;
                     ld_attributes = attrs s l.ld_attributes;
                   }
                 )
                  lbls,
               rep)
        | Type_open -> Type_open
        end;
      type_manifest =
        begin
          match decl.type_manifest with
            None -> None
          | Some ty -> Some(typexp s ty)
        end;
      type_private = decl.type_private;
      type_variance = decl.type_variance;
      type_newtype_level = None;
      type_loc = loc s decl.type_loc;
      type_attributes = attrs s decl.type_attributes;
    }
  in
  cleanup_types ();
  decl

let class_signature s sign =
  { csig_self = typexp s sign.csig_self;
    csig_vars =
      Vars.map (function (m, v, t) -> (m, v, typexp s t)) sign.csig_vars;
    csig_concr = sign.csig_concr;
    csig_inher =
      List.map (fun (p, tl) -> (type_path s p, List.map (typexp s) tl))
        sign.csig_inher;
  }

let rec class_type s =
  function
    Cty_constr (p, tyl, cty) ->
      Cty_constr (type_path s p, List.map (typexp s) tyl, class_type s cty)
  | Cty_signature sign ->
      Cty_signature (class_signature s sign)
  | Cty_arrow (l, ty, cty) ->
      Cty_arrow (l, typexp s ty, class_type s cty)

let class_declaration s decl =
  let decl =
    { cty_params = List.map (typexp s) decl.cty_params;
      cty_variance = decl.cty_variance;
      cty_type = class_type s decl.cty_type;
      cty_path = type_path s decl.cty_path;
      cty_new =
        begin match decl.cty_new with
          None    -> None
        | Some ty -> Some (typexp s ty)
        end;
      cty_loc = loc s decl.cty_loc;
      cty_attributes = attrs s decl.cty_attributes;
    }
  in
  (* Do not clean up if saving: next is cltype_declaration *)
  if not s.for_saving then cleanup_types ();
  decl

let cltype_declaration s decl =
  let decl =
    { clty_params = List.map (typexp s) decl.clty_params;
      clty_variance = decl.clty_variance;
      clty_type = class_type s decl.clty_type;
      clty_path = type_path s decl.clty_path;
      clty_loc = loc s decl.clty_loc;
      clty_attributes = attrs s decl.clty_attributes;
    }
  in
  (* Do clean up even if saving: type_declaration may be recursive *)
  cleanup_types ();
  decl

let class_type s cty =
  let cty = class_type s cty in
  cleanup_types ();
  cty

let value_description s descr =
  { val_type = type_expr s descr.val_type;
    val_kind = descr.val_kind;
    val_loc = loc s descr.val_loc;
    val_attributes = attrs s descr.val_attributes;
   }

let extension_constructor s ext =
  let ext =
    { ext_type_path = type_path s ext.ext_type_path;
      ext_type_params = List.map (typexp s) ext.ext_type_params;
      ext_args = List.map (typexp s) ext.ext_args;
      ext_ret_type = may_map (typexp s) ext.ext_ret_type;
      ext_private = ext.ext_private;
      ext_attributes = attrs s ext.ext_attributes;
      ext_loc = if s.for_saving then Location.none else ext.ext_loc; }
  in
    cleanup_types ();
    ext

let rec rename_bound_idents s idents = function
    [] -> (List.rev idents, s)
  | Sig_type(id, d, _) :: sg ->
      let id' = Ident.rename id in
      rename_bound_idents (add_type id (Pident id') s) (id' :: idents) sg
  | Sig_module(id, mty, _) :: sg ->
      let id' = Ident.rename id in
      rename_bound_idents (add_module id (Pident id') s) (id' :: idents) sg
  | Sig_modtype(id, d) :: sg ->
      let id' = Ident.rename id in
      rename_bound_idents (add_modtype id (Mty_ident(Pident id')) s)
                          (id' :: idents) sg
  | (Sig_value(id, _) | Sig_typext(id, _, _) |
     Sig_class(id, _, _) | Sig_class_type(id, _, _)) :: sg ->
      let id' = Ident.rename id in
      rename_bound_idents s (id' :: idents) sg

let rec modtype s = function
    Mty_ident p as mty ->
      begin match p with
        Pident id ->
          begin try Tbl.find id s.modtypes with Not_found -> mty end
      | Pdot(p, n, pos) ->
          Mty_ident(Pdot(module_path s p, n, pos))
      | Papply(p1, p2) ->
          fatal_error "Subst.modtype"
      end
  | Mty_signature sg ->
      Mty_signature(signature s sg)
  | Mty_functor(id, arg, res) ->
      let id' = Ident.rename id in
      Mty_functor(id', may_map (modtype s) arg,
                       modtype (add_module id (Pident id') s) res)
  | Mty_alias p ->
      Mty_alias(module_path s p)

and signature s sg =
  (* Components of signature may be mutually recursive (e.g. type declarations
     or class and type declarations), so first build global renaming
     substitution... *)
  let (new_idents, s') = rename_bound_idents s [] sg in
  (* ... then apply it to each signature component in turn *)
  List.map2 (signature_component s') sg new_idents

and signature_component s comp newid =
  match comp with
    Sig_value(id, d) ->
      Sig_value(newid, value_description s d)
  | Sig_type(id, d, rs) ->
      Sig_type(newid, type_declaration s d, rs)
  | Sig_typext(id, ext, es) ->
      Sig_typext(newid, extension_constructor s ext, es)
  | Sig_module(id, d, rs) ->
      Sig_module(newid, module_declaration s d, rs)
  | Sig_modtype(id, d) ->
      Sig_modtype(newid, modtype_declaration s d)
  | Sig_class(id, d, rs) ->
      Sig_class(newid, class_declaration s d, rs)
  | Sig_class_type(id, d, rs) ->
      Sig_class_type(newid, cltype_declaration s d, rs)

and module_declaration s decl =
  {
    md_type = modtype s decl.md_type;
    md_attributes = attrs s decl.md_attributes;
    md_loc = loc s decl.md_loc;
  }

and modtype_declaration s decl  =
  {
    mtd_type = may_map (modtype s) decl.mtd_type;
    mtd_attributes = attrs s decl.mtd_attributes;
    mtd_loc = loc s decl.mtd_loc;
  }

(* For every binding k |-> d of m1, add k |-> f d to m2
   and return resulting merged map. *)

let merge_tbls f m1 m2 =
  Tbl.fold (fun k d accu -> Tbl.add k (f d) accu) m1 m2

(* Composition of substitutions:
     apply (compose s1 s2) x = apply s2 (apply s1 x) *)

let compose s1 s2 =
  { types = merge_tbls (type_path s2) s1.types s2.types;
    modules = merge_tbls (module_path s2) s1.modules s2.modules;
    modtypes = merge_tbls (modtype s2) s1.modtypes s2.modtypes;
    for_saving = false }

end
module Env : sig 
#1 "env.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Environment handling *)

open Types

type summary =
    Env_empty
  | Env_value of summary * Ident.t * value_description
  | Env_type of summary * Ident.t * type_declaration
  | Env_extension of summary * Ident.t * extension_constructor
  | Env_module of summary * Ident.t * module_declaration
  | Env_modtype of summary * Ident.t * modtype_declaration
  | Env_class of summary * Ident.t * class_declaration
  | Env_cltype of summary * Ident.t * class_type_declaration
  | Env_open of summary * Path.t
  | Env_functor_arg of summary * Ident.t

type t

val empty: t
val initial_safe_string: t
val initial_unsafe_string: t
val diff: t -> t -> Ident.t list

type type_descriptions =
    constructor_description list * label_description list

(* For short-paths *)
type iter_cont
val iter_types:
    (Path.t -> Path.t * (type_declaration * type_descriptions) -> unit) ->
    t -> iter_cont
val run_iter_cont: iter_cont list -> (Path.t * iter_cont) list
val same_types: t -> t -> bool
val used_persistent: unit -> Concr.t
val find_shadowed_types: Path.t -> t -> Path.t list

(* Lookup by paths *)

val find_value: Path.t -> t -> value_description
val find_type: Path.t -> t -> type_declaration
val find_type_descrs: Path.t -> t -> type_descriptions
val find_module: Path.t -> t -> module_declaration
val find_modtype: Path.t -> t -> modtype_declaration
val find_class: Path.t -> t -> class_declaration
val find_cltype: Path.t -> t -> class_type_declaration

val find_type_expansion:
    Path.t -> t -> type_expr list * type_expr * int option
val find_type_expansion_opt:
    Path.t -> t -> type_expr list * type_expr * int option
(* Find the manifest type information associated to a type for the sake
   of the compiler's type-based optimisations. *)
val find_modtype_expansion: Path.t -> t -> module_type
val is_functor_arg: Path.t -> t -> bool
val normalize_path: Location.t option -> t -> Path.t -> Path.t
(* Normalize the path to a concrete value or module.
   If the option is None, allow returning dangling paths.
   Otherwise raise a Missing_module error, and may add forgotten
   head as required global. *)
val reset_required_globals: unit -> unit
val get_required_globals: unit -> Ident.t list
val add_required_global: Ident.t -> unit

val has_local_constraints: t -> bool
val add_gadt_instance_level: int -> t -> t
val gadt_instance_level: t -> type_expr -> int option
val add_gadt_instances: t -> int -> type_expr list -> unit
val add_gadt_instance_chain: t -> int -> type_expr -> unit

(* Lookup by long identifiers *)

val lookup_value: Longident.t -> t -> Path.t * value_description
val lookup_constructor: Longident.t -> t -> constructor_description
val lookup_all_constructors:
  Longident.t -> t -> (constructor_description * (unit -> unit)) list
val lookup_label: Longident.t -> t -> label_description
val lookup_all_labels:
  Longident.t -> t -> (label_description * (unit -> unit)) list
val lookup_type: Longident.t -> t -> Path.t * type_declaration
val lookup_module: load:bool -> Longident.t -> t -> Path.t
val lookup_modtype: Longident.t -> t -> Path.t * modtype_declaration
val lookup_class: Longident.t -> t -> Path.t * class_declaration
val lookup_cltype: Longident.t -> t -> Path.t * class_type_declaration

exception Recmodule
  (* Raise by lookup_module when the identifier refers
     to one of the modules of a recursive definition
     during the computation of its approximation (see #5965). *)

(* Insertion by identifier *)

val add_value:
    ?check:(string -> Warnings.t) -> Ident.t -> value_description -> t -> t
val add_type: check:bool -> Ident.t -> type_declaration -> t -> t
val add_extension: check:bool -> Ident.t -> extension_constructor -> t -> t
val add_module: ?arg:bool -> Ident.t -> module_type -> t -> t
val add_module_declaration: ?arg:bool -> Ident.t -> module_declaration -> t -> t
val add_modtype: Ident.t -> modtype_declaration -> t -> t
val add_class: Ident.t -> class_declaration -> t -> t
val add_cltype: Ident.t -> class_type_declaration -> t -> t
val add_local_constraint: Ident.t -> type_declaration -> int -> t -> t

(* Insertion of all fields of a signature. *)

val add_item: signature_item -> t -> t
val add_signature: signature -> t -> t

(* Insertion of all fields of a signature, relative to the given path.
   Used to implement open. *)

val open_signature:
    ?loc:Location.t -> ?toplevel:bool -> Asttypes.override_flag -> Path.t ->
      signature -> t -> t
val open_pers_signature: string -> t -> t

(* Insertion by name *)

val enter_value:
    ?check:(string -> Warnings.t) ->
    string -> value_description -> t -> Ident.t * t
val enter_type: string -> type_declaration -> t -> Ident.t * t
val enter_extension: string -> extension_constructor -> t -> Ident.t * t
val enter_module: ?arg:bool -> string -> module_type -> t -> Ident.t * t
val enter_module_declaration:
    ?arg:bool -> string -> module_declaration -> t -> Ident.t * t
val enter_modtype: string -> modtype_declaration -> t -> Ident.t * t
val enter_class: string -> class_declaration -> t -> Ident.t * t
val enter_cltype: string -> class_type_declaration -> t -> Ident.t * t

(* Initialize the cache of in-core module interfaces. *)
val reset_cache: unit -> unit

(* To be called before each toplevel phrase. *)
val reset_cache_toplevel: unit -> unit

(* Remember the name of the current compilation unit. *)
val set_unit_name: string -> unit
val get_unit_name: unit -> string

(* Read, save a signature to/from a file *)

val read_signature: string -> string -> signature
        (* Arguments: module name, file name. Results: signature. *)
val save_signature: signature -> string -> string -> signature
        (* Arguments: signature, module name, file name. *)
val save_signature_with_imports:
    signature -> string -> string -> (string * Digest.t option) list -> signature
        (* Arguments: signature, module name, file name,
           imported units with their CRCs. *)

(* Return the CRC of the interface of the given compilation unit *)

val crc_of_unit: string -> Digest.t

(* Return the set of compilation units imported, with their CRC *)

val imports: unit -> (string * Digest.t option) list

(* Direct access to the table of imported compilation units with their CRC *)

val crc_units: Consistbl.t
val add_import: string -> unit

(* Summaries -- compact representation of an environment, to be
   exported in debugging information. *)

val summary: t -> summary

(* Return an equivalent environment where all fields have been reset,
   except the summary. The initial environment can be rebuilt from the
   summary, using Envaux.env_of_only_summary. *)

val keep_only_summary : t -> t
val env_of_only_summary : (summary -> Subst.t -> t) -> t -> t

(* Error report *)

type error =
  | Illegal_renaming of string * string * string
  | Inconsistent_import of string * string * string
  | Need_recursive_types of string * string
  | Missing_module of Location.t * Path.t * Path.t
  | Illegal_value_name of Location.t * string

exception Error of error

open Format

val report_error: formatter -> error -> unit


val mark_value_used: t -> string -> value_description -> unit
val mark_type_used: t -> string -> type_declaration -> unit

type constructor_usage = Positive | Pattern | Privatize
val mark_constructor_used:
    constructor_usage -> t -> string -> type_declaration -> string -> unit
val mark_constructor:
    constructor_usage -> t -> string -> constructor_description -> unit
val mark_extension_used:
    constructor_usage -> t -> extension_constructor -> string -> unit

val in_signature: t -> t
val implicit_coercion: t -> t

val set_value_used_callback:
    string -> value_description -> (unit -> unit) -> unit
val set_type_used_callback:
    string -> type_declaration -> ((unit -> unit) -> unit) -> unit

(* Forward declaration to break mutual recursion with Includemod. *)
val check_modtype_inclusion:
      (t -> module_type -> Path.t -> module_type -> unit) ref
(* Forward declaration to break mutual recursion with Typecore. *)
val add_delayed_check_forward: ((unit -> unit) -> unit) ref
(* Forward declaration to break mutual recursion with Mtype. *)
val strengthen: (t -> module_type -> Path.t -> module_type) ref

(** Folding over all identifiers (for analysis purpose) *)

val fold_values:
  (string -> Path.t -> value_description -> 'a -> 'a) ->
  Longident.t option -> t -> 'a -> 'a
val fold_types:
  (string -> Path.t -> type_declaration * type_descriptions -> 'a -> 'a) ->
  Longident.t option -> t -> 'a -> 'a
val fold_constructors:
  (constructor_description -> 'a -> 'a) ->
  Longident.t option -> t -> 'a -> 'a
val fold_labels:
  (label_description -> 'a -> 'a) ->
  Longident.t option -> t -> 'a -> 'a

(** Persistent structures are only traversed if they are already loaded. *)
val fold_modules:
  (string -> Path.t -> module_declaration -> 'a -> 'a) ->
  Longident.t option -> t -> 'a -> 'a

val fold_modtypes:
  (string -> Path.t -> modtype_declaration -> 'a -> 'a) ->
  Longident.t option -> t -> 'a -> 'a
val fold_classs:
  (string -> Path.t -> class_declaration -> 'a -> 'a) ->
  Longident.t option -> t -> 'a -> 'a
val fold_cltypes:
  (string -> Path.t -> class_type_declaration -> 'a -> 'a) ->
  Longident.t option -> t -> 'a -> 'a

(** Utilities *)
val scrape_alias: t -> module_type -> module_type
val check_value_name: string -> Location.t -> unit

end = struct
#1 "env.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Environment handling *)

open Cmi_format
open Config
open Misc
open Asttypes
open Longident
open Path
open Types
open Btype

let add_delayed_check_forward = ref (fun _ -> assert false)

let value_declarations : ((string * Location.t), (unit -> unit)) Hashtbl.t =
  Hashtbl.create 16
    (* This table is used to usage of value declarations.  A declaration is
       identified with its name and location.  The callback attached to a
       declaration is called whenever the value is used explicitly
       (lookup_value) or implicitly (inclusion test between signatures,
       cf Includemod.value_descriptions). *)

let type_declarations = Hashtbl.create 16

type constructor_usage = Positive | Pattern | Privatize
type constructor_usages =
    {
     mutable cu_positive: bool;
     mutable cu_pattern: bool;
     mutable cu_privatize: bool;
    }
let add_constructor_usage cu = function
  | Positive -> cu.cu_positive <- true
  | Pattern -> cu.cu_pattern <- true
  | Privatize -> cu.cu_privatize <- true
let constructor_usages () =
  {cu_positive = false; cu_pattern = false; cu_privatize = false}

let used_constructors :
    (string * Location.t * string, (constructor_usage -> unit)) Hashtbl.t
  = Hashtbl.create 16

let prefixed_sg = Hashtbl.create 113

type error =
  | Illegal_renaming of string * string * string
  | Inconsistent_import of string * string * string
  | Need_recursive_types of string * string
  | Missing_module of Location.t * Path.t * Path.t
  | Illegal_value_name of Location.t * string

exception Error of error

let error err = raise (Error err)

module EnvLazy : sig
  type ('a,'b) t

  val force : ('a -> 'b) -> ('a,'b) t -> 'b
  val create : 'a -> ('a,'b) t
  val is_val : ('a,'b) t -> bool
  val get_arg : ('a,'b) t -> 'a option

end  = struct

  type ('a,'b) t = ('a,'b) eval ref

  and ('a,'b) eval =
      Done of 'b
    | Raise of exn
    | Thunk of 'a

  let force f x =
    match !x with
        Done x -> x
      | Raise e -> raise e
      | Thunk e ->
          try
            let y = f e in
            x := Done y;
            y
          with e ->
            x := Raise e;
            raise e

  let is_val x =
    match !x with Done _ -> true | _ -> false

  let get_arg x =
    match !x with Thunk a -> Some a | _ -> None

  let create x =
    let x = ref (Thunk x) in
    x

end


type summary =
    Env_empty
  | Env_value of summary * Ident.t * value_description
  | Env_type of summary * Ident.t * type_declaration
  | Env_extension of summary * Ident.t * extension_constructor
  | Env_module of summary * Ident.t * module_declaration
  | Env_modtype of summary * Ident.t * modtype_declaration
  | Env_class of summary * Ident.t * class_declaration
  | Env_cltype of summary * Ident.t * class_type_declaration
  | Env_open of summary * Path.t
  | Env_functor_arg of summary * Ident.t

module EnvTbl =
  struct
    (* A table indexed by identifier, with an extra slot to record usage. *)
    type 'a t = ('a * (unit -> unit)) Ident.tbl

    let empty = Ident.empty
    let nothing = fun () -> ()

    let already_defined s tbl =
      try ignore (Ident.find_name s tbl); true
      with Not_found -> false

    let add kind slot id x tbl ref_tbl =
      let slot =
        match slot with
        | None -> nothing
        | Some f ->
          (fun () ->
             let s = Ident.name id in
             f kind s (already_defined s ref_tbl)
          )
      in
      Ident.add id (x, slot) tbl

    let add_dont_track id x tbl =
      Ident.add id (x, nothing) tbl

    let find_same_not_using id tbl =
      fst (Ident.find_same id tbl)

    let find_same id tbl =
      let (x, slot) = Ident.find_same id tbl in
      slot ();
      x

    let find_name s tbl =
      let (x, slot) = Ident.find_name s tbl in
      slot ();
      x

    let find_all s tbl =
      Ident.find_all s tbl

    let fold_name f = Ident.fold_name (fun k (d,_) -> f k d)
    let keys tbl = Ident.fold_all (fun k _ accu -> k::accu) tbl []
  end

type type_descriptions =
    constructor_description list * label_description list

let in_signature_flag = 0x01
let implicit_coercion_flag = 0x02

type t = {
  values: (Path.t * value_description) EnvTbl.t;
  constrs: constructor_description EnvTbl.t;
  labels: label_description EnvTbl.t;
  types: (Path.t * (type_declaration * type_descriptions)) EnvTbl.t;
  modules: (Path.t * module_declaration) EnvTbl.t;
  modtypes: (Path.t * modtype_declaration) EnvTbl.t;
  components: (Path.t * module_components) EnvTbl.t;
  classes: (Path.t * class_declaration) EnvTbl.t;
  cltypes: (Path.t * class_type_declaration) EnvTbl.t;
  functor_args: unit Ident.tbl;
  summary: summary;
  local_constraints: bool;
  gadt_instances: (int * TypeSet.t ref) list;
  flags: int;
}

and module_components =
  (t * Subst.t * Path.t * Types.module_type, module_components_repr) EnvLazy.t

and module_components_repr =
    Structure_comps of structure_components
  | Functor_comps of functor_components

and structure_components = {
  mutable comp_values: (string, (value_description * int)) Tbl.t;
  mutable comp_constrs: (string, (constructor_description * int) list) Tbl.t;
  mutable comp_labels: (string, (label_description * int) list) Tbl.t;
  mutable comp_types:
   (string, ((type_declaration * type_descriptions) * int)) Tbl.t;
  mutable comp_modules:
   (string, ((Subst.t * Types.module_type,module_type) EnvLazy.t * int)) Tbl.t;
  mutable comp_modtypes: (string, (modtype_declaration * int)) Tbl.t;
  mutable comp_components: (string, (module_components * int)) Tbl.t;
  mutable comp_classes: (string, (class_declaration * int)) Tbl.t;
  mutable comp_cltypes: (string, (class_type_declaration * int)) Tbl.t
}

and functor_components = {
  fcomp_param: Ident.t;                 (* Formal parameter *)
  fcomp_arg: module_type option;        (* Argument signature *)
  fcomp_res: module_type;               (* Result signature *)
  fcomp_env: t;     (* Environment in which the result signature makes sense *)
  fcomp_subst: Subst.t;  (* Prefixing substitution for the result signature *)
  fcomp_cache: (Path.t, module_components) Hashtbl.t;  (* For memoization *)
  fcomp_subst_cache: (Path.t, module_type) Hashtbl.t
}

let subst_modtype_maker (subst, mty) = Subst.modtype subst mty

let empty = {
  values = EnvTbl.empty; constrs = EnvTbl.empty;
  labels = EnvTbl.empty; types = EnvTbl.empty;
  modules = EnvTbl.empty; modtypes = EnvTbl.empty;
  components = EnvTbl.empty; classes = EnvTbl.empty;
  cltypes = EnvTbl.empty;
  summary = Env_empty; local_constraints = false; gadt_instances = [];
  flags = 0;
  functor_args = Ident.empty;
 }

let in_signature env =
  {env with flags = env.flags lor in_signature_flag}
let implicit_coercion env =
  {env with flags = env.flags lor implicit_coercion_flag}

let is_in_signature env = env.flags land in_signature_flag <> 0
let is_implicit_coercion env = env.flags land implicit_coercion_flag <> 0

let diff_keys is_local tbl1 tbl2 =
  let keys2 = EnvTbl.keys tbl2 in
  List.filter
    (fun id ->
      is_local (EnvTbl.find_same_not_using id tbl2) &&
      try ignore (EnvTbl.find_same_not_using id tbl1); false
      with Not_found -> true)
    keys2

let is_ident = function
    Pident _ -> true
  | Pdot _ | Papply _ -> false

let is_local (p, _) = is_ident p

let is_local_ext = function
  | {cstr_tag = Cstr_extension(p, _)} -> is_ident p
  | _ -> false

let diff env1 env2 =
  diff_keys is_local env1.values env2.values @
  diff_keys is_local_ext env1.constrs env2.constrs @
  diff_keys is_local env1.modules env2.modules @
  diff_keys is_local env1.classes env2.classes

(* Forward declarations *)

let components_of_module' =
  ref ((fun env sub path mty -> assert false) :
          t -> Subst.t -> Path.t -> module_type -> module_components)
let components_of_module_maker' =
  ref ((fun (env, sub, path, mty) -> assert false) :
          t * Subst.t * Path.t * module_type -> module_components_repr)
let components_of_functor_appl' =
  ref ((fun f p1 p2 -> assert false) :
          functor_components -> Path.t -> Path.t -> module_components)
let check_modtype_inclusion =
  (* to be filled with Includemod.check_modtype_inclusion *)
  ref ((fun env mty1 path1 mty2 -> assert false) :
          t -> module_type -> Path.t -> module_type -> unit)
let strengthen =
  (* to be filled with Mtype.strengthen *)
  ref ((fun env mty path -> assert false) :
         t -> module_type -> Path.t -> module_type)

let md md_type =
  {md_type; md_attributes=[]; md_loc=Location.none}

(* The name of the compilation unit currently compiled.
   "" if outside a compilation unit. *)

let current_unit = ref ""

(* Persistent structure descriptions *)

type pers_struct =
  { ps_name: string;
    ps_sig: signature;
    ps_comps: module_components;
    ps_crcs: (string * Digest.t option) list;
    mutable ps_crcs_checked: bool;
    ps_filename: string;
    ps_flags: pers_flags list }

let persistent_structures =
  (Hashtbl.create 17 : (string, pers_struct option) Hashtbl.t)

(* Consistency between persistent structures *)

let crc_units = Consistbl.create()

module StringSet =
  Set.Make(struct type t = string let compare = String.compare end)

let imported_units = ref StringSet.empty

let add_import s =
  imported_units := StringSet.add s !imported_units

let clear_imports () =
  Consistbl.clear crc_units;
  imported_units := StringSet.empty

let check_consistency ps =
  if not ps.ps_crcs_checked then
  try
    List.iter
      (fun (name, crco) ->
         match crco with
            None -> ()
          | Some crc ->
              add_import name;
              Consistbl.check crc_units name crc ps.ps_filename)
      ps.ps_crcs;
    ps.ps_crcs_checked <- true;
  with Consistbl.Inconsistency(name, source, auth) ->
    error (Inconsistent_import(name, auth, source))

(* Reading persistent structures from .cmi files *)

let save_pers_struct crc ps =
  let modname = ps.ps_name in
  Hashtbl.add persistent_structures modname (Some ps);
  Consistbl.set crc_units modname crc ps.ps_filename;
  add_import modname

let read_pers_struct modname filename =
  let cmi = read_cmi filename in
  let name = cmi.cmi_name in
  let sign = cmi.cmi_sign in
  let crcs = cmi.cmi_crcs in
  let flags = cmi.cmi_flags in
  let comps =
      !components_of_module' empty Subst.identity
                             (Pident(Ident.create_persistent name))
                             (Mty_signature sign)
  in
  let ps = { ps_name = name;
             ps_sig = sign;
             ps_comps = comps;
             ps_crcs = crcs;
             ps_filename = filename;
             ps_flags = flags;
             ps_crcs_checked = false;
           } in
  if ps.ps_name <> modname then
    error (Illegal_renaming(modname, ps.ps_name, filename));
  add_import name;
  List.iter
    (function Rectypes ->
      if not !Clflags.recursive_types then
        error (Need_recursive_types(ps.ps_name, !current_unit)))
    ps.ps_flags;
  Hashtbl.add persistent_structures modname (Some ps);
  ps

let find_pers_struct ?(check=true) name =
  if name = "*predef*" then raise Not_found;
  let r =
    try Some (Hashtbl.find persistent_structures name)
    with Not_found -> None
  in
  let ps =
    match r with
    | Some None -> raise Not_found
    | Some (Some sg) -> sg
    | None ->
       (* PR#6843: record the weak dependency ([add_import]) even if
          the [find_in_path_uncap] call below fails to find the .cmi,
          to help make builds more deterministic. *)
        add_import name;
        let filename =
          try find_in_path_uncap !load_path (name ^ ".cmi")
          with Not_found ->
            Hashtbl.add persistent_structures name None;
            raise Not_found
        in
        read_pers_struct name filename
  in
  if check then check_consistency ps;
  ps

let reset_cache () =
  current_unit := "";
  Hashtbl.clear persistent_structures;
  clear_imports ();
  Hashtbl.clear value_declarations;
  Hashtbl.clear type_declarations;
  Hashtbl.clear used_constructors;
  Hashtbl.clear prefixed_sg

let reset_cache_toplevel () =
  (* Delete 'missing cmi' entries from the cache. *)
  let l =
    Hashtbl.fold
      (fun name r acc -> if r = None then name :: acc else acc)
      persistent_structures []
  in
  List.iter (Hashtbl.remove persistent_structures) l;
  Hashtbl.clear value_declarations;
  Hashtbl.clear type_declarations;
  Hashtbl.clear used_constructors;
  Hashtbl.clear prefixed_sg


let set_unit_name name =
  current_unit := name

let get_unit_name () =
  !current_unit

(* Lookup by identifier *)

let rec find_module_descr path env =
  match path with
    Pident id ->
      begin try
        let (p, desc) = EnvTbl.find_same id env.components
        in desc
      with Not_found ->
        if Ident.persistent id && not (Ident.name id = !current_unit)
        then (find_pers_struct (Ident.name id)).ps_comps
        else raise Not_found
      end
  | Pdot(p, s, pos) ->
      begin match
        EnvLazy.force !components_of_module_maker' (find_module_descr p env)
      with
        Structure_comps c ->
          let (descr, pos) = Tbl.find s c.comp_components in
          descr
      | Functor_comps f ->
         raise Not_found
      end
  | Papply(p1, p2) ->
      begin match
        EnvLazy.force !components_of_module_maker' (find_module_descr p1 env)
      with
        Functor_comps f ->
          !components_of_functor_appl' f p1 p2
      | Structure_comps c ->
          raise Not_found
      end

let find proj1 proj2 path env =
  match path with
    Pident id ->
      let (p, data) = EnvTbl.find_same id (proj1 env)
      in data
  | Pdot(p, s, pos) ->
      begin match
        EnvLazy.force !components_of_module_maker' (find_module_descr p env)
      with
        Structure_comps c ->
          let (data, pos) = Tbl.find s (proj2 c) in data
      | Functor_comps f ->
          raise Not_found
      end
  | Papply(p1, p2) ->
      raise Not_found

let find_value =
  find (fun env -> env.values) (fun sc -> sc.comp_values)
and find_type_full =
  find (fun env -> env.types) (fun sc -> sc.comp_types)
and find_modtype =
  find (fun env -> env.modtypes) (fun sc -> sc.comp_modtypes)
and find_class =
  find (fun env -> env.classes) (fun sc -> sc.comp_classes)
and find_cltype =
  find (fun env -> env.cltypes) (fun sc -> sc.comp_cltypes)

let find_type p env =
  fst (find_type_full p env)
let find_type_descrs p env =
  snd (find_type_full p env)

let find_module ~alias path env =
  match path with
    Pident id ->
      begin try
        let (p, data) = EnvTbl.find_same id env.modules
        in data
      with Not_found ->
        if Ident.persistent id && not (Ident.name id = !current_unit) then
          let ps = find_pers_struct (Ident.name id) in
          md (Mty_signature(ps.ps_sig))
        else raise Not_found
      end
  | Pdot(p, s, pos) ->
      begin match
        EnvLazy.force !components_of_module_maker' (find_module_descr p env)
      with
        Structure_comps c ->
          let (data, pos) = Tbl.find s c.comp_modules in
          md (EnvLazy.force subst_modtype_maker data)
      | Functor_comps f ->
          raise Not_found
      end
  | Papply(p1, p2) ->
      let desc1 = find_module_descr p1 env in
      begin match EnvLazy.force !components_of_module_maker' desc1 with
        Functor_comps f ->
          md begin match f.fcomp_res with
          | Mty_alias p ->
              Mty_alias (Subst.module_path f.fcomp_subst p)
          | mty ->
              if alias then mty else
              try
                Hashtbl.find f.fcomp_subst_cache p2
              with Not_found ->
                let mty =
                  Subst.modtype
                    (Subst.add_module f.fcomp_param p2 f.fcomp_subst)
                    f.fcomp_res in
                Hashtbl.add f.fcomp_subst_cache p2 mty;
                mty
          end
      | Structure_comps c ->
          raise Not_found
      end

let required_globals = ref []
let reset_required_globals () = required_globals := []
let get_required_globals () = !required_globals
let add_required_global id =
  if Ident.global id && not !Clflags.transparent_modules
  && not (List.exists (Ident.same id) !required_globals)
  then required_globals := id :: !required_globals

let rec normalize_path lax env path =
  let path =
    match path with
      Pdot(p, s, pos) ->
        Pdot(normalize_path lax env p, s, pos)
    | Papply(p1, p2) ->
        Papply(normalize_path lax env p1, normalize_path true env p2)
    | _ -> path
  in
  try match find_module ~alias:true path env with
    {md_type=Mty_alias path1} ->
      let path' = normalize_path lax env path1 in
      if lax || !Clflags.transparent_modules then path' else
      let id = Path.head path in
      if Ident.global id && not (Ident.same id (Path.head path'))
      then add_required_global id;
      path'
  | _ -> path
  with Not_found when lax
  || (match path with Pident id -> not (Ident.persistent id) | _ -> true) ->
      path

let normalize_path oloc env path =
  try normalize_path (oloc = None) env path
  with Not_found ->
    match oloc with None -> assert false
    | Some loc ->
        raise (Error(Missing_module(loc, path, normalize_path true env path)))

let find_module = find_module ~alias:false

(* Find the manifest type associated to a type when appropriate:
   - the type should be public or should have a private row,
   - the type should have an associated manifest type. *)
let find_type_expansion path env =
  let decl = find_type path env in
  match decl.type_manifest with
  | Some body when decl.type_private = Public
              || decl.type_kind <> Type_abstract
              || Btype.has_constr_row body ->
                  (decl.type_params, body, may_map snd decl.type_newtype_level)
  (* The manifest type of Private abstract data types without
     private row are still considered unknown to the type system.
     Hence, this case is caught by the following clause that also handles
     purely abstract data types without manifest type definition. *)
  | _ ->
      (* another way to expand is to normalize the path itself *)
      let path' = normalize_path None env path in
      if Path.same path path' then raise Not_found else
      (decl.type_params,
       newgenty (Tconstr (path', decl.type_params, ref Mnil)),
       may_map snd decl.type_newtype_level)

(* Find the manifest type information associated to a type, i.e.
   the necessary information for the compiler's type-based optimisations.
   In particular, the manifest type associated to a private abstract type
   is revealed for the sake of compiler's type-based optimisations. *)
let find_type_expansion_opt path env =
  let decl = find_type path env in
  match decl.type_manifest with
  (* The manifest type of Private abstract data types can still get
     an approximation using their manifest type. *)
  | Some body -> (decl.type_params, body, may_map snd decl.type_newtype_level)
  | _ ->
      let path' = normalize_path None env path in
      if Path.same path path' then raise Not_found else
      (decl.type_params,
       newgenty (Tconstr (path', decl.type_params, ref Mnil)),
       may_map snd decl.type_newtype_level)

let find_modtype_expansion path env =
  match (find_modtype path env).mtd_type with
  | None -> raise Not_found
  | Some mty -> mty

let rec is_functor_arg path env =
  match path with
    Pident id ->
      begin try Ident.find_same id env.functor_args; true
      with Not_found -> false
      end
  | Pdot (p, s, _) -> is_functor_arg p env
  | Papply _ -> true

(* Lookup by name *)

exception Recmodule

let rec lookup_module_descr lid env =
  match lid with
    Lident s ->
      begin try
        EnvTbl.find_name s env.components
      with Not_found ->
        if s = !current_unit then raise Not_found;
        let ps = find_pers_struct s in
        (Pident(Ident.create_persistent s), ps.ps_comps)
      end
  | Ldot(l, s) ->
      let (p, descr) = lookup_module_descr l env in
      begin match EnvLazy.force !components_of_module_maker' descr with
        Structure_comps c ->
          let (descr, pos) = Tbl.find s c.comp_components in
          (Pdot(p, s, pos), descr)
      | Functor_comps f ->
          raise Not_found
      end
  | Lapply(l1, l2) ->
      let (p1, desc1) = lookup_module_descr l1 env in
      let p2 = lookup_module true l2 env in
      let {md_type=mty2} = find_module p2 env in
      begin match EnvLazy.force !components_of_module_maker' desc1 with
        Functor_comps f ->
          Misc.may (!check_modtype_inclusion env mty2 p2) f.fcomp_arg;
          (Papply(p1, p2), !components_of_functor_appl' f p1 p2)
      | Structure_comps c ->
          raise Not_found
      end

and lookup_module ~load lid env : Path.t =
  match lid with
    Lident s ->
      begin try
        let (p, {md_type}) as r = EnvTbl.find_name s env.modules in
        begin match md_type with
        | Mty_ident (Path.Pident id) when Ident.name id = "#recmod#" ->
          (* see #5965 *)
          raise Recmodule
        | _ -> ()
        end;
        p
      with Not_found ->
        if s = !current_unit then raise Not_found;
        if !Clflags.transparent_modules && not load then
          try ignore (find_pers_struct ~check:false s)
          with Not_found ->
	    Location.prerr_warning Location.none (Warnings.No_cmi_file s)
        else ignore (find_pers_struct s);
        Pident(Ident.create_persistent s)
      end
  | Ldot(l, s) ->
      let (p, descr) = lookup_module_descr l env in
      begin match EnvLazy.force !components_of_module_maker' descr with
        Structure_comps c ->
          let (data, pos) = Tbl.find s c.comp_modules in
          Pdot(p, s, pos)
      | Functor_comps f ->
          raise Not_found
      end
  | Lapply(l1, l2) ->
      let (p1, desc1) = lookup_module_descr l1 env in
      let p2 = lookup_module true l2 env in
      let {md_type=mty2} = find_module p2 env in
      let p = Papply(p1, p2) in
      begin match EnvLazy.force !components_of_module_maker' desc1 with
        Functor_comps f ->
          Misc.may (!check_modtype_inclusion env mty2 p2) f.fcomp_arg;
          p
      | Structure_comps c ->
          raise Not_found
      end

let lookup proj1 proj2 lid env =
  match lid with
    Lident s ->
      EnvTbl.find_name s (proj1 env)
  | Ldot(l, s) ->
      let (p, desc) = lookup_module_descr l env in
      begin match EnvLazy.force !components_of_module_maker' desc with
        Structure_comps c ->
          let (data, pos) = Tbl.find s (proj2 c) in
          (Pdot(p, s, pos), data)
      | Functor_comps f ->
          raise Not_found
      end
  | Lapply(l1, l2) ->
      raise Not_found

let lookup_simple proj1 proj2 lid env =
  match lid with
    Lident s ->
      EnvTbl.find_name s (proj1 env)
  | Ldot(l, s) ->
      let (p, desc) = lookup_module_descr l env in
      begin match EnvLazy.force !components_of_module_maker' desc with
        Structure_comps c ->
          let (data, pos) = Tbl.find s (proj2 c) in
          data
      | Functor_comps f ->
          raise Not_found
      end
  | Lapply(l1, l2) ->
      raise Not_found

let lookup_all_simple proj1 proj2 shadow lid env =
  match lid with
    Lident s ->
      let xl = EnvTbl.find_all s (proj1 env) in
      let rec do_shadow =
        function
        | [] -> []
        | ((x, f) :: xs) ->
            (x, f) ::
              (do_shadow (List.filter (fun (y, g) -> not (shadow x y)) xs))
      in
        do_shadow xl
  | Ldot(l, s) ->
      let (p, desc) = lookup_module_descr l env in
      begin match EnvLazy.force !components_of_module_maker' desc with
        Structure_comps c ->
          let comps =
            try Tbl.find s (proj2 c) with Not_found -> []
          in
          List.map
            (fun (data, pos) -> (data, (fun () -> ())))
            comps
      | Functor_comps f ->
          raise Not_found
      end
  | Lapply(l1, l2) ->
      raise Not_found

let has_local_constraints env = env.local_constraints

let cstr_shadow cstr1 cstr2 =
  match cstr1.cstr_tag, cstr2.cstr_tag with
  | Cstr_extension _, Cstr_extension _ -> true
  | _ -> false

let lbl_shadow lbl1 lbl2 = false

let lookup_value =
  lookup (fun env -> env.values) (fun sc -> sc.comp_values)
and lookup_all_constructors =
  lookup_all_simple (fun env -> env.constrs) (fun sc -> sc.comp_constrs)
    cstr_shadow
and lookup_all_labels =
  lookup_all_simple (fun env -> env.labels) (fun sc -> sc.comp_labels)
    lbl_shadow
and lookup_type =
  lookup (fun env -> env.types) (fun sc -> sc.comp_types)
and lookup_modtype =
  lookup (fun env -> env.modtypes) (fun sc -> sc.comp_modtypes)
and lookup_class =
  lookup (fun env -> env.classes) (fun sc -> sc.comp_classes)
and lookup_cltype =
  lookup (fun env -> env.cltypes) (fun sc -> sc.comp_cltypes)

let mark_value_used env name vd =
  if not (is_implicit_coercion env) then
    try Hashtbl.find value_declarations (name, vd.val_loc) ()
    with Not_found -> ()

let mark_type_used env name vd =
  if not (is_implicit_coercion env) then
    try Hashtbl.find type_declarations (name, vd.type_loc) ()
    with Not_found -> ()

let mark_constructor_used usage env name vd constr =
  if not (is_implicit_coercion env) then
    try Hashtbl.find used_constructors (name, vd.type_loc, constr) usage
    with Not_found -> ()

let mark_extension_used usage env ext name =
  if not (is_implicit_coercion env) then
    let ty_name = Path.last ext.ext_type_path in
    try Hashtbl.find used_constructors (ty_name, ext.ext_loc, name) usage
    with Not_found -> ()

let set_value_used_callback name vd callback =
  let key = (name, vd.val_loc) in
  try
    let old = Hashtbl.find value_declarations key in
    Hashtbl.replace value_declarations key (fun () -> old (); callback ())
      (* this is to support cases like:
               let x = let x = 1 in x in x
         where the two declarations have the same location
         (e.g. resulting from Camlp4 expansion of grammar entries) *)
  with Not_found ->
    Hashtbl.add value_declarations key callback

let set_type_used_callback name td callback =
  let loc = td.type_loc in
  if loc.Location.loc_ghost then ()
  else let key = (name, loc) in
  let old =
    try Hashtbl.find type_declarations key
    with Not_found -> assert false
  in
  Hashtbl.replace type_declarations key (fun () -> callback old)

let lookup_value lid env =
  let (_, desc) as r = lookup_value lid env in
  mark_value_used env (Longident.last lid) desc;
  r

let lookup_type lid env =
  let (path, (decl, _)) = lookup_type lid env in
  mark_type_used env (Longident.last lid) decl;
  (path, decl)

(* [path] must be the path to a type, not to a module ! *)
let path_subst_last path id =
  match path with
    Pident _ -> Pident id
  | Pdot (p, name, pos) -> Pdot(p, Ident.name id, pos)
  | Papply (p1, p2) -> assert false

let mark_type_path env path =
  try
    let decl = find_type path env in
    mark_type_used env (Path.last path) decl
  with Not_found -> ()

let ty_path t =
  match repr t with
  | {desc=Tconstr(path, _, _)} -> path
  | _ -> assert false

let lookup_constructor lid env =
  match lookup_all_constructors lid env with
    [] -> raise Not_found
  | (desc, use) :: _ ->
      mark_type_path env (ty_path desc.cstr_res);
      use ();
      desc

let is_lident = function
    Lident _ -> true
  | _ -> false

let lookup_all_constructors lid env =
  try
    let cstrs = lookup_all_constructors lid env in
    let wrap_use desc use () =
      mark_type_path env (ty_path desc.cstr_res);
      use ()
    in
    List.map (fun (cstr, use) -> (cstr, wrap_use cstr use)) cstrs
  with
    Not_found when is_lident lid -> []

let mark_constructor usage env name desc =
  if not (is_implicit_coercion env)
  then match desc.cstr_tag with
  | Cstr_extension _ ->
      begin
        let ty_path = ty_path desc.cstr_res in
        let ty_name = Path.last ty_path in
        try Hashtbl.find used_constructors (ty_name, desc.cstr_loc, name) usage
        with Not_found -> ()
      end
  | _ ->
      let ty_path = ty_path desc.cstr_res in
      let ty_decl = try find_type ty_path env with Not_found -> assert false in
      let ty_name = Path.last ty_path in
      mark_constructor_used usage env ty_name ty_decl name

let lookup_label lid env =
  match lookup_all_labels lid env with
    [] -> raise Not_found
  | (desc, use) :: _ ->
      mark_type_path env (ty_path desc.lbl_res);
      use ();
      desc

let lookup_all_labels lid env =
  try
    let lbls = lookup_all_labels lid env in
    let wrap_use desc use () =
      mark_type_path env (ty_path desc.lbl_res);
      use ()
    in
    List.map (fun (lbl, use) -> (lbl, wrap_use lbl use)) lbls
  with
    Not_found when is_lident lid -> []

let lookup_class lid env =
  let (_, desc) as r = lookup_class lid env in
  (* special support for Typeclass.unbound_class *)
  if Path.name desc.cty_path = "" then ignore (lookup_type lid env)
  else mark_type_path env desc.cty_path;
  r

let lookup_cltype lid env =
  let (_, desc) as r = lookup_cltype lid env in
  if Path.name desc.clty_path = "" then ignore (lookup_type lid env)
  else mark_type_path env desc.clty_path;
  mark_type_path env desc.clty_path;
  r

(* Iter on an environment (ignoring the body of functors and
   not yet evaluated structures) *)

type iter_cont = unit -> unit
let iter_env_cont = ref []

let rec scrape_alias_safe env mty =
  match mty with
  | Mty_alias (Pident id) when Ident.persistent id -> false
  | Mty_alias path -> (* PR#6600: find_module may raise Not_found *)
      scrape_alias_safe env (find_module path env).md_type
  | _ -> true

let iter_env proj1 proj2 f env () =
  Ident.iter (fun id (x,_) -> f (Pident id) x) (proj1 env);
  let rec iter_components path path' mcomps =
    let cont () =
      let safe =
        match EnvLazy.get_arg mcomps with
          None -> true
        | Some (env, sub, path, mty) ->
            try scrape_alias_safe env mty with Not_found -> false
      in
      if not safe then () else
      match EnvLazy.force !components_of_module_maker' mcomps with
        Structure_comps comps ->
          Tbl.iter
            (fun s (d, n) -> f (Pdot (path, s, n)) (Pdot (path', s, n), d))
            (proj2 comps);
          Tbl.iter
            (fun s (c, n) ->
              iter_components (Pdot (path, s, n)) (Pdot (path', s, n)) c)
            comps.comp_components
      | Functor_comps _ -> ()
    in iter_env_cont := (path, cont) :: !iter_env_cont
  in
  Hashtbl.iter
    (fun s pso ->
      match pso with None -> ()
      | Some ps ->
          let id = Pident (Ident.create_persistent s) in
          iter_components id id ps.ps_comps)
    persistent_structures;
  Ident.iter
    (fun id ((path, comps), _) -> iter_components (Pident id) path comps)
    env.components

let run_iter_cont l =
  iter_env_cont := [];
  List.iter (fun c -> c ()) l;
  let cont = List.rev !iter_env_cont in
  iter_env_cont := [];
  cont

let iter_types f = iter_env (fun env -> env.types) (fun sc -> sc.comp_types) f

let same_types env1 env2 =
  env1.types == env2.types && env1.components == env2.components

let used_persistent () =
  let r = ref Concr.empty in
  Hashtbl.iter (fun s pso -> if pso != None then r := Concr.add s !r)
    persistent_structures;
  !r

let find_all_comps proj s (p,mcomps) =
  match EnvLazy.force !components_of_module_maker' mcomps with
    Functor_comps _ -> []
  | Structure_comps comps ->
      try let (c,n) = Tbl.find s (proj comps) in [Pdot(p,s,n), c]
      with Not_found -> []

let rec find_shadowed_comps path env =
  match path with
    Pident id ->
      List.map fst (Ident.find_all (Ident.name id) env.components)
  | Pdot (p, s, _) ->
      let l = find_shadowed_comps p env in
      let l' =
        List.map (find_all_comps (fun comps -> comps.comp_components) s) l in
      List.flatten l'
  | Papply _ -> []

let find_shadowed proj1 proj2 path env =
  match path with
    Pident id ->
      List.map fst (Ident.find_all (Ident.name id) (proj1 env))
  | Pdot (p, s, _) ->
      let l = find_shadowed_comps p env in
      let l' = List.map (find_all_comps proj2 s) l in
      List.flatten l'
  | Papply _ -> []

let find_shadowed_types path env =
  let l =
    find_shadowed
      (fun env -> env.types) (fun comps -> comps.comp_types) path env
  in
  List.map fst l


(* GADT instance tracking *)

let add_gadt_instance_level lv env =
  {env with
   gadt_instances = (lv, ref TypeSet.empty) :: env.gadt_instances}

let is_Tlink = function {desc = Tlink _} -> true | _ -> false

let gadt_instance_level env t =
  let rec find_instance = function
      [] -> None
    | (lv, r) :: rem ->
        if TypeSet.exists is_Tlink !r then
          (* Should we use set_typeset ? *)
          r := TypeSet.fold (fun ty -> TypeSet.add (repr ty)) !r TypeSet.empty;
        if TypeSet.mem t !r then Some lv else find_instance rem
  in find_instance env.gadt_instances

let add_gadt_instances env lv tl =
  let r =
    try List.assoc lv env.gadt_instances with Not_found -> assert false in
  (* Format.eprintf "Added";
  List.iter (fun ty -> Format.eprintf "@ %a" !Btype.print_raw ty) tl;
  Format.eprintf "@."; *)
  set_typeset r (List.fold_right TypeSet.add tl !r)

(* Only use this after expand_head! *)
let add_gadt_instance_chain env lv t =
  let r =
    try List.assoc lv env.gadt_instances with Not_found -> assert false in
  let rec add_instance t =
    let t = repr t in
    if not (TypeSet.mem t !r) then begin
      (* Format.eprintf "@ %a" !Btype.print_raw t; *)
      set_typeset r (TypeSet.add t !r);
      match t.desc with
        Tconstr (p, _, memo) ->
          may add_instance (find_expans Private p !memo)
      | _ -> ()
    end
  in
  (* Format.eprintf "Added chain"; *)
  add_instance t
  (* Format.eprintf "@." *)

(* Expand manifest module type names at the top of the given module type *)

let rec scrape_alias env ?path mty =
  match mty, path with
    Mty_ident p, _ ->
      begin try
        scrape_alias env (find_modtype_expansion p env) ?path
      with Not_found ->
        mty
      end
  | Mty_alias path, _ ->
      begin try
        scrape_alias env (find_module path env).md_type ~path
      with Not_found ->
        (*Location.prerr_warning Location.none
	  (Warnings.No_cmi_file (Path.name path));*)
        mty
      end
  | mty, Some path ->
      !strengthen env mty path
  | _ -> mty

let scrape_alias env mty = scrape_alias env mty

(* Compute constructor descriptions *)

let constructors_of_type ty_path decl =
  let handle_variants cstrs =
    Datarepr.constructor_descrs
      (newgenty (Tconstr(ty_path, decl.type_params, ref Mnil)))
      cstrs decl.type_private
  in
  match decl.type_kind with
  | Type_variant cstrs -> handle_variants cstrs
  | Type_record _ | Type_abstract | Type_open -> []

(* Compute label descriptions *)

let labels_of_type ty_path decl =
  match decl.type_kind with
    Type_record(labels, rep) ->
      Datarepr.label_descrs
        (newgenty (Tconstr(ty_path, decl.type_params, ref Mnil)))
        labels rep decl.type_private
  | Type_variant _ | Type_abstract | Type_open -> []

(* Given a signature and a root path, prefix all idents in the signature
   by the root path and build the corresponding substitution. *)

let rec prefix_idents root pos sub = function
    [] -> ([], sub)
  | Sig_value(id, decl) :: rem ->
      let p = Pdot(root, Ident.name id, pos) in
      let nextpos = match decl.val_kind with Val_prim _ -> pos | _ -> pos+1 in
      let (pl, final_sub) = prefix_idents root nextpos sub rem in
      (p::pl, final_sub)
  | Sig_type(id, decl, _) :: rem ->
      let p = Pdot(root, Ident.name id, nopos) in
      let (pl, final_sub) =
        prefix_idents root pos (Subst.add_type id p sub) rem in
      (p::pl, final_sub)
  | Sig_typext(id, ext, _) :: rem ->
      let p = Pdot(root, Ident.name id, pos) in
      let (pl, final_sub) = prefix_idents root (pos+1) sub rem in
      (p::pl, final_sub)
  | Sig_module(id, mty, _) :: rem ->
      let p = Pdot(root, Ident.name id, pos) in
      let (pl, final_sub) =
        prefix_idents root (pos+1) (Subst.add_module id p sub) rem in
      (p::pl, final_sub)
  | Sig_modtype(id, decl) :: rem ->
      let p = Pdot(root, Ident.name id, nopos) in
      let (pl, final_sub) =
        prefix_idents root pos
                      (Subst.add_modtype id (Mty_ident p) sub) rem in
      (p::pl, final_sub)
  | Sig_class(id, decl, _) :: rem ->
      let p = Pdot(root, Ident.name id, pos) in
      let (pl, final_sub) = prefix_idents root (pos + 1) sub rem in
      (p::pl, final_sub)
  | Sig_class_type(id, decl, _) :: rem ->
      let p = Pdot(root, Ident.name id, nopos) in
      let (pl, final_sub) = prefix_idents root pos sub rem in
      (p::pl, final_sub)

let subst_signature sub sg =
  List.map
    (fun item ->
      match item with
      | Sig_value(id, decl) ->
          Sig_value (id, Subst.value_description sub decl)
      | Sig_type(id, decl, x) ->
          Sig_type(id, Subst.type_declaration sub decl, x)
      | Sig_typext(id, ext, es) ->
          Sig_typext (id, Subst.extension_constructor sub ext, es)
      | Sig_module(id, mty, x) ->
          Sig_module(id, Subst.module_declaration sub mty,x)
      | Sig_modtype(id, decl) ->
          Sig_modtype(id, Subst.modtype_declaration sub decl)
      | Sig_class(id, decl, x) ->
          Sig_class(id, Subst.class_declaration sub decl, x)
      | Sig_class_type(id, decl, x) ->
          Sig_class_type(id, Subst.cltype_declaration sub decl, x)
    )
    sg


let prefix_idents_and_subst root sub sg =
  let (pl, sub) = prefix_idents root 0 sub sg in
  pl, sub, lazy (subst_signature sub sg)

let prefix_idents_and_subst root sub sg =
  if sub = Subst.identity then
    let sgs =
      try
        Hashtbl.find prefixed_sg root
      with Not_found ->
        let sgs = ref [] in
        Hashtbl.add prefixed_sg root sgs;
        sgs
    in
    try
      List.assq sg !sgs
    with Not_found ->
      let r = prefix_idents_and_subst root sub sg in
      sgs := (sg, r) :: !sgs;
      r
  else
    prefix_idents_and_subst root sub sg

(* Compute structure descriptions *)

let add_to_tbl id decl tbl =
  let decls =
    try Tbl.find id tbl with Not_found -> [] in
  Tbl.add id (decl :: decls) tbl

let rec components_of_module env sub path mty =
  EnvLazy.create (env, sub, path, mty)

and components_of_module_maker (env, sub, path, mty) =
  (match scrape_alias env mty with
    Mty_signature sg ->
      let c =
        { comp_values = Tbl.empty;
          comp_constrs = Tbl.empty;
          comp_labels = Tbl.empty; comp_types = Tbl.empty;
          comp_modules = Tbl.empty; comp_modtypes = Tbl.empty;
          comp_components = Tbl.empty; comp_classes = Tbl.empty;
          comp_cltypes = Tbl.empty } in
      let pl, sub, _ = prefix_idents_and_subst path sub sg in
      let env = ref env in
      let pos = ref 0 in
      List.iter2 (fun item path ->
        match item with
          Sig_value(id, decl) ->
            let decl' = Subst.value_description sub decl in
            c.comp_values <-
              Tbl.add (Ident.name id) (decl', !pos) c.comp_values;
            begin match decl.val_kind with
              Val_prim _ -> () | _ -> incr pos
            end
        | Sig_type(id, decl, _) ->
            let decl' = Subst.type_declaration sub decl in
            let constructors = List.map snd (constructors_of_type path decl') in
            let labels = List.map snd (labels_of_type path decl') in
            c.comp_types <-
              Tbl.add (Ident.name id)
                ((decl', (constructors, labels)), nopos)
                  c.comp_types;
            List.iter
              (fun descr ->
                c.comp_constrs <-
                  add_to_tbl descr.cstr_name (descr, nopos) c.comp_constrs)
              constructors;
            List.iter
              (fun descr ->
                c.comp_labels <-
                  add_to_tbl descr.lbl_name (descr, nopos) c.comp_labels)
              labels;
            env := store_type_infos None id (Pident id) decl !env !env
        | Sig_typext(id, ext, _) ->
            let ext' = Subst.extension_constructor sub ext in
            let descr = Datarepr.extension_descr path ext' in
            c.comp_constrs <-
              add_to_tbl (Ident.name id) (descr, !pos) c.comp_constrs;
            incr pos
        | Sig_module(id, md, _) ->
            let mty = md.md_type in
            let mty' = EnvLazy.create (sub, mty) in
            c.comp_modules <-
              Tbl.add (Ident.name id) (mty', !pos) c.comp_modules;
            let comps = components_of_module !env sub path mty in
            c.comp_components <-
              Tbl.add (Ident.name id) (comps, !pos) c.comp_components;
            env := store_module None id (Pident id) md !env !env;
            incr pos
        | Sig_modtype(id, decl) ->
            let decl' = Subst.modtype_declaration sub decl in
            c.comp_modtypes <-
              Tbl.add (Ident.name id) (decl', nopos) c.comp_modtypes;
            env := store_modtype None id (Pident id) decl !env !env
        | Sig_class(id, decl, _) ->
            let decl' = Subst.class_declaration sub decl in
            c.comp_classes <-
              Tbl.add (Ident.name id) (decl', !pos) c.comp_classes;
            incr pos
        | Sig_class_type(id, decl, _) ->
            let decl' = Subst.cltype_declaration sub decl in
            c.comp_cltypes <-
              Tbl.add (Ident.name id) (decl', !pos) c.comp_cltypes)
        sg pl;
        Structure_comps c
  | Mty_functor(param, ty_arg, ty_res) ->
        Functor_comps {
          fcomp_param = param;
          (* fcomp_arg must be prefixed eagerly, because it is interpreted
             in the outer environment, not in env *)
          fcomp_arg = may_map (Subst.modtype sub) ty_arg;
          (* fcomp_res is prefixed lazily, because it is interpreted in env *)
          fcomp_res = ty_res;
          fcomp_env = env;
          fcomp_subst = sub;
          fcomp_cache = Hashtbl.create 17;
          fcomp_subst_cache = Hashtbl.create 17 }
  | Mty_ident _
  | Mty_alias _ ->
        Structure_comps {
          comp_values = Tbl.empty;
          comp_constrs = Tbl.empty;
          comp_labels = Tbl.empty;
          comp_types = Tbl.empty;
          comp_modules = Tbl.empty; comp_modtypes = Tbl.empty;
          comp_components = Tbl.empty; comp_classes = Tbl.empty;
          comp_cltypes = Tbl.empty })

(* Insertion of bindings by identifier + path *)

and check_usage loc id warn tbl =
  if not loc.Location.loc_ghost && Warnings.is_active (warn "") then begin
    let name = Ident.name id in
    let key = (name, loc) in
    if Hashtbl.mem tbl key then ()
    else let used = ref false in
    Hashtbl.add tbl key (fun () -> used := true);
    if not (name = "" || name.[0] = '_' || name.[0] = '#')
    then
      !add_delayed_check_forward
        (fun () -> if not !used then Location.prerr_warning loc (warn name))
  end;

and check_value_name name loc =
  (* Note: we could also check here general validity of the
     identifier, to protect against bad identifiers forged by -pp or
     -ppx preprocessors. *)

  if String.length name > 0 && (name.[0] = '#') then
    for i = 1 to String.length name - 1 do
      if name.[i] = '#' then
        raise (Error(Illegal_value_name(loc, name)))
    done


and store_value ?check slot id path decl env renv =
  check_value_name (Ident.name id) decl.val_loc;
  may (fun f -> check_usage decl.val_loc id f value_declarations) check;
  { env with
    values = EnvTbl.add "value" slot id (path, decl) env.values renv.values;
    summary = Env_value(env.summary, id, decl) }

and store_type ~check slot id path info env renv =
  let loc = info.type_loc in
  if check then
    check_usage loc id (fun s -> Warnings.Unused_type_declaration s)
      type_declarations;
  let constructors = constructors_of_type path info in
  let labels = labels_of_type path info in
  let descrs = (List.map snd constructors, List.map snd labels) in

  if check && not loc.Location.loc_ghost &&
    Warnings.is_active (Warnings.Unused_constructor ("", false, false))
  then begin
    let ty = Ident.name id in
    List.iter
      begin fun (_, {cstr_name = c; _}) ->
        let k = (ty, loc, c) in
        if not (Hashtbl.mem used_constructors k) then
          let used = constructor_usages () in
          Hashtbl.add used_constructors k (add_constructor_usage used);
          if not (ty = "" || ty.[0] = '_')
          then !add_delayed_check_forward
              (fun () ->
                if not (is_in_signature env) && not used.cu_positive then
                  Location.prerr_warning loc
                    (Warnings.Unused_constructor
                       (c, used.cu_pattern, used.cu_privatize)))
      end
      constructors
  end;
  { env with
    constrs =
      List.fold_right
        (fun (id, descr) constrs ->
          EnvTbl.add "constructor" slot id descr constrs renv.constrs)
        constructors
        env.constrs;
    labels =
      List.fold_right
        (fun (id, descr) labels ->
          EnvTbl.add "label" slot id descr labels renv.labels)
        labels
        env.labels;
    types = EnvTbl.add "type" slot id (path, (info, descrs)) env.types
                       renv.types;
    summary = Env_type(env.summary, id, info) }

and store_type_infos slot id path info env renv =
  (* Simplified version of store_type that doesn't compute and store
     constructor and label infos, but simply record the arity and
     manifest-ness of the type.  Used in components_of_module to
     keep track of type abbreviations (e.g. type t = float) in the
     computation of label representations. *)
  { env with
    types = EnvTbl.add "type" slot id (path, (info,([],[]))) env.types
                       renv.types;
    summary = Env_type(env.summary, id, info) }

and store_extension ~check slot id path ext env renv =
  let loc = ext.ext_loc in
  if check && not loc.Location.loc_ghost &&
    Warnings.is_active (Warnings.Unused_extension ("", false, false))
  then begin
    let ty = Path.last ext.ext_type_path in
    let n = Ident.name id in
    let k = (ty, loc, n) in
    if not (Hashtbl.mem used_constructors k) then begin
      let used = constructor_usages () in
      Hashtbl.add used_constructors k (add_constructor_usage used);
      !add_delayed_check_forward
        (fun () ->
          if not (is_in_signature env) && not used.cu_positive then
            Location.prerr_warning loc
              (Warnings.Unused_extension
                 (n, used.cu_pattern, used.cu_privatize)
              )
        )
    end;
  end;
  { env with
    constrs = EnvTbl.add "constructor" slot id
                (Datarepr.extension_descr path ext)
                env.constrs renv.constrs;
    summary = Env_extension(env.summary, id, ext) }

and store_module slot id path md env renv =
  { env with
    modules = EnvTbl.add "module" slot id (path, md) env.modules renv.modules;
    components =
      EnvTbl.add "module" slot id
                 (path, components_of_module env Subst.identity path md.md_type)
                   env.components renv.components;
    summary = Env_module(env.summary, id, md) }

and store_modtype slot id path info env renv =
  { env with
    modtypes = EnvTbl.add "module type" slot id (path, info) env.modtypes
                          renv.modtypes;
    summary = Env_modtype(env.summary, id, info) }

and store_class slot id path desc env renv =
  { env with
    classes = EnvTbl.add "class" slot id (path, desc) env.classes renv.classes;
    summary = Env_class(env.summary, id, desc) }

and store_cltype slot id path desc env renv =
  { env with
    cltypes = EnvTbl.add "class type" slot id (path, desc) env.cltypes
                         renv.cltypes;
    summary = Env_cltype(env.summary, id, desc) }

(* Compute the components of a functor application in a path. *)

let components_of_functor_appl f p1 p2 =
  try
    Hashtbl.find f.fcomp_cache p2
  with Not_found ->
    let p = Papply(p1, p2) in
    let mty =
      Subst.modtype (Subst.add_module f.fcomp_param p2 Subst.identity)
                    f.fcomp_res in
    let comps = components_of_module f.fcomp_env f.fcomp_subst p mty in
    Hashtbl.add f.fcomp_cache p2 comps;
    comps

(* Define forward functions *)

let _ =
  components_of_module' := components_of_module;
  components_of_functor_appl' := components_of_functor_appl;
  components_of_module_maker' := components_of_module_maker

(* Insertion of bindings by identifier *)

let add_functor_arg ?(arg=false) id env =
  if not arg then env else
  {env with
   functor_args = Ident.add id () env.functor_args;
   summary = Env_functor_arg (env.summary, id)}

let add_value ?check id desc env =
  store_value None ?check id (Pident id) desc env env

let add_type ~check id info env =
  store_type ~check None id (Pident id) info env env

and add_extension ~check id ext env =
  store_extension ~check None id (Pident id) ext env env

and add_module_declaration ?arg id md env =
  let path =
    (*match md.md_type with
      Mty_alias path -> normalize_path env path
    | _ ->*) Pident id
  in
  let env = store_module None id path md env env in
  add_functor_arg ?arg id env

and add_modtype id info env =
  store_modtype None id (Pident id) info env env

and add_class id ty env =
  store_class None id (Pident id) ty env env

and add_cltype id ty env =
  store_cltype None id (Pident id) ty env env

let add_module ?arg id mty env =
  add_module_declaration ?arg id (md mty) env

let add_local_constraint id info elv env =
  match info with
    {type_manifest = Some ty; type_newtype_level = Some (lv, _)} ->
      (* elv is the expansion level, lv is the definition level *)
      let env =
        add_type ~check:false
          id {info with type_newtype_level = Some (lv, elv)} env in
      { env with local_constraints = true }
  | _ -> assert false

(* Insertion of bindings by name *)

let enter store_fun name data env =
  let id = Ident.create name in (id, store_fun None id (Pident id) data env env)

let enter_value ?check = enter (store_value ?check)
and enter_type = enter (store_type ~check:true)
and enter_extension = enter (store_extension ~check:true)
and enter_module_declaration ?arg name md env =
  let id = Ident.create name in
  (id, add_module_declaration ?arg id md env)
  (* let (id, env) = enter store_module name md env in
  (id, add_functor_arg ?arg id env) *)
and enter_modtype = enter store_modtype
and enter_class = enter store_class
and enter_cltype = enter store_cltype

let enter_module ?arg s mty env =
  enter_module_declaration ?arg s (md mty) env

(* Insertion of all components of a signature *)

let add_item comp env =
  match comp with
    Sig_value(id, decl)     -> add_value id decl env
  | Sig_type(id, decl, _)   -> add_type ~check:false id decl env
  | Sig_typext(id, ext, _)  -> add_extension ~check:false id ext env
  | Sig_module(id, md, _)  -> add_module_declaration id md env
  | Sig_modtype(id, decl)   -> add_modtype id decl env
  | Sig_class(id, decl, _)  -> add_class id decl env
  | Sig_class_type(id, decl, _) -> add_cltype id decl env

let rec add_signature sg env =
  match sg with
    [] -> env
  | comp :: rem -> add_signature rem (add_item comp env)

(* Open a signature path *)

let open_signature slot root sg env0 =
  (* First build the paths and substitution *)
  let (pl, sub, sg) = prefix_idents_and_subst root Subst.identity sg in
  let sg = Lazy.force sg in

  (* Then enter the components in the environment after substitution *)

  let newenv =
    List.fold_left2
      (fun env item p ->
        match item with
          Sig_value(id, decl) ->
            store_value slot (Ident.hide id) p decl env env0
        | Sig_type(id, decl, _) ->
            store_type ~check:false slot (Ident.hide id) p decl env env0
        | Sig_typext(id, ext, _) ->
            store_extension ~check:false slot (Ident.hide id) p ext env env0
        | Sig_module(id, mty, _) ->
            store_module slot (Ident.hide id) p mty env env0
        | Sig_modtype(id, decl) ->
            store_modtype slot (Ident.hide id) p decl env env0
        | Sig_class(id, decl, _) ->
            store_class slot (Ident.hide id) p decl env env0
        | Sig_class_type(id, decl, _) ->
            store_cltype slot (Ident.hide id) p decl env env0
      )
      env0 sg pl in
  { newenv with summary = Env_open(env0.summary, root) }

(* Open a signature from a file *)

let open_pers_signature name env =
  let ps = find_pers_struct name in
  open_signature None (Pident(Ident.create_persistent name)) ps.ps_sig env

let open_signature ?(loc = Location.none) ?(toplevel = false) ovf root sg env =
  if not toplevel && ovf = Asttypes.Fresh && not loc.Location.loc_ghost
     && (Warnings.is_active (Warnings.Unused_open "")
         || Warnings.is_active (Warnings.Open_shadow_identifier ("", ""))
         || Warnings.is_active (Warnings.Open_shadow_label_constructor ("","")))
  then begin
    let used = ref false in
    !add_delayed_check_forward
      (fun () ->
        if not !used then
          Location.prerr_warning loc (Warnings.Unused_open (Path.name root))
      );
    let shadowed = ref [] in
    let slot kind s b =
      if b && not (List.mem (kind, s) !shadowed) then begin
        shadowed := (kind, s) :: !shadowed;
        let w =
          match kind with
          | "label" | "constructor" ->
              Warnings.Open_shadow_label_constructor (kind, s)
          | _ -> Warnings.Open_shadow_identifier (kind, s)
        in
        Location.prerr_warning loc w
      end;
      used := true
    in
    open_signature (Some slot) root sg env
  end
  else open_signature None root sg env

(* Read a signature from a file *)

let read_signature modname filename =
  let ps = read_pers_struct modname filename in
  check_consistency ps;
  ps.ps_sig

(* Return the CRC of the interface of the given compilation unit *)

let crc_of_unit name =
  let ps = find_pers_struct name in
  let crco =
    try
      List.assoc name ps.ps_crcs
    with Not_found ->
      assert false
  in
    match crco with
      None -> assert false
    | Some crc -> crc

(* Return the list of imported interfaces with their CRCs *)

let imports() =
  Consistbl.extract (StringSet.elements !imported_units) crc_units

(* Save a signature to a file *)

let save_signature_with_imports sg modname filename imports =
  (*prerr_endline filename;
  List.iter (fun (name, crc) -> prerr_endline name) imports;*)
  Btype.cleanup_abbrev ();
  Subst.reset_for_saving ();
  let sg = Subst.signature (Subst.for_saving Subst.identity) sg in
  let oc = open_out_bin filename in
  try
    let cmi = {
      cmi_name = modname;
      cmi_sign = sg;
      cmi_crcs = imports;
      cmi_flags = if !Clflags.recursive_types then [Rectypes] else [];
    } in
    let crc = output_cmi filename oc cmi in
    close_out oc;
    (* Enter signature in persistent table so that imported_unit()
       will also return its crc *)
    let comps =
      components_of_module empty Subst.identity
        (Pident(Ident.create_persistent modname)) (Mty_signature sg) in
    let ps =
      { ps_name = modname;
        ps_sig = sg;
        ps_comps = comps;
        ps_crcs = (cmi.cmi_name, Some crc) :: imports;
        ps_filename = filename;
        ps_flags = cmi.cmi_flags;
        ps_crcs_checked = false;
      } in
    save_pers_struct crc ps;
    sg
  with exn ->
    close_out oc;
    remove_file filename;
    raise exn

let save_signature sg modname filename =
  save_signature_with_imports sg modname filename (imports())

(* Folding on environments *)

let find_all proj1 proj2 f lid env acc =
  match lid with
    | None ->
      EnvTbl.fold_name
        (fun id (p, data) acc -> f (Ident.name id) p data acc)
        (proj1 env) acc
    | Some l ->
      let p, desc = lookup_module_descr l env in
      begin match EnvLazy.force components_of_module_maker desc with
          Structure_comps c ->
            Tbl.fold
              (fun s (data, pos) acc -> f s (Pdot (p, s, pos)) data acc)
              (proj2 c) acc
        | Functor_comps _ ->
            acc
      end

let find_all_simple_list proj1 proj2 f lid env acc =
  match lid with
    | None ->
      EnvTbl.fold_name
        (fun id data acc -> f data acc)
        (proj1 env) acc
    | Some l ->
      let p, desc = lookup_module_descr l env in
      begin match EnvLazy.force components_of_module_maker desc with
          Structure_comps c ->
            Tbl.fold
              (fun s comps acc ->
                match comps with
                  [] -> acc
                | (data, pos) :: _ ->
                  f data acc)
              (proj2 c) acc
        | Functor_comps _ ->
            acc
      end

let fold_modules f lid env acc =
  match lid with
    | None ->
      let acc =
        EnvTbl.fold_name
          (fun id (p, data) acc -> f (Ident.name id) p data acc)
          env.modules
          acc
      in
      Hashtbl.fold
        (fun name ps acc ->
          match ps with
              None -> acc
            | Some ps ->
              f name (Pident(Ident.create_persistent name))
                     (md (Mty_signature ps.ps_sig)) acc)
        persistent_structures
        acc
    | Some l ->
      let p, desc = lookup_module_descr l env in
      begin match EnvLazy.force components_of_module_maker desc with
          Structure_comps c ->
            Tbl.fold
              (fun s (data, pos) acc ->
                f s (Pdot (p, s, pos))
                    (md (EnvLazy.force subst_modtype_maker data)) acc)
              c.comp_modules
              acc
        | Functor_comps _ ->
            acc
      end

let fold_values f =
  find_all (fun env -> env.values) (fun sc -> sc.comp_values) f
and fold_constructors f =
  find_all_simple_list (fun env -> env.constrs) (fun sc -> sc.comp_constrs) f
and fold_labels f =
  find_all_simple_list (fun env -> env.labels) (fun sc -> sc.comp_labels) f
and fold_types f =
  find_all (fun env -> env.types) (fun sc -> sc.comp_types) f
and fold_modtypes f =
  find_all (fun env -> env.modtypes) (fun sc -> sc.comp_modtypes) f
and fold_classs f =
  find_all (fun env -> env.classes) (fun sc -> sc.comp_classes) f
and fold_cltypes f =
  find_all (fun env -> env.cltypes) (fun sc -> sc.comp_cltypes) f


(* Make the initial environment *)
let (initial_safe_string, initial_unsafe_string) =
  Predef.build_initial_env
    (add_type ~check:false)
    (add_extension ~check:false)
    empty

(* Return the environment summary *)

let summary env = env.summary

let last_env = ref empty
let last_reduced_env = ref empty

let keep_only_summary env =
  if !last_env == env then !last_reduced_env
  else begin
    let new_env =
      {
       empty with
       summary = env.summary;
       local_constraints = env.local_constraints;
       flags = env.flags;
      }
    in
    last_env := env;
    last_reduced_env := new_env;
    new_env
  end


let env_of_only_summary env_from_summary env =
  let new_env = env_from_summary env.summary Subst.identity in
  { new_env with
    local_constraints = env.local_constraints;
    flags = env.flags;
  }

(* Error report *)

open Format

let report_error ppf = function
  | Illegal_renaming(name, modname, filename) -> fprintf ppf
      "Wrong file naming: %a@ contains the compiled interface for @ \
       %s when %s was expected"
      Location.print_filename filename name modname
  | Inconsistent_import(name, source1, source2) -> fprintf ppf
      "@[<hov>The files %a@ and %a@ \
              make inconsistent assumptions@ over interface %s@]"
      Location.print_filename source1 Location.print_filename source2 name
  | Need_recursive_types(import, export) ->
      fprintf ppf
        "@[<hov>Unit %s imports from %s, which uses recursive types.@ %s@]"
        export import "The compilation flag -rectypes is required"
  | Missing_module(_, path1, path2) ->
      fprintf ppf "@[@[<hov>";
      if Path.same path1 path2 then
        fprintf ppf "Internal path@ %s@ is dangling." (Path.name path1)
      else
        fprintf ppf "Internal path@ %s@ expands to@ %s@ which is dangling."
          (Path.name path1) (Path.name path2);
      fprintf ppf "@]@ @[%s@ %s@ %s.@]@]"
        "The compiled interface for module" (Ident.name (Path.head path2))
        "was not found"
  | Illegal_value_name(_loc, name) ->
      fprintf ppf "'%s' is not a valid value identifier."
        name

let () =
  Location.register_error_of_exn
    (function
      | Error (Missing_module (loc, _, _)
              | Illegal_value_name (loc, _)
               as err) when loc <> Location.none ->
          Some (Location.error_of_printer loc report_error err)
      | Error err -> Some (Location.error_of_printer_file report_error err)
      | _ -> None
    )

end
(** Interface as module  *)
module Annot
= struct
#1 "annot.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*          Damien Doligez, projet Gallium, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 2007 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Data types for annotations (Stypes.ml) *)

type call = Tail | Stack | Inline;;

type ident =
  | Iref_internal of Location.t (* defining occurrence *)
  | Iref_external
  | Idef of Location.t          (* scope *)
;;

end
module Typedtree : sig 
#1 "typedtree.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Abstract syntax tree after typing *)

open Asttypes
open Types

(* Value expressions for the core language *)

type partial = Partial | Total
type optional = Required | Optional

type attribute = Parsetree.attribute
type attributes = attribute list

type pattern =
  { pat_desc: pattern_desc;
    pat_loc: Location.t;
    pat_extra : (pat_extra * Location.t * attributes) list;
    pat_type: type_expr;
    mutable pat_env: Env.t;
    pat_attributes: attributes;
   }

and pat_extra =
  | Tpat_constraint of core_type
  | Tpat_type of Path.t * Longident.t loc
  | Tpat_unpack

and pattern_desc =
    Tpat_any
  | Tpat_var of Ident.t * string loc
  | Tpat_alias of pattern * Ident.t * string loc
  | Tpat_constant of constant
  | Tpat_tuple of pattern list
  | Tpat_construct of
      Longident.t loc * constructor_description * pattern list
  | Tpat_variant of label * pattern option * row_desc ref
  | Tpat_record of
      (Longident.t loc * label_description * pattern) list *
        closed_flag
  | Tpat_array of pattern list
  | Tpat_or of pattern * pattern * row_desc option
  | Tpat_lazy of pattern

and expression =
  { exp_desc: expression_desc;
    exp_loc: Location.t;
    exp_extra: (exp_extra * Location.t * attributes) list;
    exp_type: type_expr;
    exp_env: Env.t;
    exp_attributes: attributes;
   }

and exp_extra =
  | Texp_constraint of core_type
  | Texp_coerce of core_type option * core_type
  | Texp_open of override_flag * Path.t * Longident.t loc * Env.t
  | Texp_poly of core_type option
  | Texp_newtype of string

and expression_desc =
    Texp_ident of Path.t * Longident.t loc * Types.value_description
  | Texp_constant of constant
  | Texp_let of rec_flag * value_binding list * expression
  | Texp_function of label * case list * partial
  | Texp_apply of expression * (label * expression option * optional) list
  | Texp_match of expression * case list * case list * partial
  | Texp_try of expression * case list
  | Texp_tuple of expression list
  | Texp_construct of
      Longident.t loc * constructor_description * expression list
  | Texp_variant of label * expression option
  | Texp_record of
      (Longident.t loc * label_description * expression) list *
        expression option
  | Texp_field of expression * Longident.t loc * label_description
  | Texp_setfield of
      expression * Longident.t loc * label_description * expression
  | Texp_array of expression list
  | Texp_ifthenelse of expression * expression * expression option
  | Texp_sequence of expression * expression
  | Texp_while of expression * expression
  | Texp_for of
      Ident.t * Parsetree.pattern * expression * expression * direction_flag *
        expression
  | Texp_send of expression * meth * expression option
  | Texp_new of Path.t * Longident.t loc * Types.class_declaration
  | Texp_instvar of Path.t * Path.t * string loc
  | Texp_setinstvar of Path.t * Path.t * string loc * expression
  | Texp_override of Path.t * (Path.t * string loc * expression) list
  | Texp_letmodule of Ident.t * string loc * module_expr * expression
  | Texp_assert of expression
  | Texp_lazy of expression
  | Texp_object of class_structure * string list
  | Texp_pack of module_expr

and meth =
    Tmeth_name of string
  | Tmeth_val of Ident.t

and case =
    {
     c_lhs: pattern;
     c_guard: expression option;
     c_rhs: expression;
    }

(* Value expressions for the class language *)

and class_expr =
    {
     cl_desc: class_expr_desc;
     cl_loc: Location.t;
     cl_type: Types.class_type;
     cl_env: Env.t;
     cl_attributes: attributes;
    }

and class_expr_desc =
    Tcl_ident of Path.t * Longident.t loc * core_type list
  | Tcl_structure of class_structure
  | Tcl_fun of
      label * pattern * (Ident.t * string loc * expression) list * class_expr *
        partial
  | Tcl_apply of class_expr * (label * expression option * optional) list
  | Tcl_let of rec_flag * value_binding list *
                  (Ident.t * string loc * expression) list * class_expr
  | Tcl_constraint of
      class_expr * class_type option * string list * string list * Concr.t
    (* Visible instance variables, methods and concretes methods *)

and class_structure =
  {
   cstr_self: pattern;
   cstr_fields: class_field list;
   cstr_type: Types.class_signature;
   cstr_meths: Ident.t Meths.t;
  }

and class_field =
   {
    cf_desc: class_field_desc;
    cf_loc: Location.t;
    cf_attributes: attributes;
  }

and class_field_kind =
  | Tcfk_virtual of core_type
  | Tcfk_concrete of override_flag * expression

and class_field_desc =
    Tcf_inherit of
      override_flag * class_expr * string option * (string * Ident.t) list *
        (string * Ident.t) list
    (* Inherited instance variables and concrete methods *)
  | Tcf_val of string loc * mutable_flag * Ident.t * class_field_kind * bool
  | Tcf_method of string loc * private_flag * class_field_kind
  | Tcf_constraint of core_type * core_type
  | Tcf_initializer of expression
  | Tcf_attribute of attribute

(* Value expressions for the module language *)

and module_expr =
  { mod_desc: module_expr_desc;
    mod_loc: Location.t;
    mod_type: Types.module_type;
    mod_env: Env.t;
    mod_attributes: attributes;
   }

and module_type_constraint =
  Tmodtype_implicit
| Tmodtype_explicit of module_type

and module_expr_desc =
    Tmod_ident of Path.t * Longident.t loc
  | Tmod_structure of structure
  | Tmod_functor of Ident.t * string loc * module_type option * module_expr
  | Tmod_apply of module_expr * module_expr * module_coercion
  | Tmod_constraint of
      module_expr * Types.module_type * module_type_constraint * module_coercion
  | Tmod_unpack of expression * Types.module_type

and structure = {
  str_items : structure_item list;
  str_type : Types.signature;
  str_final_env : Env.t;
}

and structure_item =
  { str_desc : structure_item_desc;
    str_loc : Location.t;
    str_env : Env.t
  }

and structure_item_desc =
    Tstr_eval of expression * attributes
  | Tstr_value of rec_flag * value_binding list
  | Tstr_primitive of value_description
  | Tstr_type of type_declaration list
  | Tstr_typext of type_extension
  | Tstr_exception of extension_constructor
  | Tstr_module of module_binding
  | Tstr_recmodule of module_binding list
  | Tstr_modtype of module_type_declaration
  | Tstr_open of open_description
  | Tstr_class of (class_declaration * string list * virtual_flag) list
  | Tstr_class_type of (Ident.t * string loc * class_type_declaration) list
  | Tstr_include of include_declaration
  | Tstr_attribute of attribute

and module_binding =
    {
     mb_id: Ident.t;
     mb_name: string loc;
     mb_expr: module_expr;
     mb_attributes: attributes;
     mb_loc: Location.t;
    }

and value_binding =
  {
    vb_pat: pattern;
    vb_expr: expression;
    vb_attributes: attributes;
    vb_loc: Location.t;
  }

and module_coercion =
    Tcoerce_none
  | Tcoerce_structure of (int * module_coercion) list *
                         (Ident.t * int * module_coercion) list
  | Tcoerce_functor of module_coercion * module_coercion
  | Tcoerce_primitive of Ident.t * Primitive.description
  | Tcoerce_alias of Path.t * module_coercion

and module_type =
  { mty_desc: module_type_desc;
    mty_type : Types.module_type;
    mty_env : Env.t;
    mty_loc: Location.t;
    mty_attributes: attributes;
   }

and module_type_desc =
    Tmty_ident of Path.t * Longident.t loc
  | Tmty_signature of signature
  | Tmty_functor of Ident.t * string loc * module_type option * module_type
  | Tmty_with of module_type * (Path.t * Longident.t loc * with_constraint) list
  | Tmty_typeof of module_expr
  | Tmty_alias of Path.t * Longident.t loc

and signature = {
  sig_items : signature_item list;
  sig_type : Types.signature;
  sig_final_env : Env.t;
}

and signature_item =
  { sig_desc: signature_item_desc;
    sig_env : Env.t; (* BINANNOT ADDED *)
    sig_loc: Location.t }

and signature_item_desc =
    Tsig_value of value_description
  | Tsig_type of type_declaration list
  | Tsig_typext of type_extension
  | Tsig_exception of extension_constructor
  | Tsig_module of module_declaration
  | Tsig_recmodule of module_declaration list
  | Tsig_modtype of module_type_declaration
  | Tsig_open of open_description
  | Tsig_include of include_description
  | Tsig_class of class_description list
  | Tsig_class_type of class_type_declaration list
  | Tsig_attribute of attribute

and module_declaration =
    {
     md_id: Ident.t;
     md_name: string loc;
     md_type: module_type;
     md_attributes: attributes;
     md_loc: Location.t;
    }

and module_type_declaration =
    {
     mtd_id: Ident.t;
     mtd_name: string loc;
     mtd_type: module_type option;
     mtd_attributes: attributes;
     mtd_loc: Location.t;
    }

and open_description =
    {
     open_path: Path.t;
     open_txt: Longident.t loc;
     open_override: override_flag;
     open_loc: Location.t;
     open_attributes: attribute list;
    }

and 'a include_infos =
    {
     incl_mod: 'a;
     incl_type: Types.signature;
     incl_loc: Location.t;
     incl_attributes: attribute list;
    }

and include_description = module_type include_infos

and include_declaration = module_expr include_infos

and with_constraint =
    Twith_type of type_declaration
  | Twith_module of Path.t * Longident.t loc
  | Twith_typesubst of type_declaration
  | Twith_modsubst of Path.t * Longident.t loc

and core_type =
(* mutable because of [Typeclass.declare_method] *)
  { mutable ctyp_desc : core_type_desc;
    mutable ctyp_type : type_expr;
    ctyp_env : Env.t; (* BINANNOT ADDED *)
    ctyp_loc : Location.t;
    ctyp_attributes: attributes;
   }

and core_type_desc =
    Ttyp_any
  | Ttyp_var of string
  | Ttyp_arrow of label * core_type * core_type
  | Ttyp_tuple of core_type list
  | Ttyp_constr of Path.t * Longident.t loc * core_type list
  | Ttyp_object of (string * attributes * core_type) list * closed_flag
  | Ttyp_class of Path.t * Longident.t loc * core_type list
  | Ttyp_alias of core_type * string
  | Ttyp_variant of row_field list * closed_flag * label list option
  | Ttyp_poly of string list * core_type
  | Ttyp_package of package_type

and package_type = {
  pack_path : Path.t;
  pack_fields : (Longident.t loc * core_type) list;
  pack_type : Types.module_type;
  pack_txt : Longident.t loc;
}

and row_field =
    Ttag of label * attributes * bool * core_type list
  | Tinherit of core_type

and value_description =
  { val_id: Ident.t;
    val_name: string loc;
    val_desc: core_type;
    val_val: Types.value_description;
    val_prim: string list;
    val_loc: Location.t;
    val_attributes: attributes;
    }

and type_declaration =
  {
    typ_id: Ident.t;
    typ_name: string loc;
    typ_params: (core_type * variance) list;
    typ_type: Types.type_declaration;
    typ_cstrs: (core_type * core_type * Location.t) list;
    typ_kind: type_kind;
    typ_private: private_flag;
    typ_manifest: core_type option;
    typ_loc: Location.t;
    typ_attributes: attributes;
   }

and type_kind =
    Ttype_abstract
  | Ttype_variant of constructor_declaration list
  | Ttype_record of label_declaration list
  | Ttype_open

and label_declaration =
    {
     ld_id: Ident.t;
     ld_name: string loc;
     ld_mutable: mutable_flag;
     ld_type: core_type;
     ld_loc: Location.t;
     ld_attributes: attributes;
    }

and constructor_declaration =
    {
     cd_id: Ident.t;
     cd_name: string loc;
     cd_args: core_type list;
     cd_res: core_type option;
     cd_loc: Location.t;
     cd_attributes: attributes;
    }

and type_extension =
  {
    tyext_path: Path.t;
    tyext_txt: Longident.t loc;
    tyext_params: (core_type * variance) list;
    tyext_constructors: extension_constructor list;
    tyext_private: private_flag;
    tyext_attributes: attributes;
  }

and extension_constructor =
  {
    ext_id: Ident.t;
    ext_name: string loc;
    ext_type : Types.extension_constructor;
    ext_kind : extension_constructor_kind;
    ext_loc : Location.t;
    ext_attributes: attributes;
  }

and extension_constructor_kind =
    Text_decl of core_type list * core_type option
  | Text_rebind of Path.t * Longident.t loc

and class_type =
    {
     cltyp_desc: class_type_desc;
     cltyp_type: Types.class_type;
     cltyp_env: Env.t;
     cltyp_loc: Location.t;
     cltyp_attributes: attributes;
    }

and class_type_desc =
    Tcty_constr of Path.t * Longident.t loc * core_type list
  | Tcty_signature of class_signature
  | Tcty_arrow of label * core_type * class_type

and class_signature = {
    csig_self : core_type;
    csig_fields : class_type_field list;
    csig_type : Types.class_signature;
  }

and class_type_field = {
    ctf_desc: class_type_field_desc;
    ctf_loc: Location.t;
    ctf_attributes: attributes;
  }

and class_type_field_desc =
  | Tctf_inherit of class_type
  | Tctf_val of (string * mutable_flag * virtual_flag * core_type)
  | Tctf_method of (string * private_flag * virtual_flag * core_type)
  | Tctf_constraint of (core_type * core_type)
  | Tctf_attribute of attribute

and class_declaration =
  class_expr class_infos

and class_description =
  class_type class_infos

and class_type_declaration =
  class_type class_infos

and 'a class_infos =
  { ci_virt: virtual_flag;
    ci_params: (core_type * variance) list;
    ci_id_name : string loc;
    ci_id_class: Ident.t;
    ci_id_class_type : Ident.t;
    ci_id_object : Ident.t;
    ci_id_typesharp : Ident.t;
    ci_expr: 'a;
    ci_decl: Types.class_declaration;
    ci_type_decl : Types.class_type_declaration;
    ci_loc: Location.t;
    ci_attributes: attributes;
   }

(* Auxiliary functions over the a.s.t. *)

val iter_pattern_desc: (pattern -> unit) -> pattern_desc -> unit
val map_pattern_desc: (pattern -> pattern) -> pattern_desc -> pattern_desc

val let_bound_idents: value_binding list -> Ident.t list
val rev_let_bound_idents: value_binding list -> Ident.t list

val let_bound_idents_with_loc:
    value_binding list -> (Ident.t * string loc) list

(* Alpha conversion of patterns *)
val alpha_pat: (Ident.t * Ident.t) list -> pattern -> pattern

val mknoloc: 'a -> 'a Asttypes.loc
val mkloc: 'a -> Location.t -> 'a Asttypes.loc

val pat_bound_idents: pattern -> (Ident.t * string Asttypes.loc) list

end = struct
#1 "typedtree.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Abstract syntax tree after typing *)

open Misc
open Asttypes
open Types

(* Value expressions for the core language *)

type partial = Partial | Total
type optional = Required | Optional

type attribute = Parsetree.attribute
type attributes = attribute list

type pattern =
  { pat_desc: pattern_desc;
    pat_loc: Location.t;
    pat_extra : (pat_extra * Location.t * attribute list) list;
    pat_type: type_expr;
    mutable pat_env: Env.t;
    pat_attributes: attribute list;
   }

and pat_extra =
  | Tpat_constraint of core_type
  | Tpat_type of Path.t * Longident.t loc
  | Tpat_unpack

and pattern_desc =
    Tpat_any
  | Tpat_var of Ident.t * string loc
  | Tpat_alias of pattern * Ident.t * string loc
  | Tpat_constant of constant
  | Tpat_tuple of pattern list
  | Tpat_construct of
      Longident.t loc * constructor_description * pattern list
  | Tpat_variant of label * pattern option * row_desc ref
  | Tpat_record of
      (Longident.t loc * label_description * pattern) list *
        closed_flag
  | Tpat_array of pattern list
  | Tpat_or of pattern * pattern * row_desc option
  | Tpat_lazy of pattern

and expression =
  { exp_desc: expression_desc;
    exp_loc: Location.t;
    exp_extra: (exp_extra * Location.t * attribute list) list;
    exp_type: type_expr;
    exp_env: Env.t;
    exp_attributes: attribute list;
   }

and exp_extra =
  | Texp_constraint of core_type
  | Texp_coerce of core_type option * core_type
  | Texp_open of override_flag * Path.t * Longident.t loc * Env.t
  | Texp_poly of core_type option
  | Texp_newtype of string

and expression_desc =
    Texp_ident of Path.t * Longident.t loc * Types.value_description
  | Texp_constant of constant
  | Texp_let of rec_flag * value_binding list * expression
  | Texp_function of label * case list * partial
  | Texp_apply of expression * (label * expression option * optional) list
  | Texp_match of expression * case list * case list * partial
  | Texp_try of expression * case list
  | Texp_tuple of expression list
  | Texp_construct of
      Longident.t loc * constructor_description * expression list
  | Texp_variant of label * expression option
  | Texp_record of
      (Longident.t loc * label_description * expression) list *
        expression option
  | Texp_field of expression * Longident.t loc * label_description
  | Texp_setfield of
      expression * Longident.t loc * label_description * expression
  | Texp_array of expression list
  | Texp_ifthenelse of expression * expression * expression option
  | Texp_sequence of expression * expression
  | Texp_while of expression * expression
  | Texp_for of
      Ident.t * Parsetree.pattern * expression * expression * direction_flag *
        expression
  | Texp_send of expression * meth * expression option
  | Texp_new of Path.t * Longident.t loc * Types.class_declaration
  | Texp_instvar of Path.t * Path.t * string loc
  | Texp_setinstvar of Path.t * Path.t * string loc * expression
  | Texp_override of Path.t * (Path.t * string loc * expression) list
  | Texp_letmodule of Ident.t * string loc * module_expr * expression
  | Texp_assert of expression
  | Texp_lazy of expression
  | Texp_object of class_structure * string list
  | Texp_pack of module_expr

and meth =
    Tmeth_name of string
  | Tmeth_val of Ident.t

and case =
    {
     c_lhs: pattern;
     c_guard: expression option;
     c_rhs: expression;
    }

(* Value expressions for the class language *)

and class_expr =
    {
     cl_desc: class_expr_desc;
     cl_loc: Location.t;
     cl_type: Types.class_type;
     cl_env: Env.t;
     cl_attributes: attribute list;
    }

and class_expr_desc =
    Tcl_ident of Path.t * Longident.t loc * core_type list
  | Tcl_structure of class_structure
  | Tcl_fun of
      label * pattern * (Ident.t * string loc * expression) list * class_expr *
        partial
  | Tcl_apply of class_expr * (label * expression option * optional) list
  | Tcl_let of rec_flag * value_binding list *
                  (Ident.t * string loc * expression) list * class_expr
  | Tcl_constraint of
      class_expr * class_type option * string list * string list * Concr.t
    (* Visible instance variables, methods and concretes methods *)

and class_structure =
  {
   cstr_self: pattern;
   cstr_fields: class_field list;
   cstr_type: Types.class_signature;
   cstr_meths: Ident.t Meths.t;
  }

and class_field =
   {
    cf_desc: class_field_desc;
    cf_loc: Location.t;
    cf_attributes: attribute list;
  }

and class_field_kind =
  | Tcfk_virtual of core_type
  | Tcfk_concrete of override_flag * expression

and class_field_desc =
    Tcf_inherit of
      override_flag * class_expr * string option * (string * Ident.t) list *
        (string * Ident.t) list
    (* Inherited instance variables and concrete methods *)
  | Tcf_val of string loc * mutable_flag * Ident.t * class_field_kind * bool
  | Tcf_method of string loc * private_flag * class_field_kind
  | Tcf_constraint of core_type * core_type
  | Tcf_initializer of expression
  | Tcf_attribute of attribute

(* Value expressions for the module language *)

and module_expr =
  { mod_desc: module_expr_desc;
    mod_loc: Location.t;
    mod_type: Types.module_type;
    mod_env: Env.t;
    mod_attributes: attribute list;
   }

and module_type_constraint =
  Tmodtype_implicit
| Tmodtype_explicit of module_type

and module_expr_desc =
    Tmod_ident of Path.t * Longident.t loc
  | Tmod_structure of structure
  | Tmod_functor of Ident.t * string loc * module_type option * module_expr
  | Tmod_apply of module_expr * module_expr * module_coercion
  | Tmod_constraint of
      module_expr * Types.module_type * module_type_constraint * module_coercion
  | Tmod_unpack of expression * Types.module_type

and structure = {
  str_items : structure_item list;
  str_type : Types.signature;
  str_final_env : Env.t;
}

and structure_item =
  { str_desc : structure_item_desc;
    str_loc : Location.t;
    str_env : Env.t
  }

and structure_item_desc =
    Tstr_eval of expression * attributes
  | Tstr_value of rec_flag * value_binding list
  | Tstr_primitive of value_description
  | Tstr_type of type_declaration list
  | Tstr_typext of type_extension
  | Tstr_exception of extension_constructor
  | Tstr_module of module_binding
  | Tstr_recmodule of module_binding list
  | Tstr_modtype of module_type_declaration
  | Tstr_open of open_description
  | Tstr_class of (class_declaration * string list * virtual_flag) list
  | Tstr_class_type of (Ident.t * string loc * class_type_declaration) list
  | Tstr_include of include_declaration
  | Tstr_attribute of attribute

and module_binding =
    {
     mb_id: Ident.t;
     mb_name: string loc;
     mb_expr: module_expr;
     mb_attributes: attribute list;
     mb_loc: Location.t;
    }

and value_binding =
  {
    vb_pat: pattern;
    vb_expr: expression;
    vb_attributes: attributes;
    vb_loc: Location.t;
  }

and module_coercion =
    Tcoerce_none
  | Tcoerce_structure of (int * module_coercion) list *
                         (Ident.t * int * module_coercion) list
  | Tcoerce_functor of module_coercion * module_coercion
  | Tcoerce_primitive of Ident.t *  Primitive.description
  | Tcoerce_alias of Path.t * module_coercion

and module_type =
  { mty_desc: module_type_desc;
    mty_type : Types.module_type;
    mty_env : Env.t;
    mty_loc: Location.t;
    mty_attributes: attribute list;
   }

and module_type_desc =
    Tmty_ident of Path.t * Longident.t loc
  | Tmty_signature of signature
  | Tmty_functor of Ident.t * string loc * module_type option * module_type
  | Tmty_with of module_type * (Path.t * Longident.t loc * with_constraint) list
  | Tmty_typeof of module_expr
  | Tmty_alias of Path.t * Longident.t loc

and signature = {
  sig_items : signature_item list;
  sig_type : Types.signature;
  sig_final_env : Env.t;
}

and signature_item =
  { sig_desc: signature_item_desc;
    sig_env : Env.t; (* BINANNOT ADDED *)
    sig_loc: Location.t }

and signature_item_desc =
    Tsig_value of value_description
  | Tsig_type of type_declaration list
  | Tsig_typext of type_extension
  | Tsig_exception of extension_constructor
  | Tsig_module of module_declaration
  | Tsig_recmodule of module_declaration list
  | Tsig_modtype of module_type_declaration
  | Tsig_open of open_description
  | Tsig_include of include_description
  | Tsig_class of class_description list
  | Tsig_class_type of class_type_declaration list
  | Tsig_attribute of attribute

and module_declaration =
    {
     md_id: Ident.t;
     md_name: string loc;
     md_type: module_type;
     md_attributes: attribute list;
     md_loc: Location.t;
    }

and module_type_declaration =
    {
     mtd_id: Ident.t;
     mtd_name: string loc;
     mtd_type: module_type option;
     mtd_attributes: attribute list;
     mtd_loc: Location.t;
    }

and open_description =
    {
     open_path: Path.t;
     open_txt: Longident.t loc;
     open_override: override_flag;
     open_loc: Location.t;
     open_attributes: attribute list;
    }

and 'a include_infos =
    {
     incl_mod: 'a;
     incl_type: Types.signature;
     incl_loc: Location.t;
     incl_attributes: attribute list;
    }

and include_description = module_type include_infos

and include_declaration = module_expr include_infos

and with_constraint =
    Twith_type of type_declaration
  | Twith_module of Path.t * Longident.t loc
  | Twith_typesubst of type_declaration
  | Twith_modsubst of Path.t * Longident.t loc

and core_type =
(* mutable because of [Typeclass.declare_method] *)
  { mutable ctyp_desc : core_type_desc;
    mutable ctyp_type : type_expr;
    ctyp_env : Env.t; (* BINANNOT ADDED *)
    ctyp_loc : Location.t;
    ctyp_attributes: attribute list;
   }

and core_type_desc =
    Ttyp_any
  | Ttyp_var of string
  | Ttyp_arrow of label * core_type * core_type
  | Ttyp_tuple of core_type list
  | Ttyp_constr of Path.t * Longident.t loc * core_type list
  | Ttyp_object of (string * attributes * core_type) list * closed_flag
  | Ttyp_class of Path.t * Longident.t loc * core_type list
  | Ttyp_alias of core_type * string
  | Ttyp_variant of row_field list * closed_flag * label list option
  | Ttyp_poly of string list * core_type
  | Ttyp_package of package_type

and package_type = {
  pack_path : Path.t;
  pack_fields : (Longident.t loc * core_type) list;
  pack_type : Types.module_type;
  pack_txt : Longident.t loc;
}

and row_field =
    Ttag of label * attributes * bool * core_type list
  | Tinherit of core_type

and value_description =
  { val_id: Ident.t;
    val_name: string loc;
    val_desc: core_type;
    val_val: Types.value_description;
    val_prim: string list;
    val_loc: Location.t;
    val_attributes: attribute list;
    }

and type_declaration =
  { typ_id: Ident.t;
    typ_name: string loc;
    typ_params: (core_type * variance) list;
    typ_type: Types.type_declaration;
    typ_cstrs: (core_type * core_type * Location.t) list;
    typ_kind: type_kind;
    typ_private: private_flag;
    typ_manifest: core_type option;
    typ_loc: Location.t;
    typ_attributes: attribute list;
   }

and type_kind =
    Ttype_abstract
  | Ttype_variant of constructor_declaration list
  | Ttype_record of label_declaration list
  | Ttype_open

and label_declaration =
    {
     ld_id: Ident.t;
     ld_name: string loc;
     ld_mutable: mutable_flag;
     ld_type: core_type;
     ld_loc: Location.t;
     ld_attributes: attribute list;
    }

and constructor_declaration =
    {
     cd_id: Ident.t;
     cd_name: string loc;
     cd_args: core_type list;
     cd_res: core_type option;
     cd_loc: Location.t;
     cd_attributes: attribute list;
    }

and type_extension =
  {
    tyext_path: Path.t;
    tyext_txt: Longident.t loc;
    tyext_params: (core_type * variance) list;
    tyext_constructors: extension_constructor list;
    tyext_private: private_flag;
    tyext_attributes: attribute list;
  }

and extension_constructor =
  {
    ext_id: Ident.t;
    ext_name: string loc;
    ext_type : Types.extension_constructor;
    ext_kind : extension_constructor_kind;
    ext_loc : Location.t;
    ext_attributes: attribute list;
  }

and extension_constructor_kind =
    Text_decl of core_type list * core_type option
  | Text_rebind of Path.t * Longident.t loc

and class_type =
    {
     cltyp_desc: class_type_desc;
     cltyp_type: Types.class_type;
     cltyp_env: Env.t;
     cltyp_loc: Location.t;
     cltyp_attributes: attribute list;
    }

and class_type_desc =
    Tcty_constr of Path.t * Longident.t loc * core_type list
  | Tcty_signature of class_signature
  | Tcty_arrow of label * core_type * class_type

and class_signature = {
    csig_self : core_type;
    csig_fields : class_type_field list;
    csig_type : Types.class_signature;
  }

and class_type_field = {
    ctf_desc: class_type_field_desc;
    ctf_loc: Location.t;
    ctf_attributes: attribute list;
  }

and class_type_field_desc =
  | Tctf_inherit of class_type
  | Tctf_val of (string * mutable_flag * virtual_flag * core_type)
  | Tctf_method of (string * private_flag * virtual_flag * core_type)
  | Tctf_constraint of (core_type * core_type)
  | Tctf_attribute of attribute

and class_declaration =
  class_expr class_infos

and class_description =
  class_type class_infos

and class_type_declaration =
  class_type class_infos

and 'a class_infos =
  { ci_virt: virtual_flag;
    ci_params: (core_type * variance) list;
    ci_id_name : string loc;
    ci_id_class: Ident.t;
    ci_id_class_type : Ident.t;
    ci_id_object : Ident.t;
    ci_id_typesharp : Ident.t;
    ci_expr: 'a;
    ci_decl: Types.class_declaration;
    ci_type_decl : Types.class_type_declaration;
    ci_loc: Location.t;
    ci_attributes: attribute list;
   }

(* Auxiliary functions over the a.s.t. *)

let iter_pattern_desc f = function
  | Tpat_alias(p, _, _) -> f p
  | Tpat_tuple patl -> List.iter f patl
  | Tpat_construct(_, cstr, patl) -> List.iter f patl
  | Tpat_variant(_, pat, _) -> may f pat
  | Tpat_record (lbl_pat_list, _) ->
      List.iter (fun (_, lbl, pat) -> f pat) lbl_pat_list
  | Tpat_array patl -> List.iter f patl
  | Tpat_or(p1, p2, _) -> f p1; f p2
  | Tpat_lazy p -> f p
  | Tpat_any
  | Tpat_var _
  | Tpat_constant _ -> ()

let map_pattern_desc f d =
  match d with
  | Tpat_alias (p1, id, s) ->
      Tpat_alias (f p1, id, s)
  | Tpat_tuple pats ->
      Tpat_tuple (List.map f pats)
  | Tpat_record (lpats, closed) ->
      Tpat_record (List.map (fun (lid, l,p) -> lid, l, f p) lpats, closed)
  | Tpat_construct (lid, c,pats) ->
      Tpat_construct (lid, c, List.map f pats)
  | Tpat_array pats ->
      Tpat_array (List.map f pats)
  | Tpat_lazy p1 -> Tpat_lazy (f p1)
  | Tpat_variant (x1, Some p1, x2) ->
      Tpat_variant (x1, Some (f p1), x2)
  | Tpat_or (p1,p2,path) ->
      Tpat_or (f p1, f p2, path)
  | Tpat_var _
  | Tpat_constant _
  | Tpat_any
  | Tpat_variant (_,None,_) -> d

(* List the identifiers bound by a pattern or a let *)

let idents = ref([]: (Ident.t * string loc) list)

let rec bound_idents pat =
  match pat.pat_desc with
  | Tpat_var (id,s) -> idents := (id,s) :: !idents
  | Tpat_alias(p, id, s ) ->
      bound_idents p; idents := (id,s) :: !idents
  | Tpat_or(p1, _, _) ->
      (* Invariant : both arguments binds the same variables *)
      bound_idents p1
  | d -> iter_pattern_desc bound_idents d

let pat_bound_idents pat =
  idents := []; bound_idents pat; let res = !idents in idents := []; res

let rev_let_bound_idents_with_loc bindings =
  idents := [];
  List.iter (fun vb -> bound_idents vb.vb_pat) bindings;
  let res = !idents in idents := []; res

let let_bound_idents_with_loc pat_expr_list =
  List.rev(rev_let_bound_idents_with_loc pat_expr_list)

let rev_let_bound_idents pat = List.map fst (rev_let_bound_idents_with_loc pat)
let let_bound_idents pat = List.map  fst (let_bound_idents_with_loc pat)

let alpha_var env id = List.assoc id env

let rec alpha_pat env p = match p.pat_desc with
| Tpat_var (id, s) -> (* note the ``Not_found'' case *)
    {p with pat_desc =
     try Tpat_var (alpha_var env id, s) with
     | Not_found -> Tpat_any}
| Tpat_alias (p1, id, s) ->
    let new_p =  alpha_pat env p1 in
    begin try
      {p with pat_desc = Tpat_alias (new_p, alpha_var env id, s)}
    with
    | Not_found -> new_p
    end
| d ->
    {p with pat_desc = map_pattern_desc (alpha_pat env) d}

let mkloc = Location.mkloc
let mknoloc = Location.mknoloc

end
module TypedtreeMap : sig 
#1 "typedtreeMap.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*                  Fabrice Le Fessant, INRIA Saclay                   *)
(*                                                                     *)
(*  Copyright 2012 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Typedtree

module type MapArgument = sig
  val enter_structure : structure -> structure
  val enter_value_description : value_description -> value_description
  val enter_type_declaration : type_declaration -> type_declaration
  val enter_type_extension : type_extension -> type_extension
  val enter_extension_constructor :
    extension_constructor -> extension_constructor
  val enter_pattern : pattern -> pattern
  val enter_expression : expression -> expression
  val enter_package_type : package_type -> package_type
  val enter_signature : signature -> signature
  val enter_signature_item : signature_item -> signature_item
  val enter_module_type_declaration : module_type_declaration -> module_type_declaration
  val enter_module_type : module_type -> module_type
  val enter_module_expr : module_expr -> module_expr
  val enter_with_constraint : with_constraint -> with_constraint
  val enter_class_expr : class_expr -> class_expr
  val enter_class_signature : class_signature -> class_signature
  val enter_class_declaration : class_declaration -> class_declaration
  val enter_class_description : class_description -> class_description
  val enter_class_type_declaration :
    class_type_declaration -> class_type_declaration
  val enter_class_type : class_type -> class_type
  val enter_class_type_field : class_type_field -> class_type_field
  val enter_core_type : core_type -> core_type
  val enter_class_structure : class_structure -> class_structure
  val enter_class_field : class_field -> class_field
  val enter_structure_item : structure_item -> structure_item

  val leave_structure : structure -> structure
  val leave_value_description : value_description -> value_description
  val leave_type_declaration : type_declaration -> type_declaration
  val leave_type_extension : type_extension -> type_extension
  val leave_extension_constructor :
    extension_constructor -> extension_constructor
  val leave_pattern : pattern -> pattern
  val leave_expression : expression -> expression
  val leave_package_type : package_type -> package_type
  val leave_signature : signature -> signature
  val leave_signature_item : signature_item -> signature_item
  val leave_module_type_declaration : module_type_declaration -> module_type_declaration
  val leave_module_type : module_type -> module_type
  val leave_module_expr : module_expr -> module_expr
  val leave_with_constraint : with_constraint -> with_constraint
  val leave_class_expr : class_expr -> class_expr
  val leave_class_signature : class_signature -> class_signature
  val leave_class_declaration : class_declaration -> class_declaration
  val leave_class_description : class_description -> class_description
  val leave_class_type_declaration :
    class_type_declaration -> class_type_declaration
  val leave_class_type : class_type -> class_type
  val leave_class_type_field : class_type_field -> class_type_field
  val leave_core_type : core_type -> core_type
  val leave_class_structure : class_structure -> class_structure
  val leave_class_field : class_field -> class_field
  val leave_structure_item : structure_item -> structure_item

end

module MakeMap :
  functor
    (Iter : MapArgument) ->
sig
  val map_structure : structure -> structure
  val map_pattern : pattern -> pattern
  val map_structure_item : structure_item -> structure_item
  val map_expression : expression -> expression
  val map_class_expr : class_expr -> class_expr

  val map_signature : signature -> signature
  val map_signature_item : signature_item -> signature_item
  val map_module_type : module_type -> module_type
end

module DefaultMapArgument : MapArgument

end = struct
#1 "typedtreeMap.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*                  Fabrice Le Fessant, INRIA Saclay                   *)
(*                                                                     *)
(*  Copyright 2012 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Typedtree

module type MapArgument = sig
  val enter_structure : structure -> structure
  val enter_value_description : value_description -> value_description
  val enter_type_declaration : type_declaration -> type_declaration
  val enter_type_extension : type_extension -> type_extension
  val enter_extension_constructor :
    extension_constructor -> extension_constructor
  val enter_pattern : pattern -> pattern
  val enter_expression : expression -> expression
  val enter_package_type : package_type -> package_type
  val enter_signature : signature -> signature
  val enter_signature_item : signature_item -> signature_item
  val enter_module_type_declaration : module_type_declaration -> module_type_declaration
  val enter_module_type : module_type -> module_type
  val enter_module_expr : module_expr -> module_expr
  val enter_with_constraint : with_constraint -> with_constraint
  val enter_class_expr : class_expr -> class_expr
  val enter_class_signature : class_signature -> class_signature
  val enter_class_declaration : class_declaration -> class_declaration
  val enter_class_description : class_description -> class_description
  val enter_class_type_declaration :
    class_type_declaration -> class_type_declaration
  val enter_class_type : class_type -> class_type
  val enter_class_type_field : class_type_field -> class_type_field
  val enter_core_type : core_type -> core_type
  val enter_class_structure : class_structure -> class_structure
  val enter_class_field : class_field -> class_field
  val enter_structure_item : structure_item -> structure_item

  val leave_structure : structure -> structure
  val leave_value_description : value_description -> value_description
  val leave_type_declaration : type_declaration -> type_declaration
  val leave_type_extension : type_extension -> type_extension
  val leave_extension_constructor :
    extension_constructor -> extension_constructor
  val leave_pattern : pattern -> pattern
  val leave_expression : expression -> expression
  val leave_package_type : package_type -> package_type
  val leave_signature : signature -> signature
  val leave_signature_item : signature_item -> signature_item
  val leave_module_type_declaration : module_type_declaration -> module_type_declaration
  val leave_module_type : module_type -> module_type
  val leave_module_expr : module_expr -> module_expr
  val leave_with_constraint : with_constraint -> with_constraint
  val leave_class_expr : class_expr -> class_expr
  val leave_class_signature : class_signature -> class_signature
  val leave_class_declaration : class_declaration -> class_declaration
  val leave_class_description : class_description -> class_description
  val leave_class_type_declaration :
    class_type_declaration -> class_type_declaration
  val leave_class_type : class_type -> class_type
  val leave_class_type_field : class_type_field -> class_type_field
  val leave_core_type : core_type -> core_type
  val leave_class_structure : class_structure -> class_structure
  val leave_class_field : class_field -> class_field
  val leave_structure_item : structure_item -> structure_item

end


module MakeMap(Map : MapArgument) = struct

  let may_map f v =
    match v with
        None -> v
      | Some x -> Some (f x)


  open Misc

  let rec map_structure str =
    let str = Map.enter_structure str in
    let str_items = List.map map_structure_item str.str_items in
    Map.leave_structure { str with str_items = str_items }

  and map_binding vb =
    {
      vb_pat = map_pattern vb.vb_pat;
      vb_expr = map_expression vb.vb_expr;
      vb_attributes = vb.vb_attributes;
      vb_loc = vb.vb_loc;
    }

  and map_bindings rec_flag list =
    List.map map_binding list

  and map_case {c_lhs; c_guard; c_rhs} =
    {
     c_lhs = map_pattern c_lhs;
     c_guard = may_map map_expression c_guard;
     c_rhs = map_expression c_rhs;
    }

  and map_cases list =
    List.map map_case list

  and map_structure_item item =
    let item = Map.enter_structure_item item in
    let str_desc =
      match item.str_desc with
          Tstr_eval (exp, attrs) -> Tstr_eval (map_expression exp, attrs)
        | Tstr_value (rec_flag, list) ->
          Tstr_value (rec_flag, map_bindings rec_flag list)
        | Tstr_primitive vd ->
          Tstr_primitive (map_value_description vd)
        | Tstr_type list ->
          Tstr_type (List.map map_type_declaration list)
        | Tstr_typext tyext ->
          Tstr_typext (map_type_extension tyext)
        | Tstr_exception ext ->
          Tstr_exception (map_extension_constructor ext)
        | Tstr_module x ->
          Tstr_module (map_module_binding x)
        | Tstr_recmodule list ->
          let list = List.map map_module_binding list in
          Tstr_recmodule list
        | Tstr_modtype mtd ->
          Tstr_modtype (map_module_type_declaration mtd)
        | Tstr_open od -> Tstr_open od
        | Tstr_class list ->
          let list =
            List.map
              (fun (ci, string_list, virtual_flag) ->
                 map_class_declaration ci, string_list, virtual_flag)
              list
          in
            Tstr_class list
        | Tstr_class_type list ->
          let list =
            List.map
              (fun (id, name, ct) ->
               id, name, map_class_type_declaration ct)
              list
          in
            Tstr_class_type list
        | Tstr_include incl ->
          Tstr_include {incl with incl_mod = map_module_expr incl.incl_mod}
        | Tstr_attribute x -> Tstr_attribute x
    in
    Map.leave_structure_item { item with str_desc = str_desc}

  and map_module_binding x =
    {x with mb_expr = map_module_expr x.mb_expr}

  and map_value_description v =
    let v = Map.enter_value_description v in
    let val_desc = map_core_type v.val_desc in
    Map.leave_value_description { v with val_desc = val_desc }

  and map_type_declaration decl =
    let decl = Map.enter_type_declaration decl in
    let typ_params = List.map map_type_parameter decl.typ_params in
    let typ_cstrs = List.map (fun (ct1, ct2, loc) ->
      (map_core_type ct1,
       map_core_type ct2,
       loc)
    ) decl.typ_cstrs in
    let typ_kind = match decl.typ_kind with
        Ttype_abstract -> Ttype_abstract
      | Ttype_variant list ->
          let list = List.map map_constructor_declaration list in
          Ttype_variant list
      | Ttype_record list ->
        let list =
          List.map
            (fun ld ->
              {ld with ld_type = map_core_type ld.ld_type}
            ) list
        in
        Ttype_record list
      | Ttype_open -> Ttype_open
    in
    let typ_manifest = may_map map_core_type decl.typ_manifest in
    Map.leave_type_declaration { decl with typ_params = typ_params;
      typ_cstrs = typ_cstrs; typ_kind = typ_kind; typ_manifest = typ_manifest }

  and map_type_parameter (ct, v) = (map_core_type ct, v)

  and map_constructor_declaration cd =
    {cd with cd_args = List.map map_core_type cd.cd_args;
     cd_res = may_map map_core_type cd.cd_res
    }

  and map_type_extension tyext =
    let tyext = Map.enter_type_extension tyext in
    let tyext_params = List.map map_type_parameter tyext.tyext_params in
    let tyext_constructors  =
      List.map map_extension_constructor tyext.tyext_constructors
    in
    Map.leave_type_extension { tyext with tyext_params = tyext_params;
      tyext_constructors = tyext_constructors }

  and map_extension_constructor ext =
    let ext = Map.enter_extension_constructor ext in
    let ext_kind = match ext.ext_kind with
        Text_decl(args, ret) ->
          let args = List.map map_core_type args in
          let ret = may_map map_core_type ret in
            Text_decl(args, ret)
      | Text_rebind(p, lid) -> Text_rebind(p, lid)
    in
    Map.leave_extension_constructor {ext with ext_kind = ext_kind}

  and map_pattern pat =
    let pat = Map.enter_pattern pat in
    let pat_desc =
      match pat.pat_desc with
        | Tpat_alias (pat1, p, text) ->
          let pat1 = map_pattern pat1 in
          Tpat_alias (pat1, p, text)
        | Tpat_tuple list -> Tpat_tuple (List.map map_pattern list)
        | Tpat_construct (lid, cstr_decl, args) ->
          Tpat_construct (lid, cstr_decl,
                          List.map map_pattern args)
        | Tpat_variant (label, pato, rowo) ->
          let pato = match pato with
              None -> pato
            | Some pat -> Some (map_pattern pat)
          in
          Tpat_variant (label, pato, rowo)
        | Tpat_record (list, closed) ->
          Tpat_record (List.map (fun (lid, lab_desc, pat) ->
            (lid, lab_desc, map_pattern pat) ) list, closed)
        | Tpat_array list -> Tpat_array (List.map map_pattern list)
        | Tpat_or (p1, p2, rowo) ->
          Tpat_or (map_pattern p1, map_pattern p2, rowo)
        | Tpat_lazy p -> Tpat_lazy (map_pattern p)
        | Tpat_constant _
        | Tpat_any
        | Tpat_var _ -> pat.pat_desc

    in
    let pat_extra = List.map map_pat_extra pat.pat_extra in
    Map.leave_pattern { pat with pat_desc = pat_desc; pat_extra = pat_extra }

  and map_pat_extra pat_extra =
    match pat_extra with
      | Tpat_constraint ct, loc, attrs -> (Tpat_constraint (map_core_type  ct), loc, attrs)
      | (Tpat_type _ | Tpat_unpack), _, _ -> pat_extra

  and map_expression exp =
    let exp = Map.enter_expression exp in
    let exp_desc =
      match exp.exp_desc with
          Texp_ident (_, _, _)
        | Texp_constant _ -> exp.exp_desc
        | Texp_let (rec_flag, list, exp) ->
          Texp_let (rec_flag,
                    map_bindings rec_flag list,
                    map_expression exp)
        | Texp_function (label, cases, partial) ->
          Texp_function (label, map_cases cases, partial)
        | Texp_apply (exp, list) ->
          Texp_apply (map_expression exp,
                      List.map (fun (label, expo, optional) ->
                        let expo =
                          match expo with
                              None -> expo
                            | Some exp -> Some (map_expression exp)
                        in
                        (label, expo, optional)
                      ) list )
        | Texp_match (exp, list1, list2, partial) ->
          Texp_match (
            map_expression exp,
            map_cases list1,
            map_cases list2,
            partial
          )
        | Texp_try (exp, list) ->
          Texp_try (
            map_expression exp,
            map_cases list
          )
        | Texp_tuple list ->
          Texp_tuple (List.map map_expression list)
        | Texp_construct (lid, cstr_desc, args) ->
          Texp_construct (lid, cstr_desc,
                          List.map map_expression args )
        | Texp_variant (label, expo) ->
          let expo =match expo with
              None -> expo
            | Some exp -> Some (map_expression exp)
          in
          Texp_variant (label, expo)
        | Texp_record (list, expo) ->
          let list =
            List.map (fun (lid, lab_desc, exp) ->
              (lid, lab_desc, map_expression exp)
            ) list in
          let expo = match expo with
              None -> expo
            | Some exp -> Some (map_expression exp)
          in
          Texp_record (list, expo)
        | Texp_field (exp, lid, label) ->
          Texp_field (map_expression exp, lid, label)
        | Texp_setfield (exp1, lid, label, exp2) ->
          Texp_setfield (
            map_expression exp1,
            lid,
            label,
            map_expression exp2)
        | Texp_array list ->
          Texp_array (List.map map_expression list)
        | Texp_ifthenelse (exp1, exp2, expo) ->
          Texp_ifthenelse (
            map_expression exp1,
            map_expression exp2,
            match expo with
                None -> expo
              | Some exp -> Some (map_expression exp)
          )
        | Texp_sequence (exp1, exp2) ->
          Texp_sequence (
            map_expression exp1,
            map_expression exp2
          )
        | Texp_while (exp1, exp2) ->
          Texp_while (
            map_expression exp1,
            map_expression exp2
          )
        | Texp_for (id, name, exp1, exp2, dir, exp3) ->
          Texp_for (
            id, name,
            map_expression exp1,
            map_expression exp2,
            dir,
            map_expression exp3
          )
        | Texp_send (exp, meth, expo) ->
          Texp_send (map_expression exp, meth, may_map map_expression expo)
        | Texp_new (path, lid, cl_decl) -> exp.exp_desc
        | Texp_instvar (_, path, _) -> exp.exp_desc
        | Texp_setinstvar (path, lid, path2, exp) ->
          Texp_setinstvar (path, lid, path2, map_expression exp)
        | Texp_override (path, list) ->
          Texp_override (
            path,
            List.map (fun (path, lid, exp) ->
              (path, lid, map_expression exp)
            ) list
          )
        | Texp_letmodule (id, name, mexpr, exp) ->
          Texp_letmodule (
            id, name,
            map_module_expr mexpr,
            map_expression exp
          )
        | Texp_assert exp -> Texp_assert (map_expression exp)
        | Texp_lazy exp -> Texp_lazy (map_expression exp)
        | Texp_object (cl, string_list) ->
          Texp_object (map_class_structure cl, string_list)
        | Texp_pack (mexpr) ->
          Texp_pack (map_module_expr mexpr)
    in
    let exp_extra = List.map map_exp_extra exp.exp_extra in
    Map.leave_expression {
      exp with
        exp_desc = exp_desc;
        exp_extra = exp_extra; }

  and map_exp_extra ((desc, loc, attrs) as exp_extra) =
    match desc with
      | Texp_constraint ct ->
        Texp_constraint (map_core_type ct), loc, attrs
      | Texp_coerce (None, ct) ->
        Texp_coerce (None, map_core_type ct), loc, attrs
      | Texp_coerce (Some ct1, ct2) ->
        Texp_coerce (Some (map_core_type ct1),
                         map_core_type ct2), loc, attrs
      | Texp_poly (Some ct) ->
        Texp_poly (Some ( map_core_type ct )), loc, attrs
      | Texp_newtype _
      | Texp_open _
      | Texp_poly None -> exp_extra


  and map_package_type pack =
    let pack = Map.enter_package_type pack in
    let pack_fields = List.map (
      fun (s, ct) -> (s, map_core_type ct) ) pack.pack_fields in
    Map.leave_package_type { pack with pack_fields = pack_fields }

  and map_signature sg =
    let sg = Map.enter_signature sg in
    let sig_items = List.map map_signature_item sg.sig_items in
    Map.leave_signature { sg with sig_items = sig_items }

  and map_signature_item item =
    let item = Map.enter_signature_item item in
    let sig_desc =
      match item.sig_desc with
          Tsig_value vd ->
            Tsig_value (map_value_description vd)
        | Tsig_type list -> Tsig_type (List.map map_type_declaration list)
        | Tsig_typext tyext ->
          Tsig_typext (map_type_extension tyext)
        | Tsig_exception ext ->
          Tsig_exception (map_extension_constructor ext)
        | Tsig_module md ->
          Tsig_module {md with md_type = map_module_type md.md_type}
        | Tsig_recmodule list ->
          Tsig_recmodule
              (List.map
                 (fun md -> {md with md_type = map_module_type md.md_type})
                 list
              )
        | Tsig_modtype mtd ->
          Tsig_modtype (map_module_type_declaration mtd)
        | Tsig_open _ -> item.sig_desc
        | Tsig_include incl ->
          Tsig_include {incl with incl_mod = map_module_type incl.incl_mod}
        | Tsig_class list -> Tsig_class (List.map map_class_description list)
        | Tsig_class_type list ->
          Tsig_class_type (List.map map_class_type_declaration list)
        | Tsig_attribute _ as x -> x
    in
    Map.leave_signature_item { item with sig_desc = sig_desc }

  and map_module_type_declaration mtd =
    let mtd = Map.enter_module_type_declaration mtd in
    let mtd = {mtd with mtd_type = may_map map_module_type mtd.mtd_type} in
    Map.leave_module_type_declaration mtd

  and map_class_declaration cd =
    let cd = Map.enter_class_declaration cd in
    let ci_params = List.map map_type_parameter cd.ci_params in
    let ci_expr = map_class_expr cd.ci_expr in
    Map.leave_class_declaration
      { cd with ci_params = ci_params; ci_expr = ci_expr }

  and map_class_description cd =
    let cd = Map.enter_class_description cd in
    let ci_params = List.map map_type_parameter cd.ci_params in
    let ci_expr = map_class_type cd.ci_expr in
    Map.leave_class_description
      { cd with ci_params = ci_params; ci_expr = ci_expr}

  and map_class_type_declaration cd =
    let cd = Map.enter_class_type_declaration cd in
    let ci_params = List.map map_type_parameter cd.ci_params in
    let ci_expr = map_class_type cd.ci_expr in
    Map.leave_class_type_declaration
      { cd with ci_params = ci_params; ci_expr = ci_expr }

  and map_module_type mty =
    let mty = Map.enter_module_type mty in
    let mty_desc =
      match mty.mty_desc with
          Tmty_ident _ -> mty.mty_desc
        | Tmty_alias _ -> mty.mty_desc
        | Tmty_signature sg -> Tmty_signature (map_signature sg)
        | Tmty_functor (id, name, mtype1, mtype2) ->
          Tmty_functor (id, name, Misc.may_map map_module_type mtype1,
                        map_module_type mtype2)
        | Tmty_with (mtype, list) ->
          Tmty_with (map_module_type mtype,
                     List.map (fun (path, lid, withc) ->
                       (path, lid, map_with_constraint withc)
                     ) list)
        | Tmty_typeof mexpr ->
          Tmty_typeof (map_module_expr mexpr)
    in
    Map.leave_module_type { mty with mty_desc = mty_desc}

  and map_with_constraint cstr =
    let cstr = Map.enter_with_constraint cstr in
    let cstr =
      match cstr with
          Twith_type decl -> Twith_type (map_type_declaration decl)
        | Twith_typesubst decl -> Twith_typesubst (map_type_declaration decl)
        | Twith_module (path, lid) -> cstr
        | Twith_modsubst (path, lid) -> cstr
    in
    Map.leave_with_constraint cstr

  and map_module_expr mexpr =
    let mexpr = Map.enter_module_expr mexpr in
    let mod_desc =
      match mexpr.mod_desc with
          Tmod_ident (p, lid) -> mexpr.mod_desc
        | Tmod_structure st -> Tmod_structure (map_structure st)
        | Tmod_functor (id, name, mtype, mexpr) ->
          Tmod_functor (id, name, Misc.may_map map_module_type mtype,
                        map_module_expr mexpr)
        | Tmod_apply (mexp1, mexp2, coercion) ->
          Tmod_apply (map_module_expr mexp1, map_module_expr mexp2, coercion)
        | Tmod_constraint (mexpr, mod_type, Tmodtype_implicit, coercion ) ->
          Tmod_constraint (map_module_expr mexpr, mod_type,
                           Tmodtype_implicit, coercion)
        | Tmod_constraint (mexpr, mod_type,
                           Tmodtype_explicit mtype, coercion) ->
          Tmod_constraint (map_module_expr mexpr, mod_type,
                           Tmodtype_explicit (map_module_type mtype),
                           coercion)
        | Tmod_unpack (exp, mod_type) ->
          Tmod_unpack (map_expression exp, mod_type)
    in
    Map.leave_module_expr { mexpr with mod_desc = mod_desc }

  and map_class_expr cexpr =
    let cexpr = Map.enter_class_expr cexpr in
    let cl_desc =
      match cexpr.cl_desc with
        | Tcl_constraint (cl, None, string_list1, string_list2, concr ) ->
          Tcl_constraint (map_class_expr cl, None, string_list1,
                          string_list2, concr)
        | Tcl_structure clstr -> Tcl_structure (map_class_structure clstr)
        | Tcl_fun (label, pat, priv, cl, partial) ->
          Tcl_fun (label, map_pattern pat,
                   List.map (fun (id, name, exp) ->
                     (id, name, map_expression exp)) priv,
                   map_class_expr cl, partial)

        | Tcl_apply (cl, args) ->
          Tcl_apply (map_class_expr cl,
                     List.map (fun (label, expo, optional) ->
                       (label, may_map map_expression expo,
                        optional)
                     ) args)
        | Tcl_let (rec_flat, bindings, ivars, cl) ->
          Tcl_let (rec_flat, map_bindings rec_flat bindings,
                   List.map (fun (id, name, exp) ->
                     (id, name, map_expression exp)) ivars,
                   map_class_expr cl)

        | Tcl_constraint (cl, Some clty, vals, meths, concrs) ->
          Tcl_constraint ( map_class_expr cl,
                           Some (map_class_type clty), vals, meths, concrs)

        | Tcl_ident (id, name, tyl) ->
          Tcl_ident (id, name, List.map map_core_type tyl)
    in
    Map.leave_class_expr { cexpr with cl_desc = cl_desc }

  and map_class_type ct =
    let ct = Map.enter_class_type ct in
    let cltyp_desc =
      match ct.cltyp_desc with
          Tcty_signature csg -> Tcty_signature (map_class_signature csg)
        | Tcty_constr (path, lid, list) ->
          Tcty_constr (path, lid, List.map map_core_type list)
        | Tcty_arrow (label, ct, cl) ->
          Tcty_arrow (label, map_core_type ct, map_class_type cl)
    in
    Map.leave_class_type { ct with cltyp_desc = cltyp_desc }

  and map_class_signature cs =
    let cs = Map.enter_class_signature cs in
    let csig_self = map_core_type cs.csig_self in
    let csig_fields = List.map map_class_type_field cs.csig_fields in
    Map.leave_class_signature { cs with
      csig_self = csig_self; csig_fields = csig_fields }


  and map_class_type_field ctf =
    let ctf = Map.enter_class_type_field ctf in
    let ctf_desc =
      match ctf.ctf_desc with
          Tctf_inherit ct -> Tctf_inherit (map_class_type ct)
        | Tctf_val (s, mut, virt, ct) ->
          Tctf_val (s, mut, virt, map_core_type ct)
        | Tctf_method (s, priv, virt, ct) ->
          Tctf_method (s, priv, virt, map_core_type ct)
        | Tctf_constraint (ct1, ct2) ->
          Tctf_constraint (map_core_type ct1, map_core_type ct2)
        | Tctf_attribute _ as x -> x
    in
    Map.leave_class_type_field { ctf with ctf_desc = ctf_desc }

  and map_core_type ct =
    let ct = Map.enter_core_type ct in
    let ctyp_desc =
      match ct.ctyp_desc with
          Ttyp_any
        | Ttyp_var _ -> ct.ctyp_desc
        | Ttyp_arrow (label, ct1, ct2) ->
          Ttyp_arrow (label, map_core_type ct1, map_core_type ct2)
        | Ttyp_tuple list -> Ttyp_tuple (List.map map_core_type list)
        | Ttyp_constr (path, lid, list) ->
          Ttyp_constr (path, lid, List.map map_core_type list)
        | Ttyp_object (list, o) ->
          Ttyp_object
            (List.map (fun (s, a, t) -> (s, a, map_core_type t)) list, o)
        | Ttyp_class (path, lid, list) ->
          Ttyp_class (path, lid, List.map map_core_type list)
        | Ttyp_alias (ct, s) -> Ttyp_alias (map_core_type ct, s)
        | Ttyp_variant (list, bool, labels) ->
          Ttyp_variant (List.map map_row_field list, bool, labels)
        | Ttyp_poly (list, ct) -> Ttyp_poly (list, map_core_type ct)
        | Ttyp_package pack -> Ttyp_package (map_package_type pack)
    in
    Map.leave_core_type { ct with ctyp_desc = ctyp_desc }

  and map_class_structure cs =
    let cs = Map.enter_class_structure cs in
    let cstr_self = map_pattern cs.cstr_self in
    let cstr_fields = List.map map_class_field cs.cstr_fields in
    Map.leave_class_structure { cs with cstr_self; cstr_fields }

  and map_row_field rf =
    match rf with
        Ttag (label, attrs, bool, list) ->
          Ttag (label, attrs, bool, List.map map_core_type list)
      | Tinherit ct -> Tinherit (map_core_type ct)

  and map_class_field cf =
    let cf = Map.enter_class_field cf in
    let cf_desc =
      match cf.cf_desc with
          Tcf_inherit (ovf, cl, super, vals, meths) ->
            Tcf_inherit (ovf, map_class_expr cl, super, vals, meths)
        | Tcf_constraint (cty, cty') ->
          Tcf_constraint (map_core_type cty, map_core_type cty')
        | Tcf_val (lab, mut, ident, Tcfk_virtual cty, b) ->
          Tcf_val (lab, mut, ident, Tcfk_virtual (map_core_type cty), b)
        | Tcf_val (lab, mut, ident, Tcfk_concrete (o, exp), b) ->
          Tcf_val (lab, mut, ident, Tcfk_concrete (o, map_expression exp), b)
        | Tcf_method (lab, priv, Tcfk_virtual cty) ->
          Tcf_method (lab, priv, Tcfk_virtual (map_core_type cty))
        | Tcf_method (lab, priv, Tcfk_concrete (o, exp)) ->
          Tcf_method (lab, priv, Tcfk_concrete (o, map_expression exp))
        | Tcf_initializer exp -> Tcf_initializer (map_expression exp)
        | Tcf_attribute _ as x -> x
    in
    Map.leave_class_field { cf with cf_desc = cf_desc }
end


module DefaultMapArgument = struct

  let enter_structure t = t
  let enter_value_description t = t
  let enter_type_declaration t = t
  let enter_type_extension t = t
  let enter_extension_constructor t = t
  let enter_pattern t = t
  let enter_expression t = t
  let enter_package_type t = t
  let enter_signature t = t
  let enter_signature_item t = t
  let enter_module_type_declaration t = t
  let enter_module_type t = t
  let enter_module_expr t = t
  let enter_with_constraint t = t
  let enter_class_expr t = t
  let enter_class_signature t = t
  let enter_class_declaration t = t
  let enter_class_description t = t
  let enter_class_type_declaration t = t
  let enter_class_type t = t
  let enter_class_type_field t = t
  let enter_core_type t = t
  let enter_class_structure t = t
  let enter_class_field t = t
  let enter_structure_item t = t


  let leave_structure t = t
  let leave_value_description t = t
  let leave_type_declaration t = t
  let leave_type_extension t = t
  let leave_extension_constructor t = t
  let leave_pattern t = t
  let leave_expression t = t
  let leave_package_type t = t
  let leave_signature t = t
  let leave_signature_item t = t
  let leave_module_type_declaration t = t
  let leave_module_type t = t
  let leave_module_expr t = t
  let leave_with_constraint t = t
  let leave_class_expr t = t
  let leave_class_signature t = t
  let leave_class_declaration t = t
  let leave_class_description t = t
  let leave_class_type_declaration t = t
  let leave_class_type t = t
  let leave_class_type_field t = t
  let leave_core_type t = t
  let leave_class_structure t = t
  let leave_class_field t = t
  let leave_structure_item t = t

end

end
module Cmt_format : sig 
#1 "cmt_format.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*                  Fabrice Le Fessant, INRIA Saclay                   *)
(*                                                                     *)
(*  Copyright 2012 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(** cmt and cmti files format. *)

(** The layout of a cmt file is as follows:
      <cmt> := \{<cmi>\} <cmt magic> \{cmt infos\} \{<source info>\}
    where <cmi> is the cmi file format:
      <cmi> := <cmi magic> <cmi info>.
    More precisely, the optional <cmi> part must be present if and only if
    the file is:
    - a cmti, or
    - a cmt, for a ml file which has no corresponding mli (hence no
    corresponding cmti).

    Thus, we provide a common reading function for cmi and cmt(i)
    files which returns an option for each of the three parts: cmi
    info, cmt info, source info. *)

open Typedtree

type binary_annots =
  | Packed of Types.signature * string list
  | Implementation of structure
  | Interface of signature
  | Partial_implementation of binary_part array
  | Partial_interface of binary_part array

and binary_part =
  | Partial_structure of structure
  | Partial_structure_item of structure_item
  | Partial_expression of expression
  | Partial_pattern of pattern
  | Partial_class_expr of class_expr
  | Partial_signature of signature
  | Partial_signature_item of signature_item
  | Partial_module_type of module_type

type cmt_infos = {
  cmt_modname : string;
  cmt_annots : binary_annots;
  cmt_value_dependencies :
    (Types.value_description * Types.value_description) list;
  cmt_comments : (string * Location.t) list;
  cmt_args : string array;
  cmt_sourcefile : string option;
  cmt_builddir : string;
  cmt_loadpath : string list;
  cmt_source_digest : string option;
  cmt_initial_env : Env.t;
  cmt_imports : (string * Digest.t option) list;
  cmt_interface_digest : Digest.t option;
  cmt_use_summaries : bool;
}

type error =
    Not_a_typedtree of string

exception Error of error

(** [read filename] opens filename, and extract both the cmi_infos, if
    it exists, and the cmt_infos, if it exists. Thus, it can be used
    with .cmi, .cmt and .cmti files.

    .cmti files always contain a cmi_infos at the beginning. .cmt files
    only contain a cmi_infos at the beginning if there is no associated
    .cmti file.
*)
val read : string -> Cmi_format.cmi_infos option * cmt_infos option

val read_cmt : string -> cmt_infos
val read_cmi : string -> Cmi_format.cmi_infos

(** [save_cmt modname filename binary_annots sourcefile initial_env sg]
    writes a cmt(i) file.  *)
val save_cmt :
  string ->  (* filename.cmt to generate *)
  string ->  (* module name *)
  binary_annots ->
  string option ->  (* source file *)
  Env.t -> (* initial env *)
  Types.signature option -> (* if a .cmi was generated,
                               the signature saved there *)
  unit

(* Miscellaneous functions *)

val read_magic_number : in_channel -> string

val clear: unit -> unit

val add_saved_type : binary_part -> unit
val get_saved_types : unit -> binary_part list
val set_saved_types : binary_part list -> unit

val record_value_dependency:
  Types.value_description -> Types.value_description -> unit


(*

  val is_magic_number : string -> bool
  val read : in_channel -> Env.cmi_infos option * t
  val write_magic_number : out_channel -> unit
  val write : out_channel -> t -> unit

  val find : string list -> string -> string
  val read_signature : 'a -> string -> Types.signature * 'b list * 'c list

*)

end = struct
#1 "cmt_format.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*                  Fabrice Le Fessant, INRIA Saclay                   *)
(*                                                                     *)
(*  Copyright 2012 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Cmi_format
open Typedtree

(* Note that in Typerex, there is an awful hack to save a cmt file
   together with the interface file that was generated by ocaml (this
   is because the installed version of ocaml might differ from the one
   integrated in Typerex).
*)



let read_magic_number ic =
  let len_magic_number = String.length Config.cmt_magic_number in
  really_input_string ic len_magic_number

type binary_annots =
  | Packed of Types.signature * string list
  | Implementation of structure
  | Interface of signature
  | Partial_implementation of binary_part array
  | Partial_interface of binary_part array

and binary_part =
| Partial_structure of structure
| Partial_structure_item of structure_item
| Partial_expression of expression
| Partial_pattern of pattern
| Partial_class_expr of class_expr
| Partial_signature of signature
| Partial_signature_item of signature_item
| Partial_module_type of module_type

type cmt_infos = {
  cmt_modname : string;
  cmt_annots : binary_annots;
  cmt_value_dependencies :
    (Types.value_description * Types.value_description) list;
  cmt_comments : (string * Location.t) list;
  cmt_args : string array;
  cmt_sourcefile : string option;
  cmt_builddir : string;
  cmt_loadpath : string list;
  cmt_source_digest : Digest.t option;
  cmt_initial_env : Env.t;
  cmt_imports : (string * Digest.t option) list;
  cmt_interface_digest : Digest.t option;
  cmt_use_summaries : bool;
}

type error =
    Not_a_typedtree of string

let need_to_clear_env =
  try ignore (Sys.getenv "OCAML_BINANNOT_WITHENV"); false
  with Not_found -> true

let keep_only_summary = Env.keep_only_summary

module ClearEnv  = TypedtreeMap.MakeMap (struct
  open TypedtreeMap
  include DefaultMapArgument

  let leave_pattern p = { p with pat_env = keep_only_summary p.pat_env }
  let leave_expression e =
    let exp_extra = List.map (function
        (Texp_open (ovf, path, lloc, env), loc, attrs) ->
          (Texp_open (ovf, path, lloc, keep_only_summary env), loc, attrs)
      | exp_extra -> exp_extra) e.exp_extra in
    { e with
      exp_env = keep_only_summary e.exp_env;
      exp_extra = exp_extra }
  let leave_class_expr c =
    { c with cl_env = keep_only_summary c.cl_env }
  let leave_module_expr m =
    { m with mod_env = keep_only_summary m.mod_env }
  let leave_structure s =
    { s with str_final_env = keep_only_summary s.str_final_env }
  let leave_structure_item str =
    { str with str_env = keep_only_summary str.str_env }
  let leave_module_type m =
    { m with mty_env = keep_only_summary m.mty_env }
  let leave_signature s =
    { s with sig_final_env = keep_only_summary s.sig_final_env }
  let leave_signature_item s =
    { s with sig_env = keep_only_summary s.sig_env }
  let leave_core_type c =
    { c with ctyp_env = keep_only_summary c.ctyp_env }
  let leave_class_type c =
    { c with cltyp_env = keep_only_summary c.cltyp_env }

end)

let clear_part p = match p with
  | Partial_structure s -> Partial_structure (ClearEnv.map_structure s)
  | Partial_structure_item s ->
    Partial_structure_item (ClearEnv.map_structure_item s)
  | Partial_expression e -> Partial_expression (ClearEnv.map_expression e)
  | Partial_pattern p -> Partial_pattern (ClearEnv.map_pattern p)
  | Partial_class_expr ce -> Partial_class_expr (ClearEnv.map_class_expr ce)
  | Partial_signature s -> Partial_signature (ClearEnv.map_signature s)
  | Partial_signature_item s ->
    Partial_signature_item (ClearEnv.map_signature_item s)
  | Partial_module_type s -> Partial_module_type (ClearEnv.map_module_type s)

let clear_env binary_annots =
  if need_to_clear_env then
    match binary_annots with
      | Implementation s -> Implementation (ClearEnv.map_structure s)
      | Interface s -> Interface (ClearEnv.map_signature s)
      | Packed _ -> binary_annots
      | Partial_implementation array ->
        Partial_implementation (Array.map clear_part array)
      | Partial_interface array ->
        Partial_interface (Array.map clear_part array)

  else binary_annots




exception Error of error

let input_cmt ic = (input_value ic : cmt_infos)

let output_cmt oc cmt =
  output_string oc Config.cmt_magic_number;
  output_value oc (cmt : cmt_infos)

let read filename =
(*  Printf.fprintf stderr "Cmt_format.read %s\n%!" filename; *)
  let ic = open_in_bin filename in
  try
    let magic_number = read_magic_number ic in
    let cmi, cmt =
      if magic_number = Config.cmt_magic_number then
        None, Some (input_cmt ic)
      else if magic_number = Config.cmi_magic_number then
        let cmi = Cmi_format.input_cmi ic in
        let cmt = try
                    let magic_number = read_magic_number ic in
                    if magic_number = Config.cmt_magic_number then
                      let cmt = input_cmt ic in
                      Some cmt
                    else None
          with _ -> None
        in
        Some cmi, cmt
      else
        raise(Cmi_format.Error(Cmi_format.Not_an_interface filename))
    in
    close_in ic;
(*    Printf.fprintf stderr "Cmt_format.read done\n%!"; *)
    cmi, cmt
  with e ->
    close_in ic;
    raise e

let string_of_file filename =
  let ic = open_in filename in
  let s = Misc.string_of_file ic in
  close_in ic;
  s

let read_cmt filename =
  match read filename with
      _, None -> raise (Error (Not_a_typedtree filename))
    | _, Some cmt -> cmt

let read_cmi filename =
  match read filename with
      None, _ ->
        raise (Cmi_format.Error (Cmi_format.Not_an_interface filename))
    | Some cmi, _ -> cmi

let saved_types = ref []
let value_deps = ref []

let clear () =
  saved_types := [];
  value_deps := []

let add_saved_type b = saved_types := b :: !saved_types
let get_saved_types () = !saved_types
let set_saved_types l = saved_types := l

let record_value_dependency vd1 vd2 =
  if vd1.Types.val_loc <> vd2.Types.val_loc then
    value_deps := (vd1, vd2) :: !value_deps

let save_cmt filename modname binary_annots sourcefile initial_env sg =
  if !Clflags.binary_annotations && not !Clflags.print_types then begin
    let imports = Env.imports () in
    let oc = open_out_bin filename in
    let this_crc =
      match sg with
          None -> None
        | Some (sg) ->
          let cmi = {
            cmi_name = modname;
            cmi_sign = sg;
            cmi_flags =
            if !Clflags.recursive_types then [Cmi_format.Rectypes] else [];
            cmi_crcs = imports;
          } in
          Some (output_cmi filename oc cmi)
    in
    let source_digest = Misc.may_map Digest.file sourcefile in
    let cmt = {
      cmt_modname = modname;
      cmt_annots = clear_env binary_annots;
      cmt_value_dependencies = !value_deps;
      cmt_comments = Lexer.comments ();
      cmt_args = Sys.argv;
      cmt_sourcefile = sourcefile;
      cmt_builddir =  Sys.getcwd ();
      cmt_loadpath = !Config.load_path;
      cmt_source_digest = source_digest;
      cmt_initial_env = if need_to_clear_env then
          keep_only_summary initial_env else initial_env;
      cmt_imports = List.sort compare imports;
      cmt_interface_digest = this_crc;
      cmt_use_summaries = need_to_clear_env;
    } in
    output_cmt oc cmt;
    close_out oc;
  end;
  clear ()

end
module Ctype : sig 
#1 "ctype.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Operations on core types *)

open Asttypes
open Types

exception Unify of (type_expr * type_expr) list
exception Tags of label * label
exception Subtype of
        (type_expr * type_expr) list * (type_expr * type_expr) list
exception Cannot_expand
exception Cannot_apply
exception Recursive_abbrev
exception Unification_recursive_abbrev of (type_expr * type_expr) list

val init_def: int -> unit
        (* Set the initial variable level *)
val begin_def: unit -> unit
        (* Raise the variable level by one at the beginning of a definition. *)
val end_def: unit -> unit
        (* Lower the variable level by one at the end of a definition *)
val begin_class_def: unit -> unit
val raise_nongen_level: unit -> unit
val reset_global_level: unit -> unit
        (* Reset the global level before typing an expression *)
val increase_global_level: unit -> int
val restore_global_level: int -> unit
        (* This pair of functions is only used in Typetexp *)

val newty: type_desc -> type_expr
val newvar: ?name:string -> unit -> type_expr
val newvar2: ?name:string -> int -> type_expr
        (* Return a fresh variable *)
val new_global_var: ?name:string -> unit -> type_expr
        (* Return a fresh variable, bound at toplevel
           (as type variables ['a] in type constraints). *)
val newobj: type_expr -> type_expr
val newconstr: Path.t -> type_expr list -> type_expr
val none: type_expr
        (* A dummy type expression *)

val repr: type_expr -> type_expr
        (* Return the canonical representative of a type. *)

val object_fields: type_expr -> type_expr
val flatten_fields:
        type_expr -> (string * field_kind * type_expr) list * type_expr
        (* Transform a field type into a list of pairs label-type *)
        (* The fields are sorted *)
val associate_fields:
        (string * field_kind * type_expr) list ->
        (string * field_kind * type_expr) list ->
        (string * field_kind * type_expr * field_kind * type_expr) list *
        (string * field_kind * type_expr) list *
        (string * field_kind * type_expr) list
val opened_object: type_expr -> bool
val close_object: type_expr -> unit
val row_variable: type_expr -> type_expr
        (* Return the row variable of an open object type *)
val set_object_name:
        Ident.t -> type_expr -> type_expr list -> type_expr -> unit
val remove_object_name: type_expr -> unit
val hide_private_methods: type_expr -> unit
val find_cltype_for_path: Env.t -> Path.t -> type_declaration * type_expr
val lid_of_path: ?sharp:string -> Path.t -> Longident.t

val sort_row_fields: (label * row_field) list -> (label * row_field) list
val merge_row_fields:
        (label * row_field) list -> (label * row_field) list ->
        (label * row_field) list * (label * row_field) list *
        (label * row_field * row_field) list
val filter_row_fields:
        bool -> (label * row_field) list -> (label * row_field) list

val generalize: type_expr -> unit
        (* Generalize in-place the given type *)
val iterative_generalization: int -> type_expr list -> type_expr list
        (* Efficient repeated generalization of a type *)
val generalize_expansive: Env.t -> type_expr -> unit
        (* Generalize the covariant part of a type, making
           contravariant branches non-generalizable *)
val generalize_global: type_expr -> unit
        (* Generalize the structure of a type, lowering variables
           to !global_level *)
val generalize_structure: type_expr -> unit
        (* Same, but variables are only lowered to !current_level *)
val generalize_spine: type_expr -> unit
        (* Special function to generalize a method during inference *)
val correct_levels: type_expr -> type_expr
        (* Returns a copy with decreasing levels *)
val limited_generalize: type_expr -> type_expr -> unit
        (* Only generalize some part of the type
           Make the remaining of the type non-generalizable *)

val instance: ?partial:bool -> Env.t -> type_expr -> type_expr
        (* Take an instance of a type scheme *)
        (* partial=None  -> normal
           partial=false -> newvar() for non generic subterms
           partial=true  -> newty2 ty.level Tvar for non generic subterms *)
val instance_def: type_expr -> type_expr
        (* use defaults *)
val instance_list: Env.t -> type_expr list -> type_expr list
        (* Take an instance of a list of type schemes *)
val instance_constructor:
        ?in_pattern:Env.t ref * int ->
        constructor_description -> type_expr list * type_expr
        (* Same, for a constructor *)
val instance_parameterized_type:
        ?keep_names:bool ->
        type_expr list -> type_expr -> type_expr list * type_expr
val instance_parameterized_type_2:
        type_expr list -> type_expr list -> type_expr ->
        type_expr list * type_expr list * type_expr
val instance_declaration: type_declaration -> type_declaration
val instance_class:
        type_expr list -> class_type -> type_expr list * class_type
val instance_poly:
        ?keep_names:bool ->
        bool -> type_expr list -> type_expr -> type_expr list * type_expr
        (* Take an instance of a type scheme containing free univars *)
val instance_label:
        bool -> label_description -> type_expr list * type_expr * type_expr
        (* Same, for a label *)
val apply:
        Env.t -> type_expr list -> type_expr -> type_expr list -> type_expr
        (* [apply [p1...pN] t [a1...aN]] match the arguments [ai] to
        the parameters [pi] and returns the corresponding instance of
        [t]. Exception [Cannot_apply] is raised in case of failure. *)

val expand_head_once: Env.t -> type_expr -> type_expr
val expand_head: Env.t -> type_expr -> type_expr
val try_expand_once_opt: Env.t -> type_expr -> type_expr
val expand_head_opt: Env.t -> type_expr -> type_expr
(** The compiler's own version of [expand_head] necessary for type-based
    optimisations. *)

val full_expand: Env.t -> type_expr -> type_expr
val extract_concrete_typedecl:
        Env.t -> type_expr -> Path.t * Path.t * type_declaration
        (* Return the original path of the types, and the first concrete
           type declaration found expanding it.
           Raise [Not_found] if none appears or not a type constructor. *)

val enforce_constraints: Env.t -> type_expr -> unit

val unify: Env.t -> type_expr -> type_expr -> unit
        (* Unify the two types given. Raise [Unify] if not possible. *)
val unify_gadt: newtype_level:int -> Env.t ref -> type_expr -> type_expr -> unit
        (* Unify the two types given and update the environment with the
           local constraints. Raise [Unify] if not possible. *)
val unify_var: Env.t -> type_expr -> type_expr -> unit
        (* Same as [unify], but allow free univars when first type
           is a variable. *)
val filter_arrow: Env.t -> type_expr -> label -> type_expr * type_expr
        (* A special case of unification (with l:'a -> 'b). *)
val filter_method: Env.t -> string -> private_flag -> type_expr -> type_expr
        (* A special case of unification (with {m : 'a; 'b}). *)
val check_filter_method: Env.t -> string -> private_flag -> type_expr -> unit
        (* A special case of unification (with {m : 'a; 'b}), returning unit. *)
val occur_in: Env.t -> type_expr -> type_expr -> bool
val deep_occur: type_expr -> type_expr -> bool
val filter_self_method:
        Env.t -> string -> private_flag -> (Ident.t * type_expr) Meths.t ref ->
        type_expr -> Ident.t * type_expr
val moregeneral: Env.t -> bool -> type_expr -> type_expr -> bool
        (* Check if the first type scheme is more general than the second. *)

val rigidify: type_expr -> type_expr list
        (* "Rigidify" a type and return its type variable *)
val all_distinct_vars: Env.t -> type_expr list -> bool
        (* Check those types are all distinct type variables *)
val matches: Env.t -> type_expr -> type_expr -> bool
        (* Same as [moregeneral false], implemented using the two above
           functions and backtracking. Ignore levels *)

type class_match_failure =
    CM_Virtual_class
  | CM_Parameter_arity_mismatch of int * int
  | CM_Type_parameter_mismatch of Env.t * (type_expr * type_expr) list
  | CM_Class_type_mismatch of Env.t * class_type * class_type
  | CM_Parameter_mismatch of Env.t * (type_expr * type_expr) list
  | CM_Val_type_mismatch of string * Env.t * (type_expr * type_expr) list
  | CM_Meth_type_mismatch of string * Env.t * (type_expr * type_expr) list
  | CM_Non_mutable_value of string
  | CM_Non_concrete_value of string
  | CM_Missing_value of string
  | CM_Missing_method of string
  | CM_Hide_public of string
  | CM_Hide_virtual of string * string
  | CM_Public_method of string
  | CM_Private_method of string
  | CM_Virtual_method of string
val match_class_types:
    ?trace:bool -> Env.t -> class_type -> class_type -> class_match_failure list
        (* Check if the first class type is more general than the second. *)
val equal: Env.t -> bool -> type_expr list -> type_expr list -> bool
        (* [equal env [x1...xn] tau [y1...yn] sigma]
           checks whether the parameterized types
           [/\x1.../\xn.tau] and [/\y1.../\yn.sigma] are equivalent. *)
val match_class_declarations:
        Env.t -> type_expr list -> class_type -> type_expr list ->
        class_type -> class_match_failure list
        (* Check if the first class type is more general than the second. *)

val enlarge_type: Env.t -> type_expr -> type_expr * bool
        (* Make a type larger, flag is true if some pruning had to be done *)
val subtype: Env.t -> type_expr -> type_expr -> unit -> unit
        (* [subtype env t1 t2] checks that [t1] is a subtype of [t2].
           It accumulates the constraints the type variables must
           enforce and returns a function that inforce this
           constraints. *)

val nondep_type: Env.t -> Ident.t -> type_expr -> type_expr
        (* Return a type equivalent to the given type but without
           references to the given module identifier. Raise [Not_found]
           if no such type exists. *)
val nondep_type_decl:
        Env.t -> Ident.t -> Ident.t -> bool -> type_declaration ->
        type_declaration
        (* Same for type declarations. *)
val nondep_extension_constructor:
        Env.t -> Ident.t -> extension_constructor ->
        extension_constructor
          (* Same for extension constructor *)
val nondep_class_declaration:
        Env.t -> Ident.t -> class_declaration -> class_declaration
        (* Same for class declarations. *)
val nondep_cltype_declaration:
        Env.t -> Ident.t -> class_type_declaration -> class_type_declaration
        (* Same for class type declarations. *)
(*val correct_abbrev: Env.t -> Path.t -> type_expr list -> type_expr -> unit*)
val cyclic_abbrev: Env.t -> Ident.t -> type_expr -> bool
val is_contractive: Env.t -> type_expr -> bool
val normalize_type: Env.t -> type_expr -> unit

val closed_schema: type_expr -> bool
        (* Check whether the given type scheme contains no non-generic
           type variables *)

val free_variables: ?env:Env.t -> type_expr -> type_expr list
        (* If env present, then check for incomplete definitions too *)
val closed_type_decl: type_declaration -> type_expr option
val closed_extension_constructor: extension_constructor -> type_expr option
type closed_class_failure =
    CC_Method of type_expr * bool * string * type_expr
  | CC_Value of type_expr * bool * string * type_expr
val closed_class:
        type_expr list -> class_signature -> closed_class_failure option
        (* Check whether all type variables are bound *)

val unalias: type_expr -> type_expr
val signature_of_class_type: class_type -> class_signature
val self_type: class_type -> type_expr
val class_type_arity: class_type -> int
val arity: type_expr -> int
        (* Return the arity (as for curried functions) of the given type. *)

val collapse_conj_params: Env.t -> type_expr list -> unit
        (* Collapse conjunctive types in class parameters *)

val get_current_level: unit -> int
val wrap_trace_gadt_instances: Env.t -> ('a -> 'b) -> 'a -> 'b

(* Stubs *)
val package_subtype :
    (Env.t -> Path.t -> Longident.t list -> type_expr list ->
      Path.t -> Longident.t list -> type_expr list -> bool) ref

end = struct
#1 "ctype.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(* Xavier Leroy and Jerome Vouillon, projet Cristal, INRIA Rocquencourt*)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Operations on core types *)

open Misc
open Asttypes
open Types
open Btype

(*
   Type manipulation after type inference
   ======================================
   If one wants to manipulate a type after type inference (for
   instance, during code generation or in the debugger), one must
   first make sure that the type levels are correct, using the
   function [correct_levels]. Then, this type can be correctely
   manipulated by [apply], [expand_head] and [moregeneral].
*)

(*
   General notes
   =============
   - As much sharing as possible should be kept : it makes types
     smaller and better abbreviated.
     When necessary, some sharing can be lost. Types will still be
     printed correctly (+++ TO DO...), and abbreviations defined by a
     class do not depend on sharing thanks to constrained
     abbreviations. (Of course, even if some sharing is lost, typing
     will still be correct.)
   - All nodes of a type have a level : that way, one know whether a
     node need to be duplicated or not when instantiating a type.
   - Levels of a type are decreasing (generic level being considered
     as greatest).
   - The level of a type constructor is superior to the binding
     time of its path.
   - Recursive types without limitation should be handled (even if
     there is still an occur check). This avoid treating specially the
     case for objects, for instance. Furthermore, the occur check
     policy can then be easily changed.
*)

(*
   A faire
   =======
   - Revoir affichage des types.
   - Etendre la portee d'un alias [... as 'a] a tout le type englobant.
   - #-type implementes comme de vraies abreviations.
   - Niveaux plus fins pour les identificateurs :
       Champ [global] renomme en [level];
       Niveau -1 : global
               0 : module toplevel
               1 : module contenu dans module toplevel
              ...
     En fait, incrementer le niveau a chaque fois que l'on rentre dans
     un module.

       3   4 6
        \ / /
       1 2 5
        \|/
         0

     [Subst] doit ecreter les niveaux (pour qu'un variable non
     generalisable dans un module de niveau 2 ne se retrouve pas
     generalisable lorsque l'on l'utilise au niveau 0).

   - Traitement de la trace de l'unification separe de la fonction
     [unify].
*)

(**** Errors ****)

exception Unify of (type_expr * type_expr) list

exception Tags of label * label

let () =
  Location.register_error_of_exn
    (function
      | Tags (l, l') ->
          Some
            Location.
              (errorf ~loc:(in_file !input_name)
                 "In this program,@ variant constructors@ `%s and `%s@ \
                  have the same hash value.@ Change one of them." l l'
              )
      | _ -> None
    )

exception Subtype of
        (type_expr * type_expr) list * (type_expr * type_expr) list

exception Cannot_expand

exception Cannot_apply

exception Recursive_abbrev

(* GADT: recursive abbrevs can appear as a result of local constraints *)
exception Unification_recursive_abbrev of (type_expr * type_expr) list

(**** Type level management ****)

let current_level = ref 0
let nongen_level = ref 0
let global_level = ref 1
let saved_level = ref []

let get_current_level () = !current_level
let init_def level = current_level := level; nongen_level := level
let begin_def () =
  saved_level := (!current_level, !nongen_level) :: !saved_level;
  incr current_level; nongen_level := !current_level
let begin_class_def () =
  saved_level := (!current_level, !nongen_level) :: !saved_level;
  incr current_level
let raise_nongen_level () =
  saved_level := (!current_level, !nongen_level) :: !saved_level;
  nongen_level := !current_level
let end_def () =
  let (cl, nl) = List.hd !saved_level in
  saved_level := List.tl !saved_level;
  current_level := cl; nongen_level := nl

let reset_global_level () =
  global_level := !current_level + 1
let increase_global_level () =
  let gl = !global_level in
  global_level := !current_level;
  gl
let restore_global_level gl =
  global_level := gl

(**** Whether a path points to an object type (with hidden row variable) ****)
let is_object_type path =
  let name =
    match path with Path.Pident id -> Ident.name id
    | Path.Pdot(_, s,_) -> s
    | Path.Papply _ -> assert false
  in name.[0] = '#'

(**** Control tracing of GADT instances *)

let trace_gadt_instances = ref false
let check_trace_gadt_instances env =
  not !trace_gadt_instances && Env.has_local_constraints env &&
  (trace_gadt_instances := true; cleanup_abbrev (); true)

let reset_trace_gadt_instances b =
  if b then trace_gadt_instances := false

let wrap_trace_gadt_instances env f x =
  let b = check_trace_gadt_instances env in
  let y = f x in
  reset_trace_gadt_instances b;
  y

(**** Abbreviations without parameters ****)
(* Shall reset after generalizing *)

let simple_abbrevs = ref Mnil

let proper_abbrevs path tl abbrev =
  if tl <> [] || !trace_gadt_instances || !Clflags.principal ||
     is_object_type path
  then abbrev
  else simple_abbrevs

(**** Some type creators ****)

(* Re-export generic type creators *)

let newty2             = Btype.newty2
let newty desc         = newty2 !current_level desc
let new_global_ty desc = newty2 !global_level desc

let newvar ?name ()         = newty2 !current_level (Tvar name)
let newvar2 ?name level     = newty2 level (Tvar name)
let new_global_var ?name () = newty2 !global_level (Tvar name)

let newobj fields      = newty (Tobject (fields, ref None))

let newconstr path tyl = newty (Tconstr (path, tyl, ref Mnil))

let none = newty (Ttuple [])                (* Clearly ill-formed type *)

(**** Representative of a type ****)

(* Re-export repr *)
let repr = repr

(**** Type maps ****)

module TypePairs =
  Hashtbl.Make (struct
    type t = type_expr * type_expr
    let equal (t1, t1') (t2, t2') = (t1 == t2) && (t1' == t2')
    let hash (t, t') = t.id + 93 * t'.id
 end)


(**** unification mode ****)

type unification_mode =
  | Expression (* unification in expression *)
  | Pattern (* unification in pattern which may add local constraints *)

let umode = ref Expression
let generate_equations = ref false
let assume_injective = ref false

let set_mode_expression f =
  let old_unification_mode = !umode in
  try
    umode := Expression;
    let ret = f () in
    umode := old_unification_mode;
    ret
  with e ->
    umode := old_unification_mode;
    raise e

let set_mode_pattern ~generate ~injective f =
  let old_unification_mode = !umode
  and old_gen = !generate_equations
  and old_inj = !assume_injective in
  try
    umode := Pattern;
    generate_equations := generate;
    assume_injective := injective;
    let ret = f () in
    umode := old_unification_mode;
    generate_equations := old_gen;
    assume_injective := old_inj;
    ret
  with e ->
    umode := old_unification_mode;
    generate_equations := old_gen;
    assume_injective := old_inj;
    raise e

(*** Checks for type definitions ***)

let in_current_module = function
  | Path.Pident _ -> true
  | Path.Pdot _ | Path.Papply _ -> false

let in_pervasives p =
  in_current_module p &&
  try ignore (Env.find_type p Env.initial_safe_string); true
  with Not_found -> false

let is_datatype decl=
  match decl.type_kind with
    Type_record _ | Type_variant _ | Type_open -> true
  | Type_abstract -> false


                  (**********************************************)
                  (*  Miscellaneous operations on object types  *)
                  (**********************************************)

(* Note:
   We need to maintain some invariants:
   * cty_self must be a Tobject
   * ...
*)

(**** Object field manipulation. ****)

let object_fields ty =
  match (repr ty).desc with
    Tobject (fields, _) -> fields
  | _                   -> assert false

let flatten_fields ty =
  let rec flatten l ty =
    let ty = repr ty in
    match ty.desc with
      Tfield(s, k, ty1, ty2) ->
        flatten ((s, k, ty1)::l) ty2
    | _ ->
        (l, ty)
  in
    let (l, r) = flatten [] ty in
    (List.sort (fun (n, _, _) (n', _, _) -> compare n n') l, r)

let build_fields level =
  List.fold_right
    (fun (s, k, ty1) ty2 -> newty2 level (Tfield(s, k, ty1, ty2)))

let associate_fields fields1 fields2 =
  let rec associate p s s' =
    function
      (l, []) ->
        (List.rev p, (List.rev s) @ l, List.rev s')
    | ([], l') ->
        (List.rev p, List.rev s, (List.rev s') @ l')
    | ((n, k, t)::r, (n', k', t')::r') when n = n' ->
        associate ((n, k, t, k', t')::p) s s' (r, r')
    | ((n, k, t)::r, ((n', k', t')::_ as l')) when n < n' ->
        associate p ((n, k, t)::s) s' (r, l')
    | (((n, k, t)::r as l), (n', k', t')::r') (* when n > n' *) ->
        associate p s ((n', k', t')::s') (l, r')
  in
  associate [] [] [] (fields1, fields2)

(**** Check whether an object is open ****)

(* +++ Il faudra penser a eventuellement expanser l'abreviation *)
let rec object_row ty =
  let ty = repr ty in
  match ty.desc with
    Tobject (t, _)     -> object_row t
  | Tfield(_, _, _, t) -> object_row t
  | _ -> ty

let opened_object ty =
  match (object_row ty).desc with
  | Tvar _  | Tunivar _ | Tconstr _ -> true
  | _                               -> false

let concrete_object ty =
  match (object_row ty).desc with
  | Tvar _             -> false
  | _                  -> true

(**** Close an object ****)

let close_object ty =
  let rec close ty =
    let ty = repr ty in
    match ty.desc with
      Tvar _ ->
        link_type ty (newty2 ty.level Tnil)
    | Tfield(_, _, _, ty') -> close ty'
    | _                    -> assert false
  in
  match (repr ty).desc with
    Tobject (ty, _)   -> close ty
  | _                 -> assert false

(**** Row variable of an object type ****)

let row_variable ty =
  let rec find ty =
    let ty = repr ty in
    match ty.desc with
      Tfield (_, _, _, ty) -> find ty
    | Tvar _               -> ty
    | _                    -> assert false
  in
  match (repr ty).desc with
    Tobject (fi, _) -> find fi
  | _               -> assert false

(**** Object name manipulation ****)
(* +++ Bientot obsolete *)

let set_object_name id rv params ty =
  match (repr ty).desc with
    Tobject (fi, nm) ->
      set_name nm (Some (Path.Pident id, rv::params))
  | _ ->
      assert false

let remove_object_name ty =
  match (repr ty).desc with
    Tobject (_, nm)   -> set_name nm None
  | Tconstr (_, _, _) -> ()
  | _                 -> fatal_error "Ctype.remove_object_name"

(**** Hiding of private methods ****)

let hide_private_methods ty =
  match (repr ty).desc with
    Tobject (fi, nm) ->
      nm := None;
      let (fl, _) = flatten_fields fi in
      List.iter
        (function (_, k, _) ->
          match field_kind_repr k with
            Fvar r -> set_kind r Fabsent
          | _      -> ())
        fl
  | _ ->
      assert false


                              (*******************************)
                              (*  Operations on class types  *)
                              (*******************************)


let rec signature_of_class_type =
  function
    Cty_constr (_, _, cty) -> signature_of_class_type cty
  | Cty_signature sign     -> sign
  | Cty_arrow (_, ty, cty)   -> signature_of_class_type cty

let self_type cty =
  repr (signature_of_class_type cty).csig_self

let rec class_type_arity =
  function
    Cty_constr (_, _, cty) ->  class_type_arity cty
  | Cty_signature _        ->  0
  | Cty_arrow (_, _, cty)    ->  1 + class_type_arity cty


                  (*******************************************)
                  (*  Miscellaneous operations on row types  *)
                  (*******************************************)

let sort_row_fields = List.sort (fun (p,_) (q,_) -> compare p q)

let rec merge_rf r1 r2 pairs fi1 fi2 =
  match fi1, fi2 with
    (l1,f1 as p1)::fi1', (l2,f2 as p2)::fi2' ->
      if l1 = l2 then merge_rf r1 r2 ((l1,f1,f2)::pairs) fi1' fi2' else
      if l1 < l2 then merge_rf (p1::r1) r2 pairs fi1' fi2 else
      merge_rf r1 (p2::r2) pairs fi1 fi2'
  | [], _ -> (List.rev r1, List.rev_append r2 fi2, pairs)
  | _, [] -> (List.rev_append r1 fi1, List.rev r2, pairs)

let merge_row_fields fi1 fi2 =
  match fi1, fi2 with
    [], _ | _, [] -> (fi1, fi2, [])
  | [p1], _ when not (List.mem_assoc (fst p1) fi2) -> (fi1, fi2, [])
  | _, [p2] when not (List.mem_assoc (fst p2) fi1) -> (fi1, fi2, [])
  | _ -> merge_rf [] [] [] (sort_row_fields fi1) (sort_row_fields fi2)

let rec filter_row_fields erase = function
    [] -> []
  | (l,f as p)::fi ->
      let fi = filter_row_fields erase fi in
      match row_field_repr f with
        Rabsent -> fi
      | Reither(_,_,false,e) when erase -> set_row_field e Rabsent; fi
      | _ -> p :: fi

                    (**************************************)
                    (*  Check genericity of type schemes  *)
                    (**************************************)


exception Non_closed0

let rec closed_schema_rec ty =
  let ty = repr ty in
  if ty.level >= lowest_level then begin
    let level = ty.level in
    ty.level <- pivot_level - level;
    match ty.desc with
      Tvar _ when level <> generic_level ->
        raise Non_closed0
    | Tfield(_, kind, t1, t2) ->
        if field_kind_repr kind = Fpresent then
          closed_schema_rec t1;
        closed_schema_rec t2
    | Tvariant row ->
        let row = row_repr row in
        iter_row closed_schema_rec row;
        if not (static_row row) then closed_schema_rec row.row_more
    | _ ->
        iter_type_expr closed_schema_rec ty
  end

(* Return whether all variables of type [ty] are generic. *)
let closed_schema ty =
  try
    closed_schema_rec ty;
    unmark_type ty;
    true
  with Non_closed0 ->
    unmark_type ty;
    false

exception Non_closed of type_expr * bool

let free_variables = ref []
let really_closed = ref None

let rec free_vars_rec real ty =
  let ty = repr ty in
  if ty.level >= lowest_level then begin
    ty.level <- pivot_level - ty.level;
    begin match ty.desc, !really_closed with
      Tvar _, _ ->
        free_variables := (ty, real) :: !free_variables
    | Tconstr (path, tl, _), Some env ->
        begin try
          let (_, body, _) = Env.find_type_expansion path env in
          if (repr body).level <> generic_level then
            free_variables := (ty, real) :: !free_variables
        with Not_found -> ()
        end;
        List.iter (free_vars_rec true) tl
(* Do not count "virtual" free variables
    | Tobject(ty, {contents = Some (_, p)}) ->
        free_vars_rec false ty; List.iter (free_vars_rec true) p
*)
    | Tobject (ty, _), _ ->
        free_vars_rec false ty
    | Tfield (_, _, ty1, ty2), _ ->
        free_vars_rec true ty1; free_vars_rec false ty2
    | Tvariant row, _ ->
        let row = row_repr row in
        iter_row (free_vars_rec true) row;
        if not (static_row row) then free_vars_rec false row.row_more
    | _    ->
        iter_type_expr (free_vars_rec true) ty
    end;
  end

let free_vars ?env ty =
  free_variables := [];
  really_closed := env;
  free_vars_rec true ty;
  let res = !free_variables in
  free_variables := [];
  really_closed := None;
  res

let free_variables ?env ty =
  let tl = List.map fst (free_vars ?env ty) in
  unmark_type ty;
  tl

let closed_type ty =
  match free_vars ty with
      []           -> ()
  | (v, real) :: _ -> raise (Non_closed (v, real))

let closed_parameterized_type params ty =
  List.iter mark_type params;
  let ok =
    try closed_type ty; true with Non_closed _ -> false in
  List.iter unmark_type params;
  unmark_type ty;
  ok

let closed_type_decl decl =
  try
    List.iter mark_type decl.type_params;
    begin match decl.type_kind with
      Type_abstract ->
        ()
    | Type_variant v ->
        List.iter
          (fun {cd_args; cd_res; _} ->
            match cd_res with
            | Some _ -> ()
            | None -> List.iter closed_type cd_args)
          v
    | Type_record(r, rep) ->
        List.iter (fun l -> closed_type l.ld_type) r
    | Type_open -> ()
    end;
    begin match decl.type_manifest with
      None    -> ()
    | Some ty -> closed_type ty
    end;
    unmark_type_decl decl;
    None
  with Non_closed (ty, _) ->
    unmark_type_decl decl;
    Some ty

let closed_extension_constructor ext =
  try
    List.iter mark_type ext.ext_type_params;
    begin match ext.ext_ret_type with
    | Some _ -> ()
    | None -> List.iter closed_type ext.ext_args
    end;
    unmark_extension_constructor ext;
    None
  with Non_closed (ty, _) ->
    unmark_extension_constructor ext;
    Some ty

type closed_class_failure =
    CC_Method of type_expr * bool * string * type_expr
  | CC_Value of type_expr * bool * string * type_expr

exception CCFailure of closed_class_failure

let closed_class params sign =
  let ty = object_fields (repr sign.csig_self) in
  let (fields, rest) = flatten_fields ty in
  List.iter mark_type params;
  mark_type rest;
  List.iter
    (fun (lab, _, ty) -> if lab = dummy_method then mark_type ty)
    fields;
  try
    mark_type_node (repr sign.csig_self);
    List.iter
      (fun (lab, kind, ty) ->
        if field_kind_repr kind = Fpresent then
        try closed_type ty with Non_closed (ty0, real) ->
          raise (CCFailure (CC_Method (ty0, real, lab, ty))))
      fields;
    mark_type_params (repr sign.csig_self);
    List.iter unmark_type params;
    unmark_class_signature sign;
    None
  with CCFailure reason ->
    mark_type_params (repr sign.csig_self);
    List.iter unmark_type params;
    unmark_class_signature sign;
    Some reason


                            (**********************)
                            (*  Type duplication  *)
                            (**********************)


(* Duplicate a type, preserving only type variables *)
let duplicate_type ty =
  Subst.type_expr Subst.identity ty

(* Same, for class types *)
let duplicate_class_type ty =
  Subst.class_type Subst.identity ty


                         (*****************************)
                         (*  Type level manipulation  *)
                         (*****************************)

(*
   It would be a bit more efficient to remove abbreviation expansions
   rather than generalizing them: these expansions will usually not be
   used anymore. However, this is not possible in the general case, as
   [expand_abbrev] (via [subst]) requires these expansions to be
   preserved. Does it worth duplicating this code ?
*)
let rec iter_generalize tyl ty =
  let ty = repr ty in
  if (ty.level > !current_level) && (ty.level <> generic_level) then begin
    set_level ty generic_level;
    begin match ty.desc with
      Tconstr (_, _, abbrev) ->
        iter_abbrev (iter_generalize tyl) !abbrev
    | _ -> ()
    end;
    iter_type_expr (iter_generalize tyl) ty
  end else
    tyl := ty :: !tyl

let iter_generalize tyl ty =
  simple_abbrevs := Mnil;
  iter_generalize tyl ty

let generalize ty =
  iter_generalize (ref []) ty

(* Efficient repeated generalisation of the same type *)
let iterative_generalization min_level tyl =
  let tyl' = ref [] in
  List.iter (iter_generalize tyl') tyl;
  List.fold_right (fun ty l -> if ty.level <= min_level then l else ty::l)
    !tyl' []

(* Generalize the structure and lower the variables *)

let rec generalize_structure var_level ty =
  let ty = repr ty in
  if ty.level <> generic_level then begin
    if is_Tvar ty && ty.level > var_level then
      set_level ty var_level
    else if
      ty.level > !current_level &&
      match ty.desc with
        Tconstr (p, _, abbrev) ->
          not (is_object_type p) && (abbrev := Mnil; true)
      | _ -> true
    then begin
      set_level ty generic_level;
      iter_type_expr (generalize_structure var_level) ty
    end
  end

let generalize_structure var_level ty =
  simple_abbrevs := Mnil;
  generalize_structure var_level ty

(* Generalize the spine of a function, if the level >= !current_level *)

let rec generalize_spine ty =
  let ty = repr ty in
  if ty.level < !current_level || ty.level = generic_level then () else
  match ty.desc with
    Tarrow (_, ty1, ty2, _) ->
      set_level ty generic_level;
      generalize_spine ty1;
      generalize_spine ty2;
  | Tpoly (ty', _) ->
      set_level ty generic_level;
      generalize_spine ty'
  | Ttuple tyl
  | Tpackage (_, _, tyl) ->
      set_level ty generic_level;
      List.iter generalize_spine tyl
  | Tconstr (p, tyl, memo) when not (is_object_type p) ->
      set_level ty generic_level;
      memo := Mnil;
      List.iter generalize_spine tyl
  | _ -> ()

let forward_try_expand_once = (* Forward declaration *)
  ref (fun env ty -> raise Cannot_expand)

(*
   Lower the levels of a type (assume [level] is not
   [generic_level]).
*)
(*
    The level of a type constructor must be greater than its binding
    time. That way, a type constructor cannot escape the scope of its
    definition, as would be the case in
      let x = ref []
      module M = struct type t let _ = (x : t list ref) end
    (without this constraint, the type system would actually be unsound.)
*)
let get_level env p =
  try
    match (Env.find_type p env).type_newtype_level with
      | None -> Path.binding_time p
      | Some (x, _) -> x
  with
    | Not_found ->
      (* no newtypes in predef *)
      Path.binding_time p

let rec normalize_package_path env p =
  let t =
    try (Env.find_modtype p env).mtd_type
    with Not_found -> None
  in
  match t with
  | Some (Mty_ident p) -> normalize_package_path env p
  | Some (Mty_signature _ | Mty_functor _ | Mty_alias _) | None -> p

let rec update_level env level ty =
  let ty = repr ty in
  if ty.level > level then begin
    begin match Env.gadt_instance_level env ty with
      Some lv -> if level < lv then raise (Unify [(ty, newvar2 level)])
    | None -> ()
    end;
    match ty.desc with
      Tconstr(p, tl, abbrev) when level < get_level env p ->
        (* Try first to replace an abbreviation by its expansion. *)
        begin try
          (* if is_newtype env p then raise Cannot_expand; *)
          link_type ty (!forward_try_expand_once env ty);
          update_level env level ty
        with Cannot_expand ->
          (* +++ Levels should be restored... *)
          (* Format.printf "update_level: %i < %i@." level (get_level env p); *)
          if level < get_level env p then raise (Unify [(ty, newvar2 level)]);
          iter_type_expr (update_level env level) ty
        end
    | Tpackage (p, nl, tl) when level < get_level env p ->
        let p' = normalize_package_path env p in
        if Path.same p p' then raise (Unify [(ty, newvar2 level)]);
        log_type ty; ty.desc <- Tpackage (p', nl, tl);
        update_level env level ty
    | Tobject(_, ({contents=Some(p, tl)} as nm))
      when level < get_level env p ->
        set_name nm None;
        update_level env level ty
    | Tvariant row ->
        let row = row_repr row in
        begin match row.row_name with
        | Some (p, tl) when level < get_level env p ->
            log_type ty;
            ty.desc <- Tvariant {row with row_name = None}
        | _ -> ()
        end;
        set_level ty level;
        iter_type_expr (update_level env level) ty
    | Tfield(lab, _, ty1, _)
      when lab = dummy_method && (repr ty1).level > level ->
        raise (Unify [(ty1, newvar2 level)])
    | _ ->
        set_level ty level;
        (* XXX what about abbreviations in Tconstr ? *)
        iter_type_expr (update_level env level) ty
  end

(* Generalize and lower levels of contravariant branches simultaneously *)

let generalize_contravariant env =
  if !Clflags.principal then generalize_structure else update_level env

let rec generalize_expansive env var_level ty =
  let ty = repr ty in
  if ty.level <> generic_level then begin
    if ty.level > var_level then begin
      set_level ty generic_level;
      match ty.desc with
        Tconstr (path, tyl, abbrev) ->
          let variance =
            try (Env.find_type path env).type_variance
            with Not_found -> List.map (fun _ -> Variance.may_inv) tyl in
          abbrev := Mnil;
          List.iter2
            (fun v t ->
              if Variance.(mem May_weak v)
              then generalize_contravariant env var_level t
              else generalize_expansive env var_level t)
            variance tyl
      | Tpackage (_, _, tyl) ->
          List.iter (generalize_contravariant env var_level) tyl
      | Tarrow (_, t1, t2, _) ->
          generalize_contravariant env var_level t1;
          generalize_expansive env var_level t2
      | _ ->
          iter_type_expr (generalize_expansive env var_level) ty
    end
  end

let generalize_expansive env ty =
  simple_abbrevs := Mnil;
  try
    generalize_expansive env !nongen_level ty
  with Unify ([_, ty'] as tr) ->
    raise (Unify ((ty, ty') :: tr))

let generalize_global ty = generalize_structure !global_level ty
let generalize_structure ty = generalize_structure !current_level ty

(* Correct the levels of type [ty]. *)
let correct_levels ty =
  duplicate_type ty

(* Only generalize the type ty0 in ty *)
let limited_generalize ty0 ty =
  let ty0 = repr ty0 in

  let graph = Hashtbl.create 17 in
  let idx = ref lowest_level in
  let roots = ref [] in

  let rec inverse pty ty =
    let ty = repr ty in
    if (ty.level > !current_level) || (ty.level = generic_level) then begin
      decr idx;
      Hashtbl.add graph !idx (ty, ref pty);
      if (ty.level = generic_level) || (ty == ty0) then
        roots := ty :: !roots;
      set_level ty !idx;
      iter_type_expr (inverse [ty]) ty
    end else if ty.level < lowest_level then begin
      let (_, parents) = Hashtbl.find graph ty.level in
      parents := pty @ !parents
    end

  and generalize_parents ty =
    let idx = ty.level in
    if idx <> generic_level then begin
      set_level ty generic_level;
      List.iter generalize_parents !(snd (Hashtbl.find graph idx));
      (* Special case for rows: must generalize the row variable *)
      match ty.desc with
        Tvariant row ->
          let more = row_more row in
          let lv = more.level in
          if (lv < lowest_level || lv > !current_level)
          && lv <> generic_level then set_level more generic_level
      | _ -> ()
    end
  in

  inverse [] ty;
  if ty0.level < lowest_level then
    iter_type_expr (inverse []) ty0;
  List.iter generalize_parents !roots;
  Hashtbl.iter
    (fun _ (ty, _) ->
       if ty.level <> generic_level then set_level ty !current_level)
    graph


(* Compute statically the free univars of all nodes in a type *)
(* This avoids doing it repeatedly during instantiation *)

type inv_type_expr =
    { inv_type : type_expr;
      mutable inv_parents : inv_type_expr list }

let rec inv_type hash pty ty =
  let ty = repr ty in
  try
    let inv = TypeHash.find hash ty in
    inv.inv_parents <- pty @ inv.inv_parents
  with Not_found ->
    let inv = { inv_type = ty; inv_parents = pty } in
    TypeHash.add hash ty inv;
    iter_type_expr (inv_type hash [inv]) ty

let compute_univars ty =
  let inverted = TypeHash.create 17 in
  inv_type inverted [] ty;
  let node_univars = TypeHash.create 17 in
  let rec add_univar univ inv =
    match inv.inv_type.desc with
      Tpoly (ty, tl) when List.memq univ (List.map repr tl) -> ()
    | _ ->
        try
          let univs = TypeHash.find node_univars inv.inv_type in
          if not (TypeSet.mem univ !univs) then begin
            univs := TypeSet.add univ !univs;
            List.iter (add_univar univ) inv.inv_parents
          end
        with Not_found ->
          TypeHash.add node_univars inv.inv_type (ref(TypeSet.singleton univ));
          List.iter (add_univar univ) inv.inv_parents
  in
  TypeHash.iter (fun ty inv -> if is_Tunivar ty then add_univar ty inv)
    inverted;
  fun ty ->
    try !(TypeHash.find node_univars ty) with Not_found -> TypeSet.empty


                              (*******************)
                              (*  Instantiation  *)
                              (*******************)


let rec find_repr p1 =
  function
    Mnil ->
      None
  | Mcons (Public, p2, ty, _, _) when Path.same p1 p2 ->
      Some ty
  | Mcons (_, _, _, _, rem) ->
      find_repr p1 rem
  | Mlink {contents = rem} ->
      find_repr p1 rem

(*
   Generic nodes are duplicated, while non-generic nodes are left
   as-is.
   During instantiation, the description of a generic node is first
   replaced by a link to a stub ([Tsubst (newvar ())]). Once the
   copy is made, it replaces the stub.
   After instantiation, the description of generic node, which was
   stored by [save_desc], must be put back, using [cleanup_types].
*)

let abbreviations = ref (ref Mnil)
  (* Abbreviation memorized. *)

(* partial: we may not wish to copy the non generic types
   before we call type_pat *)
let rec copy ?env ?partial ?keep_names ty =
  let copy = copy ?env ?partial ?keep_names in
  let ty = repr ty in
  match ty.desc with
    Tsubst ty -> ty
  | _ ->
    if ty.level <> generic_level && partial = None then ty else
    (* We only forget types that are non generic and do not contain
       free univars *)
    let forget =
      if ty.level = generic_level then generic_level else
      match partial with
        None -> assert false
      | Some (free_univars, keep) ->
          if TypeSet.is_empty (free_univars ty) then
            if keep then ty.level else !current_level
          else generic_level
    in
    if forget <> generic_level then newty2 forget (Tvar None) else
    let desc = ty.desc in
    save_desc ty desc;
    let t = newvar() in          (* Stub *)
    begin match env with
      Some env when Env.has_local_constraints env ->
        begin match Env.gadt_instance_level env ty with
          Some lv -> Env.add_gadt_instances env lv [t]
        | None -> ()
        end
    | _ -> ()
    end;
    ty.desc <- Tsubst t;
    t.desc <-
      begin match desc with
      | Tconstr (p, tl, _) ->
          let abbrevs = proper_abbrevs p tl !abbreviations in
          begin match find_repr p !abbrevs with
            Some ty when repr ty != t -> (* XXX Commentaire... *)
              Tlink ty
          | _ ->
          (*
             One must allocate a new reference, so that abbrevia-
             tions belonging to different branches of a type are
             independent.
             Moreover, a reference containing a [Mcons] must be
             shared, so that the memorized expansion of an abbrevi-
             ation can be released by changing the content of just
             one reference.
          *)
              Tconstr (p, List.map copy tl,
                       ref (match !(!abbreviations) with
                              Mcons _ -> Mlink !abbreviations
                            | abbrev  -> abbrev))
          end
      | Tvariant row0 ->
          let row = row_repr row0 in
          let more = repr row.row_more in
          (* We must substitute in a subtle way *)
          (* Tsubst takes a tuple containing the row var and the variant *)
          begin match more.desc with
            Tsubst {desc = Ttuple [_;ty2]} ->
              (* This variant type has been already copied *)
              ty.desc <- Tsubst ty2; (* avoid Tlink in the new type *)
              Tlink ty2
          | _ ->
              (* If the row variable is not generic, we must keep it *)
              let keep = more.level <> generic_level in
              let more' =
                match more.desc with
                  Tsubst ty -> ty
                | Tconstr _ | Tnil ->
                    if keep then save_desc more more.desc;
                    copy more
                | Tvar _ | Tunivar _ ->
                    save_desc more more.desc;
                    if keep then more else newty more.desc
                |  _ -> assert false
              in
              let row =
                match repr more' with (* PR#6163 *)
                  {desc=Tconstr _} when not row.row_fixed ->
                    {row with row_fixed = true}
                | _ -> row
              in
              (* Open row if partial for pattern and contains Reither *)
              let more', row =
                match partial with
                  Some (free_univars, false) ->
                    let more' =
                      if more.id != more'.id then more' else
                      let lv = if keep then more.level else !current_level in
                      newty2 lv (Tvar None)
                    in
                    let not_reither (_, f) =
                      match row_field_repr f with
                        Reither _ -> false
                      | _ -> true
                    in
                    if row.row_closed && not row.row_fixed
                    && TypeSet.is_empty (free_univars ty)
                    && not (List.for_all not_reither row.row_fields) then
                      (more',
                       {row_fields = List.filter not_reither row.row_fields;
                        row_more = more'; row_bound = ();
                        row_closed = false; row_fixed = false; row_name = None})
                    else (more', row)
                | _ -> (more', row)
              in
              (* Register new type first for recursion *)
              more.desc <- Tsubst(newgenty(Ttuple[more';t]));
              (* Return a new copy *)
              Tvariant (copy_row copy true row keep more')
          end
      | Tfield (p, k, ty1, ty2) ->
          begin match field_kind_repr k with
            Fabsent  -> Tlink (copy ty2)
          | Fpresent -> copy_type_desc copy desc
          | Fvar r ->
              dup_kind r;
              copy_type_desc copy desc
          end
      | Tobject (ty1, _) when partial <> None ->
          Tobject (copy ty1, ref None)
      | _ -> copy_type_desc ?keep_names copy desc
      end;
    t

let simple_copy t = copy t

(**** Variants of instantiations ****)

let gadt_env env =
  if Env.has_local_constraints env
  then Some env
  else None

let instance ?partial env sch =
  let env = gadt_env env in
  let partial =
    match partial with
      None -> None
    | Some keep -> Some (compute_univars sch, keep)
  in
  let ty = copy ?env ?partial sch in
  cleanup_types ();
  ty

let instance_def sch =
  let ty = copy sch in
  cleanup_types ();
  ty

let instance_list env schl =
  let env = gadt_env env in
  let tyl = List.map (fun t -> copy ?env t) schl in
  cleanup_types ();
  tyl

let reified_var_counter = ref Vars.empty

(* names given to new type constructors.
   Used for existential types and
   local constraints *)
let get_new_abstract_name s =
  let index =
    try Vars.find s !reified_var_counter + 1
    with Not_found -> 0 in
  reified_var_counter := Vars.add s index !reified_var_counter;
  Printf.sprintf "%s#%d" s index

let new_declaration newtype manifest =
  {
    type_params = [];
    type_arity = 0;
    type_kind = Type_abstract;
    type_private = Public;
    type_manifest = manifest;
    type_variance = [];
    type_newtype_level = newtype;
    type_loc = Location.none;
    type_attributes = [];
  }

let instance_constructor ?in_pattern cstr =
  begin match in_pattern with
  | None -> ()
  | Some (env, newtype_lev) ->
      let process existential =
        let decl = new_declaration (Some (newtype_lev, newtype_lev)) None in
        let name =
          match repr existential with
            {desc = Tvar (Some name)} -> name
          | _ -> "ex"
        in
        let (id, new_env) =
          Env.enter_type (get_new_abstract_name name) decl !env in
        env := new_env;
        let to_unify = newty (Tconstr (Path.Pident id,[],ref Mnil)) in
        let tv = copy existential in
        assert (is_Tvar tv);
        link_type tv to_unify
      in
      List.iter process cstr.cstr_existentials
  end;
  let ty_res = copy cstr.cstr_res in
  let ty_args = List.map simple_copy  cstr.cstr_args in
  cleanup_types ();
  (ty_args, ty_res)

let instance_parameterized_type ?keep_names sch_args sch =
  let ty_args = List.map (fun t -> copy ?keep_names t) sch_args in
  let ty = copy sch in
  cleanup_types ();
  (ty_args, ty)

let instance_parameterized_type_2 sch_args sch_lst sch =
  let ty_args = List.map simple_copy sch_args in
  let ty_lst = List.map simple_copy sch_lst in
  let ty = copy sch in
  cleanup_types ();
  (ty_args, ty_lst, ty)

let instance_declaration decl =
  let decl =
    {decl with type_params = List.map simple_copy decl.type_params;
     type_manifest = may_map simple_copy decl.type_manifest;
     type_kind = match decl.type_kind with
     | Type_abstract -> Type_abstract
     | Type_variant cl ->
         Type_variant (
           List.map
             (fun c ->
                {c with cd_args=List.map simple_copy c.cd_args;
                        cd_res=may_map simple_copy c.cd_res})
             cl)
     | Type_record (fl, rr) ->
         Type_record (
           List.map
             (fun l ->
                {l with ld_type = copy l.ld_type}
             ) fl, rr)
     | Type_open -> Type_open
    }
  in
  cleanup_types ();
  decl

let instance_class params cty =
  let rec copy_class_type =
    function
      Cty_constr (path, tyl, cty) ->
        Cty_constr (path, List.map simple_copy tyl, copy_class_type cty)
    | Cty_signature sign ->
        Cty_signature
          {csig_self = copy sign.csig_self;
           csig_vars =
             Vars.map (function (m, v, ty) -> (m, v, copy ty)) sign.csig_vars;
           csig_concr = sign.csig_concr;
           csig_inher =
             List.map (fun (p,tl) -> (p, List.map simple_copy tl))
               sign.csig_inher}
    | Cty_arrow (l, ty, cty) ->
        Cty_arrow (l, copy ty, copy_class_type cty)
  in
  let params' = List.map simple_copy params in
  let cty' = copy_class_type cty in
  cleanup_types ();
  (params', cty')

(**** Instanciation for types with free universal variables ****)

let rec diff_list l1 l2 =
  if l1 == l2 then [] else
  match l1 with [] -> invalid_arg "Ctype.diff_list"
  | a :: l1 -> a :: diff_list l1 l2

let conflicts free bound =
  let bound = List.map repr bound in
  TypeSet.exists (fun t -> List.memq (repr t) bound) free

let delayed_copy = ref []
    (* copying to do later *)

(* Copy without sharing until there are no free univars left *)
(* all free univars must be included in [visited]            *)
let rec copy_sep fixed free bound visited ty =
  let ty = repr ty in
  let univars = free ty in
  if TypeSet.is_empty univars then
    if ty.level <> generic_level then ty else
    let t = newvar () in
    delayed_copy :=
      lazy (t.desc <- Tlink (copy ty))
      :: !delayed_copy;
    t
  else try
    let t, bound_t = List.assq ty visited in
    let dl = if is_Tunivar ty then [] else diff_list bound bound_t in
    if dl <> [] && conflicts univars dl then raise Not_found;
    t
  with Not_found -> begin
    let t = newvar() in          (* Stub *)
    let visited =
      match ty.desc with
        Tarrow _ | Ttuple _ | Tvariant _ | Tconstr _ | Tobject _ | Tpackage _ ->
          (ty,(t,bound)) :: visited
      | _ -> visited in
    let copy_rec = copy_sep fixed free bound visited in
    t.desc <-
      begin match ty.desc with
      | Tvariant row0 ->
          let row = row_repr row0 in
          let more = repr row.row_more in
          (* We shall really check the level on the row variable *)
          let keep = is_Tvar more && more.level <> generic_level in
          let more' = copy_rec more in
          let fixed' = fixed && is_Tvar (repr more') in
          let row = copy_row copy_rec fixed' row keep more' in
          Tvariant row
      | Tpoly (t1, tl) ->
          let tl = List.map repr tl in
          let tl' = List.map (fun t -> newty t.desc) tl in
          let bound = tl @ bound in
          let visited =
            List.map2 (fun ty t -> ty,(t,bound)) tl tl' @ visited in
          Tpoly (copy_sep fixed free bound visited t1, tl')
      | _ -> copy_type_desc copy_rec ty.desc
      end;
    t
  end

let instance_poly ?(keep_names=false) fixed univars sch =
  let univars = List.map repr univars in
  let copy_var ty =
    match ty.desc with
      Tunivar name -> if keep_names then newty (Tvar name) else newvar ()
    | _ -> assert false
  in
  let vars = List.map copy_var univars in
  let pairs = List.map2 (fun u v -> u, (v, [])) univars vars in
  delayed_copy := [];
  let ty = copy_sep fixed (compute_univars sch) [] pairs sch in
  List.iter Lazy.force !delayed_copy;
  delayed_copy := [];
  cleanup_types ();
  vars, ty

let instance_label fixed lbl =
  let ty_res = copy lbl.lbl_res in
  let vars, ty_arg =
    match repr lbl.lbl_arg with
      {desc = Tpoly (ty, tl)} ->
        instance_poly fixed tl ty
    | ty ->
        [], copy lbl.lbl_arg
  in
  cleanup_types ();
  (vars, ty_arg, ty_res)

(**** Instantiation with parameter substitution ****)

let unify' = (* Forward declaration *)
  ref (fun env ty1 ty2 -> raise (Unify []))

let subst env level priv abbrev ty params args body =
  if List.length params <> List.length args then raise (Unify []);
  let old_level = !current_level in
  current_level := level;
  try
    let body0 = newvar () in          (* Stub *)
    begin match ty with
      None      -> ()
    | Some ({desc = Tconstr (path, tl, _)} as ty) ->
        let abbrev = proper_abbrevs path tl abbrev in
        memorize_abbrev abbrev priv path ty body0
    | _ ->
        assert false
    end;
    abbreviations := abbrev;
    let (params', body') = instance_parameterized_type params body in
    abbreviations := ref Mnil;
    !unify' env body0 body';
    List.iter2 (!unify' env) params' args;
    current_level := old_level;
    body'
  with Unify _ as exn ->
    current_level := old_level;
    raise exn

(*
   Only the shape of the type matters, not whether is is generic or
   not. [generic_level] might be somewhat slower, but it ensures
   invariants on types are enforced (decreasing levels.), and we don't
   care about efficiency here.
*)
let apply env params body args =
  try
    subst env generic_level Public (ref Mnil) None params args body
  with
    Unify _ -> raise Cannot_apply


                              (****************************)
                              (*  Abbreviation expansion  *)
                              (****************************)

(*
   If the environnement has changed, memorized expansions might not
   be correct anymore, and so we flush the cache. This is safe but
   quite pessimistic: it would be enough to flush the cache when a
   type or module definition is overridden in the environnement.
*)
let previous_env = ref Env.empty
let string_of_kind = function Public -> "public" | Private -> "private"
let check_abbrev_env env =
  if env != !previous_env then begin
    (* prerr_endline "cleanup expansion cache"; *)
    cleanup_abbrev ();
    previous_env := env
  end


(* Expand an abbreviation. The expansion is memorized. *)
(*
   Assume the level is greater than the path binding time of the
   expanded abbreviation.
*)
(*
   An abbreviation expansion will fail in either of these cases:
   1. The type constructor does not correspond to a manifest type.
   2. The type constructor is defined in an external file, and this
      file is not in the path (missing -I options).
   3. The type constructor is not in the "local" environment. This can
      happens when a non-generic type variable has been instantiated
      afterwards to the not yet defined type constructor. (Actually,
      this cannot happen at the moment due to the strong constraints
      between type levels and constructor binding time.)
   4. The expansion requires the expansion of another abbreviation,
      and this other expansion fails.
*)
let expand_abbrev_gen kind find_type_expansion env ty =
  check_abbrev_env env;
  match ty with
    {desc = Tconstr (path, args, abbrev); level = level} ->
      let lookup_abbrev = proper_abbrevs path args abbrev in
      begin match find_expans kind path !lookup_abbrev with
        Some ty ->
          (* prerr_endline
            ("found a "^string_of_kind kind^" expansion for "^Path.name path);*)
          if level <> generic_level then
            begin try
              update_level env level ty
            with Unify _ ->
              (* XXX This should not happen.
                 However, levels are not correctly restored after a
                 typing error *)
              ()
            end;
          ty
      | None ->
          let (params, body, lv) =
            try find_type_expansion path env with Not_found ->
              raise Cannot_expand
          in
          (* prerr_endline
            ("add a "^string_of_kind kind^" expansion for "^Path.name path);*)
          let ty' = subst env level kind abbrev (Some ty) params args body in
          (* Hack to name the variant type *)
          begin match repr ty' with
            {desc=Tvariant row} as ty when static_row row ->
              ty.desc <- Tvariant { row with row_name = Some (path, args) }
          | _ -> ()
          end;
          (* For gadts, remember type as non exportable *)
          (* The ambiguous level registered for ty' should be the highest *)
          if !trace_gadt_instances then begin
            match max lv (Env.gadt_instance_level env ty) with
              None -> ()
            | Some lv ->
                if level < lv then raise (Unify [(ty, newvar2 level)]);
                Env.add_gadt_instances env lv [ty; ty']
          end;
          ty'
      end
  | _ ->
      assert false

(* Expand respecting privacy *)
let expand_abbrev ty =
  expand_abbrev_gen Public Env.find_type_expansion ty

(* Expand once the head of a type *)
let expand_head_once env ty =
  try expand_abbrev env (repr ty) with Cannot_expand -> assert false

(* Check whether a type can be expanded *)
let safe_abbrev env ty =
  let snap = Btype.snapshot () in
  try ignore (expand_abbrev env ty); true
  with Cannot_expand | Unify _ ->
    Btype.backtrack snap;
    false

(* Expand the head of a type once.
   Raise Cannot_expand if the type cannot be expanded.
   May raise Unify, if a recursion was hidden in the type. *)
let try_expand_once env ty =
  let ty = repr ty in
  match ty.desc with
    Tconstr (p, _, _) -> repr (expand_abbrev env ty)
  | _ -> raise Cannot_expand

(* This one only raises Cannot_expand *)
let try_expand_safe env ty =
  let snap = Btype.snapshot () in
  try try_expand_once env ty
  with Unify _ ->
    Btype.backtrack snap; raise Cannot_expand

(* Fully expand the head of a type. *)
let rec try_expand_head try_once env ty =
  let ty' = try_once env ty in
  try try_expand_head try_once env ty'
  with Cannot_expand -> ty'

let try_expand_head try_once env ty =
  let ty' = try_expand_head try_once env ty in
  begin match Env.gadt_instance_level env ty' with
    None -> ()
  | Some lv -> Env.add_gadt_instance_chain env lv ty
  end;
  ty'

(* Unsafe full expansion, may raise Unify. *)
let expand_head_unif env ty =
  try try_expand_head try_expand_once env ty with Cannot_expand -> repr ty

(* Safe version of expand_head, never fails *)
let expand_head env ty =
  try try_expand_head try_expand_safe env ty with Cannot_expand -> repr ty

let _ = forward_try_expand_once := try_expand_safe


(* Expand until we find a non-abstract type declaration *)

let rec extract_concrete_typedecl env ty =
  let ty = repr ty in
  match ty.desc with
    Tconstr (p, _, _) ->
      let decl = Env.find_type p env in
      if decl.type_kind <> Type_abstract then (p, p, decl) else
      let ty =
        try try_expand_once env ty with Cannot_expand -> raise Not_found
      in
      let (_, p', decl) = extract_concrete_typedecl env ty in
        (p, p', decl)
  | _ -> raise Not_found

(* Implementing function [expand_head_opt], the compiler's own version of
   [expand_head] used for type-based optimisations.
   [expand_head_opt] uses [Env.find_type_expansion_opt] to access the
   manifest type information of private abstract data types which is
   normally hidden to the type-checker out of the implementation module of
   the private abbreviation. *)

let expand_abbrev_opt =
  expand_abbrev_gen Private Env.find_type_expansion_opt

let try_expand_once_opt env ty =
  let ty = repr ty in
  match ty.desc with
    Tconstr _ -> repr (expand_abbrev_opt env ty)
  | _ -> raise Cannot_expand

let rec try_expand_head_opt env ty =
  let ty' = try_expand_once_opt env ty in
  begin try
    try_expand_head_opt env ty'
  with Cannot_expand ->
    ty'
  end

let expand_head_opt env ty =
  let snap = Btype.snapshot () in
  try try_expand_head_opt env ty
  with Cannot_expand | Unify _ -> (* expand_head shall never fail *)
    Btype.backtrack snap;
    repr ty

(* Make sure that the type parameters of the type constructor [ty]
   respect the type constraints *)
let enforce_constraints env ty =
  match ty with
    {desc = Tconstr (path, args, abbrev); level = level} ->
      begin try
        let decl = Env.find_type path env in
        ignore
          (subst env level Public (ref Mnil) None decl.type_params args
             (newvar2 level))
      with Not_found -> ()
      end
  | _ ->
      assert false

(* Recursively expand the head of a type.
   Also expand #-types. *)
let full_expand env ty =
  let ty = repr (expand_head env ty) in
  match ty.desc with
    Tobject (fi, {contents = Some (_, v::_)}) when is_Tvar (repr v) ->
      newty2 ty.level (Tobject (fi, ref None))
  | _ ->
      ty

(*
   Check whether the abbreviation expands to a well-defined type.
   During the typing of a class, abbreviations for correspondings
   types expand to non-generic types.
*)
let generic_abbrev env path =
  try
    let (_, body, _) = Env.find_type_expansion path env in
    (repr body).level = generic_level
  with
    Not_found ->
      false

let generic_private_abbrev env path =
  try
    match Env.find_type path env with
      {type_kind = Type_abstract;
       type_private = Private;
       type_manifest = Some body} ->
         (repr body).level = generic_level
    | _ -> false
  with Not_found -> false

let is_contractive env ty =
  match (repr ty).desc with
    Tconstr (p, _, _) ->
      in_pervasives p ||
      (try is_datatype (Env.find_type p env) with Not_found -> false)
  | _ -> true

(* Code moved to Typedecl

(* The marks are already used by [expand_abbrev]... *)
let visited = ref []

let rec non_recursive_abbrev env ty0 ty =
  let ty = repr ty in
  if ty == repr ty0 then raise Recursive_abbrev;
  if not (List.memq ty !visited) then begin
    visited := ty :: !visited;
    match ty.desc with
      Tconstr(p, args, abbrev) ->
        begin try
          non_recursive_abbrev env ty0 (try_expand_once_opt env ty)
        with Cannot_expand ->
          if !Clflags.recursive_types &&
            (in_pervasives p ||
             try is_datatype (Env.find_type p env) with Not_found -> false)
          then ()
          else iter_type_expr (non_recursive_abbrev env ty0) ty
        end
    | Tobject _ | Tvariant _ ->
        ()
    | _ ->
        if !Clflags.recursive_types then () else
        iter_type_expr (non_recursive_abbrev env ty0) ty
  end

let correct_abbrev env path params ty =
  check_abbrev_env env;
  let ty0 = newgenvar () in
  visited := [];
  let abbrev = Mcons (Public, path, ty0, ty0, Mnil) in
  simple_abbrevs := abbrev;
  try
    non_recursive_abbrev env ty0
      (subst env generic_level Public (ref abbrev) None [] [] ty);
    simple_abbrevs := Mnil;
    visited := []
  with exn ->
    simple_abbrevs := Mnil;
    visited := [];
    raise exn
*)

                              (*****************)
                              (*  Occur check  *)
                              (*****************)


exception Occur

let rec occur_rec env visited ty0 ty =
  if ty == ty0  then raise Occur;
  let occur_ok = !Clflags.recursive_types && is_contractive env ty in
  match ty.desc with
    Tconstr(p, tl, abbrev) ->
      begin try
        if occur_ok || List.memq ty visited then raise Occur;
        iter_type_expr (occur_rec env (ty::visited) ty0) ty
      with Occur -> try
        let ty' = try_expand_head try_expand_once env ty in
        (* Maybe we could simply make a recursive call here,
           but it seems it could make the occur check loop
           (see change in rev. 1.58) *)
        if ty' == ty0 || List.memq ty' visited then raise Occur;
        match ty'.desc with
          Tobject _ | Tvariant _ -> ()
        | _ ->
            if not (!Clflags.recursive_types && is_contractive env ty') then
              iter_type_expr (occur_rec env (ty'::visited) ty0) ty'
      with Cannot_expand ->
        if not occur_ok then raise Occur
      end
  | Tobject _ | Tvariant _ ->
      ()
  | _ ->
      if not occur_ok then
        iter_type_expr (occur_rec env visited ty0) ty

let type_changed = ref false (* trace possible changes to the studied type *)

let merge r b = if b then r := true

let occur env ty0 ty =
  let old = !type_changed in
  try
    while type_changed := false; occur_rec env [] ty0 ty; !type_changed
    do () (* prerr_endline "changed" *) done;
    merge type_changed old
  with exn ->
    merge type_changed old;
    raise (match exn with Occur -> Unify [] | _ -> exn)

let occur_in env ty0 t =
  try occur env ty0 t; false with Unify _ -> true

(* Check that a local constraint is well-founded *)
(* PR#6405: not needed since we allow recursion and work on normalized types *)
(*
let rec local_non_recursive_abbrev visited env p ty =
  let ty = repr ty in
  if not (List.memq ty !visited) then begin
    visited := ty :: !visited;
    match ty.desc with
      Tconstr(p', args, abbrev) ->
        if Path.same p p' then raise Recursive_abbrev;
        begin try
          local_non_recursive_abbrev visited env p (try_expand_once_opt env ty)
        with Cannot_expand -> ()
        end
    | _ -> ()
  end

let local_non_recursive_abbrev env p =
  local_non_recursive_abbrev (ref []) env p
*)

                   (*****************************)
                   (*  Polymorphic Unification  *)
                   (*****************************)

(* Since we cannot duplicate universal variables, unification must
   be done at meta-level, using bindings in univar_pairs *)
let rec unify_univar t1 t2 = function
    (cl1, cl2) :: rem ->
      let find_univ t cl =
        try
          let (_, r) = List.find (fun (t',_) -> t == repr t') cl in
          Some r
        with Not_found -> None
      in
      begin match find_univ t1 cl1, find_univ t2 cl2 with
        Some {contents=Some t'2}, Some _ when t2 == repr t'2 ->
          ()
      | Some({contents=None} as r1), Some({contents=None} as r2) ->
          set_univar r1 t2; set_univar r2 t1
      | None, None ->
          unify_univar t1 t2 rem
      | _ ->
          raise (Unify [])
      end
  | [] -> raise (Unify [])

(* Test the occurence of free univars in a type *)
(* that's way too expansive. Must do some kind of cacheing *)
let occur_univar env ty =
  let visited = ref TypeMap.empty in
  let rec occur_rec bound ty =
    let ty = repr ty in
    if ty.level >= lowest_level &&
      if TypeSet.is_empty bound then
        (ty.level <- pivot_level - ty.level; true)
      else try
        let bound' = TypeMap.find ty !visited in
        if TypeSet.exists (fun x -> not (TypeSet.mem x bound)) bound' then
          (visited := TypeMap.add ty (TypeSet.inter bound bound') !visited;
           true)
        else false
      with Not_found ->
        visited := TypeMap.add ty bound !visited;
        true
    then
      match ty.desc with
        Tunivar _ ->
          if not (TypeSet.mem ty bound) then raise (Unify [ty, newgenvar ()])
      | Tpoly (ty, tyl) ->
          let bound = List.fold_right TypeSet.add (List.map repr tyl) bound in
          occur_rec bound  ty
      | Tconstr (_, [], _) -> ()
      | Tconstr (p, tl, _) ->
          begin try
            let td = Env.find_type p env in
            List.iter2
              (fun t v ->
                if Variance.(mem May_pos v || mem May_neg v)
                then occur_rec bound t)
              tl td.type_variance
          with Not_found ->
            List.iter (occur_rec bound) tl
          end
      | _ -> iter_type_expr (occur_rec bound) ty
  in
  try
    occur_rec TypeSet.empty ty; unmark_type ty
  with exn ->
    unmark_type ty; raise exn

(* Grouping univars by families according to their binders *)
let add_univars =
  List.fold_left (fun s (t,_) -> TypeSet.add (repr t) s)

let get_univar_family univar_pairs univars =
  if univars = [] then TypeSet.empty else
  let insert s = function
      cl1, (_::_ as cl2) ->
        if List.exists (fun (t1,_) -> TypeSet.mem (repr t1) s) cl1 then
          add_univars s cl2
        else s
    | _ -> s
  in
  let s = List.fold_right TypeSet.add univars TypeSet.empty in
  List.fold_left insert s univar_pairs

(* Whether a family of univars escapes from a type *)
let univars_escape env univar_pairs vl ty =
  let family = get_univar_family univar_pairs vl in
  let visited = ref TypeSet.empty in
  let rec occur t =
    let t = repr t in
    if TypeSet.mem t !visited then () else begin
      visited := TypeSet.add t !visited;
      match t.desc with
        Tpoly (t, tl) ->
          if List.exists (fun t -> TypeSet.mem (repr t) family) tl then ()
          else occur t
      | Tunivar _ ->
          if TypeSet.mem t family then raise Occur
      | Tconstr (_, [], _) -> ()
      | Tconstr (p, tl, _) ->
          begin try
            let td = Env.find_type p env in
            List.iter2
              (fun t v ->
                if Variance.(mem May_pos v || mem May_neg v) then occur t)
              tl td.type_variance
          with Not_found ->
            List.iter occur tl
          end
      | _ ->
          iter_type_expr occur t
    end
  in
  try occur ty; false with Occur -> true

(* Wrapper checking that no variable escapes and updating univar_pairs *)
let enter_poly env univar_pairs t1 tl1 t2 tl2 f =
  let old_univars = !univar_pairs in
  let known_univars =
    List.fold_left (fun s (cl,_) -> add_univars s cl)
      TypeSet.empty old_univars
  in
  let tl1 = List.map repr tl1 and tl2 = List.map repr tl2 in
  if List.exists (fun t -> TypeSet.mem t known_univars) tl1 &&
    univars_escape env old_univars tl1 (newty(Tpoly(t2,tl2)))
  || List.exists (fun t -> TypeSet.mem t known_univars) tl2 &&
    univars_escape env old_univars tl2 (newty(Tpoly(t1,tl1)))
  then raise (Unify []);
  let cl1 = List.map (fun t -> t, ref None) tl1
  and cl2 = List.map (fun t -> t, ref None) tl2 in
  univar_pairs := (cl1,cl2) :: (cl2,cl1) :: old_univars;
  try let res = f t1 t2 in univar_pairs := old_univars; res
  with exn -> univar_pairs := old_univars; raise exn

let univar_pairs = ref []


                              (*****************)
                              (*  Unification  *)
                              (*****************)



let rec has_cached_expansion p abbrev =
  match abbrev with
    Mnil                   -> false
  | Mcons(_, p', _, _, rem)   -> Path.same p p' || has_cached_expansion p rem
  | Mlink rem              -> has_cached_expansion p !rem

(**** Transform error trace ****)
(* +++ Move it to some other place ? *)

let expand_trace env trace =
  List.fold_right
    (fun (t1, t2) rem ->
       (repr t1, full_expand env t1)::(repr t2, full_expand env t2)::rem)
    trace []

(* build a dummy variant type *)
let mkvariant fields closed =
  newgenty
    (Tvariant
       {row_fields = fields; row_closed = closed; row_more = newvar();
        row_bound = (); row_fixed = false; row_name = None })

(* force unification in Reither when one side has as non-conjunctive type *)
let rigid_variants = ref false

(**** Unification ****)

(* Return whether [t0] occurs in [ty]. Objects are also traversed. *)
let deep_occur t0 ty =
  let rec occur_rec ty =
    let ty = repr ty in
    if ty.level >= lowest_level then begin
      if ty == t0 then raise Occur;
      ty.level <- pivot_level - ty.level;
      iter_type_expr occur_rec ty
    end
  in
  try
    occur_rec ty; unmark_type ty; false
  with Occur ->
    unmark_type ty; true

(*
   1. When unifying two non-abbreviated types, one type is made a link
      to the other. When unifying an abbreviated type with a
      non-abbreviated type, the non-abbreviated type is made a link to
      the other one. When unifying to abbreviated types, these two
      types are kept distincts, but they are made to (temporally)
      expand to the same type.
   2. Abbreviations with at least one parameter are systematically
      expanded. The overhead does not seem to high, and that way
      abbreviations where some parameters does not appear in the
      expansion, such as ['a t = int], are correctly handled. In
      particular, for this example, unifying ['a t] with ['b t] keeps
      ['a] and ['b] distincts. (Is it really important ?)
   3. Unifying an abbreviation ['a t = 'a] with ['a] should not yield
      ['a t as 'a]. Indeed, the type variable would otherwise be lost.
      This problem occurs for abbreviations expanding to a type
      variable, but also to many other constrained abbreviations (for
      instance, [(< x : 'a > -> unit) t = <x : 'a>]). The solution is
      that, if an abbreviation is unified with some subpart of its
      parameters, then the parameter actually does not get
      abbreviated.  It would be possible to check whether some
      information is indeed lost, but it probably does not worth it.
*)

let newtype_level = ref None

let get_newtype_level () =
  match !newtype_level with
  | None -> assert false
  | Some x -> x

(* a local constraint can be added only if the rhs
   of the constraint does not contain any Tvars.
   They need to be removed using this function *)
let reify env t =
  let newtype_level = get_newtype_level () in
  let create_fresh_constr lev name =
    let decl = new_declaration (Some (newtype_level, newtype_level)) None in
    let name = get_new_abstract_name name in
    let (id, new_env) = Env.enter_type name decl !env in
    let t = newty2 lev (Tconstr (Path.Pident id,[],ref Mnil))  in
    env := new_env;
    t
  in
  let visited = ref TypeSet.empty in
  let rec iterator ty =
    let ty = repr ty in
    if TypeSet.mem ty !visited then () else begin
      visited := TypeSet.add ty !visited;
      match ty.desc with
        Tvar o ->
          let name = match o with Some s -> s | _ -> "ex" in
          let t = create_fresh_constr ty.level name in
          link_type ty t
      | Tvariant r ->
          let r = row_repr r in
          if not (static_row r) then begin
            if r.row_fixed then iterator (row_more r) else
            let m = r.row_more in
            match m.desc with
              Tvar o ->
                let name = match o with Some s -> s | _ -> "ex" in
                let t = create_fresh_constr m.level name in
                let row =
                  {r with row_fields=[]; row_fixed=true; row_more = t} in
                link_type m (newty2 m.level (Tvariant row))
            | _ -> assert false
          end;
          iter_row iterator r
      | Tconstr (p, _, _) when is_object_type p ->
          iter_type_expr iterator (full_expand !env ty)
      | _ ->
          iter_type_expr iterator ty
    end
  in
  iterator t

let is_newtype env p =
  try
    let decl = Env.find_type p env in
    decl.type_newtype_level <> None &&
    decl.type_kind = Type_abstract &&
    decl.type_private = Public
  with Not_found -> false

let non_aliasable p decl =
  (* in_pervasives p ||  (subsumed by in_current_module) *)
  in_current_module p && decl.type_newtype_level = None

(* Check for datatypes carefully; see PR#6348 *)
let rec expands_to_datatype env ty =
  let ty = repr ty in
  match ty.desc with
    Tconstr (p, _, _) ->
      begin try
        is_datatype (Env.find_type p env) ||
        expands_to_datatype env (try_expand_once env ty)
      with Not_found | Cannot_expand -> false
      end
  | _ -> false

(* mcomp type_pairs subst env t1 t2 does not raise an
   exception if it is possible that t1 and t2 are actually
   equal, assuming the types in type_pairs are equal and
   that the mapping subst holds.
   Assumes that both t1 and t2 do not contain any tvars
   and that both their objects and variants are closed
 *)

let rec mcomp type_pairs env t1 t2 =
  if t1 == t2 then () else
  let t1 = repr t1 in
  let t2 = repr t2 in
  if t1 == t2 then () else
  match (t1.desc, t2.desc) with
  | (Tvar _, _)
  | (_, Tvar _)  ->
      ()
  | (Tconstr (p1, [], _), Tconstr (p2, [], _)) when Path.same p1 p2 ->
      ()
  | _ ->
      let t1' = expand_head_opt env t1 in
      let t2' = expand_head_opt env t2 in
      (* Expansion may have changed the representative of the types... *)
      let t1' = repr t1' and t2' = repr t2' in
      if t1' == t2' then () else
      begin try TypePairs.find type_pairs (t1', t2')
      with Not_found ->
        TypePairs.add type_pairs (t1', t2') ();
        match (t1'.desc, t2'.desc) with
          (Tvar _, Tvar _) -> assert false
        | (Tarrow (l1, t1, u1, _), Tarrow (l2, t2, u2, _))
          when l1 = l2 || not (is_optional l1 || is_optional l2) ->
            mcomp type_pairs env t1 t2;
            mcomp type_pairs env u1 u2;
        | (Ttuple tl1, Ttuple tl2) ->
            mcomp_list type_pairs env tl1 tl2
        | (Tconstr (p1, tl1, _), Tconstr (p2, tl2, _)) ->
            mcomp_type_decl type_pairs env p1 p2 tl1 tl2
        | (Tconstr (p, _, _), _) | (_, Tconstr (p, _, _)) ->
            begin try
              let decl = Env.find_type p env in
              if non_aliasable p decl || is_datatype decl then raise (Unify [])
            with Not_found -> ()
            end
        (*
        | (Tpackage (p1, n1, tl1), Tpackage (p2, n2, tl2)) when n1 = n2 ->
            mcomp_list type_pairs env tl1 tl2
        *)
        | (Tpackage _, Tpackage _) -> ()
        | (Tvariant row1, Tvariant row2) ->
            mcomp_row type_pairs env row1 row2
        | (Tobject (fi1, _), Tobject (fi2, _)) ->
            mcomp_fields type_pairs env fi1 fi2
        | (Tfield _, Tfield _) ->       (* Actually unused *)
            mcomp_fields type_pairs env t1' t2'
        | (Tnil, Tnil) ->
            ()
        | (Tpoly (t1, []), Tpoly (t2, [])) ->
            mcomp type_pairs env t1 t2
        | (Tpoly (t1, tl1), Tpoly (t2, tl2)) ->
            enter_poly env univar_pairs t1 tl1 t2 tl2
              (mcomp type_pairs env)
        | (Tunivar _, Tunivar _) ->
            unify_univar t1' t2' !univar_pairs
        | (_, _) ->
            raise (Unify [])
      end

and mcomp_list type_pairs env tl1 tl2 =
  if List.length tl1 <> List.length tl2 then
    raise (Unify []);
  List.iter2 (mcomp type_pairs env) tl1 tl2

and mcomp_fields type_pairs env ty1 ty2 =
  if not (concrete_object ty1 && concrete_object ty2) then assert false;
  let (fields2, rest2) = flatten_fields ty2 in
  let (fields1, rest1) = flatten_fields ty1 in
  let (pairs, miss1, miss2) = associate_fields fields1 fields2 in
  mcomp type_pairs env rest1 rest2;
  if miss1 <> []  && (object_row ty1).desc = Tnil
  || miss2 <> []  && (object_row ty2).desc = Tnil then raise (Unify []);
  List.iter
    (function (n, k1, t1, k2, t2) ->
       mcomp_kind k1 k2;
       mcomp type_pairs env t1 t2)
    pairs

and mcomp_kind k1 k2 =
  let k1 = field_kind_repr k1 in
  let k2 = field_kind_repr k2 in
  match k1, k2 with
    (Fvar _, Fvar _)
  | (Fpresent, Fpresent) -> ()
  | _                    -> raise (Unify [])

and mcomp_row type_pairs env row1 row2 =
  let row1 = row_repr row1 and row2 = row_repr row2 in
  let r1, r2, pairs = merge_row_fields row1.row_fields row2.row_fields in
  let cannot_erase (_,f) =
    match row_field_repr f with
      Rpresent _ -> true
    | Rabsent | Reither _ -> false
  in
  if row1.row_closed && List.exists cannot_erase r2
  || row2.row_closed && List.exists cannot_erase r1 then raise (Unify []);
  List.iter
    (fun (_,f1,f2) ->
      match row_field_repr f1, row_field_repr f2 with
      | Rpresent None, (Rpresent (Some _) | Reither (_, _::_, _, _) | Rabsent)
      | Rpresent (Some _), (Rpresent None | Reither (true, _, _, _) | Rabsent)
      | (Reither (_, _::_, _, _) | Rabsent), Rpresent None
      | (Reither (true, _, _, _) | Rabsent), Rpresent (Some _) ->
          raise (Unify [])
      | Rpresent(Some t1), Rpresent(Some t2) ->
          mcomp type_pairs env t1 t2
      | Rpresent(Some t1), Reither(false, tl2, _, _) ->
          List.iter (mcomp type_pairs env t1) tl2
      | Reither(false, tl1, _, _), Rpresent(Some t2) ->
          List.iter (mcomp type_pairs env t2) tl1
      | _ -> ())
    pairs

and mcomp_type_decl type_pairs env p1 p2 tl1 tl2 =
  try
    let decl = Env.find_type p1 env in
    let decl' = Env.find_type p2 env in
    if Path.same p1 p2 then begin
      let inj =
        try List.map Variance.(mem Inj) (Env.find_type p1 env).type_variance
        with Not_found -> List.map (fun _ -> false) tl1
      in
      List.iter2
        (fun i (t1,t2) -> if i then mcomp type_pairs env t1 t2)
        inj (List.combine tl1 tl2)
    end else if non_aliasable p1 decl && non_aliasable p2 decl' then
      raise (Unify [])
    else
      match decl.type_kind, decl'.type_kind with
      | Type_record (lst,r), Type_record (lst',r') when r = r' ->
          mcomp_list type_pairs env tl1 tl2;
          mcomp_record_description type_pairs env lst lst'
      | Type_variant v1, Type_variant v2 ->
          mcomp_list type_pairs env tl1 tl2;
          mcomp_variant_description type_pairs env v1 v2
      | Type_open, Type_open ->
          mcomp_list type_pairs env tl1 tl2
      | Type_abstract, Type_abstract -> ()
      | Type_abstract, _ when not (non_aliasable p1 decl)-> ()
      | _, Type_abstract when not (non_aliasable p2 decl') -> ()
      | _ -> raise (Unify [])
  with Not_found -> ()

and mcomp_type_option type_pairs env t t' =
  match t, t' with
    None, None -> ()
  | Some t, Some t' -> mcomp type_pairs env t t'
  | _ -> raise (Unify [])

and mcomp_variant_description type_pairs env xs ys =
  let rec iter = fun x y ->
    match x, y with
    | c1 :: xs, c2 :: ys   ->
      mcomp_type_option type_pairs env c1.cd_res c2.cd_res;
      mcomp_list type_pairs env c1.cd_args c2.cd_args;
     if Ident.name c1.cd_id = Ident.name c2.cd_id
      then iter xs ys
      else raise (Unify [])
    | [],[] -> ()
    | _ -> raise (Unify [])
  in
  iter xs ys

and mcomp_record_description type_pairs env =
  let rec iter x y =
    match x, y with
    | l1 :: xs, l2 :: ys ->
        mcomp type_pairs env l1.ld_type l2.ld_type;
        if Ident.name l1.ld_id = Ident.name l2.ld_id &&
           l1.ld_mutable = l2.ld_mutable
        then iter xs ys
        else raise (Unify [])
    | [], [] -> ()
    | _ -> raise (Unify [])
  in
  iter

let mcomp env t1 t2 =
  mcomp (TypePairs.create 4) env t1 t2

(* Real unification *)

let find_lowest_level ty =
  let lowest = ref generic_level in
  let rec find ty =
    let ty = repr ty in
    if ty.level >= lowest_level then begin
      if ty.level < !lowest then lowest := ty.level;
      ty.level <- pivot_level - ty.level;
      iter_type_expr find ty
    end
  in find ty; unmark_type ty; !lowest

let find_newtype_level env path =
  try match (Env.find_type path env).type_newtype_level with
    Some x -> x
  | None -> assert false
  with Not_found -> assert false

let add_gadt_equation env source destination =
  let destination = duplicate_type destination in
  let source_lev = find_newtype_level !env (Path.Pident source) in
  let decl = new_declaration (Some source_lev) (Some destination) in
  let newtype_level = get_newtype_level () in
  env := Env.add_local_constraint source decl newtype_level !env;
  cleanup_abbrev ()

let unify_eq_set = TypePairs.create 11

let order_type_pair t1 t2 =
  if t1.id <= t2.id then (t1, t2) else (t2, t1)

let add_type_equality t1 t2 =
  TypePairs.add unify_eq_set (order_type_pair t1 t2) ()

let eq_package_path env p1 p2 =
  Path.same p1 p2 ||
  Path.same (normalize_package_path env p1) (normalize_package_path env p2)

let nondep_type' = ref (fun _ _ _ -> assert false)
let package_subtype = ref (fun _ _ _ _ _ _ _ -> assert false)

let rec concat_longident lid1 =
  let open Longident in
  function
    Lident s -> Ldot (lid1, s)
  | Ldot (lid2, s) -> Ldot (concat_longident lid1 lid2, s)
  | Lapply (lid2, lid) -> Lapply (concat_longident lid1 lid2, lid)

let nondep_instance env level id ty =
  let ty = !nondep_type' env id ty in
  if level = generic_level then duplicate_type ty else
  let old = !current_level in
  current_level := level;
  let ty = instance env ty in
  current_level := old;
  ty

(* Find the type paths nl1 in the module type mty2, and add them to the
   list (nl2, tl2). raise Not_found if impossible *)
let complete_type_list ?(allow_absent=false) env nl1 lv2 mty2 nl2 tl2 =
  let id2 = Ident.create "Pkg" in
  let env' = Env.add_module id2 mty2 env in
  let rec complete nl1 ntl2 =
    match nl1, ntl2 with
      [], _ -> ntl2
    | n :: nl, (n2, _ as nt2) :: ntl' when n >= n2 ->
        nt2 :: complete (if n = n2 then nl else nl1) ntl'
    | n :: nl, _ ->
        try
          let (_, decl) =
            Env.lookup_type (concat_longident (Longident.Lident "Pkg") n) env'
          in
          match decl with
            {type_arity = 0; type_kind = Type_abstract;
             type_private = Public; type_manifest = Some t2} ->
               (n, nondep_instance env' lv2 id2 t2) :: complete nl ntl2
          | {type_arity = 0; type_kind = Type_abstract;
             type_private = Public; type_manifest = None} when allow_absent ->
               complete nl ntl2
          | _ -> raise Exit
        with
        | Not_found when allow_absent -> complete nl ntl2
        | Exit -> raise Not_found
  in
  complete nl1 (List.combine nl2 tl2)

(* raise Not_found rather than Unify if the module types are incompatible *)
let unify_package env unify_list lv1 p1 n1 tl1 lv2 p2 n2 tl2 =
  let ntl2 = complete_type_list env n1 lv2 (Mty_ident p2) n2 tl2
  and ntl1 = complete_type_list env n2 lv2 (Mty_ident p1) n1 tl1 in
  unify_list (List.map snd ntl1) (List.map snd ntl2);
  if eq_package_path env p1 p2
  || !package_subtype env p1 n1 tl1 p2 n2 tl2
  && !package_subtype env p2 n2 tl2 p1 n1 tl1 then () else raise Not_found


let unify_eq env t1 t2 =
  t1 == t2 ||
  match !umode with
  | Expression -> false
  | Pattern ->
      try TypePairs.find unify_eq_set (order_type_pair t1 t2); true
      with Not_found -> false

let rec unify (env:Env.t ref) t1 t2 =
  (* First step: special cases (optimizations) *)
  if t1 == t2 then () else
  let t1 = repr t1 in
  let t2 = repr t2 in
  if unify_eq !env t1 t2 then () else
  let reset_tracing = check_trace_gadt_instances !env in

  try
    type_changed := true;
    begin match (t1.desc, t2.desc) with
      (Tvar _, Tconstr _) when deep_occur t1 t2 ->
        unify2 env t1 t2
    | (Tconstr _, Tvar _) when deep_occur t2 t1 ->
        unify2 env t1 t2
    | (Tvar _, _) ->
        occur !env t1 t2;
        occur_univar !env t2;
        link_type t1 t2;
        update_level !env t1.level t2
    | (_, Tvar _) ->
        occur !env t2 t1;
        occur_univar !env t1;
        link_type t2 t1;
        update_level !env t2.level t1
    | (Tunivar _, Tunivar _) ->
        unify_univar t1 t2 !univar_pairs;
        update_level !env t1.level t2;
        link_type t1 t2
    | (Tconstr (p1, [], a1), Tconstr (p2, [], a2))
          when Path.same p1 p2 (* && actual_mode !env = Old *)
            (* This optimization assumes that t1 does not expand to t2
               (and conversely), so we fall back to the general case
               when any of the types has a cached expansion. *)
            && not (has_cached_expansion p1 !a1
                 || has_cached_expansion p2 !a2) ->
        update_level !env t1.level t2;
        link_type t1 t2
    | (Tconstr (p1, [], _), Tconstr (p2, [], _))
      when Env.has_local_constraints !env
      && is_newtype !env p1 && is_newtype !env p2 ->
        (* Do not use local constraints more than necessary *)
        begin try
          if find_newtype_level !env p1 < find_newtype_level !env p2 then
            unify env t1 (try_expand_once !env t2)
          else
            unify env (try_expand_once !env t1) t2
        with Cannot_expand ->
          unify2 env t1 t2
        end
    | _ ->
        unify2 env t1 t2
    end;
    reset_trace_gadt_instances reset_tracing;
  with Unify trace ->
    reset_trace_gadt_instances reset_tracing;
    raise (Unify ((t1, t2)::trace))

and unify2 env t1 t2 =
  (* Second step: expansion of abbreviations *)
  let rec expand_both t1'' t2'' =
    let t1' = expand_head_unif !env t1 in
    let t2' = expand_head_unif !env t2 in
    (* Expansion may have changed the representative of the types... *)
    if unify_eq !env t1' t1'' && unify_eq !env t2' t2'' then (t1',t2') else
    expand_both t1' t2'
  in
  let t1', t2' = expand_both t1 t2 in
  let lv = min t1'.level t2'.level in
  update_level !env lv t2;
  update_level !env lv t1;
  if unify_eq !env t1' t2' then () else

  let t1 = repr t1 and t2 = repr t2 in
  if !trace_gadt_instances then begin
    (* All types in chains already have the same ambiguity levels *)
    let ilevel t =
      match Env.gadt_instance_level !env t with None -> 0 | Some lv -> lv in
    let lv1 = ilevel t1 and lv2 = ilevel t2 in
    if lv1 > lv2 then Env.add_gadt_instance_chain !env lv1 t2 else
    if lv2 > lv1 then Env.add_gadt_instance_chain !env lv2 t1
  end;
  let t1, t2 =
    if !Clflags.principal
    && (find_lowest_level t1' < lv || find_lowest_level t2' < lv) then
      (* Expand abbreviations hiding a lower level *)
      (* Should also do it for parameterized types, after unification... *)
      (match t1.desc with Tconstr (_, [], _) -> t1' | _ -> t1),
      (match t2.desc with Tconstr (_, [], _) -> t2' | _ -> t2)
    else (t1, t2)
  in
  if unify_eq !env t1 t1' || not (unify_eq !env t2 t2') then
    unify3 env t1 t1' t2 t2'
  else
    try unify3 env t2 t2' t1 t1' with Unify trace ->
      raise (Unify (List.map (fun (x, y) -> (y, x)) trace))

and unify3 env t1 t1' t2 t2' =
  (* Third step: truly unification *)
  (* Assumes either [t1 == t1'] or [t2 != t2'] *)
  let d1 = t1'.desc and d2 = t2'.desc in
  let create_recursion = (t2 != t2') && (deep_occur t1' t2) in

  begin match (d1, d2) with (* handle vars and univars specially *)
    (Tunivar _, Tunivar _) ->
      unify_univar t1' t2' !univar_pairs;
      link_type t1' t2'
  | (Tvar _, _) ->
      occur !env t1' t2;
      occur_univar !env t2;
      link_type t1' t2;
  | (_, Tvar _) ->
      occur !env t2' t1;
      occur_univar !env t1;
      link_type t2' t1;
  | (Tfield _, Tfield _) -> (* special case for GADTs *)
      unify_fields env t1' t2'
  | _ ->
    begin match !umode with
    | Expression ->
        occur !env t1' t2';
        link_type t1' t2
    | Pattern ->
        add_type_equality t1' t2'
    end;
    try
      begin match (d1, d2) with
        (Tarrow (l1, t1, u1, c1), Tarrow (l2, t2, u2, c2)) when l1 = l2 ||
        !Clflags.classic && not (is_optional l1 || is_optional l2) ->
          unify  env t1 t2; unify env  u1 u2;
          begin match commu_repr c1, commu_repr c2 with
            Clink r, c2 -> set_commu r c2
          | c1, Clink r -> set_commu r c1
          | _ -> ()
          end
      | (Ttuple tl1, Ttuple tl2) ->
          unify_list env tl1 tl2
      | (Tconstr (p1, tl1, _), Tconstr (p2, tl2, _)) when Path.same p1 p2 ->
          if !umode = Expression || not !generate_equations then
            unify_list env tl1 tl2
          else if !assume_injective then
            set_mode_pattern ~generate:true ~injective:false
                             (fun () -> unify_list env tl1 tl2)
          else if in_current_module p1 (* || in_pervasives p1 *)
                  || List.exists (expands_to_datatype !env) [t1'; t1; t2] then
            unify_list env tl1 tl2
          else
            let inj =
              try List.map Variance.(mem Inj)
                    (Env.find_type p1 !env).type_variance
              with Not_found -> List.map (fun _ -> false) tl1
            in
            List.iter2
              (fun i (t1, t2) ->
                if i then unify env t1 t2 else
                set_mode_pattern ~generate:false ~injective:false
                  begin fun () ->
                    let snap = snapshot () in
                    try unify env t1 t2 with Unify _ ->
                      backtrack snap;
                      reify env t1; reify env t2
                  end)
              inj (List.combine tl1 tl2)
      | (Tconstr ((Path.Pident p) as path,[],_),
         Tconstr ((Path.Pident p') as path',[],_))
        when is_newtype !env path && is_newtype !env path'
        && !generate_equations ->
          let source,destination =
            if find_newtype_level !env path > find_newtype_level !env path'
            then  p,t2'
            else  p',t1'
          in add_gadt_equation env source destination
      | (Tconstr ((Path.Pident p) as path,[],_), _)
        when is_newtype !env path && !generate_equations ->
          reify env t2';
          (* local_non_recursive_abbrev !env (Path.Pident p) t2'; *)
          add_gadt_equation env p t2'
      | (_, Tconstr ((Path.Pident p) as path,[],_))
        when is_newtype !env path && !generate_equations ->
          reify env t1' ;
          (* local_non_recursive_abbrev !env (Path.Pident p) t1'; *)
          add_gadt_equation env p t1'
      | (Tconstr (_,_,_), _) | (_, Tconstr (_,_,_)) when !umode = Pattern ->
          reify env t1';
          reify env t2';
          if !generate_equations then mcomp !env t1' t2'
      | (Tobject (fi1, nm1), Tobject (fi2, _)) ->
          unify_fields env fi1 fi2;
          (* Type [t2'] may have been instantiated by [unify_fields] *)
          (* XXX One should do some kind of unification... *)
          begin match (repr t2').desc with
            Tobject (_, {contents = Some (_, va::_)}) when
              (match (repr va).desc with
                Tvar _|Tunivar _|Tnil -> true | _ -> false) -> ()
          | Tobject (_, nm2) -> set_name nm2 !nm1
          | _ -> ()
          end
      | (Tvariant row1, Tvariant row2) ->
          if !umode = Expression then
            unify_row env row1 row2
          else begin
            let snap = snapshot () in
            try unify_row env row1 row2
            with Unify _ ->
              backtrack snap;
              reify env t1';
              reify env t2';
              if !generate_equations then mcomp !env t1' t2'
          end
      | (Tfield(f,kind,_,rem), Tnil) | (Tnil, Tfield(f,kind,_,rem)) ->
          begin match field_kind_repr kind with
            Fvar r when f <> dummy_method ->
              set_kind r Fabsent;
              if d2 = Tnil then unify env rem t2'
              else unify env (newty2 rem.level Tnil) rem
          | _      -> raise (Unify [])
          end
      | (Tnil, Tnil) ->
          ()
      | (Tpoly (t1, []), Tpoly (t2, [])) ->
          unify env t1 t2
      | (Tpoly (t1, tl1), Tpoly (t2, tl2)) ->
          enter_poly !env univar_pairs t1 tl1 t2 tl2 (unify env)
      | (Tpackage (p1, n1, tl1), Tpackage (p2, n2, tl2)) ->
          begin try
            unify_package !env (unify_list env)
              t1.level p1 n1 tl1 t2.level p2 n2 tl2
          with Not_found ->
            if !umode = Expression then raise (Unify []);
            List.iter (reify env) (tl1 @ tl2);
            (* if !generate_equations then List.iter2 (mcomp !env) tl1 tl2 *)
          end
      | (_, _) ->
          raise (Unify [])
      end;
      (* XXX Commentaires + changer "create_recursion" *)
      if create_recursion then
        match t2.desc with
          Tconstr (p, tl, abbrev) ->
            forget_abbrev abbrev p;
            let t2'' = expand_head_unif !env t2 in
            if not (closed_parameterized_type tl t2'') then
              link_type (repr t2) (repr t2')
        | _ ->
            () (* t2 has already been expanded by update_level *)
    with Unify trace ->
      t1'.desc <- d1;
      raise (Unify trace)
  end

and unify_list env tl1 tl2 =
  if List.length tl1 <> List.length tl2 then
    raise (Unify []);
  List.iter2 (unify env) tl1 tl2

(* Build a fresh row variable for unification *)
and make_rowvar level use1 rest1 use2 rest2  =
  let set_name ty name =
    match ty.desc with
      Tvar None -> log_type ty; ty.desc <- Tvar name
    | _ -> ()
  in
  let name =
    match rest1.desc, rest2.desc with
      Tvar (Some _ as name1), Tvar (Some _ as name2) ->
        if rest1.level <= rest2.level then name1 else name2
    | Tvar (Some _ as name), _ ->
        if use2 then set_name rest2 name; name
    | _, Tvar (Some _ as name) ->
        if use1 then set_name rest2 name; name
    | _ -> None
  in
  if use1 then rest1 else
  if use2 then rest2 else newvar2 ?name level

and unify_fields env ty1 ty2 =          (* Optimization *)
  let (fields1, rest1) = flatten_fields ty1
  and (fields2, rest2) = flatten_fields ty2 in
  let (pairs, miss1, miss2) = associate_fields fields1 fields2 in
  let l1 = (repr ty1).level and l2 = (repr ty2).level in
  let va = make_rowvar (min l1 l2) (miss2=[]) rest1 (miss1=[]) rest2 in
  let d1 = rest1.desc and d2 = rest2.desc in
  try
    unify env (build_fields l1 miss1 va) rest2;
    unify env rest1 (build_fields l2 miss2 va);
    List.iter
      (fun (n, k1, t1, k2, t2) ->
        unify_kind k1 k2;
        try
          if !trace_gadt_instances then update_level !env va.level t1;
          unify env t1 t2
        with Unify trace ->
          raise (Unify ((newty (Tfield(n, k1, t1, newty Tnil)),
                         newty (Tfield(n, k2, t2, newty Tnil)))::trace)))
      pairs
  with exn ->
    log_type rest1; rest1.desc <- d1;
    log_type rest2; rest2.desc <- d2;
    raise exn

and unify_kind k1 k2 =
  let k1 = field_kind_repr k1 in
  let k2 = field_kind_repr k2 in
  if k1 == k2 then () else
  match k1, k2 with
    (Fvar r, (Fvar _ | Fpresent)) -> set_kind r k2
  | (Fpresent, Fvar r)            -> set_kind r k1
  | (Fpresent, Fpresent)          -> ()
  | _                             -> assert false

and unify_pairs mode env tpl =
  List.iter (fun (t1, t2) -> unify env t1 t2) tpl

and unify_row env row1 row2 =
  let row1 = row_repr row1 and row2 = row_repr row2 in
  let rm1 = row_more row1 and rm2 = row_more row2 in
  if unify_eq !env rm1 rm2 then () else
  let r1, r2, pairs = merge_row_fields row1.row_fields row2.row_fields in
  if r1 <> [] && r2 <> [] then begin
    let ht = Hashtbl.create (List.length r1) in
    List.iter (fun (l,_) -> Hashtbl.add ht (hash_variant l) l) r1;
    List.iter
      (fun (l,_) ->
        try raise (Tags(l, Hashtbl.find ht (hash_variant l)))
        with Not_found -> ())
      r2
  end;
  let fixed1 = row_fixed row1 and fixed2 = row_fixed row2 in
  let more =
    if fixed1 then rm1 else
    if fixed2 then rm2 else
    newty2 (min rm1.level rm2.level) (Tvar None) in
  let fixed = fixed1 || fixed2
  and closed = row1.row_closed || row2.row_closed in
  let keep switch =
    List.for_all
      (fun (_,f1,f2) ->
        let f1, f2 = switch f1 f2 in
        row_field_repr f1 = Rabsent || row_field_repr f2 <> Rabsent)
      pairs
  in
  let empty fields =
    List.for_all (fun (_,f) -> row_field_repr f = Rabsent) fields in
  (* Check whether we are going to build an empty type *)
  if closed && (empty r1 || row2.row_closed) && (empty r2 || row1.row_closed)
  && List.for_all
      (fun (_,f1,f2) ->
        row_field_repr f1 = Rabsent || row_field_repr f2 = Rabsent)
      pairs
  then raise (Unify [mkvariant [] true, mkvariant [] true]);
  let name =
    if row1.row_name <> None && (row1.row_closed || empty r2) &&
      (not row2.row_closed || keep (fun f1 f2 -> f1, f2) && empty r1)
    then row1.row_name
    else if row2.row_name <> None && (row2.row_closed || empty r1) &&
      (not row1.row_closed || keep (fun f1 f2 -> f2, f1) && empty r2)
    then row2.row_name
    else None
  in
  let row0 = {row_fields = []; row_more = more; row_bound = ();
              row_closed = closed; row_fixed = fixed; row_name = name} in
  let set_more row rest =
    let rest =
      if closed then
        filter_row_fields row.row_closed rest
      else rest in
    if rest <> [] && (row.row_closed || row_fixed row)
    || closed && row_fixed row && not row.row_closed then begin
      let t1 = mkvariant [] true and t2 = mkvariant rest false in
      raise (Unify [if row == row1 then (t1,t2) else (t2,t1)])
    end;
    (* The following test is not principal... should rather use Tnil *)
    let rm = row_more row in
    if !trace_gadt_instances && rm.desc = Tnil then () else
    if !trace_gadt_instances then
      update_level !env rm.level (newgenty (Tvariant row));
    if row_fixed row then
      if more == rm then () else
      if is_Tvar rm then link_type rm more else unify env rm more
    else
      let ty = newgenty (Tvariant {row0 with row_fields = rest}) in
      update_level !env rm.level ty;
      link_type rm ty
  in
  let md1 = rm1.desc and md2 = rm2.desc in
  begin try
    set_more row2 r1;
    set_more row1 r2;
    List.iter
      (fun (l,f1,f2) ->
        try unify_row_field env fixed1 fixed2 more l f1 f2
        with Unify trace ->
          raise (Unify ((mkvariant [l,f1] true,
                         mkvariant [l,f2] true) :: trace)))
      pairs;
  with exn ->
    log_type rm1; rm1.desc <- md1; log_type rm2; rm2.desc <- md2; raise exn
  end

and unify_row_field env fixed1 fixed2 more l f1 f2 =
  let f1 = row_field_repr f1 and f2 = row_field_repr f2 in
  if f1 == f2 then () else
  match f1, f2 with
    Rpresent(Some t1), Rpresent(Some t2) -> unify env t1 t2
  | Rpresent None, Rpresent None -> ()
  | Reither(c1, tl1, m1, e1), Reither(c2, tl2, m2, e2) ->
      if e1 == e2 then () else
      let redo =
        (m1 || m2 || fixed1 || fixed2 ||
         !rigid_variants && (List.length tl1 = 1 || List.length tl2 = 1)) &&
        begin match tl1 @ tl2 with [] -> false
        | t1 :: tl ->
            if c1 || c2 then raise (Unify []);
            List.iter (unify env t1) tl;
            !e1 <> None || !e2 <> None
        end in
      if redo then unify_row_field env fixed1 fixed2 more l f1 f2 else
      let tl1 = List.map repr tl1 and tl2 = List.map repr tl2 in
      let rec remq tl = function [] -> []
        | ty :: tl' ->
            if List.memq ty tl then remq tl tl' else ty :: remq tl tl'
      in
      let tl2' = remq tl2 tl1 and tl1' = remq tl1 tl2 in
      (* Is this handling of levels really principal? *)
      List.iter (update_level !env (repr more).level) (tl1' @ tl2');
      let e = ref None in
      let f1' = Reither(c1 || c2, tl1', m1 || m2, e)
      and f2' = Reither(c1 || c2, tl2', m1 || m2, e) in
      set_row_field e1 f1'; set_row_field e2 f2';
  | Reither(_, _, false, e1), Rabsent when not fixed1 -> set_row_field e1 f2
  | Rabsent, Reither(_, _, false, e2) when not fixed2 -> set_row_field e2 f1
  | Rabsent, Rabsent -> ()
  | Reither(false, tl, _, e1), Rpresent(Some t2) when not fixed1 ->
      set_row_field e1 f2;
      update_level !env (repr more).level t2;
      (try List.iter (fun t1 -> unify env t1 t2) tl
      with exn -> e1 := None; raise exn)
  | Rpresent(Some t1), Reither(false, tl, _, e2) when not fixed2 ->
      set_row_field e2 f1;
      update_level !env (repr more).level t1;
      (try List.iter (unify env t1) tl
      with exn -> e2 := None; raise exn)
  | Reither(true, [], _, e1), Rpresent None when not fixed1 ->
      set_row_field e1 f2
  | Rpresent None, Reither(true, [], _, e2) when not fixed2 ->
      set_row_field e2 f1
  | _ -> raise (Unify [])


let unify env ty1 ty2 =
  try
    unify env ty1 ty2
  with
    Unify trace ->
      raise (Unify (expand_trace !env trace))
  | Recursive_abbrev ->
      raise (Unification_recursive_abbrev (expand_trace !env [(ty1,ty2)]))

let unify_gadt ~newtype_level:lev (env:Env.t ref) ty1 ty2 =
  try
    univar_pairs := [];
    newtype_level := Some lev;
    set_mode_pattern ~generate:true ~injective:true
                     (fun () -> unify env ty1 ty2);
    newtype_level := None;
    TypePairs.clear unify_eq_set;
  with e ->
    TypePairs.clear unify_eq_set;
    match e with
      Unify e -> raise (Unify e)
    | e -> newtype_level := None; raise e

let unify_var env t1 t2 =
  let t1 = repr t1 and t2 = repr t2 in
  if t1 == t2 then () else
  match t1.desc with
    Tvar _ ->
      let reset_tracing = check_trace_gadt_instances env in
      begin try
        occur env t1 t2;
        update_level env t1.level t2;
        link_type t1 t2;
        reset_trace_gadt_instances reset_tracing;
      with Unify trace ->
        reset_trace_gadt_instances reset_tracing;
        let expanded_trace = expand_trace env ((t1,t2)::trace) in
        raise (Unify expanded_trace)
      end
  | _ ->
      unify (ref env) t1 t2

let _ = unify' := unify_var

let unify_pairs env ty1 ty2 pairs =
  univar_pairs := pairs;
  unify env ty1 ty2

let unify env ty1 ty2 =
  unify_pairs (ref env) ty1 ty2 []



(**** Special cases of unification ****)

let expand_head_trace env t =
  let reset_tracing = check_trace_gadt_instances env in
  let t = expand_head_unif env t in
  reset_trace_gadt_instances reset_tracing;
  t

(*
   Unify [t] and [l:'a -> 'b]. Return ['a] and ['b].
   In label mode, label mismatch is accepted when
   (1) the requested label is ""
   (2) the original label is not optional
*)

let filter_arrow env t l =
  let t = expand_head_trace env t in
  match t.desc with
    Tvar _ ->
      let lv = t.level in
      let t1 = newvar2 lv and t2 = newvar2 lv in
      let t' = newty2 lv (Tarrow (l, t1, t2, Cok)) in
      link_type t t';
      (t1, t2)
  | Tarrow(l', t1, t2, _)
    when l = l' || !Clflags.classic && l = "" && not (is_optional l') ->
      (t1, t2)
  | _ ->
      raise (Unify [])

(* Used by [filter_method]. *)
let rec filter_method_field env name priv ty =
  let ty = expand_head_trace env ty in
  match ty.desc with
    Tvar _ ->
      let level = ty.level in
      let ty1 = newvar2 level and ty2 = newvar2 level in
      let ty' = newty2 level (Tfield (name,
                                      begin match priv with
                                        Private -> Fvar (ref None)
                                      | Public  -> Fpresent
                                      end,
                                      ty1, ty2))
      in
      link_type ty ty';
      ty1
  | Tfield(n, kind, ty1, ty2) ->
      let kind = field_kind_repr kind in
      if (n = name) && (kind <> Fabsent) then begin
        if priv = Public then
          unify_kind kind Fpresent;
        ty1
      end else
        filter_method_field env name priv ty2
  | _ ->
      raise (Unify [])

(* Unify [ty] and [< name : 'a; .. >]. Return ['a]. *)
let filter_method env name priv ty =
  let ty = expand_head_trace env ty in
  match ty.desc with
    Tvar _ ->
      let ty1 = newvar () in
      let ty' = newobj ty1 in
      update_level env ty.level ty';
      link_type ty ty';
      filter_method_field env name priv ty1
  | Tobject(f, _) ->
      filter_method_field env name priv f
  | _ ->
      raise (Unify [])

let check_filter_method env name priv ty =
  ignore(filter_method env name priv ty)

let filter_self_method env lab priv meths ty =
  let ty' = filter_method env lab priv ty in
  try
    Meths.find lab !meths
  with Not_found ->
    let pair = (Ident.create lab, ty') in
    meths := Meths.add lab pair !meths;
    pair


                        (***********************************)
                        (*  Matching between type schemes  *)
                        (***********************************)

(*
   Update the level of [ty]. First check that the levels of generic
   variables from the subject are not lowered.
*)
let moregen_occur env level ty =
  let rec occur ty =
    let ty = repr ty in
    if ty.level > level then begin
      if is_Tvar ty && ty.level >= generic_level - 1 then raise Occur;
      ty.level <- pivot_level - ty.level;
      match ty.desc with
        Tvariant row when static_row row ->
          iter_row occur row
      | _ ->
          iter_type_expr occur ty
    end
  in
  begin try
    occur ty; unmark_type ty
  with Occur ->
    unmark_type ty; raise (Unify [])
  end;
  (* also check for free univars *)
  occur_univar env ty;
  update_level env level ty

let may_instantiate inst_nongen t1 =
  if inst_nongen then t1.level <> generic_level - 1
                 else t1.level =  generic_level

let rec moregen inst_nongen type_pairs env t1 t2 =
  if t1 == t2 then () else
  let t1 = repr t1 in
  let t2 = repr t2 in
  if t1 == t2 then () else

  try
    match (t1.desc, t2.desc) with
      (Tvar _, _) when may_instantiate inst_nongen t1 ->
        moregen_occur env t1.level t2;
        occur env t1 t2;
        link_type t1 t2
    | (Tconstr (p1, [], _), Tconstr (p2, [], _)) when Path.same p1 p2 ->
        ()
    | _ ->
        let t1' = expand_head env t1 in
        let t2' = expand_head env t2 in
        (* Expansion may have changed the representative of the types... *)
        let t1' = repr t1' and t2' = repr t2' in
        if t1' == t2' then () else
        begin try
          TypePairs.find type_pairs (t1', t2')
        with Not_found ->
          TypePairs.add type_pairs (t1', t2') ();
          match (t1'.desc, t2'.desc) with
            (Tvar _, _) when may_instantiate inst_nongen t1' ->
              moregen_occur env t1'.level t2;
              link_type t1' t2
          | (Tarrow (l1, t1, u1, _), Tarrow (l2, t2, u2, _)) when l1 = l2
            || !Clflags.classic && not (is_optional l1 || is_optional l2) ->
              moregen inst_nongen type_pairs env t1 t2;
              moregen inst_nongen type_pairs env u1 u2
          | (Ttuple tl1, Ttuple tl2) ->
              moregen_list inst_nongen type_pairs env tl1 tl2
          | (Tconstr (p1, tl1, _), Tconstr (p2, tl2, _))
                when Path.same p1 p2 ->
              moregen_list inst_nongen type_pairs env tl1 tl2
          | (Tpackage (p1, n1, tl1), Tpackage (p2, n2, tl2)) ->
              begin try
                unify_package env (moregen_list inst_nongen type_pairs env)
                  t1'.level p1 n1 tl1 t2'.level p2 n2 tl2
              with Not_found -> raise (Unify [])
              end
          | (Tvariant row1, Tvariant row2) ->
              moregen_row inst_nongen type_pairs env row1 row2
          | (Tobject (fi1, nm1), Tobject (fi2, nm2)) ->
              moregen_fields inst_nongen type_pairs env fi1 fi2
          | (Tfield _, Tfield _) ->           (* Actually unused *)
              moregen_fields inst_nongen type_pairs env t1' t2'
          | (Tnil, Tnil) ->
              ()
          | (Tpoly (t1, []), Tpoly (t2, [])) ->
              moregen inst_nongen type_pairs env t1 t2
          | (Tpoly (t1, tl1), Tpoly (t2, tl2)) ->
              enter_poly env univar_pairs t1 tl1 t2 tl2
                (moregen inst_nongen type_pairs env)
          | (Tunivar _, Tunivar _) ->
              unify_univar t1' t2' !univar_pairs
          | (_, _) ->
              raise (Unify [])
        end
  with Unify trace ->
    raise (Unify ((t1, t2)::trace))

and moregen_list inst_nongen type_pairs env tl1 tl2 =
  if List.length tl1 <> List.length tl2 then
    raise (Unify []);
  List.iter2 (moregen inst_nongen type_pairs env) tl1 tl2

and moregen_fields inst_nongen type_pairs env ty1 ty2 =
  let (fields1, rest1) = flatten_fields ty1
  and (fields2, rest2) = flatten_fields ty2 in
  let (pairs, miss1, miss2) = associate_fields fields1 fields2 in
  if miss1 <> [] then raise (Unify []);
  moregen inst_nongen type_pairs env rest1
    (build_fields (repr ty2).level miss2 rest2);
  List.iter
    (fun (n, k1, t1, k2, t2) ->
       moregen_kind k1 k2;
       try moregen inst_nongen type_pairs env t1 t2 with Unify trace ->
         raise (Unify ((newty (Tfield(n, k1, t1, rest2)),
                        newty (Tfield(n, k2, t2, rest2)))::trace)))
    pairs

and moregen_kind k1 k2 =
  let k1 = field_kind_repr k1 in
  let k2 = field_kind_repr k2 in
  if k1 == k2 then () else
  match k1, k2 with
    (Fvar r, (Fvar _ | Fpresent))  -> set_kind r k2
  | (Fpresent, Fpresent)           -> ()
  | _                              -> raise (Unify [])

and moregen_row inst_nongen type_pairs env row1 row2 =
  let row1 = row_repr row1 and row2 = row_repr row2 in
  let rm1 = repr row1.row_more and rm2 = repr row2.row_more in
  if rm1 == rm2 then () else
  let may_inst =
    is_Tvar rm1 && may_instantiate inst_nongen rm1 || rm1.desc = Tnil in
  let r1, r2, pairs = merge_row_fields row1.row_fields row2.row_fields in
  let r1, r2 =
    if row2.row_closed then
      filter_row_fields may_inst r1, filter_row_fields false r2
    else r1, r2
  in
  if r1 <> [] || row1.row_closed && (not row2.row_closed || r2 <> [])
  then raise (Unify []);
  begin match rm1.desc, rm2.desc with
    Tunivar _, Tunivar _ ->
      unify_univar rm1 rm2 !univar_pairs
  | Tunivar _, _ | _, Tunivar _ ->
      raise (Unify [])
  | _ when static_row row1 -> ()
  | _ when may_inst ->
      let ext = newgenty (Tvariant {row2 with row_fields = r2}) in
      moregen_occur env rm1.level ext;
      link_type rm1 ext
  | Tconstr _, Tconstr _ ->
      moregen inst_nongen type_pairs env rm1 rm2
  | _ -> raise (Unify [])
  end;
  List.iter
    (fun (l,f1,f2) ->
      let f1 = row_field_repr f1 and f2 = row_field_repr f2 in
      if f1 == f2 then () else
      match f1, f2 with
        Rpresent(Some t1), Rpresent(Some t2) ->
          moregen inst_nongen type_pairs env t1 t2
      | Rpresent None, Rpresent None -> ()
      | Reither(false, tl1, _, e1), Rpresent(Some t2) when may_inst ->
          set_row_field e1 f2;
          List.iter (fun t1 -> moregen inst_nongen type_pairs env t1 t2) tl1
      | Reither(c1, tl1, _, e1), Reither(c2, tl2, m2, e2) ->
          if e1 != e2 then begin
            if c1 && not c2 then raise(Unify []);
            set_row_field e1 (Reither (c2, [], m2, e2));
            if List.length tl1 = List.length tl2 then
              List.iter2 (moregen inst_nongen type_pairs env) tl1 tl2
            else match tl2 with
              t2 :: _ ->
                List.iter (fun t1 -> moregen inst_nongen type_pairs env t1 t2)
                  tl1
            | [] ->
                if tl1 <> [] then raise (Unify [])
          end
      | Reither(true, [], _, e1), Rpresent None when may_inst ->
          set_row_field e1 f2
      | Reither(_, _, _, e1), Rabsent when may_inst ->
          set_row_field e1 f2
      | Rabsent, Rabsent -> ()
      | _ -> raise (Unify []))
    pairs

(* Must empty univar_pairs first *)
let moregen inst_nongen type_pairs env patt subj =
  univar_pairs := [];
  moregen inst_nongen type_pairs env patt subj

(*
   Non-generic variable can be instanciated only if [inst_nongen] is
   true. So, [inst_nongen] should be set to false if the subject might
   contain non-generic variables (and we do not want them to be
   instanciated).
   Usually, the subject is given by the user, and the pattern
   is unimportant.  So, no need to propagate abbreviations.
*)
let moregeneral env inst_nongen pat_sch subj_sch =
  let old_level = !current_level in
  current_level := generic_level - 1;
  (*
     Generic variables are first duplicated with [instance].  So,
     their levels are lowered to [generic_level - 1].  The subject is
     then copied with [duplicate_type].  That way, its levels won't be
     changed.
  *)
  let subj = duplicate_type (instance env subj_sch) in
  current_level := generic_level;
  (* Duplicate generic variables *)
  let patt = instance env pat_sch in
  let res =
    try moregen inst_nongen (TypePairs.create 13) env patt subj; true with
      Unify _ -> false
  in
  current_level := old_level;
  res


(* Alternative approach: "rigidify" a type scheme,
   and check validity after unification *)
(* Simpler, no? *)

let rec rigidify_rec vars ty =
  let ty = repr ty in
  if ty.level >= lowest_level then begin
    ty.level <- pivot_level - ty.level;
    match ty.desc with
    | Tvar _ ->
        if not (List.memq ty !vars) then vars := ty :: !vars
    | Tvariant row ->
        let row = row_repr row in
        let more = repr row.row_more in
        if is_Tvar more && not (row_fixed row) then begin
          let more' = newty2 more.level more.desc in
          let row' = {row with row_fixed=true; row_fields=[]; row_more=more'}
          in link_type more (newty2 ty.level (Tvariant row'))
        end;
        iter_row (rigidify_rec vars) row;
        (* only consider the row variable if the variant is not static *)
        if not (static_row row) then rigidify_rec vars (row_more row)
    | _ ->
        iter_type_expr (rigidify_rec vars) ty
  end

let rigidify ty =
  let vars = ref [] in
  rigidify_rec vars ty;
  unmark_type ty;
  !vars

let all_distinct_vars env vars =
  let tyl = ref [] in
  List.for_all
    (fun ty ->
      let ty = expand_head env ty in
      if List.memq ty !tyl then false else
      (tyl := ty :: !tyl; is_Tvar ty))
    vars

let matches env ty ty' =
  let snap = snapshot () in
  let vars = rigidify ty in
  cleanup_abbrev ();
  let ok =
    try unify env ty ty'; all_distinct_vars env vars
    with Unify _ -> false
  in
  backtrack snap;
  ok


                 (*********************************************)
                 (*  Equivalence between parameterized types  *)
                 (*********************************************)

let rec get_object_row ty =
  match repr ty with
  | {desc=Tfield (_, _, _, tl)} -> get_object_row tl
  | ty -> ty

let expand_head_rigid env ty =
  let old = !rigid_variants in
  rigid_variants := true;
  let ty' = expand_head env ty in
  rigid_variants := old; ty'

let normalize_subst subst =
  if List.exists
      (function {desc=Tlink _}, _ | _, {desc=Tlink _} -> true | _ -> false)
      !subst
  then subst := List.map (fun (t1,t2) -> repr t1, repr t2) !subst

let rec eqtype rename type_pairs subst env t1 t2 =
  if t1 == t2 then () else
  let t1 = repr t1 in
  let t2 = repr t2 in
  if t1 == t2 then () else

  try
    match (t1.desc, t2.desc) with
      (Tvar _, Tvar _) when rename ->
        begin try
          normalize_subst subst;
          if List.assq t1 !subst != t2 then raise (Unify [])
        with Not_found ->
          if List.exists (fun (_, t) -> t == t2) !subst then raise (Unify []);
          subst := (t1, t2) :: !subst
        end
    | (Tconstr (p1, [], _), Tconstr (p2, [], _)) when Path.same p1 p2 ->
        ()
    | _ ->
        let t1' = expand_head_rigid env t1 in
        let t2' = expand_head_rigid env t2 in
        (* Expansion may have changed the representative of the types... *)
        let t1' = repr t1' and t2' = repr t2' in
        if t1' == t2' then () else
        begin try
          TypePairs.find type_pairs (t1', t2')
        with Not_found ->
          TypePairs.add type_pairs (t1', t2') ();
          match (t1'.desc, t2'.desc) with
            (Tvar _, Tvar _) when rename ->
              begin try
                normalize_subst subst;
                if List.assq t1' !subst != t2' then raise (Unify [])
              with Not_found ->
                if List.exists (fun (_, t) -> t == t2') !subst
                then raise (Unify []);
                subst := (t1', t2') :: !subst
              end
          | (Tarrow (l1, t1, u1, _), Tarrow (l2, t2, u2, _)) when l1 = l2
            || !Clflags.classic && not (is_optional l1 || is_optional l2) ->
              eqtype rename type_pairs subst env t1 t2;
              eqtype rename type_pairs subst env u1 u2;
          | (Ttuple tl1, Ttuple tl2) ->
              eqtype_list rename type_pairs subst env tl1 tl2
          | (Tconstr (p1, tl1, _), Tconstr (p2, tl2, _))
                when Path.same p1 p2 ->
              eqtype_list rename type_pairs subst env tl1 tl2
          | (Tpackage (p1, n1, tl1), Tpackage (p2, n2, tl2)) ->
              begin try
                unify_package env (eqtype_list rename type_pairs subst env)
                  t1'.level p1 n1 tl1 t2'.level p2 n2 tl2
              with Not_found -> raise (Unify [])
              end
          | (Tvariant row1, Tvariant row2) ->
              eqtype_row rename type_pairs subst env row1 row2
          | (Tobject (fi1, nm1), Tobject (fi2, nm2)) ->
              eqtype_fields rename type_pairs subst env fi1 fi2
          | (Tfield _, Tfield _) ->       (* Actually unused *)
              eqtype_fields rename type_pairs subst env t1' t2'
          | (Tnil, Tnil) ->
              ()
          | (Tpoly (t1, []), Tpoly (t2, [])) ->
              eqtype rename type_pairs subst env t1 t2
          | (Tpoly (t1, tl1), Tpoly (t2, tl2)) ->
              enter_poly env univar_pairs t1 tl1 t2 tl2
                (eqtype rename type_pairs subst env)
          | (Tunivar _, Tunivar _) ->
              unify_univar t1' t2' !univar_pairs
          | (_, _) ->
              raise (Unify [])
        end
  with Unify trace ->
    raise (Unify ((t1, t2)::trace))

and eqtype_list rename type_pairs subst env tl1 tl2 =
  if List.length tl1 <> List.length tl2 then
    raise (Unify []);
  List.iter2 (eqtype rename type_pairs subst env) tl1 tl2

and eqtype_fields rename type_pairs subst env ty1 ty2 =
  let (fields1, rest1) = flatten_fields ty1 in
  let (fields2, rest2) = flatten_fields ty2 in
  (* First check if same row => already equal *)
  let same_row =
    rest1 == rest2 || TypePairs.mem type_pairs (rest1,rest2) ||
    (rename && List.mem (rest1, rest2) !subst)
  in
  if same_row then () else
  (* Try expansion, needed when called from Includecore.type_manifest *)
  match expand_head_rigid env rest2 with
    {desc=Tobject(ty2,_)} -> eqtype_fields rename type_pairs subst env ty1 ty2
  | _ ->
  let (pairs, miss1, miss2) = associate_fields fields1 fields2 in
  eqtype rename type_pairs subst env rest1 rest2;
  if (miss1 <> []) || (miss2 <> []) then raise (Unify []);
  List.iter
    (function (n, k1, t1, k2, t2) ->
       eqtype_kind k1 k2;
       try eqtype rename type_pairs subst env t1 t2 with Unify trace ->
         raise (Unify ((newty (Tfield(n, k1, t1, rest2)),
                        newty (Tfield(n, k2, t2, rest2)))::trace)))
    pairs

and eqtype_kind k1 k2 =
  let k1 = field_kind_repr k1 in
  let k2 = field_kind_repr k2 in
  match k1, k2 with
    (Fvar _, Fvar _)
  | (Fpresent, Fpresent) -> ()
  | _                    -> raise (Unify [])

and eqtype_row rename type_pairs subst env row1 row2 =
  (* Try expansion, needed when called from Includecore.type_manifest *)
  match expand_head_rigid env (row_more row2) with
    {desc=Tvariant row2} -> eqtype_row rename type_pairs subst env row1 row2
  | _ ->
  let row1 = row_repr row1 and row2 = row_repr row2 in
  let r1, r2, pairs = merge_row_fields row1.row_fields row2.row_fields in
  if row1.row_closed <> row2.row_closed
  || not row1.row_closed && (r1 <> [] || r2 <> [])
  || filter_row_fields false (r1 @ r2) <> []
  then raise (Unify []);
  if not (static_row row1) then
    eqtype rename type_pairs subst env row1.row_more row2.row_more;
  List.iter
    (fun (_,f1,f2) ->
      match row_field_repr f1, row_field_repr f2 with
        Rpresent(Some t1), Rpresent(Some t2) ->
          eqtype rename type_pairs subst env t1 t2
      | Reither(true, [], _, _), Reither(true, [], _, _) ->
          ()
      | Reither(false, t1::tl1, _, _), Reither(false, t2::tl2, _, _) ->
          eqtype rename type_pairs subst env t1 t2;
          if List.length tl1 = List.length tl2 then
            (* if same length allow different types (meaning?) *)
            List.iter2 (eqtype rename type_pairs subst env) tl1 tl2
          else begin
            (* otherwise everything must be equal *)
            List.iter (eqtype rename type_pairs subst env t1) tl2;
            List.iter (fun t1 -> eqtype rename type_pairs subst env t1 t2) tl1
          end
      | Rpresent None, Rpresent None -> ()
      | Rabsent, Rabsent -> ()
      | _ -> raise (Unify []))
    pairs

(* Two modes: with or without renaming of variables *)
let equal env rename tyl1 tyl2 =
  try
    univar_pairs := [];
    eqtype_list rename (TypePairs.create 11) (ref []) env tyl1 tyl2; true
  with
    Unify _ -> false

(* Must empty univar_pairs first *)
let eqtype rename type_pairs subst env t1 t2 =
  univar_pairs := [];
  eqtype rename type_pairs subst env t1 t2


                          (*************************)
                          (*  Class type matching  *)
                          (*************************)


type class_match_failure =
    CM_Virtual_class
  | CM_Parameter_arity_mismatch of int * int
  | CM_Type_parameter_mismatch of Env.t * (type_expr * type_expr) list
  | CM_Class_type_mismatch of Env.t * class_type * class_type
  | CM_Parameter_mismatch of Env.t * (type_expr * type_expr) list
  | CM_Val_type_mismatch of string * Env.t * (type_expr * type_expr) list
  | CM_Meth_type_mismatch of string * Env.t * (type_expr * type_expr) list
  | CM_Non_mutable_value of string
  | CM_Non_concrete_value of string
  | CM_Missing_value of string
  | CM_Missing_method of string
  | CM_Hide_public of string
  | CM_Hide_virtual of string * string
  | CM_Public_method of string
  | CM_Private_method of string
  | CM_Virtual_method of string

exception Failure of class_match_failure list

let rec moregen_clty trace type_pairs env cty1 cty2 =
  try
    match cty1, cty2 with
      Cty_constr (_, _, cty1), _ ->
        moregen_clty true type_pairs env cty1 cty2
    | _, Cty_constr (_, _, cty2) ->
        moregen_clty true type_pairs env cty1 cty2
    | Cty_arrow (l1, ty1, cty1'), Cty_arrow (l2, ty2, cty2') when l1 = l2 ->
        begin try moregen true type_pairs env ty1 ty2 with Unify trace ->
          raise (Failure [CM_Parameter_mismatch (env, expand_trace env trace)])
        end;
        moregen_clty false type_pairs env cty1' cty2'
    | Cty_signature sign1, Cty_signature sign2 ->
        let ty1 = object_fields (repr sign1.csig_self) in
        let ty2 = object_fields (repr sign2.csig_self) in
        let (fields1, rest1) = flatten_fields ty1
        and (fields2, rest2) = flatten_fields ty2 in
        let (pairs, miss1, miss2) = associate_fields fields1 fields2 in
        List.iter
          (fun (lab, k1, t1, k2, t2) ->
            begin try moregen true type_pairs env t1 t2 with Unify trace ->
              raise (Failure [CM_Meth_type_mismatch
                                 (lab, env, expand_trace env trace)])
           end)
        pairs;
      Vars.iter
        (fun lab (mut, v, ty) ->
           let (mut', v', ty') = Vars.find lab sign1.csig_vars in
           try moregen true type_pairs env ty' ty with Unify trace ->
             raise (Failure [CM_Val_type_mismatch
                                (lab, env, expand_trace env trace)]))
        sign2.csig_vars
  | _ ->
      raise (Failure [])
  with
    Failure error when trace || error = [] ->
      raise (Failure (CM_Class_type_mismatch (env, cty1, cty2)::error))

let match_class_types ?(trace=true) env pat_sch subj_sch =
  let type_pairs = TypePairs.create 53 in
  let old_level = !current_level in
  current_level := generic_level - 1;
  (*
     Generic variables are first duplicated with [instance].  So,
     their levels are lowered to [generic_level - 1].  The subject is
     then copied with [duplicate_type].  That way, its levels won't be
     changed.
  *)
  let (_, subj_inst) = instance_class [] subj_sch in
  let subj = duplicate_class_type subj_inst in
  current_level := generic_level;
  (* Duplicate generic variables *)
  let (_, patt) = instance_class [] pat_sch in
  let res =
    let sign1 = signature_of_class_type patt in
    let sign2 = signature_of_class_type subj in
    let t1 = repr sign1.csig_self in
    let t2 = repr sign2.csig_self in
    TypePairs.add type_pairs (t1, t2) ();
    let (fields1, rest1) = flatten_fields (object_fields t1)
    and (fields2, rest2) = flatten_fields (object_fields t2) in
    let (pairs, miss1, miss2) = associate_fields fields1 fields2 in
    let error =
      List.fold_right
        (fun (lab, k, _) err ->
           let err =
             let k = field_kind_repr k in
             begin match k with
               Fvar r -> set_kind r Fabsent; err
             | _      -> CM_Hide_public lab::err
             end
           in
           if Concr.mem lab sign1.csig_concr then err
           else CM_Hide_virtual ("method", lab) :: err)
        miss1 []
    in
    let missing_method = List.map (fun (m, _, _) -> m) miss2 in
    let error =
      (List.map (fun m -> CM_Missing_method m) missing_method) @ error
    in
    (* Always succeeds *)
    moregen true type_pairs env rest1 rest2;
    let error =
      List.fold_right
        (fun (lab, k1, t1, k2, t2) err ->
           try moregen_kind k1 k2; err with
             Unify _ -> CM_Public_method lab::err)
        pairs error
    in
    let error =
      Vars.fold
        (fun lab (mut, vr, ty) err ->
          try
            let (mut', vr', ty') = Vars.find lab sign1.csig_vars in
            if mut = Mutable && mut' <> Mutable then
              CM_Non_mutable_value lab::err
            else if vr = Concrete && vr' <> Concrete then
              CM_Non_concrete_value lab::err
            else
              err
          with Not_found ->
            CM_Missing_value lab::err)
        sign2.csig_vars error
    in
    let error =
      Vars.fold
        (fun lab (_,vr,_) err ->
          if vr = Virtual && not (Vars.mem lab sign2.csig_vars) then
            CM_Hide_virtual ("instance variable", lab) :: err
          else err)
        sign1.csig_vars error
    in
    let error =
      List.fold_right
        (fun e l ->
           if List.mem e missing_method then l else CM_Virtual_method e::l)
        (Concr.elements (Concr.diff sign2.csig_concr sign1.csig_concr))
        error
    in
    match error with
      [] ->
        begin try
          moregen_clty trace type_pairs env patt subj;
          []
        with
          Failure r -> r
        end
    | error ->
        CM_Class_type_mismatch (env, patt, subj)::error
  in
  current_level := old_level;
  res

let rec equal_clty trace type_pairs subst env cty1 cty2 =
  try
    match cty1, cty2 with
      Cty_constr (_, _, cty1), Cty_constr (_, _, cty2) ->
        equal_clty true type_pairs subst env cty1 cty2
    | Cty_constr (_, _, cty1), _ ->
        equal_clty true type_pairs subst env cty1 cty2
    | _, Cty_constr (_, _, cty2) ->
        equal_clty true type_pairs subst env cty1 cty2
    | Cty_arrow (l1, ty1, cty1'), Cty_arrow (l2, ty2, cty2') when l1 = l2 ->
        begin try eqtype true type_pairs subst env ty1 ty2 with Unify trace ->
          raise (Failure [CM_Parameter_mismatch (env, expand_trace env trace)])
        end;
        equal_clty false type_pairs subst env cty1' cty2'
    | Cty_signature sign1, Cty_signature sign2 ->
        let ty1 = object_fields (repr sign1.csig_self) in
        let ty2 = object_fields (repr sign2.csig_self) in
        let (fields1, rest1) = flatten_fields ty1
        and (fields2, rest2) = flatten_fields ty2 in
        let (pairs, miss1, miss2) = associate_fields fields1 fields2 in
        List.iter
          (fun (lab, k1, t1, k2, t2) ->
             begin try eqtype true type_pairs subst env t1 t2 with
               Unify trace ->
                 raise (Failure [CM_Meth_type_mismatch
                                    (lab, env, expand_trace env trace)])
             end)
          pairs;
        Vars.iter
          (fun lab (_, _, ty) ->
             let (_, _, ty') = Vars.find lab sign1.csig_vars in
             try eqtype true type_pairs subst env ty' ty with Unify trace ->
               raise (Failure [CM_Val_type_mismatch
                                  (lab, env, expand_trace env trace)]))
          sign2.csig_vars
    | _ ->
        raise
          (Failure (if trace then []
                    else [CM_Class_type_mismatch (env, cty1, cty2)]))
  with
    Failure error when trace ->
      raise (Failure (CM_Class_type_mismatch (env, cty1, cty2)::error))

let match_class_declarations env patt_params patt_type subj_params subj_type =
  let type_pairs = TypePairs.create 53 in
  let subst = ref [] in
  let sign1 = signature_of_class_type patt_type in
  let sign2 = signature_of_class_type subj_type in
  let t1 = repr sign1.csig_self in
  let t2 = repr sign2.csig_self in
  TypePairs.add type_pairs (t1, t2) ();
  let (fields1, rest1) = flatten_fields (object_fields t1)
  and (fields2, rest2) = flatten_fields (object_fields t2) in
  let (pairs, miss1, miss2) = associate_fields fields1 fields2 in
  let error =
    List.fold_right
      (fun (lab, k, _) err ->
        let err =
          let k = field_kind_repr k in
          begin match k with
            Fvar r -> err
          | _      -> CM_Hide_public lab::err
          end
        in
        if Concr.mem lab sign1.csig_concr then err
        else CM_Hide_virtual ("method", lab) :: err)
      miss1 []
  in
  let missing_method = List.map (fun (m, _, _) -> m) miss2 in
  let error =
    (List.map (fun m -> CM_Missing_method m) missing_method) @ error
  in
  (* Always succeeds *)
  eqtype true type_pairs subst env rest1 rest2;
  let error =
    List.fold_right
      (fun (lab, k1, t1, k2, t2) err ->
        let k1 = field_kind_repr k1 in
        let k2 = field_kind_repr k2 in
        match k1, k2 with
          (Fvar _, Fvar _)
        | (Fpresent, Fpresent) -> err
        | (Fvar _, Fpresent)   -> CM_Private_method lab::err
        | (Fpresent, Fvar _)  -> CM_Public_method lab::err
        | _                    -> assert false)
      pairs error
  in
  let error =
    Vars.fold
      (fun lab (mut, vr, ty) err ->
         try
           let (mut', vr', ty') = Vars.find lab sign1.csig_vars in
           if mut = Mutable && mut' <> Mutable then
             CM_Non_mutable_value lab::err
           else if vr = Concrete && vr' <> Concrete then
             CM_Non_concrete_value lab::err
           else
             err
         with Not_found ->
           CM_Missing_value lab::err)
      sign2.csig_vars error
  in
  let error =
    Vars.fold
      (fun lab (_,vr,_) err ->
        if vr = Virtual && not (Vars.mem lab sign2.csig_vars) then
          CM_Hide_virtual ("instance variable", lab) :: err
        else err)
      sign1.csig_vars error
  in
  let error =
    List.fold_right
      (fun e l ->
        if List.mem e missing_method then l else CM_Virtual_method e::l)
      (Concr.elements (Concr.diff sign2.csig_concr sign1.csig_concr))
      error
  in
  match error with
    [] ->
      begin try
        let lp = List.length patt_params in
        let ls = List.length subj_params in
        if lp  <> ls then
          raise (Failure [CM_Parameter_arity_mismatch (lp, ls)]);
        List.iter2 (fun p s ->
          try eqtype true type_pairs subst env p s with Unify trace ->
            raise (Failure [CM_Type_parameter_mismatch
                               (env, expand_trace env trace)]))
          patt_params subj_params;
     (* old code: equal_clty false type_pairs subst env patt_type subj_type; *)
        equal_clty false type_pairs subst env
          (Cty_signature sign1) (Cty_signature sign2);
        (* Use moregeneral for class parameters, need to recheck everything to
           keeps relationships (PR#4824) *)
        let clty_params =
          List.fold_right (fun ty cty -> Cty_arrow ("*",ty,cty)) in
        match_class_types ~trace:false env
          (clty_params patt_params patt_type)
          (clty_params subj_params subj_type)
      with
        Failure r -> r
      end
  | error ->
      error


                              (***************)
                              (*  Subtyping  *)
                              (***************)


(**** Build a subtype of a given type. ****)

(* build_subtype:
   [visited] traces traversed object and variant types
   [loops] is a mapping from variables to variables, to reproduce
     positive loops in a class type
   [posi] true if the current variance is positive
   [level] number of expansions/enlargement allowed on this branch *)

let warn = ref false  (* whether double coercion might do better *)
let pred_expand n = if n mod 2 = 0 && n > 0 then pred n else n
let pred_enlarge n = if n mod 2 = 1 then pred n else n

type change = Unchanged | Equiv | Changed
let collect l = List.fold_left (fun c1 (_, c2) -> max c1 c2) Unchanged l

let rec filter_visited = function
    [] -> []
  | {desc=Tobject _|Tvariant _} :: _ as l -> l
  | _ :: l -> filter_visited l

let memq_warn t visited =
  if List.memq t visited then (warn := true; true) else false

let rec lid_of_path ?(sharp="") = function
    Path.Pident id ->
      Longident.Lident (sharp ^ Ident.name id)
  | Path.Pdot (p1, s, _) ->
      Longident.Ldot (lid_of_path p1, sharp ^ s)
  | Path.Papply (p1, p2) ->
      Longident.Lapply (lid_of_path ~sharp p1, lid_of_path p2)

let find_cltype_for_path env p =
  let path, cl_abbr = Env.lookup_type (lid_of_path ~sharp:"#" p) env in
  match cl_abbr.type_manifest with
    Some ty ->
      begin match (repr ty).desc with
        Tobject(_,{contents=Some(p',_)}) when Path.same p p' -> cl_abbr, ty
      | _ -> raise Not_found
      end
  | None -> assert false

let has_constr_row' env t =
  has_constr_row (expand_abbrev env t)

let rec build_subtype env visited loops posi level t =
  let t = repr t in
  match t.desc with
    Tvar _ ->
      if posi then
        try
          let t' = List.assq t loops in
          warn := true;
          (t', Equiv)
        with Not_found ->
          (t, Unchanged)
      else
        (t, Unchanged)
  | Tarrow(l, t1, t2, _) ->
      if memq_warn t visited then (t, Unchanged) else
      let visited = t :: visited in
      let (t1', c1) = build_subtype env visited loops (not posi) level t1 in
      let (t2', c2) = build_subtype env visited loops posi level t2 in
      let c = max c1 c2 in
      if c > Unchanged then (newty (Tarrow(l, t1', t2', Cok)), c)
      else (t, Unchanged)
  | Ttuple tlist ->
      if memq_warn t visited then (t, Unchanged) else
      let visited = t :: visited in
      let tlist' =
        List.map (build_subtype env visited loops posi level) tlist
      in
      let c = collect tlist' in
      if c > Unchanged then (newty (Ttuple (List.map fst tlist')), c)
      else (t, Unchanged)
  | Tconstr(p, tl, abbrev)
    when level > 0 && generic_abbrev env p && safe_abbrev env t
    && not (has_constr_row' env t) ->
      let t' = repr (expand_abbrev env t) in
      let level' = pred_expand level in
      begin try match t'.desc with
        Tobject _ when posi && not (opened_object t') ->
          let cl_abbr, body = find_cltype_for_path env p in
          let ty =
            subst env !current_level Public abbrev None
              cl_abbr.type_params tl body in
          let ty = repr ty in
          let ty1, tl1 =
            match ty.desc with
              Tobject(ty1,{contents=Some(p',tl1)}) when Path.same p p' ->
                ty1, tl1
            | _ -> raise Not_found
          in
          (* Fix PR4505: do not set ty to Tvar when it appears in tl1,
             as this occurence might break the occur check.
             XXX not clear whether this correct anyway... *)
          if List.exists (deep_occur ty) tl1 then raise Not_found;
          ty.desc <- Tvar None;
          let t'' = newvar () in
          let loops = (ty, t'') :: loops in
          (* May discard [visited] as level is going down *)
          let (ty1', c) =
            build_subtype env [t'] loops posi (pred_enlarge level') ty1 in
          assert (is_Tvar t'');
          let nm =
            if c > Equiv || deep_occur ty ty1' then None else Some(p,tl1) in
          t''.desc <- Tobject (ty1', ref nm);
          (try unify_var env ty t with Unify _ -> assert false);
          (t'', Changed)
      | _ -> raise Not_found
      with Not_found ->
        let (t'',c) = build_subtype env visited loops posi level' t' in
        if c > Unchanged then (t'',c)
        else (t, Unchanged)
      end
  | Tconstr(p, tl, abbrev) ->
      (* Must check recursion on constructors, since we do not always
         expand them *)
      if memq_warn t visited then (t, Unchanged) else
      let visited = t :: visited in
      begin try
        let decl = Env.find_type p env in
        if level = 0 && generic_abbrev env p && safe_abbrev env t
        && not (has_constr_row' env t)
        then warn := true;
        let tl' =
          List.map2
            (fun v t ->
              let (co,cn) = Variance.get_upper v in
              if cn then
                if co then (t, Unchanged)
                else build_subtype env visited loops (not posi) level t
              else
                if co then build_subtype env visited loops posi level t
                else (newvar(), Changed))
            decl.type_variance tl
        in
        let c = collect tl' in
        if c > Unchanged then (newconstr p (List.map fst tl'), c)
        else (t, Unchanged)
      with Not_found ->
        (t, Unchanged)
      end
  | Tvariant row ->
      let row = row_repr row in
      if memq_warn t visited || not (static_row row) then (t, Unchanged) else
      let level' = pred_enlarge level in
      let visited =
        t :: if level' < level then [] else filter_visited visited in
      let fields = filter_row_fields false row.row_fields in
      let fields =
        List.map
          (fun (l,f as orig) -> match row_field_repr f with
            Rpresent None ->
              if posi then
                (l, Reither(true, [], false, ref None)), Unchanged
              else
                orig, Unchanged
          | Rpresent(Some t) ->
              let (t', c) = build_subtype env visited loops posi level' t in
              let f =
                if posi && level > 0
                then Reither(false, [t'], false, ref None)
                else Rpresent(Some t')
              in (l, f), c
          | _ -> assert false)
          fields
      in
      let c = collect fields in
      let row =
        { row_fields = List.map fst fields; row_more = newvar();
          row_bound = (); row_closed = posi; row_fixed = false;
          row_name = if c > Unchanged then None else row.row_name }
      in
      (newty (Tvariant row), Changed)
  | Tobject (t1, _) ->
      if memq_warn t visited || opened_object t1 then (t, Unchanged) else
      let level' = pred_enlarge level in
      let visited =
        t :: if level' < level then [] else filter_visited visited in
      let (t1', c) = build_subtype env visited loops posi level' t1 in
      if c > Unchanged then (newty (Tobject (t1', ref None)), c)
      else (t, Unchanged)
  | Tfield(s, _, t1, t2) (* Always present *) ->
      let (t1', c1) = build_subtype env visited loops posi level t1 in
      let (t2', c2) = build_subtype env visited loops posi level t2 in
      let c = max c1 c2 in
      if c > Unchanged then (newty (Tfield(s, Fpresent, t1', t2')), c)
      else (t, Unchanged)
  | Tnil ->
      if posi then
        let v = newvar () in
        (v, Changed)
      else begin
        warn := true;
        (t, Unchanged)
      end
  | Tsubst _ | Tlink _ ->
      assert false
  | Tpoly(t1, tl) ->
      let (t1', c) = build_subtype env visited loops posi level t1 in
      if c > Unchanged then (newty (Tpoly(t1', tl)), c)
      else (t, Unchanged)
  | Tunivar _ | Tpackage _ ->
      (t, Unchanged)

let enlarge_type env ty =
  warn := false;
  (* [level = 4] allows 2 expansions involving objects/variants *)
  let (ty', _) = build_subtype env [] [] true 4 ty in
  (ty', !warn)

(**** Check whether a type is a subtype of another type. ****)

(*
    During the traversal, a trace of visited types is maintained. It
    is printed in case of error.
    Constraints (pairs of types that must be equals) are accumulated
    rather than being enforced straight. Indeed, the result would
    otherwise depend on the order in which these constraints are
    enforced.
    A function enforcing these constraints is returned. That way, type
    variables can be bound to their actual values before this function
    is called (see Typecore).
    Only well-defined abbreviations are expanded (hence the tests
    [generic_abbrev ...]).
*)

let subtypes = TypePairs.create 17

let subtype_error env trace =
  raise (Subtype (expand_trace env (List.rev trace), []))

(* check list inclusion, assuming lists are ordered *)
let rec included nl1 nl2 =
  match nl1, nl2 with
    (a::nl1', b::nl2') ->
      if a = b then included nl1' nl2' else
      a > b && included nl1 nl2'
  | ([], _) -> true
  | (_, []) -> false

let rec extract_assoc nl1 nl2 tl2 =
  match (nl1, nl2, tl2) with
    (a::nl1', b::nl2, t::tl2) ->
      if a = b then t :: extract_assoc nl1' nl2 tl2
      else extract_assoc nl1 nl2 tl2
  | ([], _, _) -> []
  | _ -> assert false

let rec subtype_rec env trace t1 t2 cstrs =
  let t1 = repr t1 in
  let t2 = repr t2 in
  if t1 == t2 then cstrs else

  begin try
    TypePairs.find subtypes (t1, t2);
    cstrs
  with Not_found ->
    TypePairs.add subtypes (t1, t2) ();
    match (t1.desc, t2.desc) with
      (Tvar _, _) | (_, Tvar _) ->
        (trace, t1, t2, !univar_pairs)::cstrs
    | (Tarrow(l1, t1, u1, _), Tarrow(l2, t2, u2, _)) when l1 = l2
      || !Clflags.classic && not (is_optional l1 || is_optional l2) ->
        let cstrs = subtype_rec env ((t2, t1)::trace) t2 t1 cstrs in
        subtype_rec env ((u1, u2)::trace) u1 u2 cstrs
    | (Ttuple tl1, Ttuple tl2) ->
        subtype_list env trace tl1 tl2 cstrs
    | (Tconstr(p1, [], _), Tconstr(p2, [], _)) when Path.same p1 p2 ->
        cstrs
    | (Tconstr(p1, tl1, abbrev1), _)
      when generic_abbrev env p1 && safe_abbrev env t1 ->
        subtype_rec env trace (expand_abbrev env t1) t2 cstrs
    | (_, Tconstr(p2, tl2, abbrev2))
      when generic_abbrev env p2 && safe_abbrev env t2 ->
        subtype_rec env trace t1 (expand_abbrev env t2) cstrs
    | (Tconstr(p1, tl1, _), Tconstr(p2, tl2, _)) when Path.same p1 p2 ->
        begin try
          let decl = Env.find_type p1 env in
          List.fold_left2
            (fun cstrs v (t1, t2) ->
              let (co, cn) = Variance.get_upper v in
              if co then
                if cn then
                  (trace, newty2 t1.level (Ttuple[t1]),
                   newty2 t2.level (Ttuple[t2]), !univar_pairs) :: cstrs
                else subtype_rec env ((t1, t2)::trace) t1 t2 cstrs
              else
                if cn then subtype_rec env ((t2, t1)::trace) t2 t1 cstrs
                else cstrs)
            cstrs decl.type_variance (List.combine tl1 tl2)
        with Not_found ->
          (trace, t1, t2, !univar_pairs)::cstrs
        end
    | (Tconstr(p1, _, _), _) when generic_private_abbrev env p1 ->
        subtype_rec env trace (expand_abbrev_opt env t1) t2 cstrs
(*  | (_, Tconstr(p2, _, _)) when generic_private_abbrev false env p2 ->
        subtype_rec env trace t1 (expand_abbrev_opt env t2) cstrs *)
    | (Tobject (f1, _), Tobject (f2, _))
      when is_Tvar (object_row f1) && is_Tvar (object_row f2) ->
        (* Same row variable implies same object. *)
        (trace, t1, t2, !univar_pairs)::cstrs
    | (Tobject (f1, _), Tobject (f2, _)) ->
        subtype_fields env trace f1 f2 cstrs
    | (Tvariant row1, Tvariant row2) ->
        begin try
          subtype_row env trace row1 row2 cstrs
        with Exit ->
          (trace, t1, t2, !univar_pairs)::cstrs
        end
    | (Tpoly (u1, []), Tpoly (u2, [])) ->
        subtype_rec env trace u1 u2 cstrs
    | (Tpoly (u1, tl1), Tpoly (u2, [])) ->
        let _, u1' = instance_poly false tl1 u1 in
        subtype_rec env trace u1' u2 cstrs
    | (Tpoly (u1, tl1), Tpoly (u2,tl2)) ->
        begin try
          enter_poly env univar_pairs u1 tl1 u2 tl2
            (fun t1 t2 -> subtype_rec env trace t1 t2 cstrs)
        with Unify _ ->
          (trace, t1, t2, !univar_pairs)::cstrs
        end
(*    | (Tpackage (p1, nl1, tl1), Tpackage (p2, nl2, tl2))
      when eq_package_path env p1 p2 && included nl2 nl1 ->
        List.map2 (fun t1 t2 -> (trace, t1, t2, !univar_pairs))
          (extract_assoc nl2 nl1 tl1) tl2
        @ cstrs *)
    | (Tpackage (p1, nl1, tl1), Tpackage (p2, nl2, tl2)) ->
        begin try
          let ntl1 = complete_type_list env nl2 t1.level (Mty_ident p1) nl1 tl1
          and ntl2 = complete_type_list env nl1 t2.level (Mty_ident p2) nl2 tl2
              ~allow_absent:true in
          let cstrs' =
            List.map
              (fun (n2,t2) -> (trace, List.assoc n2 ntl1, t2, !univar_pairs))
              ntl2
          in
          if eq_package_path env p1 p2 then cstrs' @ cstrs
          else begin
            (* need to check module subtyping *)
            let snap = Btype.snapshot () in
            try
              List.iter (fun (_, t1, t2, _) -> unify env t1 t2) cstrs';
              if !package_subtype env p1 nl1 tl1 p2 nl2 tl2
              then (Btype.backtrack snap; cstrs' @ cstrs)
              else raise (Unify [])
            with Unify _ ->
              Btype.backtrack snap; raise Not_found
          end
        with Not_found ->
          (trace, t1, t2, !univar_pairs)::cstrs
        end
    | (_, _) ->
        (trace, t1, t2, !univar_pairs)::cstrs
  end

and subtype_list env trace tl1 tl2 cstrs =
  if List.length tl1 <> List.length tl2 then
    subtype_error env trace;
  List.fold_left2
    (fun cstrs t1 t2 -> subtype_rec env ((t1, t2)::trace) t1 t2 cstrs)
    cstrs tl1 tl2

and subtype_fields env trace ty1 ty2 cstrs =
  (* Assume that either rest1 or rest2 is not Tvar *)
  let (fields1, rest1) = flatten_fields ty1 in
  let (fields2, rest2) = flatten_fields ty2 in
  let (pairs, miss1, miss2) = associate_fields fields1 fields2 in
  let cstrs =
    if rest2.desc = Tnil then cstrs else
    if miss1 = [] then
      subtype_rec env ((rest1, rest2)::trace) rest1 rest2 cstrs
    else
      (trace, build_fields (repr ty1).level miss1 rest1, rest2,
       !univar_pairs) :: cstrs
  in
  let cstrs =
    if miss2 = [] then cstrs else
    (trace, rest1, build_fields (repr ty2).level miss2 (newvar ()),
     !univar_pairs) :: cstrs
  in
  List.fold_left
    (fun cstrs (_, k1, t1, k2, t2) ->
      (* Theses fields are always present *)
      subtype_rec env ((t1, t2)::trace) t1 t2 cstrs)
    cstrs pairs

and subtype_row env trace row1 row2 cstrs =
  let row1 = row_repr row1 and row2 = row_repr row2 in
  let r1, r2, pairs =
    merge_row_fields row1.row_fields row2.row_fields in
  let more1 = repr row1.row_more
  and more2 = repr row2.row_more in
  match more1.desc, more2.desc with
    Tconstr(p1,_,_), Tconstr(p2,_,_) when Path.same p1 p2 ->
      subtype_rec env ((more1,more2)::trace) more1 more2 cstrs
  | (Tvar _|Tconstr _|Tnil), (Tvar _|Tconstr _|Tnil)
    when row1.row_closed && r1 = [] ->
      List.fold_left
        (fun cstrs (_,f1,f2) ->
          match row_field_repr f1, row_field_repr f2 with
            (Rpresent None|Reither(true,_,_,_)), Rpresent None ->
              cstrs
          | Rpresent(Some t1), Rpresent(Some t2) ->
              subtype_rec env ((t1, t2)::trace) t1 t2 cstrs
          | Reither(false, t1::_, _, _), Rpresent(Some t2) ->
              subtype_rec env ((t1, t2)::trace) t1 t2 cstrs
          | Rabsent, _ -> cstrs
          | _ -> raise Exit)
        cstrs pairs
  | Tunivar _, Tunivar _
    when row1.row_closed = row2.row_closed && r1 = [] && r2 = [] ->
      let cstrs =
        subtype_rec env ((more1,more2)::trace) more1 more2 cstrs in
      List.fold_left
        (fun cstrs (_,f1,f2) ->
          match row_field_repr f1, row_field_repr f2 with
            Rpresent None, Rpresent None
          | Reither(true,[],_,_), Reither(true,[],_,_)
          | Rabsent, Rabsent ->
              cstrs
          | Rpresent(Some t1), Rpresent(Some t2)
          | Reither(false,[t1],_,_), Reither(false,[t2],_,_) ->
              subtype_rec env ((t1, t2)::trace) t1 t2 cstrs
          | _ -> raise Exit)
        cstrs pairs
  | _ ->
      raise Exit

let subtype env ty1 ty2 =
  TypePairs.clear subtypes;
  univar_pairs := [];
  (* Build constraint set. *)
  let cstrs = subtype_rec env [(ty1, ty2)] ty1 ty2 [] in
  TypePairs.clear subtypes;
  (* Enforce constraints. *)
  function () ->
    List.iter
      (function (trace0, t1, t2, pairs) ->
         try unify_pairs (ref env) t1 t2 pairs with Unify trace ->
           raise (Subtype (expand_trace env (List.rev trace0),
                           List.tl (List.tl trace))))
      (List.rev cstrs)

                              (*******************)
                              (*  Miscellaneous  *)
                              (*******************)

(* Utility for printing. The resulting type is not used in computation. *)
let rec unalias_object ty =
  let ty = repr ty in
  match ty.desc with
    Tfield (s, k, t1, t2) ->
      newty2 ty.level (Tfield (s, k, t1, unalias_object t2))
  | Tvar _ | Tnil ->
      newty2 ty.level ty.desc
  | Tunivar _ ->
      ty
  | Tconstr _ ->
      newvar2 ty.level
  | _ ->
      assert false

let unalias ty =
  let ty = repr ty in
  match ty.desc with
    Tvar _ | Tunivar _ ->
      ty
  | Tvariant row ->
      let row = row_repr row in
      let more = row.row_more in
      newty2 ty.level
        (Tvariant {row with row_more = newty2 more.level more.desc})
  | Tobject (ty, nm) ->
      newty2 ty.level (Tobject (unalias_object ty, nm))
  | _ ->
      newty2 ty.level ty.desc

(* Return the arity (as for curried functions) of the given type. *)
let rec arity ty =
  match (repr ty).desc with
    Tarrow(_, t1, t2, _) -> 1 + arity t2
  | _ -> 0

(* Check whether an abbreviation expands to itself. *)
let cyclic_abbrev env id ty =
  let rec check_cycle seen ty =
    let ty = repr ty in
    match ty.desc with
      Tconstr (p, tl, abbrev) ->
        p = Path.Pident id || List.memq ty seen ||
        begin try
          check_cycle (ty :: seen) (expand_abbrev_opt env ty)
        with
          Cannot_expand -> false
        | Unify _ -> true
        end
    | _ ->
        false
  in check_cycle [] ty

(* Normalize a type before printing, saving... *)
(* Cannot use mark_type because deep_occur uses it too *)
let rec normalize_type_rec env visited ty =
  let ty = repr ty in
  if not (TypeSet.mem ty !visited) then begin
    visited := TypeSet.add ty !visited;
    begin match ty.desc with
    | Tvariant row ->
      let row = row_repr row in
      let fields = List.map
          (fun (l,f0) ->
            let f = row_field_repr f0 in l,
            match f with Reither(b, ty::(_::_ as tyl), m, e) ->
              let tyl' =
                List.fold_left
                  (fun tyl ty ->
                    if List.exists (fun ty' -> equal env false [ty] [ty']) tyl
                    then tyl else ty::tyl)
                  [ty] tyl
              in
              if f != f0 || List.length tyl' < List.length tyl then
                Reither(b, List.rev tyl', m, e)
              else f
            | _ -> f)
          row.row_fields in
      let fields =
        List.sort (fun (p,_) (q,_) -> compare p q)
          (List.filter (fun (_,fi) -> fi <> Rabsent) fields) in
      log_type ty;
      ty.desc <- Tvariant {row with row_fields = fields}
    | Tobject (fi, nm) ->
        begin match !nm with
        | None -> ()
        | Some (n, v :: l) ->
            if deep_occur ty (newgenty (Ttuple l)) then
              (* The abbreviation may be hiding something, so remove it *)
              set_name nm None
            else let v' = repr v in
            begin match v'.desc with
            | Tvar _ | Tunivar _ ->
                if v' != v then set_name nm (Some (n, v' :: l))
            | Tnil ->
                log_type ty; ty.desc <- Tconstr (n, l, ref Mnil)
            | _ -> set_name nm None
            end
        | _ ->
            fatal_error "Ctype.normalize_type_rec"
        end;
        let fi = repr fi in
        if fi.level < lowest_level then () else
        let fields, row = flatten_fields fi in
        let fi' = build_fields fi.level fields row in
        log_type ty; fi.desc <- fi'.desc
    | _ -> ()
    end;
    iter_type_expr (normalize_type_rec env visited) ty
  end

let normalize_type env ty =
  normalize_type_rec env (ref TypeSet.empty) ty


                              (*************************)
                              (*  Remove dependencies  *)
                              (*************************)


(*
   Variables are left unchanged. Other type nodes are duplicated, with
   levels set to generic level.
   We cannot use Tsubst here, because unification may be called by
   expand_abbrev.
*)

let nondep_hash     = TypeHash.create 47
let nondep_variants = TypeHash.create 17
let clear_hash ()   =
  TypeHash.clear nondep_hash; TypeHash.clear nondep_variants

let rec nondep_type_rec env id ty =
  match ty.desc with
    Tvar _ | Tunivar _ -> ty
  | Tlink ty -> nondep_type_rec env id ty
  | _ -> try TypeHash.find nondep_hash ty
  with Not_found ->
    let ty' = newgenvar () in        (* Stub *)
    TypeHash.add nondep_hash ty ty';
    ty'.desc <-
      begin match ty.desc with
      | Tconstr(p, tl, abbrev) ->
          if Path.isfree id p then
            begin try
              Tlink (nondep_type_rec env id
                       (expand_abbrev env (newty2 ty.level ty.desc)))
              (*
                 The [Tlink] is important. The expanded type may be a
                 variable, or may not be completely copied yet
                 (recursive type), so one cannot just take its
                 description.
               *)
            with Cannot_expand | Unify _ ->
              raise Not_found
            end
          else
            Tconstr(p, List.map (nondep_type_rec env id) tl, ref Mnil)
      | Tpackage(p, nl, tl) when Path.isfree id p ->
          let p' = normalize_package_path env p in
          if Path.isfree id p' then raise Not_found;
          Tpackage (p', nl, List.map (nondep_type_rec env id) tl)
      | Tobject (t1, name) ->
          Tobject (nondep_type_rec env id t1,
                 ref (match !name with
                        None -> None
                      | Some (p, tl) ->
                          if Path.isfree id p then None
                          else Some (p, List.map (nondep_type_rec env id) tl)))
      | Tvariant row ->
          let row = row_repr row in
          let more = repr row.row_more in
          (* We must keep sharing according to the row variable *)
          begin try
            let ty2 = TypeHash.find nondep_variants more in
            (* This variant type has been already copied *)
            TypeHash.add nondep_hash ty ty2;
            Tlink ty2
          with Not_found ->
            (* Register new type first for recursion *)
            TypeHash.add nondep_variants more ty';
            let static = static_row row in
            let more' = if static then newgenty Tnil else more in
            (* Return a new copy *)
            let row =
              copy_row (nondep_type_rec env id) true row true more' in
            match row.row_name with
              Some (p, tl) when Path.isfree id p ->
                Tvariant {row with row_name = None}
            | _ -> Tvariant row
          end
      | _ -> copy_type_desc (nondep_type_rec env id) ty.desc
      end;
    ty'

let nondep_type env id ty =
  try
    let ty' = nondep_type_rec env id ty in
    clear_hash ();
    ty'
  with Not_found ->
    clear_hash ();
    raise Not_found

let () = nondep_type' := nondep_type

let unroll_abbrev id tl ty =
  let ty = repr ty and path = Path.Pident id in
  if is_Tvar ty || (List.exists (deep_occur ty) tl)
  || is_object_type path then
    ty
  else
    let ty' = newty2 ty.level ty.desc in
    link_type ty (newty2 ty.level (Tconstr (path, tl, ref Mnil)));
    ty'

(* Preserve sharing inside type declarations. *)
let nondep_type_decl env mid id is_covariant decl =
  try
    let params = List.map (nondep_type_rec env mid) decl.type_params in
    let tk =
      try match decl.type_kind with
        Type_abstract ->
          Type_abstract
      | Type_variant cstrs ->
          Type_variant
            (List.map
               (fun c ->
                 {c with
                  cd_args = List.map (nondep_type_rec env mid) c.cd_args;
                  cd_res = may_map (nondep_type_rec env mid) c.cd_res;
                 }
               )
               cstrs)
      | Type_record(lbls, rep) ->
          Type_record
            (List.map
               (fun l ->
                  {l with ld_type = nondep_type_rec env mid l.ld_type}
               )
               lbls,
             rep)
      | Type_open ->
          Type_open
      with Not_found when is_covariant -> Type_abstract
    and tm =
      try match decl.type_manifest with
        None -> None
      | Some ty ->
          Some (unroll_abbrev id params (nondep_type_rec env mid ty))
      with Not_found when is_covariant ->
        None
    in
    clear_hash ();
    let priv =
      match tm with
      | Some ty when Btype.has_constr_row ty -> Private
      | _ -> decl.type_private
    in
    { type_params = params;
      type_arity = decl.type_arity;
      type_kind = tk;
      type_manifest = tm;
      type_private = priv;
      type_variance = decl.type_variance;
      type_newtype_level = None;
      type_loc = decl.type_loc;
      type_attributes = decl.type_attributes;
    }
  with Not_found ->
    clear_hash ();
    raise Not_found

(* Preserve sharing inside extension constructors. *)
let nondep_extension_constructor env mid ext =
  try
    let type_path, type_params =
      if Path.isfree mid ext.ext_type_path then
        begin
          let ty =
            newgenty (Tconstr(ext.ext_type_path, ext.ext_type_params, ref Mnil))
          in
          let ty' = nondep_type_rec env mid ty in
            match (repr ty').desc with
                Tconstr(p, tl, _) -> p, tl
              | _ -> raise Not_found
        end
      else
        let type_params =
          List.map (nondep_type_rec env mid) ext.ext_type_params
        in
          ext.ext_type_path, type_params
    in
    let args = List.map (nondep_type_rec env mid) ext.ext_args in
    let ret_type = may_map (nondep_type_rec env mid) ext.ext_ret_type in
      clear_hash ();
      { ext_type_path = type_path;
        ext_type_params = type_params;
        ext_args = args;
        ext_ret_type = ret_type;
        ext_private = ext.ext_private;
        ext_attributes = ext.ext_attributes;
        ext_loc = ext.ext_loc;
      }
  with Not_found ->
    clear_hash ();
    raise Not_found


(* Preserve sharing inside class types. *)
let nondep_class_signature env id sign =
  { csig_self = nondep_type_rec env id sign.csig_self;
    csig_vars =
      Vars.map (function (m, v, t) -> (m, v, nondep_type_rec env id t))
        sign.csig_vars;
    csig_concr = sign.csig_concr;
    csig_inher =
      List.map (fun (p,tl) -> (p, List.map (nondep_type_rec env id) tl))
        sign.csig_inher }

let rec nondep_class_type env id =
  function
    Cty_constr (p, _, cty) when Path.isfree id p ->
      nondep_class_type env id cty
  | Cty_constr (p, tyl, cty) ->
      Cty_constr (p, List.map (nondep_type_rec env id) tyl,
                   nondep_class_type env id cty)
  | Cty_signature sign ->
      Cty_signature (nondep_class_signature env id sign)
  | Cty_arrow (l, ty, cty) ->
      Cty_arrow (l, nondep_type_rec env id ty, nondep_class_type env id cty)

let nondep_class_declaration env id decl =
  assert (not (Path.isfree id decl.cty_path));
  let decl =
    { cty_params = List.map (nondep_type_rec env id) decl.cty_params;
      cty_variance = decl.cty_variance;
      cty_type = nondep_class_type env id decl.cty_type;
      cty_path = decl.cty_path;
      cty_new =
        begin match decl.cty_new with
          None    -> None
        | Some ty -> Some (nondep_type_rec env id ty)
        end;
      cty_loc = decl.cty_loc;
      cty_attributes = decl.cty_attributes;
    }
  in
  clear_hash ();
  decl

let nondep_cltype_declaration env id decl =
  assert (not (Path.isfree id decl.clty_path));
  let decl =
    { clty_params = List.map (nondep_type_rec env id) decl.clty_params;
      clty_variance = decl.clty_variance;
      clty_type = nondep_class_type env id decl.clty_type;
      clty_path = decl.clty_path;
      clty_loc = decl.clty_loc;
      clty_attributes = decl.clty_attributes;
    }
  in
  clear_hash ();
  decl

(* collapse conjonctive types in class parameters *)
let rec collapse_conj env visited ty =
  let ty = repr ty in
  if List.memq ty visited then () else
  let visited = ty :: visited in
  match ty.desc with
    Tvariant row ->
      let row = row_repr row in
      List.iter
        (fun (l,fi) ->
          match row_field_repr fi with
            Reither (c, t1::(_::_ as tl), m, e) ->
              List.iter (unify env t1) tl;
              set_row_field e (Reither (c, [t1], m, ref None))
          | _ ->
              ())
        row.row_fields;
      iter_row (collapse_conj env visited) row
  | _ ->
      iter_type_expr (collapse_conj env visited) ty

let collapse_conj_params env params =
  List.iter (collapse_conj env []) params

end
(** Interface as module  *)
module Outcometree
= struct
#1 "outcometree.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*     Daniel de Rauglaudre, projet Cristal, INRIA Rocquencourt        *)
(*                                                                     *)
(*  Copyright 2001 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Module [Outcometree]: results displayed by the toplevel *)

(* These types represent messages that the toplevel displays as normal
   results or errors. The real displaying is customisable using the hooks:
      [Toploop.print_out_value]
      [Toploop.print_out_type]
      [Toploop.print_out_sig_item]
      [Toploop.print_out_phrase] *)

type out_ident =
  | Oide_apply of out_ident * out_ident
  | Oide_dot of out_ident * string
  | Oide_ident of string

type out_value =
  | Oval_array of out_value list
  | Oval_char of char
  | Oval_constr of out_ident * out_value list
  | Oval_ellipsis
  | Oval_float of float
  | Oval_int of int
  | Oval_int32 of int32
  | Oval_int64 of int64
  | Oval_nativeint of nativeint
  | Oval_list of out_value list
  | Oval_printer of (Format.formatter -> unit)
  | Oval_record of (out_ident * out_value) list
  | Oval_string of string
  | Oval_stuff of string
  | Oval_tuple of out_value list
  | Oval_variant of string * out_value option

type out_type =
  | Otyp_abstract
  | Otyp_open
  | Otyp_alias of out_type * string
  | Otyp_arrow of string * out_type * out_type
  | Otyp_class of bool * out_ident * out_type list
  | Otyp_constr of out_ident * out_type list
  | Otyp_manifest of out_type * out_type
  | Otyp_object of (string * out_type) list * bool option
  | Otyp_record of (string * bool * out_type) list
  | Otyp_stuff of string
  | Otyp_sum of (string * out_type list * out_type option) list
  | Otyp_tuple of out_type list
  | Otyp_var of bool * string
  | Otyp_variant of
      bool * out_variant * bool * (string list) option
  | Otyp_poly of string list * out_type
  | Otyp_module of string * string list * out_type list

and out_variant =
  | Ovar_fields of (string * bool * out_type list) list
  | Ovar_name of out_ident * out_type list

type out_class_type =
  | Octy_constr of out_ident * out_type list
  | Octy_arrow of string * out_type * out_class_type
  | Octy_signature of out_type option * out_class_sig_item list
and out_class_sig_item =
  | Ocsg_constraint of out_type * out_type
  | Ocsg_method of string * bool * bool * out_type
  | Ocsg_value of string * bool * bool * out_type

type out_module_type =
  | Omty_abstract
  | Omty_functor of string * out_module_type option * out_module_type
  | Omty_ident of out_ident
  | Omty_signature of out_sig_item list
  | Omty_alias of out_ident
and out_sig_item =
  | Osig_class of
      bool * string * (string * (bool * bool)) list * out_class_type *
        out_rec_status
  | Osig_class_type of
      bool * string * (string * (bool * bool)) list * out_class_type *
        out_rec_status
  | Osig_typext of out_extension_constructor * out_ext_status
  | Osig_modtype of string * out_module_type
  | Osig_module of string * out_module_type * out_rec_status
  | Osig_type of out_type_decl * out_rec_status
  | Osig_value of string * out_type * string list
and out_type_decl =
  { otype_name: string;
    otype_params: (string * (bool * bool)) list;
    otype_type: out_type;
    otype_private: Asttypes.private_flag;
    otype_cstrs: (out_type * out_type) list }
and out_extension_constructor =
  { oext_name: string;
    oext_type_name: string;
    oext_type_params: string list;
    oext_args: out_type list;
    oext_ret_type: out_type option;
    oext_private: Asttypes.private_flag }
and out_type_extension =
  { otyext_name: string;
    otyext_params: string list;
    otyext_constructors: (string * out_type list * out_type option) list;
    otyext_private: Asttypes.private_flag }
and out_rec_status =
  | Orec_not
  | Orec_first
  | Orec_next
and out_ext_status =
  | Oext_first
  | Oext_next
  | Oext_exception

type out_phrase =
  | Ophr_eval of out_value * out_type
  | Ophr_signature of (out_sig_item * out_value option) list
  | Ophr_exception of (exn * out_value)

end
module Oprint : sig 
#1 "oprint.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*                  Projet Cristal, INRIA Rocquencourt                 *)
(*                                                                     *)
(*  Copyright 2002 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Format
open Outcometree

val out_value : (formatter -> out_value -> unit) ref
val out_type : (formatter -> out_type -> unit) ref
val out_class_type : (formatter -> out_class_type -> unit) ref
val out_module_type : (formatter -> out_module_type -> unit) ref
val out_sig_item : (formatter -> out_sig_item -> unit) ref
val out_signature : (formatter -> out_sig_item list -> unit) ref
val out_type_extension : (formatter -> out_type_extension -> unit) ref
val out_phrase : (formatter -> out_phrase -> unit) ref

val parenthesized_ident : string -> bool

end = struct
#1 "oprint.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*                  Projet Cristal, INRIA Rocquencourt                 *)
(*                                                                     *)
(*  Copyright 2002 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Format
open Outcometree

exception Ellipsis

let cautious f ppf arg =
  try f ppf arg with
    Ellipsis -> fprintf ppf "..."

let rec print_ident ppf =
  function
    Oide_ident s -> pp_print_string ppf s
  | Oide_dot (id, s) ->
      print_ident ppf id; pp_print_char ppf '.'; pp_print_string ppf s
  | Oide_apply (id1, id2) ->
      fprintf ppf "%a(%a)" print_ident id1 print_ident id2

let parenthesized_ident name =
  (List.mem name ["or"; "mod"; "land"; "lor"; "lxor"; "lsl"; "lsr"; "asr"])
  ||
  (match name.[0] with
      'a'..'z' | 'A'..'Z' | '\223'..'\246' | '\248'..'\255' | '_' ->
        false
    | _ -> true)

let value_ident ppf name =
  if parenthesized_ident name then
    fprintf ppf "( %s )" name
  else
    pp_print_string ppf name

(* Values *)

let valid_float_lexeme s =
  let l = String.length s in
  let rec loop i =
    if i >= l then s ^ "." else
    match s.[i] with
    | '0' .. '9' | '-' -> loop (i+1)
    | _ -> s
  in loop 0

let float_repres f =
  match classify_float f with
    FP_nan -> "nan"
  | FP_infinite ->
      if f < 0.0 then "neg_infinity" else "infinity"
  | _ ->
      let float_val =
        let s1 = Printf.sprintf "%.12g" f in
        if f = float_of_string s1 then s1 else
        let s2 = Printf.sprintf "%.15g" f in
        if f = float_of_string s2 then s2 else
        Printf.sprintf "%.18g" f
      in valid_float_lexeme float_val

let parenthesize_if_neg ppf fmt v isneg =
  if isneg then pp_print_char ppf '(';
  fprintf ppf fmt v;
  if isneg then pp_print_char ppf ')'

let print_out_value ppf tree =
  let rec print_tree_1 ppf =
    function
    | Oval_constr (name, [param]) ->
        fprintf ppf "@[<1>%a@ %a@]" print_ident name print_constr_param param
    | Oval_constr (name, (_ :: _ as params)) ->
        fprintf ppf "@[<1>%a@ (%a)@]" print_ident name
          (print_tree_list print_tree_1 ",") params
    | Oval_variant (name, Some param) ->
        fprintf ppf "@[<2>`%s@ %a@]" name print_constr_param param
    | tree -> print_simple_tree ppf tree
  and print_constr_param ppf = function
    | Oval_int i -> parenthesize_if_neg ppf "%i" i (i < 0)
    | Oval_int32 i -> parenthesize_if_neg ppf "%lil" i (i < 0l)
    | Oval_int64 i -> parenthesize_if_neg ppf "%LiL" i (i < 0L)
    | Oval_nativeint i -> parenthesize_if_neg ppf "%nin" i (i < 0n)
    | Oval_float f -> parenthesize_if_neg ppf "%s" (float_repres f) (f < 0.0)
    | tree -> print_simple_tree ppf tree
  and print_simple_tree ppf =
    function
      Oval_int i -> fprintf ppf "%i" i
    | Oval_int32 i -> fprintf ppf "%lil" i
    | Oval_int64 i -> fprintf ppf "%LiL" i
    | Oval_nativeint i -> fprintf ppf "%nin" i
    | Oval_float f -> pp_print_string ppf (float_repres f)
    | Oval_char c -> fprintf ppf "%C" c
    | Oval_string s ->
        begin try fprintf ppf "%S" s with
          Invalid_argument "String.create" -> fprintf ppf "<huge string>"
        end
    | Oval_list tl ->
        fprintf ppf "@[<1>[%a]@]" (print_tree_list print_tree_1 ";") tl
    | Oval_array tl ->
        fprintf ppf "@[<2>[|%a|]@]" (print_tree_list print_tree_1 ";") tl
    | Oval_constr (name, []) -> print_ident ppf name
    | Oval_variant (name, None) -> fprintf ppf "`%s" name
    | Oval_stuff s -> pp_print_string ppf s
    | Oval_record fel ->
        fprintf ppf "@[<1>{%a}@]" (cautious (print_fields true)) fel
    | Oval_ellipsis -> raise Ellipsis
    | Oval_printer f -> f ppf
    | Oval_tuple tree_list ->
        fprintf ppf "@[<1>(%a)@]" (print_tree_list print_tree_1 ",") tree_list
    | tree -> fprintf ppf "@[<1>(%a)@]" (cautious print_tree_1) tree
  and print_fields first ppf =
    function
      [] -> ()
    | (name, tree) :: fields ->
        if not first then fprintf ppf ";@ ";
        fprintf ppf "@[<1>%a@ =@ %a@]" print_ident name (cautious print_tree_1)
          tree;
        print_fields false ppf fields
  and print_tree_list print_item sep ppf tree_list =
    let rec print_list first ppf =
      function
        [] -> ()
      | tree :: tree_list ->
          if not first then fprintf ppf "%s@ " sep;
          print_item ppf tree;
          print_list false ppf tree_list
    in
    cautious (print_list true) ppf tree_list
  in
  cautious print_tree_1 ppf tree

let out_value = ref print_out_value

(* Types *)

let rec print_list_init pr sep ppf =
  function
    [] -> ()
  | a :: l -> sep ppf; pr ppf a; print_list_init pr sep ppf l

let rec print_list pr sep ppf =
  function
    [] -> ()
  | [a] -> pr ppf a
  | a :: l -> pr ppf a; sep ppf; print_list pr sep ppf l

let pr_present =
  print_list (fun ppf s -> fprintf ppf "`%s" s) (fun ppf -> fprintf ppf "@ ")

let pr_vars =
  print_list (fun ppf s -> fprintf ppf "'%s" s) (fun ppf -> fprintf ppf "@ ")

let rec print_out_type ppf =
  function
  | Otyp_alias (ty, s) ->
      fprintf ppf "@[%a@ as '%s@]" print_out_type ty s
  | Otyp_poly (sl, ty) ->
      fprintf ppf "@[<hov 2>%a.@ %a@]"
        pr_vars sl
        print_out_type ty
  | ty ->
      print_out_type_1 ppf ty

and print_out_type_1 ppf =
  function
    Otyp_arrow (lab, ty1, ty2) ->
      pp_open_box ppf 0;
      if lab <> "" then (pp_print_string ppf lab; pp_print_char ppf ':');
      print_out_type_2 ppf ty1;
      pp_print_string ppf " ->";
      pp_print_space ppf ();
      print_out_type_1 ppf ty2;
      pp_close_box ppf ()
  | ty -> print_out_type_2 ppf ty
and print_out_type_2 ppf =
  function
    Otyp_tuple tyl ->
      fprintf ppf "@[<0>%a@]" (print_typlist print_simple_out_type " *") tyl
  | ty -> print_simple_out_type ppf ty
and print_simple_out_type ppf =
  function
    Otyp_class (ng, id, tyl) ->
      fprintf ppf "@[%a%s#%a@]" print_typargs tyl (if ng then "_" else "")
        print_ident id
         
  | Otyp_constr ( (Oide_dot ((Oide_dot (Oide_ident "Js", "Internal")),
                             ("fn" | "meth" as name )) as id) ,
                 ([Otyp_variant(_,Ovar_fields [ variant, _, tys], _,_); result] as tyl))
    ->
      (* Otyp_arrow*)
      let make tys result =
        if tys = [] then
          Otyp_arrow ("", Otyp_constr (Oide_ident "unit", []),result)
        else
            match tys with
          | [ Otyp_tuple tys as single] -> 
              if variant = "Arity_1" then
                Otyp_arrow ("", single, result)
              else 
                List.fold_right (fun x acc  -> Otyp_arrow("",x,acc) ) tys result
          | [single] ->
              Otyp_arrow ("", single, result)
          | _ -> 
              raise_notrace Not_found
      in
      begin match (make tys result) with
      | exception _ ->
          begin 
            pp_open_box ppf 0;
            print_typargs ppf tyl;
            print_ident ppf id;
            pp_close_box ppf ()
          end
      | res ->
          begin match name  with
          | "fn" -> 
              fprintf ppf "@[<0>(%a@ [@bs])@]" print_out_type_1 res
          | "meth" ->
              fprintf ppf "@[<0>(%a@ [@bs.meth])@]" print_out_type_1 res
          | _ -> assert false 
          end
      end
  | Otyp_constr ((Oide_dot (Oide_dot (Oide_ident "Js", "Internal"), "meth_callback" ) as id) ,
                 ([Otyp_variant(_,Ovar_fields [ variant, _, tys], _,_); result] as tyl))
    ->
      let make tys result =
          match tys with
          | [ Otyp_tuple tys as single ] -> 
              if variant = "Arity_1" then Otyp_arrow ("", single, result)
              else 
                List.fold_right (fun x acc  -> Otyp_arrow("",x,acc) ) tys result
          | [single] ->
              Otyp_arrow ("", single, result)
          | _ -> 
              raise_notrace Not_found
      in
      begin match (make tys result) with
      | exception _ ->
          begin 
            pp_open_box ppf 0;
            print_typargs ppf tyl;
            print_ident ppf id;
            pp_close_box ppf ()
          end
      | res ->
          fprintf ppf "@[<0>(%a@ [@bs.this])@]" print_out_type_1 res

      end
      
  | Otyp_constr (id, tyl) ->
      pp_open_box ppf 0;
      print_typargs ppf tyl;
      print_ident ppf id;
      pp_close_box ppf ()
  | Otyp_object (fields, rest) ->
      fprintf ppf "@[<2>< %a >@]" (print_fields rest) fields
  | Otyp_stuff s -> pp_print_string ppf s
  | Otyp_var (ng, s) -> fprintf ppf "'%s%s" (if ng then "_" else "") s
  | Otyp_variant (non_gen, row_fields, closed, tags) ->
      let print_present ppf =
        function
          None | Some [] -> ()
        | Some l -> fprintf ppf "@;<1 -2>> @[<hov>%a@]" pr_present l
      in
      let print_fields ppf =
        function
          Ovar_fields fields ->
            print_list print_row_field (fun ppf -> fprintf ppf "@;<1 -2>| ")
              ppf fields
        | Ovar_name (id, tyl) ->
            fprintf ppf "@[%a%a@]" print_typargs tyl print_ident id
      in
      fprintf ppf "%s[%s@[<hv>@[<hv>%a@]%a ]@]" (if non_gen then "_" else "")
        (if closed then if tags = None then " " else "< "
         else if tags = None then "> " else "? ")
        print_fields row_fields
        print_present tags
  | Otyp_alias _ | Otyp_poly _ | Otyp_arrow _ | Otyp_tuple _ as ty ->
      pp_open_box ppf 1;
      pp_print_char ppf '(';
      print_out_type ppf ty;
      pp_print_char ppf ')';
      pp_close_box ppf ()
  | Otyp_abstract | Otyp_open
  | Otyp_sum _ | Otyp_record _ | Otyp_manifest (_, _) -> ()
  | Otyp_module (p, n, tyl) ->
      fprintf ppf "@[<1>(module %s" p;
      let first = ref true in
      List.iter2
        (fun s t ->
          let sep = if !first then (first := false; "with") else "and" in
          fprintf ppf " %s type %s = %a" sep s print_out_type t
        )
        n tyl;
      fprintf ppf ")@]"
and print_fields rest ppf =
  function
    [] ->
      begin match rest with
        Some non_gen -> fprintf ppf "%s.." (if non_gen then "_" else "")
      | None -> ()
      end
  | [s, t] ->
      fprintf ppf "%s : %a" s print_out_type t;
      begin match rest with
        Some _ -> fprintf ppf ";@ "
      | None -> ()
      end;
      print_fields rest ppf []
  | (s, t) :: l ->
      fprintf ppf "%s : %a;@ %a" s print_out_type t (print_fields rest) l
and print_row_field ppf (l, opt_amp, tyl) =
  let pr_of ppf =
    if opt_amp then fprintf ppf " of@ &@ "
    else if tyl <> [] then fprintf ppf " of@ "
    else fprintf ppf ""
  in
  fprintf ppf "@[<hv 2>`%s%t%a@]" l pr_of (print_typlist print_out_type " &")
    tyl
and print_typlist print_elem sep ppf =
  function
    [] -> ()
  | [ty] -> print_elem ppf ty
  | ty :: tyl ->
      print_elem ppf ty;
      pp_print_string ppf sep;
      pp_print_space ppf ();
      print_typlist print_elem sep ppf tyl
and print_typargs ppf =
  function
    [] -> ()
  | [ty1] -> print_simple_out_type ppf ty1; pp_print_space ppf ()
  | tyl ->
      pp_open_box ppf 1;
      pp_print_char ppf '(';
      print_typlist print_out_type "," ppf tyl;
      pp_print_char ppf ')';
      pp_close_box ppf ();
      pp_print_space ppf ()

let out_type = ref print_out_type

(* Class types *)

let type_parameter ppf (ty, (co, cn)) =
  fprintf ppf "%s%s"
    (if not cn then "+" else if not co then "-" else "")
    (if ty = "_" then ty else "'"^ty)

let print_out_class_params ppf =
  function
    [] -> ()
  | tyl ->
      fprintf ppf "@[<1>[%a]@]@ "
        (print_list type_parameter (fun ppf -> fprintf ppf ", "))
        tyl

let rec print_out_class_type ppf =
  function
    Octy_constr (id, tyl) ->
      let pr_tyl ppf =
        function
          [] -> ()
        | tyl ->
            fprintf ppf "@[<1>[%a]@]@ " (print_typlist !out_type ",") tyl
      in
      fprintf ppf "@[%a%a@]" pr_tyl tyl print_ident id
  | Octy_arrow (lab, ty, cty) ->
      fprintf ppf "@[%s%a ->@ %a@]" (if lab <> "" then lab ^ ":" else "")
        print_out_type_2 ty print_out_class_type cty
  | Octy_signature (self_ty, csil) ->
      let pr_param ppf =
        function
          Some ty -> fprintf ppf "@ @[(%a)@]" !out_type ty
        | None -> ()
      in
      fprintf ppf "@[<hv 2>@[<2>object%a@]@ %a@;<1 -2>end@]" pr_param self_ty
        (print_list print_out_class_sig_item (fun ppf -> fprintf ppf "@ "))
        csil
and print_out_class_sig_item ppf =
  function
    Ocsg_constraint (ty1, ty2) ->
      fprintf ppf "@[<2>constraint %a =@ %a@]" !out_type ty1
        !out_type ty2
  | Ocsg_method (name, priv, virt, ty) ->
      fprintf ppf "@[<2>method %s%s%s :@ %a@]"
        (if priv then "private " else "") (if virt then "virtual " else "")
        name !out_type ty
  | Ocsg_value (name, mut, vr, ty) ->
      fprintf ppf "@[<2>val %s%s%s :@ %a@]"
        (if mut then "mutable " else "")
        (if vr then "virtual " else "")
        name !out_type ty

let out_class_type = ref print_out_class_type

(* Signature *)

let out_module_type = ref (fun _ -> failwith "Oprint.out_module_type")
let out_sig_item = ref (fun _ -> failwith "Oprint.out_sig_item")
let out_signature = ref (fun _ -> failwith "Oprint.out_signature")
let out_type_extension = ref (fun _ -> failwith "Oprint.out_type_extension")

let rec print_out_functor ppf =
  function
    Omty_functor (_, None, mty_res) ->
      fprintf ppf "() %a" print_out_functor mty_res
  | Omty_functor (name , Some mty_arg, mty_res) ->
      fprintf ppf "(%s : %a) %a" name
        print_out_module_type mty_arg print_out_functor mty_res
  | m -> fprintf ppf "->@ %a" print_out_module_type m
and print_out_module_type ppf =
  function
    Omty_abstract -> ()
  | Omty_functor _ as t ->
      fprintf ppf "@[<2>functor@ %a@]" print_out_functor t
  | Omty_ident id -> fprintf ppf "%a" print_ident id
  | Omty_signature sg ->
      fprintf ppf "@[<hv 2>sig@ %a@;<1 -2>end@]" !out_signature sg
  | Omty_alias id -> fprintf ppf "(module %a)" print_ident id
and print_out_signature ppf =
  function
    [] -> ()
  | [item] -> !out_sig_item ppf item
  | Osig_typext(ext, Oext_first) :: items ->
      (* Gather together the extension constructors *)
      let rec gather_extensions acc items =
        match items with
            Osig_typext(ext, Oext_next) :: items ->
              gather_extensions
                ((ext.oext_name, ext.oext_args, ext.oext_ret_type) :: acc)
                items
          | _ -> (List.rev acc, items)
      in
      let exts, items =
        gather_extensions
          [(ext.oext_name, ext.oext_args, ext.oext_ret_type)]
          items
      in
      let te =
        { otyext_name = ext.oext_type_name;
          otyext_params = ext.oext_type_params;
          otyext_constructors = exts;
          otyext_private = ext.oext_private }
      in
        fprintf ppf "%a@ %a" !out_type_extension te print_out_signature items
  | item :: items ->
      fprintf ppf "%a@ %a" !out_sig_item item print_out_signature items
and print_out_sig_item ppf =
  function
    Osig_class (vir_flag, name, params, clt, rs) ->
      fprintf ppf "@[<2>%s%s@ %a%s@ :@ %a@]"
        (if rs = Orec_next then "and" else "class")
        (if vir_flag then " virtual" else "") print_out_class_params params
        name !out_class_type clt
  | Osig_class_type (vir_flag, name, params, clt, rs) ->
      fprintf ppf "@[<2>%s%s@ %a%s@ =@ %a@]"
        (if rs = Orec_next then "and" else "class type")
        (if vir_flag then " virtual" else "") print_out_class_params params
        name !out_class_type clt
  | Osig_typext (ext, Oext_exception) ->
      fprintf ppf "@[<2>exception %a@]"
        print_out_constr (ext.oext_name, ext.oext_args, ext.oext_ret_type)
  | Osig_typext (ext, es) ->
      print_out_extension_constructor ppf ext
  | Osig_modtype (name, Omty_abstract) ->
      fprintf ppf "@[<2>module type %s@]" name
  | Osig_modtype (name, mty) ->
      fprintf ppf "@[<2>module type %s =@ %a@]" name !out_module_type mty
  | Osig_module (name, Omty_alias id, _) ->
      fprintf ppf "@[<2>module %s =@ %a@]" name print_ident id
  | Osig_module (name, mty, rs) ->
      fprintf ppf "@[<2>%s %s :@ %a@]"
        (match rs with Orec_not -> "module"
                     | Orec_first -> "module rec"
                     | Orec_next -> "and")
        name !out_module_type mty
  | Osig_type(td, rs) ->
        print_out_type_decl
          (match rs with
           | Orec_not   -> "type nonrec"
           | Orec_first -> "type"
           | Orec_next  -> "and")
          ppf td
  | Osig_value (name, ty, prims) ->
      let kwd = if prims = [] then "val" else "external" in
      let pr_prims ppf =
        function
          [] -> ()
        | s :: sl ->
            fprintf ppf "@ = \"%s\"" s;
            List.iter (fun s ->
(* TODO: in general, we should print bs attributes, some attributes like
  bs.splice does need it *)

    let len = String.length s in
    if len >= 3 && s.[0] = 'B' && s.[1] = 'S' && s.[2] = ':' then
      fprintf ppf "@ \"BS-EXTERNAL\"" 
    else
      fprintf ppf "@ \"%s\"" s
                  
              ) sl
      in
      fprintf ppf "@[<2>%s %a :@ %a%a@]" kwd value_ident name !out_type
        ty pr_prims prims

and print_out_type_decl kwd ppf td =
  let print_constraints ppf =
    List.iter
      (fun (ty1, ty2) ->
         fprintf ppf "@ @[<2>constraint %a =@ %a@]" !out_type ty1
           !out_type ty2)
      td.otype_cstrs
  in
  let type_defined ppf =
    match td.otype_params with
      [] -> pp_print_string ppf td.otype_name
    | [param] -> fprintf ppf "@[%a@ %s@]" type_parameter param td.otype_name
    | _ ->
        fprintf ppf "@[(@[%a)@]@ %s@]"
          (print_list type_parameter (fun ppf -> fprintf ppf ",@ "))
          td.otype_params
          td.otype_name
  in
  let print_manifest ppf =
    function
      Otyp_manifest (ty, _) -> fprintf ppf " =@ %a" !out_type ty
    | _ -> ()
  in
  let print_name_params ppf =
    fprintf ppf "%s %t%a" kwd type_defined print_manifest td.otype_type
  in
  let ty =
    match td.otype_type with
      Otyp_manifest (_, ty) -> ty
    | _ -> td.otype_type
  in
  let print_private ppf = function
    Asttypes.Private -> fprintf ppf " private"
  | Asttypes.Public -> ()
  in
  let print_out_tkind ppf = function
  | Otyp_abstract -> ()
  | Otyp_record lbls ->
      fprintf ppf " =%a {%a@;<1 -2>}"
        print_private td.otype_private
        (print_list_init print_out_label (fun ppf -> fprintf ppf "@ ")) lbls
  | Otyp_sum constrs ->
      fprintf ppf " =%a@;<1 2>%a"
        print_private td.otype_private
        (print_list print_out_constr (fun ppf -> fprintf ppf "@ | ")) constrs
  | Otyp_open ->
      fprintf ppf " = .."
  | ty ->
      fprintf ppf " =%a@;<1 2>%a"
        print_private td.otype_private
        !out_type ty
  in
  fprintf ppf "@[<2>@[<hv 2>%t%a@]%t@]"
    print_name_params
    print_out_tkind ty
    print_constraints

and print_out_constr ppf (name, tyl,ret_type_opt) =
  match ret_type_opt with
  | None ->
      begin match tyl with
      | [] ->
          pp_print_string ppf name
      | _ ->
          fprintf ppf "@[<2>%s of@ %a@]" name
            (print_typlist print_simple_out_type " *") tyl
      end
  | Some ret_type ->
      begin match tyl with
      | [] ->
          fprintf ppf "@[<2>%s :@ %a@]" name print_simple_out_type  ret_type
      | _ ->
          fprintf ppf "@[<2>%s :@ %a -> %a@]" name
            (print_typlist print_simple_out_type " *")
            tyl print_simple_out_type ret_type
      end


and print_out_label ppf (name, mut, arg) =
  fprintf ppf "@[<2>%s%s :@ %a@];" (if mut then "mutable " else "") name
    !out_type arg

and print_out_extension_constructor ppf ext =
  let print_extended_type ppf =
    let print_type_parameter ppf ty =
      fprintf ppf "%s"
        (if ty = "_" then ty else "'"^ty)
    in
      match ext.oext_type_params with
        [] -> fprintf ppf "%s" ext.oext_type_name
      | [ty_param] ->
        fprintf ppf "@[%a@ %s@]"
          print_type_parameter
          ty_param
          ext.oext_type_name
      | _ ->
        fprintf ppf "@[(@[%a)@]@ %s@]"
          (print_list print_type_parameter (fun ppf -> fprintf ppf ",@ "))
          ext.oext_type_params
          ext.oext_type_name
  in
  fprintf ppf "@[<hv 2>type %t +=%s@;<1 2>%a@]"
    print_extended_type
    (if ext.oext_private = Asttypes.Private then " private" else "")
    print_out_constr (ext.oext_name, ext.oext_args, ext.oext_ret_type)

and print_out_type_extension ppf te =
  let print_extended_type ppf =
    let print_type_parameter ppf ty =
      fprintf ppf "%s"
        (if ty = "_" then ty else "'"^ty)
    in
    match te.otyext_params with
      [] -> fprintf ppf "%s" te.otyext_name
    | [param] ->
      fprintf ppf "@[%a@ %s@]"
        print_type_parameter param
        te.otyext_name
    | _ ->
        fprintf ppf "@[(@[%a)@]@ %s@]"
          (print_list print_type_parameter (fun ppf -> fprintf ppf ",@ "))
          te.otyext_params
          te.otyext_name
  in
  fprintf ppf "@[<hv 2>type %t +=%s@;<1 2>%a@]"
    print_extended_type
    (if te.otyext_private = Asttypes.Private then " private" else "")
    (print_list print_out_constr (fun ppf -> fprintf ppf "@ | "))
    te.otyext_constructors

let _ = out_module_type := print_out_module_type
let _ = out_signature := print_out_signature
let _ = out_sig_item := print_out_sig_item
let _ = out_type_extension := print_out_type_extension

(* Phrases *)

let print_out_exception ppf exn outv =
  match exn with
    Sys.Break -> fprintf ppf "Interrupted.@."
  | Out_of_memory -> fprintf ppf "Out of memory during evaluation.@."
  | Stack_overflow ->
      fprintf ppf "Stack overflow during evaluation (looping recursion?).@."
  | _ -> fprintf ppf "@[Exception:@ %a.@]@." !out_value outv

let rec print_items ppf =
  function
    [] -> ()
  | (Osig_typext(ext, Oext_first), None) :: items ->
      (* Gather together extension constructors *)
      let rec gather_extensions acc items =
        match items with
            (Osig_typext(ext, Oext_next), None) :: items ->
              gather_extensions
                ((ext.oext_name, ext.oext_args, ext.oext_ret_type) :: acc)
                items
          | _ -> (List.rev acc, items)
      in
      let exts, items =
        gather_extensions
          [(ext.oext_name, ext.oext_args, ext.oext_ret_type)]
          items
      in
      let te =
        { otyext_name = ext.oext_type_name;
          otyext_params = ext.oext_type_params;
          otyext_constructors = exts;
          otyext_private = ext.oext_private }
      in
        fprintf ppf "@[%a@]" !out_type_extension te;
        if items <> [] then fprintf ppf "@ %a" print_items items
  | (tree, valopt) :: items ->
      begin match valopt with
        Some v ->
          fprintf ppf "@[<2>%a =@ %a@]" !out_sig_item tree
            !out_value v
      | None -> fprintf ppf "@[%a@]" !out_sig_item tree
      end;
      if items <> [] then fprintf ppf "@ %a" print_items items

let print_out_phrase ppf =
  function
    Ophr_eval (outv, ty) ->
      fprintf ppf "@[- : %a@ =@ %a@]@." !out_type ty !out_value outv
  | Ophr_signature [] -> ()
  | Ophr_signature items -> fprintf ppf "@[<v>%a@]@." print_items items
  | Ophr_exception (exn, outv) -> print_out_exception ppf exn outv

let out_phrase = ref print_out_phrase

end
module Printtyp : sig 
#1 "printtyp.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Printing functions *)

open Format
open Types
open Outcometree

val longident: formatter -> Longident.t -> unit
val ident: formatter -> Ident.t -> unit
val tree_of_path: Path.t -> out_ident
val path: formatter -> Path.t -> unit
val string_of_path: Path.t -> string
val raw_type_expr: formatter -> type_expr -> unit

val wrap_printing_env: Env.t -> (unit -> 'a) -> 'a
    (* Call the function using the environment for type path shortening *)
    (* This affects all the printing functions below *)

val reset: unit -> unit
val mark_loops: type_expr -> unit
val reset_and_mark_loops: type_expr -> unit
val reset_and_mark_loops_list: type_expr list -> unit
val type_expr: formatter -> type_expr -> unit
val tree_of_type_scheme: type_expr -> out_type
val type_sch : formatter -> type_expr -> unit
val type_scheme: formatter -> type_expr -> unit
(* Maxence *)
val reset_names: unit -> unit
val type_scheme_max: ?b_reset_names: bool ->
        formatter -> type_expr -> unit
(* Fin Maxence *)
val tree_of_value_description: Ident.t -> value_description -> out_sig_item
val value_description: Ident.t -> formatter -> value_description -> unit
val tree_of_type_declaration:
    Ident.t -> type_declaration -> rec_status -> out_sig_item
val type_declaration: Ident.t -> formatter -> type_declaration -> unit
val tree_of_extension_constructor:
    Ident.t -> extension_constructor -> ext_status -> out_sig_item
val extension_constructor:
    Ident.t -> formatter -> extension_constructor -> unit
val tree_of_module: Ident.t -> module_type -> rec_status -> out_sig_item
val modtype: formatter -> module_type -> unit
val signature: formatter -> signature -> unit
val tree_of_modtype_declaration:
    Ident.t -> modtype_declaration -> out_sig_item
val tree_of_signature: Types.signature -> out_sig_item list
val tree_of_typexp: bool -> type_expr -> out_type
val modtype_declaration: Ident.t -> formatter -> modtype_declaration -> unit
val class_type: formatter -> class_type -> unit
val tree_of_class_declaration:
    Ident.t -> class_declaration -> rec_status -> out_sig_item
val class_declaration: Ident.t -> formatter -> class_declaration -> unit
val tree_of_cltype_declaration:
    Ident.t -> class_type_declaration -> rec_status -> out_sig_item
val cltype_declaration: Ident.t -> formatter -> class_type_declaration -> unit
val type_expansion: type_expr -> Format.formatter -> type_expr -> unit
val prepare_expansion: type_expr * type_expr -> type_expr * type_expr
val trace:
    bool -> bool-> string -> formatter -> (type_expr * type_expr) list -> unit
val report_unification_error:
    formatter -> Env.t -> ?unif:bool -> (type_expr * type_expr) list ->
    (formatter -> unit) -> (formatter -> unit) ->
    unit


val super_report_unification_error:
    formatter -> Env.t -> ?unif:bool -> (type_expr * type_expr) list ->
    (formatter -> unit) -> (formatter -> unit) ->
    unit


val report_subtyping_error:
    formatter -> Env.t -> (type_expr * type_expr) list ->
    string -> (type_expr * type_expr) list -> unit
val report_ambiguous_type_error:
    formatter -> Env.t -> (Path.t * Path.t) -> (Path.t * Path.t) list ->
    (formatter -> unit) -> (formatter -> unit) -> (formatter -> unit) -> unit

(* for toploop *)
val hide_rec_items: signature_item list -> unit

end = struct
#1 "printtyp.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(* Xavier Leroy and Jerome Vouillon, projet Cristal, INRIA Rocquencourt*)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Printing functions *)

open Misc
open Ctype
open Format
open Longident
open Path
open Asttypes
open Types
open Btype
open Outcometree

(* Print a long identifier *)

let rec longident ppf = function
  | Lident s -> pp_print_string ppf s
  | Ldot(p, s) -> fprintf ppf "%a.%s" longident p s
  | Lapply(p1, p2) -> fprintf ppf "%a(%a)" longident p1 longident p2

(* Print an identifier *)

let unique_names = ref Ident.empty

let ident_name id =
  try Ident.find_same id !unique_names with Not_found -> Ident.name id

let add_unique id =
  try ignore (Ident.find_same id !unique_names)
  with Not_found ->
    unique_names := Ident.add id (Ident.unique_toplevel_name id) !unique_names

let ident ppf id = pp_print_string ppf (ident_name id)

(* Print a path *)

let ident_pervasive = Ident.create_persistent "Pervasives"

let rec tree_of_path = function
  | Pident id ->
      Oide_ident (ident_name id)
  | Pdot(Pident id, s, pos) when Ident.same id ident_pervasive ->
      Oide_ident s
  | Pdot(p, s, pos) ->
      Oide_dot (tree_of_path p, s)
  | Papply(p1, p2) ->
      Oide_apply (tree_of_path p1, tree_of_path p2)

let rec path ppf = function
  | Pident id ->
      ident ppf id
  | Pdot(Pident id, s, pos) when Ident.same id ident_pervasive ->
      pp_print_string ppf s
  | Pdot(p, s, pos) ->
      path ppf p;
      pp_print_char ppf '.';
      pp_print_string ppf s
  | Papply(p1, p2) ->
      fprintf ppf "%a(%a)" path p1 path p2

let rec string_of_out_ident = function
  | Oide_ident s -> s
  | Oide_dot (id, s) -> String.concat "." [string_of_out_ident id; s]
  | Oide_apply (id1, id2) ->
      String.concat ""
        [string_of_out_ident id1; "("; string_of_out_ident id2; ")"]

let string_of_path p = string_of_out_ident (tree_of_path p)

(* Print a recursive annotation *)

let tree_of_rec = function
  | Trec_not -> Orec_not
  | Trec_first -> Orec_first
  | Trec_next -> Orec_next

(* Print a raw type expression, with sharing *)

let raw_list pr ppf = function
    [] -> fprintf ppf "[]"
  | a :: l ->
      fprintf ppf "@[<1>[%a%t]@]" pr a
        (fun ppf -> List.iter (fun x -> fprintf ppf ";@,%a" pr x) l)

let rec safe_kind_repr v = function
    Fvar {contents=Some k}  ->
      if List.memq k v then "Fvar loop" else
      safe_kind_repr (k::v) k
  | Fvar _ -> "Fvar None"
  | Fpresent -> "Fpresent"
  | Fabsent -> "Fabsent"

let rec safe_commu_repr v = function
    Cok -> "Cok"
  | Cunknown -> "Cunknown"
  | Clink r ->
      if List.memq r v then "Clink loop" else
      safe_commu_repr (r::v) !r

let rec safe_repr v = function
    {desc = Tlink t} when not (List.memq t v) ->
      safe_repr (t::v) t
  | t -> t

let rec list_of_memo = function
    Mnil -> []
  | Mcons (priv, p, t1, t2, rem) -> p :: list_of_memo rem
  | Mlink rem -> list_of_memo !rem

let print_name ppf = function
    None -> fprintf ppf "None"
  | Some name -> fprintf ppf "\"%s\"" name

let visited = ref []
let rec raw_type ppf ty =
  let ty = safe_repr [] ty in
  if List.memq ty !visited then fprintf ppf "{id=%d}" ty.id else begin
    visited := ty :: !visited;
    fprintf ppf "@[<1>{id=%d;level=%d;desc=@,%a}@]" ty.id ty.level
      raw_type_desc ty.desc
  end
and raw_type_list tl = raw_list raw_type tl
and raw_type_desc ppf = function
    Tvar name -> fprintf ppf "Tvar %a" print_name name
  | Tarrow(l,t1,t2,c) ->
      fprintf ppf "@[<hov1>Tarrow(%s,@,%a,@,%a,@,%s)@]"
        l raw_type t1 raw_type t2
        (safe_commu_repr [] c)
  | Ttuple tl ->
      fprintf ppf "@[<1>Ttuple@,%a@]" raw_type_list tl
  | Tconstr (p, tl, abbrev) ->
      fprintf ppf "@[<hov1>Tconstr(@,%a,@,%a,@,%a)@]" path p
        raw_type_list tl
        (raw_list path) (list_of_memo !abbrev)
  | Tobject (t, nm) ->
      fprintf ppf "@[<hov1>Tobject(@,%a,@,@[<1>ref%t@])@]" raw_type t
        (fun ppf ->
          match !nm with None -> fprintf ppf " None"
          | Some(p,tl) ->
              fprintf ppf "(Some(@,%a,@,%a))" path p raw_type_list tl)
  | Tfield (f, k, t1, t2) ->
      fprintf ppf "@[<hov1>Tfield(@,%s,@,%s,@,%a,@;<0 -1>%a)@]" f
        (safe_kind_repr [] k)
        raw_type t1 raw_type t2
  | Tnil -> fprintf ppf "Tnil"
  | Tlink t -> fprintf ppf "@[<1>Tlink@,%a@]" raw_type t
  | Tsubst t -> fprintf ppf "@[<1>Tsubst@,%a@]" raw_type t
  | Tunivar name -> fprintf ppf "Tunivar %a" print_name name
  | Tpoly (t, tl) ->
      fprintf ppf "@[<hov1>Tpoly(@,%a,@,%a)@]"
        raw_type t
        raw_type_list tl
  | Tvariant row ->
      fprintf ppf
        "@[<hov1>{@[%s@,%a;@]@ @[%s@,%a;@]@ %s%b;@ %s%b;@ @[<1>%s%t@]}@]"
        "row_fields="
        (raw_list (fun ppf (l, f) ->
          fprintf ppf "@[%s,@ %a@]" l raw_field f))
        row.row_fields
        "row_more=" raw_type row.row_more
        "row_closed=" row.row_closed
        "row_fixed=" row.row_fixed
        "row_name="
        (fun ppf ->
          match row.row_name with None -> fprintf ppf "None"
          | Some(p,tl) ->
              fprintf ppf "Some(@,%a,@,%a)" path p raw_type_list tl)
  | Tpackage (p, _, tl) ->
      fprintf ppf "@[<hov1>Tpackage(@,%a@,%a)@]" path p
        raw_type_list tl

and raw_field ppf = function
    Rpresent None -> fprintf ppf "Rpresent None"
  | Rpresent (Some t) -> fprintf ppf "@[<1>Rpresent(Some@,%a)@]" raw_type t
  | Reither (c,tl,m,e) ->
      fprintf ppf "@[<hov1>Reither(%b,@,%a,@,%b,@,@[<1>ref%t@])@]" c
        raw_type_list tl m
        (fun ppf ->
          match !e with None -> fprintf ppf " None"
          | Some f -> fprintf ppf "@,@[<1>(%a)@]" raw_field f)
  | Rabsent -> fprintf ppf "Rabsent"

let raw_type_expr ppf t =
  visited := [];
  raw_type ppf t;
  visited := []

let () = Btype.print_raw := raw_type_expr

(* Normalize paths *)

type param_subst = Id | Nth of int | Map of int list

let is_nth = function
    Nth _ -> true
  | _ -> false

let compose l1 = function
  | Id -> Map l1
  | Map l2 -> Map (List.map (List.nth l1) l2)
  | Nth n  -> Nth (List.nth l1 n)

let apply_subst s1 tyl =
  match s1 with
    Nth n1 -> [List.nth tyl n1]
  | Map l1 -> List.map (List.nth tyl) l1
  | Id -> tyl

type best_path = Paths of Path.t list | Best of Path.t

let printing_env = ref Env.empty
let printing_depth = ref 0
let printing_cont = ref ([] : Env.iter_cont list)
let printing_old = ref Env.empty
let printing_pers = ref Concr.empty
module Path2 = struct
  include Path
  let rec compare p1 p2 =
    (* must ignore position when comparing paths *)
    match (p1, p2) with
      (Pdot(p1, s1, pos1), Pdot(p2, s2, pos2)) ->
        let c = compare p1 p2 in
        if c <> 0 then c else String.compare s1 s2
    | (Papply(fun1, arg1), Papply(fun2, arg2)) ->
        let c = compare fun1 fun2 in
        if c <> 0 then c else compare arg1 arg2
    | _ -> Pervasives.compare p1 p2
end
module PathMap = Map.Make(Path2)
let printing_map = ref PathMap.empty

let same_type t t' = repr t == repr t'

let rec index l x =
  match l with
    [] -> raise Not_found
  | a :: l -> if x == a then 0 else 1 + index l x

let rec uniq = function
    [] -> true
  | a :: l -> not (List.memq a l) && uniq l

let rec normalize_type_path ?(cache=false) env p =
  try
    let (params, ty, _) = Env.find_type_expansion p env in
    let params = List.map repr params in
    match repr ty with
      {desc = Tconstr (p1, tyl, _)} ->
        let tyl = List.map repr tyl in
        if List.length params = List.length tyl
        && List.for_all2 (==) params tyl
        then normalize_type_path ~cache env p1
        else if cache || List.length params <= List.length tyl
             || not (uniq tyl) then (p, Id)
        else
          let l1 = List.map (index params) tyl in
          let (p2, s2) = normalize_type_path ~cache env p1 in
          (p2, compose l1 s2)
    | ty ->
        (p, Nth (index params ty))
  with
    Not_found -> (p, Id)

let rec path_size = function
    Pident id ->
      (let s = Ident.name id in if s <> "" && s.[0] = '_' then 10 else 1),
      -Ident.binding_time id
  | Pdot (p, _, _) ->
      let (l, b) = path_size p in (1+l, b)
  | Papply (p1, p2) ->
      let (l, b) = path_size p1 in
      (l + fst (path_size p2), b)

let same_printing_env env =
  let used_pers = Env.used_persistent () in
  Env.same_types !printing_old env && Concr.equal !printing_pers used_pers

let set_printing_env env =
  printing_env := if !Clflags.real_paths then Env.empty else env;
  if !printing_env == Env.empty || same_printing_env env then () else
  begin
    (* printf "Reset printing_map@."; *)
    printing_old := env;
    printing_pers := Env.used_persistent ();
    printing_map := PathMap.empty;
    printing_depth := 0;
    (* printf "Recompute printing_map.@."; *)
    let cont =
      Env.iter_types
        (fun p (p', decl) ->
          let (p1, s1) = normalize_type_path env p' ~cache:true in
          (* Format.eprintf "%a -> %a = %a@." path p path p' path p1 *)
          if s1 = Id then
          try
            let r = PathMap.find p1 !printing_map in
            match !r with
              Paths l -> r := Paths (p :: l)
            | Best p' -> r := Paths [p; p'] (* assert false *)
          with Not_found ->
            printing_map := PathMap.add p1 (ref (Paths [p])) !printing_map)
        env in
    printing_cont := [cont];
  end

let wrap_printing_env env f =
  set_printing_env env;
  try_finally f (fun () -> set_printing_env Env.empty)

let is_unambiguous path env =
  let l = Env.find_shadowed_types path env in
  List.exists (Path.same path) l || (* concrete paths are ok *)
  match l with
    [] -> true
  | p :: rem ->
      (* allow also coherent paths:  *)
      let normalize p = fst (normalize_type_path ~cache:true env p) in
      let p' = normalize p in
      List.for_all (fun p -> Path.same (normalize p) p') rem ||
      (* also allow repeatedly defining and opening (for toplevel) *)
      let id = lid_of_path p in
      List.for_all (fun p -> lid_of_path p = id) rem &&
      Path.same p (fst (Env.lookup_type id env))

let rec get_best_path r =
  match !r with
    Best p' -> p'
  | Paths [] -> raise Not_found
  | Paths l ->
      r := Paths [];
      List.iter
        (fun p ->
          (* Format.eprintf "evaluating %a@." path p; *)
          match !r with
            Best p' when path_size p >= path_size p' -> ()
          | _ -> if is_unambiguous p !printing_env then r := Best p)
              (* else Format.eprintf "%a ignored as ambiguous@." path p *)
        l;
      get_best_path r

let best_type_path p =
  if !Clflags.real_paths || !printing_env == Env.empty
  then (p, Id)
  else
    let (p', s) = normalize_type_path !printing_env p in
    let get_path () = get_best_path (PathMap.find  p' !printing_map) in
    while !printing_cont <> [] &&
      try ignore (get_path ()); false with Not_found -> true
    do
      printing_cont := List.map snd (Env.run_iter_cont !printing_cont);
      incr printing_depth;
    done;
    let p'' = try get_path () with Not_found -> p' in
    (* Format.eprintf "%a = %a -> %a@." path p path p' path p''; *)
    (p'', s)

(* Print a type expression *)

let names = ref ([] : (type_expr * string) list)
let name_counter = ref 0
let named_vars = ref ([] : string list)

let reset_names () = names := []; name_counter := 0; named_vars := []
let add_named_var ty =
  match ty.desc with
    Tvar (Some name) | Tunivar (Some name) ->
      if List.mem name !named_vars then () else
      named_vars := name :: !named_vars
  | _ -> ()

let rec new_name () =
  let name =
    if !name_counter < 26
    then String.make 1 (Char.chr(97 + !name_counter))
    else String.make 1 (Char.chr(97 + !name_counter mod 26)) ^
           string_of_int(!name_counter / 26) in
  incr name_counter;
  if List.mem name !named_vars
  || List.exists (fun (_, name') -> name = name') !names
  then new_name ()
  else name

let name_of_type t =
  (* We've already been through repr at this stage, so t is our representative
     of the union-find class. *)
  try List.assq t !names with Not_found ->
    let name =
      match t.desc with
        Tvar (Some name) | Tunivar (Some name) ->
          (* Some part of the type we've already printed has assigned another
           * unification variable to that name. We want to keep the name, so try
           * adding a number until we find a name that's not taken. *)
          let current_name = ref name in
          let i = ref 0 in
          while List.exists (fun (_, name') -> !current_name = name') !names do
            current_name := name ^ (string_of_int !i);
            i := !i + 1;
          done;
          !current_name
      | _ ->
          (* No name available, create a new one *)
          new_name ()
    in
    (* Exception for type declarations *)
    if name <> "_" then names := (t, name) :: !names;
    name

let check_name_of_type t = ignore(name_of_type t)

let remove_names tyl =
  let tyl = List.map repr tyl in
  names := List.filter (fun (ty,_) -> not (List.memq ty tyl)) !names


let non_gen_mark sch ty =
  if sch && is_Tvar ty && ty.level <> generic_level then "_" else ""

let print_name_of_type sch ppf t =
  fprintf ppf "'%s%s" (non_gen_mark sch t) (name_of_type t)

let visited_objects = ref ([] : type_expr list)
let aliased = ref ([] : type_expr list)
let delayed = ref ([] : type_expr list)

let add_delayed t =
  if not (List.memq t !delayed) then delayed := t :: !delayed

let is_aliased ty = List.memq (proxy ty) !aliased
let add_alias ty =
  let px = proxy ty in
  if not (is_aliased px) then begin
    aliased := px :: !aliased;
    add_named_var px
  end

let aliasable ty =
  match ty.desc with
    Tvar _ | Tunivar _ | Tpoly _ -> false
  | Tconstr (p, _, _) ->
      not (is_nth (snd (best_type_path p)))
  | _ -> true

let namable_row row =
  row.row_name <> None &&
  List.for_all
    (fun (_, f) ->
       match row_field_repr f with
       | Reither(c, l, _, _) ->
           row.row_closed && if c then l = [] else List.length l = 1
       | _ -> true)
    row.row_fields

let rec mark_loops_rec visited ty =
  let ty = repr ty in
  let px = proxy ty in
  if List.memq px visited && aliasable ty then add_alias px else
    let visited = px :: visited in
    match ty.desc with
    | Tvar _ -> add_named_var ty
    | Tarrow(_, ty1, ty2, _) ->
        mark_loops_rec visited ty1; mark_loops_rec visited ty2
    | Ttuple tyl -> List.iter (mark_loops_rec visited) tyl
    | Tconstr(p, tyl, _) ->
        let (p', s) = best_type_path p in
        List.iter (mark_loops_rec visited) (apply_subst s tyl)
    | Tpackage (_, _, tyl) ->
        List.iter (mark_loops_rec visited) tyl
    | Tvariant row ->
        if List.memq px !visited_objects then add_alias px else
         begin
          let row = row_repr row in
          if not (static_row row) then
            visited_objects := px :: !visited_objects;
          match row.row_name with
          | Some(p, tyl) when namable_row row ->
              List.iter (mark_loops_rec visited) tyl
          | _ ->
              iter_row (mark_loops_rec visited) row
         end
    | Tobject (fi, nm) ->
        if List.memq px !visited_objects then add_alias px else
         begin
          if opened_object ty then
            visited_objects := px :: !visited_objects;
          begin match !nm with
          | None ->
              let fields, _ = flatten_fields fi in
              List.iter
                (fun (_, kind, ty) ->
                  if field_kind_repr kind = Fpresent then
                    mark_loops_rec visited ty)
                fields
          | Some (_, l) ->
              List.iter (mark_loops_rec visited) (List.tl l)
          end
        end
    | Tfield(_, kind, ty1, ty2) when field_kind_repr kind = Fpresent ->
        mark_loops_rec visited ty1; mark_loops_rec visited ty2
    | Tfield(_, _, _, ty2) ->
        mark_loops_rec visited ty2
    | Tnil -> ()
    | Tsubst ty -> mark_loops_rec visited ty
    | Tlink _ -> fatal_error "Printtyp.mark_loops_rec (2)"
    | Tpoly (ty, tyl) ->
        List.iter (fun t -> add_alias t) tyl;
        mark_loops_rec visited ty
    | Tunivar _ -> add_named_var ty

let mark_loops ty =
  normalize_type Env.empty ty;
  mark_loops_rec [] ty;;

let reset_loop_marks () =
  visited_objects := []; aliased := []; delayed := []

let reset () =
  unique_names := Ident.empty; reset_names (); reset_loop_marks ()

let reset_and_mark_loops ty =
  reset (); mark_loops ty

let reset_and_mark_loops_list tyl =
  reset (); List.iter mark_loops tyl

(* Disabled in classic mode when printing an unification error *)
let print_labels = ref true
let print_label ppf l =
  if !print_labels && l <> "" || is_optional l then fprintf ppf "%s:" l

let rec tree_of_typexp sch ty =
  let ty = repr ty in
  let px = proxy ty in
  if List.mem_assq px !names && not (List.memq px !delayed) then
   let mark = is_non_gen sch ty in
   Otyp_var (mark, name_of_type px) else

  let pr_typ () =
    match ty.desc with
    | Tvar _ ->
        Otyp_var (is_non_gen sch ty, name_of_type ty)
    | Tarrow(l, ty1, ty2, _) ->
        let pr_arrow l ty1 ty2 =
          let lab =
            if !print_labels && l <> "" || is_optional l then l else ""
          in
          let t1 =
            if is_optional l then
              match (repr ty1).desc with
              | Tconstr(path, [ty], _)
                when Path.same path Predef.path_option ->
                  tree_of_typexp sch ty
              | _ -> Otyp_stuff "<hidden>"
            else tree_of_typexp sch ty1 in
          Otyp_arrow (lab, t1, tree_of_typexp sch ty2) in
        pr_arrow l ty1 ty2
    | Ttuple tyl ->
        Otyp_tuple (tree_of_typlist sch tyl)
    | Tconstr(p, tyl, abbrev) ->
        let p', s = best_type_path p in
        let tyl' = apply_subst s tyl in
        if is_nth s then tree_of_typexp sch (List.hd tyl') else
        Otyp_constr (tree_of_path p', tree_of_typlist sch tyl')
    | Tvariant row ->
        let row = row_repr row in
        let fields =
          if row.row_closed then
            List.filter (fun (_, f) -> row_field_repr f <> Rabsent)
              row.row_fields
          else row.row_fields in
        let present =
          List.filter
            (fun (_, f) ->
               match row_field_repr f with
               | Rpresent _ -> true
               | _ -> false)
            fields in
        let all_present = List.length present = List.length fields in
        begin match row.row_name with
        | Some(p, tyl) when namable_row row ->
            let (p', s) = best_type_path p in
            let id = tree_of_path p' in
            let args = tree_of_typlist sch (apply_subst s tyl) in
            if row.row_closed && all_present then
              if is_nth s then List.hd args else Otyp_constr (id, args)
            else
              let non_gen = is_non_gen sch px in
              let tags =
                if all_present then None else Some (List.map fst present) in
              let inh =
                match args with
                  [Otyp_constr (i, a)] when is_nth s -> Ovar_name (i, a)
                | _ ->
                    (* fallback case, should change outcometree... *)
                    Ovar_name (tree_of_path p, tree_of_typlist sch tyl)
              in
              Otyp_variant (non_gen, inh, row.row_closed, tags)
        | _ ->
            let non_gen =
              not (row.row_closed && all_present) && is_non_gen sch px in
            let fields = List.map (tree_of_row_field sch) fields in
            let tags =
              if all_present then None else Some (List.map fst present) in
            Otyp_variant (non_gen, Ovar_fields fields, row.row_closed, tags)
        end
    | Tobject (fi, nm) ->
        tree_of_typobject sch fi !nm
    | Tnil | Tfield _ ->
        tree_of_typobject sch ty None
    | Tsubst ty ->
        tree_of_typexp sch ty
    | Tlink _ ->
        fatal_error "Printtyp.tree_of_typexp"
    | Tpoly (ty, []) ->
        tree_of_typexp sch ty
    | Tpoly (ty, tyl) ->
        (*let print_names () =
          List.iter (fun (_, name) -> prerr_string (name ^ " ")) !names;
          prerr_string "; " in *)
        let tyl = List.map repr tyl in
        if tyl = [] then tree_of_typexp sch ty else begin
          let old_delayed = !delayed in
          (* Make the names delayed, so that the real type is
             printed once when used as proxy *)
          List.iter add_delayed tyl;
          let tl = List.map name_of_type tyl in
          let tr = Otyp_poly (tl, tree_of_typexp sch ty) in
          (* Forget names when we leave scope *)
          remove_names tyl;
          delayed := old_delayed; tr
        end
    | Tunivar _ ->
        Otyp_var (false, name_of_type ty)
    | Tpackage (p, n, tyl) ->
        let n =
          List.map (fun li -> String.concat "." (Longident.flatten li)) n in
        Otyp_module (Path.name p, n, tree_of_typlist sch tyl)
  in
  if List.memq px !delayed then delayed := List.filter ((!=) px) !delayed;
  if is_aliased px && aliasable ty then begin
    check_name_of_type px;
    Otyp_alias (pr_typ (), name_of_type px) end
  else pr_typ ()

and tree_of_row_field sch (l, f) =
  match row_field_repr f with
  | Rpresent None | Reither(true, [], _, _) -> (l, false, [])
  | Rpresent(Some ty) -> (l, false, [tree_of_typexp sch ty])
  | Reither(c, tyl, _, _) ->
      if c (* contradiction: un constructeur constant qui a un argument *)
      then (l, true, tree_of_typlist sch tyl)
      else (l, false, tree_of_typlist sch tyl)
  | Rabsent -> (l, false, [] (* une erreur, en fait *))

and tree_of_typlist sch tyl =
  List.map (tree_of_typexp sch) tyl

and tree_of_typobject sch fi nm =
  begin match nm with
  | None ->
      let pr_fields fi =
        let (fields, rest) = flatten_fields fi in
        let present_fields =
          List.fold_right
            (fun (n, k, t) l ->
               match field_kind_repr k with
               | Fpresent -> (n, t) :: l
               | _ -> l)
            fields [] in
        let sorted_fields =
          List.sort (fun (n, _) (n', _) -> compare n n') present_fields in
        tree_of_typfields sch rest sorted_fields in
      let (fields, rest) = pr_fields fi in
      Otyp_object (fields, rest)
  | Some (p, ty :: tyl) ->
      let non_gen = is_non_gen sch (repr ty) in
      let args = tree_of_typlist sch tyl in
      let (p', s) = best_type_path p in
      assert (s = Id);
      Otyp_class (non_gen, tree_of_path p', args)
  | _ ->
      fatal_error "Printtyp.tree_of_typobject"
  end

and is_non_gen sch ty =
    sch && is_Tvar ty && ty.level <> generic_level

and tree_of_typfields sch rest = function
  | [] ->
      let rest =
        match rest.desc with
        | Tvar _ | Tunivar _ -> Some (is_non_gen sch rest)
        | Tconstr _ -> Some false
        | Tnil -> None
        | _ -> fatal_error "typfields (1)"
      in
      ([], rest)
  | (s, t) :: l ->
      let field = (s, tree_of_typexp sch t) in
      let (fields, rest) = tree_of_typfields sch rest l in
      (field :: fields, rest)

let typexp sch prio ppf ty =
  !Oprint.out_type ppf (tree_of_typexp sch ty)

let type_expr ppf ty = typexp false 0 ppf ty

and type_sch ppf ty = typexp true 0 ppf ty

and type_scheme ppf ty = reset_and_mark_loops ty; typexp true 0 ppf ty

(* Maxence *)
let type_scheme_max ?(b_reset_names=true) ppf ty =
  if b_reset_names then reset_names () ;
  typexp true 0 ppf ty
(* Fin Maxence *)

let tree_of_type_scheme ty = reset_and_mark_loops ty; tree_of_typexp true ty

(* Print one type declaration *)

let tree_of_constraints params =
  List.fold_right
    (fun ty list ->
       let ty' = unalias ty in
       if proxy ty != proxy ty' then
         let tr = tree_of_typexp true ty in
         (tr, tree_of_typexp true ty') :: list
       else list)
    params []

let filter_params tyl =
  let params =
    List.fold_left
      (fun tyl ty ->
        let ty = repr ty in
        if List.memq ty tyl then Btype.newgenty (Tsubst ty) :: tyl
        else ty :: tyl)
      [] tyl
  in List.rev params

let string_of_mutable = function
  | Immutable -> ""
  | Mutable -> "mutable "

let rec tree_of_type_decl id decl =

  reset();

  let params = filter_params decl.type_params in

  begin match decl.type_manifest with
  | Some ty ->
      let vars = free_variables ty in
      List.iter
        (function {desc = Tvar (Some "_")} as ty ->
            if List.memq ty vars then ty.desc <- Tvar None
          | _ -> ())
        params
  | None -> ()
  end;

  List.iter add_alias params;
  List.iter mark_loops params;
  List.iter check_name_of_type (List.map proxy params);
  let ty_manifest =
    match decl.type_manifest with
    | None -> None
    | Some ty ->
        let ty =
          (* Special hack to hide variant name *)
          match repr ty with {desc=Tvariant row} ->
            let row = row_repr row in
            begin match row.row_name with
              Some (Pident id', _) when Ident.same id id' ->
                newgenty (Tvariant {row with row_name = None})
            | _ -> ty
            end
          | _ -> ty
        in
        mark_loops ty;
        Some ty
  in
  begin match decl.type_kind with
  | Type_abstract -> ()
  | Type_variant cstrs ->
      List.iter
        (fun c ->
          List.iter mark_loops c.cd_args;
          may mark_loops c.cd_res)
        cstrs
  | Type_record(l, rep) ->
      List.iter (fun l -> mark_loops l.ld_type) l
  | Type_open -> ()
  end;

  let type_param =
    function
    | Otyp_var (_, id) -> id
    | _ -> "?"
  in
  let type_defined decl =
    let abstr =
      match decl.type_kind with
        Type_abstract ->
          decl.type_manifest = None || decl.type_private = Private
      | Type_record _ ->
          decl.type_private = Private
      | Type_variant tll ->
          decl.type_private = Private ||
          List.exists (fun cd -> cd.cd_res <> None) tll
      | Type_open ->
          decl.type_manifest = None
    in
    let vari =
      List.map2
        (fun ty v ->
          if abstr || not (is_Tvar (repr ty)) then Variance.get_upper v
          else (true,true))
        decl.type_params decl.type_variance
    in
    (Ident.name id,
     List.map2 (fun ty cocn -> type_param (tree_of_typexp false ty), cocn)
       params vari)
  in
  let tree_of_manifest ty1 =
    match ty_manifest with
    | None -> ty1
    | Some ty -> Otyp_manifest (tree_of_typexp false ty, ty1)
  in
  let (name, args) = type_defined decl in
  let constraints = tree_of_constraints params in
  let ty, priv =
    match decl.type_kind with
    | Type_abstract ->
        begin match ty_manifest with
        | None -> (Otyp_abstract, Public)
        | Some ty ->
            tree_of_typexp false ty, decl.type_private
        end
    | Type_variant cstrs ->
        tree_of_manifest (Otyp_sum (List.map tree_of_constructor cstrs)),
        decl.type_private
    | Type_record(lbls, rep) ->
        tree_of_manifest (Otyp_record (List.map tree_of_label lbls)),
        decl.type_private
    | Type_open ->
        tree_of_manifest Otyp_open,
        Public
  in
    { otype_name = name;
      otype_params = args;
      otype_type = ty;
      otype_private = priv;
      otype_cstrs = constraints }

and tree_of_constructor cd =
  let name = Ident.name cd.cd_id in
  match cd.cd_res with
  | None -> (name, tree_of_typlist false cd.cd_args, None)
  | Some res ->
      let nm = !names in
      names := [];
      let ret = tree_of_typexp false res in
      let args = tree_of_typlist false cd.cd_args in
      names := nm;
      (name, args, Some ret)

and tree_of_label l =
  (Ident.name l.ld_id, l.ld_mutable = Mutable, tree_of_typexp false l.ld_type)

let tree_of_type_declaration id decl rs =
  Osig_type (tree_of_type_decl id decl, tree_of_rec rs)

let type_declaration id ppf decl =
  !Oprint.out_sig_item ppf (tree_of_type_declaration id decl Trec_first)

(* Print an extension declaration *)

let tree_of_extension_constructor id ext es =
  reset ();
  let ty_name = Path.name ext.ext_type_path in
  let ty_params = filter_params ext.ext_type_params in
  List.iter add_alias ty_params;
  List.iter mark_loops ty_params;
  List.iter check_name_of_type (List.map proxy ty_params);
  List.iter mark_loops ext.ext_args;
  may mark_loops ext.ext_ret_type;
  let type_param =
    function
    | Otyp_var (_, id) -> id
    | _ -> "?"
  in
  let ty_params =
    List.map (fun ty -> type_param (tree_of_typexp false ty)) ty_params
  in
  let name = Ident.name id in
  let args, ret =
    match ext.ext_ret_type with
    | None -> (tree_of_typlist false ext.ext_args, None)
    | Some res ->
        let nm = !names in
        names := [];
        let ret = tree_of_typexp false res in
        let args = tree_of_typlist false ext.ext_args in
        names := nm;
        (args, Some ret)
  in
  let ext =
    { oext_name = name;
      oext_type_name = ty_name;
      oext_type_params = ty_params;
      oext_args = args;
      oext_ret_type = ret;
      oext_private = ext.ext_private }
  in
  let es =
    match es with
        Text_first -> Oext_first
      | Text_next -> Oext_next
      | Text_exception -> Oext_exception
  in
    Osig_typext (ext, es)

let extension_constructor id ppf ext =
  !Oprint.out_sig_item ppf (tree_of_extension_constructor id ext Text_first)

(* Print a value declaration *)

let tree_of_value_description id decl =
  (* Format.eprintf "@[%a@]@." raw_type_expr decl.val_type; *)
  let id = Ident.name id in
  let ty = tree_of_type_scheme decl.val_type in
  let prims =
    match decl.val_kind with
    | Val_prim p -> Primitive.description_list p
    | _ -> []
  in
  Osig_value (id, ty, prims)

let value_description id ppf decl =
  !Oprint.out_sig_item ppf (tree_of_value_description id decl)

(* Print a class type *)

let class_var sch ppf l (m, t) =
  fprintf ppf
    "@ @[<2>val %s%s :@ %a@]" (string_of_mutable m) l (typexp sch 0) t

let method_type (_, kind, ty) =
  match field_kind_repr kind, repr ty with
    Fpresent, {desc=Tpoly(ty, tyl)} -> (ty, tyl)
  | _       , ty                    -> (ty, [])

let tree_of_metho sch concrete csil (lab, kind, ty) =
  if lab <> dummy_method then begin
    let kind = field_kind_repr kind in
    let priv = kind <> Fpresent in
    let virt = not (Concr.mem lab concrete) in
    let (ty, tyl) = method_type (lab, kind, ty) in
    let tty = tree_of_typexp sch ty in
    remove_names tyl;
    Ocsg_method (lab, priv, virt, tty) :: csil
  end
  else csil

let rec prepare_class_type params = function
  | Cty_constr (p, tyl, cty) ->
      let sty = Ctype.self_type cty in
      if List.memq (proxy sty) !visited_objects
      || not (List.for_all is_Tvar params)
      || List.exists (deep_occur sty) tyl
      then prepare_class_type params cty
      else List.iter mark_loops tyl
  | Cty_signature sign ->
      let sty = repr sign.csig_self in
      (* Self may have a name *)
      let px = proxy sty in
      if List.memq px !visited_objects then add_alias sty
      else visited_objects := px :: !visited_objects;
      let (fields, _) =
        Ctype.flatten_fields (Ctype.object_fields sign.csig_self)
      in
      List.iter (fun met -> mark_loops (fst (method_type met))) fields;
      Vars.iter (fun _ (_, _, ty) -> mark_loops ty) sign.csig_vars
  | Cty_arrow (_, ty, cty) ->
      mark_loops ty;
      prepare_class_type params cty

let rec tree_of_class_type sch params =
  function
  | Cty_constr (p', tyl, cty) ->
      let sty = Ctype.self_type cty in
      if List.memq (proxy sty) !visited_objects
      || not (List.for_all is_Tvar params)
      then
        tree_of_class_type sch params cty
      else
        Octy_constr (tree_of_path p', tree_of_typlist true tyl)
  | Cty_signature sign ->
      let sty = repr sign.csig_self in
      let self_ty =
        if is_aliased sty then
          Some (Otyp_var (false, name_of_type (proxy sty)))
        else None
      in
      let (fields, _) =
        Ctype.flatten_fields (Ctype.object_fields sign.csig_self)
      in
      let csil = [] in
      let csil =
        List.fold_left
          (fun csil (ty1, ty2) -> Ocsg_constraint (ty1, ty2) :: csil)
          csil (tree_of_constraints params)
      in
      let all_vars =
        Vars.fold (fun l (m, v, t) all -> (l, m, v, t) :: all) sign.csig_vars []
      in
      (* Consequence of PR#3607: order of Map.fold has changed! *)
      let all_vars = List.rev all_vars in
      let csil =
        List.fold_left
          (fun csil (l, m, v, t) ->
            Ocsg_value (l, m = Mutable, v = Virtual, tree_of_typexp sch t)
            :: csil)
          csil all_vars
      in
      let csil =
        List.fold_left (tree_of_metho sch sign.csig_concr) csil fields
      in
      Octy_signature (self_ty, List.rev csil)
  | Cty_arrow (l, ty, cty) ->
      let lab = if !print_labels && l <> "" || is_optional l then l else "" in
      let ty =
       if is_optional l then
         match (repr ty).desc with
         | Tconstr(path, [ty], _) when Path.same path Predef.path_option -> ty
         | _ -> newconstr (Path.Pident(Ident.create "<hidden>")) []
       else ty in
      let tr = tree_of_typexp sch ty in
      Octy_arrow (lab, tr, tree_of_class_type sch params cty)

let class_type ppf cty =
  reset ();
  prepare_class_type [] cty;
  !Oprint.out_class_type ppf (tree_of_class_type false [] cty)

let tree_of_class_param param variance =
  (match tree_of_typexp true param with
    Otyp_var (_, s) -> s
  | _ -> "?"),
  if is_Tvar (repr param) then (true, true) else variance

let tree_of_class_params params =
  let tyl = tree_of_typlist true params in
  List.map (function Otyp_var (_, s) -> s | _ -> "?") tyl

let class_variance =
  List.map Variance.(fun v -> mem May_pos v, mem May_neg v)

let tree_of_class_declaration id cl rs =
  let params = filter_params cl.cty_params in

  reset ();
  List.iter add_alias params;
  prepare_class_type params cl.cty_type;
  let sty = Ctype.self_type cl.cty_type in
  List.iter mark_loops params;

  List.iter check_name_of_type (List.map proxy params);
  if is_aliased sty then check_name_of_type (proxy sty);

  let vir_flag = cl.cty_new = None in
  Osig_class
    (vir_flag, Ident.name id,
     List.map2 tree_of_class_param params (class_variance cl.cty_variance),
     tree_of_class_type true params cl.cty_type,
     tree_of_rec rs)

let class_declaration id ppf cl =
  !Oprint.out_sig_item ppf (tree_of_class_declaration id cl Trec_first)

let tree_of_cltype_declaration id cl rs =
  let params = List.map repr cl.clty_params in

  reset ();
  List.iter add_alias params;
  prepare_class_type params cl.clty_type;
  let sty = Ctype.self_type cl.clty_type in
  List.iter mark_loops params;

  List.iter check_name_of_type (List.map proxy params);
  if is_aliased sty then check_name_of_type (proxy sty);

  let sign = Ctype.signature_of_class_type cl.clty_type in

  let virt =
    let (fields, _) =
      Ctype.flatten_fields (Ctype.object_fields sign.csig_self) in
    List.exists
      (fun (lab, _, ty) ->
         not (lab = dummy_method || Concr.mem lab sign.csig_concr))
      fields
    || Vars.fold (fun _ (_,vr,_) b -> vr = Virtual || b) sign.csig_vars false
  in

  Osig_class_type
    (virt, Ident.name id,
     List.map2 tree_of_class_param params (class_variance cl.clty_variance),
     tree_of_class_type true params cl.clty_type,
     tree_of_rec rs)

let cltype_declaration id ppf cl =
  !Oprint.out_sig_item ppf (tree_of_cltype_declaration id cl Trec_first)

(* Print a module type *)

let wrap_env fenv ftree arg =
  let env = !printing_env in
  set_printing_env (fenv env);
  let tree = ftree arg in
  set_printing_env env;
  tree

let filter_rem_sig item rem =
  match item, rem with
  | Sig_class _, ctydecl :: tydecl1 :: tydecl2 :: rem ->
      ([ctydecl; tydecl1; tydecl2], rem)
  | Sig_class_type _, tydecl1 :: tydecl2 :: rem ->
      ([tydecl1; tydecl2], rem)
  | _ ->
      ([], rem)

let dummy =
  { type_params = []; type_arity = 0; type_kind = Type_abstract;
    type_private = Public; type_manifest = None; type_variance = [];
    type_newtype_level = None; type_loc = Location.none;
    type_attributes = [];
  }

let hide_rec_items = function
  | Sig_type(id, decl, rs) ::rem
    when rs = Trec_first && not !Clflags.real_paths ->
      let rec get_ids = function
          Sig_type (id, _, Trec_next) :: rem ->
            id :: get_ids rem
        | _ -> []
      in
      let ids = id :: get_ids rem in
      set_printing_env
        (List.fold_right
           (fun id -> Env.add_type ~check:false (Ident.rename id) dummy)
           ids !printing_env)
  | _ -> ()

let rec tree_of_modtype = function
  | Mty_ident p ->
      Omty_ident (tree_of_path p)
  | Mty_signature sg ->
      Omty_signature (tree_of_signature sg)
  | Mty_functor(param, ty_arg, ty_res) ->
      let res =
        match ty_arg with None -> tree_of_modtype ty_res
        | Some mty ->
            wrap_env (Env.add_module ~arg:true param mty) tree_of_modtype ty_res
      in
      Omty_functor (Ident.name param, may_map tree_of_modtype ty_arg, res)
  | Mty_alias p ->
      Omty_alias (tree_of_path p)

and tree_of_signature sg =
  wrap_env (fun env -> env) (tree_of_signature_rec !printing_env false) sg

and tree_of_signature_rec env' in_type_group = function
    [] -> []
  | item :: rem ->
      let in_type_group =
        match in_type_group, item with
          true, Sig_type (_, _, Trec_next) -> true
        | _, Sig_type (_, _, (Trec_not | Trec_first)) -> set_printing_env env'; true
        | _ -> set_printing_env env'; false
      in
      let (sg, rem) = filter_rem_sig item rem in
      let trees =
        match item with
        | Sig_value(id, decl) ->
            [tree_of_value_description id decl]
        | Sig_type(id, _, _) when is_row_name (Ident.name id) ->
            []
        | Sig_type(id, decl, rs) ->
            hide_rec_items (item :: rem);
            [Osig_type(tree_of_type_decl id decl, tree_of_rec rs)]
        | Sig_typext(id, ext, es) ->
            [tree_of_extension_constructor id ext es]
        | Sig_module(id, md, rs) ->
            [Osig_module (Ident.name id, tree_of_modtype md.md_type,
                          tree_of_rec rs)]
        | Sig_modtype(id, decl) ->
            [tree_of_modtype_declaration id decl]
        | Sig_class(id, decl, rs) ->
            [tree_of_class_declaration id decl rs]
        | Sig_class_type(id, decl, rs) ->
            [tree_of_cltype_declaration id decl rs]
      in
      let env' = Env.add_signature (item :: sg) env' in
      trees @ tree_of_signature_rec env' in_type_group rem

and tree_of_modtype_declaration id decl =
  let mty =
    match decl.mtd_type with
    | None -> Omty_abstract
    | Some mty -> tree_of_modtype mty
  in
  Osig_modtype (Ident.name id, mty)

let tree_of_module id mty rs =
  Osig_module (Ident.name id, tree_of_modtype mty, tree_of_rec rs)

let modtype ppf mty = !Oprint.out_module_type ppf (tree_of_modtype mty)
let modtype_declaration id ppf decl =
  !Oprint.out_sig_item ppf (tree_of_modtype_declaration id decl)

(* Print a signature body (used by -i when compiling a .ml) *)

let print_signature ppf tree =
  fprintf ppf "@[<v>%a@]" !Oprint.out_signature tree

let signature ppf sg =
  fprintf ppf "%a" print_signature (tree_of_signature sg)

(* Print an unification error *)

let same_path t t' =
  let t = repr t and t' = repr t' in
  t == t' ||
  match t.desc, t'.desc with
    Tconstr(p,tl,_), Tconstr(p',tl',_) ->
      let (p1, s1) = best_type_path p and (p2, s2)  = best_type_path p' in
      begin match s1, s2 with
        Nth n1, Nth n2 when n1 = n2 -> true
      | (Id | Map _), (Id | Map _) when Path.same p1 p2 ->
          let tl = apply_subst s1 tl and tl' = apply_subst s2 tl' in
          List.length tl = List.length tl' &&
          List.for_all2 same_type tl tl'
      | _ -> false
      end
  | _ ->
      false

let type_expansion t ppf t' =
  if same_path t t' then type_expr ppf t else
  let t' = if proxy t == proxy t' then unalias t' else t' in
  fprintf ppf "@[<2>%a@ =@ %a@]" type_expr t type_expr t'

let type_path_expansion tp ppf tp' =
  if Path.same tp tp' then path ppf tp else
  fprintf ppf "@[<2>%a@ =@ %a@]" path tp path tp'

let rec trace fst txt ppf = function
  | (t1, t1') :: (t2, t2') :: rem ->
      if not fst then fprintf ppf "@,";
      fprintf ppf "@[Type@;<1 2>%a@ %s@;<1 2>%a@] %a"
       (type_expansion t1) t1' txt (type_expansion t2) t2'
       (trace false txt) rem
  | _ -> ()

let rec filter_trace keep_last = function
  | (_, t1') :: (_, t2') :: [] when is_Tvar t1' || is_Tvar t2' ->
      []
  | (t1, t1') :: (t2, t2') :: rem ->
      let rem' = filter_trace keep_last rem in
      if is_constr_row t1' || is_constr_row t2'
      || same_path t1 t1' && same_path t2 t2' && not (keep_last && rem' = [])
      then rem'
      else (t1, t1') :: (t2, t2') :: rem'
  | _ -> []

let rec type_path_list ppf = function
  | [tp, tp'] -> type_path_expansion tp ppf tp'
  | (tp, tp') :: rem ->
      fprintf ppf "%a@;<2 0>%a"
        (type_path_expansion tp) tp'
        type_path_list rem
  | [] -> ()

(* Hide variant name and var, to force printing the expanded type *)
let hide_variant_name t =
  match repr t with
  | {desc = Tvariant row} as t when (row_repr row).row_name <> None ->
      newty2 t.level
        (Tvariant {(row_repr row) with row_name = None;
                   row_more = newvar2 (row_more row).level})
  | _ -> t

let prepare_expansion (t, t') =
  let t' = hide_variant_name t' in
  mark_loops t;
  if not (same_path t t') then mark_loops t';
  (t, t')

let may_prepare_expansion compact (t, t') =
  match (repr t').desc with
    Tvariant _ | Tobject _ when compact ->
      mark_loops t; (t, t)
  | _ -> prepare_expansion (t, t')

let print_tags ppf fields =
  match fields with [] -> ()
  | (t, _) :: fields ->
      fprintf ppf "`%s" t;
      List.iter (fun (t, _) -> fprintf ppf ",@ `%s" t) fields

let has_explanation unif t3 t4 =
  match t3.desc, t4.desc with
    Tfield _, (Tnil|Tconstr _) | (Tnil|Tconstr _), Tfield _
  | Tnil, Tconstr _ | Tconstr _, Tnil
  | _, Tvar _ | Tvar _, _
  | Tvariant _, Tvariant _ -> true
  | Tfield (l,_,_,{desc=Tnil}), Tfield (l',_,_,{desc=Tnil}) -> l = l'
  | _ -> false

let rec mismatch unif = function
    (_, t) :: (_, t') :: rem ->
      begin match mismatch unif rem with
        Some _ as m -> m
      | None ->
          if has_explanation unif t t' then Some(t,t') else None
      end
  | [] -> None
  | _ -> assert false

let explanation unif t3 t4 ppf =
  match t3.desc, t4.desc with
  | Ttuple [], Tvar _ | Tvar _, Ttuple [] ->
      fprintf ppf "@,Self type cannot escape its class"
  | Tconstr (p, tl, _), Tvar _
    when unif && t4.level < Path.binding_time p ->
      fprintf ppf
        "@,@[The type constructor@;<1 2>%a@ would escape its scope@]"
        path p
  | Tvar _, Tconstr (p, tl, _)
    when unif && t3.level < Path.binding_time p ->
      fprintf ppf
        "@,@[The type constructor@;<1 2>%a@ would escape its scope@]"
        path p
  | Tvar _, Tunivar _ | Tunivar _, Tvar _ ->
      fprintf ppf "@,The universal variable %a would escape its scope"
        type_expr (if is_Tunivar t3 then t3 else t4)
  | Tvar _, _ | _, Tvar _ ->
      let t, t' = if is_Tvar t3 then (t3, t4) else (t4, t3) in
      if occur_in Env.empty t t' then
        fprintf ppf "@,@[<hov>The type variable %a occurs inside@ %a@]"
          type_expr t type_expr t'
      else
        fprintf ppf "@,@[<hov>This instance of %a is ambiguous:@ %s@]"
          type_expr t'
          "it would escape the scope of its equation"
  | Tfield (lab, _, _, _), _
  | _, Tfield (lab, _, _, _) when lab = dummy_method ->
      fprintf ppf
        "@,Self type cannot be unified with a closed object type"
  | Tfield (l,_,_,{desc=Tnil}), Tfield (l',_,_,{desc=Tnil}) when l = l' ->
      fprintf ppf "@,Types for method %s are incompatible" l
  | (Tnil|Tconstr _), Tfield (l, _, _, _) ->
      fprintf ppf
        "@,@[The first object type has no method %s@]" l
  | Tfield (l, _, _, _), (Tnil|Tconstr _) ->
      fprintf ppf
        "@,@[The second object type has no method %s@]" l
  | Tnil, Tconstr _ | Tconstr _, Tnil ->
      fprintf ppf
        "@,@[The %s object type has an abstract row, it cannot be closed@]"
        (if t4.desc = Tnil then "first" else "second")
  | Tvariant row1, Tvariant row2 ->
      let row1 = row_repr row1 and row2 = row_repr row2 in
      begin match
        row1.row_fields, row1.row_closed, row2.row_fields, row2.row_closed with
      | [], true, [], true ->
          fprintf ppf "@,These two variant types have no intersection"
      | [], true, fields, _ ->
          fprintf ppf
            "@,@[The first variant type does not allow tag(s)@ @[<hov>%a@]@]"
            print_tags fields
      | fields, _, [], true ->
          fprintf ppf
            "@,@[The second variant type does not allow tag(s)@ @[<hov>%a@]@]"
            print_tags fields
      | [l1,_], true, [l2,_], true when l1 = l2 ->
          fprintf ppf "@,Types for tag `%s are incompatible" l1
      | _ -> ()
      end
  | _ -> ()

let explanation unif mis ppf =
  match mis with
    None -> ()
  | Some (t3, t4) -> explanation unif t3 t4 ppf

let ident_same_name id1 id2 =
  if Ident.equal id1 id2 && not (Ident.same id1 id2) then begin
    add_unique id1; add_unique id2
  end

let rec path_same_name p1 p2 =
  match p1, p2 with
    Pident id1, Pident id2 -> ident_same_name id1 id2
  | Pdot (p1, s1, _), Pdot (p2, s2, _) when s1 = s2 -> path_same_name p1 p2
  | Papply (p1, p1'), Papply (p2, p2') ->
      path_same_name p1 p2; path_same_name p1' p2'
  | _ -> ()

let type_same_name t1 t2 =
  match (repr t1).desc, (repr t2).desc with
    Tconstr (p1, _, _), Tconstr (p2, _, _) ->
      path_same_name (fst (best_type_path p1)) (fst (best_type_path p2))
  | _ -> ()

let rec trace_same_names = function
    (t1, t1') :: (t2, t2') :: rem ->
      type_same_name t1 t2; type_same_name t1' t2'; trace_same_names rem
  | _ -> ()

let unification_error unif tr txt1 ppf txt2 =
  reset ();
  trace_same_names tr;
  let tr = List.map (fun (t, t') -> (t, hide_variant_name t')) tr in
  let mis = mismatch unif tr in
  match tr with
  | [] | _ :: [] -> assert false
  | t1 :: t2 :: tr ->
    try
      let tr = filter_trace (mis = None) tr in
      let t1, t1' = may_prepare_expansion (tr = []) t1
      and t2, t2' = may_prepare_expansion (tr = []) t2 in
      print_labels := not !Clflags.classic;
      let tr = List.map prepare_expansion tr in
      fprintf ppf
        "@[<v>\
          @[%t@;<1 2>%a@ \
            %t@;<1 2>%a\
          @]%a%t\
         @]"
        txt1 (type_expansion t1) t1'
        txt2 (type_expansion t2) t2'
        (trace false "is not compatible with type") tr
        (explanation unif mis);
      print_labels := true
    with exn ->
      print_labels := true;
      raise exn

let report_unification_error ppf env ?(unif=true)
    tr txt1 txt2 =
  wrap_printing_env env (fun () -> unification_error unif tr txt1 ppf txt2)
;;


let super_type_expansion ~tag t ppf t' =
  if same_path t t' then begin
    Format.pp_open_tag ppf tag;
    type_expr ppf t;
    Format.pp_close_tag ppf ();
  end else begin
    let t' = if proxy t == proxy t' then unalias t' else t' in
    fprintf ppf "@[<2>";
    Format.pp_open_tag ppf tag;
    fprintf ppf "%a" type_expr t;
    Format.pp_close_tag ppf ();
    fprintf ppf "@ @{<dim>(defined as@}@ ";
    Format.pp_open_tag ppf tag;
    fprintf ppf "%a" type_expr t';
    Format.pp_close_tag ppf ();
    fprintf ppf "@{<dim>)@}";
    fprintf ppf "@]";
  end

let super_trace ppf =
  let rec super_trace first_report ppf = function
    | (t1, t1') :: (t2, t2') :: rem ->
      fprintf ppf 
        "@,@,@[<v 2>";
      if first_report then 
        fprintf ppf "The incompatible parts:@,"
      else begin 
        fprintf ppf "Further expanded:@,"
      end;
      fprintf ppf 
        "@[<v>\
          @[%a@]@,\
          vs@,\
          @[%a@]\
          %a\
        @]"
        (super_type_expansion ~tag:"error" t1) t1'
        (super_type_expansion ~tag:"info" t2) t2'
        (super_trace false) rem;
      fprintf ppf "@]"
    | _ -> ()
  in super_trace true ppf

let super_unification_error unif tr txt1 ppf txt2 = begin
  reset ();
  trace_same_names tr;
  let tr = List.map (fun (t, t') -> (t, hide_variant_name t')) tr in
  let mis = mismatch unif tr in
  match tr with
  | [] | _ :: [] -> assert false
  | t1 :: t2 :: tr ->
    try
      let tr = filter_trace (mis = None) tr in
      let t1, t1' = may_prepare_expansion (tr = []) t1
      and t2, t2' = may_prepare_expansion (tr = []) t2 in
      print_labels := not !Clflags.classic;
      let tr = List.map prepare_expansion tr in
      fprintf ppf
        "@[<v 0>\
          @[<v 2>\
            %t@,\
            @[<2>%a@]\
          @]@,\
          @[<v 2>\
            %t@,\
            @[<2>%a@]\
          @]\
          %a\
          %t\
        @]"
        txt1 (super_type_expansion ~tag:"error" t1) t1'
        txt2 (super_type_expansion ~tag:"info" t2) t2'
        super_trace tr
        (explanation unif mis);
      print_labels := true
    with exn ->
      print_labels := true;
      raise exn
end

let super_report_unification_error ppf env ?(unif=true)
    tr txt1 txt2 =
  wrap_printing_env env (fun () -> super_unification_error unif tr txt1 ppf txt2)
;;


let trace fst keep_last txt ppf tr =
  print_labels := not !Clflags.classic;
  trace_same_names tr;
  try match tr with
    t1 :: t2 :: tr' ->
      if fst then trace fst txt ppf (t1 :: t2 :: filter_trace keep_last tr')
      else trace fst txt ppf (filter_trace keep_last tr);
      print_labels := true
  | _ -> ()
  with exn ->
    print_labels := true;
    raise exn

let report_subtyping_error ppf env tr1 txt1 tr2 =
  wrap_printing_env env (fun () ->
    reset ();
    let tr1 = List.map prepare_expansion tr1
    and tr2 = List.map prepare_expansion tr2 in
    fprintf ppf "@[<v>%a" (trace true (tr2 = []) txt1) tr1;
    if tr2 = [] then fprintf ppf "@]" else
    let mis = mismatch true tr2 in
    fprintf ppf "%a%t@]"
      (trace false (mis = None) "is not compatible with type") tr2
      (explanation true mis))

let report_ambiguous_type_error ppf env (tp0, tp0') tpl txt1 txt2 txt3 =
  wrap_printing_env env (fun () ->
    reset ();
    List.iter
      (fun (tp, tp') -> path_same_name tp0 tp; path_same_name tp0' tp')
      tpl;
    match tpl with
      [] -> assert false
    | [tp, tp'] ->
        fprintf ppf
          "@[%t@;<1 2>%a@ \
             %t@;<1 2>%a\
           @]"
          txt1 (type_path_expansion tp) tp'
          txt3 (type_path_expansion tp0) tp0'
    | _ ->
        fprintf ppf
          "@[%t@;<1 2>@[<hv>%a@]\
             @ %t@;<1 2>%a\
           @]"
          txt2 type_path_list tpl
          txt3 (type_path_expansion tp0) tp0')

end
module Includeclass : sig 
#1 "includeclass.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*          Jerome Vouillon, projet Cristal, INRIA Rocquencourt        *)
(*                                                                     *)
(*  Copyright 1997 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Inclusion checks for the class language *)

open Types
open Ctype
open Format

val class_types:
        Env.t -> class_type -> class_type -> class_match_failure list
val class_type_declarations:
        Env.t -> class_type_declaration -> class_type_declaration ->
        class_match_failure list
val class_declarations:
        Env.t -> class_declaration -> class_declaration ->
        class_match_failure list

val report_error: formatter -> class_match_failure list -> unit

end = struct
#1 "includeclass.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*          Jerome Vouillon, projet Cristal, INRIA Rocquencourt        *)
(*                                                                     *)
(*  Copyright 1997 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Inclusion checks for the class language *)

open Types

let class_types env cty1 cty2 =
  Ctype.match_class_types env cty1 cty2

let class_type_declarations env cty1 cty2 =
  Ctype.match_class_declarations env
    cty1.clty_params cty1.clty_type
    cty2.clty_params cty2.clty_type

let class_declarations env cty1 cty2 =
  match cty1.cty_new, cty2.cty_new with
    None, Some _ ->
      [Ctype.CM_Virtual_class]
  | _ ->
      Ctype.match_class_declarations env
        cty1.cty_params cty1.cty_type
        cty2.cty_params cty2.cty_type

open Format
open Ctype

(*
let rec hide_params = function
    Tcty_arrow ("*", _, cty) -> hide_params cty
  | cty -> cty
*)

let include_err ppf =
  function
  | CM_Virtual_class ->
      fprintf ppf "A class cannot be changed from virtual to concrete"
  | CM_Parameter_arity_mismatch (ls, lp) ->
      fprintf ppf
        "The classes do not have the same number of type parameters"
  | CM_Type_parameter_mismatch (env, trace) ->
      Printtyp.report_unification_error ppf env ~unif:false trace
        (function ppf ->
          fprintf ppf "A type parameter has type")
        (function ppf ->
          fprintf ppf "but is expected to have type")
  | CM_Class_type_mismatch (env, cty1, cty2) ->
      Printtyp.wrap_printing_env env (fun () ->
        fprintf ppf
          "@[The class type@;<1 2>%a@ %s@;<1 2>%a@]"
          Printtyp.class_type cty1
          "is not matched by the class type"
          Printtyp.class_type cty2)
  | CM_Parameter_mismatch (env, trace) ->
      Printtyp.report_unification_error ppf env ~unif:false trace
        (function ppf ->
          fprintf ppf "A parameter has type")
        (function ppf ->
          fprintf ppf "but is expected to have type")
  | CM_Val_type_mismatch (lab, env, trace) ->
      Printtyp.report_unification_error ppf env ~unif:false trace
        (function ppf ->
          fprintf ppf "The instance variable %s@ has type" lab)
        (function ppf ->
          fprintf ppf "but is expected to have type")
  | CM_Meth_type_mismatch (lab, env, trace) ->
      Printtyp.report_unification_error ppf env ~unif:false trace
        (function ppf ->
          fprintf ppf "The method %s@ has type" lab)
        (function ppf ->
          fprintf ppf "but is expected to have type")
  | CM_Non_mutable_value lab ->
      fprintf ppf
       "@[The non-mutable instance variable %s cannot become mutable@]" lab
  | CM_Non_concrete_value lab ->
      fprintf ppf
       "@[The virtual instance variable %s cannot become concrete@]" lab
  | CM_Missing_value lab ->
      fprintf ppf "@[The first class type has no instance variable %s@]" lab
  | CM_Missing_method lab ->
      fprintf ppf "@[The first class type has no method %s@]" lab
  | CM_Hide_public lab ->
     fprintf ppf "@[The public method %s cannot be hidden@]" lab
  | CM_Hide_virtual (k, lab) ->
      fprintf ppf "@[The virtual %s %s cannot be hidden@]" k lab
  | CM_Public_method lab ->
      fprintf ppf "@[The public method %s cannot become private" lab
  | CM_Virtual_method lab ->
      fprintf ppf "@[The virtual method %s cannot become concrete" lab
  | CM_Private_method lab ->
      fprintf ppf "The private method %s cannot become public" lab

let report_error ppf = function
  |  [] -> ()
  | err :: errs ->
      let print_errs ppf errs =
         List.iter (fun err -> fprintf ppf "@ %a" include_err err) errs in
      fprintf ppf "@[<v>%a%a@]" include_err err print_errs errs

end
module Includecore : sig 
#1 "includecore.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Inclusion checks for the core language *)

open Typedtree
open Types

exception Dont_match

type type_mismatch =
    Arity
  | Privacy
  | Kind
  | Constraint
  | Manifest
  | Variance
  | Field_type of Ident.t
  | Field_mutable of Ident.t
  | Field_arity of Ident.t
  | Field_names of int * Ident.t * Ident.t
  | Field_missing of bool * Ident.t
  | Record_representation of bool

val value_descriptions:
    Env.t -> Ident.t -> value_description -> value_description -> module_coercion
val type_declarations:
    ?equality:bool ->
      Env.t -> string ->
        type_declaration -> Ident.t -> type_declaration -> type_mismatch list
val extension_constructors:
    Env.t -> Ident.t -> extension_constructor -> extension_constructor -> bool
(*
val class_types:
        Env.t -> class_type -> class_type -> bool
*)

val report_type_mismatch:
    string -> string -> string -> Format.formatter -> type_mismatch list -> unit

end = struct
#1 "includecore.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Inclusion checks for the core language *)

open Asttypes
open Path
open Types
open Typedtree

(* Inclusion between value descriptions *)

exception Dont_match

let value_descriptions env id vd1 vd2 =
  if Ctype.moregeneral env true vd1.val_type vd2.val_type then begin
    match (vd1.val_kind, vd2.val_kind) with
        (Val_prim p1, Val_prim p2) ->
          if p1 = p2 then Tcoerce_none else raise Dont_match
      | (Val_prim p, _) -> Tcoerce_primitive (id,p)
      | (_, Val_prim p) -> raise Dont_match
      | (_, _) -> Tcoerce_none
  end else
    raise Dont_match

(* Inclusion between "private" annotations *)

let private_flags decl1 decl2 =
  match decl1.type_private, decl2.type_private with
  | Private, Public ->
      decl2.type_kind = Type_abstract &&
      (decl2.type_manifest = None || decl1.type_kind <> Type_abstract)
  | _, _ -> true

(* Inclusion between manifest types (particularly for private row types) *)

let is_absrow env ty =
  match ty.desc with
    Tconstr(Pident id, _, _) ->
      begin match Ctype.expand_head env ty with
        {desc=Tobject _|Tvariant _} -> true
      | _ -> false
      end
  | _ -> false

let type_manifest env ty1 params1 ty2 params2 priv2 =
  let ty1' = Ctype.expand_head env ty1 and ty2' = Ctype.expand_head env ty2 in
  match ty1'.desc, ty2'.desc with
    Tvariant row1, Tvariant row2 when is_absrow env (Btype.row_more row2) ->
      let row1 = Btype.row_repr row1 and row2 = Btype.row_repr row2 in
      Ctype.equal env true (ty1::params1) (row2.row_more::params2) &&
      begin match row1.row_more with
        {desc=Tvar _|Tconstr _|Tnil} -> true
      | _ -> false
      end &&
      let r1, r2, pairs =
        Ctype.merge_row_fields row1.row_fields row2.row_fields in
      (not row2.row_closed ||
       row1.row_closed && Ctype.filter_row_fields false r1 = []) &&
      List.for_all
        (fun (_,f) -> match Btype.row_field_repr f with
          Rabsent | Reither _ -> true | Rpresent _ -> false)
        r2 &&
      let to_equal = ref (List.combine params1 params2) in
      List.for_all
        (fun (_, f1, f2) ->
          match Btype.row_field_repr f1, Btype.row_field_repr f2 with
            Rpresent(Some t1),
            (Rpresent(Some t2) | Reither(false, [t2], _, _)) ->
              to_equal := (t1,t2) :: !to_equal; true
          | Rpresent None, (Rpresent None | Reither(true, [], _, _)) -> true
          | Reither(c1,tl1,_,_), Reither(c2,tl2,_,_)
            when List.length tl1 = List.length tl2 && c1 = c2 ->
              to_equal := List.combine tl1 tl2 @ !to_equal; true
          | Rabsent, (Reither _ | Rabsent) -> true
          | _ -> false)
        pairs &&
      let tl1, tl2 = List.split !to_equal in
      Ctype.equal env true tl1 tl2
  | Tobject (fi1, _), Tobject (fi2, _)
    when is_absrow env (snd(Ctype.flatten_fields fi2)) ->
      let (fields2,rest2) = Ctype.flatten_fields fi2 in
      Ctype.equal env true (ty1::params1) (rest2::params2) &&
      let (fields1,rest1) = Ctype.flatten_fields fi1 in
      (match rest1 with {desc=Tnil|Tvar _|Tconstr _} -> true | _ -> false) &&
      let pairs, miss1, miss2 = Ctype.associate_fields fields1 fields2 in
      miss2 = [] &&
      let tl1, tl2 =
        List.split (List.map (fun (_,_,t1,_,t2) -> t1, t2) pairs) in
      Ctype.equal env true (params1 @ tl1) (params2 @ tl2)
  | _ ->
      let rec check_super ty1 =
        Ctype.equal env true (ty1 :: params1) (ty2 :: params2) ||
        priv2 = Private &&
        try check_super
              (Ctype.try_expand_once_opt env (Ctype.expand_head env ty1))
        with Ctype.Cannot_expand -> false
      in check_super ty1

(* Inclusion between type declarations *)

type type_mismatch =
    Arity
  | Privacy
  | Kind
  | Constraint
  | Manifest
  | Variance
  | Field_type of Ident.t
  | Field_mutable of Ident.t
  | Field_arity of Ident.t
  | Field_names of int * Ident.t * Ident.t
  | Field_missing of bool * Ident.t
  | Record_representation of bool

let report_type_mismatch0 first second decl ppf err =
  let pr fmt = Format.fprintf ppf fmt in
  match err with
    Arity -> pr "They have different arities"
  | Privacy -> pr "A private type would be revealed"
  | Kind -> pr "Their kinds differ"
  | Constraint -> pr "Their constraints differ"
  | Manifest -> ()
  | Variance -> pr "Their variances do not agree"
  | Field_type s ->
      pr "The types for field %s are not equal" (Ident.name s)
  | Field_mutable s ->
      pr "The mutability of field %s is different" (Ident.name s)
  | Field_arity s ->
      pr "The arities for field %s differ" (Ident.name s)
  | Field_names (n, name1, name2) ->
      pr "Fields number %i have different names, %s and %s"
        n (Ident.name name1) (Ident.name name2)
  | Field_missing (b, s) ->
      pr "The field %s is only present in %s %s"
        (Ident.name s) (if b then second else first) decl
  | Record_representation b ->
      pr "Their internal representations differ:@ %s %s %s"
        (if b then second else first) decl
        "uses unboxed float representation"

let report_type_mismatch first second decl ppf =
  List.iter
    (fun err ->
      if err = Manifest then () else
      Format.fprintf ppf "@ %a." (report_type_mismatch0 first second decl) err)

let rec compare_variants env decl1 decl2 n cstrs1 cstrs2 =
  match cstrs1, cstrs2 with
    [], []           -> []
  | [], c::_ -> [Field_missing (true, c.Types.cd_id)]
  | c::_, [] -> [Field_missing (false, c.Types.cd_id)]
  | {Types.cd_id=cstr1; cd_args=arg1; cd_res=ret1}::rem1,
    {Types.cd_id=cstr2; cd_args=arg2; cd_res=ret2}::rem2 ->
      if Ident.name cstr1 <> Ident.name cstr2 then
        [Field_names (n, cstr1, cstr2)]
      else if List.length arg1 <> List.length arg2 then
        [Field_arity cstr1]
      else match ret1, ret2 with
      | Some r1, Some r2 when not (Ctype.equal env true [r1] [r2]) ->
          [Field_type cstr1]
      | Some _, None | None, Some _ ->
          [Field_type cstr1]
      | _ ->
          if Misc.for_all2
              (fun ty1 ty2 ->
                Ctype.equal env true (ty1::decl1.type_params)
                  (ty2::decl2.type_params))
              (arg1) (arg2)
          then
            compare_variants env decl1 decl2 (n+1) rem1 rem2
          else [Field_type cstr1]


let rec compare_records env decl1 decl2 n labels1 labels2 =
  match labels1, labels2 with
    [], []           -> []
  | [], l::_ -> [Field_missing (true, l.ld_id)]
  | l::_, [] -> [Field_missing (false, l.ld_id)]
  | {Types.ld_id=lab1; ld_mutable=mut1; ld_type=arg1}::rem1,
    {Types.ld_id=lab2; ld_mutable=mut2; ld_type=arg2}::rem2 ->
      if Ident.name lab1 <> Ident.name lab2
      then [Field_names (n, lab1, lab2)]
      else if mut1 <> mut2 then [Field_mutable lab1] else
      if Ctype.equal env true (arg1::decl1.type_params)
                              (arg2::decl2.type_params)
      then compare_records env decl1 decl2 (n+1) rem1 rem2
      else [Field_type lab1]

let type_declarations ?(equality = false) env name decl1 id decl2 =
  if decl1.type_arity <> decl2.type_arity then [Arity] else
  if not (private_flags decl1 decl2) then [Privacy] else
  let err = match (decl1.type_kind, decl2.type_kind) with
      (_, Type_abstract) -> []
    | (Type_variant cstrs1, Type_variant cstrs2) ->
        let mark cstrs usage name decl =
          List.iter
            (fun c ->
              Env.mark_constructor_used usage env name decl
                                        (Ident.name c.Types.cd_id))
            cstrs
        in
        let usage =
          if decl1.type_private = Private || decl2.type_private = Public
          then Env.Positive else Env.Privatize
        in
        mark cstrs1 usage name decl1;
        if equality then mark cstrs2 Env.Positive (Ident.name id) decl2;
        compare_variants env decl1 decl2 1 cstrs1 cstrs2
    | (Type_record(labels1,rep1), Type_record(labels2,rep2)) ->
        let err = compare_records env decl1 decl2 1 labels1 labels2 in
        if err <> [] || rep1 = rep2 then err else
        [Record_representation (rep2 = Record_float)]
    | (Type_open, Type_open) -> []
    | (_, _) -> [Kind]
  in
  if err <> [] then err else
  let err = match (decl1.type_manifest, decl2.type_manifest) with
      (_, None) ->
        if Ctype.equal env true decl1.type_params decl2.type_params
        then [] else [Constraint]
    | (Some ty1, Some ty2) ->
        if type_manifest env ty1 decl1.type_params ty2 decl2.type_params
            decl2.type_private
        then [] else [Manifest]
    | (None, Some ty2) ->
        let ty1 =
          Btype.newgenty (Tconstr(Pident id, decl2.type_params, ref Mnil))
        in
        if Ctype.equal env true decl1.type_params decl2.type_params then
          if Ctype.equal env false [ty1] [ty2] then []
          else [Manifest]
        else [Constraint]
  in
  if err <> [] then err else
  let abstr =
    decl2.type_private = Private ||
    decl2.type_kind = Type_abstract && decl2.type_manifest = None in
  let opn = decl2.type_kind = Type_open && decl2.type_manifest = None in
  let constrained ty = not (Btype.(is_Tvar (repr ty))) in
  if List.for_all2
      (fun ty (v1,v2) ->
        let open Variance in
        let imp a b = not a || b in
        let (co1,cn1) = get_upper v1 and (co2,cn2) = get_upper v2 in
        (if abstr then (imp co1 co2 && imp cn1 cn2)
         else if opn || constrained ty then (co1 = co2 && cn1 = cn2)
         else true) &&
        let (p1,n1,i1,j1) = get_lower v1 and (p2,n2,i2,j2) = get_lower v2 in
        imp abstr (imp p2 p1 && imp n2 n1 && imp i2 i1 && imp j2 j1))
      decl2.type_params (List.combine decl1.type_variance decl2.type_variance)
  then [] else [Variance]

(* Inclusion between extension constructors *)

let extension_constructors env id ext1 ext2 =
  let usage =
    if ext1.ext_private = Private || ext2.ext_private = Public
    then Env.Positive else Env.Privatize
  in
  Env.mark_extension_used usage env ext1 (Ident.name id);
  let ty1 =
    Btype.newgenty (Tconstr(ext1.ext_type_path, ext1.ext_type_params, ref Mnil))
  in
  let ty2 =
    Btype.newgenty (Tconstr(ext2.ext_type_path, ext2.ext_type_params, ref Mnil))
  in
  if Ctype.equal env true
       (ty1 :: ext1.ext_type_params)
       (ty2 :: ext2.ext_type_params)
  then
    if List.length ext1.ext_args = List.length ext2.ext_args then
      if match ext1.ext_ret_type, ext2.ext_ret_type with
          Some r1, Some r2 when not (Ctype.equal env true [r1] [r2]) -> false
        | Some _, None | None, Some _ -> false
        | _ ->
            Misc.for_all2
              (fun ty1 ty2 ->
                Ctype.equal env true
                  (ty1 :: ext1.ext_type_params)
                  (ty2 :: ext2.ext_type_params))
              ext1.ext_args ext2.ext_args
      then
        match ext1.ext_private, ext2.ext_private with
            Private, Public -> false
          | _, _ -> true
      else false
    else false
  else false

(* Inclusion between class types *)
let encode_val (mut, ty) rem =
  begin match mut with
    Asttypes.Mutable   -> Predef.type_unit
  | Asttypes.Immutable -> Btype.newgenvar ()
  end
  ::ty::rem

let meths meths1 meths2 =
  Meths.fold
    (fun nam t2 (ml1, ml2) ->
       (begin try
          Meths.find nam meths1 :: ml1
        with Not_found ->
          ml1
        end,
        t2 :: ml2))
    meths2 ([], [])

let vars vars1 vars2 =
  Vars.fold
    (fun lab v2 (vl1, vl2) ->
       (begin try
          encode_val (Vars.find lab vars1) vl1
        with Not_found ->
          vl1
        end,
        encode_val v2 vl2))
    vars2 ([], [])

end
module Mtype : sig 
#1 "mtype.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Operations on module types *)

open Types

val scrape: Env.t -> module_type -> module_type
        (* Expand toplevel module type abbreviations
           till hitting a "hard" module type (signature, functor,
           or abstract module type ident. *)
val freshen: module_type -> module_type
        (* Return an alpha-equivalent copy of the given module type
           where bound identifiers are fresh. *)
val strengthen: Env.t -> module_type -> Path.t -> module_type
        (* Strengthen abstract type components relative to the
           given path. *)
val strengthen_decl: Env.t -> module_declaration -> Path.t -> module_declaration
val nondep_supertype: Env.t -> Ident.t -> module_type -> module_type
        (* Return the smallest supertype of the given type
           in which the given ident does not appear.
           Raise [Not_found] if no such type exists. *)
val no_code_needed: Env.t -> module_type -> bool
val no_code_needed_sig: Env.t -> signature -> bool
        (* Determine whether a module needs no implementation code,
           i.e. consists only of type definitions. *)
val enrich_modtype: Env.t -> Path.t -> module_type -> module_type
val enrich_typedecl: Env.t -> Path.t -> type_declaration -> type_declaration
val type_paths: Env.t -> Path.t -> module_type -> Path.t list
val contains_type: Env.t -> module_type -> bool
val remove_aliases: Env.t -> module_type -> module_type

end = struct
#1 "mtype.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Operations on module types *)

open Asttypes
open Path
open Types


let rec scrape env mty =
  match mty with
    Mty_ident p ->
      begin try
        scrape env (Env.find_modtype_expansion p env)
      with Not_found ->
        mty
      end
  | _ -> mty

let freshen mty =
  Subst.modtype Subst.identity mty

let rec strengthen env mty p =
  match scrape env mty with
    Mty_signature sg ->
      Mty_signature(strengthen_sig env sg p)
  | Mty_functor(param, arg, res)
    when !Clflags.applicative_functors && Ident.name param <> "*" ->
      Mty_functor(param, arg, strengthen env res (Papply(p, Pident param)))
  | mty ->
      mty

and strengthen_sig env sg p =
  match sg with
    [] -> []
  | (Sig_value(id, desc) as sigelt) :: rem ->
      sigelt :: strengthen_sig env rem p
  | Sig_type(id, decl, rs) :: rem ->
      let newdecl =
        match decl.type_manifest, decl.type_private, decl.type_kind with
          Some _, Public, _ -> decl
        | Some _, Private, (Type_record _ | Type_variant _) -> decl
        | _ ->
            let manif =
              Some(Btype.newgenty(Tconstr(Pdot(p, Ident.name id, nopos),
                                          decl.type_params, ref Mnil))) in
            if decl.type_kind = Type_abstract then
              { decl with type_private = Public; type_manifest = manif }
            else
              { decl with type_manifest = manif }
      in
      Sig_type(id, newdecl, rs) :: strengthen_sig env rem p
  | (Sig_typext(id, ext, es) as sigelt) :: rem ->
      sigelt :: strengthen_sig env rem p
  | Sig_module(id, md, rs) :: rem ->
      let str = strengthen_decl env md (Pdot(p, Ident.name id, nopos)) in
      Sig_module(id, str, rs)
      :: strengthen_sig (Env.add_module_declaration id md env) rem p
      (* Need to add the module in case it defines manifest module types *)
  | Sig_modtype(id, decl) :: rem ->
      let newdecl =
        match decl.mtd_type with
          None ->
            {decl with mtd_type = Some(Mty_ident(Pdot(p,Ident.name id,nopos)))}
        | Some _ ->
            decl
      in
      Sig_modtype(id, newdecl) ::
      strengthen_sig (Env.add_modtype id decl env) rem p
      (* Need to add the module type in case it is manifest *)
  | (Sig_class(id, decl, rs) as sigelt) :: rem ->
      sigelt :: strengthen_sig env rem p
  | (Sig_class_type(id, decl, rs) as sigelt) :: rem ->
      sigelt :: strengthen_sig env rem p

and strengthen_decl env md p =
  {md with md_type = strengthen env md.md_type p}

let () = Env.strengthen := strengthen

(* In nondep_supertype, env is only used for the type it assigns to id.
   Hence there is no need to keep env up-to-date by adding the bindings
   traversed. *)

type variance = Co | Contra | Strict

let nondep_supertype env mid mty =

  let rec nondep_mty env va mty =
    match mty with
      Mty_ident p ->
        if Path.isfree mid p then
          nondep_mty env va (Env.find_modtype_expansion p env)
        else mty
    | Mty_alias p ->
        if Path.isfree mid p then
          nondep_mty env va (Env.find_module p env).md_type
        else mty
    | Mty_signature sg ->
        Mty_signature(nondep_sig env va sg)
    | Mty_functor(param, arg, res) ->
        let var_inv =
          match va with Co -> Contra | Contra -> Co | Strict -> Strict in
        Mty_functor(param, Misc.may_map (nondep_mty env var_inv) arg,
                    nondep_mty
                      (Env.add_module ~arg:true param
                         (Btype.default_mty arg) env) va res)

  and nondep_sig env va = function
    [] -> []
  | item :: rem ->
      let rem' = nondep_sig env va rem in
      match item with
        Sig_value(id, d) ->
          Sig_value(id,
                    {d with val_type = Ctype.nondep_type env mid d.val_type})
          :: rem'
      | Sig_type(id, d, rs) ->
          Sig_type(id, Ctype.nondep_type_decl env mid id (va = Co) d, rs)
          :: rem'
      | Sig_typext(id, ext, es) ->
          Sig_typext(id, Ctype.nondep_extension_constructor env mid ext, es)
          :: rem'
      | Sig_module(id, md, rs) ->
          Sig_module(id, {md with md_type=nondep_mty env va md.md_type}, rs)
          :: rem'
      | Sig_modtype(id, d) ->
          begin try
            Sig_modtype(id, nondep_modtype_decl env d) :: rem'
          with Not_found ->
            match va with
              Co -> Sig_modtype(id, {mtd_type=None; mtd_loc=Location.none;
                                     mtd_attributes=[]}) :: rem'
            | _  -> raise Not_found
          end
      | Sig_class(id, d, rs) ->
          Sig_class(id, Ctype.nondep_class_declaration env mid d, rs)
          :: rem'
      | Sig_class_type(id, d, rs) ->
          Sig_class_type(id, Ctype.nondep_cltype_declaration env mid d, rs)
          :: rem'

  and nondep_modtype_decl env mtd =
    {mtd with mtd_type = Misc.may_map (nondep_mty env Strict) mtd.mtd_type}

  in
    nondep_mty env Co mty

let enrich_typedecl env p decl =
  match decl.type_manifest with
    Some ty -> decl
  | None ->
      try
        let orig_decl = Env.find_type p env in
        if orig_decl.type_arity <> decl.type_arity
        then decl
        else {decl with type_manifest =
                Some(Btype.newgenty(Tconstr(p, decl.type_params, ref Mnil)))}
      with Not_found ->
        decl

let rec enrich_modtype env p mty =
  match mty with
    Mty_signature sg ->
      Mty_signature(List.map (enrich_item env p) sg)
  | _ ->
      mty

and enrich_item env p = function
    Sig_type(id, decl, rs) ->
      Sig_type(id,
                enrich_typedecl env (Pdot(p, Ident.name id, nopos)) decl, rs)
  | Sig_module(id, md, rs) ->
      Sig_module(id,
                  {md with
                   md_type = enrich_modtype env
                       (Pdot(p, Ident.name id, nopos)) md.md_type},
                 rs)
  | item -> item

let rec type_paths env p mty =
  match scrape env mty with
    Mty_ident p -> []
  | Mty_alias p -> []
  | Mty_signature sg -> type_paths_sig env p 0 sg
  | Mty_functor(param, arg, res) -> []

and type_paths_sig env p pos sg =
  match sg with
    [] -> []
  | Sig_value(id, decl) :: rem ->
      let pos' = match decl.val_kind with Val_prim _ -> pos | _ -> pos + 1 in
      type_paths_sig env p pos' rem
  | Sig_type(id, decl, _) :: rem ->
      Pdot(p, Ident.name id, nopos) :: type_paths_sig env p pos rem
  | Sig_module(id, md, _) :: rem ->
      type_paths env (Pdot(p, Ident.name id, pos)) md.md_type @
      type_paths_sig (Env.add_module_declaration id md env) p (pos+1) rem
  | Sig_modtype(id, decl) :: rem ->
      type_paths_sig (Env.add_modtype id decl env) p pos rem
  | (Sig_typext _ | Sig_class _) :: rem ->
      type_paths_sig env p (pos+1) rem
  | (Sig_class_type _) :: rem ->
      type_paths_sig env p pos rem

let rec no_code_needed env mty =
  match scrape env mty with
    Mty_ident p -> false
  | Mty_signature sg -> no_code_needed_sig env sg
  | Mty_functor(_, _, _) -> false
  | Mty_alias p -> true

and no_code_needed_sig env sg =
  match sg with
    [] -> true
  | Sig_value(id, decl) :: rem ->
      begin match decl.val_kind with
      | Val_prim _ -> no_code_needed_sig env rem
      | _ -> false
      end
  | Sig_module(id, md, _) :: rem ->
      no_code_needed env md.md_type &&
      no_code_needed_sig (Env.add_module_declaration id md env) rem
  | (Sig_type _ | Sig_modtype _ | Sig_class_type _) :: rem ->
      no_code_needed_sig env rem
  | (Sig_typext _ | Sig_class _) :: rem ->
      false


(* Check whether a module type may return types *)

let rec contains_type env = function
    Mty_ident path ->
      begin try match (Env.find_modtype path env).mtd_type with
      | None -> raise Exit (* PR#6427 *)
      | Some mty -> contains_type env mty
      with Not_found -> raise Exit
      end
  | Mty_signature sg ->
      contains_type_sig env sg
  | Mty_functor (_, _, body) ->
      contains_type env body
  | Mty_alias _ ->
      ()

and contains_type_sig env = List.iter (contains_type_item env)

and contains_type_item env = function
    Sig_type (_,({type_manifest = None} |
                 {type_kind = Type_abstract; type_private = Private}),_)
  | Sig_modtype _ ->
      raise Exit
  | Sig_module (_, {md_type = mty}, _) ->
      contains_type env mty
  | Sig_value _
  | Sig_type _
  | Sig_typext _
  | Sig_class _
  | Sig_class_type _ ->
      ()

let contains_type env mty =
  try contains_type env mty; false with Exit -> true


(* Remove module aliases from a signature *)

module P = struct
  type t = Path.t
  let compare p1 p2 =
    if Path.same p1 p2 then 0 else compare p1 p2
end
module PathSet = Set.Make (P)
module PathMap = Map.Make (P)
module IdentSet = Set.Make (struct type t = Ident.t let compare = compare end)

let rec get_prefixes = function
    Pident _ -> PathSet.empty
  | Pdot (p, _, _)
  | Papply (p, _) -> PathSet.add p (get_prefixes p)

let rec get_arg_paths = function
    Pident _ -> PathSet.empty
  | Pdot (p, _, _) -> get_arg_paths p
  | Papply (p1, p2) ->
      PathSet.add p2
        (PathSet.union (get_prefixes p2)
           (PathSet.union (get_arg_paths p1) (get_arg_paths p2)))

let rec rollback_path subst p =
  try Pident (PathMap.find p subst)
  with Not_found ->
    match p with
      Pident _ | Papply _ -> p
    | Pdot (p1, s, n) ->
        let p1' = rollback_path subst p1 in
        if Path.same p1 p1' then p else rollback_path subst (Pdot (p1', s, n))

let rec collect_ids subst bindings p =
    begin match rollback_path subst p with
      Pident id ->
        let ids =
          try collect_ids subst bindings (Ident.find_same id bindings)
          with Not_found -> IdentSet.empty
        in
        IdentSet.add id ids
    | _ -> IdentSet.empty
    end

let collect_arg_paths mty =
  let open Btype in
  let paths = ref PathSet.empty
  and subst = ref PathMap.empty
  and bindings = ref Ident.empty in
  (* let rt = Ident.create "Root" in
     and prefix = ref (Path.Pident rt) in *)
  let it_path p = paths := PathSet.union (get_arg_paths p) !paths
  and it_signature_item it si =
    type_iterators.it_signature_item it si;
    match si with
      Sig_module (id, {md_type=Mty_alias p}, _) ->
        bindings := Ident.add id p !bindings
    | Sig_module (id, {md_type=Mty_signature sg}, _) ->
        List.iter
          (function Sig_module (id', _, _) ->
              subst :=
                PathMap.add (Pdot (Pident id, Ident.name id', -1)) id' !subst
            | _ -> ())
          sg
    | _ -> ()
  in
  let it = {type_iterators with it_path; it_signature_item} in
  it.it_module_type it mty;
  it.it_module_type unmark_iterators mty;
  PathSet.fold (fun p -> IdentSet.union (collect_ids !subst !bindings p))
    !paths IdentSet.empty

let rec remove_aliases env excl mty =
  match mty with
    Mty_signature sg ->
      Mty_signature (remove_aliases_sig env excl sg)
  | Mty_alias _ ->
      let mty' = Env.scrape_alias env mty in
      if mty' = mty then mty else
      remove_aliases env excl mty'
  | mty ->
      mty

and remove_aliases_sig env excl sg =
  match sg with
    [] -> []
  | Sig_module(id, md, rs) :: rem  ->
      let mty =
        match md.md_type with
          Mty_alias _ when IdentSet.mem id excl ->
            md.md_type
        | mty ->
            remove_aliases env excl mty
      in
      Sig_module(id, {md with md_type = mty} , rs) ::
      remove_aliases_sig (Env.add_module id mty env) excl rem
  | Sig_modtype(id, mtd) :: rem ->
      Sig_modtype(id, mtd) ::
      remove_aliases_sig (Env.add_modtype id mtd env) excl rem
  | it :: rem ->
      it :: remove_aliases_sig env excl rem

let remove_aliases env sg =
  let excl = collect_arg_paths sg in
  (* PathSet.iter (fun p -> Format.eprintf "%a@ " Printtyp.path p) excl;
  Format.eprintf "@."; *)
  remove_aliases env excl sg

end
module Includemod : sig 
#1 "includemod.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Inclusion checks for the module language *)

open Typedtree
open Types
open Format

val modtypes: Env.t -> module_type -> module_type -> module_coercion
val signatures: Env.t -> signature -> signature -> module_coercion
val compunit:
      Env.t -> string -> signature -> string -> signature -> module_coercion
val type_declarations:
      Env.t -> Ident.t -> type_declaration -> type_declaration -> unit
val print_coercion: formatter -> module_coercion -> unit

type symptom =
    Missing_field of Ident.t * Location.t * string (* kind *)
  | Value_descriptions of Ident.t * value_description * value_description
  | Type_declarations of Ident.t * type_declaration
        * type_declaration * Includecore.type_mismatch list
  | Extension_constructors of
      Ident.t * extension_constructor * extension_constructor
  | Module_types of module_type * module_type
  | Modtype_infos of Ident.t * modtype_declaration * modtype_declaration
  | Modtype_permutation
  | Interface_mismatch of string * string
  | Class_type_declarations of
      Ident.t * class_type_declaration * class_type_declaration *
      Ctype.class_match_failure list
  | Class_declarations of
      Ident.t * class_declaration * class_declaration *
      Ctype.class_match_failure list
  | Unbound_modtype_path of Path.t
  | Unbound_module_path of Path.t
  | Invalid_module_alias of Path.t

type pos =
    Module of Ident.t | Modtype of Ident.t | Arg of Ident.t | Body of Ident.t
type error = pos list * Env.t * symptom

exception Error of error list

val report_error: formatter -> error list -> unit
val expand_module_alias: Env.t -> pos list -> Path.t -> Types.module_type

end = struct
#1 "includemod.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Inclusion checks for the module language *)

open Misc
open Path
open Typedtree
open Types

type symptom =
    Missing_field of Ident.t * Location.t * string (* kind *)
  | Value_descriptions of Ident.t * value_description * value_description
  | Type_declarations of Ident.t * type_declaration
        * type_declaration * Includecore.type_mismatch list
  | Extension_constructors of
      Ident.t * extension_constructor * extension_constructor
  | Module_types of module_type * module_type
  | Modtype_infos of Ident.t * modtype_declaration * modtype_declaration
  | Modtype_permutation
  | Interface_mismatch of string * string
  | Class_type_declarations of
      Ident.t * class_type_declaration * class_type_declaration *
      Ctype.class_match_failure list
  | Class_declarations of
      Ident.t * class_declaration * class_declaration *
      Ctype.class_match_failure list
  | Unbound_modtype_path of Path.t
  | Unbound_module_path of Path.t
  | Invalid_module_alias of Path.t

type pos =
    Module of Ident.t | Modtype of Ident.t | Arg of Ident.t | Body of Ident.t
type error = pos list * Env.t * symptom

exception Error of error list

(* All functions "blah env x1 x2" check that x1 is included in x2,
   i.e. that x1 is the type of an implementation that fulfills the
   specification x2. If not, Error is raised with a backtrace of the error. *)

(* Inclusion between value descriptions *)

let value_descriptions env cxt subst id vd1 vd2 =
  Cmt_format.record_value_dependency vd1 vd2;
  Env.mark_value_used env (Ident.name id) vd1;
  let vd2 = Subst.value_description subst vd2 in
  try
    Includecore.value_descriptions env id vd1 vd2
  with Includecore.Dont_match ->
    raise(Error[cxt, env, Value_descriptions(id, vd1, vd2)])

(* Inclusion between type declarations *)

let type_declarations env ?(old_env=env) cxt subst id decl1 decl2 =
  Env.mark_type_used env (Ident.name id) decl1;
  let decl2 = Subst.type_declaration subst decl2 in
  let err = Includecore.type_declarations env (Ident.name id) decl1 id decl2 in
  if err <> [] then
    raise(Error[cxt, old_env, Type_declarations(id, decl1, decl2, err)])

(* Inclusion between extension constructors *)

let extension_constructors env cxt subst id ext1 ext2 =
  let ext2 = Subst.extension_constructor subst ext2 in
  if Includecore.extension_constructors env id ext1 ext2
  then ()
  else raise(Error[cxt, env, Extension_constructors(id, ext1, ext2)])

(* Inclusion between class declarations *)

let class_type_declarations ~old_env env cxt subst id decl1 decl2 =
  let decl2 = Subst.cltype_declaration subst decl2 in
  match Includeclass.class_type_declarations env decl1 decl2 with
    []     -> ()
  | reason ->
      raise(Error[cxt, old_env,
                  Class_type_declarations(id, decl1, decl2, reason)])

let class_declarations ~old_env env cxt subst id decl1 decl2 =
  let decl2 = Subst.class_declaration subst decl2 in
  match Includeclass.class_declarations env decl1 decl2 with
    []     -> ()
  | reason ->
      raise(Error[cxt, old_env, Class_declarations(id, decl1, decl2, reason)])

(* Expand a module type identifier when possible *)

exception Dont_match

let may_expand_module_path env path =
  try ignore (Env.find_modtype_expansion path env); true
  with Not_found -> false

let expand_module_path env cxt path =
  try
    Env.find_modtype_expansion path env
  with Not_found ->
    raise(Error[cxt, env, Unbound_modtype_path path])

let expand_module_alias env cxt path =
  try (Env.find_module path env).md_type
  with Not_found ->
    raise(Error[cxt, env, Unbound_module_path path])

(*
let rec normalize_module_path env cxt path =
  match expand_module_alias env cxt path with
    Mty_alias path' -> normalize_module_path env cxt path'
  | _ -> path
*)

(* Extract name, kind and ident from a signature item *)

type field_desc =
    Field_value of string
  | Field_type of string
  | Field_typext of string
  | Field_module of string
  | Field_modtype of string
  | Field_class of string
  | Field_classtype of string

let kind_of_field_desc = function
  | Field_value _ -> "value"
  | Field_type _ -> "type"
  | Field_typext _ -> "extension constructor"
  | Field_module _ -> "module"
  | Field_modtype _ -> "module type"
  | Field_class _ -> "class"
  | Field_classtype _ -> "class type"

let item_ident_name = function
    Sig_value(id, d) -> (id, d.val_loc, Field_value(Ident.name id))
  | Sig_type(id, d, _) -> (id, d.type_loc, Field_type(Ident.name id))
  | Sig_typext(id, d, _) -> (id, d.ext_loc, Field_typext(Ident.name id))
  | Sig_module(id, d, _) -> (id, d.md_loc, Field_module(Ident.name id))
  | Sig_modtype(id, d) -> (id, d.mtd_loc, Field_modtype(Ident.name id))
  | Sig_class(id, d, _) -> (id, d.cty_loc, Field_class(Ident.name id))
  | Sig_class_type(id, d, _) -> (id, d.clty_loc, Field_classtype(Ident.name id))

let is_runtime_component = function
  | Sig_value(_,{val_kind = Val_prim _})
  | Sig_type(_,_,_)
  | Sig_modtype(_,_)
  | Sig_class_type(_,_,_) -> false
  | Sig_value(_,_)
  | Sig_typext(_,_,_)
  | Sig_module(_,_,_)
  | Sig_class(_, _,_) -> true

(* Print a coercion *)

let rec print_list pr ppf = function
    [] -> ()
  | [a] -> pr ppf a
  | a :: l -> pr ppf a; Format.fprintf ppf ";@ "; print_list pr ppf l
let print_list pr ppf l =
  Format.fprintf ppf "[@[%a@]]" (print_list pr) l

let rec print_coercion ppf c =
  let pr fmt = Format.fprintf ppf fmt in
  match c with
    Tcoerce_none -> pr "id"
  | Tcoerce_structure (fl, nl) ->
      pr "@[<2>struct@ %a@ %a@]"
        (print_list print_coercion2) fl
        (print_list print_coercion3) nl
  | Tcoerce_functor (inp, out) ->
      pr "@[<2>functor@ (%a)@ (%a)@]"
        print_coercion inp
        print_coercion out
  | Tcoerce_primitive (_,pd) ->
      pr "prim %s" pd.Primitive.prim_name
  | Tcoerce_alias (p, c) ->
      pr "@[<2>alias %a@ (%a)@]"
        Printtyp.path p
        print_coercion c
and print_coercion2 ppf (n, c) =
  Format.fprintf ppf "@[%d,@ %a@]" n print_coercion c
and print_coercion3 ppf (i, n, c) =
  Format.fprintf ppf "@[%s, %d,@ %a@]"
    (Ident.unique_name i) n print_coercion c

(* Simplify a structure coercion *)

let simplify_structure_coercion cc id_pos_list =
  let rec is_identity_coercion pos = function
  | [] ->
      true
  | (n, c) :: rem ->
      n = pos && c = Tcoerce_none && is_identity_coercion (pos + 1) rem in
  if is_identity_coercion 0 cc
  then Tcoerce_none
  else Tcoerce_structure (cc, id_pos_list)

(* Inclusion between module types.
   Return the restriction that transforms a value of the smaller type
   into a value of the bigger type. *)

let rec modtypes env cxt subst mty1 mty2 =
  try
    try_modtypes env cxt subst mty1 mty2
  with
    Dont_match ->
      raise(Error[cxt, env, Module_types(mty1, Subst.modtype subst mty2)])
  | Error reasons as err ->
      match mty1, mty2 with
        Mty_alias _, _
      | _, Mty_alias _ -> raise err
      | _ ->
          raise(Error((cxt, env, Module_types(mty1, Subst.modtype subst mty2))
                      :: reasons))

and try_modtypes env cxt subst mty1 mty2 =
  match (mty1, mty2) with
  | (Mty_alias p1, Mty_alias p2) ->
      if Env.is_functor_arg p2 env then
        raise (Error[cxt, env, Invalid_module_alias p2]);
      if Path.same p1 p2 then Tcoerce_none else
      let p1 = Env.normalize_path None env p1
      and p2 = Env.normalize_path None env (Subst.module_path subst p2) in
      (* Should actually be Tcoerce_ignore, if it existed *)
      if Path.same p1 p2 then Tcoerce_none else raise Dont_match
  | (Mty_alias p1, _) ->
      let p1 = try
        Env.normalize_path (Some Location.none) env p1
      with Env.Error (Env.Missing_module (_, _, path)) ->
        raise (Error[cxt, env, Unbound_module_path path])
      in
      let mty1 = Mtype.strengthen env (expand_module_alias env cxt p1) p1 in
      Tcoerce_alias (p1, modtypes env cxt subst mty1 mty2)
  | (Mty_ident p1, _) when may_expand_module_path env p1 ->
      try_modtypes env cxt subst (expand_module_path env cxt p1) mty2
  | (_, Mty_ident p2) ->
      try_modtypes2 env cxt mty1 (Subst.modtype subst mty2)
  | (Mty_signature sig1, Mty_signature sig2) ->
      signatures env cxt subst sig1 sig2
  | (Mty_functor(param1, None, res1), Mty_functor(param2, None, res2)) ->
      begin match modtypes env (Body param1::cxt) subst res1 res2 with
        Tcoerce_none -> Tcoerce_none
      | cc -> Tcoerce_functor (Tcoerce_none, cc)
      end
  | (Mty_functor(param1, Some arg1, res1),
     Mty_functor(param2, Some arg2, res2)) ->
      let arg2' = Subst.modtype subst arg2 in
      let cc_arg = modtypes env (Arg param1::cxt) Subst.identity arg2' arg1 in
      let cc_res =
        modtypes (Env.add_module param1 arg2' env) (Body param1::cxt)
          (Subst.add_module param2 (Pident param1) subst) res1 res2 in
      begin match (cc_arg, cc_res) with
          (Tcoerce_none, Tcoerce_none) -> Tcoerce_none
        | _ -> Tcoerce_functor(cc_arg, cc_res)
      end
  | (_, _) ->
      raise Dont_match

and try_modtypes2 env cxt mty1 mty2 =
  (* mty2 is an identifier *)
  match (mty1, mty2) with
    (Mty_ident p1, Mty_ident p2) when Path.same p1 p2 ->
      Tcoerce_none
  | (_, Mty_ident p2) ->
      try_modtypes env cxt Subst.identity mty1 (expand_module_path env cxt p2)
  | (_, _) ->
      assert false

(* Inclusion between signatures *)

and signatures env cxt subst sig1 sig2 =
  (* Environment used to check inclusion of components *)
  let new_env =
    Env.add_signature sig1 (Env.in_signature env) in
  (* Keep ids for module aliases *)
  let (id_pos_list,_) =
    List.fold_left
      (fun (l,pos) -> function
          Sig_module (id, _, _) ->
            ((id,pos,Tcoerce_none)::l , pos+1)
        | item -> (l, if is_runtime_component item then pos+1 else pos))
      ([], 0) sig1 in
  (* Build a table of the components of sig1, along with their positions.
     The table is indexed by kind and name of component *)
  let rec build_component_table pos tbl = function
      [] -> pos, tbl
    | item :: rem ->
        let (id, _loc, name) = item_ident_name item in
        let nextpos = if is_runtime_component item then pos + 1 else pos in
        build_component_table nextpos
                              (Tbl.add name (id, item, pos) tbl) rem in
  let len1, comps1 =
    build_component_table 0 Tbl.empty sig1 in
  let len2 =
    List.fold_left
      (fun n i -> if is_runtime_component i then n + 1 else n)
      0
      sig2
  in
  (* Pair each component of sig2 with a component of sig1,
     identifying the names along the way.
     Return a coercion list indicating, for all run-time components
     of sig2, the position of the matching run-time components of sig1
     and the coercion to be applied to it. *)
  let rec pair_components subst paired unpaired = function
      [] ->
        begin match unpaired with
            [] ->
              let cc =
                signature_components env new_env cxt subst (List.rev paired)
              in
              if len1 = len2 then (* see PR#5098 *)
                simplify_structure_coercion cc id_pos_list
              else
                Tcoerce_structure (cc, id_pos_list)
          | _  -> raise(Error unpaired)
        end
    | item2 :: rem ->
        let (id2, loc, name2) = item_ident_name item2 in
        let name2, report =
          match item2, name2 with
            Sig_type (_, {type_manifest=None}, _), Field_type s
            when let l = String.length s in
            l >= 4 && String.sub s (l-4) 4 = "#row" ->
              (* Do not report in case of failure,
                 as the main type will generate an error *)
              Field_type (String.sub s 0 (String.length s - 4)), false
          | _ -> name2, true
        in
        begin try
          let (id1, item1, pos1) = Tbl.find name2 comps1 in
          let new_subst =
            match item2 with
              Sig_type _ ->
                Subst.add_type id2 (Pident id1) subst
            | Sig_module _ ->
                Subst.add_module id2 (Pident id1) subst
            | Sig_modtype _ ->
                Subst.add_modtype id2 (Mty_ident (Pident id1)) subst
            | Sig_value _ | Sig_typext _
            | Sig_class _ | Sig_class_type _ ->
                subst
          in
          pair_components new_subst
            ((item1, item2, pos1) :: paired) unpaired rem
        with Not_found ->
          let unpaired =
            if report then
              (cxt, env, Missing_field (id2, loc, kind_of_field_desc name2)) ::
              unpaired
            else unpaired in
          pair_components subst paired unpaired rem
        end in
  (* Do the pairing and checking, and return the final coercion *)
  pair_components subst [] [] sig2

(* Inclusion between signature components *)

and signature_components old_env env cxt subst paired =
  let comps_rec rem = signature_components old_env env cxt subst rem in
  match paired with
    [] -> []
  | (Sig_value(id1, valdecl1), Sig_value(id2, valdecl2), pos) :: rem ->
      let cc = value_descriptions env cxt subst id1 valdecl1 valdecl2 in
      begin match valdecl2.val_kind with
        Val_prim p -> comps_rec rem
      | _ -> (pos, cc) :: comps_rec rem
      end
  | (Sig_type(id1, tydecl1, _), Sig_type(id2, tydecl2, _), pos) :: rem ->
      type_declarations ~old_env env cxt subst id1 tydecl1 tydecl2;
      comps_rec rem
  | (Sig_typext(id1, ext1, _), Sig_typext(id2, ext2, _), pos)
    :: rem ->
      extension_constructors env cxt subst id1 ext1 ext2;
      (pos, Tcoerce_none) :: comps_rec rem
  | (Sig_module(id1, mty1, _), Sig_module(id2, mty2, _), pos) :: rem ->
      let cc =
        modtypes env (Module id1::cxt) subst
          (Mtype.strengthen env mty1.md_type (Pident id1)) mty2.md_type in
      (pos, cc) :: comps_rec rem
  | (Sig_modtype(id1, info1), Sig_modtype(id2, info2), pos) :: rem ->
      modtype_infos env cxt subst id1 info1 info2;
      comps_rec rem
  | (Sig_class(id1, decl1, _), Sig_class(id2, decl2, _), pos) :: rem ->
      class_declarations ~old_env env cxt subst id1 decl1 decl2;
      (pos, Tcoerce_none) :: comps_rec rem
  | (Sig_class_type(id1, info1, _),
     Sig_class_type(id2, info2, _), pos) :: rem ->
      class_type_declarations ~old_env env cxt subst id1 info1 info2;
      comps_rec rem
  | _ ->
      assert false

(* Inclusion between module type specifications *)

and modtype_infos env cxt subst id info1 info2 =
  let info2 = Subst.modtype_declaration subst info2 in
  let cxt' = Modtype id :: cxt in
  try
    match (info1.mtd_type, info2.mtd_type) with
      (None, None) -> ()
    | (Some mty1, None) -> ()
    | (Some mty1, Some mty2) ->
        check_modtype_equiv env cxt' mty1 mty2
    | (None, Some mty2) ->
        check_modtype_equiv env cxt' (Mty_ident(Pident id)) mty2
  with Error reasons ->
    raise(Error((cxt, env, Modtype_infos(id, info1, info2)) :: reasons))

and check_modtype_equiv env cxt mty1 mty2 =
  match
    (modtypes env cxt Subst.identity mty1 mty2,
     modtypes env cxt Subst.identity mty2 mty1)
  with
    (Tcoerce_none, Tcoerce_none) -> ()
  | (_, _) -> raise(Error [cxt, env, Modtype_permutation])

(* Simplified inclusion check between module types (for Env) *)

let check_modtype_inclusion env mty1 path1 mty2 =
  try
    ignore(modtypes env [] Subst.identity
                    (Mtype.strengthen env mty1 path1) mty2)
  with Error reasons ->
    raise Not_found

let _ = Env.check_modtype_inclusion := check_modtype_inclusion

(* Check that an implementation of a compilation unit meets its
   interface. *)

let compunit env impl_name impl_sig intf_name intf_sig =
  try
    signatures env [] Subst.identity impl_sig intf_sig
  with Error reasons ->
    raise(Error(([], Env.empty,Interface_mismatch(impl_name, intf_name))
                :: reasons))

(* Hide the context and substitution parameters to the outside world *)

let modtypes env mty1 mty2 = modtypes env [] Subst.identity mty1 mty2
let signatures env sig1 sig2 = signatures env [] Subst.identity sig1 sig2
let type_declarations env id decl1 decl2 =
  type_declarations env [] Subst.identity id decl1 decl2

(*
let modtypes env m1 m2 =
  let c = modtypes env m1 m2 in
  Format.eprintf "@[<2>modtypes@ %a@ %a =@ %a@]@."
    Printtyp.modtype m1 Printtyp.modtype m2
    print_coercion c;
  c
*)

(* Error report *)

open Format
open Printtyp

let show_loc msg ppf loc =
  let pos = loc.Location.loc_start in
  if List.mem pos.Lexing.pos_fname [""; "_none_"; "//toplevel//"] then ()
  else fprintf ppf "@\n@[<2>%a:@ %s@]" Location.print_loc loc msg

let show_locs ppf (loc1, loc2) =
  show_loc "Expected declaration" ppf loc2;
  show_loc "Actual declaration" ppf loc1

let include_err ppf = function
  | Missing_field (id, loc, kind) ->
      fprintf ppf "The %s `%a' is required but not provided" kind ident id;
      show_loc "Expected declaration" ppf loc
  | Value_descriptions(id, d1, d2) ->
      fprintf ppf
        "@[<hv 2>Values do not match:@ %a@;<1 -2>is not included in@ %a@]"
        (value_description id) d1 (value_description id) d2;
      show_locs ppf (d1.val_loc, d2.val_loc);
  | Type_declarations(id, d1, d2, errs) ->
      fprintf ppf "@[<v>@[<hv>%s:@;<1 2>%a@ %s@;<1 2>%a@]%a%a@]"
        "Type declarations do not match"
        (type_declaration id) d1
        "is not included in"
        (type_declaration id) d2
        show_locs (d1.type_loc, d2.type_loc)
        (Includecore.report_type_mismatch
           "the first" "the second" "declaration") errs
  | Extension_constructors(id, x1, x2) ->
      fprintf ppf
       "@[<hv 2>Extension declarations do not match:@ \
        %a@;<1 -2>is not included in@ %a@]"
      (extension_constructor id) x1
      (extension_constructor id) x2;
      show_locs ppf (x1.ext_loc, x2.ext_loc)
  | Module_types(mty1, mty2)->
      fprintf ppf
       "@[<hv 2>Modules do not match:@ \
        %a@;<1 -2>is not included in@ %a@]"
      modtype mty1
      modtype mty2
  | Modtype_infos(id, d1, d2) ->
      fprintf ppf
       "@[<hv 2>Module type declarations do not match:@ \
        %a@;<1 -2>does not match@ %a@]"
      (modtype_declaration id) d1
      (modtype_declaration id) d2
  | Modtype_permutation ->
      fprintf ppf "Illegal permutation of structure fields"
  | Interface_mismatch(impl_name, intf_name) ->
      fprintf ppf "@[The implementation %s@ does not match the interface %s:"
       impl_name intf_name
  | Class_type_declarations(id, d1, d2, reason) ->
      fprintf ppf
       "@[<hv 2>Class type declarations do not match:@ \
        %a@;<1 -2>does not match@ %a@]@ %a"
      (Printtyp.cltype_declaration id) d1
      (Printtyp.cltype_declaration id) d2
      Includeclass.report_error reason
  | Class_declarations(id, d1, d2, reason) ->
      fprintf ppf
       "@[<hv 2>Class declarations do not match:@ \
        %a@;<1 -2>does not match@ %a@]@ %a"
      (Printtyp.class_declaration id) d1
      (Printtyp.class_declaration id) d2
      Includeclass.report_error reason
  | Unbound_modtype_path path ->
      fprintf ppf "Unbound module type %a" Printtyp.path path
  | Unbound_module_path path ->
      fprintf ppf "Unbound module %a" Printtyp.path path
  | Invalid_module_alias path ->
      fprintf ppf "Module %a cannot be aliased" Printtyp.path path

let rec context ppf = function
    Module id :: rem ->
      fprintf ppf "@[<2>module %a%a@]" ident id args rem
  | Modtype id :: rem ->
      fprintf ppf "@[<2>module type %a =@ %a@]" ident id context_mty rem
  | Body x :: rem ->
      fprintf ppf "functor (%s) ->@ %a" (argname x) context_mty rem
  | Arg x :: rem ->
      fprintf ppf "functor (%a : %a) -> ..." ident x context_mty rem
  | [] ->
      fprintf ppf "<here>"
and context_mty ppf = function
    (Module _ | Modtype _) :: _ as rem ->
      fprintf ppf "@[<2>sig@ %a@;<1 -2>end@]" context rem
  | cxt -> context ppf cxt
and args ppf = function
    Body x :: rem ->
      fprintf ppf "(%s)%a" (argname x) args rem
  | Arg x :: rem ->
      fprintf ppf "(%a :@ %a) : ..." ident x context_mty rem
  | cxt ->
      fprintf ppf " :@ %a" context_mty cxt
and argname x =
  let s = Ident.name x in
  if s = "*" then "" else s

let path_of_context = function
    Module id :: rem ->
      let rec subm path = function
          [] -> path
        | Module id :: rem -> subm (Pdot (path, Ident.name id, -1)) rem
        | _ -> assert false
      in subm (Pident id) rem
  | _ -> assert false

let context ppf cxt =
  if cxt = [] then () else
  if List.for_all (function Module _ -> true | _ -> false) cxt then
    fprintf ppf "In module %a:@ " path (path_of_context cxt)
  else
    fprintf ppf "@[<hv 2>At position@ %a@]@ " context cxt

let include_err ppf (cxt, env, err) =
  Printtyp.wrap_printing_env env (fun () ->
    fprintf ppf "@[<v>%a%a@]" context (List.rev cxt) include_err err)

let buffer = ref Bytes.empty
let is_big obj =
  let size = !Clflags.error_size in
  size > 0 &&
  begin
    if Bytes.length !buffer < size then buffer := Bytes.create size;
    try ignore (Marshal.to_buffer !buffer 0 size obj []); false
    with _ -> true
  end

let report_error ppf errs =
  if errs = [] then () else
  let (errs , err) = split_last errs in
  let pe = ref true in
  let include_err' ppf (_,_,obj as err) =
    if not (is_big obj) then fprintf ppf "%a@ " include_err err
    else if !pe then (fprintf ppf "...@ "; pe := false)
  in
  let print_errs ppf = List.iter (include_err' ppf) in
  fprintf ppf "@[<v>%a%a@]" print_errs errs include_err err


(* We could do a better job to split the individual error items
   as sub-messages of the main interface mismatch on the whole unit. *)
let () =
  Location.register_error_of_exn
    (function
      | Error err -> Some (Location.error_of_printer_file report_error err)
      | _ -> None
    )

end
module Stypes : sig 
#1 "stypes.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*          Damien Doligez, projet Moscova, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 2003 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Recording and dumping (partial) type information *)

(* Clflags.save_types must be true *)

open Typedtree;;

type annotation =
  | Ti_pat   of pattern
  | Ti_expr  of expression
  | Ti_class of class_expr
  | Ti_mod   of module_expr
  | An_call of Location.t * Annot.call
  | An_ident of Location.t * string * Annot.ident
;;

val record : annotation -> unit;;
val record_phrase : Location.t -> unit;;
val dump : string option -> unit;;

val get_location : annotation -> Location.t;;
val get_info : unit -> annotation list;;

end = struct
#1 "stypes.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*          Damien Doligez, projet Moscova, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 2003 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Recording and dumping (partial) type information *)

(*
  We record all types in a list as they are created.
  This means we can dump type information even if type inference fails,
  which is extremely important, since type information is most
  interesting in case of errors.
*)

open Annot;;
open Lexing;;
open Location;;
open Typedtree;;

let output_int oc i = output_string oc (string_of_int i)

type annotation =
  | Ti_pat   of pattern
  | Ti_expr  of expression
  | Ti_class of class_expr
  | Ti_mod   of module_expr
  | An_call of Location.t * Annot.call
  | An_ident of Location.t * string * Annot.ident
;;

let get_location ti =
  match ti with
    Ti_pat p   -> p.pat_loc
  | Ti_expr e  -> e.exp_loc
  | Ti_class c -> c.cl_loc
  | Ti_mod m   -> m.mod_loc
  | An_call (l, k) -> l
  | An_ident (l, s, k) -> l
;;

let annotations = ref ([] : annotation list);;
let phrases = ref ([] : Location.t list);;

let record ti =
  if !Clflags.annotations && not (get_location ti).Location.loc_ghost then
    annotations := ti :: !annotations
;;

let record_phrase loc =
  if !Clflags.annotations then phrases := loc :: !phrases;
;;

(* comparison order:
   the intervals are sorted by order of increasing upper bound
   same upper bound -> sorted by decreasing lower bound
*)
let cmp_loc_inner_first loc1 loc2 =
  match compare loc1.loc_end.pos_cnum loc2.loc_end.pos_cnum with
  | 0 -> compare loc2.loc_start.pos_cnum loc1.loc_start.pos_cnum
  | x -> x
;;
let cmp_ti_inner_first ti1 ti2 =
  cmp_loc_inner_first (get_location ti1) (get_location ti2)
;;

let print_position pp pos =
  if pos = dummy_pos then
    output_string pp "--"
  else begin
    output_char pp '\"';
    output_string pp (String.escaped pos.pos_fname);
    output_string pp "\" ";
    output_int pp pos.pos_lnum;
    output_char pp ' ';
    output_int pp pos.pos_bol;
    output_char pp ' ';
    output_int pp pos.pos_cnum;
  end
;;

let print_location pp loc =
  print_position pp loc.loc_start;
  output_char pp ' ';
  print_position pp loc.loc_end;
;;

let sort_filter_phrases () =
  let ph = List.sort (fun x y -> cmp_loc_inner_first y x) !phrases in
  let rec loop accu cur l =
    match l with
    | [] -> accu
    | loc :: t ->
       if cur.loc_start.pos_cnum <= loc.loc_start.pos_cnum
          && cur.loc_end.pos_cnum >= loc.loc_end.pos_cnum
       then loop accu cur t
       else loop (loc :: accu) loc t
  in
  phrases := loop [] Location.none ph;
;;

let rec printtyp_reset_maybe loc =
  match !phrases with
  | cur :: t when cur.loc_start.pos_cnum <= loc.loc_start.pos_cnum ->
     Printtyp.reset ();
     phrases := t;
     printtyp_reset_maybe loc;
  | _ -> ()
;;

let call_kind_string k =
  match k with
  | Tail -> "tail"
  | Stack -> "stack"
  | Inline -> "inline"
;;

let print_ident_annot pp str k =
  match k with
  | Idef l ->
      output_string pp "def ";
      output_string pp str;
      output_char pp ' ';
      print_location pp l;
      output_char pp '\n'
  | Iref_internal l ->
      output_string pp "int_ref ";
      output_string pp str;
      output_char pp ' ';
      print_location pp l;
      output_char pp '\n'
  | Iref_external ->
      output_string pp "ext_ref ";
      output_string pp str;
      output_char pp '\n'
;;

(* The format of the annotation file is documented in emacs/caml-types.el. *)

let print_info pp prev_loc ti =
  match ti with
  | Ti_class _ | Ti_mod _ -> prev_loc
  | Ti_pat  {pat_loc = loc; pat_type = typ; pat_env = env}
  | Ti_expr {exp_loc = loc; exp_type = typ; exp_env = env} ->
      if loc <> prev_loc then begin
        print_location pp loc;
        output_char pp '\n'
      end;
      output_string pp "type(\n";
      printtyp_reset_maybe loc;
      Printtyp.mark_loops typ;
      Format.pp_print_string Format.str_formatter "  ";
      Printtyp.wrap_printing_env env
                       (fun () -> Printtyp.type_sch Format.str_formatter typ);
      Format.pp_print_newline Format.str_formatter ();
      let s = Format.flush_str_formatter () in
      output_string pp s;
      output_string pp ")\n";
      loc
  | An_call (loc, k) ->
      if loc <> prev_loc then begin
        print_location pp loc;
        output_char pp '\n'
      end;
      output_string pp "call(\n  ";
      output_string pp (call_kind_string k);
      output_string pp "\n)\n";
      loc
  | An_ident (loc, str, k) ->
      if loc <> prev_loc then begin
        print_location pp loc;
        output_char pp '\n'
      end;
      output_string pp "ident(\n  ";
      print_ident_annot pp str k;
      output_string pp ")\n";
      loc
;;

let get_info () =
  let info = List.fast_sort cmp_ti_inner_first !annotations in
  annotations := [];
  info
;;

let dump filename =
  if !Clflags.annotations then begin
    let info = get_info () in
    let pp =
      match filename with
          None -> stdout
        | Some filename -> open_out filename in
    sort_filter_phrases ();
    ignore (List.fold_left (print_info pp) Location.none info);
    begin match filename with
    | None -> ()
    | Some _ -> close_out pp
    end;
    phrases := [];
  end else begin
    annotations := [];
  end;
;;

end
module Parmatch : sig 
#1 "parmatch.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Detection of partial matches and unused match cases. *)
open Asttypes
open Typedtree
open Types

val pretty_const : constant -> string
val top_pretty : Format.formatter -> pattern -> unit
val pretty_pat : pattern -> unit
val pretty_line : pattern list -> unit
val pretty_matrix : pattern list list -> unit

val omega : pattern
val omegas : int -> pattern list
val omega_list : 'a list -> pattern list
val normalize_pat : pattern -> pattern
val all_record_args :
    (Longident.t loc * label_description * pattern) list ->
    (Longident.t loc * label_description * pattern) list
val const_compare : constant -> constant -> int

val le_pat : pattern -> pattern -> bool
val le_pats : pattern list -> pattern list -> bool
val compat : pattern -> pattern -> bool
val compats : pattern list -> pattern list -> bool
exception Empty
val lub : pattern -> pattern -> pattern
val lubs : pattern list -> pattern list -> pattern list

val get_mins : ('a -> 'a -> bool) -> 'a list -> 'a list

(* Those two functions recombine one pattern and its arguments:
   For instance:
     (_,_)::p1::p2::rem -> (p1, p2)::rem
   The second one will replace mutable arguments by '_'
*)
val set_args : pattern -> pattern list -> pattern list
val set_args_erase_mutable : pattern -> pattern list -> pattern list

val pat_of_constr : pattern -> constructor_description -> pattern
val complete_constrs :
    pattern -> constructor_tag list -> constructor_description  list

val pressure_variants: Env.t -> pattern list -> unit
val check_partial_gadt:
    ((string, constructor_description) Hashtbl.t ->
     (string, label_description) Hashtbl.t ->
     Parsetree.pattern -> pattern option) ->
    Location.t -> case list -> partial
val check_unused: Env.t -> case list -> unit

(* Irrefutability tests *)
val irrefutable : pattern -> bool
val fluid : pattern -> bool

end = struct
#1 "parmatch.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Detection of partial matches and unused match cases. *)

open Misc
open Asttypes
open Types
open Typedtree

(*************************************)
(* Utilities for building patterns   *)
(*************************************)

let make_pat desc ty tenv =
  {pat_desc = desc; pat_loc = Location.none; pat_extra = [];
   pat_type = ty ; pat_env = tenv;
   pat_attributes = [];
  }

let omega = make_pat Tpat_any Ctype.none Env.empty

let extra_pat =
  make_pat
    (Tpat_var (Ident.create "+", mknoloc "+"))
    Ctype.none Env.empty

let rec omegas i =
  if i <= 0 then [] else omega :: omegas (i-1)

let omega_list l = List.map (fun _ -> omega) l

let zero = make_pat (Tpat_constant (Const_int 0)) Ctype.none Env.empty

(***********************)
(* Compatibility check *)
(***********************)

(* p and q compatible means, there exists V that matches both *)

let is_absent tag row = Btype.row_field tag !row = Rabsent

let is_absent_pat p = match p.pat_desc with
| Tpat_variant (tag, _, row) -> is_absent tag row
| _ -> false

let const_compare x y =
  match x,y with
  | Const_float f1, Const_float f2 ->
      Pervasives.compare (float_of_string f1) (float_of_string f2)
  | Const_string (s1, _), Const_string (s2, _) ->
      String.compare s1 s2
  | _, _ -> Pervasives.compare x y

let records_args l1 l2 =
  (* Invariant: fields are already sorted by Typecore.type_label_a_list *)
  let rec combine r1 r2 l1 l2 = match l1,l2 with
  | [],[] -> List.rev r1, List.rev r2
  | [],(_,_,p2)::rem2 -> combine (omega::r1) (p2::r2) [] rem2
  | (_,_,p1)::rem1,[] -> combine (p1::r1) (omega::r2) rem1 []
  | (_,lbl1,p1)::rem1, ( _,lbl2,p2)::rem2 ->
      if lbl1.lbl_pos < lbl2.lbl_pos then
        combine (p1::r1) (omega::r2) rem1 l2
      else if lbl1.lbl_pos > lbl2.lbl_pos then
        combine (omega::r1) (p2::r2) l1 rem2
      else (* same label on both sides *)
        combine (p1::r1) (p2::r2) rem1 rem2 in
  combine [] [] l1 l2


let rec compat p q =
  match p.pat_desc,q.pat_desc with
  | Tpat_alias (p,_,_),_      -> compat p q
  | _,Tpat_alias (q,_,_)      -> compat p q
  | (Tpat_any|Tpat_var _),_ -> true
  | _,(Tpat_any|Tpat_var _) -> true
  | Tpat_or (p1,p2,_),_     -> compat p1 q || compat p2 q
  | _,Tpat_or (q1,q2,_)     -> compat p q1 || compat p q2
  | Tpat_constant c1, Tpat_constant c2 -> const_compare c1 c2 = 0
  | Tpat_tuple ps, Tpat_tuple qs -> compats ps qs
  | Tpat_lazy p, Tpat_lazy q -> compat p q
  | Tpat_construct (_, c1,ps1), Tpat_construct (_, c2,ps2) ->
      Types.equal_tag c1.cstr_tag  c2.cstr_tag && compats ps1 ps2
  | Tpat_variant(l1,Some p1, r1), Tpat_variant(l2,Some p2,_) ->
      l1=l2 && compat p1 p2
  | Tpat_variant (l1,None,r1), Tpat_variant(l2,None,_) ->
      l1 = l2
  | Tpat_variant (_, None, _), Tpat_variant (_,Some _, _) -> false
  | Tpat_variant (_, Some _, _), Tpat_variant (_, None, _) -> false
  | Tpat_record (l1,_),Tpat_record (l2,_) ->
      let ps,qs = records_args l1 l2 in
      compats ps qs
  | Tpat_array ps, Tpat_array qs ->
      List.length ps = List.length qs &&
      compats ps qs
  | _,_  ->
      assert false

and compats ps qs = match ps,qs with
| [], [] -> true
| p::ps, q::qs -> compat p q && compats ps qs
| _,_    -> assert false

exception Empty (* Empty pattern *)

(****************************************)
(* Utilities for retrieving type paths  *)
(****************************************)

(* May need a clean copy, cf. PR#4745 *)
let clean_copy ty =
  if ty.level = Btype.generic_level then ty
  else Subst.type_expr Subst.identity ty

let get_type_path ty tenv =
  let ty = Ctype.repr (Ctype.expand_head tenv (clean_copy ty)) in
  match ty.desc with
  | Tconstr (path,_,_) -> path
  | _ -> fatal_error "Parmatch.get_type_path"

(*************************************)
(* Values as patterns pretty printer *)
(*************************************)

open Format
;;

let is_cons = function
| {cstr_name = "::"} -> true
| _ -> false

let pretty_const c = match c with
| Const_int i -> Printf.sprintf "%d" i
| Const_char c -> Printf.sprintf "%C" c
| Const_string (s, _) -> Printf.sprintf "%S" s
| Const_float f -> Printf.sprintf "%s" f
| Const_int32 i -> Printf.sprintf "%ldl" i
| Const_int64 i -> Printf.sprintf "%LdL" i
| Const_nativeint i -> Printf.sprintf "%ndn" i

let rec pretty_val ppf v =
  match v.pat_extra with
      (cstr, _loc, _attrs) :: rem ->
        begin match cstr with
          | Tpat_unpack ->
            fprintf ppf "@[(module %a)@]" pretty_val { v with pat_extra = rem }
          | Tpat_constraint ctyp ->
            fprintf ppf "@[(%a : _)@]" pretty_val { v with pat_extra = rem }
          | Tpat_type _ ->
            fprintf ppf "@[(# %a)@]" pretty_val { v with pat_extra = rem }
        end
    | [] ->
  match v.pat_desc with
  | Tpat_any -> fprintf ppf "_"
  | Tpat_var (x,_) -> Ident.print ppf x
  | Tpat_constant c -> fprintf ppf "%s" (pretty_const c)
  | Tpat_tuple vs ->
      fprintf ppf "@[(%a)@]" (pretty_vals ",") vs
  | Tpat_construct (_, cstr, []) ->
      fprintf ppf "%s" cstr.cstr_name
  | Tpat_construct (_, cstr, [w]) ->
      fprintf ppf "@[<2>%s@ %a@]" cstr.cstr_name pretty_arg w
  | Tpat_construct (_, cstr, vs) ->
      let name = cstr.cstr_name in
      begin match (name, vs) with
        ("::", [v1;v2]) ->
          fprintf ppf "@[%a::@,%a@]" pretty_car v1 pretty_cdr v2
      |  _ ->
          fprintf ppf "@[<2>%s@ @[(%a)@]@]" name (pretty_vals ",") vs
      end
  | Tpat_variant (l, None, _) ->
      fprintf ppf "`%s" l
  | Tpat_variant (l, Some w, _) ->
      fprintf ppf "@[<2>`%s@ %a@]" l pretty_arg w
  | Tpat_record (lvs,_) ->
      fprintf ppf "@[{%a}@]"
        pretty_lvals
        (List.filter
           (function
             | (_,_,{pat_desc=Tpat_any}) -> false (* do not show lbl=_ *)
             | _ -> true) lvs)
  | Tpat_array vs ->
      fprintf ppf "@[[| %a |]@]" (pretty_vals " ;") vs
  | Tpat_lazy v ->
      fprintf ppf "@[<2>lazy@ %a@]" pretty_arg v
  | Tpat_alias (v, x,_) ->
      fprintf ppf "@[(%a@ as %a)@]" pretty_val v Ident.print x
  | Tpat_or (v,w,_)    ->
      fprintf ppf "@[(%a|@,%a)@]" pretty_or v pretty_or w

and pretty_car ppf v = match v.pat_desc with
| Tpat_construct (_,cstr, [_ ; _])
    when is_cons cstr ->
      fprintf ppf "(%a)" pretty_val v
| _ -> pretty_val ppf v

and pretty_cdr ppf v = match v.pat_desc with
| Tpat_construct (_,cstr, [v1 ; v2])
    when is_cons cstr ->
      fprintf ppf "%a::@,%a" pretty_car v1 pretty_cdr v2
| _ -> pretty_val ppf v

and pretty_arg ppf v = match v.pat_desc with
| Tpat_construct (_,_,_::_)
| Tpat_variant (_, Some _, _) -> fprintf ppf "(%a)" pretty_val v
|  _ -> pretty_val ppf v

and pretty_or ppf v = match v.pat_desc with
| Tpat_or (v,w,_) ->
    fprintf ppf "%a|@,%a" pretty_or v pretty_or w
| _ -> pretty_val ppf v

and pretty_vals sep ppf = function
  | [] -> ()
  | [v] -> pretty_val ppf v
  | v::vs ->
      fprintf ppf "%a%s@ %a" pretty_val v sep (pretty_vals sep) vs

and pretty_lvals ppf = function
  | [] -> ()
  | [_,lbl,v] ->
      fprintf ppf "%s=%a" lbl.lbl_name pretty_val v
  | (_, lbl,v)::rest ->
      fprintf ppf "%s=%a;@ %a"
        lbl.lbl_name pretty_val v pretty_lvals rest

let top_pretty ppf v =
  fprintf ppf "@[%a@]@?" pretty_val v


let pretty_pat p =
  top_pretty Format.str_formatter p ;
  prerr_string (Format.flush_str_formatter ())

type matrix = pattern list list

let pretty_line ps =
  List.iter
    (fun p ->
      top_pretty Format.str_formatter p ;
      prerr_string " <" ;
      prerr_string (Format.flush_str_formatter ()) ;
      prerr_string ">")
    ps

let pretty_matrix (pss : matrix) =
  prerr_endline "begin matrix" ;
  List.iter
    (fun ps ->
      pretty_line ps ;
      prerr_endline "")
    pss ;
  prerr_endline "end matrix"


(****************************)
(* Utilities for matching   *)
(****************************)

(* Check top matching *)
let simple_match p1 p2 =
  match p1.pat_desc, p2.pat_desc with
  | Tpat_construct(_, c1, _), Tpat_construct(_, c2, _) ->
      Types.equal_tag c1.cstr_tag c2.cstr_tag
  | Tpat_variant(l1, _, _), Tpat_variant(l2, _, _) ->
      l1 = l2
  | Tpat_constant(c1), Tpat_constant(c2) -> const_compare c1 c2 = 0
  | Tpat_tuple _, Tpat_tuple _ -> true
  | Tpat_lazy _, Tpat_lazy _ -> true
  | Tpat_record _ , Tpat_record _ -> true
  | Tpat_array p1s, Tpat_array p2s -> List.length p1s = List.length p2s
  | _, (Tpat_any | Tpat_var(_)) -> true
  | _, _ -> false




(* extract record fields as a whole *)
let record_arg p = match p.pat_desc with
| Tpat_any -> []
| Tpat_record (args,_) -> args
| _ -> fatal_error "Parmatch.as_record"


(* Raise Not_found when pos is not present in arg *)
let get_field pos arg =
  let _,_, p = List.find (fun (_,lbl,_) -> pos = lbl.lbl_pos) arg in
  p

let extract_fields omegas arg =
  List.map
    (fun (_,lbl,_) ->
      try
        get_field lbl.lbl_pos arg
      with Not_found -> omega)
    omegas

let all_record_args lbls = match lbls with
| (_,{lbl_all=lbl_all},_)::_ ->
    let t =
      Array.map
        (fun lbl -> mknoloc (Longident.Lident "?temp?"), lbl,omega)
        lbl_all in
    List.iter
      (fun ((_, lbl,_) as x) ->  t.(lbl.lbl_pos) <- x)
      lbls ;
    Array.to_list t
|  _ -> fatal_error "Parmatch.all_record_args"


(* Build argument list when p2 >= p1, where p1 is a simple pattern *)
let rec simple_match_args p1 p2 = match p2.pat_desc with
| Tpat_alias (p2,_,_) -> simple_match_args p1 p2
| Tpat_construct(_, cstr, args) -> args
| Tpat_variant(lab, Some arg, _) -> [arg]
| Tpat_tuple(args)  -> args
| Tpat_record(args,_) ->  extract_fields (record_arg p1) args
| Tpat_array(args) -> args
| Tpat_lazy arg -> [arg]
| (Tpat_any | Tpat_var(_)) ->
    begin match p1.pat_desc with
      Tpat_construct(_, _,args) -> omega_list args
    | Tpat_variant(_, Some _, _) -> [omega]
    | Tpat_tuple(args) -> omega_list args
    | Tpat_record(args,_) ->  omega_list args
    | Tpat_array(args) ->  omega_list args
    | Tpat_lazy _ -> [omega]
    | _ -> []
    end
| _ -> []

(*
  Normalize a pattern ->
   all arguments are omega (simple pattern) and no more variables
*)

let rec normalize_pat q = match q.pat_desc with
  | Tpat_any | Tpat_constant _ -> q
  | Tpat_var _ -> make_pat Tpat_any q.pat_type q.pat_env
  | Tpat_alias (p,_,_) -> normalize_pat p
  | Tpat_tuple (args) ->
      make_pat (Tpat_tuple (omega_list args)) q.pat_type q.pat_env
  | Tpat_construct  (lid, c,args) ->
      make_pat
        (Tpat_construct (lid, c,omega_list args))
        q.pat_type q.pat_env
  | Tpat_variant (l, arg, row) ->
      make_pat (Tpat_variant (l, may_map (fun _ -> omega) arg, row))
        q.pat_type q.pat_env
  | Tpat_array (args) ->
      make_pat (Tpat_array (omega_list args))  q.pat_type q.pat_env
  | Tpat_record (largs, closed) ->
      make_pat
        (Tpat_record (List.map (fun (lid,lbl,_) ->
                                 lid, lbl,omega) largs, closed))
        q.pat_type q.pat_env
  | Tpat_lazy _ ->
      make_pat (Tpat_lazy omega) q.pat_type q.pat_env
  | Tpat_or _ -> fatal_error "Parmatch.normalize_pat"

(*
  Build normalized (cf. supra) discriminating pattern,
  in the non-data type case
*)

let discr_pat q pss =

  let rec acc_pat acc pss = match pss with
    ({pat_desc = Tpat_alias (p,_,_)}::ps)::pss ->
        acc_pat acc ((p::ps)::pss)
  | ({pat_desc = Tpat_or (p1,p2,_)}::ps)::pss ->
        acc_pat acc ((p1::ps)::(p2::ps)::pss)
  | ({pat_desc = (Tpat_any | Tpat_var _)}::_)::pss ->
        acc_pat acc pss
  | (({pat_desc = Tpat_tuple _} as p)::_)::_ -> normalize_pat p
  | (({pat_desc = Tpat_lazy _} as p)::_)::_ -> normalize_pat p
  | (({pat_desc = Tpat_record (largs,closed)} as p)::_)::pss ->
      let new_omegas =
        List.fold_right
          (fun (lid, lbl,_) r ->
            try
              let _ = get_field lbl.lbl_pos r in
              r
            with Not_found ->
              (lid, lbl,omega)::r)
          largs (record_arg acc)
      in
      acc_pat
        (make_pat (Tpat_record (new_omegas, closed)) p.pat_type p.pat_env)
        pss
  | _ -> acc in

  match normalize_pat q with
  | {pat_desc= (Tpat_any | Tpat_record _)} as q -> acc_pat q pss
  | q -> q

(*
   In case a matching value is found, set actual arguments
   of the matching pattern.
*)

let rec read_args xs r = match xs,r with
| [],_ -> [],r
| _::xs, arg::rest ->
   let args,rest = read_args xs rest in
   arg::args,rest
| _,_ ->
    fatal_error "Parmatch.read_args"

let do_set_args erase_mutable q r = match q with
| {pat_desc = Tpat_tuple omegas} ->
    let args,rest = read_args omegas r in
    make_pat (Tpat_tuple args) q.pat_type q.pat_env::rest
| {pat_desc = Tpat_record (omegas,closed)} ->
    let args,rest = read_args omegas r in
    make_pat
      (Tpat_record
         (List.map2 (fun (lid, lbl,_) arg ->
           if
             erase_mutable &&
             (match lbl.lbl_mut with
             | Mutable -> true | Immutable -> false)
           then
             lid, lbl, omega
           else
             lid, lbl, arg)
            omegas args, closed))
      q.pat_type q.pat_env::
    rest
| {pat_desc = Tpat_construct (lid, c,omegas)} ->
    let args,rest = read_args omegas r in
    make_pat
      (Tpat_construct (lid, c,args))
      q.pat_type q.pat_env::
    rest
| {pat_desc = Tpat_variant (l, omega, row)} ->
    let arg, rest =
      match omega, r with
        Some _, a::r -> Some a, r
      | None, r -> None, r
      | _ -> assert false
    in
    make_pat
      (Tpat_variant (l, arg, row)) q.pat_type q.pat_env::
    rest
| {pat_desc = Tpat_lazy omega} ->
    begin match r with
      arg::rest ->
        make_pat (Tpat_lazy arg) q.pat_type q.pat_env::rest
    | _ -> fatal_error "Parmatch.do_set_args (lazy)"
    end
| {pat_desc = Tpat_array omegas} ->
    let args,rest = read_args omegas r in
    make_pat
      (Tpat_array args) q.pat_type q.pat_env::
    rest
| {pat_desc=Tpat_constant _|Tpat_any} ->
    q::r (* case any is used in matching.ml *)
| _ -> fatal_error "Parmatch.set_args"

let set_args q r = do_set_args false q r
and set_args_erase_mutable q r = do_set_args true q r

(* filter pss acording to pattern q *)
let filter_one q pss =
  let rec filter_rec = function
      ({pat_desc = Tpat_alias(p,_,_)}::ps)::pss ->
        filter_rec ((p::ps)::pss)
    | ({pat_desc = Tpat_or(p1,p2,_)}::ps)::pss ->
        filter_rec ((p1::ps)::(p2::ps)::pss)
    | (p::ps)::pss ->
        if simple_match q p
        then (simple_match_args q p @ ps) :: filter_rec pss
        else filter_rec pss
    | _ -> [] in
  filter_rec pss

(*
  Filter pss in the ``extra case''. This applies :
  - According to an extra constructor (datatype case, non-complete signature).
  - Acordinng to anything (all-variables case).
*)
let filter_extra pss =
  let rec filter_rec = function
      ({pat_desc = Tpat_alias(p,_,_)}::ps)::pss ->
        filter_rec ((p::ps)::pss)
    | ({pat_desc = Tpat_or(p1,p2,_)}::ps)::pss ->
        filter_rec ((p1::ps)::(p2::ps)::pss)
    | ({pat_desc = (Tpat_any | Tpat_var(_))} :: qs) :: pss ->
        qs :: filter_rec pss
    | _::pss  -> filter_rec pss
    | [] -> [] in
  filter_rec pss

(*
  Pattern p0 is the discriminating pattern,
  returns [(q0,pss0) ; ... ; (qn,pssn)]
  where the qi's are simple patterns and the pssi's are
  matched matrices.

  NOTES
   * (qi,[]) is impossible.
   * In the case when matching is useless (all-variable case),
     returns []
*)

let filter_all pat0 pss =

  let rec insert q qs env =
    match env with
      [] ->
        let q0 = normalize_pat q in
        [q0, [simple_match_args q0 q @ qs]]
    | ((q0,pss) as c)::env ->
        if simple_match q0 q
        then (q0, ((simple_match_args q0 q @ qs) :: pss)) :: env
        else c :: insert q qs env in

  let rec filter_rec env = function
    ({pat_desc = Tpat_alias(p,_,_)}::ps)::pss ->
      filter_rec env ((p::ps)::pss)
  | ({pat_desc = Tpat_or(p1,p2,_)}::ps)::pss ->
      filter_rec env ((p1::ps)::(p2::ps)::pss)
  | ({pat_desc = (Tpat_any | Tpat_var(_))}::_)::pss ->
      filter_rec env pss
  | (p::ps)::pss ->
      filter_rec (insert p ps env) pss
  | _ -> env

  and filter_omega env = function
    ({pat_desc = Tpat_alias(p,_,_)}::ps)::pss ->
      filter_omega env ((p::ps)::pss)
  | ({pat_desc = Tpat_or(p1,p2,_)}::ps)::pss ->
      filter_omega env ((p1::ps)::(p2::ps)::pss)
  | ({pat_desc = (Tpat_any | Tpat_var(_))}::ps)::pss ->
      filter_omega
        (List.map (fun (q,qss) -> (q,(simple_match_args q omega @ ps) :: qss))
           env)
        pss
  | _::pss -> filter_omega env pss
  | [] -> env in

  filter_omega
    (filter_rec
      (match pat0.pat_desc with
        (Tpat_record(_) | Tpat_tuple(_) | Tpat_lazy(_)) -> [pat0,[]]
      | _ -> [])
      pss)
    pss

(* Variant related functions *)

let rec set_last a = function
    [] -> []
  | [_] -> [a]
  | x::l -> x :: set_last a l

(* mark constructor lines for failure when they are incomplete *)
let rec mark_partial = function
    ({pat_desc = Tpat_alias(p,_,_)}::ps)::pss ->
      mark_partial ((p::ps)::pss)
  | ({pat_desc = Tpat_or(p1,p2,_)}::ps)::pss ->
      mark_partial ((p1::ps)::(p2::ps)::pss)
  | ({pat_desc = (Tpat_any | Tpat_var(_))} :: _ as ps) :: pss ->
      ps :: mark_partial pss
  | ps::pss  ->
      (set_last zero ps) :: mark_partial pss
  | [] -> []

let close_variant env row =
  let row = Btype.row_repr row in
  let nm =
    List.fold_left
      (fun nm (tag,f) ->
        match Btype.row_field_repr f with
        | Reither(_, _, false, e) ->
            (* m=false means that this tag is not explicitly matched *)
            Btype.set_row_field e Rabsent;
            None
        | Rabsent | Reither (_, _, true, _) | Rpresent _ -> nm)
      row.row_name row.row_fields in
  if not row.row_closed || nm != row.row_name then begin
    (* this unification cannot fail *)
    Ctype.unify env row.row_more
      (Btype.newgenty
         (Tvariant {row with row_fields = []; row_more = Btype.newgenvar();
                    row_closed = true; row_name = nm}))
  end

let row_of_pat pat =
  match Ctype.expand_head pat.pat_env pat.pat_type with
    {desc = Tvariant row} -> Btype.row_repr row
  | _ -> assert false

(*
  Check whether the first column of env makes up a complete signature or
  not.
*)

let generalized_constructor x =
  match x with
    ({pat_desc = Tpat_construct(_,c,_);pat_env=env},_) ->
      c.cstr_generalized
  | _ -> assert false

let clean_env env =
  let rec loop =
    function
      | [] -> []
      | x :: xs ->
          if generalized_constructor x then loop xs else x :: loop xs
  in
  loop env

let full_match ignore_generalized closing env =  match env with
| ({pat_desc = Tpat_construct(_,c,_);pat_type=typ},_) :: _ ->
    if c.cstr_consts < 0 then false (* extensions *)
    else
      if ignore_generalized then
        (* remove generalized constructors;
           those cases will be handled separately *)
        let env = clean_env env in
        List.length env = c.cstr_normal
      else
        List.length env = c.cstr_consts + c.cstr_nonconsts

| ({pat_desc = Tpat_variant _} as p,_) :: _ ->
    let fields =
      List.map
        (function ({pat_desc = Tpat_variant (tag, _, _)}, _) -> tag
          | _ -> assert false)
        env
    in
    let row = row_of_pat p in
    if closing && not (Btype.row_fixed row) then
      (* closing=true, we are considering the variant as closed *)
      List.for_all
        (fun (tag,f) ->
          match Btype.row_field_repr f with
            Rabsent | Reither(_, _, false, _) -> true
          | Reither (_, _, true, _)
              (* m=true, do not discard matched tags, rather warn *)
          | Rpresent _ -> List.mem tag fields)
        row.row_fields
    else
      row.row_closed &&
      List.for_all
        (fun (tag,f) ->
          Btype.row_field_repr f = Rabsent || List.mem tag fields)
        row.row_fields
| ({pat_desc = Tpat_constant(Const_char _)},_) :: _ ->
    List.length env = 256
| ({pat_desc = Tpat_constant(_)},_) :: _ -> false
| ({pat_desc = Tpat_tuple(_)},_) :: _ -> true
| ({pat_desc = Tpat_record(_)},_) :: _ -> true
| ({pat_desc = Tpat_array(_)},_) :: _ -> false
| ({pat_desc = Tpat_lazy(_)},_) :: _ -> true
| _ -> fatal_error "Parmatch.full_match"

let full_match_gadt env = match env with
  | ({pat_desc = Tpat_construct(_,c,_);pat_type=typ},_) :: _ ->
    List.length env = c.cstr_consts + c.cstr_nonconsts
  | _ -> true

let extendable_match env = match env with
| ({pat_desc=Tpat_construct(_,{cstr_tag=(Cstr_constant _|Cstr_block _)},_)}
     as p,_) :: _ ->
    let path = get_type_path p.pat_type p.pat_env in
    not
      (Path.same path Predef.path_bool ||
      Path.same path Predef.path_list ||
      Path.same path Predef.path_option)
| _ -> false


let should_extend ext env = match ext with
| None -> false
| Some ext -> match env with
  | ({pat_desc =
      Tpat_construct(_, {cstr_tag=(Cstr_constant _|Cstr_block _)},_)}
     as p, _) :: _ ->
      let path = get_type_path p.pat_type p.pat_env in
      Path.same path ext
  | _ -> false

(* complement constructor tags *)
let complete_tags nconsts nconstrs tags =
  let seen_const = Array.make nconsts false
  and seen_constr = Array.make nconstrs false in
  List.iter
    (function
      | Cstr_constant i -> seen_const.(i) <- true
      | Cstr_block i -> seen_constr.(i) <- true
      | _  -> assert false)
    tags ;
  let r = ref [] in
  for i = 0 to nconsts-1 do
    if not seen_const.(i) then
      r := Cstr_constant i :: !r
  done ;
  for i = 0 to nconstrs-1 do
    if not seen_constr.(i) then
      r := Cstr_block i :: !r
  done ;
  !r

(* build a pattern from a constructor list *)
let pat_of_constr ex_pat cstr =
 {ex_pat with pat_desc =
  Tpat_construct (mknoloc (Longident.Lident "?pat_of_constr?"),
                  cstr,omegas cstr.cstr_arity)}

let rec pat_of_constrs ex_pat = function
| [] -> raise Empty
| [cstr] -> pat_of_constr ex_pat cstr
| cstr::rem ->
    {ex_pat with
    pat_desc=
      Tpat_or
        (pat_of_constr ex_pat cstr,
         pat_of_constrs ex_pat rem, None)}

let rec get_variant_constructors env ty =
  match (Ctype.repr ty).desc with
  | Tconstr (path,_,_) -> begin
      match Env.find_type path env with
      | {type_kind=Type_variant _} ->
          fst (Env.find_type_descrs path env)
      | {type_manifest = Some _} ->
          get_variant_constructors env
            (Ctype.expand_head_once env (clean_copy ty))
      | _ -> fatal_error "Parmatch.get_variant_constructors"
    end
  | _ -> fatal_error "Parmatch.get_variant_constructors"

let rec map_filter f  =
  function
      [] -> []
    | x :: xs ->
        match f x with
        | None -> map_filter f xs
        | Some y -> y :: map_filter f xs

(* Sends back a pattern that complements constructor tags all_tag *)
let complete_constrs p all_tags =
  match p.pat_desc with
  | Tpat_construct (_,c,_) ->
      let not_tags = complete_tags c.cstr_consts c.cstr_nonconsts all_tags in
      let constrs = get_variant_constructors p.pat_env c.cstr_res in
        map_filter
          (fun cnstr ->
            if List.exists (fun tag -> Types.equal_tag tag cnstr.cstr_tag) not_tags then Some cnstr else None)
          constrs
  | _ -> fatal_error "Parmatch.complete_constr"


(* Auxiliary for build_other *)

let build_other_constant proj make first next p env =
  let all = List.map (fun (p, _) -> proj p.pat_desc) env in
  let rec try_const i =
    if List.mem i all
    then try_const (next i)
    else make_pat (make i) p.pat_type p.pat_env
  in try_const first

(*
  Builds a pattern that is incompatible with all patterns in
  in the first column of env
*)

let build_other ext env =  match env with
| ({pat_desc = Tpat_construct (lid,
      ({cstr_tag=Cstr_extension _} as c),_)},_) :: _ ->
    let c = {c with cstr_name = "*extension*"} in
      make_pat (Tpat_construct(lid, c, [])) Ctype.none Env.empty
| ({pat_desc = Tpat_construct (_, _,_)} as p,_) :: _ ->
    begin match ext with
    | Some ext when Path.same ext (get_type_path p.pat_type p.pat_env) ->
        extra_pat
    | _ ->
        let get_tag = function
          | {pat_desc = Tpat_construct (_,c,_)} -> c.cstr_tag
          | _ -> fatal_error "Parmatch.get_tag" in
        let all_tags =  List.map (fun (p,_) -> get_tag p) env in
        pat_of_constrs p (complete_constrs p all_tags)
    end
| ({pat_desc = Tpat_variant (_,_,r)} as p,_) :: _ ->
    let tags =
      List.map
        (function ({pat_desc = Tpat_variant (tag, _, _)}, _) -> tag
                | _ -> assert false)
        env
    in
    let row = row_of_pat p in
    let make_other_pat tag const =
      let arg = if const then None else Some omega in
      make_pat (Tpat_variant(tag, arg, r)) p.pat_type p.pat_env in
    begin match
      List.fold_left
        (fun others (tag,f) ->
          if List.mem tag tags then others else
          match Btype.row_field_repr f with
            Rabsent (* | Reither _ *) -> others
          (* This one is called after erasing pattern info *)
          | Reither (c, _, _, _) -> make_other_pat tag c :: others
          | Rpresent arg -> make_other_pat tag (arg = None) :: others)
        [] row.row_fields
    with
      [] ->
        make_other_pat "AnyExtraTag" true
    | pat::other_pats ->
        List.fold_left
          (fun p_res pat ->
            make_pat (Tpat_or (pat, p_res, None)) p.pat_type p.pat_env)
          pat other_pats
    end
| ({pat_desc = Tpat_constant(Const_char _)} as p,_) :: _ ->
    let all_chars =
      List.map
        (fun (p,_) -> match p.pat_desc with
        | Tpat_constant (Const_char c) -> c
        | _ -> assert false)
        env in

    let rec find_other i imax =
      if i > imax then raise Not_found
      else
        let ci = Char.chr i in
        if List.mem ci all_chars then
          find_other (i+1) imax
        else
          make_pat (Tpat_constant (Const_char ci)) p.pat_type p.pat_env in
    let rec try_chars = function
      | [] -> omega
      | (c1,c2) :: rest ->
          try
            find_other (Char.code c1) (Char.code c2)
          with
          | Not_found -> try_chars rest in

    try_chars
      [ 'a', 'z' ; 'A', 'Z' ; '0', '9' ;
        ' ', '~' ; Char.chr 0 , Char.chr 255]

| ({pat_desc=(Tpat_constant (Const_int _))} as p,_) :: _ ->
    build_other_constant
      (function Tpat_constant(Const_int i) -> i | _ -> assert false)
      (function i -> Tpat_constant(Const_int i))
      0 succ p env
| ({pat_desc=(Tpat_constant (Const_int32 _))} as p,_) :: _ ->
    build_other_constant
      (function Tpat_constant(Const_int32 i) -> i | _ -> assert false)
      (function i -> Tpat_constant(Const_int32 i))
      0l Int32.succ p env
| ({pat_desc=(Tpat_constant (Const_int64 _))} as p,_) :: _ ->
    build_other_constant
      (function Tpat_constant(Const_int64 i) -> i | _ -> assert false)
      (function i -> Tpat_constant(Const_int64 i))
      0L Int64.succ p env
| ({pat_desc=(Tpat_constant (Const_nativeint _))} as p,_) :: _ ->
    build_other_constant
      (function Tpat_constant(Const_nativeint i) -> i | _ -> assert false)
      (function i -> Tpat_constant(Const_nativeint i))
      0n Nativeint.succ p env
| ({pat_desc=(Tpat_constant (Const_string _))} as p,_) :: _ ->
    build_other_constant
      (function Tpat_constant(Const_string (s, _)) -> String.length s
              | _ -> assert false)
      (function i -> Tpat_constant(Const_string(String.make i '*', None)))
      0 succ p env
| ({pat_desc=(Tpat_constant (Const_float _))} as p,_) :: _ ->
    build_other_constant
      (function Tpat_constant(Const_float f) -> float_of_string f
              | _ -> assert false)
      (function f -> Tpat_constant(Const_float (string_of_float f)))
      0.0 (fun f -> f +. 1.0) p env

| ({pat_desc = Tpat_array args} as p,_)::_ ->
    let all_lengths =
      List.map
        (fun (p,_) -> match p.pat_desc with
        | Tpat_array args -> List.length args
        | _ -> assert false)
        env in
    let rec try_arrays l =
      if List.mem l all_lengths then try_arrays (l+1)
      else
        make_pat
          (Tpat_array (omegas l))
          p.pat_type p.pat_env in
    try_arrays 0
| [] -> omega
| _ -> omega

let build_other_gadt ext env =
  match env with
    | ({pat_desc = Tpat_construct _} as p,_) :: _ ->
        let get_tag = function
          | {pat_desc = Tpat_construct (_,c,_)} -> c.cstr_tag
          | _ -> fatal_error "Parmatch.get_tag" in
        let all_tags =  List.map (fun (p,_) -> get_tag p) env in
        let cnstrs  = complete_constrs p all_tags in
        let pats = List.map (pat_of_constr p) cnstrs in
        (* List.iter (Format.eprintf "%a@." top_pretty) pats;
           Format.eprintf "@.@."; *)
        pats
    | _ -> assert false

(*
  Core function :
  Is the last row of pattern matrix pss + qs satisfiable ?
  That is :
    Does there exists at least one value vector, es such that :
     1- for all ps in pss ps # es (ps and es are not compatible)
     2- qs <= es                  (es matches qs)
*)

let rec has_instance p = match p.pat_desc with
  | Tpat_variant (l,_,r) when is_absent l r -> false
  | Tpat_any | Tpat_var _ | Tpat_constant _ | Tpat_variant (_,None,_) -> true
  | Tpat_alias (p,_,_) | Tpat_variant (_,Some p,_) -> has_instance p
  | Tpat_or (p1,p2,_) -> has_instance p1 || has_instance p2
  | Tpat_construct (_,_,ps) | Tpat_tuple ps | Tpat_array ps ->
      has_instances ps
  | Tpat_record (lps,_) -> has_instances (List.map (fun (_,_,x) -> x) lps)
  | Tpat_lazy p
    -> has_instance p


and has_instances = function
  | [] -> true
  | q::rem -> has_instance q && has_instances rem

let rec satisfiable pss qs = match pss with
| [] -> has_instances qs
| _  ->
    match qs with
    | [] -> false
    | {pat_desc = Tpat_or(q1,q2,_)}::qs ->
        satisfiable pss (q1::qs) || satisfiable pss (q2::qs)
    | {pat_desc = Tpat_alias(q,_,_)}::qs ->
          satisfiable pss (q::qs)
    | {pat_desc = (Tpat_any | Tpat_var(_))}::qs ->
        let q0 = discr_pat omega pss in
        begin match filter_all q0 pss with
          (* first column of pss is made of variables only *)
        | [] -> satisfiable (filter_extra pss) qs
        | constrs  ->
            if full_match false false constrs then
              List.exists
                (fun (p,pss) ->
                  not (is_absent_pat p) &&
                  satisfiable pss (simple_match_args p omega @ qs))
                constrs
            else
              satisfiable (filter_extra pss) qs
        end
    | {pat_desc=Tpat_variant (l,_,r)}::_ when is_absent l r -> false
    | q::qs ->
        let q0 = discr_pat q pss in
        satisfiable (filter_one q0 pss) (simple_match_args q0 q @ qs)

(*
  Now another satisfiable function that additionally
  supplies an example of a matching value.

  This function should be called for exhaustiveness check only.
*)

type 'a result =
  | Rnone           (* No matching value *)
  | Rsome of 'a     (* This matching value *)

let rec orify_many =
  let orify x y =
    make_pat (Tpat_or (x, y, None)) x.pat_type x.pat_env
  in
  function
    | [] -> assert false
    | [x] -> x
    | x :: xs -> orify x (orify_many xs)

let rec try_many  f = function
  | [] -> Rnone
  | (p,pss)::rest ->
      match f (p,pss) with
      | Rnone -> try_many  f rest
      | r -> r

let rappend r1 r2 =
  match r1, r2 with
  | Rnone, _ -> r2
  | _, Rnone -> r1
  | Rsome l1, Rsome l2 -> Rsome (l1 @ l2)

let rec try_many_gadt  f = function
  | [] -> Rnone
  | (p,pss)::rest ->
      rappend (f (p, pss)) (try_many_gadt f rest)

let rec exhaust ext pss n = match pss with
| []    ->  Rsome (omegas n)
| []::_ ->  Rnone
| pss   ->
    let q0 = discr_pat omega pss in
    begin match filter_all q0 pss with
          (* first column of pss is made of variables only *)
    | [] ->
        begin match exhaust ext (filter_extra pss) (n-1) with
        | Rsome r -> Rsome (q0::r)
        | r -> r
      end
    | constrs ->
        let try_non_omega (p,pss) =
          if is_absent_pat p then
            Rnone
          else
            match
              exhaust
                ext pss (List.length (simple_match_args p omega) + n - 1)
            with
            | Rsome r -> Rsome (set_args p r)
            | r       -> r in
        if
          full_match true false constrs && not (should_extend ext constrs)
        then
          try_many try_non_omega constrs
        else
          (*
             D = filter_extra pss is the default matrix
             as it is included in pss, one can avoid
             recursive calls on specialized matrices,
             Essentially :
             * D exhaustive => pss exhaustive
             * D non-exhaustive => we have a non-filtered value
          *)
          let r =  exhaust ext (filter_extra pss) (n-1) in
          match r with
          | Rnone -> Rnone
          | Rsome r ->
              try
                Rsome (build_other ext constrs::r)
              with
      (* cannot occur, since constructors don't make a full signature *)
              | Empty -> fatal_error "Parmatch.exhaust"
    end

let combinations f lst lst' =
  let rec iter2 x =
    function
        [] -> []
      | y :: ys ->
          f x y :: iter2 x ys
  in
  let rec iter =
    function
        [] -> []
      | x :: xs -> iter2 x lst' @ iter xs
  in
  iter lst

(*
let print_pat pat =
  let rec string_of_pat pat =
    match pat.pat_desc with
        Tpat_var _ -> "v"
      | Tpat_any -> "_"
      | Tpat_alias (p, x) -> Printf.sprintf "(%s) as ?"  (string_of_pat p)
      | Tpat_constant n -> "0"
      | Tpat_construct (_, lid, _) ->
        Printf.sprintf "%s" (String.concat "." (Longident.flatten lid.txt))
      | Tpat_lazy p ->
        Printf.sprintf "(lazy %s)" (string_of_pat p)
      | Tpat_or (p1,p2,_) ->
        Printf.sprintf "(%s | %s)" (string_of_pat p1) (string_of_pat p2)
      | Tpat_tuple list ->
        Printf.sprintf "(%s)" (String.concat "," (List.map string_of_pat list))
      | Tpat_variant (_, _, _) -> "variant"
      | Tpat_record (_, _) -> "record"
      | Tpat_array _ -> "array"
  in
  Printf.fprintf stderr "PAT[%s]\n%!" (string_of_pat pat)
*)

(* strictly more powerful than exhaust; however, exhaust
   was kept for backwards compatibility *)
let rec exhaust_gadt (ext:Path.t option) pss n = match pss with
| []    ->  Rsome [omegas n]
| []::_ ->  Rnone
| pss   ->
    let q0 = discr_pat omega pss in
    begin match filter_all q0 pss with
          (* first column of pss is made of variables only *)
    | [] ->
        begin match exhaust_gadt ext (filter_extra pss) (n-1) with
        | Rsome r -> Rsome (List.map (fun row -> q0::row) r)
        | r -> r
      end
    | constrs ->
        let try_non_omega (p,pss) =
          if is_absent_pat p then
            Rnone
          else
            match
              exhaust_gadt
                ext pss (List.length (simple_match_args p omega) + n - 1)
            with
            | Rsome r -> Rsome (List.map (fun row ->  (set_args p row)) r)
            | r       -> r in
        let before = try_many_gadt try_non_omega constrs in
        if
          full_match_gadt constrs && not (should_extend ext constrs)
        then
          before
        else
          (*
            D = filter_extra pss is the default matrix
            as it is included in pss, one can avoid
            recursive calls on specialized matrices,
            Essentially :
           * D exhaustive => pss exhaustive
           * D non-exhaustive => we have a non-filtered value
           *)
          let r =  exhaust_gadt ext (filter_extra pss) (n-1) in
          match r with
          | Rnone -> before
          | Rsome r ->
              try
                let missing_trailing = build_other_gadt ext constrs in
                let dug =
                  combinations
                    (fun head tail -> head :: tail)
                    missing_trailing
                    r
                in
                match before with
                | Rnone -> Rsome dug
                | Rsome x -> Rsome (x @ dug)
              with
      (* cannot occur, since constructors don't make a full signature *)
              | Empty -> fatal_error "Parmatch.exhaust"
    end

let exhaust_gadt ext pss n =
  let ret = exhaust_gadt ext pss n in
  match ret with
    Rnone -> Rnone
  | Rsome lst ->
      (* The following line is needed to compile stdlib/printf.ml *)
      if lst = [] then Rsome (omegas n) else
      let singletons =
        List.map
          (function
              [x] -> x
            | _ -> assert false)
          lst
      in
      Rsome [orify_many singletons]

(*
   Another exhaustiveness check, enforcing variant typing.
   Note that it does not check exact exhaustiveness, but whether a
   matching could be made exhaustive by closing all variant types.
   When this is true of all other columns, the current column is left
   open (even if it means that the whole matching is not exhaustive as
   a result).
   When this is false for the matrix minus the current column, and the
   current column is composed of variant tags, we close the variant
   (even if it doesn't help in making the matching exhaustive).
*)

let rec pressure_variants tdefs = function
  | []    -> false
  | []::_ -> true
  | pss   ->
      let q0 = discr_pat omega pss in
      begin match filter_all q0 pss with
        [] -> pressure_variants tdefs (filter_extra pss)
      | constrs ->
          let rec try_non_omega = function
              (p,pss) :: rem ->
                let ok = pressure_variants tdefs pss in
                try_non_omega rem && ok
            | [] -> true
          in
          if full_match true (tdefs=None) constrs then
            try_non_omega constrs
          else if tdefs = None then
            pressure_variants None (filter_extra pss)
          else
            let full = full_match true true constrs in
            let ok =
              if full then try_non_omega constrs
              else try_non_omega (filter_all q0 (mark_partial pss))
            in
            begin match constrs, tdefs with
              ({pat_desc=Tpat_variant _} as p,_):: _, Some env ->
                let row = row_of_pat p in
                if Btype.row_fixed row
                || pressure_variants None (filter_extra pss) then ()
                else close_variant env row
            | _ -> ()
            end;
            ok
      end


(* Yet another satisfiable fonction *)

(*
   This time every_satisfiable pss qs checks the
   utility of every expansion of qs.
   Expansion means expansion of or-patterns inside qs
*)

type answer =
  | Used                                (* Useful pattern *)
  | Unused                              (* Useless pattern *)
  | Upartial of Typedtree.pattern list  (* Mixed, with list of useless ones *)



(* this row type enable column processing inside the matrix
    - left  ->  elements not to be processed,
    - right ->  elements to be processed
*)
type 'a row = {no_ors : 'a list ; ors : 'a list ; active : 'a list}


let pretty_row {ors=ors ; no_ors=no_ors; active=active} =
  pretty_line ors ; prerr_string " *" ;
  pretty_line no_ors ; prerr_string " *" ;
  pretty_line active

let pretty_rows rs =
  prerr_endline "begin matrix" ;
  List.iter
    (fun r ->
      pretty_row r ;
      prerr_endline "")
    rs ;
  prerr_endline "end matrix"

(* Initial build *)
let make_row ps = {ors=[] ; no_ors=[]; active=ps}

let make_rows pss = List.map make_row pss


(* Useful to detect and expand  or pats inside as pats *)
let rec unalias p = match p.pat_desc with
| Tpat_alias (p,_,_) -> unalias p
| _ -> p


let is_var p = match (unalias p).pat_desc with
| Tpat_any|Tpat_var _ -> true
| _                   -> false

let is_var_column rs =
  List.for_all
    (fun r -> match r.active with
    | p::_ -> is_var p
    | []   -> assert false)
    rs

(* Standard or-args for left-to-right matching *)
let rec or_args p = match p.pat_desc with
| Tpat_or (p1,p2,_) -> p1,p2
| Tpat_alias (p,_,_)  -> or_args p
| _                 -> assert false

(* Just remove current column *)
let remove r = match r.active with
| _::rem -> {r with active=rem}
| []     -> assert false

let remove_column rs = List.map remove rs

(* Current column has been processed *)
let push_no_or r = match r.active with
| p::rem -> { r with no_ors = p::r.no_ors ; active=rem}
| [] -> assert false

let push_or r = match r.active with
| p::rem -> { r with ors = p::r.ors ; active=rem}
| [] -> assert false

let push_or_column rs = List.map push_or rs
and push_no_or_column rs = List.map push_no_or rs

(* Those are adaptations of the previous homonymous functions that
   work on the current column, instead of the first column
*)

let discr_pat q rs =
  discr_pat q (List.map (fun r -> r.active) rs)

let filter_one q rs =
  let rec filter_rec rs = match rs with
  | [] -> []
  | r::rem ->
      match r.active with
      | [] -> assert false
      | {pat_desc = Tpat_alias(p,_,_)}::ps ->
          filter_rec ({r with active = p::ps}::rem)
      | {pat_desc = Tpat_or(p1,p2,_)}::ps ->
          filter_rec
            ({r with active = p1::ps}::
             {r with active = p2::ps}::
             rem)
      | p::ps ->
          if simple_match q p then
            {r with active=simple_match_args q p @ ps} :: filter_rec rem
          else
            filter_rec rem in
  filter_rec rs


(* Back to normal matrices *)
let make_vector r = r.no_ors

let make_matrix rs = List.map make_vector rs


(* Standard union on answers *)
let union_res r1 r2 = match r1, r2 with
| (Unused,_)
| (_, Unused) -> Unused
| Used,_    -> r2
| _, Used   -> r1
| Upartial u1, Upartial u2 -> Upartial (u1@u2)

(* propose or pats for expansion *)
let extract_elements qs =
  let rec do_rec seen = function
    | [] -> []
    | q::rem ->
        {no_ors= List.rev_append seen rem @ qs.no_ors ;
        ors=[] ;
        active = [q]}::
        do_rec (q::seen) rem in
  do_rec [] qs.ors

(* idem for matrices *)
let transpose rs = match rs with
| [] -> assert false
| r::rem ->
    let i = List.map (fun x -> [x]) r in
    List.fold_left
      (List.map2 (fun r x -> x::r))
      i rem

let extract_columns pss qs = match pss with
| [] -> List.map (fun _ -> []) qs.ors
| _  ->
  let rows = List.map extract_elements pss in
  transpose rows

(* Core function
   The idea is to first look for or patterns (recursive case), then
   check or-patterns argument usefulness (terminal case)
*)

let rec every_satisfiables pss qs = match qs.active with
| []     ->
    (* qs is now partitionned,  check usefulness *)
    begin match qs.ors with
    | [] -> (* no or-patterns *)
        if satisfiable (make_matrix pss) (make_vector qs) then
          Used
        else
          Unused
    | _  -> (* n or-patterns -> 2n expansions *)
        List.fold_right2
          (fun pss qs r -> match r with
          | Unused -> Unused
          | _ ->
              match qs.active with
              | [q] ->
                  let q1,q2 = or_args q in
                  let r_loc = every_both pss qs q1 q2 in
                  union_res r r_loc
              | _   -> assert false)
          (extract_columns pss qs) (extract_elements qs)
          Used
    end
| q::rem ->
    let uq = unalias q in
    begin match uq.pat_desc with
    | Tpat_any | Tpat_var _ ->
        if is_var_column pss then
(* forget about ``all-variable''  columns now *)
          every_satisfiables (remove_column pss) (remove qs)
        else
(* otherwise this is direct food for satisfiable *)
          every_satisfiables (push_no_or_column pss) (push_no_or qs)
    | Tpat_or (q1,q2,_) ->
        if
          q1.pat_loc.Location.loc_ghost &&
          q2.pat_loc.Location.loc_ghost
        then
(* syntactically generated or-pats should not be expanded *)
          every_satisfiables (push_no_or_column pss) (push_no_or qs)
        else
(* this is a real or-pattern *)
          every_satisfiables (push_or_column pss) (push_or qs)
    | Tpat_variant (l,_,r) when is_absent l r -> (* Ah Jacques... *)
        Unused
    | _ ->
(* standard case, filter matrix *)
        let q0 = discr_pat q pss in
        every_satisfiables
          (filter_one q0 pss)
          {qs with active=simple_match_args q0 q @ rem}
    end

(*
  This function ``every_both'' performs the usefulness check
  of or-pat q1|q2.
  The trick is to call every_satisfied twice with
  current active columns restricted to q1 and q2,
  That way,
  - others orpats in qs.ors will not get expanded.
  - all matching work performed on qs.no_ors is not performed again.
  *)
and every_both pss qs q1 q2 =
  let qs1 = {qs with active=[q1]}
  and qs2 =  {qs with active=[q2]} in
  let r1 = every_satisfiables pss qs1
  and r2 =  every_satisfiables (if compat q1 q2 then qs1::pss else pss) qs2 in
  match r1 with
  | Unused ->
      begin match r2 with
      | Unused -> Unused
      | Used   -> Upartial [q1]
      | Upartial u2 -> Upartial (q1::u2)
      end
  | Used ->
      begin match r2 with
      | Unused -> Upartial [q2]
      | _      -> r2
      end
  | Upartial u1 ->
      begin match r2 with
      | Unused -> Upartial (u1@[q2])
      | Used   -> r1
      | Upartial u2 -> Upartial (u1 @ u2)
      end




(* le_pat p q  means, forall V,  V matches q implies V matches p *)
let rec le_pat p q =
  match (p.pat_desc, q.pat_desc) with
  | (Tpat_var _|Tpat_any),_ -> true
  | Tpat_alias(p,_,_), _ -> le_pat p q
  | _, Tpat_alias(q,_,_) -> le_pat p q
  | Tpat_constant(c1), Tpat_constant(c2) -> const_compare c1 c2 = 0
  | Tpat_construct(_,c1,ps), Tpat_construct(_,c2,qs) ->
      Types.equal_tag c1.cstr_tag  c2.cstr_tag && le_pats ps qs
  | Tpat_variant(l1,Some p1,_), Tpat_variant(l2,Some p2,_) ->
      (l1 = l2 && le_pat p1 p2)
  | Tpat_variant(l1,None,r1), Tpat_variant(l2,None,_) ->
      l1 = l2
  | Tpat_variant(_,_,_), Tpat_variant(_,_,_) -> false
  | Tpat_tuple(ps), Tpat_tuple(qs) -> le_pats ps qs
  | Tpat_lazy p, Tpat_lazy q -> le_pat p q
  | Tpat_record (l1,_), Tpat_record (l2,_) ->
      let ps,qs = records_args l1 l2 in
      le_pats ps qs
  | Tpat_array(ps), Tpat_array(qs) ->
      List.length ps = List.length qs && le_pats ps qs
(* In all other cases, enumeration is performed *)
  | _,_  -> not (satisfiable [[p]] [q])

and le_pats ps qs =
  match ps,qs with
    p::ps, q::qs -> le_pat p q && le_pats ps qs
  | _, _         -> true

let get_mins le ps =
  let rec select_rec r = function
      [] -> r
    | p::ps ->
        if List.exists (fun p0 -> le p0 p) ps
        then select_rec r ps
        else select_rec (p::r) ps in
  select_rec [] (select_rec [] ps)

(*
  lub p q is a pattern that matches all values matched by p and q
  may raise Empty, when p and q and not compatible
*)

let rec lub p q = match p.pat_desc,q.pat_desc with
| Tpat_alias (p,_,_),_      -> lub p q
| _,Tpat_alias (q,_,_)      -> lub p q
| (Tpat_any|Tpat_var _),_ -> q
| _,(Tpat_any|Tpat_var _) -> p
| Tpat_or (p1,p2,_),_     -> orlub p1 p2 q
| _,Tpat_or (q1,q2,_)     -> orlub q1 q2 p (* Thanks god, lub is commutative *)
| Tpat_constant c1, Tpat_constant c2 when const_compare c1 c2 = 0 -> p
| Tpat_tuple ps, Tpat_tuple qs ->
    let rs = lubs ps qs in
    make_pat (Tpat_tuple rs) p.pat_type p.pat_env
| Tpat_lazy p, Tpat_lazy q ->
    let r = lub p q in
    make_pat (Tpat_lazy r) p.pat_type p.pat_env
| Tpat_construct (lid, c1,ps1), Tpat_construct (_,c2,ps2)
      when  Types.equal_tag c1.cstr_tag  c2.cstr_tag  ->
        let rs = lubs ps1 ps2 in
        make_pat (Tpat_construct (lid, c1,rs))
          p.pat_type p.pat_env
| Tpat_variant(l1,Some p1,row), Tpat_variant(l2,Some p2,_)
          when  l1=l2 ->
            let r=lub p1 p2 in
            make_pat (Tpat_variant (l1,Some r,row)) p.pat_type p.pat_env
| Tpat_variant (l1,None,row), Tpat_variant(l2,None,_)
              when l1 = l2 -> p
| Tpat_record (l1,closed),Tpat_record (l2,_) ->
    let rs = record_lubs l1 l2 in
    make_pat (Tpat_record (rs, closed)) p.pat_type p.pat_env
| Tpat_array ps, Tpat_array qs
      when List.length ps = List.length qs ->
        let rs = lubs ps qs in
        make_pat (Tpat_array rs) p.pat_type p.pat_env
| _,_  ->
    raise Empty

and orlub p1 p2 q =
  try
    let r1 = lub p1 q in
    try
      {q with pat_desc=(Tpat_or (r1,lub p2 q,None))}
  with
  | Empty -> r1
with
| Empty -> lub p2 q

and record_lubs l1 l2 =
  let rec lub_rec l1 l2 = match l1,l2 with
  | [],_ -> l2
  | _,[] -> l1
  | (lid1, lbl1,p1)::rem1, (lid2, lbl2,p2)::rem2 ->
      if lbl1.lbl_pos < lbl2.lbl_pos then
        (lid1, lbl1,p1)::lub_rec rem1 l2
      else if lbl2.lbl_pos < lbl1.lbl_pos  then
        (lid2, lbl2,p2)::lub_rec l1 rem2
      else
        (lid1, lbl1,lub p1 p2)::lub_rec rem1 rem2 in
  lub_rec l1 l2

and lubs ps qs = match ps,qs with
| p::ps, q::qs -> lub p q :: lubs ps qs
| _,_ -> []


(******************************)
(* Exported variant closing   *)
(******************************)

(* Apply pressure to variants *)

let pressure_variants tdefs patl =
  let pss = List.map (fun p -> [p;omega]) patl in
  ignore (pressure_variants (Some tdefs) pss)

(*****************************)
(* Utilities for diagnostics *)
(*****************************)

(*
  Build up a working pattern matrix by forgetting
  about guarded patterns
*)

let rec initial_matrix = function
    [] -> []
  | {c_guard=Some _} :: rem -> initial_matrix rem
  | {c_guard=None; c_lhs=p} :: rem -> [p] :: initial_matrix rem

(******************************************)
(* Look for a row that matches some value *)
(******************************************)

(*
  Useful for seeing if the example of
  non-matched value can indeed be matched
  (by a guarded clause)
*)



exception NoGuard

let rec initial_all no_guard = function
  | [] ->
      if no_guard then
        raise NoGuard
      else
        []
  | {c_lhs=pat; c_guard; _} :: rem ->
      ([pat], pat.pat_loc) :: initial_all (no_guard && c_guard = None) rem


let rec do_filter_var = function
  | (_::ps,loc)::rem -> (ps,loc)::do_filter_var rem
  | _ -> []

let do_filter_one q pss =
  let rec filter_rec = function
    | ({pat_desc = Tpat_alias(p,_,_)}::ps,loc)::pss ->
        filter_rec ((p::ps,loc)::pss)
    | ({pat_desc = Tpat_or(p1,p2,_)}::ps,loc)::pss ->
        filter_rec ((p1::ps,loc)::(p2::ps,loc)::pss)
    | (p::ps,loc)::pss ->
        if simple_match q p
        then (simple_match_args q p @ ps, loc) :: filter_rec pss
        else filter_rec pss
    | _ -> [] in
  filter_rec pss

let rec do_match pss qs = match qs with
| [] ->
    begin match pss  with
    | ([],loc)::_ -> Some loc
    | _ -> None
    end
| q::qs -> match q with
  | {pat_desc = Tpat_or (q1,q2,_)} ->
      begin match do_match pss (q1::qs) with
      | None -> do_match pss (q2::qs)
      | r -> r
      end
  | {pat_desc = Tpat_any} ->
      do_match (do_filter_var pss) qs
  | _ ->
      let q0 = normalize_pat q in
      do_match (do_filter_one q0 pss) (simple_match_args q0 q @ qs)


let check_partial_all v casel =
  try
    let pss = initial_all true casel in
    do_match pss [v]
  with
  | NoGuard -> None

(************************)
(* Exhaustiveness check *)
(************************)


  let rec get_first f =
    function
      | [] -> None
      | x :: xs ->
          match f x with
          | None -> get_first f xs
          | x -> x


(* conversion from Typedtree.pattern to Parsetree.pattern list *)
module Conv = struct
  open Parsetree
  let mkpat desc = Ast_helper.Pat.mk desc

  let rec select : 'a list list -> 'a list list =
    function
      | xs :: [] -> List.map (fun y -> [y]) xs
      | (x::xs)::ys ->
          List.map
            (fun lst -> x :: lst)
            (select ys)
          @
            select (xs::ys)
      | _ -> []

  let name_counter = ref 0
  let fresh name =
    let current = !name_counter in
    name_counter := !name_counter + 1;
    "#$" ^ name ^ string_of_int current

  let conv (typed: Typedtree.pattern) :
      Parsetree.pattern list *
      (string, Types.constructor_description) Hashtbl.t *
      (string, Types.label_description) Hashtbl.t
      =
    let constrs = Hashtbl.create 0 in
    let labels = Hashtbl.create 0 in
    let rec loop pat =
      match pat.pat_desc with
        Tpat_or (a,b,_) ->
          loop a @ loop b
      | Tpat_any | Tpat_constant _ | Tpat_var _ ->
          [mkpat Ppat_any]
      | Tpat_alias (p,_,_) -> loop p
      | Tpat_tuple lst ->
          let results = select (List.map loop lst) in
          List.map
            (fun lst -> mkpat (Ppat_tuple lst))
            results
      | Tpat_construct (cstr_lid, cstr,lst) ->
          let id = fresh cstr.cstr_name in
          let lid = { cstr_lid with txt = Longident.Lident id } in
          Hashtbl.add constrs id cstr;
          let results = select (List.map loop lst) in
          begin match lst with
            [] ->
              [mkpat (Ppat_construct(lid, None))]
          | _ ->
              List.map
                (fun lst ->
                  let arg =
                    match lst with
                      [] -> assert false
                    | [x] -> Some x
                    | _ -> Some (mkpat (Ppat_tuple lst))
                  in
                  mkpat (Ppat_construct(lid, arg)))
                results
          end
      | Tpat_variant(label,p_opt,row_desc) ->
          begin match p_opt with
          | None ->
              [mkpat (Ppat_variant(label, None))]
          | Some p ->
              let results = loop p in
              List.map
                (fun p ->
                  mkpat (Ppat_variant(label, Some p)))
                results
          end
      | Tpat_record (subpatterns, _closed_flag) ->
          let pats =
            select
              (List.map (fun (_,_,x) -> loop x) subpatterns)
          in
          let label_idents =
            List.map
              (fun (_,lbl,_) ->
                let id = fresh lbl.lbl_name in
                Hashtbl.add labels id lbl;
                Longident.Lident id)
              subpatterns
          in
          List.map
            (fun lst ->
              let lst = List.map2 (fun lid pat ->
                (mknoloc lid, pat)
              )  label_idents lst in
              mkpat (Ppat_record (lst, Open)))
            pats
      | Tpat_array lst ->
          let results = select (List.map loop lst) in
          List.map (fun lst -> mkpat (Ppat_array lst)) results
      | Tpat_lazy p ->
          let results = loop p in
          List.map (fun p -> mkpat (Ppat_lazy p)) results
    in
    let ps = loop typed in
    (ps, constrs, labels)
end


let do_check_partial ?pred exhaust loc casel pss = match pss with
| [] ->
        (*
          This can occur
          - For empty matches generated by ocamlp4 (no warning)
          - when all patterns have guards (then, casel <> [])
          (specific warning)
          Then match MUST be considered non-exhaustive,
          otherwise compilation of PM is broken.
          *)
    begin match casel with
    | [] -> ()
    | _  -> Location.prerr_warning loc Warnings.All_clauses_guarded
    end ;
    Partial
| ps::_  ->
    begin match exhaust None pss (List.length ps) with
    | Rnone -> Total
    | Rsome [u] ->
        let v =
          match pred with
          | Some pred ->
              let (patterns,constrs,labels) = Conv.conv u in
(*              Hashtbl.iter (fun s (path, _) ->
                Printf.fprintf stderr "CONV: %s -> %s \n%!" s (Path.name path))
                constrs
              ; *)
              get_first (pred constrs labels) patterns
          | None -> Some u
        in
        begin match v with
          None -> Total
        | Some v ->
            let errmsg =
              match v.pat_desc with
                Tpat_construct (_, {cstr_name="*extension*"}, _) ->
                  "_\nMatching over values of extensible variant types must include\n\
                   a wild card pattern in order to be exhaustive."
              | _ -> try
                let buf = Buffer.create 16 in
                let fmt = formatter_of_buffer buf in
                top_pretty fmt v;
                begin match check_partial_all v casel with
                | None -> ()
                | Some _ ->
                    (* This is 'Some loc', where loc is the location of
                       a possibly matching clause.
                       Forget about loc, because printing two locations
                       is a pain in the top-level *)
                    Buffer.add_string buf
                      "\n(However, some guarded clause may match this value.)"
                end ;
                Buffer.contents buf
              with _ ->
                ""
            in
            Location.prerr_warning loc (Warnings.Partial_match errmsg) ;
            Partial
        end
    | _ ->
        fatal_error "Parmatch.check_partial"
    end

let do_check_partial_normal loc casel pss =
  do_check_partial exhaust loc casel pss

let do_check_partial_gadt pred loc casel pss =
  do_check_partial ~pred exhaust_gadt loc casel pss



(*****************)
(* Fragile check *)
(*****************)

(* Collect all data types in a pattern *)

let rec add_path path = function
  | [] -> [path]
  | x::rem as paths ->
      if Path.same path x then paths
      else x::add_path path rem

let extendable_path path =
  not
    (Path.same path Predef.path_bool ||
    Path.same path Predef.path_list ||
    Path.same path Predef.path_unit ||
    Path.same path Predef.path_option)

let rec collect_paths_from_pat r p = match p.pat_desc with
| Tpat_construct(_, {cstr_tag=(Cstr_constant _|Cstr_block _)},ps) ->
    let path =  get_type_path p.pat_type p.pat_env in
    List.fold_left
      collect_paths_from_pat
      (if extendable_path path then add_path path r else r)
      ps
| Tpat_any|Tpat_var _|Tpat_constant _| Tpat_variant (_,None,_) -> r
| Tpat_tuple ps | Tpat_array ps
| Tpat_construct (_, {cstr_tag=Cstr_extension _}, ps)->
    List.fold_left collect_paths_from_pat r ps
| Tpat_record (lps,_) ->
    List.fold_left
      (fun r (_, _, p) -> collect_paths_from_pat r p)
      r lps
| Tpat_variant (_, Some p, _) | Tpat_alias (p,_,_) -> collect_paths_from_pat r p
| Tpat_or (p1,p2,_) ->
    collect_paths_from_pat (collect_paths_from_pat r p1) p2
| Tpat_lazy p
    ->
    collect_paths_from_pat r p


(*
  Actual fragile check
   1. Collect data types in the patterns of the match.
   2. One exhautivity check per datatype, considering that
      the type is extended.
*)

let do_check_fragile_param exhaust loc casel pss =
  let exts =
    List.fold_left
      (fun r c -> collect_paths_from_pat r c.c_lhs)
      [] casel in
  match exts with
  | [] -> ()
  | _ -> match pss with
    | [] -> ()
    | ps::_ ->
        List.iter
          (fun ext ->
            match exhaust (Some ext) pss (List.length ps) with
            | Rnone ->
                Location.prerr_warning
                  loc
                  (Warnings.Fragile_match (Path.name ext))
            | Rsome _ -> ())
          exts

let do_check_fragile_normal = do_check_fragile_param exhaust
let do_check_fragile_gadt = do_check_fragile_param exhaust_gadt

(********************************)
(* Exported unused clause check *)
(********************************)

let check_unused tdefs casel =
  if Warnings.is_active Warnings.Unused_match then
    let rec do_rec pref = function
      | [] -> ()
      | {c_lhs=q; c_guard} :: rem ->
          let qs = [q] in
            begin try
              let pss =
                  get_mins le_pats (List.filter (compats qs) pref) in
              let r = every_satisfiables (make_rows pss) (make_row qs) in
              match r with
              | Unused ->
                  Location.prerr_warning
                    q.pat_loc Warnings.Unused_match
              | Upartial ps ->
                  List.iter
                    (fun p ->
                      Location.prerr_warning
                        p.pat_loc Warnings.Unused_pat)
                    ps
              | Used -> ()
            with Empty | Not_found | NoGuard -> assert false
            end ;

          if c_guard <> None then
            do_rec pref rem
          else
            do_rec ([q]::pref) rem in

    do_rec [] casel

(*********************************)
(* Exported irrefutability tests *)
(*********************************)

let irrefutable pat = le_pat pat omega

(* An inactive pattern is a pattern whose matching needs only
   trivial computations (tag/equality tests).
   Patterns containing (lazy _) subpatterns are active. *)

let rec inactive pat = match pat with
| Tpat_lazy _ ->
    false
| Tpat_any | Tpat_var _ | Tpat_constant _ | Tpat_variant (_, None, _) ->
    true
| Tpat_tuple ps | Tpat_construct (_, _, ps) | Tpat_array ps ->
    List.for_all (fun p -> inactive p.pat_desc) ps
| Tpat_alias (p,_,_) | Tpat_variant (_, Some p, _) ->
    inactive p.pat_desc
| Tpat_record (ldps,_) ->
    List.exists (fun (_, _, p) -> inactive p.pat_desc) ldps
| Tpat_or (p,q,_) ->
    inactive p.pat_desc && inactive q.pat_desc

(* A `fluid' pattern is both irrefutable and inactive *)

let fluid pat =  irrefutable pat && inactive pat.pat_desc








(********************************)
(* Exported exhustiveness check *)
(********************************)

(*
   Fragile check is performed when required and
   on exhaustive matches only.
*)

let check_partial_param do_check_partial do_check_fragile loc casel =
    if Warnings.is_active (Warnings.Partial_match "") then begin
      let pss = initial_matrix casel in
      let pss = get_mins le_pats pss in
      let total = do_check_partial loc casel pss in
      if
        total = Total && Warnings.is_active (Warnings.Fragile_match "")
      then begin
        do_check_fragile loc casel pss
      end ;
      total
    end else
      Partial

let check_partial =
    check_partial_param
      do_check_partial_normal
      do_check_fragile_normal

let check_partial_gadt pred loc casel =
  (*ignores GADT constructors *)
  let first_check = check_partial loc casel in
  match first_check with
  | Partial -> Partial
  | Total ->
      (* checks for missing GADT constructors *)
      (* let casel =
        match casel with [] -> [] | a :: l -> a :: l @ [a] in *)
      check_partial_param (do_check_partial_gadt pred)
        do_check_fragile_gadt loc casel

end
module Typetexp : sig 
#1 "typetexp.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Typechecking of type expressions for the core language *)

open Types

val transl_simple_type:
        Env.t -> bool -> Parsetree.core_type -> Typedtree.core_type
val transl_simple_type_univars:
        Env.t -> Parsetree.core_type -> Typedtree.core_type
val transl_simple_type_delayed:
        Env.t -> Parsetree.core_type -> Typedtree.core_type * (unit -> unit)
        (* Translate a type, but leave type variables unbound. Returns
           the type and a function that binds the type variable. *)
val transl_type_scheme:
        Env.t -> Parsetree.core_type -> Typedtree.core_type
val reset_type_variables: unit -> unit
val type_variable: Location.t -> string -> type_expr
val transl_type_param:
  Env.t -> Parsetree.core_type -> Typedtree.core_type

type variable_context
val narrow: unit -> variable_context
val widen: variable_context -> unit

exception Already_bound

type error =
    Unbound_type_variable of string
  | Unbound_type_constructor of Longident.t
  | Unbound_type_constructor_2 of Path.t
  | Type_arity_mismatch of Longident.t * int * int
  | Bound_type_variable of string
  | Recursive_type
  | Unbound_row_variable of Longident.t
  | Type_mismatch of (type_expr * type_expr) list
  | Alias_type_mismatch of (type_expr * type_expr) list
  | Present_has_conjunction of string
  | Present_has_no_type of string
  | Constructor_mismatch of type_expr * type_expr
  | Not_a_variant of type_expr
  | Variant_tags of string * string
  | Invalid_variable_name of string
  | Cannot_quantify of string * type_expr
  | Multiple_constraints_on_type of Longident.t
  | Repeated_method_label of string
  | Unbound_value of Longident.t
  | Unbound_constructor of Longident.t
  | Unbound_label of Longident.t
  | Unbound_module of Longident.t
  | Unbound_class of Longident.t
  | Unbound_modtype of Longident.t
  | Unbound_cltype of Longident.t
  | Ill_typed_functor_application of Longident.t
  | Illegal_reference_to_recursive_module
  | Access_functor_as_structure of Longident.t

exception Error of Location.t * Env.t * error

val report_error: Env.t -> Format.formatter -> error -> unit

(* Support for first-class modules. *)
val transl_modtype_longident:  (* from Typemod *)
    (Location.t -> Env.t -> Longident.t -> Path.t) ref
val transl_modtype: (* from Typemod *)
    (Env.t -> Parsetree.module_type -> Typedtree.module_type) ref
val create_package_mty:
    Location.t -> Env.t -> Parsetree.package_type ->
    (Longident.t Asttypes.loc * Parsetree.core_type) list *
      Parsetree.module_type

val find_type:
    Env.t -> Location.t -> Longident.t -> Path.t * type_declaration
val find_constructor:
    Env.t -> Location.t -> Longident.t -> constructor_description
val find_all_constructors:
    Env.t -> Location.t -> Longident.t ->
    (constructor_description * (unit -> unit)) list
val find_label:
    Env.t -> Location.t -> Longident.t -> label_description
val find_all_labels:
    Env.t -> Location.t -> Longident.t ->
    (label_description * (unit -> unit)) list
val find_value:
    Env.t -> Location.t -> Longident.t -> Path.t * value_description
val find_class:
    Env.t -> Location.t -> Longident.t -> Path.t * class_declaration
val find_module:
    Env.t -> Location.t -> Longident.t -> Path.t * module_declaration
val lookup_module:
    ?load:bool -> Env.t -> Location.t -> Longident.t -> Path.t
val find_modtype:
    Env.t -> Location.t -> Longident.t -> Path.t * modtype_declaration
val find_class_type:
    Env.t -> Location.t -> Longident.t -> Path.t * class_type_declaration

val unbound_constructor_error: Env.t -> Longident.t Location.loc -> 'a
val unbound_label_error: Env.t -> Longident.t Location.loc -> 'a

type cd
val spellcheck_simple:
    Format.formatter ->
    (('a -> cd -> cd) -> Longident.t option -> 'b -> cd -> cd) ->
    ('a -> string) -> 'b -> Longident.t -> unit

val check_deprecated: Location.t -> Parsetree.attributes -> string -> unit

val warning_enter_scope: unit -> unit
val warning_leave_scope: unit -> unit
val warning_attribute: Parsetree.attributes -> unit

val error_of_extension: Parsetree.extension -> Location.error

val emit_external_warnings: Ast_mapper.mapper

end = struct
#1 "typetexp.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* typetexp.ml,v 1.34.4.9 2002/01/07 08:39:16 garrigue Exp *)

(* Typechecking of type expressions for the core language *)

open Asttypes
open Misc
open Parsetree
open Typedtree
open Types
open Ctype

exception Already_bound

type error =
    Unbound_type_variable of string
  | Unbound_type_constructor of Longident.t
  | Unbound_type_constructor_2 of Path.t
  | Type_arity_mismatch of Longident.t * int * int
  | Bound_type_variable of string
  | Recursive_type
  | Unbound_row_variable of Longident.t
  | Type_mismatch of (type_expr * type_expr) list
  | Alias_type_mismatch of (type_expr * type_expr) list
  | Present_has_conjunction of string
  | Present_has_no_type of string
  | Constructor_mismatch of type_expr * type_expr
  | Not_a_variant of type_expr
  | Variant_tags of string * string
  | Invalid_variable_name of string
  | Cannot_quantify of string * type_expr
  | Multiple_constraints_on_type of Longident.t
  | Repeated_method_label of string
  | Unbound_value of Longident.t
  | Unbound_constructor of Longident.t
  | Unbound_label of Longident.t
  | Unbound_module of Longident.t
  | Unbound_class of Longident.t
  | Unbound_modtype of Longident.t
  | Unbound_cltype of Longident.t
  | Ill_typed_functor_application of Longident.t
  | Illegal_reference_to_recursive_module
  | Access_functor_as_structure of Longident.t

exception Error of Location.t * Env.t * error
exception Error_forward of Location.error

let string_of_cst = function
  | Const_string(s, _) -> Some s
  | _ -> None

let string_of_payload = function
  | PStr[{pstr_desc=Pstr_eval({pexp_desc=Pexp_constant c},_)}] ->
      string_of_cst c
  | _ -> None

let rec error_of_extension ext =
  match ext with
  | ({txt = ("ocaml.error"|"error") as txt; loc}, p) ->
    let rec sub_from inner =
      match inner with
      | {pstr_desc=Pstr_extension (ext, _)} :: rest ->
          error_of_extension ext :: sub_from rest
      | {pstr_loc} :: rest ->
          (Location.errorf ~loc
             "Invalid syntax for sub-error of extension '%s'." txt) ::
            sub_from rest
      | [] -> []
    in
    begin match p with
    | PStr({pstr_desc=Pstr_eval
              ({pexp_desc=Pexp_constant(Const_string(msg,_))}, _)}::
           {pstr_desc=Pstr_eval
              ({pexp_desc=Pexp_constant(Const_string(if_highlight,_))}, _)}::
           inner) ->
        Location.error ~loc ~if_highlight ~sub:(sub_from inner) msg
    | PStr({pstr_desc=Pstr_eval
              ({pexp_desc=Pexp_constant(Const_string(msg,_))}, _)}::inner) ->
        Location.error ~loc ~sub:(sub_from inner) msg
    | _ -> Location.errorf ~loc "Invalid syntax for extension '%s'." txt
    end
  | ({txt; loc}, _) ->
      Location.errorf ~loc "Uninterpreted extension '%s'." txt

let check_deprecated loc attrs s =
  List.iter
    (function
    | ({txt = "ocaml.deprecated"|"deprecated"; _}, p) ->
      begin match string_of_payload p with
      | Some txt ->
 
if Clflags.bs_vscode then    
     Location.prerr_warning loc (Warnings.Deprecated (s ^ " " ^ txt))
else           
     Location.prerr_warning loc (Warnings.Deprecated (s ^ "\n" ^ txt))
          
      | None ->
          Location.prerr_warning loc (Warnings.Deprecated s)
      end
    | _ ->  ())
    attrs

let emit_external_warnings =
  (* Note: this is run as a preliminary pass when type-checking an
     interface or implementation.  This allows to cover all kinds of
     attributes, but the drawback is that it doesn't take local
     configuration of warnings (with '@@warning'/'@@warnerror'
     attributes) into account.  We should rather check for
     'ppwarning' attributes during the actual type-checking, making
     sure to cover all contexts (easier and more ugly alternative:
     duplicate here the logic which control warnings locally). *)
  let open Ast_mapper in
  {
    default_mapper with
    attribute = (fun _ a ->
        begin match a with
        | {txt="ocaml.ppwarning"|"ppwarning"},
          PStr[{pstr_desc=Pstr_eval({pexp_desc=Pexp_constant
                                         (Const_string (s, _))},_);
                pstr_loc}] ->
            Location.prerr_warning pstr_loc (Warnings.Preprocessor s)
        | _ -> ()
        end;
        a
      )
  }


let warning_scope = ref []

let warning_enter_scope () =
  warning_scope := (Warnings.backup ()) :: !warning_scope
let warning_leave_scope () =
  match !warning_scope with
  | [] -> assert false
  | hd :: tl ->
      Warnings.restore hd;
      warning_scope := tl

let warning_attribute attrs =
  let process loc txt errflag payload =
    match string_of_payload payload with
    | Some s ->
        begin try Warnings.parse_options errflag s
        with Arg.Bad _ ->
          Location.prerr_warning loc
            (Warnings.Attribute_payload
               (txt, "Ill-formed list of warnings"))
        end
    | None ->
        Location.prerr_warning loc
          (Warnings.Attribute_payload
             (txt, "A single string literal is expected"))
  in
  List.iter
    (function
      | ({txt = ("ocaml.warning"|"warning") as txt; loc}, payload) ->
          process loc txt false payload
      | ({txt = ("ocaml.warnerror"|"warnerror") as txt; loc}, payload) ->
          process loc txt true payload
      | _ ->
          ()
    )
    attrs

type variable_context = int * (string, type_expr) Tbl.t

(* Local definitions *)

let instance_list = Ctype.instance_list Env.empty

(* Narrowing unbound identifier errors. *)

let rec narrow_unbound_lid_error : 'a. _ -> _ -> _ -> _ -> 'a =
  fun env loc lid make_error ->
  let check_module mlid =
    try ignore (Env.lookup_module true mlid env) with
    | Not_found ->
        narrow_unbound_lid_error env loc mlid (fun lid -> Unbound_module lid)
    | Env.Recmodule ->
        raise (Error (loc, env, Illegal_reference_to_recursive_module))
  in
  begin match lid with
  | Longident.Lident _ -> ()
  | Longident.Ldot (mlid, _) ->
      check_module mlid;
      let md = Env.find_module (Env.lookup_module true mlid env) env in
      begin match Env.scrape_alias env md.md_type with
        Mty_functor _ ->
          raise (Error (loc, env, Access_functor_as_structure mlid))
      | _ -> ()
      end
  | Longident.Lapply (flid, mlid) ->
      check_module flid;
      check_module mlid;
      raise (Error (loc, env, Ill_typed_functor_application lid))
  end;
  raise (Error (loc, env, make_error lid))

let find_component lookup make_error env loc lid =
  try
    match lid with
    | Longident.Ldot (Longident.Lident "*predef*", s) ->
        lookup (Longident.Lident s) Env.initial_safe_string
    | _ -> lookup lid env
  with Not_found ->
    narrow_unbound_lid_error env loc lid make_error
  | Env.Recmodule ->
    raise (Error (loc, env, Illegal_reference_to_recursive_module))

let find_type env loc lid =
  let (path, decl) as r =
    find_component Env.lookup_type (fun lid -> Unbound_type_constructor lid)
      env loc lid
  in
  check_deprecated loc decl.type_attributes (Path.name path);
  r

let find_constructor =
  find_component Env.lookup_constructor (fun lid -> Unbound_constructor lid)
let find_all_constructors =
  find_component Env.lookup_all_constructors
    (fun lid -> Unbound_constructor lid)
let find_label =
  find_component Env.lookup_label (fun lid -> Unbound_label lid)
let find_all_labels =
  find_component Env.lookup_all_labels (fun lid -> Unbound_label lid)

let find_class env loc lid =
  let (path, decl) as r =
    find_component Env.lookup_class (fun lid -> Unbound_class lid) env loc lid
  in
  check_deprecated loc decl.cty_attributes (Path.name path);
  r

let find_value env loc lid =
  Env.check_value_name (Longident.last lid) loc;
  let (path, decl) as r =
    find_component Env.lookup_value (fun lid -> Unbound_value lid) env loc lid
  in
  check_deprecated loc decl.val_attributes (Path.name path);
  r

let lookup_module ?(load=false) env loc lid =
  let (path, decl) as r =
    find_component (fun lid env -> (Env.lookup_module ~load lid env, ()))
      (fun lid -> Unbound_module lid) env loc lid
  in path

let find_module env loc lid =
  let path = lookup_module ~load:true env loc lid in
  let decl = Env.find_module path env in
  check_deprecated loc decl.md_attributes (Path.name path);
  (path, decl)

let find_modtype env loc lid =
  let (path, decl) as r =
    find_component Env.lookup_modtype (fun lid -> Unbound_modtype lid)
      env loc lid
  in
  check_deprecated loc decl.mtd_attributes (Path.name path);
  r

let find_class_type env loc lid =
  let (path, decl) as r =
    find_component Env.lookup_cltype (fun lid -> Unbound_cltype lid)
      env loc lid
  in
  check_deprecated loc decl.clty_attributes (Path.name path);
  r

let unbound_constructor_error env lid =
  narrow_unbound_lid_error env lid.loc lid.txt
    (fun lid -> Unbound_constructor lid)

let unbound_label_error env lid =
  narrow_unbound_lid_error env lid.loc lid.txt
    (fun lid -> Unbound_label lid)

(* Support for first-class modules. *)

let transl_modtype_longident = ref (fun _ -> assert false)
let transl_modtype = ref (fun _ -> assert false)

let create_package_mty fake loc env (p, l) =
  let l =
    List.sort
      (fun (s1, t1) (s2, t2) ->
         if s1.txt = s2.txt then
           raise (Error (loc, env, Multiple_constraints_on_type s1.txt));
         compare s1.txt s2.txt)
      l
  in
  l,
  List.fold_left
    (fun mty (s, t) ->
      let d = {ptype_name = mkloc (Longident.last s.txt) s.loc;
               ptype_params = [];
               ptype_cstrs = [];
               ptype_kind = Ptype_abstract;
               ptype_private = Asttypes.Public;
               ptype_manifest = if fake then None else Some t;
               ptype_attributes = [];
               ptype_loc = loc} in
      Ast_helper.Mty.mk ~loc
        (Pmty_with (mty, [ Pwith_type ({ txt = s.txt; loc }, d) ]))
    )
    (Ast_helper.Mty.mk ~loc (Pmty_ident p))
    l

(* Translation of type expressions *)

let type_variables = ref (Tbl.empty : (string, type_expr) Tbl.t)
let univars        = ref ([] : (string * type_expr) list)
let pre_univars    = ref ([] : type_expr list)
let used_variables = ref (Tbl.empty : (string, type_expr * Location.t) Tbl.t)

let reset_type_variables () =
  reset_global_level ();
  type_variables := Tbl.empty

let narrow () =
  (increase_global_level (), !type_variables)

let widen (gl, tv) =
  restore_global_level gl;
  type_variables := tv

let strict_lowercase c = (c = '_' || c >= 'a' && c <= 'z')

let validate_name = function
    None -> None
  | Some name as s ->
      if name <> "" && strict_lowercase name.[0] then s else None

let new_global_var ?name () =
  new_global_var ?name:(validate_name name) ()
let newvar ?name () =
  newvar ?name:(validate_name name) ()

let type_variable loc name =
  try
    Tbl.find name !type_variables
  with Not_found ->
    raise(Error(loc, Env.empty, Unbound_type_variable ("'" ^ name)))

let transl_type_param env styp =
  let loc = styp.ptyp_loc in
  match styp.ptyp_desc with
    Ptyp_any ->
      let ty = new_global_var ~name:"_" () in
        { ctyp_desc = Ttyp_any; ctyp_type = ty; ctyp_env = env;
          ctyp_loc = loc; ctyp_attributes = styp.ptyp_attributes; }
  | Ptyp_var name ->
      let ty =
        try
          if name <> "" && name.[0] = '_' then
            raise (Error (loc, Env.empty, Invalid_variable_name ("'" ^ name)));
          ignore (Tbl.find name !type_variables);
          raise Already_bound
        with Not_found ->
          let v = new_global_var ~name () in
            type_variables := Tbl.add name v !type_variables;
            v
      in
        { ctyp_desc = Ttyp_var name; ctyp_type = ty; ctyp_env = env;
          ctyp_loc = loc; ctyp_attributes = styp.ptyp_attributes; }
  | _ -> assert false

let wrap_method ty =
  match (Ctype.repr ty).desc with
    Tpoly _ -> ty
  | _ -> Ctype.newty (Tpoly (ty, []))

let new_pre_univar ?name () =
  let v = newvar ?name () in pre_univars := v :: !pre_univars; v

let rec swap_list = function
    x :: y :: l -> y :: x :: swap_list l
  | l -> l

type policy = Fixed | Extensible | Univars

let rec transl_type env policy styp =
  let loc = styp.ptyp_loc in
  let ctyp ctyp_desc ctyp_type =
    { ctyp_desc; ctyp_type; ctyp_env = env;
      ctyp_loc = loc; ctyp_attributes = styp.ptyp_attributes }
  in
  match styp.ptyp_desc with
    Ptyp_any ->
      let ty =
        if policy = Univars then new_pre_univar () else
          if policy = Fixed then
            raise (Error (styp.ptyp_loc, env, Unbound_type_variable "_"))
          else newvar ()
      in
      ctyp Ttyp_any ty
  | Ptyp_var name ->
    let ty =
      if name <> "" && name.[0] = '_' then
        raise (Error (styp.ptyp_loc, env, Invalid_variable_name ("'" ^ name)));
      begin try
        instance env (List.assoc name !univars)
      with Not_found -> try
        instance env (fst(Tbl.find name !used_variables))
      with Not_found ->
        let v =
          if policy = Univars then new_pre_univar ~name () else newvar ~name ()
        in
        used_variables := Tbl.add name (v, styp.ptyp_loc) !used_variables;
        v
      end
    in
    ctyp (Ttyp_var name) ty
  | Ptyp_arrow(l, st1, st2) ->
    let cty1 = transl_type env policy st1 in
    let cty2 = transl_type env policy st2 in
    let ty = newty (Tarrow(l, cty1.ctyp_type, cty2.ctyp_type, Cok)) in
    ctyp (Ttyp_arrow (l, cty1, cty2)) ty
  | Ptyp_tuple stl ->
    if List.length stl < 2 then
      Syntaxerr.ill_formed_ast loc "Tuples must have at least 2 components.";
    let ctys = List.map (transl_type env policy) stl in
    let ty = newty (Ttuple (List.map (fun ctyp -> ctyp.ctyp_type) ctys)) in
    ctyp (Ttyp_tuple ctys) ty
  | Ptyp_constr(lid, stl) ->
      let (path, decl) = find_type env styp.ptyp_loc lid.txt in
      let stl =
        match stl with
        | [ {ptyp_desc=Ptyp_any} as t ] when decl.type_arity > 1 ->
            List.map (fun _ -> t) decl.type_params
        | _ -> stl
      in
      if List.length stl <> decl.type_arity then
        raise(Error(styp.ptyp_loc, env,
                    Type_arity_mismatch(lid.txt, decl.type_arity,
                                        List.length stl)));
      let args = List.map (transl_type env policy) stl in
      let params = instance_list decl.type_params in
      let unify_param =
        match decl.type_manifest with
          None -> unify_var
        | Some ty ->
            if (repr ty).level = Btype.generic_level then unify_var else unify
      in
      List.iter2
        (fun (sty, cty) ty' ->
           try unify_param env ty' cty.ctyp_type with Unify trace ->
             raise (Error(sty.ptyp_loc, env, Type_mismatch (swap_list trace))))
        (List.combine stl args) params;
      let constr =
        newconstr path (List.map (fun ctyp -> ctyp.ctyp_type) args) in
      begin try
        Ctype.enforce_constraints env constr
      with Unify trace ->
        raise (Error(styp.ptyp_loc, env, Type_mismatch trace))
      end;
      ctyp (Ttyp_constr (path, lid, args)) constr
  | Ptyp_object (fields, o) ->
      let fields =
        List.map (fun (s, a, t) -> (s, a, transl_poly_type env policy t))
          fields
      in
      let ty = newobj (transl_fields loc env policy [] o fields) in
      ctyp (Ttyp_object (fields, o)) ty
  | Ptyp_class(lid, stl) ->
      let (path, decl, is_variant) =
        try
          let (path, decl) = Env.lookup_type lid.txt env in
          let rec check decl =
            match decl.type_manifest with
              None -> raise Not_found
            | Some ty ->
                match (repr ty).desc with
                  Tvariant row when Btype.static_row row -> ()
                | Tconstr (path, _, _) ->
                    check (Env.find_type path env)
                | _ -> raise Not_found
          in check decl;
          Location.prerr_warning styp.ptyp_loc
            (Warnings.Deprecated "old syntax for polymorphic variant type");
          (path, decl,true)
        with Not_found -> try
          let lid2 =
            match lid.txt with
              Longident.Lident s     -> Longident.Lident ("#" ^ s)
            | Longident.Ldot(r, s)   -> Longident.Ldot (r, "#" ^ s)
            | Longident.Lapply(_, _) -> fatal_error "Typetexp.transl_type"
          in
          let (path, decl) = Env.lookup_type lid2 env in
          (path, decl, false)
        with Not_found ->
          ignore (find_class env styp.ptyp_loc lid.txt); assert false
      in
      if List.length stl <> decl.type_arity then
        raise(Error(styp.ptyp_loc, env,
                    Type_arity_mismatch(lid.txt, decl.type_arity,
                                        List.length stl)));
      let args = List.map (transl_type env policy) stl in
      let params = instance_list decl.type_params in
      List.iter2
        (fun (sty, cty) ty' ->
           try unify_var env ty' cty.ctyp_type with Unify trace ->
             raise (Error(sty.ptyp_loc, env, Type_mismatch (swap_list trace))))
        (List.combine stl args) params;
        let ty_args = List.map (fun ctyp -> ctyp.ctyp_type) args in
      let ty =
        try Ctype.expand_head env (newconstr path ty_args)
        with Unify trace ->
          raise (Error(styp.ptyp_loc, env, Type_mismatch trace))
      in
      let ty = match ty.desc with
        Tvariant row ->
          let row = Btype.row_repr row in
          let fields =
            List.map
              (fun (l,f) -> l,
                match Btype.row_field_repr f with
                | Rpresent (Some ty) ->
                    Reither(false, [ty], false, ref None)
                | Rpresent None ->
                    Reither (true, [], false, ref None)
                | _ -> f)
              row.row_fields
          in
          let row = { row_closed = true; row_fields = fields;
                      row_bound = (); row_name = Some (path, ty_args);
                      row_fixed = false; row_more = newvar () } in
          let static = Btype.static_row row in
          let row =
            if static then { row with row_more = newty Tnil }
            else if policy <> Univars then row
            else { row with row_more = new_pre_univar () }
          in
          newty (Tvariant row)
      | Tobject (fi, _) ->
          let _, tv = flatten_fields fi in
          if policy = Univars then pre_univars := tv :: !pre_univars;
          ty
      | _ ->
          assert false
      in
      ctyp (Ttyp_class (path, lid, args)) ty
  | Ptyp_alias(st, alias) ->
      let cty =
        try
          let t =
            try List.assoc alias !univars
            with Not_found ->
              instance env (fst(Tbl.find alias !used_variables))
          in
          let ty = transl_type env policy st in
          begin try unify_var env t ty.ctyp_type with Unify trace ->
            let trace = swap_list trace in
            raise(Error(styp.ptyp_loc, env, Alias_type_mismatch trace))
          end;
          ty
        with Not_found ->
          if !Clflags.principal then begin_def ();
          let t = newvar () in
          used_variables := Tbl.add alias (t, styp.ptyp_loc) !used_variables;
          let ty = transl_type env policy st in
          begin try unify_var env t ty.ctyp_type with Unify trace ->
            let trace = swap_list trace in
            raise(Error(styp.ptyp_loc, env, Alias_type_mismatch trace))
          end;
          if !Clflags.principal then begin
            end_def ();
            generalize_structure t;
          end;
          let t = instance env t in
          let px = Btype.proxy t in
          begin match px.desc with
          | Tvar None -> Btype.log_type px; px.desc <- Tvar (Some alias)
          | Tunivar None -> Btype.log_type px; px.desc <- Tunivar (Some alias)
          | _ -> ()
          end;
          { ty with ctyp_type = t }
      in
      ctyp (Ttyp_alias (cty, alias)) cty.ctyp_type
  | Ptyp_variant(fields, closed, present) ->
      let name = ref None in
      let mkfield l f =
        newty (Tvariant {row_fields=[l,f]; row_more=newvar();
                         row_bound=(); row_closed=true;
                         row_fixed=false; row_name=None}) in
      let hfields = Hashtbl.create 17 in
      let add_typed_field loc l f =
        let h = Btype.hash_variant l in
        try
          let (l',f') = Hashtbl.find hfields h in
          (* Check for tag conflicts *)
          if l <> l' then raise(Error(styp.ptyp_loc, env, Variant_tags(l, l')));
          let ty = mkfield l f and ty' = mkfield l f' in
          if equal env false [ty] [ty'] then () else
          try unify env ty ty'
          with Unify trace ->
            raise(Error(loc, env, Constructor_mismatch (ty,ty')))
        with Not_found ->
          Hashtbl.add hfields h (l,f)
      in
      let add_field = function
          Rtag (l, attrs, c, stl) ->
            name := None;
            let tl = List.map (transl_type env policy) stl in
            let f = match present with
              Some present when not (List.mem l present) ->
                let ty_tl = List.map (fun cty -> cty.ctyp_type) tl in
                Reither(c, ty_tl, false, ref None)
            | _ ->
                if List.length stl > 1 || c && stl <> [] then
                  raise(Error(styp.ptyp_loc, env, Present_has_conjunction l));
                match tl with [] -> Rpresent None
                | st :: _ ->
                      Rpresent (Some st.ctyp_type)
            in
            add_typed_field styp.ptyp_loc l f;
              Ttag (l,attrs,c,tl)
        | Rinherit sty ->
            let cty = transl_type env policy sty in
            let ty = cty.ctyp_type in
            let nm =
              match repr cty.ctyp_type with
                {desc=Tconstr(p, tl, _)} -> Some(p, tl)
              | _                        -> None
            in
            begin try
              (* Set name if there are no fields yet *)
              Hashtbl.iter (fun _ _ -> raise Exit) hfields;
              name := nm
            with Exit ->
              (* Unset it otherwise *)
              name := None
            end;
            let fl = match expand_head env cty.ctyp_type, nm with
              {desc=Tvariant row}, _ when Btype.static_row row ->
                let row = Btype.row_repr row in
                row.row_fields
            | {desc=Tvar _}, Some(p, _) ->
                raise(Error(sty.ptyp_loc, env, Unbound_type_constructor_2 p))
            | _ ->
                raise(Error(sty.ptyp_loc, env, Not_a_variant ty))
            in
            List.iter
              (fun (l, f) ->
                let f = match present with
                  Some present when not (List.mem l present) ->
                    begin match f with
                      Rpresent(Some ty) ->
                        Reither(false, [ty], false, ref None)
                    | Rpresent None ->
                        Reither(true, [], false, ref None)
                    | _ ->
                        assert false
                    end
                | _ -> f
                in
                add_typed_field sty.ptyp_loc l f)
              fl;
              Tinherit cty
      in
      let tfields = List.map add_field fields in
      let fields = Hashtbl.fold (fun _ p l -> p :: l) hfields [] in
      begin match present with None -> ()
      | Some present ->
          List.iter
            (fun l -> if not (List.mem_assoc l fields) then
              raise(Error(styp.ptyp_loc, env, Present_has_no_type l)))
            present
      end;
      let row =
        { row_fields = List.rev fields; row_more = newvar ();
          row_bound = (); row_closed = (closed = Closed);
          row_fixed = false; row_name = !name } in
      let static = Btype.static_row row in
      let row =
        if static then { row with row_more = newty Tnil }
        else if policy <> Univars then row
        else { row with row_more = new_pre_univar () }
      in
      let ty = newty (Tvariant row) in
      ctyp (Ttyp_variant (tfields, closed, present)) ty
   | Ptyp_poly(vars, st) ->
      begin_def();
      let new_univars = List.map (fun name -> name, newvar ~name ()) vars in
      let old_univars = !univars in
      univars := new_univars @ !univars;
      let cty = transl_type env policy st in
      let ty = cty.ctyp_type in
      univars := old_univars;
      end_def();
      generalize ty;
      let ty_list =
        List.fold_left
          (fun tyl (name, ty1) ->
            let v = Btype.proxy ty1 in
            if deep_occur v ty then begin
              match v.desc with
                Tvar name when v.level = Btype.generic_level ->
                  v.desc <- Tunivar name;
                  v :: tyl
              | _ ->
                raise (Error (styp.ptyp_loc, env, Cannot_quantify (name, v)))
            end else tyl)
          [] new_univars
      in
      let ty' = Btype.newgenty (Tpoly(ty, List.rev ty_list)) in
      unify_var env (newvar()) ty';
      ctyp (Ttyp_poly (vars, cty)) ty'
  | Ptyp_package (p, l) ->
      let l, mty = create_package_mty true styp.ptyp_loc env (p, l) in
      let z = narrow () in
      let mty = !transl_modtype env mty in
      widen z;
      let ptys = List.map (fun (s, pty) ->
                             s, transl_type env policy pty
                          ) l in
      let path = !transl_modtype_longident styp.ptyp_loc env p.txt in
      let ty = newty (Tpackage (path,
                       List.map (fun (s, pty) -> s.txt) l,
                       List.map (fun (_,cty) -> cty.ctyp_type) ptys))
      in
      ctyp (Ttyp_package {
            pack_path = path;
            pack_type = mty.mty_type;
            pack_fields = ptys;
            pack_txt = p;
           }) ty
  | Ptyp_extension ext ->
      raise (Error_forward (error_of_extension ext))

and transl_poly_type env policy t =
  transl_type env policy (Ast_helper.Typ.force_poly t)

and transl_fields loc env policy seen o =
  function
    [] ->
      begin match o, policy with
      | Closed, _ -> newty Tnil
      | Open, Univars -> new_pre_univar ()
      | Open, _ -> newvar ()
      end
  | (s, _attrs, ty1) :: l ->
      if List.mem s seen then raise (Error (loc, env, Repeated_method_label s));
      let ty2 = transl_fields loc env policy (s :: seen) o l in
      newty (Tfield (s, Fpresent, ty1.ctyp_type, ty2))

(* Make the rows "fixed" in this type, to make universal check easier *)
let rec make_fixed_univars ty =
  let ty = repr ty in
  if ty.level >= Btype.lowest_level then begin
    Btype.mark_type_node ty;
    match ty.desc with
    | Tvariant row ->
        let row = Btype.row_repr row in
        if Btype.is_Tunivar (Btype.row_more row) then
          ty.desc <- Tvariant
              {row with row_fixed=true;
               row_fields = List.map
                 (fun (s,f as p) -> match Btype.row_field_repr f with
                   Reither (c, tl, m, r) -> s, Reither (c, tl, true, r)
                 | _ -> p)
                 row.row_fields};
        Btype.iter_row make_fixed_univars row
    | _ ->
        Btype.iter_type_expr make_fixed_univars ty
  end

let make_fixed_univars ty =
  make_fixed_univars ty;
  Btype.unmark_type ty

let create_package_mty = create_package_mty false

let globalize_used_variables env fixed =
  let r = ref [] in
  Tbl.iter
    (fun name (ty, loc) ->
      let v = new_global_var () in
      let snap = Btype.snapshot () in
      if try unify env v ty; true with _ -> Btype.backtrack snap; false
      then try
        r := (loc, v,  Tbl.find name !type_variables) :: !r
      with Not_found ->
        if fixed && Btype.is_Tvar (repr ty) then
          raise(Error(loc, env, Unbound_type_variable ("'"^name)));
        let v2 = new_global_var () in
        r := (loc, v, v2) :: !r;
        type_variables := Tbl.add name v2 !type_variables)
    !used_variables;
  used_variables := Tbl.empty;
  fun () ->
    List.iter
      (function (loc, t1, t2) ->
        try unify env t1 t2 with Unify trace ->
          raise (Error(loc, env, Type_mismatch trace)))
      !r

let transl_simple_type env fixed styp =
  univars := []; used_variables := Tbl.empty;
  let typ = transl_type env (if fixed then Fixed else Extensible) styp in
  globalize_used_variables env fixed ();
  make_fixed_univars typ.ctyp_type;
  typ

let transl_simple_type_univars env styp =
  univars := []; used_variables := Tbl.empty; pre_univars := [];
  begin_def ();
  let typ = transl_type env Univars styp in
  (* Only keep already global variables in used_variables *)
  let new_variables = !used_variables in
  used_variables := Tbl.empty;
  Tbl.iter
    (fun name p ->
      if Tbl.mem name !type_variables then
        used_variables := Tbl.add name p !used_variables)
    new_variables;
  globalize_used_variables env false ();
  end_def ();
  generalize typ.ctyp_type;
  let univs =
    List.fold_left
      (fun acc v ->
        let v = repr v in
        match v.desc with
          Tvar name when v.level = Btype.generic_level ->
            v.desc <- Tunivar name; v :: acc
        | _ -> acc)
      [] !pre_univars
  in
  make_fixed_univars typ.ctyp_type;
    { typ with ctyp_type =
        instance env (Btype.newgenty (Tpoly (typ.ctyp_type, univs))) }

let transl_simple_type_delayed env styp =
  univars := []; used_variables := Tbl.empty;
  let typ = transl_type env Extensible styp in
  make_fixed_univars typ.ctyp_type;
  (typ, globalize_used_variables env false)

let transl_type_scheme env styp =
  reset_type_variables();
  begin_def();
  let typ = transl_simple_type env false styp in
  end_def();
  generalize typ.ctyp_type;
  typ


(* Error report *)

open Format
open Printtyp

let spellcheck ppf fold env lid =
  let cutoff =
    match String.length (Longident.last lid) with
      | 1 | 2 -> 0
      | 3 | 4 -> 1
      | 5 | 6 -> 2
      | _ -> 3
  in
  let compare target head acc =
    let (best_choice, best_dist) = acc in
    match Misc.edit_distance target head cutoff with
      | None -> (best_choice, best_dist)
      | Some dist ->
        let choice =
          if dist < best_dist then [head]
          else if dist = best_dist then head :: best_choice
          else best_choice in
        (choice, min dist best_dist)
  in
  let init = ([], max_int) in
  let handle (choice, _dist) =
    match List.rev choice with
      | [] -> ()
      | last :: rev_rest ->
        fprintf ppf "@\nHint: Did you mean %s%s%s?"
          (String.concat ", " (List.rev rev_rest))
          (if rev_rest = [] then "" else " or ")
          last
  in
  (* flush now to get the error report early, in the (unheard of) case
     where the linear search would take a bit of time; in the worst
     case, the user has seen the error, she can interrupt the process
     before the spell-checking terminates. *)
  fprintf ppf "@?";
  match lid with
    | Longident.Lapply _ -> ()
    | Longident.Lident s ->
      handle (fold (compare s) None env init)
    | Longident.Ldot (r, s) ->
      handle (fold (compare s) (Some r) env init)

let spellcheck_simple ppf fold extr =
  spellcheck ppf (fun f -> fold (fun decl x -> f (extr decl) x))

let spellcheck ppf fold =
  spellcheck ppf (fun f -> fold (fun s _ _ x -> f s x))

type cd = string list * int

let report_error env ppf = function
  | Unbound_type_variable name ->
    fprintf ppf "Unbound type parameter %s@." name
  | Unbound_type_constructor lid ->
    fprintf ppf "Unbound type constructor %a" longident lid;
    spellcheck ppf Env.fold_types env lid;
  | Unbound_type_constructor_2 p ->
    fprintf ppf "The type constructor@ %a@ is not yet completely defined"
      path p
  | Type_arity_mismatch(lid, expected, provided) ->
    fprintf ppf
      "@[The type constructor %a@ expects %i argument(s),@ \
        but is here applied to %i argument(s)@]"
      longident lid expected provided
  | Bound_type_variable name ->
    fprintf ppf "Already bound type parameter '%s" name
  | Recursive_type ->
    fprintf ppf "This type is recursive"
  | Unbound_row_variable lid ->
      (* we don't use "spellcheck" here: this error is not raised
         anywhere so it's unclear how it should be handled *)
      fprintf ppf "Unbound row variable in #%a" longident lid
  | Type_mismatch trace ->
      Printtyp.report_unification_error ppf Env.empty trace
        (function ppf ->
           fprintf ppf "This type")
        (function ppf ->
           fprintf ppf "should be an instance of type")
  | Alias_type_mismatch trace ->
      Printtyp.report_unification_error ppf Env.empty trace
        (function ppf ->
           fprintf ppf "This alias is bound to type")
        (function ppf ->
           fprintf ppf "but is used as an instance of type")
  | Present_has_conjunction l ->
      fprintf ppf "The present constructor %s has a conjunctive type" l
  | Present_has_no_type l ->
      fprintf ppf "The present constructor %s has no type" l
  | Constructor_mismatch (ty, ty') ->
      wrap_printing_env env (fun ()  ->
        Printtyp.reset_and_mark_loops_list [ty; ty'];
        fprintf ppf "@[<hov>%s %a@ %s@ %a@]"
          "This variant type contains a constructor"
          Printtyp.type_expr ty
          "which should be"
          Printtyp.type_expr ty')
  | Not_a_variant ty ->
      Printtyp.reset_and_mark_loops ty;
      fprintf ppf "@[The type %a@ is not a polymorphic variant type@]"
        Printtyp.type_expr ty
  | Variant_tags (lab1, lab2) ->
      fprintf ppf
        "@[Variant tags `%s@ and `%s have the same hash value.@ %s@]"
        lab1 lab2 "Change one of them."
  | Invalid_variable_name name ->
      fprintf ppf "The type variable name %s is not allowed in programs" name
  | Cannot_quantify (name, v) ->
      fprintf ppf
        "@[<hov>The universal type variable '%s cannot be generalized:@ %s.@]"
        name
        (if Btype.is_Tvar v then "it escapes its scope" else
         if Btype.is_Tunivar v then "it is already bound to another variable"
         else "it is not a variable")
  | Multiple_constraints_on_type s ->
      fprintf ppf "Multiple constraints for type %a" longident s
  | Repeated_method_label s ->
      fprintf ppf "@[This is the second method `%s' of this object type.@ %s@]"
        s "Multiple occurences are not allowed."
  | Unbound_value lid ->
      fprintf ppf "Unbound value %a" longident lid;
      spellcheck ppf Env.fold_values env lid;
  | Unbound_module lid ->
      fprintf ppf "Unbound module %a" longident lid;
      spellcheck ppf Env.fold_modules env lid;
  | Unbound_constructor lid ->
      fprintf ppf "Unbound constructor %a" longident lid;
      spellcheck_simple ppf Env.fold_constructors (fun d -> d.cstr_name)
        env lid;
  | Unbound_label lid ->
      fprintf ppf "Unbound record field %a" longident lid;
      spellcheck_simple ppf Env.fold_labels (fun d -> d.lbl_name) env lid;
  | Unbound_class lid ->
      fprintf ppf "Unbound class %a" longident lid;
      spellcheck ppf Env.fold_classs env lid;
  | Unbound_modtype lid ->
      fprintf ppf "Unbound module type %a" longident lid;
      spellcheck ppf Env.fold_modtypes env lid;
  | Unbound_cltype lid ->
      fprintf ppf "Unbound class type %a" longident lid;
      spellcheck ppf Env.fold_cltypes env lid;
  | Ill_typed_functor_application lid ->
      fprintf ppf "Ill-typed functor application %a" longident lid
  | Illegal_reference_to_recursive_module ->
      fprintf ppf "Illegal recursive module reference"
  | Access_functor_as_structure lid ->
      fprintf ppf "The module %a is a functor, not a structure" longident lid

let () =
  Location.register_error_of_exn
    (function
      | Error (loc, env, err) ->
        Some (Location.error_of_printer loc (report_error env) err)
      | Error_forward err ->
        Some err
      | _ ->
        None
    )

end
module Typecore : sig 
#1 "typecore.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Type inference for the core language *)

open Asttypes
open Types
open Format

val is_nonexpansive: Typedtree.expression -> bool

val type_binding:
        Env.t -> rec_flag ->
          Parsetree.value_binding list ->
          Annot.ident option ->
          Typedtree.value_binding list * Env.t
val type_let:
        Env.t -> rec_flag ->
          Parsetree.value_binding list ->
          Annot.ident option ->
          Typedtree.value_binding list * Env.t
val type_expression:
        Env.t -> Parsetree.expression -> Typedtree.expression
val type_class_arg_pattern:
        string -> Env.t -> Env.t -> label -> Parsetree.pattern ->
        Typedtree.pattern * (Ident.t * string loc * Ident.t * type_expr) list *
        Env.t * Env.t
val type_self_pattern:
        string -> type_expr -> Env.t -> Env.t -> Env.t -> Parsetree.pattern ->
        Typedtree.pattern *
        (Ident.t * type_expr) Meths.t ref *
        (Ident.t * Asttypes.mutable_flag * Asttypes.virtual_flag * type_expr)
            Vars.t ref *
        Env.t * Env.t * Env.t
val check_partial:
        ?lev:int -> Env.t -> type_expr ->
	Location.t -> Typedtree.case list -> Typedtree.partial
val type_expect:
        ?in_function:(Location.t * type_expr) ->
        Env.t -> Parsetree.expression -> type_expr -> Typedtree.expression
val type_exp:
        Env.t -> Parsetree.expression -> Typedtree.expression
val type_approx:
        Env.t -> Parsetree.expression -> type_expr
val type_argument:
        Env.t -> Parsetree.expression ->
        type_expr -> type_expr -> Typedtree.expression

val option_some: Typedtree.expression -> Typedtree.expression
val option_none: type_expr -> Location.t -> Typedtree.expression
val extract_option_type: Env.t -> type_expr -> type_expr
val iter_pattern: (Typedtree.pattern -> unit) -> Typedtree.pattern -> unit
val generalizable: int -> type_expr -> bool
val reset_delayed_checks: unit -> unit
val force_delayed_checks: unit -> unit

val self_coercion : (Path.t * Location.t list ref) list ref

type error =
    Polymorphic_label of Longident.t
  | Constructor_arity_mismatch of Longident.t * int * int
  | Label_mismatch of Longident.t * (type_expr * type_expr) list
  | Pattern_type_clash of (type_expr * type_expr) list
  | Or_pattern_type_clash of Ident.t * (type_expr * type_expr) list
  | Multiply_bound_variable of string
  | Orpat_vars of Ident.t
  | Expr_type_clash of (type_expr * type_expr) list
  | Apply_non_function of type_expr
  | Apply_wrong_label of label * type_expr
  | Label_multiply_defined of string
  | Label_missing of Ident.t list
  | Label_not_mutable of Longident.t
  | Wrong_name of string * type_expr * string * Path.t * Longident.t
  | Name_type_mismatch of
      string * Longident.t * (Path.t * Path.t) * (Path.t * Path.t) list
  | Invalid_format of string
  | Undefined_method of type_expr * string
  | Undefined_inherited_method of string
  | Virtual_class of Longident.t
  | Private_type of type_expr
  | Private_label of Longident.t * type_expr
  | Unbound_instance_variable of string
  | Instance_variable_not_mutable of bool * string
  | Not_subtype of (type_expr * type_expr) list * (type_expr * type_expr) list
  | Outside_class
  | Value_multiply_overridden of string
  | Coercion_failure of
      type_expr * type_expr * (type_expr * type_expr) list * bool
  | Too_many_arguments of bool * type_expr
  | Abstract_wrong_label of label * type_expr
  | Scoping_let_module of string * type_expr
  | Masked_instance_variable of Longident.t
  | Not_a_variant_type of Longident.t
  | Incoherent_label_order
  | Less_general of string * (type_expr * type_expr) list
  | Modules_not_allowed
  | Cannot_infer_signature
  | Not_a_packed_module of type_expr
  | Recursive_local_constraint of (type_expr * type_expr) list
  | Unexpected_existential
  | Unqualified_gadt_pattern of Path.t * string
  | Invalid_interval
  | Invalid_for_loop_index
  | No_value_clauses
  | Exception_pattern_below_toplevel

exception Error of Location.t * Env.t * error
exception Error_forward of Location.error

val report_error: Env.t -> formatter -> error -> unit
 (* Deprecated.  Use Location.{error_of_exn, report_error}. *)

(* Forward declaration, to be filled in by Typemod.type_module *)
val type_module: (Env.t -> Parsetree.module_expr -> Typedtree.module_expr) ref
(* Forward declaration, to be filled in by Typemod.type_open *)
val type_open:
    (override_flag -> Env.t -> Location.t -> Longident.t loc -> Path.t * Env.t)
    ref
(* Forward declaration, to be filled in by Typeclass.class_structure *)
val type_object:
  (Env.t -> Location.t -> Parsetree.class_structure ->
   Typedtree.class_structure * Types.class_signature * string list) ref
val type_package:
  (Env.t -> Parsetree.module_expr -> Path.t -> Longident.t list ->
  type_expr list -> Typedtree.module_expr * type_expr list) ref

val create_package_type : Location.t -> Env.t ->
  Longident.t * (Longident.t * Parsetree.core_type) list ->
  Path.t * (Longident.t * Typedtree.core_type) list * Types.type_expr

end = struct
#1 "typecore.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Typechecking for the core language *)

open Misc
open Asttypes
open Parsetree
open Types
open Typedtree
open Btype
open Ctype

type error =
    Polymorphic_label of Longident.t
  | Constructor_arity_mismatch of Longident.t * int * int
  | Label_mismatch of Longident.t * (type_expr * type_expr) list
  | Pattern_type_clash of (type_expr * type_expr) list
  | Or_pattern_type_clash of Ident.t * (type_expr * type_expr) list
  | Multiply_bound_variable of string
  | Orpat_vars of Ident.t
  | Expr_type_clash of (type_expr * type_expr) list
  | Apply_non_function of type_expr
  | Apply_wrong_label of label * type_expr
  | Label_multiply_defined of string
  | Label_missing of Ident.t list
  | Label_not_mutable of Longident.t
  | Wrong_name of string * type_expr * string * Path.t * Longident.t
  | Name_type_mismatch of
      string * Longident.t * (Path.t * Path.t) * (Path.t * Path.t) list
  | Invalid_format of string
  | Undefined_method of type_expr * string
  | Undefined_inherited_method of string
  | Virtual_class of Longident.t
  | Private_type of type_expr
  | Private_label of Longident.t * type_expr
  | Unbound_instance_variable of string
  | Instance_variable_not_mutable of bool * string
  | Not_subtype of (type_expr * type_expr) list * (type_expr * type_expr) list
  | Outside_class
  | Value_multiply_overridden of string
  | Coercion_failure of
      type_expr * type_expr * (type_expr * type_expr) list * bool
  | Too_many_arguments of bool * type_expr
  | Abstract_wrong_label of label * type_expr
  | Scoping_let_module of string * type_expr
  | Masked_instance_variable of Longident.t
  | Not_a_variant_type of Longident.t
  | Incoherent_label_order
  | Less_general of string * (type_expr * type_expr) list
  | Modules_not_allowed
  | Cannot_infer_signature
  | Not_a_packed_module of type_expr
  | Recursive_local_constraint of (type_expr * type_expr) list
  | Unexpected_existential
  | Unqualified_gadt_pattern of Path.t * string
  | Invalid_interval
  | Invalid_for_loop_index
  | No_value_clauses
  | Exception_pattern_below_toplevel

exception Error of Location.t * Env.t * error
exception Error_forward of Location.error

(* Forward declaration, to be filled in by Typemod.type_module *)

let type_module =
  ref ((fun env md -> assert false) :
       Env.t -> Parsetree.module_expr -> Typedtree.module_expr)

(* Forward declaration, to be filled in by Typemod.type_open *)

let type_open =
  ref (fun _ -> assert false)

(* Forward declaration, to be filled in by Typemod.type_package *)

let type_package =
  ref (fun _ -> assert false)

(* Forward declaration, to be filled in by Typeclass.class_structure *)
let type_object =
  ref (fun env s -> assert false :
       Env.t -> Location.t -> Parsetree.class_structure ->
         Typedtree.class_structure * Types.class_signature * string list)

(*
  Saving and outputting type information.
  We keep these function names short, because they have to be
  called each time we create a record of type [Typedtree.expression]
  or [Typedtree.pattern] that will end up in the typed AST.
*)
let re node =
  Cmt_format.add_saved_type (Cmt_format.Partial_expression node);
  Stypes.record (Stypes.Ti_expr node);
  node
;;
let rp node =
  Cmt_format.add_saved_type (Cmt_format.Partial_pattern node);
  Stypes.record (Stypes.Ti_pat node);
  node
;;


let fst3 (x, _, _) = x
let snd3 (_,x,_) = x

let case lhs rhs =
  {c_lhs = lhs; c_guard = None; c_rhs = rhs}

(* Upper approximation of free identifiers on the parse tree *)

let iter_expression f e =

  let rec expr e =
    f e;
    match e.pexp_desc with
    | Pexp_extension _ (* we don't iterate under extension point *)
    | Pexp_ident _
    | Pexp_new _
    | Pexp_constant _ -> ()
    | Pexp_function pel -> List.iter case pel
    | Pexp_fun (_, eo, _, e) -> may expr eo; expr e
    | Pexp_apply (e, lel) -> expr e; List.iter (fun (_, e) -> expr e) lel
    | Pexp_let (_, pel, e) ->  expr e; List.iter binding pel
    | Pexp_match (e, pel)
    | Pexp_try (e, pel) -> expr e; List.iter case pel
    | Pexp_array el
    | Pexp_tuple el -> List.iter expr el
    | Pexp_construct (_, eo)
    | Pexp_variant (_, eo) -> may expr eo
    | Pexp_record (iel, eo) ->
        may expr eo; List.iter (fun (_, e) -> expr e) iel
    | Pexp_open (_, _, e)
    | Pexp_newtype (_, e)
    | Pexp_poly (e, _)
    | Pexp_lazy e
    | Pexp_assert e
    | Pexp_setinstvar (_, e)
    | Pexp_send (e, _)
    | Pexp_constraint (e, _)
    | Pexp_coerce (e, _, _)
    | Pexp_field (e, _) -> expr e
    | Pexp_while (e1, e2)
    | Pexp_sequence (e1, e2)
    | Pexp_setfield (e1, _, e2) -> expr e1; expr e2
    | Pexp_ifthenelse (e1, e2, eo) -> expr e1; expr e2; may expr eo
    | Pexp_for (_, e1, e2, _, e3) -> expr e1; expr e2; expr e3
    | Pexp_override sel -> List.iter (fun (_, e) -> expr e) sel
    | Pexp_letmodule (_, me, e) -> expr e; module_expr me
    | Pexp_object { pcstr_fields = fs } -> List.iter class_field fs
    | Pexp_pack me -> module_expr me

  and case {pc_lhs = _; pc_guard; pc_rhs} =
    may expr pc_guard;
    expr pc_rhs

  and binding x =
    expr x.pvb_expr

  and module_expr me =
    match me.pmod_desc with
    | Pmod_extension _
    | Pmod_ident _ -> ()
    | Pmod_structure str -> List.iter structure_item str
    | Pmod_constraint (me, _)
    | Pmod_functor (_, _, me) -> module_expr me
    | Pmod_apply (me1, me2) -> module_expr me1; module_expr me2
    | Pmod_unpack e -> expr e


  and structure_item str =
    match str.pstr_desc with
    | Pstr_eval (e, _) -> expr e
    | Pstr_value (_, pel) -> List.iter binding pel
    | Pstr_primitive _
    | Pstr_type _
    | Pstr_typext _
    | Pstr_exception _
    | Pstr_modtype _
    | Pstr_open _
    | Pstr_class_type _
    | Pstr_attribute _
    | Pstr_extension _ -> ()
    | Pstr_include {pincl_mod = me}
    | Pstr_module {pmb_expr = me} -> module_expr me
    | Pstr_recmodule l -> List.iter (fun x -> module_expr x.pmb_expr) l
    | Pstr_class cdl -> List.iter (fun c -> class_expr c.pci_expr) cdl

  and class_expr ce =
    match ce.pcl_desc with
    | Pcl_constr _ -> ()
    | Pcl_structure { pcstr_fields = fs } -> List.iter class_field fs
    | Pcl_fun (_, eo, _,  ce) -> may expr eo; class_expr ce
    | Pcl_apply (ce, lel) ->
        class_expr ce; List.iter (fun (_, e) -> expr e) lel
    | Pcl_let (_, pel, ce) ->
        List.iter binding pel; class_expr ce
    | Pcl_constraint (ce, _) -> class_expr ce
    | Pcl_extension _ -> ()

  and class_field cf =
    match cf.pcf_desc with
    | Pcf_inherit (_, ce, _) -> class_expr ce
    | Pcf_val (_, _, Cfk_virtual _)
    | Pcf_method (_, _, Cfk_virtual _ ) | Pcf_constraint _ -> ()
    | Pcf_val (_, _, Cfk_concrete (_, e))
    | Pcf_method (_, _, Cfk_concrete (_, e)) -> expr e
    | Pcf_initializer e -> expr e
    | Pcf_attribute _ | Pcf_extension _ -> ()

  in
  expr e


let all_idents_cases el =
  let idents = Hashtbl.create 8 in
  let f = function
    | {pexp_desc=Pexp_ident { txt = Longident.Lident id; _ }; _} ->
        Hashtbl.replace idents id ()
    | _ -> ()
  in
  List.iter
    (fun cp ->
      may (iter_expression f) cp.pc_guard;
      iter_expression f cp.pc_rhs
    )
    el;
  Hashtbl.fold (fun x () rest -> x :: rest) idents []


(* Typing of constants *)

let type_constant = function
    Const_int _ -> instance_def Predef.type_int
  | Const_char _ -> instance_def Predef.type_char
  | Const_string _ -> instance_def Predef.type_string
  | Const_float _ -> instance_def Predef.type_float
  | Const_int32 _ -> instance_def Predef.type_int32
  | Const_int64 _ -> instance_def Predef.type_int64
  | Const_nativeint _ -> instance_def Predef.type_nativeint

(* Specific version of type_option, using newty rather than newgenty *)

let type_option ty =
  newty (Tconstr(Predef.path_option,[ty], ref Mnil))

let mkexp exp_desc exp_type exp_loc exp_env =
  { exp_desc; exp_type; exp_loc; exp_env; exp_extra = []; exp_attributes = [] }

let option_none ty loc =
  let lid = Longident.Lident "None"
  and env = Env.initial_safe_string in
  let cnone = Env.lookup_constructor lid env in
  mkexp (Texp_construct(mknoloc lid, cnone, [])) ty loc env

let option_some texp =
  let lid = Longident.Lident "Some" in
  let csome = Env.lookup_constructor lid Env.initial_safe_string in
  mkexp ( Texp_construct(mknoloc lid , csome, [texp]) )
    (type_option texp.exp_type) texp.exp_loc texp.exp_env

let extract_option_type env ty =
  match expand_head env ty with {desc = Tconstr(path, [ty], _)}
    when Path.same path Predef.path_option -> ty
  | _ -> assert false

let extract_concrete_record env ty =
  match extract_concrete_typedecl env ty with
    (p0, p, {type_kind=Type_record (fields, _)}) -> (p0, p, fields)
  | _ -> raise Not_found

let extract_concrete_variant env ty =
  match extract_concrete_typedecl env ty with
    (p0, p, {type_kind=Type_variant cstrs}) -> (p0, p, cstrs)
  | (p0, p, {type_kind=Type_open}) -> (p0, p, [])
  | _ -> raise Not_found

let extract_label_names sexp env ty =
  try
    let (_, _,fields) = extract_concrete_record env ty in
    List.map (fun l -> l.Types.ld_id) fields
  with Not_found ->
    assert false

let explicit_arity =
  List.exists
    (function
      | ({txt="ocaml.explicit_arity"|"explicit_arity"; _}, _) -> true
      | _ -> false
    )

(* Typing of patterns *)

(* unification inside type_pat*)
let unify_pat_types loc env ty ty' =
  try
    unify env ty ty'
  with
    Unify trace ->
      raise(Error(loc, env, Pattern_type_clash(trace)))
  | Tags(l1,l2) ->
      raise(Typetexp.Error(loc, env, Typetexp.Variant_tags (l1, l2)))

(* unification inside type_exp and type_expect *)
let unify_exp_types loc env ty expected_ty =
  (* Format.eprintf "@[%a@ %a@]@." Printtyp.raw_type_expr exp.exp_type
    Printtyp.raw_type_expr expected_ty; *)
  try
    unify env ty expected_ty
  with
    Unify trace ->
      raise(Error(loc, env, Expr_type_clash(trace)))
  | Tags(l1,l2) ->
      raise(Typetexp.Error(loc, env, Typetexp.Variant_tags (l1, l2)))

(* level at which to create the local type declarations *)
let newtype_level = ref None
let get_newtype_level () =
  match !newtype_level with
    Some y -> y
  | None -> assert false

let unify_pat_types_gadt loc env ty ty' =
  let newtype_level =
    match !newtype_level with
    | None -> assert false
    | Some x -> x
  in
  try
    unify_gadt ~newtype_level env ty ty'
  with
    Unify trace ->
      raise(Error(loc, !env, Pattern_type_clash(trace)))
  | Tags(l1,l2) ->
      raise(Typetexp.Error(loc, !env, Typetexp.Variant_tags (l1, l2)))
  | Unification_recursive_abbrev trace ->
      raise(Error(loc, !env, Recursive_local_constraint trace))


(* Creating new conjunctive types is not allowed when typing patterns *)

let unify_pat env pat expected_ty =
  unify_pat_types pat.pat_loc env pat.pat_type expected_ty

(* make all Reither present in open variants *)
let finalize_variant pat =
  match pat.pat_desc with
    Tpat_variant(tag, opat, r) ->
      let row =
        match expand_head pat.pat_env pat.pat_type with
          {desc = Tvariant row} -> r := row; row_repr row
        | _ -> assert false
      in
      begin match row_field tag row with
      | Rabsent -> () (* assert false *)
      | Reither (true, [], _, e) when not row.row_closed ->
          set_row_field e (Rpresent None)
      | Reither (false, ty::tl, _, e) when not row.row_closed ->
          set_row_field e (Rpresent (Some ty));
          begin match opat with None -> assert false
          | Some pat -> List.iter (unify_pat pat.pat_env pat) (ty::tl)
          end
      | Reither (c, l, true, e) when not (row_fixed row) ->
          set_row_field e (Reither (c, [], false, ref None))
      | _ -> ()
      end;
      (* Force check of well-formedness   WHY? *)
      (* unify_pat pat.pat_env pat
        (newty(Tvariant{row_fields=[]; row_more=newvar(); row_closed=false;
                        row_bound=(); row_fixed=false; row_name=None})); *)
  | _ -> ()

let rec iter_pattern f p =
  f p;
  iter_pattern_desc (iter_pattern f) p.pat_desc

let has_variants p =
  try
    iter_pattern (function {pat_desc=Tpat_variant _} -> raise Exit | _ -> ())
      p;
    false
  with Exit ->
    true


(* pattern environment *)
let pattern_variables = ref ([] :
 (Ident.t * type_expr * string loc * Location.t * bool (* as-variable *)) list)
let pattern_force = ref ([] : (unit -> unit) list)
let pattern_scope = ref (None : Annot.ident option);;
let allow_modules = ref false
let module_variables = ref ([] : (string loc * Location.t) list)
let reset_pattern scope allow =
  pattern_variables := [];
  pattern_force := [];
  pattern_scope := scope;
  allow_modules := allow;
  module_variables := [];
;;

let enter_variable ?(is_module=false) ?(is_as_variable=false) loc name ty =
  if List.exists (fun (id, _, _, _, _) -> Ident.name id = name.txt)
      !pattern_variables
  then raise(Error(loc, Env.empty, Multiply_bound_variable name.txt));
  let id = Ident.create name.txt in
  pattern_variables :=
    (id, ty, name, loc, is_as_variable) :: !pattern_variables;
  if is_module then begin
    (* Note: unpack patterns enter a variable of the same name *)
    if not !allow_modules then
      raise (Error (loc, Env.empty, Modules_not_allowed));
    module_variables := (name, loc) :: !module_variables
  end else
    (* moved to genannot *)
    may (fun s -> Stypes.record (Stypes.An_ident (name.loc, name.txt, s)))
        !pattern_scope;
  id

let sort_pattern_variables vs =
  List.sort
    (fun (x,_,_,_,_) (y,_,_,_,_) ->
      Pervasives.compare (Ident.name x) (Ident.name y))
    vs

let enter_orpat_variables loc env  p1_vs p2_vs =
  (* unify_vars operate on sorted lists *)

  let p1_vs = sort_pattern_variables p1_vs
  and p2_vs = sort_pattern_variables p2_vs in

  let rec unify_vars p1_vs p2_vs = match p1_vs, p2_vs with
      | (x1,t1,_,l1,a1)::rem1, (x2,t2,_,l2,a2)::rem2 when Ident.equal x1 x2 ->
          if x1==x2 then
            unify_vars rem1 rem2
          else begin
            begin try
              unify env t1 t2
            with
            | Unify trace ->
                raise(Error(loc, env, Or_pattern_type_clash(x1, trace)))
            end;
          (x2,x1)::unify_vars rem1 rem2
          end
      | [],[] -> []
      | (x,_,_,_,_)::_, [] -> raise (Error (loc, env, Orpat_vars x))
      | [],(x,_,_,_,_)::_  -> raise (Error (loc, env, Orpat_vars x))
      | (x,_,_,_,_)::_, (y,_,_,_,_)::_ ->
          let min_var =
            if Ident.name x < Ident.name y then x
            else y in
          raise (Error (loc, env, Orpat_vars min_var)) in
  unify_vars p1_vs p2_vs

let rec build_as_type env p =
  match p.pat_desc with
    Tpat_alias(p1,_, _) -> build_as_type env p1
  | Tpat_tuple pl ->
      let tyl = List.map (build_as_type env) pl in
      newty (Ttuple tyl)
  | Tpat_construct(_, cstr, pl) ->
      let keep = cstr.cstr_private = Private || cstr.cstr_existentials <> [] in
      if keep then p.pat_type else
      let tyl = List.map (build_as_type env) pl in
      let ty_args, ty_res = instance_constructor cstr in
      List.iter2 (fun (p,ty) -> unify_pat env {p with pat_type = ty})
        (List.combine pl tyl) ty_args;
      ty_res
  | Tpat_variant(l, p', _) ->
      let ty = may_map (build_as_type env) p' in
      newty (Tvariant{row_fields=[l, Rpresent ty]; row_more=newvar();
                      row_bound=(); row_name=None;
                      row_fixed=false; row_closed=false})
  | Tpat_record (lpl,_) ->
      let lbl = snd3 (List.hd lpl) in
      if lbl.lbl_private = Private then p.pat_type else
      let ty = newvar () in
      let ppl = List.map (fun (_, l, p) -> l.lbl_pos, p) lpl in
      let do_label lbl =
        let _, ty_arg, ty_res = instance_label false lbl in
        unify_pat env {p with pat_type = ty} ty_res;
        let refinable =
          lbl.lbl_mut = Immutable && List.mem_assoc lbl.lbl_pos ppl &&
          match (repr lbl.lbl_arg).desc with Tpoly _ -> false | _ -> true in
        if refinable then begin
          let arg = List.assoc lbl.lbl_pos ppl in
          unify_pat env {arg with pat_type = build_as_type env arg} ty_arg
        end else begin
          let _, ty_arg', ty_res' = instance_label false lbl in
          unify env ty_arg ty_arg';
          unify_pat env p ty_res'
        end in
      Array.iter do_label lbl.lbl_all;
      ty
  | Tpat_or(p1, p2, row) ->
      begin match row with
        None ->
          let ty1 = build_as_type env p1 and ty2 = build_as_type env p2 in
          unify_pat env {p2 with pat_type = ty2} ty1;
          ty1
      | Some row ->
          let row = row_repr row in
          newty (Tvariant{row with row_closed=false; row_more=newvar()})
      end
  | Tpat_any | Tpat_var _ | Tpat_constant _
  | Tpat_array _ | Tpat_lazy _ -> p.pat_type

let build_or_pat env loc lid =
  let path, decl = Typetexp.find_type env loc lid
  in
  let tyl = List.map (fun _ -> newvar()) decl.type_params in
  let row0 =
    let ty = expand_head env (newty(Tconstr(path, tyl, ref Mnil))) in
    match ty.desc with
      Tvariant row when static_row row -> row
    | _ -> raise(Error(loc, env, Not_a_variant_type lid))
  in
  let pats, fields =
    List.fold_left
      (fun (pats,fields) (l,f) ->
        match row_field_repr f with
          Rpresent None ->
            (l,None) :: pats,
            (l, Reither(true,[], true, ref None)) :: fields
        | Rpresent (Some ty) ->
            (l, Some {pat_desc=Tpat_any; pat_loc=Location.none; pat_env=env;
                      pat_type=ty; pat_extra=[]; pat_attributes=[]})
            :: pats,
            (l, Reither(false, [ty], true, ref None)) :: fields
        | _ -> pats, fields)
      ([],[]) (row_repr row0).row_fields in
  let row =
    { row_fields = List.rev fields; row_more = newvar(); row_bound = ();
      row_closed = false; row_fixed = false; row_name = Some (path, tyl) }
  in
  let ty = newty (Tvariant row) in
  let gloc = {loc with Location.loc_ghost=true} in
  let row' = ref {row with row_more=newvar()} in
  let pats =
    List.map
      (fun (l,p) ->
        {pat_desc=Tpat_variant(l,p,row'); pat_loc=gloc;
         pat_env=env; pat_type=ty; pat_extra=[]; pat_attributes=[]})
      pats
  in
  match pats with
    [] -> raise(Error(loc, env, Not_a_variant_type lid))
  | pat :: pats ->
      let r =
        List.fold_left
          (fun pat pat0 ->
            {pat_desc=Tpat_or(pat0,pat,Some row0); pat_extra=[];
             pat_loc=gloc; pat_env=env; pat_type=ty; pat_attributes=[]})
          pat pats in
      (path, rp { r with pat_loc = loc },ty)

(* Type paths *)

let rec expand_path env p =
  let decl =
    try Some (Env.find_type p env) with Not_found -> None
  in
  match decl with
    Some {type_manifest = Some ty} ->
      begin match repr ty with
        {desc=Tconstr(p,_,_)} -> expand_path env p
      | _ -> p
         (* PR#6394: recursive module may introduce incoherent manifest *)
      end
  | _ ->
      let p' = Env.normalize_path None env p in
      if Path.same p p' then p else expand_path env p'

let compare_type_path env tpath1 tpath2 =
  Path.same (expand_path env tpath1) (expand_path env tpath2)

(* Records *)

module NameChoice(Name : sig
  type t
  val type_kind: string
  val get_name: t -> string
  val get_type: t -> type_expr
  val get_descrs: Env.type_descriptions -> t list
  val fold: (t -> 'a -> 'a) -> Longident.t option -> Env.t -> 'a -> 'a
  val unbound_name_error: Env.t -> Longident.t loc -> 'a
end) = struct
  open Name

  let get_type_path env d =
    match (get_type d).desc with
    | Tconstr(p, _, _) -> p
    | _ -> assert false

  let spellcheck ppf env p lid =
    Typetexp.spellcheck_simple ppf fold
      (fun d ->
        if compare_type_path env p (get_type_path env d)
        then get_name d else "") env lid

  let lookup_from_type env tpath lid =
    let descrs = get_descrs (Env.find_type_descrs tpath env) in
    Env.mark_type_used env (Path.last tpath) (Env.find_type tpath env);
    match lid.txt with
      Longident.Lident s -> begin
        try
          List.find (fun nd -> get_name nd = s) descrs
        with Not_found ->
          raise (Error (lid.loc, env,
                        Wrong_name ("", newvar (), type_kind, tpath, lid.txt)))
      end
    | _ -> raise Not_found

  let rec unique eq acc = function
      [] -> List.rev acc
    | x :: rem ->
        if List.exists (eq x) acc then unique eq acc rem
        else unique eq (x :: acc) rem

  let ambiguous_types env lbl others =
    let tpath = get_type_path env lbl in
    let others =
      List.map (fun (lbl, _) -> get_type_path env lbl) others in
    let tpaths = unique (compare_type_path env) [tpath] others in
    match tpaths with
      [_] -> []
    | _ -> List.map Printtyp.string_of_path tpaths

  let disambiguate_by_type env tpath lbls =
    let check_type (lbl, _) =
      let lbl_tpath = get_type_path env lbl in
      compare_type_path env tpath lbl_tpath
    in
    List.find check_type lbls

  let disambiguate ?(warn=Location.prerr_warning) ?(check_lk=fun _ _ -> ())
      ?scope lid env opath lbls =
    let scope = match scope with None -> lbls | Some l -> l in
    let lbl = match opath with
      None ->
        begin match lbls with
          [] -> unbound_name_error env lid
        | (lbl, use) :: rest ->
            use ();
            let paths = ambiguous_types env lbl rest in
            if paths <> [] then
              warn lid.loc
                (Warnings.Ambiguous_name ([Longident.last lid.txt],
                                          paths, false));
            lbl
        end
    | Some(tpath0, tpath, pr) ->
        let warn_pr () =
          let kind = if type_kind = "record" then "field" else "constructor" in
          warn lid.loc
            (Warnings.Not_principal
               ("this type-based " ^ kind ^ " disambiguation"))
        in
        try
          let lbl, use = disambiguate_by_type env tpath scope in
          use ();
          if not pr then begin
            (* Check if non-principal type is affecting result *)
            match lbls with
              [] -> warn_pr ()
            | (lbl', use') :: rest ->
                let lbl_tpath = get_type_path env lbl' in
                if not (compare_type_path env tpath lbl_tpath) then warn_pr ()
                else
                  let paths = ambiguous_types env lbl rest in
                  if paths <> [] then
                    warn lid.loc
                      (Warnings.Ambiguous_name ([Longident.last lid.txt],
                                                paths, false))
          end;
          lbl
        with Not_found -> try
          let lbl = lookup_from_type env tpath lid in
          check_lk tpath lbl;
          let s = Printtyp.string_of_path tpath in
          warn lid.loc
            (Warnings.Name_out_of_scope (s, [Longident.last lid.txt], false));
          if not pr then warn_pr ();
          lbl
        with Not_found ->
          if lbls = [] then unbound_name_error env lid else
          let tp = (tpath0, expand_path env tpath) in
          let tpl =
            List.map
              (fun (lbl, _) ->
                let tp0 = get_type_path env lbl in
                let tp = expand_path env tp0 in
                  (tp0, tp))
              lbls
          in
          raise (Error (lid.loc, env,
                        Name_type_mismatch (type_kind, lid.txt, tp, tpl)))
    in
    begin match scope with
      (lab1,_)::_ when lab1 == lbl -> ()
    | _ ->
        Location.prerr_warning lid.loc
          (Warnings.Disambiguated_name(get_name lbl))
    end;
    lbl
end

let wrap_disambiguate kind ty f x =
  try f x with Error (loc, env, Wrong_name (_,_,tk,tp,lid)) ->
    raise (Error (loc, env, Wrong_name (kind,ty,tk,tp,lid)))

module Label = NameChoice (struct
  type t = label_description
  let type_kind = "record"
  let get_name lbl = lbl.lbl_name
  let get_type lbl = lbl.lbl_res
  let get_descrs = snd
  let fold = Env.fold_labels
  let unbound_name_error = Typetexp.unbound_label_error
end)

let disambiguate_label_by_ids keep env closed ids labels =
  let check_ids (lbl, _) =
    let lbls = Hashtbl.create 8 in
    Array.iter (fun lbl -> Hashtbl.add lbls lbl.lbl_name ()) lbl.lbl_all;
    List.for_all (Hashtbl.mem lbls) ids
  and check_closed (lbl, _) =
    (not closed || List.length ids = Array.length lbl.lbl_all)
  in
  let labels' = List.filter check_ids labels in
  if keep && labels' = [] then (false, labels) else
  let labels'' = List.filter check_closed labels' in
  if keep && labels'' = [] then (false, labels') else (true, labels'')

(* Only issue warnings once per record constructor/pattern *)
let disambiguate_lid_a_list loc closed env opath lid_a_list =
  let ids = List.map (fun (lid, _) -> Longident.last lid.txt) lid_a_list in
  let w_pr = ref false and w_amb = ref []
  and w_scope = ref [] and w_scope_ty = ref "" in
  let warn loc msg =
    let open Warnings in
    match msg with
    | Not_principal _ -> w_pr := true
    | Ambiguous_name([s], l, _) -> w_amb := (s, l) :: !w_amb
    | Name_out_of_scope(ty, [s], _) ->
        w_scope := s :: !w_scope; w_scope_ty := ty
    | _ -> Location.prerr_warning loc msg
  in
  let process_label lid =
    (* Strategy for each field:
       * collect all the labels in scope for that name
       * if the type is known and principal, just eventually warn
         if the real label was not in scope
       * fail if there is no known type and no label found
       * otherwise use other fields to reduce the list of candidates
       * if there is no known type reduce it incrementally, so that
         there is still at least one candidate (for error message)
       * if the reduced list is valid, call Label.disambiguate
     *)
    let scope = Typetexp.find_all_labels env lid.loc lid.txt in
    if opath = None && scope = [] then
      Typetexp.unbound_label_error env lid;
    let (ok, labels) =
      match opath with
        Some (_, _, true) -> (true, scope) (* disambiguate only checks scope *)
      | _  -> disambiguate_label_by_ids (opath=None) env closed ids scope
    in
    if ok then Label.disambiguate lid env opath labels ~warn ~scope
          else fst (List.hd labels) (* will fail later *)
  in
  let lbl_a_list =
    List.map (fun (lid,a) -> lid, process_label lid, a) lid_a_list in
  if !w_pr then
    Location.prerr_warning loc
      (Warnings.Not_principal "this type-based record disambiguation")
  else begin
    match List.rev !w_amb with
      (_,types)::others as amb ->
        let paths =
          List.map (fun (_,lbl,_) -> Label.get_type_path env lbl) lbl_a_list in
        let path = List.hd paths in
        if List.for_all (compare_type_path env path) (List.tl paths) then
          Location.prerr_warning loc
            (Warnings.Ambiguous_name (List.map fst amb, types, true))
        else
          List.iter
            (fun (s,l) -> Location.prerr_warning loc
                (Warnings.Ambiguous_name ([s],l,false)))
            amb
    | _ -> ()
  end;
  if !w_scope <> [] then
    Location.prerr_warning loc
      (Warnings.Name_out_of_scope (!w_scope_ty, List.rev !w_scope, true));
  lbl_a_list

let rec find_record_qual = function
  | [] -> None
  | ({ txt = Longident.Ldot (modname, _) }, _) :: _ -> Some modname
  | _ :: rest -> find_record_qual rest

let type_label_a_list ?labels loc closed env type_lbl_a opath lid_a_list =
  let lbl_a_list =
    match lid_a_list, labels with
      ({txt=Longident.Lident s}, _)::_, Some labels when Hashtbl.mem labels s ->
        (* Special case for rebuilt syntax trees *)
        List.map
          (function lid, a -> match lid.txt with
            Longident.Lident s -> lid, Hashtbl.find labels s, a
          | _ -> assert false)
          lid_a_list
    | _ ->
        let lid_a_list =
          match find_record_qual lid_a_list with
            None -> lid_a_list
          | Some modname ->
              List.map
                (fun (lid, a as lid_a) ->
                  match lid.txt with Longident.Lident s ->
                    {lid with txt=Longident.Ldot (modname, s)}, a
                  | _ -> lid_a)
                lid_a_list
        in
        disambiguate_lid_a_list loc closed env opath lid_a_list
  in
  (* Invariant: records are sorted in the typed tree *)
  let lbl_a_list =
    List.sort
      (fun (_,lbl1,_) (_,lbl2,_) -> compare lbl1.lbl_pos lbl2.lbl_pos)
      lbl_a_list
  in
  List.map type_lbl_a lbl_a_list
;;

(* Checks over the labels mentioned in a record pattern:
   no duplicate definitions (error); properly closed (warning) *)

let check_recordpat_labels loc lbl_pat_list closed =
  match lbl_pat_list with
  | [] -> ()                            (* should not happen *)
  | (_, label1, _) :: _ ->
      let all = label1.lbl_all in
      let defined = Array.make (Array.length all) false in
      let check_defined (_, label, _) =
        if defined.(label.lbl_pos)
        then raise(Error(loc, Env.empty, Label_multiply_defined label.lbl_name))
        else defined.(label.lbl_pos) <- true in
      List.iter check_defined lbl_pat_list;
      if closed = Closed
      && Warnings.is_active (Warnings.Non_closed_record_pattern "")
      then begin
        let undefined = ref [] in
        for i = 0 to Array.length all - 1 do
          if not defined.(i) then undefined := all.(i).lbl_name :: !undefined
        done;
        if !undefined <> [] then begin
          let u = String.concat ", " (List.rev !undefined) in
          Location.prerr_warning loc (Warnings.Non_closed_record_pattern u)
        end
      end

(* Constructors *)

module Constructor = NameChoice (struct
  type t = constructor_description
  let type_kind = "variant"
  let get_name cstr = cstr.cstr_name
  let get_type cstr = cstr.cstr_res
  let get_descrs = fst
  let fold = Env.fold_constructors
  let unbound_name_error = Typetexp.unbound_constructor_error
end)

(* unification of a type with a tconstr with
   freshly created arguments *)
let unify_head_only loc env ty constr =
  let (_, ty_res) = instance_constructor constr in
  match (repr ty_res).desc with
  | Tconstr(p,args,m) ->
      ty_res.desc <- Tconstr(p,List.map (fun _ -> newvar ()) args,m);
      enforce_constraints env ty_res;
      unify_pat_types loc env ty_res ty
  | _ -> assert false

(* Typing of patterns *)

(* type_pat does not generate local constraints inside or patterns *)
type type_pat_mode =
  | Normal
  | Inside_or

(* type_pat propagates the expected type as well as maps for
   constructors and labels.
   Unification may update the typing environment. *)
let rec type_pat ~constrs ~labels ~no_existentials ~mode ~env sp expected_ty =
  let type_pat ?(mode=mode) ?(env=env) =
    type_pat ~constrs ~labels ~no_existentials ~mode ~env in
  let loc = sp.ppat_loc in
  match sp.ppat_desc with
    Ppat_any ->
      rp {
        pat_desc = Tpat_any;
        pat_loc = loc; pat_extra=[];
        pat_type = expected_ty;
        pat_attributes = sp.ppat_attributes;
        pat_env = !env }
  | Ppat_var name ->
      let id = enter_variable loc name expected_ty in
      rp {
        pat_desc = Tpat_var (id, name);
        pat_loc = loc; pat_extra=[];
        pat_type = expected_ty;
        pat_attributes = sp.ppat_attributes;
        pat_env = !env }
  | Ppat_unpack name ->
      let id = enter_variable loc name expected_ty ~is_module:true in
      rp {
        pat_desc = Tpat_var (id, name);
        pat_loc = sp.ppat_loc;
        pat_extra=[Tpat_unpack, loc, sp.ppat_attributes];
        pat_type = expected_ty;
        pat_attributes = [];
        pat_env = !env }
  | Ppat_constraint({ppat_desc=Ppat_var name; ppat_loc=lloc},
                    ({ptyp_desc=Ptyp_poly _} as sty)) ->
      (* explicitly polymorphic type *)
      let cty, force = Typetexp.transl_simple_type_delayed !env sty in
      let ty = cty.ctyp_type in
      unify_pat_types lloc !env ty expected_ty;
      pattern_force := force :: !pattern_force;
      begin match ty.desc with
      | Tpoly (body, tyl) ->
          begin_def ();
          let _, ty' = instance_poly ~keep_names:true false tyl body in
          end_def ();
          generalize ty';
          let id = enter_variable lloc name ty' in
          rp {
            pat_desc = Tpat_var (id, name);
            pat_loc = lloc;
            pat_extra = [Tpat_constraint cty, loc, sp.ppat_attributes];
            pat_type = ty;
            pat_attributes = [];
            pat_env = !env
          }
      | _ -> assert false
      end
  | Ppat_alias(sq, name) ->
      let q = type_pat sq expected_ty in
      begin_def ();
      let ty_var = build_as_type !env q in
      end_def ();
      generalize ty_var;
      let id = enter_variable ~is_as_variable:true loc name ty_var in
      rp {
        pat_desc = Tpat_alias(q, id, name);
        pat_loc = loc; pat_extra=[];
        pat_type = q.pat_type;
        pat_attributes = sp.ppat_attributes;
        pat_env = !env }
  | Ppat_constant cst ->
      unify_pat_types loc !env (type_constant cst) expected_ty;
      rp {
        pat_desc = Tpat_constant cst;
        pat_loc = loc; pat_extra=[];
        pat_type = expected_ty;
        pat_attributes = sp.ppat_attributes;
        pat_env = !env }
  | Ppat_interval (Const_char c1, Const_char c2) ->
      let open Ast_helper.Pat in
      let gloc = {loc with Location.loc_ghost=true} in
      let rec loop c1 c2 =
        if c1 = c2 then constant ~loc:gloc (Const_char c1)
        else
          or_ ~loc:gloc
            (constant ~loc:gloc (Const_char c1))
            (loop (Char.chr(Char.code c1 + 1)) c2)
      in
      let p = if c1 <= c2 then loop c1 c2 else loop c2 c1 in
      let p = {p with ppat_loc=loc} in
      type_pat p expected_ty
        (* TODO: record 'extra' to remember about interval *)
  | Ppat_interval _ ->
      raise (Error (loc, !env, Invalid_interval))
  | Ppat_tuple spl ->
      if List.length spl < 2 then
        Syntaxerr.ill_formed_ast loc "Tuples must have at least 2 components.";
      let spl_ann = List.map (fun p -> (p,newvar ())) spl in
      let ty = newty (Ttuple(List.map snd spl_ann)) in
      unify_pat_types loc !env ty expected_ty;
      let pl = List.map (fun (p,t) -> type_pat p t) spl_ann in
      rp {
        pat_desc = Tpat_tuple pl;
        pat_loc = loc; pat_extra=[];
        pat_type = expected_ty;
        pat_attributes = sp.ppat_attributes;
        pat_env = !env }
  | Ppat_construct(lid, sarg) ->
      let opath =
        try
          let (p0, p, _) = extract_concrete_variant !env expected_ty in
            Some (p0, p, true)
        with Not_found -> None
      in
      let constrs =
        match lid.txt, constrs with
          Longident.Lident s, Some constrs when Hashtbl.mem constrs s ->
            [Hashtbl.find constrs s, (fun () -> ())]
        | _ ->  Typetexp.find_all_constructors !env lid.loc lid.txt
      in
      let check_lk tpath constr =
        if constr.cstr_generalized then
          raise (Error (lid.loc, !env,
                        Unqualified_gadt_pattern (tpath, constr.cstr_name)))
      in
      let constr =
        wrap_disambiguate "This variant pattern is expected to have" expected_ty
          (Constructor.disambiguate lid !env opath ~check_lk) constrs
      in
      Env.mark_constructor Env.Pattern !env (Longident.last lid.txt) constr;
      Typetexp.check_deprecated loc constr.cstr_attributes constr.cstr_name;
      if no_existentials && constr.cstr_existentials <> [] then
        raise (Error (loc, !env, Unexpected_existential));
      (* if constructor is gadt, we must verify that the expected type has the
         correct head *)
      if constr.cstr_generalized then
        unify_head_only loc !env expected_ty constr;
      let sargs =
        match sarg with
          None -> []
        | Some {ppat_desc = Ppat_tuple spl} when
            constr.cstr_arity > 1 || explicit_arity sp.ppat_attributes
          -> spl
        | Some({ppat_desc = Ppat_any} as sp) when constr.cstr_arity <> 1 ->
            if constr.cstr_arity = 0 then
              Location.prerr_warning sp.ppat_loc
                                     Warnings.Wildcard_arg_to_constant_constr;
            replicate_list sp constr.cstr_arity
        | Some sp -> [sp] in
      if List.length sargs <> constr.cstr_arity then
        raise(Error(loc, !env, Constructor_arity_mismatch(lid.txt,
                                     constr.cstr_arity, List.length sargs)));
      let (ty_args, ty_res) =
        instance_constructor ~in_pattern:(env, get_newtype_level ()) constr
      in
      if constr.cstr_generalized && mode = Normal then
        unify_pat_types_gadt loc env ty_res expected_ty
      else
        unify_pat_types loc !env ty_res expected_ty;
      let args = List.map2 (fun p t -> type_pat p t) sargs ty_args in
      rp {
        pat_desc=Tpat_construct(lid, constr, args);
        pat_loc = loc; pat_extra=[];
        pat_type = expected_ty;
        pat_attributes = sp.ppat_attributes;
        pat_env = !env }
  | Ppat_variant(l, sarg) ->
      let arg_type = match sarg with None -> [] | Some _ -> [newvar()] in
      let row = { row_fields =
                    [l, Reither(sarg = None, arg_type, true, ref None)];
                  row_bound = ();
                  row_closed = false;
                  row_more = newvar ();
                  row_fixed = false;
                  row_name = None } in
      unify_pat_types loc !env (newty (Tvariant row)) expected_ty;
      let arg =
        (* PR#6235: propagate type information *)
        match sarg, arg_type with
          Some p, [ty] -> Some (type_pat p ty)
        | _            -> None
      in
      rp {
        pat_desc = Tpat_variant(l, arg, ref {row with row_more = newvar()});
        pat_loc = loc; pat_extra=[];
        pat_type =  expected_ty;
        pat_attributes = sp.ppat_attributes;
        pat_env = !env }
  | Ppat_record(lid_sp_list, closed) ->
      if lid_sp_list = [] then
        Syntaxerr.ill_formed_ast loc "Records cannot be empty.";
      let opath, record_ty =
        try
          let (p0, p,_) = extract_concrete_record !env expected_ty in
          Some (p0, p, true), expected_ty
        with Not_found -> None, newvar ()
      in
      let type_label_pat (label_lid, label, sarg) =
        begin_def ();
        let (vars, ty_arg, ty_res) = instance_label false label in
        if vars = [] then end_def ();
        begin try
          unify_pat_types loc !env ty_res record_ty
        with Unify trace ->
          raise(Error(label_lid.loc, !env,
                      Label_mismatch(label_lid.txt, trace)))
        end;
        let arg = type_pat sarg ty_arg in
        if vars <> [] then begin
          end_def ();
          generalize ty_arg;
          List.iter generalize vars;
          let instantiated tv =
            let tv = expand_head !env tv in
            not (is_Tvar tv) || tv.level <> generic_level in
          if List.exists instantiated vars then
            raise (Error(label_lid.loc, !env, Polymorphic_label label_lid.txt))
        end;
        (label_lid, label, arg)
      in
      let lbl_pat_list =
        wrap_disambiguate "This record pattern is expected to have" expected_ty
          (type_label_a_list ?labels loc false !env type_label_pat opath)
          lid_sp_list
      in
      check_recordpat_labels loc lbl_pat_list closed;
      unify_pat_types loc !env record_ty expected_ty;
      rp {
        pat_desc = Tpat_record (lbl_pat_list, closed);
        pat_loc = loc; pat_extra=[];
        pat_type = expected_ty;
        pat_attributes = sp.ppat_attributes;
        pat_env = !env }
  | Ppat_array spl ->
      let ty_elt = newvar() in
      unify_pat_types
        loc !env (instance_def (Predef.type_array ty_elt)) expected_ty;
      let spl_ann = List.map (fun p -> (p,newvar())) spl in
      let pl = List.map (fun (p,t) -> type_pat p ty_elt) spl_ann in
      rp {
        pat_desc = Tpat_array pl;
        pat_loc = loc; pat_extra=[];
        pat_type = expected_ty;
        pat_attributes = sp.ppat_attributes;
        pat_env = !env }
  | Ppat_or(sp1, sp2) ->
      let initial_pattern_variables = !pattern_variables in
      let p1 = type_pat ~mode:Inside_or sp1 expected_ty in
      let p1_variables = !pattern_variables in
      pattern_variables := initial_pattern_variables;
      let p2 = type_pat ~mode:Inside_or sp2 expected_ty in
      let p2_variables = !pattern_variables in
      let alpha_env =
        enter_orpat_variables loc !env p1_variables p2_variables in
      pattern_variables := p1_variables;
      rp {
        pat_desc = Tpat_or(p1, alpha_pat alpha_env p2, None);
        pat_loc = loc; pat_extra=[];
        pat_type = expected_ty;
        pat_attributes = sp.ppat_attributes;
        pat_env = !env }
  | Ppat_lazy sp1 ->
      let nv = newvar () in
      unify_pat_types loc !env (instance_def (Predef.type_lazy_t nv))
        expected_ty;
      let p1 = type_pat sp1 nv in
      rp {
        pat_desc = Tpat_lazy p1;
        pat_loc = loc; pat_extra=[];
        pat_type = expected_ty;
        pat_attributes = sp.ppat_attributes;
        pat_env = !env }
  | Ppat_constraint(sp, sty) ->
      (* Separate when not already separated by !principal *)
      let separate = true in
      if separate then begin_def();
      let cty, force = Typetexp.transl_simple_type_delayed !env sty in
      let ty = cty.ctyp_type in
      let ty, expected_ty' =
        if separate then begin
          end_def();
          generalize_structure ty;
          instance !env ty, instance !env ty
        end else ty, ty
      in
      unify_pat_types loc !env ty expected_ty;
      let p = type_pat sp expected_ty' in
      (*Format.printf "%a@.%a@."
        Printtyp.raw_type_expr ty
        Printtyp.raw_type_expr p.pat_type;*)
      pattern_force := force :: !pattern_force;
      let extra = (Tpat_constraint cty, loc, sp.ppat_attributes) in
      if separate then
        match p.pat_desc with
          Tpat_var (id,s) ->
            {p with pat_type = ty;
             pat_desc = Tpat_alias
               ({p with pat_desc = Tpat_any; pat_attributes = []}, id,s);
             pat_extra = [extra];
            }
        | _ -> {p with pat_type = ty;
                pat_extra = extra :: p.pat_extra}
      else p
  | Ppat_type lid ->
      let (path, p,ty) = build_or_pat !env loc lid.txt in
      unify_pat_types loc !env ty expected_ty;
      { p with pat_extra =
        (Tpat_type (path, lid), loc, sp.ppat_attributes) :: p.pat_extra }
  | Ppat_exception _ ->
      raise (Error (loc, !env, Exception_pattern_below_toplevel))
  | Ppat_extension ext ->
      raise (Error_forward (Typetexp.error_of_extension ext))

let type_pat ?(allow_existentials=false) ?constrs ?labels
    ?(lev=get_current_level()) env sp expected_ty =
  newtype_level := Some lev;
  try
    let r =
      type_pat ~no_existentials:(not allow_existentials) ~constrs ~labels
        ~mode:Normal ~env sp expected_ty in
    iter_pattern (fun p -> p.pat_env <- !env) r;
    newtype_level := None;
    r
  with e ->
    newtype_level := None;
    raise e


(* this function is passed to Partial.parmatch
   to type check gadt nonexhaustiveness *)
let partial_pred ~lev env expected_ty constrs labels p =
  let snap = snapshot () in
  try
    reset_pattern None true;
    let typed_p =
      type_pat ~allow_existentials:true ~lev
        ~constrs ~labels (ref env) p expected_ty
    in
    backtrack snap;
    (* types are invalidated but we don't need them here *)
    Some typed_p
  with _ ->
    backtrack snap;
    None

let check_partial ?(lev=get_current_level ()) env expected_ty =
  Parmatch.check_partial_gadt (partial_pred ~lev env expected_ty)

let rec iter3 f lst1 lst2 lst3 =
  match lst1,lst2,lst3 with
  | x1::xs1,x2::xs2,x3::xs3 ->
      f x1 x2 x3;
      iter3 f xs1 xs2 xs3
  | [],[],[] ->
      ()
  | _ ->
      assert false

let add_pattern_variables ?check ?check_as env =
  let pv = get_ref pattern_variables in
  (List.fold_right
     (fun (id, ty, name, loc, as_var) env ->
       let check = if as_var then check_as else check in
       Env.add_value ?check id
         {val_type = ty; val_kind = Val_reg; Types.val_loc = loc;
          val_attributes = [];
         } env
     )
     pv env,
   get_ref module_variables)

let type_pattern ~lev env spat scope expected_ty =
  reset_pattern scope true;
  let new_env = ref env in
  let pat = type_pat ~allow_existentials:true ~lev new_env spat expected_ty in
  let new_env, unpacks =
    add_pattern_variables !new_env
      ~check:(fun s -> Warnings.Unused_var_strict s)
      ~check_as:(fun s -> Warnings.Unused_var s) in
  (pat, new_env, get_ref pattern_force, unpacks)

let type_pattern_list env spatl scope expected_tys allow =
  reset_pattern scope allow;
  let new_env = ref env in
  let patl = List.map2 (type_pat new_env) spatl expected_tys in
  let new_env, unpacks = add_pattern_variables !new_env in
  (patl, new_env, get_ref pattern_force, unpacks)

let type_class_arg_pattern cl_num val_env met_env l spat =
  reset_pattern None false;
  let nv = newvar () in
  let pat = type_pat (ref val_env) spat nv in
  if has_variants pat then begin
    Parmatch.pressure_variants val_env [pat];
    iter_pattern finalize_variant pat
  end;
  List.iter (fun f -> f()) (get_ref pattern_force);
  if is_optional l then unify_pat val_env pat (type_option (newvar ()));
  let (pv, met_env) =
    List.fold_right
      (fun (id, ty, name, loc, as_var) (pv, env) ->
         let check s =
           if as_var then Warnings.Unused_var s
           else Warnings.Unused_var_strict s in
         let id' = Ident.create (Ident.name id) in
         ((id', name, id, ty)::pv,
          Env.add_value id' {val_type = ty;
                             val_kind = Val_ivar (Immutable, cl_num);
                             val_attributes = [];
                             Types.val_loc = loc;
                            } ~check
            env))
      !pattern_variables ([], met_env)
  in
  let val_env, _ = add_pattern_variables val_env in
  (pat, pv, val_env, met_env)

let type_self_pattern cl_num privty val_env met_env par_env spat =
  let open Ast_helper in
  let spat =
    Pat.mk (Ppat_alias (Pat.mk(Ppat_alias (spat, mknoloc "selfpat-*")),
                        mknoloc ("selfpat-" ^ cl_num)))
  in
  reset_pattern None false;
  let nv = newvar() in
  let pat = type_pat (ref val_env) spat nv in
  List.iter (fun f -> f()) (get_ref pattern_force);
  let meths = ref Meths.empty in
  let vars = ref Vars.empty in
  let pv = !pattern_variables in
  pattern_variables := [];
  let (val_env, met_env, par_env) =
    List.fold_right
      (fun (id, ty, name, loc, as_var) (val_env, met_env, par_env) ->
         (Env.add_value id {val_type = ty;
                            val_kind = Val_unbound;
                            val_attributes = [];
                            Types.val_loc = loc;
                           } val_env,
          Env.add_value id {val_type = ty;
                            val_kind = Val_self (meths, vars, cl_num, privty);
                            val_attributes = [];
                            Types.val_loc = loc;
                           }
            ~check:(fun s -> if as_var then Warnings.Unused_var s
                             else Warnings.Unused_var_strict s)
            met_env,
          Env.add_value id {val_type = ty; val_kind = Val_unbound;
                            val_attributes = [];
                            Types.val_loc = loc;
                           } par_env))
      pv (val_env, met_env, par_env)
  in
  (pat, meths, vars, val_env, met_env, par_env)

let delayed_checks = ref []
let reset_delayed_checks () = delayed_checks := []
let add_delayed_check f =
  delayed_checks := (f, Warnings.backup ()) :: !delayed_checks

let force_delayed_checks () =
  (* checks may change type levels *)
  let snap = Btype.snapshot () in
  let w_old = Warnings.backup () in
  List.iter
    (fun (f, w) -> Warnings.restore w; f ())
    (List.rev !delayed_checks);
  Warnings.restore w_old;
  reset_delayed_checks ();
  Btype.backtrack snap

let rec final_subexpression sexp =
  match sexp.pexp_desc with
    Pexp_let (_, _, e)
  | Pexp_sequence (_, e)
  | Pexp_try (e, _)
  | Pexp_ifthenelse (_, e, _)
  | Pexp_match (_, {pc_rhs=e} :: _)
    -> final_subexpression e
  | _ -> sexp

(* Generalization criterion for expressions *)

let rec is_nonexpansive exp =
  match exp.exp_desc with
    Texp_ident(_,_,_) -> true
  | Texp_constant _ -> true
  | Texp_let(rec_flag, pat_exp_list, body) ->
      List.for_all (fun vb -> is_nonexpansive vb.vb_expr) pat_exp_list &&
      is_nonexpansive body
  | Texp_function _ -> true
  | Texp_apply(e, (_,None,_)::el) ->
      is_nonexpansive e && List.for_all is_nonexpansive_opt (List.map snd3 el)
  | Texp_match(e, cases, [], _) ->
      is_nonexpansive e &&
      List.for_all
        (fun {c_lhs = _; c_guard; c_rhs} ->
           is_nonexpansive_opt c_guard && is_nonexpansive c_rhs
        ) cases
  | Texp_tuple el ->
      List.for_all is_nonexpansive el
  | Texp_construct( _, _, el) ->
      List.for_all is_nonexpansive el
  | Texp_variant(_, arg) -> is_nonexpansive_opt arg
  | Texp_record(lbl_exp_list, opt_init_exp) ->
      List.for_all
        (fun (_, lbl, exp) -> lbl.lbl_mut = Immutable && is_nonexpansive exp)
        lbl_exp_list
      && is_nonexpansive_opt opt_init_exp
  | Texp_field(exp, lbl, _) -> is_nonexpansive exp
  | Texp_array [] -> true
  | Texp_ifthenelse(cond, ifso, ifnot) ->
      is_nonexpansive ifso && is_nonexpansive_opt ifnot
  | Texp_sequence (e1, e2) -> is_nonexpansive e2  (* PR#4354 *)
  | Texp_new (_, _, cl_decl) when Ctype.class_type_arity cl_decl.cty_type > 0 ->
      true
  (* Note: nonexpansive only means no _observable_ side effects *)
  | Texp_lazy e -> is_nonexpansive e
  | Texp_object ({cstr_fields=fields; cstr_type = { csig_vars=vars}}, _) ->
      let count = ref 0 in
      List.for_all
        (fun field -> match field.cf_desc with
            Tcf_method _ -> true
          | Tcf_val (_, _, _, Tcfk_concrete (_, e), _) ->
              incr count; is_nonexpansive e
          | Tcf_val (_, _, _, Tcfk_virtual _, _) ->
              incr count; true
          | Tcf_initializer e -> is_nonexpansive e
          | Tcf_constraint _ -> true
          | Tcf_inherit _ -> false
          | Tcf_attribute _ -> true)
        fields &&
      Vars.fold (fun _ (mut,_,_) b -> decr count; b && mut = Immutable)
        vars true &&
      !count = 0
  | Texp_letmodule (_, _, mexp, e) ->
      is_nonexpansive_mod mexp && is_nonexpansive e
  | Texp_pack mexp ->
      is_nonexpansive_mod mexp
  | _ -> false

and is_nonexpansive_mod mexp =
  match mexp.mod_desc with
  | Tmod_ident _ -> true
  | Tmod_functor _ -> true
  | Tmod_unpack (e, _) -> is_nonexpansive e
  | Tmod_constraint (m, _, _, _) -> is_nonexpansive_mod m
  | Tmod_structure str ->
      List.for_all
        (fun item -> match item.str_desc with
          | Tstr_eval _ | Tstr_primitive _ | Tstr_type _
          | Tstr_modtype _ | Tstr_open _ | Tstr_class_type _  -> true
          | Tstr_value (_, pat_exp_list) ->
              List.for_all (fun vb -> is_nonexpansive vb.vb_expr) pat_exp_list
          | Tstr_module {mb_expr=m;_}
          | Tstr_include {incl_mod=m;_} -> is_nonexpansive_mod m
          | Tstr_recmodule id_mod_list ->
              List.for_all (fun {mb_expr=m;_} -> is_nonexpansive_mod m)
                id_mod_list
          | Tstr_exception {ext_kind = Text_decl _} ->
              false (* true would be unsound *)
          | Tstr_exception {ext_kind = Text_rebind _} -> true
          | Tstr_typext te ->
              List.for_all
                (function {ext_kind = Text_decl _} -> false
                        | {ext_kind = Text_rebind _} -> true)
                te.tyext_constructors
          | Tstr_class _ -> false (* could be more precise *)
          | Tstr_attribute _ -> true
        )
        str.str_items
  | Tmod_apply _ -> false

and is_nonexpansive_opt = function
    None -> true
  | Some e -> is_nonexpansive e

(* Approximate the type of an expression, for better recursion *)

let rec approx_type env sty =
  match sty.ptyp_desc with
    Ptyp_arrow (p, _, sty) ->
      let ty1 = if is_optional p then type_option (newvar ()) else newvar () in
      newty (Tarrow (p, ty1, approx_type env sty, Cok))
  | Ptyp_tuple args ->
      newty (Ttuple (List.map (approx_type env) args))
  | Ptyp_constr (lid, ctl) ->
      begin try
        let (path, decl) = Env.lookup_type lid.txt env in
        if List.length ctl <> decl.type_arity then raise Not_found;
        let tyl = List.map (approx_type env) ctl in
        newconstr path tyl
      with Not_found -> newvar ()
      end
  | Ptyp_poly (_, sty) ->
      approx_type env sty
  | _ -> newvar ()

let rec type_approx env sexp =
  match sexp.pexp_desc with
    Pexp_let (_, _, e) -> type_approx env e
  | Pexp_fun (p, _, _, e) when is_optional p ->
       newty (Tarrow(p, type_option (newvar ()), type_approx env e, Cok))
  | Pexp_fun (p,_,_, e) ->
       newty (Tarrow(p, newvar (), type_approx env e, Cok))
  | Pexp_function ({pc_rhs=e}::_) ->
       newty (Tarrow("", newvar (), type_approx env e, Cok))
  | Pexp_match (_, {pc_rhs=e}::_) -> type_approx env e
  | Pexp_try (e, _) -> type_approx env e
  | Pexp_tuple l -> newty (Ttuple(List.map (type_approx env) l))
  | Pexp_ifthenelse (_,e,_) -> type_approx env e
  | Pexp_sequence (_,e) -> type_approx env e
  | Pexp_constraint (e, sty) ->
      let ty = type_approx env e in
      let ty1 = approx_type env sty in
      begin try unify env ty ty1 with Unify trace ->
        raise(Error(sexp.pexp_loc, env, Expr_type_clash trace))
      end;
      ty1
  | Pexp_coerce (e, sty1, sty2) ->
      let approx_ty_opt = function
        | None -> newvar ()
        | Some sty -> approx_type env sty
      in
      let ty = type_approx env e
      and ty1 = approx_ty_opt sty1
      and ty2 = approx_type env sty2 in
      begin try unify env ty ty1 with Unify trace ->
        raise(Error(sexp.pexp_loc, env, Expr_type_clash trace))
      end;
      ty2
  | _ -> newvar ()

(* List labels in a function type, and whether return type is a variable *)
let rec list_labels_aux env visited ls ty_fun =
  let ty = expand_head env ty_fun in
  if List.memq ty visited then
    List.rev ls, false
  else match ty.desc with
    Tarrow (l, _, ty_res, _) ->
      list_labels_aux env (ty::visited) (l::ls) ty_res
  | _ ->
      List.rev ls, is_Tvar ty

let list_labels env ty =
  wrap_trace_gadt_instances env (list_labels_aux env [] []) ty

(* Check that all univars are safe in a type *)
let check_univars env expans kind exp ty_expected vars =
  if expans && not (is_nonexpansive exp) then
    generalize_expansive env exp.exp_type;
  (* need to expand twice? cf. Ctype.unify2 *)
  let vars = List.map (expand_head env) vars in
  let vars = List.map (expand_head env) vars in
  let vars' =
    List.filter
      (fun t ->
        let t = repr t in
        generalize t;
        match t.desc with
          Tvar name when t.level = generic_level ->
            log_type t; t.desc <- Tunivar name; true
        | _ -> false)
      vars in
  if List.length vars = List.length vars' then () else
  let ty = newgenty (Tpoly(repr exp.exp_type, vars'))
  and ty_expected = repr ty_expected in
  raise (Error (exp.exp_loc, env,
                Less_general(kind, [ty, ty; ty_expected, ty_expected])))

(* Check that a type is not a function *)
let check_application_result env statement exp =
  let loc = exp.exp_loc in
  match (expand_head env exp.exp_type).desc with
  | Tarrow _ ->
      Location.prerr_warning exp.exp_loc Warnings.Partial_application
  | Tvar _ -> ()
  | Tconstr (p, _, _) when Path.same p Predef.path_unit -> ()
  | _ ->
      if statement then
        Location.prerr_warning loc Warnings.Statement_type

(* Check that a type is generalizable at some level *)
let generalizable level ty =
  let rec check ty =
    let ty = repr ty in
    if ty.level < lowest_level then () else
    if ty.level <= level then raise Exit else
    (mark_type_node ty; iter_type_expr check ty)
  in
  try check ty; unmark_type ty; true
  with Exit -> unmark_type ty; false

(* Hack to allow coercion of self. Will clean-up later. *)
let self_coercion = ref ([] : (Path.t * Location.t list ref) list)

(* Helpers for packaged modules. *)
let create_package_type loc env (p, l) =
  let s = !Typetexp.transl_modtype_longident loc env p in
  let fields = List.map (fun (name, ct) ->
                           name, Typetexp.transl_simple_type env false ct) l in
  let ty = newty (Tpackage (s,
                    List.map fst l,
                   List.map (fun (_, cty) -> cty.ctyp_type) fields))
  in
   (s, fields, ty)

 let wrap_unpacks sexp unpacks =
   let open Ast_helper in
   List.fold_left
     (fun sexp (name, loc) ->
       Exp.letmodule ~loc:sexp.pexp_loc
         name
         (Mod.unpack ~loc
            (Exp.ident ~loc:name.loc (mkloc (Longident.Lident name.txt) name.loc)))
         sexp
     )
    sexp unpacks

(* Helpers for type_cases *)

let contains_variant_either ty =
  let rec loop ty =
    let ty = repr ty in
    if ty.level >= lowest_level then begin
      mark_type_node ty;
      match ty.desc with
        Tvariant row ->
          let row = row_repr row in
          if not row.row_fixed then
            List.iter
              (fun (_,f) ->
                match row_field_repr f with Reither _ -> raise Exit | _ -> ())
              row.row_fields;
          iter_row loop row
      | _ ->
          iter_type_expr loop ty
    end
  in
  try loop ty; unmark_type ty; false
  with Exit -> unmark_type ty; true

let iter_ppat f p =
  match p.ppat_desc with
  | Ppat_any | Ppat_var _ | Ppat_constant _ | Ppat_interval _
  | Ppat_extension _
  | Ppat_type _ | Ppat_unpack _ -> ()
  | Ppat_array pats -> List.iter f pats
  | Ppat_or (p1,p2) -> f p1; f p2
  | Ppat_variant (_, arg) | Ppat_construct (_, arg) -> may f arg
  | Ppat_tuple lst ->  List.iter f lst
  | Ppat_exception p | Ppat_alias (p,_)
  | Ppat_constraint (p,_) | Ppat_lazy p -> f p
  | Ppat_record (args, flag) -> List.iter (fun (_,p) -> f p) args

let contains_polymorphic_variant p =
  let rec loop p =
    match p.ppat_desc with
      Ppat_variant _ | Ppat_type _ -> raise Exit
    | _ -> iter_ppat loop p
  in
  try loop p; false with Exit -> true

let contains_gadt env p =
  let rec loop p =
    match p.ppat_desc with
      Ppat_construct (lid, _) ->
        begin try
          let cstrs = Env.lookup_all_constructors lid.txt env in
          List.iter (fun (cstr,_) -> if cstr.cstr_generalized then raise Exit)
            cstrs
        with Not_found -> ()
        end; iter_ppat loop p
    | _ -> iter_ppat loop p
  in
  try loop p; false with Exit -> true

let check_absent_variant env =
  iter_pattern
    (function {pat_desc = Tpat_variant (s, arg, row)} as pat ->
      let row = row_repr !row in
      if List.exists (fun (s',fi) -> s = s' && row_field_repr fi <> Rabsent)
          row.row_fields
      || not row.row_fixed && not (static_row row)  (* same as Ctype.poly *)
      then () else
      let ty_arg =
        match arg with None -> [] | Some p -> [correct_levels p.pat_type] in
      let row' = {row_fields = [s, Reither(arg=None,ty_arg,true,ref None)];
                  row_more = newvar (); row_bound = ();
                  row_closed = false; row_fixed = false; row_name = None} in
      (* Should fail *)
      unify_pat env {pat with pat_type = newty (Tvariant row')}
                    (correct_levels pat.pat_type)
      | _ -> ())

(* Duplicate types of values in the environment *)
(* XXX Should we do something about global type variables too? *)

let duplicate_ident_types loc caselist env =
  let caselist =
    List.filter (fun {pc_lhs} -> contains_gadt env pc_lhs) caselist in
  let idents = all_idents_cases caselist in
  List.fold_left
    (fun env s ->
      try
        (* XXX This will mark the value as being used;
           I don't think this is what we want *)
        let (path, desc) = Env.lookup_value (Longident.Lident s) env in
        match path with
          Path.Pident id ->
            let desc = {desc with val_type = correct_levels desc.val_type} in
            Env.add_value id desc env
        | _ -> env
      with Not_found -> env)
    env idents

(* Typing of expressions *)

let unify_exp env exp expected_ty =
  (* Format.eprintf "@[%a@ %a@]@." Printtyp.raw_type_expr exp.exp_type
    Printtyp.raw_type_expr expected_ty; *)
    unify_exp_types exp.exp_loc env exp.exp_type expected_ty

let rec type_exp env sexp =
  (* We now delegate everything to type_expect *)
  type_expect env sexp (newvar ())

(* Typing of an expression with an expected type.
   This provide better error messages, and allows controlled
   propagation of return type information.
   In the principal case, [type_expected'] may be at generic_level.
 *)

and type_expect ?in_function env sexp ty_expected =
  let previous_saved_types = Cmt_format.get_saved_types () in
  Typetexp.warning_enter_scope ();
  Typetexp.warning_attribute sexp.pexp_attributes;
  let exp = type_expect_ ?in_function env sexp ty_expected in
  Typetexp.warning_leave_scope ();
  Cmt_format.set_saved_types
    (Cmt_format.Partial_expression exp :: previous_saved_types);
  exp

and type_expect_ ?in_function env sexp ty_expected =
  let loc = sexp.pexp_loc in
  (* Record the expression type before unifying it with the expected type *)
  let rue exp =
    unify_exp env (re exp) (instance env ty_expected);
    exp
  in
  match sexp.pexp_desc with
  | Pexp_ident lid ->
      begin
        let (path, desc) = Typetexp.find_value env loc lid.txt in
        if !Clflags.annotations then begin
          let dloc = desc.Types.val_loc in
          let annot =
            if dloc.Location.loc_ghost then Annot.Iref_external
            else Annot.Iref_internal dloc
          in
          let name = Path.name ~paren:Oprint.parenthesized_ident path in
          Stypes.record (Stypes.An_ident (loc, name, annot))
        end;
        rue {
          exp_desc =
            begin match desc.val_kind with
              Val_ivar (_, cl_num) ->
                let (self_path, _) =
                  Env.lookup_value (Longident.Lident ("self-" ^ cl_num)) env
                in
                Texp_instvar(self_path, path,
                             match lid.txt with
                                 Longident.Lident txt -> { txt; loc = lid.loc }
                               | _ -> assert false)
            | Val_self (_, _, cl_num, _) ->
                let (path, _) =
                  Env.lookup_value (Longident.Lident ("self-" ^ cl_num)) env
                in
                Texp_ident(path, lid, desc)
            | Val_unbound ->
                raise(Error(loc, env, Masked_instance_variable lid.txt))
            (*| Val_prim _ ->
                let p = Env.normalize_path (Some loc) env path in
                Env.add_required_global (Path.head p);
                Texp_ident(path, lid, desc)*)
            | _ ->
                Texp_ident(path, lid, desc)
          end;
          exp_loc = loc; exp_extra = [];
          exp_type = instance env desc.val_type;
          exp_attributes = sexp.pexp_attributes;
          exp_env = env }
      end
  | Pexp_constant(Const_string (str, _) as cst) -> (
    (* Terrible hack for format strings *)
    let ty_exp = expand_head env ty_expected in
    let fmt6_path =
      Path.(Pdot (Pident (Ident.create_persistent "CamlinternalFormatBasics"),
                  "format6", 0)) in
    let is_format = match ty_exp.desc with
      | Tconstr(path, _, _) when Path.same path fmt6_path ->
        if !Clflags.principal && ty_exp.level <> generic_level then
          Location.prerr_warning loc
            (Warnings.Not_principal "this coercion to format6");
        true
      | _ -> false
    in
    if is_format then
      let format_parsetree =
        { (type_format loc str env) with pexp_loc = sexp.pexp_loc }  in
      type_expect ?in_function env format_parsetree ty_expected
    else
      rue {
        exp_desc = Texp_constant cst;
        exp_loc = loc; exp_extra = [];
        exp_type = instance_def Predef.type_string;
        exp_attributes = sexp.pexp_attributes;
        exp_env = env }
  )
  | Pexp_constant cst ->
      rue {
        exp_desc = Texp_constant cst;
        exp_loc = loc; exp_extra = [];
        exp_type = type_constant cst;
        exp_attributes = sexp.pexp_attributes;
        exp_env = env }
  | Pexp_let(Nonrecursive,
             [{pvb_pat=spat; pvb_expr=sval; pvb_attributes=[]}], sbody)
    when contains_gadt env spat ->
    (* TODO: allow non-empty attributes? *)
      type_expect ?in_function env
        {sexp with
         pexp_desc = Pexp_match (sval, [Ast_helper.Exp.case spat sbody])}
        ty_expected
  | Pexp_let(rec_flag, spat_sexp_list, sbody) ->
      let scp =
        match sexp.pexp_attributes, rec_flag with
        | [{txt="#default"},_], _ -> None
        | _, Recursive -> Some (Annot.Idef loc)
        | _, Nonrecursive -> Some (Annot.Idef sbody.pexp_loc)
      in
      let (pat_exp_list, new_env, unpacks) =
        type_let env rec_flag spat_sexp_list scp true in
      let body =
        type_expect new_env (wrap_unpacks sbody unpacks) ty_expected in
      re {
        exp_desc = Texp_let(rec_flag, pat_exp_list, body);
        exp_loc = loc; exp_extra = [];
        exp_type = body.exp_type;
        exp_attributes = sexp.pexp_attributes;
        exp_env = env }
  | Pexp_fun (l, Some default, spat, sexp) ->
      assert(is_optional l); (* default allowed only with optional argument *)
      let open Ast_helper in
      let default_loc = default.pexp_loc in
      let scases = [
        Exp.case
          (Pat.construct ~loc:default_loc
             (mknoloc (Longident.(Ldot (Lident "*predef*", "Some"))))
             (Some (Pat.var ~loc:default_loc (mknoloc "*sth*"))))
          (Exp.ident ~loc:default_loc (mknoloc (Longident.Lident "*sth*")));

        Exp.case
          (Pat.construct ~loc:default_loc
             (mknoloc (Longident.(Ldot (Lident "*predef*", "None"))))
             None)
          default;
       ]
      in
      let smatch =
        Exp.match_ ~loc (Exp.ident ~loc (mknoloc (Longident.Lident "*opt*")))
          scases
      in
      let sfun =
        Exp.fun_ ~loc
          l None
          (Pat.var ~loc (mknoloc "*opt*"))
          (Exp.let_ ~loc Nonrecursive ~attrs:[mknoloc "#default",PStr []]
             [Vb.mk spat smatch] sexp)
      in
      type_expect ?in_function env sfun ty_expected
        (* TODO: keep attributes, call type_function directly *)
  | Pexp_fun (l, None, spat, sexp) ->
      type_function ?in_function loc sexp.pexp_attributes env ty_expected
        l [{pc_lhs=spat; pc_guard=None; pc_rhs=sexp}]
  | Pexp_function caselist ->
      type_function ?in_function
        loc sexp.pexp_attributes env ty_expected "" caselist
  | Pexp_apply(sfunct, sargs) ->
      if sargs = [] then
        Syntaxerr.ill_formed_ast loc "Function application with no argument.";
      begin_def (); (* one more level for non-returning functions *)
      if !Clflags.principal then begin_def ();
      let funct = type_exp env sfunct in
      if !Clflags.principal then begin
          end_def ();
          generalize_structure funct.exp_type
        end;
      let rec lower_args seen ty_fun =
        let ty = expand_head env ty_fun in
        if List.memq ty seen then () else
        match ty.desc with
          Tarrow (l, ty_arg, ty_fun, com) ->
            (try unify_var env (newvar()) ty_arg with Unify _ -> assert false);
            lower_args (ty::seen) ty_fun
        | _ -> ()
      in
      let ty = instance env funct.exp_type in
      end_def ();
      wrap_trace_gadt_instances env (lower_args []) ty;
      begin_def ();
      let (args, ty_res) = type_application env funct sargs in
      end_def ();
      unify_var env (newvar()) funct.exp_type;
      rue {
        exp_desc = Texp_apply(funct, args);
        exp_loc = loc; exp_extra = [];
        exp_type = ty_res;
        exp_attributes = sexp.pexp_attributes;
        exp_env = env }
  | Pexp_match(sarg, caselist) ->
      begin_def ();
      let arg = type_exp env sarg in
      end_def ();
      if is_nonexpansive arg then generalize arg.exp_type
      else generalize_expansive env arg.exp_type;
      let rec split_cases vc ec = function
        | [] -> List.rev vc, List.rev ec
        | {pc_lhs = {ppat_desc=Ppat_exception p}} as c :: rest ->
            split_cases vc ({c with pc_lhs = p} :: ec) rest
        | c :: rest ->
            split_cases (c :: vc) ec rest
      in
      let val_caselist, exn_caselist = split_cases [] [] caselist in
      if val_caselist = [] && exn_caselist <> [] then
        raise (Error (loc, env, No_value_clauses));
      (* Note: val_caselist = [] and exn_caselist = [], i.e. a fully
         empty pattern matching can be generated by Camlp4 with its
         revised syntax.  Let's accept it for backward compatibility. *)
      let val_cases, partial =
        type_cases env arg.exp_type ty_expected true loc val_caselist in
      let exn_cases, _ =
        type_cases env Predef.type_exn ty_expected false loc exn_caselist in
      re {
        exp_desc = Texp_match(arg, val_cases, exn_cases, partial);
        exp_loc = loc; exp_extra = [];
        exp_type = instance env ty_expected;
        exp_attributes = sexp.pexp_attributes;
        exp_env = env }
  | Pexp_try(sbody, caselist) ->
      let body = type_expect env sbody ty_expected in
      let cases, _ =
        type_cases env Predef.type_exn ty_expected false loc caselist in
      re {
        exp_desc = Texp_try(body, cases);
        exp_loc = loc; exp_extra = [];
        exp_type = body.exp_type;
        exp_attributes = sexp.pexp_attributes;
        exp_env = env }
  | Pexp_tuple sexpl ->
      if List.length sexpl < 2 then
        Syntaxerr.ill_formed_ast loc "Tuples must have at least 2 components.";
      let subtypes = List.map (fun _ -> newgenvar ()) sexpl in
      let to_unify = newgenty (Ttuple subtypes) in
      unify_exp_types loc env to_unify ty_expected;
      let expl =
        List.map2 (fun body ty -> type_expect env body ty) sexpl subtypes
      in
      re {
        exp_desc = Texp_tuple expl;
        exp_loc = loc; exp_extra = [];
        (* Keep sharing *)
        exp_type = newty (Ttuple (List.map (fun e -> e.exp_type) expl));
        exp_attributes = sexp.pexp_attributes;
        exp_env = env }
  | Pexp_construct(lid, sarg) ->
      type_construct env loc lid sarg ty_expected sexp.pexp_attributes
  | Pexp_variant(l, sarg) ->
      (* Keep sharing *)
      let ty_expected0 = instance env ty_expected in
      begin try match
        sarg, expand_head env ty_expected, expand_head env ty_expected0 with
      | Some sarg, {desc = Tvariant row}, {desc = Tvariant row0} ->
          let row = row_repr row in
          begin match row_field_repr (List.assoc l row.row_fields),
          row_field_repr (List.assoc l row0.row_fields) with
            Rpresent (Some ty), Rpresent (Some ty0) ->
              let arg = type_argument env sarg ty ty0 in
              re { exp_desc = Texp_variant(l, Some arg);
                   exp_loc = loc; exp_extra = [];
                   exp_type = ty_expected0;
                   exp_attributes = sexp.pexp_attributes;
                   exp_env = env }
          | _ -> raise Not_found
          end
      | _ -> raise Not_found
      with Not_found ->
        let arg = may_map (type_exp env) sarg in
        let arg_type = may_map (fun arg -> arg.exp_type) arg in
        rue {
          exp_desc = Texp_variant(l, arg);
          exp_loc = loc; exp_extra = [];
          exp_type= newty (Tvariant{row_fields = [l, Rpresent arg_type];
                                    row_more = newvar ();
                                    row_bound = ();
                                    row_closed = false;
                                    row_fixed = false;
                                    row_name = None});
          exp_attributes = sexp.pexp_attributes;
          exp_env = env }
      end
  | Pexp_record(lid_sexp_list, opt_sexp) ->
      if lid_sexp_list = [] then
        Syntaxerr.ill_formed_ast loc "Records cannot be empty.";
      let opt_exp =
        match opt_sexp with
          None -> None
        | Some sexp ->
            if !Clflags.principal then begin_def ();
            let exp = type_exp env sexp in
            if !Clflags.principal then begin
              end_def ();
              generalize_structure exp.exp_type
            end;
            Some exp
      in
      let ty_record, opath =
        let get_path ty =
          try
            let (p0, p,_) = extract_concrete_record env ty in
            (* XXX level may be wrong *)
            Some (p0, p, ty.level = generic_level || not !Clflags.principal)
          with Not_found -> None
        in
        match get_path ty_expected with
          None ->
            begin match opt_exp with
              None -> newvar (), None
            | Some exp ->
                match get_path exp.exp_type with
                  None -> newvar (), None
                | Some (_, p', _) as op ->
                    let decl = Env.find_type p' env in
                    begin_def ();
                    let ty =
                      newconstr p' (instance_list env decl.type_params) in
                    end_def ();
                    generalize_structure ty;
                    ty, op
            end
        | op -> ty_expected, op
      in
      let closed = (opt_sexp = None) in
      let lbl_exp_list =
        wrap_disambiguate "This record expression is expected to have" ty_record
          (type_label_a_list loc closed env
             (type_label_exp true env loc ty_record)
             opath)
          lid_sexp_list
      in
      unify_exp_types loc env ty_record (instance env ty_expected);

      (* type_label_a_list returns a list of labels sorted by lbl_pos *)
      (* note: check_duplicates would better be implemented in
         type_label_a_list directly *)
      let rec check_duplicates = function
        | (_, lbl1, _) :: (_, lbl2, _) :: _ when lbl1.lbl_pos = lbl2.lbl_pos ->
          raise(Error(loc, env, Label_multiply_defined lbl1.lbl_name))
        | _ :: rem ->
            check_duplicates rem
        | [] -> ()
      in
      check_duplicates lbl_exp_list;
      let opt_exp =
        match opt_exp, lbl_exp_list with
          None, _ -> None
        | Some exp, (lid, lbl, lbl_exp) :: _ ->
            let ty_exp = instance env exp.exp_type in
            let unify_kept lbl =
              (* do not connect overridden labels *)
              if List.for_all
                  (fun (_, lbl',_) -> lbl'.lbl_pos <> lbl.lbl_pos)
                  lbl_exp_list
              then begin
                let _, ty_arg1, ty_res1 = instance_label false lbl
                and _, ty_arg2, ty_res2 = instance_label false lbl in
                unify env ty_arg1 ty_arg2;
                unify env (instance env ty_expected) ty_res2;
                unify_exp_types exp.exp_loc env ty_exp ty_res1;
              end in
            Array.iter unify_kept lbl.lbl_all;
            Some {exp with exp_type = ty_exp}
        | _ -> assert false
      in
      let num_fields =
        match lbl_exp_list with [] -> assert false
        | (_, lbl,_)::_ -> Array.length lbl.lbl_all in
      if opt_sexp = None && List.length lid_sexp_list <> num_fields then begin
        let present_indices =
          List.map (fun (_, lbl, _) -> lbl.lbl_pos) lbl_exp_list in
        let label_names = extract_label_names sexp env ty_expected in
        let rec missing_labels n = function
            [] -> []
          | lbl :: rem ->
              if List.mem n present_indices then missing_labels (n + 1) rem
              else lbl :: missing_labels (n + 1) rem
        in
        let missing = missing_labels 0 label_names in
        raise(Error(loc, env, Label_missing missing))
      end
      else if opt_sexp <> None && List.length lid_sexp_list = num_fields then
        Location.prerr_warning loc Warnings.Useless_record_with;
      re {
        exp_desc = Texp_record(lbl_exp_list, opt_exp);
        exp_loc = loc; exp_extra = [];
        exp_type = instance env ty_expected;
        exp_attributes = sexp.pexp_attributes;
        exp_env = env }
  | Pexp_field(srecord, lid) ->
      let (record, label, _) = type_label_access env loc srecord lid in
      let (_, ty_arg, ty_res) = instance_label false label in
      unify_exp env record ty_res;
      rue {
        exp_desc = Texp_field(record, lid, label);
        exp_loc = loc; exp_extra = [];
        exp_type = ty_arg;
        exp_attributes = sexp.pexp_attributes;
        exp_env = env }
  | Pexp_setfield(srecord, lid, snewval) ->
      let (record, label, opath) = type_label_access env loc srecord lid in
      let ty_record = if opath = None then newvar () else record.exp_type in
      let (label_loc, label, newval) =
        type_label_exp false env loc ty_record (lid, label, snewval) in
      unify_exp env record ty_record;
      if label.lbl_mut = Immutable then
        raise(Error(loc, env, Label_not_mutable lid.txt));
      rue {
        exp_desc = Texp_setfield(record, label_loc, label, newval);
        exp_loc = loc; exp_extra = [];
        exp_type = instance_def Predef.type_unit;
        exp_attributes = sexp.pexp_attributes;
        exp_env = env }
  | Pexp_array(sargl) ->
      let ty = newgenvar() in
      let to_unify = Predef.type_array ty in
      unify_exp_types loc env to_unify ty_expected;
      let argl = List.map (fun sarg -> type_expect env sarg ty) sargl in
      re {
        exp_desc = Texp_array argl;
        exp_loc = loc; exp_extra = [];
        exp_type = instance env ty_expected;
        exp_attributes = sexp.pexp_attributes;
        exp_env = env }
  | Pexp_ifthenelse(scond, sifso, sifnot) ->
      let cond = type_expect env scond Predef.type_bool in
      begin match sifnot with
        None ->
          let ifso = type_expect env sifso Predef.type_unit in
          rue {
            exp_desc = Texp_ifthenelse(cond, ifso, None);
            exp_loc = loc; exp_extra = [];
            exp_type = ifso.exp_type;
            exp_attributes = sexp.pexp_attributes;
            exp_env = env }
      | Some sifnot ->
          let ifso = type_expect env sifso ty_expected in
          let ifnot = type_expect env sifnot ty_expected in
          (* Keep sharing *)
          unify_exp env ifnot ifso.exp_type;
          re {
            exp_desc = Texp_ifthenelse(cond, ifso, Some ifnot);
            exp_loc = loc; exp_extra = [];
            exp_type = ifso.exp_type;
            exp_attributes = sexp.pexp_attributes;
            exp_env = env }
      end
  | Pexp_sequence(sexp1, sexp2) ->
      let exp1 = type_statement env sexp1 in
      let exp2 = type_expect env sexp2 ty_expected in
      re {
        exp_desc = Texp_sequence(exp1, exp2);
        exp_loc = loc; exp_extra = [];
        exp_type = exp2.exp_type;
        exp_attributes = sexp.pexp_attributes;
        exp_env = env }
  | Pexp_while(scond, sbody) ->
      let cond = type_expect env scond Predef.type_bool in
      let body = type_statement env sbody in
      rue {
        exp_desc = Texp_while(cond, body);
        exp_loc = loc; exp_extra = [];
        exp_type = instance_def Predef.type_unit;
        exp_attributes = sexp.pexp_attributes;
        exp_env = env }
  | Pexp_for(param, slow, shigh, dir, sbody) ->
      let low = type_expect env slow Predef.type_int in
      let high = type_expect env shigh Predef.type_int in
      let id, new_env =
        match param.ppat_desc with
        | Ppat_any -> Ident.create "_for", env
        | Ppat_var {txt} ->
            Env.enter_value txt {val_type = instance_def Predef.type_int;
                                 val_attributes = [];
                                 val_kind = Val_reg; Types.val_loc = loc; } env
              ~check:(fun s -> Warnings.Unused_for_index s)
        | _ ->
            raise (Error (param.ppat_loc, env, Invalid_for_loop_index))
      in
      let body = type_statement new_env sbody in
      rue {
        exp_desc = Texp_for(id, param, low, high, dir, body);
        exp_loc = loc; exp_extra = [];
        exp_type = instance_def Predef.type_unit;
        exp_attributes = sexp.pexp_attributes;
        exp_env = env }
  | Pexp_constraint (sarg, sty) ->
      let separate = true in (* always separate, 1% slowdown for lablgtk *)
      if separate then begin_def ();
      let cty = Typetexp.transl_simple_type env false sty in
      let ty = cty.ctyp_type in
      let (arg, ty') =
        if separate then begin
          end_def ();
          generalize_structure ty;
          (type_argument env sarg ty (instance env ty), instance env ty)
        end else
          (type_argument env sarg ty ty, ty)
      in
      rue {
        exp_desc = arg.exp_desc;
        exp_loc = arg.exp_loc;
        exp_type = ty';
        exp_attributes = arg.exp_attributes;
        exp_env = env;
        exp_extra =
          (Texp_constraint cty, loc, sexp.pexp_attributes) :: arg.exp_extra;
      }
  | Pexp_coerce(sarg, sty, sty') ->
      let separate = true (* always separate, 1% slowdown for lablgtk *)
        (* !Clflags.principal || Env.has_local_constraints env *) in
      let (arg, ty',cty,cty') =
        match sty with
        | None ->
            let (cty', force) =
              Typetexp.transl_simple_type_delayed env sty'
            in
            let ty' = cty'.ctyp_type in
            if separate then begin_def ();
            let arg = type_exp env sarg in
            let gen =
              if separate then begin
                end_def ();
                let tv = newvar () in
                let gen = generalizable tv.level arg.exp_type in
                unify_var env tv arg.exp_type;
                gen
              end else true
            in
            begin match arg.exp_desc, !self_coercion, (repr ty').desc with
              Texp_ident(_, _, {val_kind=Val_self _}), (path,r) :: _,
              Tconstr(path',_,_) when Path.same path path' ->
                (* prerr_endline "self coercion"; *)
                r := loc :: !r;
                force ()
            | _ when free_variables ~env arg.exp_type = []
                  && free_variables ~env ty' = [] ->
                if not gen && (* first try a single coercion *)
                  let snap = snapshot () in
                  let ty, b = enlarge_type env ty' in
                  try
                    force (); Ctype.unify env arg.exp_type ty; true
                  with Unify _ ->
                    backtrack snap; false
                then ()
                else begin try
                  let force' = subtype env arg.exp_type ty' in
                  force (); force' ();
                  if not gen then
                    Location.prerr_warning loc
                      (Warnings.Not_principal "this ground coercion");
                with Subtype (tr1, tr2) ->
                  (* prerr_endline "coercion failed"; *)
                  raise(Error(loc, env, Not_subtype(tr1, tr2)))
                end;
            | _ ->
                let ty, b = enlarge_type env ty' in
                force ();
                begin try Ctype.unify env arg.exp_type ty with Unify trace ->
                  raise(Error(sarg.pexp_loc, env,
                        Coercion_failure(ty', full_expand env ty', trace, b)))
                end
            end;
            (arg, ty', None, cty')
        | Some sty ->
            if separate then begin_def ();
            let (cty, force) =
              Typetexp.transl_simple_type_delayed env sty
            and (cty', force') =
              Typetexp.transl_simple_type_delayed env sty'
            in
            let ty = cty.ctyp_type in
            let ty' = cty'.ctyp_type in
            begin try
              let force'' = subtype env ty ty' in
              force (); force' (); force'' ()
            with Subtype (tr1, tr2) ->
              raise(Error(loc, env, Not_subtype(tr1, tr2)))
            end;
            if separate then begin
              end_def ();
              generalize_structure ty;
              generalize_structure ty';
              (type_argument env sarg ty (instance env ty),
               instance env ty', Some cty, cty')
            end else
              (type_argument env sarg ty ty, ty', Some cty, cty')
      in
      rue {
        exp_desc = arg.exp_desc;
        exp_loc = arg.exp_loc;
        exp_type = ty';
        exp_attributes = arg.exp_attributes;
        exp_env = env;
        exp_extra = (Texp_coerce (cty, cty'), loc, sexp.pexp_attributes) ::
                       arg.exp_extra;
      }
  | Pexp_send (e, met) ->
      if !Clflags.principal then begin_def ();
      let obj = type_exp env e in
      begin try
        let (meth, exp, typ) =
          match obj.exp_desc with
            Texp_ident(path, _, {val_kind = Val_self (meths, _, _, privty)}) ->
              let (id, typ) =
                filter_self_method env met Private meths privty
              in
              if is_Tvar (repr typ) then
                Location.prerr_warning loc
                  (Warnings.Undeclared_virtual_method met);
              (Tmeth_val id, None, typ)
          | Texp_ident(path, lid, {val_kind = Val_anc (methods, cl_num)}) ->
              let method_id =
                begin try List.assoc met methods with Not_found ->
                  raise(Error(e.pexp_loc, env, Undefined_inherited_method met))
                end
              in
              begin match
                Env.lookup_value (Longident.Lident ("selfpat-" ^ cl_num)) env,
                Env.lookup_value (Longident.Lident ("self-" ^cl_num)) env
              with
                (_, ({val_kind = Val_self (meths, _, _, privty)} as desc)),
                (path, _) ->
                  let (_, typ) =
                    filter_self_method env met Private meths privty
                  in
                  let method_type = newvar () in
                  let (obj_ty, res_ty) = filter_arrow env method_type "" in
                  unify env obj_ty desc.val_type;
                  unify env res_ty (instance env typ);
                  let exp =
                    Texp_apply({exp_desc =
                                Texp_ident(Path.Pident method_id, lid,
                                           {val_type = method_type;
                                            val_kind = Val_reg;
                                            val_attributes = [];
                                            Types.val_loc = Location.none});
                                exp_loc = loc; exp_extra = [];
                                exp_type = method_type;
                                exp_attributes = []; (* check *)
                                exp_env = env},
                          ["",
                            Some {exp_desc = Texp_ident(path, lid, desc);
                                  exp_loc = obj.exp_loc; exp_extra = [];
                                  exp_type = desc.val_type;
                                  exp_attributes = []; (* check *)
                                  exp_env = env},
                               Required])
                  in
                  (Tmeth_name met, Some (re {exp_desc = exp;
                                             exp_loc = loc; exp_extra = [];
                                             exp_type = typ;
                                             exp_attributes = []; (* check *)
                                             exp_env = env}), typ)
              |  _ ->
                  assert false
              end
          | _ ->
              (Tmeth_name met, None,
               filter_method env met Public obj.exp_type)
        in
        if !Clflags.principal then begin
          end_def ();
          generalize_structure typ;
        end;
        let typ =
          match repr typ with
            {desc = Tpoly (ty, [])} ->
              instance env ty
          | {desc = Tpoly (ty, tl); level = l} ->
              if !Clflags.principal && l <> generic_level then
                Location.prerr_warning loc
                  (Warnings.Not_principal "this use of a polymorphic method");
              snd (instance_poly false tl ty)
          | {desc = Tvar _} as ty ->
              let ty' = newvar () in
              unify env (instance_def ty) (newty(Tpoly(ty',[])));
              (* if not !Clflags.nolabels then
                 Location.prerr_warning loc (Warnings.Unknown_method met); *)
              ty'
          | _ ->
              assert false
        in
        rue {
          exp_desc = Texp_send(obj, meth, exp);
          exp_loc = loc; exp_extra = [];
          exp_type = typ;
          exp_attributes = sexp.pexp_attributes;
          exp_env = env }
      with Unify _ ->
        raise(Error(e.pexp_loc, env, Undefined_method (obj.exp_type, met)))
      end
  | Pexp_new cl ->
      let (cl_path, cl_decl) = Typetexp.find_class env loc cl.txt in
      begin match cl_decl.cty_new with
          None ->
            raise(Error(loc, env, Virtual_class cl.txt))
        | Some ty ->
            rue {
              exp_desc = Texp_new (cl_path, cl, cl_decl);
              exp_loc = loc; exp_extra = [];
              exp_type = instance_def ty;
              exp_attributes = sexp.pexp_attributes;
              exp_env = env }
        end
  | Pexp_setinstvar (lab, snewval) ->
      begin try
        let (path, desc) = Env.lookup_value (Longident.Lident lab.txt) env in
        match desc.val_kind with
          Val_ivar (Mutable, cl_num) ->
            let newval =
              type_expect env snewval (instance env desc.val_type) in
            let (path_self, _) =
              Env.lookup_value (Longident.Lident ("self-" ^ cl_num)) env
            in
            rue {
              exp_desc = Texp_setinstvar(path_self, path, lab, newval);
              exp_loc = loc; exp_extra = [];
              exp_type = instance_def Predef.type_unit;
              exp_attributes = sexp.pexp_attributes;
              exp_env = env }
        | Val_ivar _ ->
            raise(Error(loc, env, Instance_variable_not_mutable(true,lab.txt)))
        | _ ->
            raise(Error(loc, env, Instance_variable_not_mutable(false,lab.txt)))
      with
        Not_found ->
          raise(Error(loc, env, Unbound_instance_variable lab.txt))
      end
  | Pexp_override lst ->
      let _ =
       List.fold_right
        (fun (lab, _) l ->
           if List.exists (fun l -> l.txt = lab.txt) l then
             raise(Error(loc, env,
                         Value_multiply_overridden lab.txt));
           lab::l)
        lst
        [] in
      begin match
        try
          Env.lookup_value (Longident.Lident "selfpat-*") env,
          Env.lookup_value (Longident.Lident "self-*") env
        with Not_found ->
          raise(Error(loc, env, Outside_class))
      with
        (_, {val_type = self_ty; val_kind = Val_self (_, vars, _, _)}),
        (path_self, _) ->
          let type_override (lab, snewval) =
            begin try
              let (id, _, _, ty) = Vars.find lab.txt !vars in
              (Path.Pident id, lab, type_expect env snewval (instance env ty))
            with
              Not_found ->
                raise(Error(loc, env, Unbound_instance_variable lab.txt))
            end
          in
          let modifs = List.map type_override lst in
          rue {
            exp_desc = Texp_override(path_self, modifs);
            exp_loc = loc; exp_extra = [];
            exp_type = self_ty;
            exp_attributes = sexp.pexp_attributes;
            exp_env = env }
      | _ ->
          assert false
      end
  | Pexp_letmodule(name, smodl, sbody) ->
      let ty = newvar() in
      (* remember original level *)
      begin_def ();
      Ident.set_current_time ty.level;
      let context = Typetexp.narrow () in
      let modl = !type_module env smodl in
      let (id, new_env) = Env.enter_module name.txt modl.mod_type env in
      Ctype.init_def(Ident.current_time());
      Typetexp.widen context;
      let body = type_expect new_env sbody ty_expected in
      (* go back to original level *)
      end_def ();
      (* Unification of body.exp_type with the fresh variable ty
         fails if and only if the prefix condition is violated,
         i.e. if generative types rooted at id show up in the
         type body.exp_type.  Thus, this unification enforces the
         scoping condition on "let module". *)
      begin try
        Ctype.unify_var new_env ty body.exp_type
      with Unify _ ->
        raise(Error(loc, env, Scoping_let_module(name.txt, body.exp_type)))
      end;
      re {
        exp_desc = Texp_letmodule(id, name, modl, body);
        exp_loc = loc; exp_extra = [];
        exp_type = ty;
        exp_attributes = sexp.pexp_attributes;
        exp_env = env }
  | Pexp_assert (e) ->
      let cond = type_expect env e Predef.type_bool in
      let exp_type =
        match cond.exp_desc with
        | Texp_construct(_, {cstr_name="false"}, _) ->
            instance env ty_expected
        | _ ->
            instance_def Predef.type_unit
      in
      rue {
        exp_desc = Texp_assert cond;
        exp_loc = loc; exp_extra = [];
        exp_type;
        exp_attributes = sexp.pexp_attributes;
        exp_env = env;
      }
  | Pexp_lazy e ->
      let ty = newgenvar () in
      let to_unify = Predef.type_lazy_t ty in
      unify_exp_types loc env to_unify ty_expected;
      let arg = type_expect env e ty in
      re {
        exp_desc = Texp_lazy arg;
        exp_loc = loc; exp_extra = [];
        exp_type = instance env ty_expected;
        exp_attributes = sexp.pexp_attributes;
        exp_env = env;
      }
  | Pexp_object s ->
      let desc, sign, meths = !type_object env loc s in
      rue {
        exp_desc = Texp_object (desc, (*sign,*) meths);
        exp_loc = loc; exp_extra = [];
        exp_type = sign.csig_self;
        exp_attributes = sexp.pexp_attributes;
        exp_env = env;
      }
  | Pexp_poly(sbody, sty) ->
      if !Clflags.principal then begin_def ();
      let ty, cty =
        match sty with None -> repr ty_expected, None
        | Some sty ->
            let sty = Ast_helper.Typ.force_poly sty in
            let cty = Typetexp.transl_simple_type env false sty in
            repr cty.ctyp_type, Some cty
      in
      if !Clflags.principal then begin
        end_def ();
        generalize_structure ty
      end;
      if sty <> None then
        unify_exp_types loc env (instance env ty) (instance env ty_expected);
      let exp =
        match (expand_head env ty).desc with
          Tpoly (ty', []) ->
            let exp = type_expect env sbody ty' in
            { exp with exp_type = instance env ty }
        | Tpoly (ty', tl) ->
            (* One more level to generalize locally *)
            begin_def ();
            if !Clflags.principal then begin_def ();
            let vars, ty'' = instance_poly true tl ty' in
            if !Clflags.principal then begin
              end_def ();
              generalize_structure ty''
            end;
            let exp = type_expect env sbody ty'' in
            end_def ();
            check_univars env false "method" exp ty_expected vars;
            { exp with exp_type = instance env ty }
        | Tvar _ ->
            let exp = type_exp env sbody in
            let exp = {exp with exp_type = newty (Tpoly (exp.exp_type, []))} in
            unify_exp env exp ty;
            exp
        | _ -> assert false
      in
      re { exp with exp_extra =
             (Texp_poly cty, loc, sexp.pexp_attributes) :: exp.exp_extra }
  | Pexp_newtype(name, sbody) ->
      let ty = newvar () in
      (* remember original level *)
      begin_def ();
      (* Create a fake abstract type declaration for name. *)
      let level = get_current_level () in
      let decl = {
        type_params = [];
        type_arity = 0;
        type_kind = Type_abstract;
        type_private = Public;
        type_manifest = None;
        type_variance = [];
        type_newtype_level = Some (level, level);
        type_loc = loc;
        type_attributes = [];
      }
      in
      Ident.set_current_time ty.level;
      let (id, new_env) = Env.enter_type name decl env in
      Ctype.init_def(Ident.current_time());

      let body = type_exp new_env sbody in
      (* Replace every instance of this type constructor in the resulting
         type. *)
      let seen = Hashtbl.create 8 in
      let rec replace t =
        if Hashtbl.mem seen t.id then ()
        else begin
          Hashtbl.add seen t.id ();
          match t.desc with
          | Tconstr (Path.Pident id', _, _) when id == id' -> link_type t ty
          | _ -> Btype.iter_type_expr replace t
        end
      in
      let ety = Subst.type_expr Subst.identity body.exp_type in
      replace ety;
      (* back to original level *)
      end_def ();
      (* lower the levels of the result type *)
      (* unify_var env ty ety; *)

      (* non-expansive if the body is non-expansive, so we don't introduce
         any new extra node in the typed AST. *)
      rue { body with exp_loc = loc; exp_type = ety;
            exp_extra =
            (Texp_newtype name, loc, sexp.pexp_attributes) :: body.exp_extra }
  | Pexp_pack m ->
      let (p, nl, tl) =
        match Ctype.expand_head env (instance env ty_expected) with
          {desc = Tpackage (p, nl, tl)} ->
            if !Clflags.principal &&
              (Ctype.expand_head env ty_expected).level < Btype.generic_level
            then
              Location.prerr_warning loc
                (Warnings.Not_principal "this module packing");
            (p, nl, tl)
        | {desc = Tvar _} ->
            raise (Error (loc, env, Cannot_infer_signature))
        | _ ->
            raise (Error (loc, env, Not_a_packed_module ty_expected))
      in
      let (modl, tl') = !type_package env m p nl tl in
      rue {
        exp_desc = Texp_pack modl;
        exp_loc = loc; exp_extra = [];
        exp_type = newty (Tpackage (p, nl, tl'));
        exp_attributes = sexp.pexp_attributes;
        exp_env = env }
  | Pexp_open (ovf, lid, e) ->
      let (path, newenv) = !type_open ovf env sexp.pexp_loc lid in
      let exp = type_expect newenv e ty_expected in
      { exp with
        exp_extra = (Texp_open (ovf, path, lid, newenv), loc,
                     sexp.pexp_attributes) ::
                      exp.exp_extra;
      }
  | Pexp_extension ext ->
      raise (Error_forward (Typetexp.error_of_extension ext))

and type_function ?in_function loc attrs env ty_expected l caselist =
  let (loc_fun, ty_fun) =
    match in_function with Some p -> p
    | None -> (loc, instance env ty_expected)
  in
  let separate = !Clflags.principal || Env.has_local_constraints env in
  if separate then begin_def ();
  let (ty_arg, ty_res) =
    try filter_arrow env (instance env ty_expected) l
    with Unify _ ->
      match expand_head env ty_expected with
        {desc = Tarrow _} as ty ->
          raise(Error(loc, env, Abstract_wrong_label(l, ty)))
      | _ ->
          raise(Error(loc_fun, env,
                      Too_many_arguments (in_function <> None, ty_fun)))
  in
  let ty_arg =
    if is_optional l then
      let tv = newvar() in
      begin
        try unify env ty_arg (type_option tv)
        with Unify _ -> assert false
      end;
      type_option tv
    else ty_arg
  in
  if separate then begin
    end_def ();
    generalize_structure ty_arg;
    generalize_structure ty_res
  end;
  let cases, partial =
    type_cases ~in_function:(loc_fun,ty_fun) env ty_arg ty_res
      true loc caselist in
  let not_function ty =
    let ls, tvar = list_labels env ty in
    ls = [] && not tvar
  in
  if is_optional l && not_function ty_res then
    Location.prerr_warning (List.hd cases).c_lhs.pat_loc
      Warnings.Unerasable_optional_argument;
  re {
  exp_desc = Texp_function(l,cases, partial);
    exp_loc = loc; exp_extra = [];
    exp_type = instance env (newgenty (Tarrow(l, ty_arg, ty_res, Cok)));
    exp_attributes = attrs;
    exp_env = env }


and type_label_access env loc srecord lid =
  if !Clflags.principal then begin_def ();
  let record = type_exp env srecord in
  if !Clflags.principal then begin
    end_def ();
    generalize_structure record.exp_type
  end;
  let ty_exp = record.exp_type in
  let opath =
    try
      let (p0, p,_) = extract_concrete_record env ty_exp in
      Some(p0, p, ty_exp.level = generic_level || not !Clflags.principal)
    with Not_found -> None
  in
  let labels = Typetexp.find_all_labels env lid.loc lid.txt in
  let label =
    wrap_disambiguate "This expression has" ty_exp
      (Label.disambiguate lid env opath) labels in
  (record, label, opath)

(* Typing format strings for printing or reading.
   These formats are used by functions in modules Printf, Format, and Scanf.
   (Handling of * modifiers contributed by Thorsten Ohl.) *)

and type_format loc str env =
  let loc = {loc with Location.loc_ghost = true} in
  try
    CamlinternalFormatBasics.(CamlinternalFormat.(
      let mk_exp_loc pexp_desc = {
        pexp_desc = pexp_desc;
        pexp_loc = loc;
        pexp_attributes = [];
      } and mk_lid_loc lid = {
        txt = lid;
        loc = loc;
      } in
      let mk_constr name args =
        let lid = Longident.(Ldot(Lident "CamlinternalFormatBasics", name)) in
        let arg = match args with
          | []          -> None
          | [ e ]       -> Some e
          | _ :: _ :: _ -> Some (mk_exp_loc (Pexp_tuple args)) in
        mk_exp_loc (Pexp_construct (mk_lid_loc lid, arg)) in
      let mk_cst cst = mk_exp_loc (Pexp_constant cst) in
      let mk_int n = mk_cst (Const_int n)
      and mk_string str = mk_cst (Const_string (str, None))
      and mk_char chr = mk_cst (Const_char chr) in
      let rec mk_formatting_lit fmting = match fmting with
        | Close_box ->
          mk_constr "Close_box" []
        | Close_tag ->
          mk_constr "Close_tag" []
        | Break (org, ns, ni) ->
          mk_constr "Break" [ mk_string org; mk_int ns; mk_int ni ]
        | FFlush ->
          mk_constr "FFlush" []
        | Force_newline ->
          mk_constr "Force_newline" []
        | Flush_newline ->
          mk_constr "Flush_newline" []
        | Magic_size (org, sz) ->
          mk_constr "Magic_size" [ mk_string org; mk_int sz ]
        | Escaped_at ->
          mk_constr "Escaped_at" []
        | Escaped_percent ->
          mk_constr "Escaped_percent" []
        | Scan_indic c ->
          mk_constr "Scan_indic" [ mk_char c ]
      and mk_formatting_gen : type a b c d e f .
          (a, b, c, d, e, f) formatting_gen -> Parsetree.expression =
        fun fmting -> match fmting with
        | Open_tag (Format (fmt', str')) ->
          mk_constr "Open_tag" [ mk_format fmt' str' ]
        | Open_box (Format (fmt', str')) ->
          mk_constr "Open_box" [ mk_format fmt' str' ]
      and mk_format : type a b c d e f .
          (a, b, c, d, e, f) CamlinternalFormatBasics.fmt -> string ->
          Parsetree.expression = fun fmt str ->
        mk_constr "Format" [ mk_fmt fmt; mk_string str ]
      and mk_side side = match side with
        | Left  -> mk_constr "Left"  []
        | Right -> mk_constr "Right" []
        | Zeros -> mk_constr "Zeros" []
      and mk_iconv iconv = match iconv with
        | Int_d  -> mk_constr "Int_d"  [] | Int_pd -> mk_constr "Int_pd" []
        | Int_sd -> mk_constr "Int_sd" [] | Int_i  -> mk_constr "Int_i"  []
        | Int_pi -> mk_constr "Int_pi" [] | Int_si -> mk_constr "Int_si" []
        | Int_x  -> mk_constr "Int_x"  [] | Int_Cx -> mk_constr "Int_Cx" []
        | Int_X  -> mk_constr "Int_X"  [] | Int_CX -> mk_constr "Int_CX" []
        | Int_o  -> mk_constr "Int_o"  [] | Int_Co -> mk_constr "Int_Co" []
        | Int_u  -> mk_constr "Int_u"  []
      and mk_fconv fconv = match fconv with
        | Float_f  -> mk_constr "Float_f"  []
        | Float_pf -> mk_constr "Float_pf" []
        | Float_sf -> mk_constr "Float_sf" []
        | Float_e  -> mk_constr "Float_e"  []
        | Float_pe -> mk_constr "Float_pe" []
        | Float_se -> mk_constr "Float_se" []
        | Float_E  -> mk_constr "Float_E"  []
        | Float_pE -> mk_constr "Float_pE" []
        | Float_sE -> mk_constr "Float_sE" []
        | Float_g  -> mk_constr "Float_g"  []
        | Float_pg -> mk_constr "Float_pg" []
        | Float_sg -> mk_constr "Float_sg" []
        | Float_G  -> mk_constr "Float_G"  []
        | Float_pG -> mk_constr "Float_pG" []
        | Float_sG -> mk_constr "Float_sG" []
        | Float_F  -> mk_constr "Float_F"  []
      and mk_counter cnt = match cnt with
        | Line_counter  -> mk_constr "Line_counter"  []
        | Char_counter  -> mk_constr "Char_counter"  []
        | Token_counter -> mk_constr "Token_counter" []
      and mk_int_opt n_opt = match n_opt with
        | None ->
          let lid_loc = mk_lid_loc (Longident.Lident "None") in
          mk_exp_loc (Pexp_construct (lid_loc, None))
        | Some n ->
          let lid_loc = mk_lid_loc (Longident.Lident "Some") in
          mk_exp_loc (Pexp_construct (lid_loc, Some (mk_int n)))
      and mk_fmtty : type a b c d e f g h i j k l .
          (a, b, c, d, e, f, g, h, i, j, k, l) fmtty_rel -> Parsetree.expression =
      fun fmtty -> match fmtty with
        | Char_ty rest      -> mk_constr "Char_ty"      [ mk_fmtty rest ]
        | String_ty rest    -> mk_constr "String_ty"    [ mk_fmtty rest ]
        | Int_ty rest       -> mk_constr "Int_ty"       [ mk_fmtty rest ]
        | Int32_ty rest     -> mk_constr "Int32_ty"     [ mk_fmtty rest ]
        | Nativeint_ty rest -> mk_constr "Nativeint_ty" [ mk_fmtty rest ]
        | Int64_ty rest     -> mk_constr "Int64_ty"     [ mk_fmtty rest ]
        | Float_ty rest     -> mk_constr "Float_ty"     [ mk_fmtty rest ]
        | Bool_ty rest      -> mk_constr "Bool_ty"      [ mk_fmtty rest ]
        | Alpha_ty rest     -> mk_constr "Alpha_ty"     [ mk_fmtty rest ]
        | Theta_ty rest     -> mk_constr "Theta_ty"     [ mk_fmtty rest ]
        | Any_ty rest       -> mk_constr "Any_ty"       [ mk_fmtty rest ]
        | Reader_ty rest    -> mk_constr "Reader_ty"    [ mk_fmtty rest ]
        | Ignored_reader_ty rest ->
          mk_constr "Ignored_reader_ty" [ mk_fmtty rest ]
        | Format_arg_ty (sub_fmtty, rest) ->
          mk_constr "Format_arg_ty" [ mk_fmtty sub_fmtty; mk_fmtty rest ]
        | Format_subst_ty (sub_fmtty1, sub_fmtty2, rest) ->
          mk_constr "Format_subst_ty"
            [ mk_fmtty sub_fmtty1; mk_fmtty sub_fmtty2; mk_fmtty rest ]
        | End_of_fmtty -> mk_constr "End_of_fmtty" []
      and mk_ignored : type a b c d e f .
          (a, b, c, d, e, f) ignored -> Parsetree.expression =
      fun ign -> match ign with
        | Ignored_char ->
          mk_constr "Ignored_char" []
        | Ignored_caml_char ->
          mk_constr "Ignored_caml_char" []
        | Ignored_string pad_opt ->
          mk_constr "Ignored_string" [ mk_int_opt pad_opt ]
        | Ignored_caml_string pad_opt ->
          mk_constr "Ignored_caml_string" [ mk_int_opt pad_opt ]
        | Ignored_int (iconv, pad_opt) ->
          mk_constr "Ignored_int" [ mk_iconv iconv; mk_int_opt pad_opt ]
        | Ignored_int32 (iconv, pad_opt) ->
          mk_constr "Ignored_int32" [ mk_iconv iconv; mk_int_opt pad_opt ]
        | Ignored_nativeint (iconv, pad_opt) ->
          mk_constr "Ignored_nativeint" [ mk_iconv iconv; mk_int_opt pad_opt ]
        | Ignored_int64 (iconv, pad_opt) ->
          mk_constr "Ignored_int64" [ mk_iconv iconv; mk_int_opt pad_opt ]
        | Ignored_float (pad_opt, prec_opt) ->
          mk_constr "Ignored_float" [ mk_int_opt pad_opt; mk_int_opt prec_opt ]
        | Ignored_bool ->
          mk_constr "Ignored_bool" []
        | Ignored_format_arg (pad_opt, fmtty) ->
          mk_constr "Ignored_format_arg" [ mk_int_opt pad_opt; mk_fmtty fmtty ]
        | Ignored_format_subst (pad_opt, fmtty) ->
          mk_constr "Ignored_format_subst" [
            mk_int_opt pad_opt; mk_fmtty fmtty ]
        | Ignored_reader ->
          mk_constr "Ignored_reader" []
        | Ignored_scan_char_set (width_opt, char_set) ->
          mk_constr "Ignored_scan_char_set" [
            mk_int_opt width_opt; mk_string char_set ]
        | Ignored_scan_get_counter counter ->
          mk_constr "Ignored_scan_get_counter" [
            mk_counter counter
          ]
        | Ignored_scan_next_char ->
          mk_constr "Ignored_scan_next_char" []
      and mk_padding : type x y . (x, y) padding -> Parsetree.expression =
      fun pad -> match pad with
        | No_padding         -> mk_constr "No_padding" []
        | Lit_padding (s, w) -> mk_constr "Lit_padding" [ mk_side s; mk_int w ]
        | Arg_padding s      -> mk_constr "Arg_padding" [ mk_side s ]
      and mk_precision : type x y . (x, y) precision -> Parsetree.expression =
      fun prec -> match prec with
        | No_precision    -> mk_constr "No_precision" []
        | Lit_precision w -> mk_constr "Lit_precision" [ mk_int w ]
        | Arg_precision   -> mk_constr "Arg_precision" []
      and mk_fmt : type a b c d e f .
          (a, b, c, d, e, f) fmt -> Parsetree.expression =
      fun fmt -> match fmt with
        | Char rest ->
          mk_constr "Char" [ mk_fmt rest ]
        | Caml_char rest ->
          mk_constr "Caml_char" [ mk_fmt rest ]
        | String (pad, rest) ->
          mk_constr "String" [ mk_padding pad; mk_fmt rest ]
        | Caml_string (pad, rest) ->
          mk_constr "Caml_string" [ mk_padding pad; mk_fmt rest ]
        | Int (iconv, pad, prec, rest) ->
          mk_constr "Int" [
            mk_iconv iconv; mk_padding pad; mk_precision prec; mk_fmt rest ]
        | Int32 (iconv, pad, prec, rest) ->
          mk_constr "Int32" [
            mk_iconv iconv; mk_padding pad; mk_precision prec; mk_fmt rest ]
        | Nativeint (iconv, pad, prec, rest) ->
          mk_constr "Nativeint" [
            mk_iconv iconv; mk_padding pad; mk_precision prec; mk_fmt rest ]
        | Int64 (iconv, pad, prec, rest) ->
          mk_constr "Int64" [
            mk_iconv iconv; mk_padding pad; mk_precision prec; mk_fmt rest ]
        | Float (fconv, pad, prec, rest) ->
          mk_constr "Float" [
            mk_fconv fconv; mk_padding pad; mk_precision prec; mk_fmt rest ]
        | Bool rest ->
          mk_constr "Bool" [ mk_fmt rest ]
        | Flush rest ->
          mk_constr "Flush" [ mk_fmt rest ]
        | String_literal (s, rest) ->
          mk_constr "String_literal" [ mk_string s; mk_fmt rest ]
        | Char_literal (c, rest) ->
          mk_constr "Char_literal" [ mk_char c; mk_fmt rest ]
        | Format_arg (pad_opt, fmtty, rest) ->
          mk_constr "Format_arg" [
            mk_int_opt pad_opt; mk_fmtty fmtty; mk_fmt rest ]
        | Format_subst (pad_opt, fmtty, rest) ->
          mk_constr "Format_subst" [
            mk_int_opt pad_opt; mk_fmtty fmtty; mk_fmt rest ]
        | Alpha rest ->
          mk_constr "Alpha" [ mk_fmt rest ]
        | Theta rest ->
          mk_constr "Theta" [ mk_fmt rest ]
        | Formatting_lit (fmting, rest) ->
          mk_constr "Formatting_lit" [ mk_formatting_lit fmting; mk_fmt rest ]
        | Formatting_gen (fmting, rest) ->
          mk_constr "Formatting_gen" [ mk_formatting_gen fmting; mk_fmt rest ]
        | Reader rest ->
          mk_constr "Reader" [ mk_fmt rest ]
        | Scan_char_set (width_opt, char_set, rest) ->
          mk_constr "Scan_char_set" [
            mk_int_opt width_opt; mk_string char_set; mk_fmt rest ]
        | Scan_get_counter (cnt, rest) ->
          mk_constr "Scan_get_counter" [ mk_counter cnt; mk_fmt rest ]
        | Scan_next_char rest ->
          mk_constr "Scan_next_char" [ mk_fmt rest ]
        | Ignored_param (ign, rest) ->
          mk_constr "Ignored_param" [ mk_ignored ign; mk_fmt rest ]
        | End_of_format ->
          mk_constr "End_of_format" []
        | Custom _ ->
          (* Custom formatters have no syntax so they will never appear
             in formats parsed from strings. *)
          assert false
      in
      let legacy_behavior = not !Clflags.strict_formats in
      let Fmt_EBB fmt = fmt_ebb_of_string ~legacy_behavior str in
      mk_constr "Format" [ mk_fmt fmt; mk_string str ]
    ))
  with Failure msg ->
    raise (Error (loc, env, Invalid_format msg))

and type_label_exp create env loc ty_expected
          (lid, label, sarg) =
  (* Here also ty_expected may be at generic_level *)
  begin_def ();
  let separate = !Clflags.principal || Env.has_local_constraints env in
  if separate then (begin_def (); begin_def ());
  let (vars, ty_arg, ty_res) = instance_label true label in
  if separate then begin
    end_def ();
    (* Generalize label information *)
    generalize_structure ty_arg;
    generalize_structure ty_res
  end;
  begin try
    unify env (instance_def ty_res) (instance env ty_expected)
  with Unify trace ->
    raise (Error(lid.loc, env, Label_mismatch(lid.txt, trace)))
  end;
  (* Instantiate so that we can generalize internal nodes *)
  let ty_arg = instance_def ty_arg in
  if separate then begin
    end_def ();
    (* Generalize information merged from ty_expected *)
    generalize_structure ty_arg
  end;
  if label.lbl_private = Private then
    if create then
      raise (Error(loc, env, Private_type ty_expected))
    else
      raise (Error(lid.loc, env, Private_label(lid.txt, ty_expected)));
  let arg =
    let snap = if vars = [] then None else Some (Btype.snapshot ()) in
    let arg = type_argument env sarg ty_arg (instance env ty_arg) in
    end_def ();
    try
      check_univars env (vars <> []) "field value" arg label.lbl_arg vars;
      arg
    with exn when not (is_nonexpansive arg) -> try
      (* Try to retype without propagating ty_arg, cf PR#4862 *)
      may Btype.backtrack snap;
      begin_def ();
      let arg = type_exp env sarg in
      end_def ();
      generalize_expansive env arg.exp_type;
      unify_exp env arg ty_arg;
      check_univars env false "field value" arg label.lbl_arg vars;
      arg
    with Error (_, _, Less_general _) as e -> raise e
    | _ -> raise exn    (* In case of failure return the first error *)
  in
  (lid, label, {arg with exp_type = instance env arg.exp_type})

and type_argument env sarg ty_expected' ty_expected =
  (* ty_expected' may be generic *)
  let no_labels ty =
    let ls, tvar = list_labels env ty in
    not tvar && List.for_all ((=) "") ls
  in
  let rec is_inferred sexp =
    match sexp.pexp_desc with
      Pexp_ident _ | Pexp_apply _ | Pexp_field _ | Pexp_constraint _
    | Pexp_coerce _ | Pexp_send _ | Pexp_new _ -> true
    | Pexp_sequence (_, e) | Pexp_open (_, _, e) -> is_inferred e
    | Pexp_ifthenelse (_, e1, Some e2) -> is_inferred e1 && is_inferred e2
    | _ -> false
  in
  match expand_head env ty_expected' with
    {desc = Tarrow("",ty_arg,ty_res,_); level = lv} when is_inferred sarg ->
      (* apply optional arguments when expected type is "" *)
      (* we must be very careful about not breaking the semantics *)
      if !Clflags.principal then begin_def ();
      let texp = type_exp env sarg in
      if !Clflags.principal then begin
        end_def ();
        generalize_structure texp.exp_type
      end;
      let rec make_args args ty_fun =
        match (expand_head env ty_fun).desc with
        | Tarrow (l,ty_arg,ty_fun,_) when is_optional l ->
            let ty = option_none (instance env ty_arg) sarg.pexp_loc in
            make_args ((l, Some ty, Optional) :: args) ty_fun
        | Tarrow (l,_,ty_res',_) when l = "" || !Clflags.classic ->
            List.rev args, ty_fun, no_labels ty_res'
        | Tvar _ ->  List.rev args, ty_fun, false
        |  _ -> [], texp.exp_type, false
      in
      let args, ty_fun', simple_res = make_args [] texp.exp_type in
      let warn = !Clflags.principal &&
        (lv <> generic_level || (repr ty_fun').level <> generic_level)
      and texp = {texp with exp_type = instance env texp.exp_type}
      and ty_fun = instance env ty_fun' in
      if not (simple_res || no_labels ty_res) then begin
        unify_exp env texp ty_expected;
        texp
      end else begin
      unify_exp env {texp with exp_type = ty_fun} ty_expected;
      if args = [] then texp else
      (* eta-expand to avoid side effects *)
      let var_pair name ty =
        let id = Ident.create name in
        {pat_desc = Tpat_var (id, mknoloc name); pat_type = ty;pat_extra=[];
         pat_attributes = [];
         pat_loc = Location.none; pat_env = env},
        {exp_type = ty; exp_loc = Location.none; exp_env = env;
         exp_extra = []; exp_attributes = [];
         exp_desc =
         Texp_ident(Path.Pident id, mknoloc (Longident.Lident name),
                    {val_type = ty; val_kind = Val_reg;
                     val_attributes = [];
                     Types.val_loc = Location.none})}
      in
      let eta_pat, eta_var = var_pair "eta" ty_arg in
      let func texp =
        let e =
          {texp with exp_type = ty_res; exp_desc =
           Texp_apply
             (texp,
              args @ ["", Some eta_var, Required])}
        in
        { texp with exp_type = ty_fun; exp_desc =
          Texp_function("", [case eta_pat e], Total) }
      in
      Location.prerr_warning texp.exp_loc
        (Warnings.Eliminated_optional_arguments (List.map (fun (l, _, _) -> l) args));
      if warn then Location.prerr_warning texp.exp_loc
          (Warnings.Without_principality "eliminated optional argument");
      if is_nonexpansive texp then func texp else
      (* let-expand to have side effects *)
      let let_pat, let_var = var_pair "arg" texp.exp_type in
      re { texp with exp_type = ty_fun; exp_desc =
           Texp_let (Nonrecursive,
                     [{vb_pat=let_pat; vb_expr=texp; vb_attributes=[];
                       vb_loc=Location.none;
                      }],
                     func let_var) }
      end
  | _ ->
      let texp = type_expect env sarg ty_expected' in
      unify_exp env texp ty_expected;
      texp

and type_application env funct sargs =
  (* funct.exp_type may be generic *)
  let result_type omitted ty_fun =
    List.fold_left
      (fun ty_fun (l,ty,lv) -> newty2 lv (Tarrow(l,ty,ty_fun,Cok)))
      ty_fun omitted
  in
  let has_label l ty_fun =
    let ls, tvar = list_labels env ty_fun in
    tvar || List.mem l ls
  in
  let ignored = ref [] in
  let rec type_unknown_args
      (args :
      (Asttypes.label * (unit -> Typedtree.expression) option *
         Typedtree.optional) list)
    omitted ty_fun = function
      [] ->
        (List.map
            (function l, None, x -> l, None, x
                | l, Some f, x -> l, Some (f ()), x)
           (List.rev args),
         instance env (result_type omitted ty_fun))
    | (l1, sarg1) :: sargl ->
        let (ty1, ty2) =
          let ty_fun = expand_head env ty_fun in
          match ty_fun.desc with
            Tvar _ ->
              let t1 = newvar () and t2 = newvar () in
              let not_identity = function
                  Texp_ident(_,_,{val_kind=Val_prim
                                  {Primitive.prim_name="%identity"}}) ->
                    false
                | _ -> true
              in
              if ty_fun.level >= t1.level && not_identity funct.exp_desc then
                Location.prerr_warning sarg1.pexp_loc Warnings.Unused_argument;
              unify env ty_fun (newty (Tarrow(l1,t1,t2,Clink(ref Cunknown))));
              (t1, t2)
          | Tarrow (l,t1,t2,_) when l = l1
            || !Clflags.classic && l1 = "" && not (is_optional l) ->
              (t1, t2)
          | td ->
              let ty_fun =
                match td with Tarrow _ -> newty td | _ -> ty_fun in
              let ty_res = result_type (omitted @ !ignored) ty_fun in
              match ty_res.desc with
                Tarrow _ ->
                  if (!Clflags.classic || not (has_label l1 ty_fun)) then
                    raise (Error(sarg1.pexp_loc, env,
                                 Apply_wrong_label(l1, ty_res)))
                  else
                    raise (Error(funct.exp_loc, env, Incoherent_label_order))
              | _ ->
                  raise(Error(funct.exp_loc, env, Apply_non_function
                                (expand_head env funct.exp_type)))
        in
        let optional = if is_optional l1 then Optional else Required in
        let arg1 () =
          let arg1 = type_expect env sarg1 ty1 in
          if optional = Optional then
            unify_exp env arg1 (type_option(newvar()));
          arg1
        in
        type_unknown_args ((l1, Some arg1, optional) :: args) omitted ty2 sargl
  in
  let ignore_labels =
    !Clflags.classic ||
    begin
      let ls, tvar = list_labels env funct.exp_type in
      not tvar &&
      let labels = List.filter (fun l -> not (is_optional l)) ls in
      List.length labels = List.length sargs &&
      List.for_all (fun (l,_) -> l = "") sargs &&
      List.exists (fun l -> l <> "") labels &&
      (Location.prerr_warning funct.exp_loc Warnings.Labels_omitted;
       true)
    end
  in
  let warned = ref false in
  let rec type_args args omitted ty_fun ty_fun0 ty_old sargs more_sargs =
    match expand_head env ty_fun, expand_head env ty_fun0 with
      {desc=Tarrow (l, ty, ty_fun, com); level=lv} as ty_fun',
      {desc=Tarrow (_, ty0, ty_fun0, _)}
      when (sargs <> [] || more_sargs <> []) && commu_repr com = Cok ->
        let may_warn loc w =
          if not !warned && !Clflags.principal && lv <> generic_level
          then begin
            warned := true;
            Location.prerr_warning loc w
          end
        in
        let name = label_name l
        and optional = if is_optional l then Optional else Required in
        let sargs, more_sargs, arg =
          if ignore_labels && not (is_optional l) then begin
            (* In classic mode, omitted = [] *)
            match sargs, more_sargs with
              (l', sarg0) :: _, _ ->
                raise(Error(sarg0.pexp_loc, env,
                            Apply_wrong_label(l', ty_old)))
            | _, (l', sarg0) :: more_sargs ->
                if l <> l' && l' <> "" then
                  raise(Error(sarg0.pexp_loc, env,
                              Apply_wrong_label(l', ty_fun')))
                else
                  ([], more_sargs,
                   Some (fun () -> type_argument env sarg0 ty ty0))
            | _ ->
                assert false
          end else try
            let (l', sarg0, sargs, more_sargs) =
              try
                let (l', sarg0, sargs1, sargs2) = extract_label name sargs in
                if sargs1 <> [] then
                  may_warn sarg0.pexp_loc
                    (Warnings.Not_principal "commuting this argument");
                (l', sarg0, sargs1 @ sargs2, more_sargs)
              with Not_found ->
                let (l', sarg0, sargs1, sargs2) =
                  extract_label name more_sargs in
                if sargs1 <> [] || sargs <> [] then
                  may_warn sarg0.pexp_loc
                    (Warnings.Not_principal "commuting this argument");
                (l', sarg0, sargs @ sargs1, sargs2)
            in
            if optional = Required && is_optional l' then
              Location.prerr_warning sarg0.pexp_loc
                (Warnings.Nonoptional_label l);
            sargs, more_sargs,
            if optional = Required || is_optional l' then
              Some (fun () -> type_argument env sarg0 ty ty0)
            else begin
              may_warn sarg0.pexp_loc
                (Warnings.Not_principal "using an optional argument here");
              Some (fun () -> option_some (type_argument env sarg0
                                             (extract_option_type env ty)
                                             (extract_option_type env ty0)))
            end
          with Not_found ->
            sargs, more_sargs,
            if optional = Optional &&
              (List.mem_assoc "" sargs || List.mem_assoc "" more_sargs)
            then begin
              may_warn funct.exp_loc
                (Warnings.Without_principality "eliminated optional argument");
              ignored := (l,ty,lv) :: !ignored;
              Some (fun () -> option_none (instance env ty) Location.none)
            end else begin
              may_warn funct.exp_loc
                (Warnings.Without_principality "commuted an argument");
              None
            end
        in
        let omitted =
          if arg = None then (l,ty,lv) :: omitted else omitted in
        let ty_old = if sargs = [] then ty_fun else ty_old in
        type_args ((l,arg,optional)::args) omitted ty_fun ty_fun0
          ty_old sargs more_sargs
    | _ ->
        match sargs with
          (l, sarg0) :: _ when ignore_labels ->
            raise(Error(sarg0.pexp_loc, env,
                        Apply_wrong_label(l, ty_old)))
        | _ ->
            type_unknown_args args omitted ty_fun0
              (sargs @ more_sargs)
  in
  match funct.exp_desc, sargs with
    (* Special case for ignore: avoid discarding warning *)
    Texp_ident (_, _, {val_kind=Val_prim{Primitive.prim_name="%ignore"}}),
    ["", sarg] ->
      let ty_arg, ty_res = filter_arrow env (instance env funct.exp_type) "" in
      let exp = type_expect env sarg ty_arg in
      begin match (expand_head env exp.exp_type).desc with
      | Tarrow _ ->
          Location.prerr_warning exp.exp_loc Warnings.Partial_application
      | Tvar _ ->
          add_delayed_check (fun () -> check_application_result env false exp)
      | _ -> ()
      end;
      (["", Some exp, Required], ty_res)
  | _ ->
      let ty = funct.exp_type in
      if ignore_labels then
        type_args [] [] ty (instance env ty) ty [] sargs
      else
        type_args [] [] ty (instance env ty) ty sargs []

and type_construct env loc lid sarg ty_expected attrs =
  let opath =
    try
      let (p0, p,_) = extract_concrete_variant env ty_expected in
      Some(p0, p, ty_expected.level = generic_level || not !Clflags.principal)
    with Not_found -> None
  in
  let constrs = Typetexp.find_all_constructors env lid.loc lid.txt in
  let constr =
    wrap_disambiguate "This variant expression is expected to have" ty_expected
      (Constructor.disambiguate lid env opath) constrs in
  Env.mark_constructor Env.Positive env (Longident.last lid.txt) constr;
  Typetexp.check_deprecated loc constr.cstr_attributes constr.cstr_name;
  let sargs =
    match sarg with
      None -> []
    | Some {pexp_desc = Pexp_tuple sel} when
        constr.cstr_arity > 1 || explicit_arity attrs
      -> sel
    | Some se -> [se] in
  if List.length sargs <> constr.cstr_arity then
    raise(Error(loc, env, Constructor_arity_mismatch
                  (lid.txt, constr.cstr_arity, List.length sargs)));
  let separate = !Clflags.principal || Env.has_local_constraints env in
  if separate then (begin_def (); begin_def ());
  let (ty_args, ty_res) = instance_constructor constr in
  let texp =
    re {
      exp_desc = Texp_construct(lid, constr, []);
      exp_loc = loc; exp_extra = [];
      exp_type = ty_res;
      exp_attributes = attrs;
      exp_env = env } in
  if separate then begin
    end_def ();
    generalize_structure ty_res;
    unify_exp env {texp with exp_type = instance_def ty_res}
                  (instance env ty_expected);
    end_def ();
    List.iter generalize_structure ty_args;
    generalize_structure ty_res;
  end;
  let ty_args0, ty_res =
    match instance_list env (ty_res :: ty_args) with
      t :: tl -> tl, t
    | _ -> assert false
  in
  let texp = {texp with exp_type = ty_res} in
  if not separate then unify_exp env texp (instance env ty_expected);
  let args = List.map2 (fun e (t,t0) -> type_argument env e t t0) sargs
      (List.combine ty_args ty_args0) in
  if constr.cstr_private = Private then
    raise(Error(loc, env, Private_type ty_res));
  (* NOTE: shouldn't we call "re" on this final expression? -- AF *)
  { texp with
    exp_desc = Texp_construct(lid, constr, args) }

(* Typing of statements (expressions whose values are discarded) *)

and type_statement env sexp =
  let loc = (final_subexpression sexp).pexp_loc in
  begin_def();
  let exp = type_exp env sexp in
  end_def();
  if !Clflags.strict_sequence then
    let expected_ty = instance_def Predef.type_unit in
    unify_exp env exp expected_ty;
    exp else
  let ty = expand_head env exp.exp_type and tv = newvar() in
  begin match ty.desc with
  | Tarrow _ ->
      Location.prerr_warning loc Warnings.Partial_application
  | Tconstr (p, _, _) when Path.same p Predef.path_unit -> ()
  | Tvar _ when ty.level > tv.level ->
      Location.prerr_warning loc Warnings.Nonreturning_statement
  | Tvar _ ->
      add_delayed_check (fun () -> check_application_result env true exp)
  | _ ->
      Location.prerr_warning loc Warnings.Statement_type
  end;
  unify_var env tv ty;
  exp

(* Typing of match cases *)

and type_cases ?in_function env ty_arg ty_res partial_flag loc caselist =
  (* ty_arg is _fully_ generalized *)
  let patterns = List.map (fun {pc_lhs=p} -> p) caselist in
  let erase_either =
    List.exists contains_polymorphic_variant patterns
    && contains_variant_either ty_arg
  and has_gadts = List.exists (contains_gadt env) patterns in
(*  prerr_endline ( if has_gadts then "contains gadt" else "no gadt"); *)
  let ty_arg =
    if (has_gadts || erase_either) && not !Clflags.principal
    then correct_levels ty_arg else ty_arg
  and ty_res, env =
    if has_gadts && not !Clflags.principal then
      correct_levels ty_res, duplicate_ident_types loc caselist env
    else ty_res, env
  in
  let lev, env =
    if has_gadts then begin
      (* raise level for existentials *)
      begin_def ();
      Ident.set_current_time (get_current_level ());
      let lev = Ident.current_time () in
      Ctype.init_def (lev+1000);                 (* up to 1000 existentials *)
      (lev, Env.add_gadt_instance_level lev env)
    end else (get_current_level (), env)
  in
(*  if has_gadts then
    Format.printf "lev = %d@.%a@." lev Printtyp.raw_type_expr ty_res; *)
  begin_def (); (* propagation of the argument *)
  let ty_arg' = newvar () in
  let pattern_force = ref [] in
(*  Format.printf "@[%i %i@ %a@]@." lev (get_current_level())
    Printtyp.raw_type_expr ty_arg; *)
  let pat_env_list =
    List.map
      (fun {pc_lhs; pc_guard; pc_rhs} ->
        let loc =
          let open Location in
          match pc_guard with
          | None -> pc_rhs.pexp_loc
          | Some g -> {pc_rhs.pexp_loc with loc_start=g.pexp_loc.loc_start}
        in
        if !Clflags.principal then begin_def (); (* propagation of pattern *)
        let scope = Some (Annot.Idef loc) in
        let (pat, ext_env, force, unpacks) =
          let partial =
            if !Clflags.principal || erase_either
            then Some false else None in
          let ty_arg = instance ?partial env ty_arg in
          type_pattern ~lev env pc_lhs scope ty_arg
        in
        pattern_force := force @ !pattern_force;
        let pat =
          if !Clflags.principal then begin
            end_def ();
            iter_pattern (fun {pat_type=t} -> generalize_structure t) pat;
            { pat with pat_type = instance env pat.pat_type }
          end else pat
        in
        (pat, (ext_env, unpacks)))
      caselist in
  (* Unify cases (delayed to keep it order-free) *)
  let patl = List.map fst pat_env_list in
  List.iter (fun pat -> unify_pat env pat ty_arg') patl;
  (* Check for polymorphic variants to close *)
  if List.exists has_variants patl then begin
    Parmatch.pressure_variants env patl;
    List.iter (iter_pattern finalize_variant) patl
  end;
  (* `Contaminating' unifications start here *)
  List.iter (fun f -> f()) !pattern_force;
  (* Post-processing and generalization *)
  List.iter (iter_pattern (fun {pat_type=t} -> unify_var env t (newvar())))
    patl;
  List.iter (fun pat -> unify_pat env pat (instance env ty_arg)) patl;
  end_def ();
  List.iter (iter_pattern (fun {pat_type=t} -> generalize t)) patl;
  (* type bodies *)
  let in_function = if List.length caselist = 1 then in_function else None in
  let cases =
    List.map2
      (fun (pat, (ext_env, unpacks)) {pc_lhs; pc_guard; pc_rhs} ->
        let sexp = wrap_unpacks pc_rhs unpacks in
        let ty_res' =
          if !Clflags.principal then begin
            begin_def ();
            let ty = instance ~partial:true env ty_res in
            end_def ();
            generalize_structure ty; ty
          end
          else if contains_gadt env pc_lhs then correct_levels ty_res
          else ty_res in
(*        Format.printf "@[%i %i, ty_res' =@ %a@]@." lev (get_current_level())
          Printtyp.raw_type_expr ty_res'; *)
        let guard =
          match pc_guard with
          | None -> None
          | Some scond ->
              Some
                (type_expect ext_env (wrap_unpacks scond unpacks)
                   Predef.type_bool)
        in
        let exp = type_expect ?in_function ext_env sexp ty_res' in
        {
         c_lhs = pat;
         c_guard = guard;
         c_rhs = {exp with exp_type = instance env ty_res'}
        }
      )
      pat_env_list caselist
  in
  if !Clflags.principal || has_gadts then begin
    let ty_res' = instance env ty_res in
    List.iter (fun c -> unify_exp env c.c_rhs ty_res') cases
  end;
  let partial =
    if partial_flag then
      check_partial ~lev env ty_arg loc cases
    else
      Partial
  in
  add_delayed_check
    (fun () ->
      List.iter (fun (pat, (env, _)) -> check_absent_variant env pat)
        pat_env_list;
      Parmatch.check_unused env cases);
  if has_gadts then begin
    end_def ();
    (* Ensure that existential types do not escape *)
    unify_exp_types loc env (instance env ty_res) (newvar ()) ;
  end;
  cases, partial

(* Typing of let bindings *)

and type_let ?(check = fun s -> Warnings.Unused_var s)
             ?(check_strict = fun s -> Warnings.Unused_var_strict s)
    env rec_flag spat_sexp_list scope allow =
  let open Ast_helper in
  begin_def();
  if !Clflags.principal then begin_def ();

  let is_fake_let =
    match spat_sexp_list with
    | [{pvb_expr={pexp_desc=Pexp_match(
           {pexp_desc=Pexp_ident({ txt = Longident.Lident "*opt*"})},_)}}] ->
        true (* the fake let-declaration introduced by fun ?(x = e) -> ... *)
    | _ ->
        false
  in
  let check = if is_fake_let then check_strict else check in

  let spatl =
    List.map
      (fun {pvb_pat=spat; pvb_expr=sexp; pvb_attributes=_} ->
        match spat.ppat_desc, sexp.pexp_desc with
          (Ppat_any | Ppat_constraint _), _ -> spat
        | _, Pexp_coerce (_, _, sty)
        | _, Pexp_constraint (_, sty) when !Clflags.principal ->
            (* propagate type annotation to pattern,
               to allow it to be generalized in -principal mode *)
            Pat.constraint_
              ~loc:{spat.ppat_loc with Location.loc_ghost=true}
              spat
              sty
        | _ -> spat)
      spat_sexp_list in
  let nvs = List.map (fun _ -> newvar ()) spatl in
  let (pat_list, new_env, force, unpacks) =
    type_pattern_list env spatl scope nvs allow in
  let is_recursive = (rec_flag = Recursive) in
  (* If recursive, first unify with an approximation of the expression *)
  if is_recursive then
    List.iter2
      (fun pat binding ->
        let pat =
          match pat.pat_type.desc with
          | Tpoly (ty, tl) ->
              {pat with pat_type =
               snd (instance_poly ~keep_names:true false tl ty)}
          | _ -> pat
        in unify_pat env pat (type_approx env binding.pvb_expr))
      pat_list spat_sexp_list;
  (* Polymorphic variant processing *)
  List.iter
    (fun pat ->
      if has_variants pat then begin
        Parmatch.pressure_variants env [pat];
        iter_pattern finalize_variant pat
      end)
    pat_list;
  (* Generalize the structure *)
  let pat_list =
    if !Clflags.principal then begin
      end_def ();
      List.map
        (fun pat ->
          iter_pattern (fun pat -> generalize_structure pat.pat_type) pat;
          {pat with pat_type = instance env pat.pat_type})
        pat_list
    end else pat_list in
  (* Only bind pattern variables after generalizing *)
  List.iter (fun f -> f()) force;
  let exp_env =
    if is_recursive then new_env else env in

  let current_slot = ref None in
  let rec_needed = ref false in
  let warn_unused =
    Warnings.is_active (check "") || Warnings.is_active (check_strict "") ||
    (is_recursive && (Warnings.is_active Warnings.Unused_rec_flag))
  in
  let pat_slot_list =
    (* Algorithm to detect unused declarations in recursive bindings:
       - During type checking of the definitions, we capture the 'value_used'
         events on the bound identifiers and record them in a slot corresponding
         to the current definition (!current_slot).
         In effect, this creates a dependency graph between definitions.

       - After type checking the definition (!current_slot = None),
         when one of the bound identifier is effectively used, we trigger
         again all the events recorded in the corresponding slot.
         The effect is to traverse the transitive closure of the graph created
         in the first step.

       We also keep track of whether *all* variables in a given pattern
       are unused. If this is the case, for local declarations, the issued
       warning is 26, not 27.
     *)
    List.map
      (fun pat ->
        if not warn_unused then pat, None
        else
          let some_used = ref false in
            (* has one of the identifier of this pattern been used? *)
          let slot = ref [] in
          List.iter
            (fun (id,_) ->
              let vd = Env.find_value (Path.Pident id) new_env in
              (* note: Env.find_value does not trigger the value_used event *)
              let name = Ident.name id in
              let used = ref false in
              if not (name = "" || name.[0] = '_' || name.[0] = '#') then
                add_delayed_check
                  (fun () ->
                    if not !used then
                      Location.prerr_warning vd.Types.val_loc
                        ((if !some_used then check_strict else check) name)
                  );
              Env.set_value_used_callback
                name vd
                (fun () ->
                  match !current_slot with
                  | Some slot ->
                      slot := (name, vd) :: !slot; rec_needed := true
                  | None ->
                      List.iter
                        (fun (name, vd) -> Env.mark_value_used env name vd)
                        (get_ref slot);
                      used := true;
                      some_used := true
                )
            )
            (Typedtree.pat_bound_idents pat);
          pat, Some slot
        )
      pat_list
  in
  let exp_list =
    List.map2
      (fun {pvb_expr=sexp; _} (pat, slot) ->
        let sexp =
          if rec_flag = Recursive then wrap_unpacks sexp unpacks else sexp in
        if is_recursive then current_slot := slot;
        match pat.pat_type.desc with
        | Tpoly (ty, tl) ->
            begin_def ();
            if !Clflags.principal then begin_def ();
            let vars, ty' = instance_poly ~keep_names:true true tl ty in
            if !Clflags.principal then begin
              end_def ();
              generalize_structure ty'
            end;
            let exp = type_expect exp_env sexp ty' in
            end_def ();
            check_univars env true "definition" exp pat.pat_type vars;
            {exp with exp_type = instance env exp.exp_type}
        | _ -> type_expect exp_env sexp pat.pat_type)
      spat_sexp_list pat_slot_list in
  current_slot := None;
  if is_recursive && not !rec_needed
  && Warnings.is_active Warnings.Unused_rec_flag then
    Location.prerr_warning (List.hd spat_sexp_list).pvb_pat.ppat_loc
      Warnings.Unused_rec_flag;
  List.iter2
    (fun pat exp ->
      ignore(check_partial env pat.pat_type pat.pat_loc [case pat exp]))
    pat_list exp_list;
  end_def();
  List.iter2
    (fun pat exp ->
       if not (is_nonexpansive exp) then
         iter_pattern (fun pat -> generalize_expansive env pat.pat_type) pat)
    pat_list exp_list;
  List.iter
    (fun pat -> iter_pattern (fun pat -> generalize pat.pat_type) pat)
    pat_list;
  let l = List.combine pat_list exp_list in
  let l =
    List.map2
      (fun (p, e) pvb ->
        {vb_pat=p; vb_expr=e; vb_attributes=pvb.pvb_attributes;
         vb_loc=pvb.pvb_loc;
        })
      l spat_sexp_list
  in
  (l, new_env, unpacks)

(* Typing of toplevel bindings *)

let type_binding env rec_flag spat_sexp_list scope =
  Typetexp.reset_type_variables();
  let (pat_exp_list, new_env, unpacks) =
    type_let
      ~check:(fun s -> Warnings.Unused_value_declaration s)
      ~check_strict:(fun s -> Warnings.Unused_value_declaration s)
      env rec_flag spat_sexp_list scope false
  in
  (pat_exp_list, new_env)

let type_let env rec_flag spat_sexp_list scope =
  let (pat_exp_list, new_env, unpacks) =
    type_let env rec_flag spat_sexp_list scope false in
  (pat_exp_list, new_env)

(* Typing of toplevel expressions *)

let type_expression env sexp =
  Typetexp.reset_type_variables();
  begin_def();
  let exp = type_exp env sexp in
  end_def();
  if is_nonexpansive exp then generalize exp.exp_type
  else generalize_expansive env exp.exp_type;
  match sexp.pexp_desc with
    Pexp_ident lid ->
      (* Special case for keeping type variables when looking-up a variable *)
      let (path, desc) = Env.lookup_value lid.txt env in
      {exp with exp_type = desc.val_type}
  | _ -> exp

(* Error report *)

open Format
open Printtyp

let report_error env ppf = function
  | Polymorphic_label lid ->
      fprintf ppf "@[The record field %a is polymorphic.@ %s@]"
        longident lid "You cannot instantiate it in a pattern."
  | Constructor_arity_mismatch(lid, expected, provided) ->
      fprintf ppf
       "@[The constructor %a@ expects %i argument(s),@ \
        but is applied here to %i argument(s)@]"
       longident lid expected provided
  | Label_mismatch(lid, trace) ->
      report_unification_error ppf env trace
        (function ppf ->
           fprintf ppf "The record field %a@ belongs to the type"
                   longident lid)
        (function ppf ->
           fprintf ppf "but is mixed here with fields of type")
  | Pattern_type_clash trace ->
      report_unification_error ppf env trace
        (function ppf ->
          fprintf ppf "This pattern matches values of type")
        (function ppf ->
          fprintf ppf "but a pattern was expected which matches values of type")
  | Or_pattern_type_clash (id, trace) ->
      report_unification_error ppf env trace
        (function ppf ->
          fprintf ppf "The variable %s on the left-hand side of this or-pattern has type" (Ident.name id))
        (function ppf ->
          fprintf ppf "but on the right-hand side it has type")
  | Multiply_bound_variable name ->
      fprintf ppf "Variable %s is bound several times in this matching" name
  | Orpat_vars id ->
      fprintf ppf "Variable %s must occur on both sides of this | pattern"
        (Ident.name id)
  | Expr_type_clash trace ->
      report_unification_error ppf env trace
        (function ppf ->
           fprintf ppf "This expression has type")
        (function ppf ->
           fprintf ppf "but an expression was expected of type")
  | Apply_non_function typ ->
      reset_and_mark_loops typ;
      begin match (repr typ).desc with
        Tarrow _ ->
          fprintf ppf "@[<v>@[<2>This function has type@ %a@]"
            type_expr typ;
          fprintf ppf "@ @[It is applied to too many arguments;@ %s@]@]"
                      "maybe you forgot a `;'."
      | _ ->
          fprintf ppf "@[<v>@[<2>This expression has type@ %a@]@ %s@]"
            type_expr typ
            "This is not a function; it cannot be applied."
      end
  | Apply_wrong_label (l, ty) ->
      let print_label ppf = function
        | "" -> fprintf ppf "without label"
        | l ->
            fprintf ppf "with label %s" (prefixed_label_name l)
      in
      reset_and_mark_loops ty;
      fprintf ppf
        "@[<v>@[<2>The function applied to this argument has type@ %a@]@.\
          This argument cannot be applied %a@]"
        type_expr ty print_label l
  | Label_multiply_defined s ->
      fprintf ppf "The record field label %s is defined several times" s
  | Label_missing labels ->
      let print_labels ppf =
        List.iter (fun lbl -> fprintf ppf "@ %s" (Ident.name lbl)) in
      fprintf ppf "@[<hov>Some record fields are undefined:%a@]"
        print_labels labels
  | Label_not_mutable lid ->
      fprintf ppf "The record field %a is not mutable" longident lid
  | Wrong_name (eorp, ty, kind, p, lid) ->
      reset_and_mark_loops ty;
      fprintf ppf "@[@[<2>%s type@ %a@]@ "
        eorp type_expr ty;
      fprintf ppf "The %s %a does not belong to type %a@]"
        (if kind = "record" then "field" else "constructor")
        longident lid (*kind*) path p;
      if kind = "record" then Label.spellcheck ppf env p lid
                         else Constructor.spellcheck ppf env p lid
  | Name_type_mismatch (kind, lid, tp, tpl) ->
      let name = if kind = "record" then "field" else "constructor" in
      report_ambiguous_type_error ppf env tp tpl
        (function ppf ->
           fprintf ppf "The %s %a@ belongs to the %s type"
             name longident lid kind)
        (function ppf ->
           fprintf ppf "The %s %a@ belongs to one of the following %s types:"
             name longident lid kind)
        (function ppf ->
           fprintf ppf "but a %s was expected belonging to the %s type"
             name kind)
  | Invalid_format msg ->
      fprintf ppf "%s" msg
  | Undefined_method (ty, me) ->
      reset_and_mark_loops ty;
      fprintf ppf
        "@[<v>@[This expression has type@;<1 2>%a@]@,\
         It has no method %s@]" type_expr ty me
  | Undefined_inherited_method me ->
      fprintf ppf "This expression has no method %s" me
  | Virtual_class cl ->
      fprintf ppf "Cannot instantiate the virtual class %a"
        longident cl
  | Unbound_instance_variable v ->
      fprintf ppf "Unbound instance variable %s" v
  | Instance_variable_not_mutable (b, v) ->
      if b then
        fprintf ppf "The instance variable %s is not mutable" v
      else
        fprintf ppf "The value %s is not an instance variable" v
  | Not_subtype(tr1, tr2) ->
      report_subtyping_error ppf env tr1 "is not a subtype of" tr2
  | Outside_class ->
      fprintf ppf "This object duplication occurs outside a method definition"
  | Value_multiply_overridden v ->
      fprintf ppf "The instance variable %s is overridden several times" v
  | Coercion_failure (ty, ty', trace, b) ->
      report_unification_error ppf env trace
        (function ppf ->
           let ty, ty' = prepare_expansion (ty, ty') in
           fprintf ppf
             "This expression cannot be coerced to type@;<1 2>%a;@ it has type"
           (type_expansion ty) ty')
        (function ppf ->
           fprintf ppf "but is here used with type");
      if b then
        fprintf ppf ".@.@[<hov>%s@ %s@]"
          "This simple coercion was not fully general."
          "Consider using a double coercion."
  | Too_many_arguments (in_function, ty) ->
      reset_and_mark_loops ty;
      if in_function then begin
        fprintf ppf "This function expects too many arguments,@ ";
        fprintf ppf "it should have type@ %a"
          type_expr ty
      end else begin
        fprintf ppf "This expression should not be a function,@ ";
        fprintf ppf "the expected type is@ %a"
          type_expr ty
      end
  | Abstract_wrong_label (l, ty) ->
      let label_mark = function
        | "" -> "but its first argument is not labelled"
        |  l -> sprintf "but its first argument is labelled %s"
          (prefixed_label_name l) in
      reset_and_mark_loops ty;
      fprintf ppf "@[<v>@[<2>This function should have type@ %a@]@,%s@]"
      type_expr ty (label_mark l)
  | Scoping_let_module(id, ty) ->
      reset_and_mark_loops ty;
      fprintf ppf
       "This `let module' expression has type@ %a@ " type_expr ty;
      fprintf ppf
       "In this type, the locally bound module name %s escapes its scope" id
  | Masked_instance_variable lid ->
      fprintf ppf
        "The instance variable %a@ \
         cannot be accessed from the definition of another instance variable"
        longident lid
  | Private_type ty ->
      fprintf ppf "Cannot create values of the private type %a" type_expr ty
  | Private_label (lid, ty) ->
      fprintf ppf "Cannot assign field %a of the private type %a"
        longident lid type_expr ty
  | Not_a_variant_type lid ->
      fprintf ppf "The type %a@ is not a variant type" longident lid
  | Incoherent_label_order ->
      fprintf ppf "This function is applied to arguments@ ";
      fprintf ppf "in an order different from other calls.@ ";
      fprintf ppf "This is only allowed when the real type is known."
  | Less_general (kind, trace) ->
      report_unification_error ppf env trace
        (fun ppf -> fprintf ppf "This %s has type" kind)
        (fun ppf -> fprintf ppf "which is less general than")
  | Modules_not_allowed ->
      fprintf ppf "Modules are not allowed in this pattern."
  | Cannot_infer_signature ->
      fprintf ppf
        "The signature for this packaged module couldn't be inferred."
  | Not_a_packed_module ty ->
      fprintf ppf
        "This expression is packed module, but the expected type is@ %a"
        type_expr ty
  | Recursive_local_constraint trace ->
      report_unification_error ppf env trace
        (function ppf ->
           fprintf ppf "Recursive local constraint when unifying")
        (function ppf ->
           fprintf ppf "with")
  | Unexpected_existential ->
      fprintf ppf
        "Unexpected existential"
  | Unqualified_gadt_pattern (tpath, name) ->
      fprintf ppf "@[The GADT constructor %s of type %a@ %s.@]"
        name path tpath
        "must be qualified in this pattern"
  | Invalid_interval ->
      fprintf ppf "@[Only character intervals are supported in patterns.@]"
  | Invalid_for_loop_index ->
      fprintf ppf
        "@[Invalid for-loop index: only variables and _ are allowed.@]"
  | No_value_clauses ->
      fprintf ppf
        "None of the patterns in this 'match' expression match values."
  | Exception_pattern_below_toplevel ->
      fprintf ppf
        "@[Exception patterns must be at the top level of a match case.@]"

let report_error env ppf err =
  wrap_printing_env env (fun () -> report_error env ppf err)

let () =
  Location.register_error_of_exn
    (function
      | Error (loc, env, err) ->
        Some (Location.error_of_printer loc (report_error env) err)
      | Error_forward err ->
        Some err
      | _ ->
        None
    )

let () =
  Env.add_delayed_check_forward := add_delayed_check

end
module Typedecl : sig 
#1 "typedecl.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Typing of type definitions and primitive definitions *)

open Types
open Format

val transl_type_decl:
    Env.t -> Asttypes.rec_flag -> Parsetree.type_declaration list ->
    Typedtree.type_declaration list * Env.t

val transl_exception:
    Env.t ->
    Parsetree.extension_constructor -> Typedtree.extension_constructor * Env.t

val transl_type_extension:
    bool -> Env.t -> Location.t -> Parsetree.type_extension ->
    Typedtree.type_extension * Env.t

val transl_value_decl:
    Env.t -> Location.t ->
    Parsetree.value_description -> Typedtree.value_description * Env.t

val transl_with_constraint:
    Env.t -> Ident.t -> Path.t option -> Types.type_declaration ->
    Parsetree.type_declaration -> Typedtree.type_declaration

val abstract_type_decl: int -> type_declaration
val approx_type_decl:
    Env.t -> Parsetree.type_declaration list ->
                                  (Ident.t * type_declaration) list
val check_recmod_typedecl:
    Env.t -> Location.t -> Ident.t list -> Path.t -> type_declaration -> unit
val check_coherence:
    Env.t -> Location.t -> Ident.t -> type_declaration -> unit

(* for fixed types *)
val is_fixed_type : Parsetree.type_declaration -> bool

(* for typeclass.ml *)
val compute_variance_decls:
    Env.t ->
    (Ident.t * Types.type_declaration * Types.type_declaration *
     Types.class_declaration * Types.class_type_declaration *
     'a Typedtree.class_infos) list ->
    (Types.type_declaration * Types.type_declaration *
     Types.class_declaration * Types.class_type_declaration) list

type error =
    Repeated_parameter
  | Duplicate_constructor of string
  | Too_many_constructors
  | Duplicate_label of string
  | Recursive_abbrev of string
  | Cycle_in_def of string * type_expr
  | Definition_mismatch of type_expr * Includecore.type_mismatch list
  | Constraint_failed of type_expr * type_expr
  | Inconsistent_constraint of Env.t * (type_expr * type_expr) list
  | Type_clash of Env.t * (type_expr * type_expr) list
  | Parameters_differ of Path.t * type_expr * type_expr
  | Null_arity_external
  | Missing_native_external
  | Unbound_type_var of type_expr * type_declaration
  | Not_open_type of Path.t
  | Not_extensible_type of Path.t
  | Extension_mismatch of Path.t * Includecore.type_mismatch list
  | Rebind_wrong_type of Longident.t * Env.t * (type_expr * type_expr) list
  | Rebind_mismatch of Longident.t * Path.t * Path.t
  | Rebind_private of Longident.t
  | Bad_variance of int * (bool*bool*bool) * (bool*bool*bool)
  | Unavailable_type_constructor of Path.t
  | Bad_fixed_type of string
  | Unbound_type_var_ext of type_expr * extension_constructor
  | Varying_anonymous

exception Error of Location.t * error

val report_error: formatter -> error -> unit

end = struct
#1 "typedecl.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(* Xavier Leroy and Jerome Vouillon, projet Cristal, INRIA Rocquencourt*)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(**** Typing of type definitions ****)

open Misc
open Asttypes
open Parsetree
open Primitive
open Types
open Typetexp

type error =
    Repeated_parameter
  | Duplicate_constructor of string
  | Too_many_constructors
  | Duplicate_label of string
  | Recursive_abbrev of string
  | Cycle_in_def of string * type_expr
  | Definition_mismatch of type_expr * Includecore.type_mismatch list
  | Constraint_failed of type_expr * type_expr
  | Inconsistent_constraint of Env.t * (type_expr * type_expr) list
  | Type_clash of Env.t * (type_expr * type_expr) list
  | Parameters_differ of Path.t * type_expr * type_expr
  | Null_arity_external
  | Missing_native_external
  | Unbound_type_var of type_expr * type_declaration
  | Not_open_type of Path.t
  | Not_extensible_type of Path.t
  | Extension_mismatch of Path.t * Includecore.type_mismatch list
  | Rebind_wrong_type of Longident.t * Env.t * (type_expr * type_expr) list
  | Rebind_mismatch of Longident.t * Path.t * Path.t
  | Rebind_private of Longident.t
  | Bad_variance of int * (bool * bool * bool) * (bool * bool * bool)
  | Unavailable_type_constructor of Path.t
  | Bad_fixed_type of string
  | Unbound_type_var_ext of type_expr * extension_constructor
  | Varying_anonymous

open Typedtree

exception Error of Location.t * error

(* Enter all declared types in the environment as abstract types *)

let enter_type env sdecl id =
  let decl =
    { type_params =
        List.map (fun _ -> Btype.newgenvar ()) sdecl.ptype_params;
      type_arity = List.length sdecl.ptype_params;
      type_kind = Type_abstract;
      type_private = sdecl.ptype_private;
      type_manifest =
        begin match sdecl.ptype_manifest with None -> None
        | Some _ -> Some(Ctype.newvar ()) end;
      type_variance = List.map (fun _ -> Variance.full) sdecl.ptype_params;
      type_newtype_level = None;
      type_loc = sdecl.ptype_loc;
      type_attributes = sdecl.ptype_attributes;
    }
  in
  Env.add_type ~check:true id decl env

let update_type temp_env env id loc =
  let path = Path.Pident id in
  let decl = Env.find_type path temp_env in
  match decl.type_manifest with None -> ()
  | Some ty ->
      let params = List.map (fun _ -> Ctype.newvar ()) decl.type_params in
      try Ctype.unify env (Ctype.newconstr path params) ty
      with Ctype.Unify trace ->
        raise (Error(loc, Type_clash (env, trace)))

(* Determine if a type is (an abbreviation for) the type "float" *)
(* We use the Ctype.expand_head_opt version of expand_head to get access
   to the manifest type of private abbreviations. *)
let is_float env ty =
  match Ctype.repr (Ctype.expand_head_opt env ty) with
    {desc = Tconstr(p, _, _)} -> Path.same p Predef.path_float
  | _ -> false

(* Determine if a type definition defines a fixed type. (PW) *)
let is_fixed_type sd =
  let rec has_row_var sty =
    match sty.ptyp_desc with
      Ptyp_alias (sty, _) -> has_row_var sty
    | Ptyp_class _
    | Ptyp_object (_, Open)
    | Ptyp_variant (_, Open, _)
    | Ptyp_variant (_, Closed, Some _) -> true
    | _ -> false
  in
  match sd.ptype_manifest with
    None -> false
  | Some sty ->
      sd.ptype_kind = Ptype_abstract &&
      sd.ptype_private = Private &&
      has_row_var sty

(* Set the row variable in a fixed type *)
let set_fixed_row env loc p decl =
  let tm =
    match decl.type_manifest with
      None -> assert false
    | Some t -> Ctype.expand_head env t
  in
  let rv =
    match tm.desc with
      Tvariant row ->
        let row = Btype.row_repr row in
        tm.desc <- Tvariant {row with row_fixed = true};
        if Btype.static_row row then Btype.newgenty Tnil
        else row.row_more
    | Tobject (ty, _) ->
        snd (Ctype.flatten_fields ty)
    | _ ->
        raise (Error (loc, Bad_fixed_type "is not an object or variant"))
  in
  if not (Btype.is_Tvar rv) then
    raise (Error (loc, Bad_fixed_type "has no row variable"));
  rv.desc <- Tconstr (p, decl.type_params, ref Mnil)

(* Translate one type declaration *)

module StringSet =
  Set.Make(struct
    type t = string
    let compare (x:t) y = compare x y
  end)

let make_params env params =
  let make_param (sty, v) =
    try
      (transl_type_param env sty, v)
    with Already_bound ->
      raise(Error(sty.ptyp_loc, Repeated_parameter))
  in
    List.map make_param params

let make_constructor env type_path type_params sargs sret_type =
  match sret_type with
  | None ->
      let targs = List.map (transl_simple_type env true) sargs in
      let args = List.map (fun cty -> cty.ctyp_type) targs in
        targs, None, args, None
  | Some sret_type ->
      (* if it's a generalized constructor we must first narrow and
         then widen so as to not introduce any new constraints *)
      let z = narrow () in
      reset_type_variables ();
      let targs = List.map (transl_simple_type env false) sargs in
      let args = List.map (fun cty -> cty.ctyp_type) targs in
      let tret_type = transl_simple_type env false sret_type in
      let ret_type = tret_type.ctyp_type in
      begin
        match (Ctype.repr ret_type).desc with
          Tconstr (p', _, _) when Path.same type_path p' -> ()
        | _ ->
            raise (Error (sret_type.ptyp_loc, Constraint_failed
                            (ret_type, Ctype.newconstr type_path type_params)))
      end;
      widen z;
      targs, Some tret_type, args, Some ret_type

let transl_declaration env sdecl id =
  (* Bind type parameters *)
  reset_type_variables();
  Ctype.begin_def ();
  let tparams = make_params env sdecl.ptype_params in
  let params = List.map (fun (cty, _) -> cty.ctyp_type) tparams in
  let cstrs = List.map
    (fun (sty, sty', loc) ->
      transl_simple_type env false sty,
      transl_simple_type env false sty', loc)
    sdecl.ptype_cstrs
  in
  let (tkind, kind) =
    match sdecl.ptype_kind with
        Ptype_abstract -> Ttype_abstract, Type_abstract
      | Ptype_variant scstrs ->
        if scstrs = [] then
          Syntaxerr.ill_formed_ast sdecl.ptype_loc
            "Variant types cannot be empty.";
        let all_constrs = ref StringSet.empty in
        List.iter
          (fun {pcd_name = {txt = name}} ->
            if StringSet.mem name !all_constrs then
              raise(Error(sdecl.ptype_loc, Duplicate_constructor name));
            all_constrs := StringSet.add name !all_constrs)
          scstrs;
        if List.length
          (List.filter (fun cd -> cd.pcd_args <> []) scstrs)
          > (Config.max_tag + 1) then
          raise(Error(sdecl.ptype_loc, Too_many_constructors));
        let make_cstr scstr =
          let name = Ident.create scstr.pcd_name.txt in
          let targs, tret_type, args, ret_type =
            make_constructor env (Path.Pident id) params
                             scstr.pcd_args scstr.pcd_res
          in
          let tcstr =
            { cd_id = name;
              cd_name = scstr.pcd_name;
              cd_args = targs;
              cd_res = tret_type;
              cd_loc = scstr.pcd_loc;
              cd_attributes = scstr.pcd_attributes }
          in
          let cstr =
            { Types.cd_id = name;
              cd_args = args;
              cd_res = ret_type;
              cd_loc = scstr.pcd_loc;
              cd_attributes = scstr.pcd_attributes }
          in
            tcstr, cstr
        in
        let tcstrs, cstrs = List.split (List.map make_cstr scstrs) in
          Ttype_variant tcstrs, Type_variant cstrs
      | Ptype_record lbls ->
        if lbls = [] then
          Syntaxerr.ill_formed_ast sdecl.ptype_loc "Records cannot be empty.";
        let all_labels = ref StringSet.empty in
        List.iter
          (fun {pld_name = {txt=name}} ->
            if StringSet.mem name !all_labels then
              raise(Error(sdecl.ptype_loc, Duplicate_label name));
            all_labels := StringSet.add name !all_labels)
          lbls;
        let lbls = List.map (fun {pld_name=name;
                                  pld_mutable=mut;
                                  pld_type=arg;
                                  pld_loc=loc;
                                  pld_attributes=attrs} ->
          let arg = Ast_helper.Typ.force_poly arg in
          let cty = transl_simple_type env true arg in
          {ld_id = Ident.create name.txt; ld_name = name; ld_mutable = mut;
           ld_type = cty; ld_loc = loc; ld_attributes = attrs}
          ) lbls in
        let lbls' =
          List.map
            (fun ld ->
              let ty = ld.ld_type.ctyp_type in
              let ty = match ty.desc with Tpoly(t,[]) -> t | _ -> ty in
              {Types.ld_id = ld.ld_id;
               ld_mutable = ld.ld_mutable;
               ld_type = ty;
               ld_loc = ld.ld_loc;
               ld_attributes = ld.ld_attributes
              }
            )
            lbls in
        let rep =
          if List.for_all (fun l -> is_float env l.Types.ld_type) lbls'
          then Record_float
          else Record_regular in
        Ttype_record lbls, Type_record(lbls', rep)
      | Ptype_open -> Ttype_open, Type_open
      in
    let (tman, man) = match sdecl.ptype_manifest with
        None -> None, None
      | Some sty ->
        let no_row = not (is_fixed_type sdecl) in
        let cty = transl_simple_type env no_row sty in
        Some cty, Some cty.ctyp_type
    in
    let decl =
      { type_params = params;
        type_arity = List.length params;
        type_kind = kind;
        type_private = sdecl.ptype_private;
        type_manifest = man;
        type_variance = List.map (fun _ -> Variance.full) params;
        type_newtype_level = None;
        type_loc = sdecl.ptype_loc;
        type_attributes = sdecl.ptype_attributes;
      } in

  (* Check constraints *)
    List.iter
      (fun (cty, cty', loc) ->
        let ty = cty.ctyp_type in
        let ty' = cty'.ctyp_type in
        try Ctype.unify env ty ty' with Ctype.Unify tr ->
          raise(Error(loc, Inconsistent_constraint (env, tr))))
      cstrs;
    Ctype.end_def ();
  (* Add abstract row *)
    if is_fixed_type sdecl then begin
      let (p, _) =
        try Env.lookup_type (Longident.Lident(Ident.name id ^ "#row")) env
        with Not_found -> assert false in
      set_fixed_row env sdecl.ptype_loc p decl
    end;
  (* Check for cyclic abbreviations *)
    begin match decl.type_manifest with None -> ()
      | Some ty ->
        if Ctype.cyclic_abbrev env id ty then
          raise(Error(sdecl.ptype_loc, Recursive_abbrev sdecl.ptype_name.txt));
    end;
    {
      typ_id = id;
      typ_name = sdecl.ptype_name;
      typ_params = tparams;
      typ_type = decl;
      typ_cstrs = cstrs;
      typ_loc = sdecl.ptype_loc;
      typ_manifest = tman;
      typ_kind = tkind;
      typ_private = sdecl.ptype_private;
      typ_attributes = sdecl.ptype_attributes;
    }

(* Generalize a type declaration *)

let generalize_decl decl =
  List.iter Ctype.generalize decl.type_params;
  begin match decl.type_kind with
    Type_abstract ->
      ()
  | Type_variant v ->
      List.iter
        (fun c ->
          List.iter Ctype.generalize c.Types.cd_args;
          may Ctype.generalize c.Types.cd_res)
        v
  | Type_record(r, rep) ->
      List.iter (fun l -> Ctype.generalize l.Types.ld_type) r
  | Type_open ->
      ()
  end;
  begin match decl.type_manifest with
  | None    -> ()
  | Some ty -> Ctype.generalize ty
  end

(* Check that all constraints are enforced *)

module TypeSet = Btype.TypeSet
module TypeMap = Btype.TypeMap

let rec check_constraints_rec env loc visited ty =
  let ty = Ctype.repr ty in
  if TypeSet.mem ty !visited then () else begin
  visited := TypeSet.add ty !visited;
  match ty.desc with
  | Tconstr (path, args, _) ->
      let args' = List.map (fun _ -> Ctype.newvar ()) args in
      let ty' = Ctype.newconstr path args' in
      begin try Ctype.enforce_constraints env ty'
      with Ctype.Unify _ -> assert false
      | Not_found -> raise (Error(loc, Unavailable_type_constructor path))
      end;
      if not (Ctype.matches env ty ty') then
        raise (Error(loc, Constraint_failed (ty, ty')));
      List.iter (check_constraints_rec env loc visited) args
  | Tpoly (ty, tl) ->
      let _, ty = Ctype.instance_poly false tl ty in
      check_constraints_rec env loc visited ty
  | _ ->
      Btype.iter_type_expr (check_constraints_rec env loc visited) ty
  end

module SMap = Map.Make(String)

let check_constraints env sdecl (_, decl) =
  let visited = ref TypeSet.empty in
  begin match decl.type_kind with
  | Type_abstract -> ()
  | Type_variant l ->
      let find_pl = function
          Ptype_variant pl -> pl
        | Ptype_record _ | Ptype_abstract | Ptype_open -> assert false
      in
      let pl = find_pl sdecl.ptype_kind in
      let pl_index =
        let foldf acc x =
          SMap.add x.pcd_name.txt x acc
        in
        List.fold_left foldf SMap.empty pl
      in
      List.iter
        (fun {Types.cd_id=name; cd_args=tyl; cd_res=ret_type} ->
          let {pcd_args = styl; pcd_res = sret_type; _} =
            try SMap.find (Ident.name name) pl_index
            with Not_found -> assert false in
          List.iter2
            (fun sty ty ->
              check_constraints_rec env sty.ptyp_loc visited ty)
            styl tyl;
          match sret_type, ret_type with
          | Some sr, Some r ->
              check_constraints_rec env sr.ptyp_loc visited r
          | _ ->
              () )
        l
  | Type_record (l, _) ->
      let find_pl = function
          Ptype_record pl -> pl
        | Ptype_variant _ | Ptype_abstract | Ptype_open -> assert false
      in
      let pl = find_pl sdecl.ptype_kind in
      let rec get_loc name = function
          [] -> assert false
        | pld :: tl ->
            if name = pld.pld_name.txt then pld.pld_type.ptyp_loc
            else get_loc name tl
      in
      List.iter
        (fun {Types.ld_id=name; ld_type=ty} ->
          check_constraints_rec env (get_loc (Ident.name name) pl) visited ty)
        l
  | Type_open -> ()
  end;
  begin match decl.type_manifest with
  | None -> ()
  | Some ty ->
      let sty =
        match sdecl.ptype_manifest with Some sty -> sty | _ -> assert false
      in
      check_constraints_rec env sty.ptyp_loc visited ty
  end

(*
   If both a variant/record definition and a type equation are given,
   need to check that the equation refers to a type of the same kind
   with the same constructors and labels.
*)
let check_coherence env loc id decl =
  match decl with
    { type_kind = (Type_variant _ | Type_record _| Type_open);
      type_manifest = Some ty } ->
      begin match (Ctype.repr ty).desc with
        Tconstr(path, args, _) ->
          begin try
            let decl' = Env.find_type path env in
            let err =
              if List.length args <> List.length decl.type_params
              then [Includecore.Arity]
              else if not (Ctype.equal env false args decl.type_params)
              then [Includecore.Constraint]
              else
                Includecore.type_declarations ~equality:true env
                  (Path.last path)
                  decl'
                  id
                  (Subst.type_declaration
                     (Subst.add_type id path Subst.identity) decl)
            in
            if err <> [] then
              raise(Error(loc, Definition_mismatch (ty, err)))
          with Not_found ->
            raise(Error(loc, Unavailable_type_constructor path))
          end
      | _ -> raise(Error(loc, Definition_mismatch (ty, [])))
      end
  | _ -> ()

let check_abbrev env sdecl (id, decl) =
  check_coherence env sdecl.ptype_loc id decl

(* Check that recursion is well-founded *)

let check_well_founded env loc path to_check ty =
  let visited = ref TypeMap.empty in
  let rec check ty0 exp_nodes ty =
    let ty = Btype.repr ty in
    if TypeSet.mem ty exp_nodes then begin
      (*Format.eprintf "@[%a@]@." Printtyp.raw_type_expr ty;*)
      if match ty0.desc with
      | Tconstr (p, _, _) -> Path.same p path
      | _ -> false
      then raise (Error (loc, Recursive_abbrev (Path.name path)))
      else raise (Error (loc, Cycle_in_def (Path.name path, ty0)))
    end;
    let (fini, exp_nodes) =
      try
        let prev = TypeMap.find ty !visited in
        if TypeSet.subset exp_nodes prev then (true, exp_nodes) else
        (false, TypeSet.union exp_nodes prev)
      with Not_found ->
        (false, exp_nodes)
    in
    let snap = Btype.snapshot () in
    if fini then () else try
      visited := TypeMap.add ty exp_nodes !visited;
      match ty.desc with
      | Tconstr(p, args, _)
        when not (TypeSet.is_empty exp_nodes) || to_check p ->
          let ty' = Ctype.try_expand_once_opt env ty in
          let ty0 = if TypeSet.is_empty exp_nodes then ty else ty0 in
          check ty0 (TypeSet.add ty exp_nodes) ty'
      | _ -> raise Ctype.Cannot_expand
    with
    | Ctype.Cannot_expand ->
        let nodes =
          if !Clflags.recursive_types && Ctype.is_contractive env ty
          || match ty.desc with Tobject _ | Tvariant _ -> true | _ -> false
          then TypeSet.empty
          else exp_nodes in
        Btype.iter_type_expr (check ty0 nodes) ty
    | Ctype.Unify _ ->
        (* Will be detected by check_recursion *)
        Btype.backtrack snap
  in
  Ctype.wrap_trace_gadt_instances env (check ty TypeSet.empty) ty

let check_well_founded_manifest env loc path decl =
  if decl.type_manifest = None then () else
  let args = List.map (fun _ -> Ctype.newvar()) decl.type_params in
  check_well_founded env loc path (Path.same path) (Ctype.newconstr path args)

let check_well_founded_decl env loc path decl to_check =
  let open Btype in
  let it =
    {type_iterators with
     it_type_expr = (fun _ -> check_well_founded env loc path to_check)} in
  it.it_type_declaration it (Ctype.instance_declaration decl)

(* Check for ill-defined abbrevs *)

let check_recursion env loc path decl to_check =
  (* to_check is true for potentially mutually recursive paths.
     (path, decl) is the type declaration to be checked. *)

  if decl.type_params = [] then () else

  let visited = ref [] in

  let rec check_regular cpath args prev_exp ty =
    let ty = Ctype.repr ty in
    if not (List.memq ty !visited) then begin
      visited := ty :: !visited;
      match ty.desc with
      | Tconstr(path', args', _) ->
          if Path.same path path' then begin
            if not (Ctype.equal env false args args') then
              raise (Error(loc,
                     Parameters_differ(cpath, ty, Ctype.newconstr path args)))
          end
          (* Attempt to expand a type abbreviation if:
              1- [to_check path'] holds
                 (otherwise the expansion cannot involve [path]);
              2- we haven't expanded this type constructor before
                 (otherwise we could loop if [path'] is itself
                 a non-regular abbreviation). *)
          else if to_check path' && not (List.mem path' prev_exp) then begin
            try
              (* Attempt expansion *)
              let (params0, body0, _) = Env.find_type_expansion path' env in
              let (params, body) =
                Ctype.instance_parameterized_type params0 body0 in
              begin
                try List.iter2 (Ctype.unify env) params args'
                with Ctype.Unify _ ->
                  raise (Error(loc, Constraint_failed
                                 (ty, Ctype.newconstr path' params0)));
              end;
              check_regular path' args (path' :: prev_exp) body
            with Not_found -> ()
          end;
          List.iter (check_regular cpath args prev_exp) args'
      | Tpoly (ty, tl) ->
          let (_, ty) = Ctype.instance_poly ~keep_names:true false tl ty in
          check_regular cpath args prev_exp ty
      | _ ->
          Btype.iter_type_expr (check_regular cpath args prev_exp) ty
    end in

  Misc.may
    (fun body ->
      let (args, body) =
        Ctype.instance_parameterized_type
          ~keep_names:true decl.type_params body in
      check_regular path args [] body)
    decl.type_manifest

let check_abbrev_recursion env id_loc_list to_check tdecl =
  let decl = tdecl.typ_type in
  let id = tdecl.typ_id in
  check_recursion env (List.assoc id id_loc_list) (Path.Pident id) decl to_check

(* Compute variance *)

let get_variance ty visited =
  try TypeMap.find ty !visited with Not_found -> Variance.null

let compute_variance env visited vari ty =
  let rec compute_variance_rec vari ty =
    (* Format.eprintf "%a: %x@." Printtyp.type_expr ty (Obj.magic vari); *)
    let ty = Ctype.repr ty in
    let vari' = get_variance ty visited in
    if Variance.subset vari vari' then () else
    let vari = Variance.union vari vari' in
    visited := TypeMap.add ty vari !visited;
    let compute_same = compute_variance_rec vari in
    match ty.desc with
      Tarrow (_, ty1, ty2, _) ->
        let open Variance in
        let v = conjugate vari in
        let v1 =
          if mem May_pos v || mem May_neg v
          then set May_weak true v else v
        in
        compute_variance_rec v1 ty1;
        compute_same ty2
    | Ttuple tl ->
        List.iter compute_same tl
    | Tconstr (path, tl, _) ->
        let open Variance in
        if tl = [] then () else begin
          try
            let decl = Env.find_type path env in
            let cvari f = mem f vari in
            List.iter2
              (fun ty v ->
                let cv f = mem f v in
                let strict =
                  cvari Inv && cv Inj || (cvari Pos || cvari Neg) && cv Inv
                in
                if strict then compute_variance_rec full ty else
                let p1 = inter v vari
                and n1 = inter v (conjugate vari) in
                let v1 =
                  union (inter covariant (union p1 (conjugate p1)))
                    (inter (conjugate covariant) (union n1 (conjugate n1)))
                and weak =
                  cvari May_weak && (cv May_pos || cv May_neg) ||
                  (cvari May_pos || cvari May_neg) && cv May_weak
                in
                let v2 = set May_weak weak v1 in
                compute_variance_rec v2 ty)
              tl decl.type_variance
          with Not_found ->
            List.iter (compute_variance_rec may_inv) tl
        end
    | Tobject (ty, _) ->
        compute_same ty
    | Tfield (_, _, ty1, ty2) ->
        compute_same ty1;
        compute_same ty2
    | Tsubst ty ->
        compute_same ty
    | Tvariant row ->
        let row = Btype.row_repr row in
        List.iter
          (fun (_,f) ->
            match Btype.row_field_repr f with
              Rpresent (Some ty) ->
                compute_same ty
            | Reither (_, tyl, _, _) ->
                let open Variance in
                let upper =
                  List.fold_left (fun s f -> set f true s)
                    null [May_pos; May_neg; May_weak]
                in
                let v = inter vari upper in
                List.iter (compute_variance_rec v) tyl
            | _ -> ())
          row.row_fields;
        compute_same row.row_more
    | Tpoly (ty, _) ->
        compute_same ty
    | Tvar _ | Tnil | Tlink _ | Tunivar _ -> ()
    | Tpackage (_, _, tyl) ->
        let v =
          Variance.(if mem Pos vari || mem Neg vari then full else may_inv)
        in
        List.iter (compute_variance_rec v) tyl
  in
  compute_variance_rec vari ty

let make_variance ty = (ty, ref Variance.null)

let make p n i =
  let open Variance in
  set May_pos p (set May_neg n (set May_weak n (set Inj i null)))

let compute_variance_type env check (required, loc) decl tyl =
  (* Requirements *)
  let required =
    List.map (fun (c,n,i) -> if c || n then (c,n,i) else (true,true,i))
      required
  in
  (* Prepare *)
  let params = List.map Btype.repr decl.type_params in
  let tvl = ref TypeMap.empty in
  (* Compute occurences in body *)
  let open Variance in
  List.iter
    (fun (cn,ty) ->
      compute_variance env tvl (if cn then full else covariant) ty)
    tyl;
  if check then begin
    (* Check variance of parameters *)
    let pos = ref 0 in
    List.iter2
      (fun ty (c, n, i) ->
        incr pos;
        let var = get_variance ty tvl in
        let (co,cn) = get_upper var and ij = mem Inj var in
        if Btype.is_Tvar ty && (co && not c || cn && not n || not ij && i)
        then raise (Error(loc, Bad_variance (!pos, (co,cn,ij), (c,n,i)))))
      params required;
    (* Check propagation from constrained parameters *)
    let args = Btype.newgenty (Ttuple params) in
    let fvl = Ctype.free_variables args in
    let fvl = List.filter (fun v -> not (List.memq v params)) fvl in
    (* If there are no extra variables there is nothing to do *)
    if fvl = [] then () else
    let tvl2 = ref TypeMap.empty in
    List.iter2
      (fun ty (p,n,i) ->
        if Btype.is_Tvar ty then () else
        let v =
          if p then if n then full else covariant else conjugate covariant in
        compute_variance env tvl2 v ty)
      params required;
    let visited = ref TypeSet.empty in
    let rec check ty =
      let ty = Ctype.repr ty in
      if TypeSet.mem ty !visited then () else
      let visited' = TypeSet.add ty !visited in
      visited := visited';
      let v1 = get_variance ty tvl in
      let snap = Btype.snapshot () in
      let v2 =
        TypeMap.fold
          (fun t vt v ->
            if Ctype.equal env false [ty] [t] then union vt v else v)
          !tvl2 null in
      Btype.backtrack snap;
      let (c1,n1) = get_upper v1 and (c2,n2,_,i2) = get_lower v2 in
      if c1 && not c2 || n1 && not n2 then
        if List.memq ty fvl then
          let code = if not i2 then -2 else if c2 || n2 then -1 else -3 in
          raise (Error (loc, Bad_variance (code, (c1,n1,false), (c2,n2,false))))
        else
          Btype.iter_type_expr check ty
    in
    List.iter (fun (_,ty) -> check ty) tyl;
  end;
  List.map2
    (fun ty (p, n, i) ->
      let v = get_variance ty tvl in
      let tr = decl.type_private in
      (* Use required variance where relevant *)
      let concr = decl.type_kind <> Type_abstract (*|| tr = Type_new*) in
      let (p, n) =
        if tr = Private || not (Btype.is_Tvar ty) then (p, n) (* set *)
        else (false, false) (* only check *)
      and i = concr  || i && tr = Private in
      let v = union v (make p n i) in
      let v =
        if not concr then v else
        if mem Pos v && mem Neg v then full else
        if Btype.is_Tvar ty then v else
        union v
          (if p then if n then full else covariant else conjugate covariant)
      in
      if decl.type_kind = Type_abstract && tr = Public then v else
      set May_weak (mem May_neg v) v)
    params required

let add_false = List.map (fun ty -> false, ty)

(* A parameter is constrained if either is is instantiated,
   or it is a variable appearing in another parameter *)
let constrained env vars ty =
  match ty.desc with
  | Tvar _ -> List.exists (fun tl -> List.memq ty tl) vars
  | _ -> true

let compute_variance_gadt env check (required, loc as rloc) decl
    (tl, ret_type_opt) =
  match ret_type_opt with
  | None ->
      compute_variance_type env check rloc {decl with type_private = Private}
        (add_false tl)
  | Some ret_type ->
      match Ctype.repr ret_type with
      | {desc=Tconstr (path, tyl, _)} ->
          (* let tyl = List.map (Ctype.expand_head env) tyl in *)
          let tyl = List.map Ctype.repr tyl in
          let fvl = List.map (Ctype.free_variables ?env:None) tyl in
          let _ =
            List.fold_left2
              (fun (fv1,fv2) ty (c,n,i) ->
                match fv2 with [] -> assert false
                | fv :: fv2 ->
                    (* fv1 @ fv2 = free_variables of other parameters *)
                    if (c||n) && constrained env (fv1 @ fv2) ty then
                      raise (Error(loc, Varying_anonymous));
                    (fv :: fv1, fv2))
              ([], fvl) tyl required
          in
          compute_variance_type env check rloc
            {decl with type_params = tyl; type_private = Private}
            (add_false tl)
      | _ -> assert false

let compute_variance_extension env check decl ext rloc =
  compute_variance_gadt env check rloc
    {decl with type_params = ext.ext_type_params}
    (ext.ext_args, ext.ext_ret_type)

let compute_variance_decl env check decl (required, loc as rloc) =
  if (decl.type_kind = Type_abstract || decl.type_kind = Type_open)
       && decl.type_manifest = None then
    List.map
      (fun (c, n, i) ->
        make (not n) (not c) (decl.type_kind <> Type_abstract || i))
      required
  else
  let mn =
    match decl.type_manifest with
      None -> []
    | Some ty -> [false, ty]
  in
  match decl.type_kind with
    Type_abstract | Type_open ->
      compute_variance_type env check rloc decl mn
  | Type_variant tll ->
      if List.for_all (fun c -> c.Types.cd_res = None) tll then
        compute_variance_type env check rloc decl
          (mn @
           add_false (List.flatten (List.map (fun c -> c.Types.cd_args) tll)))
      else begin
        let mn =
          List.map (fun (_,ty) -> ([ty],None)) mn in
        let tll =
          mn @ List.map (fun c -> c.Types.cd_args, c.Types.cd_res) tll in
        match List.map (compute_variance_gadt env check rloc decl) tll with
        | vari :: rem ->
            let varl = List.fold_left (List.map2 Variance.union) vari rem in
            List.map
              Variance.(fun v -> if mem Pos v && mem Neg v then full else v)
              varl
        | _ -> assert false
      end
  | Type_record (ftl, _) ->
      compute_variance_type env check rloc decl
        (mn @ List.map (fun {Types.ld_mutable; ld_type} ->
             (ld_mutable = Mutable, ld_type)) ftl)

let is_sharp id =
  let s = Ident.name id in
  String.length s > 0 && s.[0] = '#'

let rec compute_variance_fixpoint env decls required variances =
  let new_decls =
    List.map2
      (fun (id, decl) variance -> id, {decl with type_variance = variance})
      decls variances
  in
  let new_env =
    List.fold_right
      (fun (id, decl) env -> Env.add_type ~check:true id decl env)
      new_decls env
  in
  let new_variances =
    List.map2
      (fun (id, decl) -> compute_variance_decl new_env false decl)
      new_decls required
  in
  let new_variances =
    List.map2 (List.map2 Variance.union) new_variances variances in
  if new_variances <> variances then
    compute_variance_fixpoint env decls required new_variances
  else begin
    (* List.iter (fun (id, decl) ->
      Printf.eprintf "%s:" (Ident.name id);
      List.iter (fun (v : Variance.t) ->
        Printf.eprintf " %x" (Obj.magic v : int))
        decl.type_variance;
      prerr_endline "")
      new_decls; *)
    List.iter2
      (fun (id, decl) req -> if not (is_sharp id) then
        ignore (compute_variance_decl new_env true decl req))
      new_decls required;
    new_decls, new_env
  end

let init_variance (id, decl) =
  List.map (fun _ -> Variance.null) decl.type_params

let add_injectivity =
  List.map
    (function
      | Covariant -> (true, false, false)
      | Contravariant -> (false, true, false)
      | Invariant -> (false, false, false)
    )

(* for typeclass.ml *)
let compute_variance_decls env cldecls =
  let decls, required =
    List.fold_right
      (fun (obj_id, obj_abbr, cl_abbr, clty, cltydef, ci) (decls, req) ->
        let variance = List.map snd ci.ci_params in
        (obj_id, obj_abbr) :: decls,
        (add_injectivity variance, ci.ci_loc) :: req)
      cldecls ([],[])
  in
  let variances = List.map init_variance decls in
  let (decls, _) = compute_variance_fixpoint env decls required variances in
  List.map2
    (fun (_,decl) (_, _, cl_abbr, clty, cltydef, _) ->
      let variance = decl.type_variance in
      (decl, {cl_abbr with type_variance = variance},
       {clty with cty_variance = variance},
       {cltydef with clty_variance = variance}))
    decls cldecls

(* Check multiple declarations of labels/constructors *)

let check_duplicates sdecl_list =
  let labels = Hashtbl.create 7 and constrs = Hashtbl.create 7 in
  List.iter
    (fun sdecl -> match sdecl.ptype_kind with
      Ptype_variant cl ->
        List.iter
          (fun pcd ->
            try
              let name' = Hashtbl.find constrs pcd.pcd_name.txt in
              Location.prerr_warning pcd.pcd_loc
                (Warnings.Duplicate_definitions
                   ("constructor", pcd.pcd_name.txt, name',
                    sdecl.ptype_name.txt))
            with Not_found ->
              Hashtbl.add constrs pcd.pcd_name.txt sdecl.ptype_name.txt)
          cl
    | Ptype_record fl ->
        List.iter
          (fun {pld_name=cname;pld_loc=loc} ->
            try
              let name' = Hashtbl.find labels cname.txt in
              Location.prerr_warning loc
                (Warnings.Duplicate_definitions
                   ("label", cname.txt, name', sdecl.ptype_name.txt))
            with Not_found -> Hashtbl.add labels cname.txt sdecl.ptype_name.txt)
          fl
    | Ptype_abstract -> ()
    | Ptype_open -> ())
    sdecl_list

(* Force recursion to go through id for private types*)
let name_recursion sdecl id decl =
  match decl with
  | { type_kind = Type_abstract;
      type_manifest = Some ty;
      type_private = Private; } when is_fixed_type sdecl ->
    let ty = Ctype.repr ty in
    let ty' = Btype.newty2 ty.level ty.desc in
    if Ctype.deep_occur ty ty' then
      let td = Tconstr(Path.Pident id, decl.type_params, ref Mnil) in
      Btype.link_type ty (Btype.newty2 ty.level td);
      {decl with type_manifest = Some ty'}
    else decl
  | _ -> decl

(* Translate a set of type declarations, mutually recursive or not *)
let transl_type_decl env rec_flag sdecl_list =
  (* Add dummy types for fixed rows *)
  let fixed_types = List.filter is_fixed_type sdecl_list in
  let sdecl_list =
    List.map
      (fun sdecl ->
        let ptype_name =
          mkloc (sdecl.ptype_name.txt ^"#row") sdecl.ptype_name.loc in
        {sdecl with
         ptype_name; ptype_kind = Ptype_abstract; ptype_manifest = None})
      fixed_types
    @ sdecl_list
  in
  (* Create identifiers. *)
  let id_list =
    List.map (fun sdecl -> Ident.create sdecl.ptype_name.txt) sdecl_list
  in
  (*
     Since we've introduced fresh idents, make sure the definition
     level is at least the binding time of these events. Otherwise,
     passing one of the recursively-defined type constrs as argument
     to an abbreviation may fail.
  *)
  Ctype.init_def(Ident.current_time());
  Ctype.begin_def();
  (* Enter types. *)
  let temp_env =
    match rec_flag with
    | Asttypes.Nonrecursive -> env
    | Asttypes.Recursive -> List.fold_left2 enter_type env sdecl_list id_list
  in
  (* Translate each declaration. *)
  let current_slot = ref None in
  let warn_unused = Warnings.is_active (Warnings.Unused_type_declaration "") in
  let id_slots id =
    match rec_flag with
    | Asttypes.Recursive when warn_unused ->
        (* See typecore.ml for a description of the algorithm used
             to detect unused declarations in a set of recursive definitions. *)
        let slot = ref [] in
        let td = Env.find_type (Path.Pident id) temp_env in
        let name = Ident.name id in
        Env.set_type_used_callback
          name td
          (fun old_callback ->
             match !current_slot with
             | Some slot -> slot := (name, td) :: !slot
             | None ->
                 List.iter (fun (name, d) -> Env.mark_type_used env name d)
                   (get_ref slot);
                 old_callback ()
          );
        id, Some slot
    | Asttypes.Recursive | Asttypes.Nonrecursive ->
        id, None
  in
  let transl_declaration name_sdecl (id, slot) =
    current_slot := slot; transl_declaration temp_env name_sdecl id in
  let tdecls =
    List.map2 transl_declaration sdecl_list (List.map id_slots id_list) in
  let decls =
    List.map (fun tdecl -> (tdecl.typ_id, tdecl.typ_type)) tdecls in
  current_slot := None;
  (* Check for duplicates *)
  check_duplicates sdecl_list;
  (* Build the final env. *)
  let newenv =
    List.fold_right
      (fun (id, decl) env -> Env.add_type ~check:true id decl env)
      decls env
  in
  (* Update stubs *)
  begin match rec_flag with
    | Asttypes.Nonrecursive -> ()
    | Asttypes.Recursive ->
      List.iter2
        (fun id sdecl -> update_type temp_env newenv id sdecl.ptype_loc)
        id_list sdecl_list
  end;
  (* Generalize type declarations. *)
  Ctype.end_def();
  List.iter (fun (_, decl) -> generalize_decl decl) decls;
  (* Check for ill-formed abbrevs *)
  let id_loc_list =
    List.map2 (fun id sdecl -> (id, sdecl.ptype_loc))
      id_list sdecl_list
  in
  List.iter (fun (id, decl) ->
    check_well_founded_manifest newenv (List.assoc id id_loc_list)
      (Path.Pident id) decl)
    decls;
  let to_check =
    function Path.Pident id -> List.mem_assoc id id_loc_list | _ -> false in
  List.iter (fun (id, decl) ->
    check_well_founded_decl newenv (List.assoc id id_loc_list) (Path.Pident id)
      decl to_check)
    decls;
  List.iter (check_abbrev_recursion newenv id_loc_list to_check) tdecls;
  (* Check that all type variable are closed *)
  List.iter2
    (fun sdecl tdecl ->
      let decl = tdecl.typ_type in
       match Ctype.closed_type_decl decl with
         Some ty -> raise(Error(sdecl.ptype_loc, Unbound_type_var(ty,decl)))
       | None   -> ())
    sdecl_list tdecls;
  (* Check that constraints are enforced *)
  List.iter2 (check_constraints newenv) sdecl_list decls;
  (* Name recursion *)
  let decls =
    List.map2 (fun sdecl (id, decl) -> id, name_recursion sdecl id decl)
      sdecl_list decls
  in
  (* Add variances to the environment *)
  let required =
    List.map
      (fun sdecl ->
         add_injectivity (List.map snd sdecl.ptype_params),
         sdecl.ptype_loc
      )
      sdecl_list
  in
  let final_decls, final_env =
    compute_variance_fixpoint env decls required (List.map init_variance decls)
  in
  (* Check re-exportation *)
  List.iter2 (check_abbrev final_env) sdecl_list final_decls;
  (* Keep original declaration *)
  let final_decls =
    List.map2
      (fun tdecl (id2, decl) ->
        { tdecl with typ_type = decl }
      ) tdecls final_decls
  in
  (* Done *)
  (final_decls, final_env)

(* Translating type extensions *)

let transl_extension_constructor env check_open type_path type_params
                                 typext_params priv sext =
  let id = Ident.create sext.pext_name.txt in
  let args, ret_type, kind =
    match sext.pext_kind with
      Pext_decl(sargs, sret_type) ->
        let targs, tret_type, args, ret_type =
          make_constructor env type_path typext_params sargs sret_type
        in
          args, ret_type, Text_decl(targs, tret_type)
    | Pext_rebind lid ->
        let cdescr = Typetexp.find_constructor env sext.pext_loc lid.txt in
        let usage =
          if cdescr.cstr_private = Private || priv = Public
          then Env.Positive else Env.Privatize
        in
        Env.mark_constructor usage env (Longident.last lid.txt) cdescr;
        let (args, cstr_res) = Ctype.instance_constructor cdescr in
        let res, ret_type =
          if cdescr.cstr_generalized then
            let params = Ctype.instance_list env type_params in
            let res = Ctype.newconstr type_path params in
            let ret_type = Some (Ctype.newconstr type_path params) in
              res, ret_type
          else (Ctype.newconstr type_path typext_params), None
        in
        begin
          try
            Ctype.unify env cstr_res res
          with Ctype.Unify trace ->
            raise (Error(lid.loc,
                     Rebind_wrong_type(lid.txt, env, trace)))
        end;
        (* Remove "_" names from parameters used in the constructor *)
        if not cdescr.cstr_generalized then begin
          let vars =
            Ctype.free_variables (Btype.newgenty (Ttuple args))
          in
            List.iter
              (function {desc = Tvar (Some "_")} as ty ->
                          if List.memq ty vars then ty.desc <- Tvar None
                        | _ -> ())
              typext_params
        end;
        (* Ensure that constructor's type matches the type being extended *)
        let cstr_type_path, cstr_type_params =
          match cdescr.cstr_res.desc with
            Tconstr (p, _, _) ->
              let decl = Env.find_type p env in
                p, decl.type_params
          | _ -> assert false
        in
        let cstr_types =
          (Btype.newgenty
             (Tconstr(cstr_type_path, cstr_type_params, ref Mnil)))
          :: cstr_type_params
        in
        let ext_types =
          (Btype.newgenty
             (Tconstr(type_path, type_params, ref Mnil)))
          :: type_params
        in
        if not (Ctype.equal env true cstr_types ext_types) then
          raise (Error(lid.loc,
                       Rebind_mismatch(lid.txt, cstr_type_path, type_path)));
        (* Disallow rebinding private constructors to non-private *)
        begin
          match cdescr.cstr_private, priv with
            Private, Public ->
              raise (Error(lid.loc, Rebind_private lid.txt))
          | _ -> ()
        end;
        let path =
          match cdescr.cstr_tag with
            Cstr_extension(path, _) -> path
          | _ -> assert false
        in
          args, ret_type, Text_rebind(path, lid)
  in
  let ext =
    { ext_type_path = type_path;
      ext_type_params = typext_params;
      ext_args = args;
      ext_ret_type = ret_type;
      ext_private = priv;
      Types.ext_loc = sext.pext_loc;
      Types.ext_attributes = sext.pext_attributes; }
  in
    { ext_id = id;
      ext_name = sext.pext_name;
      ext_type = ext;
      ext_kind = kind;
      Typedtree.ext_loc = sext.pext_loc;
      Typedtree.ext_attributes = sext.pext_attributes; }

let transl_type_extension check_open env loc styext =
  reset_type_variables();
  Ctype.begin_def();
  let (type_path, type_decl) =
    Typetexp.find_type env loc styext.ptyext_path.txt
  in
  begin
    match type_decl.type_kind with
      Type_open -> ()
    | Type_abstract ->
        if check_open then begin
          try
            let {pext_loc} =
              List.find (function {pext_kind = Pext_decl _} -> true
                                | {pext_kind = Pext_rebind _} -> false)
                        styext.ptyext_constructors
            in
              raise (Error(pext_loc, Not_open_type type_path))
          with Not_found -> ()
        end
    | _ -> raise (Error(loc, Not_extensible_type type_path))
  end;
  let type_variance =
    List.map (fun v ->
                let (co, cn) = Variance.get_upper v in
                  (not cn, not co, false))
             type_decl.type_variance
  in
  let err =
    if type_decl.type_arity <> List.length styext.ptyext_params then
      [Includecore.Arity]
    else
      if List.for_all2
           (fun (c1, n1, _) (c2, n2, _) -> (not c2 || c1) && (not n2 || n1))
           type_variance
           (add_injectivity (List.map snd styext.ptyext_params))
      then [] else [Includecore.Variance]
  in
  if err <> [] then
    raise (Error(loc, Extension_mismatch (type_path, err)));
  let ttype_params = make_params env styext.ptyext_params in
  let type_params = List.map (fun (cty, _) -> cty.ctyp_type) ttype_params in
  List.iter2 (Ctype.unify_var env)
    (Ctype.instance_list env type_decl.type_params)
    type_params;
  let constructors =
    List.map (transl_extension_constructor env check_open type_path
               type_decl.type_params type_params styext.ptyext_private)
      styext.ptyext_constructors
  in
  Ctype.end_def();
  (* Generalize types *)
  List.iter Ctype.generalize type_params;
  List.iter
    (fun ext ->
       List.iter Ctype.generalize ext.ext_type.ext_args;
       may Ctype.generalize ext.ext_type.ext_ret_type)
    constructors;
  (* Check that all type variable are closed *)
  List.iter
    (fun ext ->
       match Ctype.closed_extension_constructor ext.ext_type with
         Some ty ->
           raise(Error(ext.ext_loc, Unbound_type_var_ext(ty, ext.ext_type)))
       | None -> ())
    constructors;
  (* Check variances are correct *)
  List.iter
    (fun ext->
      ignore (compute_variance_extension env true type_decl
                ext.ext_type (type_variance, loc)))
    constructors;
  (* Add extension constructors to the environment *)
  let newenv =
    List.fold_left
      (fun env ext ->
         Env.add_extension ~check:true ext.ext_id ext.ext_type env)
      env constructors
  in
  let tyext =
    { tyext_path = type_path;
      tyext_txt = styext.ptyext_path;
      tyext_params = ttype_params;
      tyext_constructors = constructors;
      tyext_private = styext.ptyext_private;
      tyext_attributes = styext.ptyext_attributes; }
  in
    (tyext, newenv)

let transl_exception env sext =
  reset_type_variables();
  Ctype.begin_def();
  let ext =
    transl_extension_constructor env false
      Predef.path_exn [] [] Asttypes.Public sext
  in
  Ctype.end_def();
  (* Generalize types *)
  List.iter Ctype.generalize ext.ext_type.ext_args;
  may Ctype.generalize ext.ext_type.ext_ret_type;
  (* Check that all type variable are closed *)
  begin match Ctype.closed_extension_constructor ext.ext_type with
    Some ty ->
      raise (Error(ext.ext_loc, Unbound_type_var_ext(ty, ext.ext_type)))
  | None -> ()
  end;
  let newenv = Env.add_extension ~check:true ext.ext_id ext.ext_type env in
    ext, newenv

(* Translate a value declaration *)
let transl_value_decl env loc valdecl =
  let cty = Typetexp.transl_type_scheme env valdecl.pval_type in
  let ty = cty.ctyp_type in
  let v =
  match valdecl.pval_prim with
    [] ->
      { val_type = ty; val_kind = Val_reg; Types.val_loc = loc;
        val_attributes = valdecl.pval_attributes }
  | decl ->
      let arity = Ctype.arity ty in
      let prim = Primitive.parse_declaration  arity decl in
      let prim_native_name = prim.prim_native_name in 
      if arity = 0 && not ( String.length prim_native_name > 3 &&
                            String.unsafe_get prim_native_name 0 = 'B' &&
                            String.unsafe_get prim_native_name 1 = 'S' &&
                            String.unsafe_get prim_native_name 2 = ':'
                          ) && prim.prim_name.[0] <> '%' then
        raise(Error(valdecl.pval_type.ptyp_loc, Null_arity_external));
      if !Clflags.native_code
      && prim.prim_arity > 5
      && prim_native_name = ""
      then raise(Error(valdecl.pval_type.ptyp_loc, Missing_native_external));
      { val_type = ty; val_kind = Val_prim prim; Types.val_loc = loc;
        val_attributes = valdecl.pval_attributes }
  in
  let (id, newenv) =
    Env.enter_value valdecl.pval_name.txt v env
      ~check:(fun s -> Warnings.Unused_value_declaration s)
  in
  let desc =
    {
     val_id = id;
     val_name = valdecl.pval_name;
     val_desc = cty; val_val = v;
     val_prim = valdecl.pval_prim;
     val_loc = valdecl.pval_loc;
     val_attributes = valdecl.pval_attributes;
    }
  in
  desc, newenv

(* Translate a "with" constraint -- much simplified version of
    transl_type_decl. *)
let transl_with_constraint env id row_path orig_decl sdecl =
  Env.mark_type_used env (Ident.name id) orig_decl;
  reset_type_variables();
  Ctype.begin_def();
  let tparams = make_params env sdecl.ptype_params in
  let params = List.map (fun (cty, _) -> cty.ctyp_type) tparams in
  let orig_decl = Ctype.instance_declaration orig_decl in
  let arity_ok = List.length params = orig_decl.type_arity in
  if arity_ok then
    List.iter2 (Ctype.unify_var env) params orig_decl.type_params;
  let constraints = List.map
    (function (ty, ty', loc) ->
       try
         let cty = transl_simple_type env false ty in
         let cty' = transl_simple_type env false ty' in
         let ty = cty.ctyp_type in
         let ty' = cty'.ctyp_type in
         Ctype.unify env ty ty';
         (cty, cty', loc)
       with Ctype.Unify tr ->
         raise(Error(loc, Inconsistent_constraint (env, tr))))
    sdecl.ptype_cstrs
  in
  let no_row = not (is_fixed_type sdecl) in
  let (tman, man) =  match sdecl.ptype_manifest with
      None -> None, None
    | Some sty ->
        let cty = transl_simple_type env no_row sty in
        Some cty, Some cty.ctyp_type
  in
  let priv =
    if sdecl.ptype_private = Private then Private else
    if arity_ok && orig_decl.type_kind <> Type_abstract
    then orig_decl.type_private else sdecl.ptype_private
  in
  if arity_ok && orig_decl.type_kind <> Type_abstract
  && sdecl.ptype_private = Private then
    Location.prerr_warning sdecl.ptype_loc
      (Warnings.Deprecated "spurious use of private");
  let decl =
    { type_params = params;
      type_arity = List.length params;
      type_kind =
        if arity_ok && man <> None then orig_decl.type_kind else Type_abstract;
      type_private = priv;
      type_manifest = man;
      type_variance = [];
      type_newtype_level = None;
      type_loc = sdecl.ptype_loc;
      type_attributes = sdecl.ptype_attributes;
    }
  in
  begin match row_path with None -> ()
  | Some p -> set_fixed_row env sdecl.ptype_loc p decl
  end;
  begin match Ctype.closed_type_decl decl with None -> ()
  | Some ty -> raise(Error(sdecl.ptype_loc, Unbound_type_var(ty,decl)))
  end;
  let decl = name_recursion sdecl id decl in
  let decl =
    {decl with type_variance =
     compute_variance_decl env false decl
       (add_injectivity (List.map snd sdecl.ptype_params), sdecl.ptype_loc)} in
  Ctype.end_def();
  generalize_decl decl;
  {
    typ_id = id;
    typ_name = sdecl.ptype_name;
    typ_params = tparams;
    typ_type = decl;
    typ_cstrs = constraints;
    typ_loc = sdecl.ptype_loc;
    typ_manifest = tman;
    typ_kind = Ttype_abstract;
    typ_private = sdecl.ptype_private;
    typ_attributes = sdecl.ptype_attributes;
  }

(* Approximate a type declaration: just make all types abstract *)

let abstract_type_decl arity =
  let rec make_params n =
    if n <= 0 then [] else Ctype.newvar() :: make_params (n-1) in
  Ctype.begin_def();
  let decl =
    { type_params = make_params arity;
      type_arity = arity;
      type_kind = Type_abstract;
      type_private = Public;
      type_manifest = None;
      type_variance = replicate_list Variance.full arity;
      type_newtype_level = None;
      type_loc = Location.none;
      type_attributes = [];
     } in
  Ctype.end_def();
  generalize_decl decl;
  decl

let approx_type_decl env sdecl_list =
  List.map
    (fun sdecl ->
      (Ident.create sdecl.ptype_name.txt,
       abstract_type_decl (List.length sdecl.ptype_params)))
    sdecl_list

(* Variant of check_abbrev_recursion to check the well-formedness
   conditions on type abbreviations defined within recursive modules. *)

let check_recmod_typedecl env loc recmod_ids path decl =
  (* recmod_ids is the list of recursively-defined module idents.
     (path, decl) is the type declaration to be checked. *)
  let to_check path =
    List.exists (fun id -> Path.isfree id path) recmod_ids in
  check_well_founded_decl env loc path decl to_check;
  check_recursion env loc path decl to_check


(**** Error report ****)

open Format

let explain_unbound ppf tv tl typ kwd lab =
  try
    let ti = List.find (fun ti -> Ctype.deep_occur tv (typ ti)) tl in
    let ty0 = (* Hack to force aliasing when needed *)
      Btype.newgenty (Tobject(tv, ref None)) in
    Printtyp.reset_and_mark_loops_list [typ ti; ty0];
    fprintf ppf
      ".@.@[<hov2>In %s@ %s%a@;<1 -2>the variable %a is unbound@]"
      kwd (lab ti) Printtyp.type_expr (typ ti) Printtyp.type_expr tv
  with Not_found -> ()

let explain_unbound_single ppf tv ty =
  let trivial ty =
    explain_unbound ppf tv [ty] (fun t -> t) "type" (fun _ -> "") in
  match (Ctype.repr ty).desc with
    Tobject(fi,_) ->
      let (tl, rv) = Ctype.flatten_fields fi in
      if rv == tv then trivial ty else
      explain_unbound ppf tv tl (fun (_,_,t) -> t)
        "method" (fun (lab,_,_) -> lab ^ ": ")
  | Tvariant row ->
      let row = Btype.row_repr row in
      if row.row_more == tv then trivial ty else
      explain_unbound ppf tv row.row_fields
        (fun (l,f) -> match Btype.row_field_repr f with
          Rpresent (Some t) -> t
        | Reither (_,[t],_,_) -> t
        | Reither (_,tl,_,_) -> Btype.newgenty (Ttuple tl)
        | _ -> Btype.newgenty (Ttuple[]))
        "case" (fun (lab,_) -> "`" ^ lab ^ " of ")
  | _ -> trivial ty

let report_error ppf = function
  | Repeated_parameter ->
      fprintf ppf "A type parameter occurs several times"
  | Duplicate_constructor s ->
      fprintf ppf "Two constructors are named %s" s
  | Too_many_constructors ->
      fprintf ppf
        "@[Too many non-constant constructors@ -- maximum is %i %s@]"
        (Config.max_tag + 1) "non-constant constructors"
  | Duplicate_label s ->
      fprintf ppf "Two labels are named %s" s
  | Recursive_abbrev s ->
      fprintf ppf "The type abbreviation %s is cyclic" s
  | Cycle_in_def (s, ty) ->
      Printtyp.reset_and_mark_loops ty;
      fprintf ppf "@[<v>The definition of %s contains a cycle:@ %a@]"
        s Printtyp.type_expr ty
  | Definition_mismatch (ty, errs) ->
      Printtyp.reset_and_mark_loops ty;
      fprintf ppf "@[<v>@[<hov>%s@ %s@;<1 2>%a@]%a@]"
        "This variant or record definition" "does not match that of type"
        Printtyp.type_expr ty
        (Includecore.report_type_mismatch "the original" "this" "definition")
        errs
  | Constraint_failed (ty, ty') ->
      Printtyp.reset_and_mark_loops ty;
      Printtyp.mark_loops ty';
      fprintf ppf "@[%s@ @[<hv>Type@ %a@ should be an instance of@ %a@]@]"
        "Constraints are not satisfied in this type."
        Printtyp.type_expr ty Printtyp.type_expr ty'
  | Parameters_differ (path, ty, ty') ->
      Printtyp.reset_and_mark_loops ty;
      Printtyp.mark_loops ty';
      fprintf ppf
        "@[<hv>In the definition of %s, type@ %a@ should be@ %a@]"
        (Path.name path) Printtyp.type_expr ty Printtyp.type_expr ty'
  | Inconsistent_constraint (env, trace) ->
      fprintf ppf "The type constraints are not consistent.@.";
      Printtyp.report_unification_error ppf env trace
        (fun ppf -> fprintf ppf "Type")
        (fun ppf -> fprintf ppf "is not compatible with type")
  | Type_clash (env, trace) ->
      Printtyp.report_unification_error ppf env trace
        (function ppf ->
           fprintf ppf "This type constructor expands to type")
        (function ppf ->
           fprintf ppf "but is used here with type")
  | Null_arity_external ->
      fprintf ppf "External identifiers must be functions"
  | Missing_native_external ->
      fprintf ppf "@[<hv>An external function with more than 5 arguments \
                   requires a second stub function@ \
                   for native-code compilation@]"
  | Unbound_type_var (ty, decl) ->
      fprintf ppf "A type variable is unbound in this type declaration";
      let ty = Ctype.repr ty in
      begin match decl.type_kind, decl.type_manifest with
      | Type_variant tl, _ ->
          explain_unbound ppf ty tl (fun c ->
            Btype.newgenty (Ttuple c.Types.cd_args))
            "case" (fun c -> Ident.name c.Types.cd_id ^ " of ")
      | Type_record (tl, _), _ ->
          explain_unbound ppf ty tl (fun l -> l.Types.ld_type)
            "field" (fun l -> Ident.name l.Types.ld_id ^ ": ")
      | Type_abstract, Some ty' ->
          explain_unbound_single ppf ty ty'
      | _ -> ()
      end
  | Unbound_type_var_ext (ty, ext) ->
      fprintf ppf "A type variable is unbound in this extension constructor";
      explain_unbound ppf ty ext.ext_args (fun c -> c) "type" (fun _ -> "")
  | Not_open_type path ->
      fprintf ppf "@[%s@ %a@]"
        "Cannot extend type definition"
        Printtyp.path path
  | Not_extensible_type path ->
      fprintf ppf "@[%s@ %a@ %s@]"
        "Type"
        Printtyp.path path
        "is not extensible"
  | Extension_mismatch (path, errs) ->
      fprintf ppf "@[<v>@[<hov>%s@ %s@;<1 2>%s@]%a@]"
        "This extension" "does not match the definition of type"
        (Path.name path)
        (Includecore.report_type_mismatch
           "the type" "this extension" "definition")
        errs
  | Rebind_wrong_type (lid, env, trace) ->
      Printtyp.report_unification_error ppf env trace
        (function ppf ->
          fprintf ppf "The constructor %a@ has type"
            Printtyp.longident lid)
        (function ppf ->
           fprintf ppf "but was expected to be of type")
  | Rebind_mismatch (lid, p, p') ->
      fprintf ppf
        "@[%s@ %a@ %s@ %s@ %s@ %s@ %s@]"
        "The constructor" Printtyp.longident lid
        "extends type" (Path.name p)
        "whose declaration does not match"
        "the declaration of type" (Path.name p')
  | Rebind_private lid ->
      fprintf ppf "@[%s@ %a@ %s@]"
        "The constructor"
        Printtyp.longident lid
        "is private"
  | Bad_variance (n, v1, v2) ->
      let variance (p,n,i) =
        let inj = if i then "injective " else "" in
        match p, n with
          true,  true  -> inj ^ "invariant"
        | true,  false -> inj ^ "covariant"
        | false, true  -> inj ^ "contravariant"
        | false, false -> if inj = "" then "unrestricted" else inj
      in
      let suffix n =
        let teen = (n mod 100)/10 = 1 in
        match n mod 10 with
        | 1 when not teen -> "st"
        | 2 when not teen -> "nd"
        | 3 when not teen -> "rd"
        | _ -> "th"
      in
      if n = -1 then
        fprintf ppf "@[%s@ %s@ It"
          "In this definition, a type variable has a variance that"
          "is not reflected by its occurrence in type parameters."
      else if n = -2 then
        fprintf ppf "@[%s@ %s@]"
          "In this definition, a type variable cannot be deduced"
          "from the type parameters."
      else if n = -3 then
        fprintf ppf "@[%s@ %s@ It"
          "In this definition, a type variable has a variance that"
          "cannot be deduced from the type parameters."
      else
        fprintf ppf "@[%s@ %s@ The %d%s type parameter"
          "In this definition, expected parameter"
          "variances are not satisfied."
          n (suffix n);
      if n <> -2 then
        fprintf ppf " was expected to be %s,@ but it is %s.@]"
          (variance v2) (variance v1)
  | Unavailable_type_constructor p ->
      fprintf ppf "The definition of type %a@ is unavailable" Printtyp.path p
  | Bad_fixed_type r ->
      fprintf ppf "This fixed type %s" r
  | Varying_anonymous ->
      fprintf ppf "@[%s@ %s@ %s@]"
        "In this GADT definition," "the variance of some parameter"
        "cannot be checked"

let () =
  Location.register_error_of_exn
    (function
      | Error (loc, err) ->
        Some (Location.error_of_printer loc report_error err)
      | _ ->
        None
    )

end
module Typeclass : sig 
#1 "typeclass.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*         Jerome Vouillon, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Asttypes
open Types
open Format

val class_declarations:
  Env.t -> Parsetree.class_declaration list ->
  (Ident.t * string loc * class_declaration *
   Ident.t * class_type_declaration *
   Ident.t * type_declaration *
   Ident.t * type_declaration *
   int * string list * Typedtree.class_declaration) list * Env.t

(*
and class_declaration =
  (class_expr, Types.class_declaration) class_infos
*)

val class_descriptions:
  Env.t -> Parsetree.class_description list ->
  (Ident.t * string loc * class_declaration *
   Ident.t * class_type_declaration *
   Ident.t * type_declaration *
   Ident.t * type_declaration *
   int * string list * Typedtree.class_description) list * Env.t

(*
and class_description =
  (class_type, unit) class_infos
*)

val class_type_declarations:
  Env.t -> Parsetree.class_description list ->
  (Ident.t * string loc * class_type_declaration *
   Ident.t * type_declaration *
   Ident.t * type_declaration *
  Typedtree.class_type_declaration) list * Env.t

(*
and class_type_declaration =
  (class_type, Types.class_type_declaration) class_infos
*)

val approx_class_declarations:
  Env.t -> Parsetree.class_description list ->
  (Ident.t * string loc * class_type_declaration *
   Ident.t * type_declaration *
   Ident.t * type_declaration *
  Typedtree.class_type_declaration) list

val virtual_methods: Types.class_signature -> label list

(*
val type_classes :
           bool ->
           ('a -> Types.type_expr) ->
           (Env.t -> 'a -> 'b * Types.class_type) ->
           Env.t ->
           'a Parsetree.class_infos list ->
  (  Ident.t * Types.class_declaration *
     Ident.t * Types.class_type_declaration *
     Ident.t * Types.type_declaration *
     Ident.t * Types.type_declaration *
     int * string list * 'b * 'b Typedtree.class_infos)
           list * Env.t
*)

type error =
    Unconsistent_constraint of (type_expr * type_expr) list
  | Field_type_mismatch of string * string * (type_expr * type_expr) list
  | Structure_expected of class_type
  | Cannot_apply of class_type
  | Apply_wrong_label of label
  | Pattern_type_clash of type_expr
  | Repeated_parameter
  | Unbound_class_2 of Longident.t
  | Unbound_class_type_2 of Longident.t
  | Abbrev_type_clash of type_expr * type_expr * type_expr
  | Constructor_type_mismatch of string * (type_expr * type_expr) list
  | Virtual_class of bool * bool * string list * string list
  | Parameter_arity_mismatch of Longident.t * int * int
  | Parameter_mismatch of (type_expr * type_expr) list
  | Bad_parameters of Ident.t * type_expr * type_expr
  | Class_match_failure of Ctype.class_match_failure list
  | Unbound_val of string
  | Unbound_type_var of (formatter -> unit) * Ctype.closed_class_failure
  | Make_nongen_seltype of type_expr
  | Non_generalizable_class of Ident.t * Types.class_declaration
  | Cannot_coerce_self of type_expr
  | Non_collapsable_conjunction of
      Ident.t * Types.class_declaration * (type_expr * type_expr) list
  | Final_self_clash of (type_expr * type_expr) list
  | Mutability_mismatch of string * mutable_flag
  | No_overriding of string * string
  | Duplicate of string * string

exception Error of Location.t * Env.t * error
exception Error_forward of Location.error

val report_error : Env.t -> formatter -> error -> unit

end = struct
#1 "typeclass.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*         Jerome Vouillon, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Parsetree
open Asttypes
open Path
open Types
open Typecore
open Typetexp
open Format

type error =
    Unconsistent_constraint of (type_expr * type_expr) list
  | Field_type_mismatch of string * string * (type_expr * type_expr) list
  | Structure_expected of class_type
  | Cannot_apply of class_type
  | Apply_wrong_label of label
  | Pattern_type_clash of type_expr
  | Repeated_parameter
  | Unbound_class_2 of Longident.t
  | Unbound_class_type_2 of Longident.t
  | Abbrev_type_clash of type_expr * type_expr * type_expr
  | Constructor_type_mismatch of string * (type_expr * type_expr) list
  | Virtual_class of bool * bool * string list * string list
  | Parameter_arity_mismatch of Longident.t * int * int
  | Parameter_mismatch of (type_expr * type_expr) list
  | Bad_parameters of Ident.t * type_expr * type_expr
  | Class_match_failure of Ctype.class_match_failure list
  | Unbound_val of string
  | Unbound_type_var of (formatter -> unit) * Ctype.closed_class_failure
  | Make_nongen_seltype of type_expr
  | Non_generalizable_class of Ident.t * Types.class_declaration
  | Cannot_coerce_self of type_expr
  | Non_collapsable_conjunction of
      Ident.t * Types.class_declaration * (type_expr * type_expr) list
  | Final_self_clash of (type_expr * type_expr) list
  | Mutability_mismatch of string * mutable_flag
  | No_overriding of string * string
  | Duplicate of string * string

exception Error of Location.t * Env.t * error
exception Error_forward of Location.error

open Typedtree

let ctyp desc typ env loc =
  { ctyp_desc = desc; ctyp_type = typ; ctyp_loc = loc; ctyp_env = env; ctyp_attributes = [] }

                       (**********************)
                       (*  Useful constants  *)
                       (**********************)


(*
   Self type have a dummy private method, thus preventing it to become
   closed.
*)
let dummy_method = Btype.dummy_method

(*
   Path associated to the temporary class type of a class being typed
   (its constructor is not available).
*)
let unbound_class = Path.Pident (Ident.create "")


                (************************************)
                (*  Some operations on class types  *)
                (************************************)


(* Fully expand the head of a class type *)
let rec scrape_class_type =
  function
    Cty_constr (_, _, cty) -> scrape_class_type cty
  | cty                     -> cty

(* Generalize a class type *)
let rec generalize_class_type gen =
  function
    Cty_constr (_, params, cty) ->
      List.iter gen params;
      generalize_class_type gen cty
  | Cty_signature {csig_self = sty; csig_vars = vars; csig_inher = inher} ->
      gen sty;
      Vars.iter (fun _ (_, _, ty) -> gen ty) vars;
      List.iter (fun (_,tl) -> List.iter gen tl) inher
  | Cty_arrow (_, ty, cty) ->
      gen ty;
      generalize_class_type gen cty

let generalize_class_type vars =
  let gen = if vars then Ctype.generalize else Ctype.generalize_structure in
  generalize_class_type gen

(* Return the virtual methods of a class type *)
let virtual_methods sign =
  let (fields, _) =
    Ctype.flatten_fields (Ctype.object_fields sign.Types.csig_self)
  in
  List.fold_left
    (fun virt (lab, _, _) ->
       if lab = dummy_method then virt else
       if Concr.mem lab sign.csig_concr then virt else
       lab::virt)
    [] fields

(* Return the constructor type associated to a class type *)
let rec constructor_type constr cty =
  match cty with
    Cty_constr (_, _, cty) ->
      constructor_type constr cty
  | Cty_signature sign ->
      constr
  | Cty_arrow (l, ty, cty) ->
      Ctype.newty (Tarrow (l, ty, constructor_type constr cty, Cok))

let rec class_body cty =
  match cty with
    Cty_constr (_, _, cty') ->
      cty (* Only class bodies can be abbreviated *)
  | Cty_signature sign ->
      cty
  | Cty_arrow (_, ty, cty) ->
      class_body cty

let extract_constraints cty =
  let sign = Ctype.signature_of_class_type cty in
  (Vars.fold (fun lab _ vars -> lab :: vars) sign.csig_vars [],
   begin let (fields, _) =
     Ctype.flatten_fields (Ctype.object_fields sign.csig_self)
   in
   List.fold_left
     (fun meths (lab, _, _) ->
        if lab = dummy_method then meths else lab::meths)
     [] fields
   end,
   sign.csig_concr)

let rec abbreviate_class_type path params cty =
  match cty with
    Cty_constr (_, _, _) | Cty_signature _ ->
      Cty_constr (path, params, cty)
  | Cty_arrow (l, ty, cty) ->
      Cty_arrow (l, ty, abbreviate_class_type path params cty)

let rec closed_class_type =
  function
    Cty_constr (_, params, _) ->
      List.for_all Ctype.closed_schema params
  | Cty_signature sign ->
      Ctype.closed_schema sign.csig_self
        &&
      Vars.fold (fun _ (_, _, ty) cc -> Ctype.closed_schema ty && cc)
        sign.csig_vars
        true
  | Cty_arrow (_, ty, cty) ->
      Ctype.closed_schema ty
        &&
      closed_class_type cty

let closed_class cty =
  List.for_all Ctype.closed_schema cty.cty_params
    &&
  closed_class_type cty.cty_type

let rec limited_generalize rv =
  function
    Cty_constr (path, params, cty) ->
      List.iter (Ctype.limited_generalize rv) params;
      limited_generalize rv cty
  | Cty_signature sign ->
      Ctype.limited_generalize rv sign.csig_self;
      Vars.iter (fun _ (_, _, ty) -> Ctype.limited_generalize rv ty)
        sign.csig_vars;
      List.iter (fun (_, tl) -> List.iter (Ctype.limited_generalize rv) tl)
        sign.csig_inher
  | Cty_arrow (_, ty, cty) ->
      Ctype.limited_generalize rv ty;
      limited_generalize rv cty

(* Record a class type *)
let rc node =
  Cmt_format.add_saved_type (Cmt_format.Partial_class_expr node);
  Stypes.record (Stypes.Ti_class node); (* moved to genannot *)
  node


                (***********************************)
                (*  Primitives for typing classes  *)
                (***********************************)


(* Enter a value in the method environment only *)
let enter_met_env ?check loc lab kind ty val_env met_env par_env =
  let (id, val_env) =
    Env.enter_value lab {val_type = ty; val_kind = Val_unbound;
                         val_attributes = [];
                         Types.val_loc = loc} val_env
  in
  (id, val_env,
   Env.add_value ?check id {val_type = ty; val_kind = kind;
                            val_attributes = [];
                            Types.val_loc = loc} met_env,
   Env.add_value id {val_type = ty; val_kind = Val_unbound;
                     val_attributes = [];
                     Types.val_loc = loc} par_env)

(* Enter an instance variable in the environment *)
let enter_val cl_num vars inh lab mut virt ty val_env met_env par_env loc =
  let instance = Ctype.instance val_env in
  let (id, virt) =
    try
      let (id, mut', virt', ty') = Vars.find lab !vars in
      if mut' <> mut then
        raise (Error(loc, val_env, Mutability_mismatch(lab, mut)));
      Ctype.unify val_env (instance ty) (instance ty');
      (if not inh then Some id else None),
      (if virt' = Concrete then virt' else virt)
    with
      Ctype.Unify tr ->
        raise (Error(loc, val_env,
                     Field_type_mismatch("instance variable", lab, tr)))
    | Not_found -> None, virt
  in
  let (id, _, _, _) as result =
    match id with Some id -> (id, val_env, met_env, par_env)
    | None ->
        enter_met_env Location.none lab (Val_ivar (mut, cl_num))
          ty val_env met_env par_env
  in
  vars := Vars.add lab (id, mut, virt, ty) !vars;
  result

let concr_vals vars =
  Vars.fold
    (fun id (_, vf, _) s -> if vf = Virtual then s else Concr.add id s)
    vars Concr.empty

let inheritance self_type env ovf concr_meths warn_vals loc parent =
  match scrape_class_type parent with
    Cty_signature cl_sig ->

      (* Methods *)
      begin try
        Ctype.unify env self_type cl_sig.csig_self
      with Ctype.Unify trace ->
        match trace with
          _::_::_::({desc = Tfield(n, _, _, _)}, _)::rem ->
            raise(Error(loc, env, Field_type_mismatch ("method", n, rem)))
        | _ ->
            assert false
      end;

      (* Overriding *)
      let over_meths = Concr.inter cl_sig.csig_concr concr_meths in
      let concr_vals = concr_vals cl_sig.csig_vars in
      let over_vals = Concr.inter concr_vals warn_vals in
      begin match ovf with
        Some Fresh ->
          let cname =
            match parent with
              Cty_constr (p, _, _) -> Path.name p
            | _ -> "inherited"
          in
          if not (Concr.is_empty over_meths) then
            Location.prerr_warning loc
              (Warnings.Method_override (cname :: Concr.elements over_meths));
          if not (Concr.is_empty over_vals) then
            Location.prerr_warning loc
              (Warnings.Instance_variable_override
                 (cname :: Concr.elements over_vals));
      | Some Override
        when Concr.is_empty over_meths && Concr.is_empty over_vals ->
        raise (Error(loc, env, No_overriding ("","")))
      | _ -> ()
      end;

      let concr_meths = Concr.union cl_sig.csig_concr concr_meths
      and warn_vals = Concr.union concr_vals warn_vals in

      (cl_sig, concr_meths, warn_vals)

  | _ ->
      raise(Error(loc, env, Structure_expected parent))

let virtual_method val_env meths self_type lab priv sty loc =
  let (_, ty') =
     Ctype.filter_self_method val_env lab priv meths self_type
  in
  let sty = Ast_helper.Typ.force_poly sty in
  let cty = transl_simple_type val_env false sty in
  let ty = cty.ctyp_type in
  begin
    try Ctype.unify val_env ty ty' with Ctype.Unify trace ->
        raise(Error(loc, val_env, Field_type_mismatch ("method", lab, trace)));
  end;
  cty

let delayed_meth_specs = ref []

let declare_method val_env meths self_type lab priv sty loc =
  let (_, ty') =
     Ctype.filter_self_method val_env lab priv meths self_type
  in
  let unif ty =
    try Ctype.unify val_env ty ty' with Ctype.Unify trace ->
      raise(Error(loc, val_env, Field_type_mismatch ("method", lab, trace)))
  in
  let sty = Ast_helper.Typ.force_poly sty in
  match sty.ptyp_desc, priv with
    Ptyp_poly ([],sty'), Public ->
(* TODO: we moved the [transl_simple_type_univars] outside of the lazy,
so that we can get an immediate value. Is that correct ? Ask Jacques. *)
      let returned_cty = ctyp Ttyp_any (Ctype.newty Tnil) val_env loc in
      delayed_meth_specs :=
      lazy (
        let cty = transl_simple_type_univars val_env sty' in
        let ty = cty.ctyp_type in
        unif ty;
        returned_cty.ctyp_desc <- Ttyp_poly ([], cty);
        returned_cty.ctyp_type <- ty;
        ) ::
      !delayed_meth_specs;
      returned_cty
  | _ ->
      let cty = transl_simple_type val_env false sty in
      let ty = cty.ctyp_type in
      unif ty;
      cty

let type_constraint val_env sty sty' loc =
  let cty  = transl_simple_type val_env false sty in
  let ty = cty.ctyp_type in
  let cty' = transl_simple_type val_env false sty' in
  let ty' = cty'.ctyp_type in
  begin
    try Ctype.unify val_env ty ty' with Ctype.Unify trace ->
        raise(Error(loc, val_env, Unconsistent_constraint trace));
  end;
  (cty, cty')

let make_method loc cl_num expr =
  let open Ast_helper in
  let mkid s = mkloc s loc in
  Exp.fun_ ~loc:expr.pexp_loc "" None
    (Pat.alias ~loc (Pat.var ~loc (mkid "self-*")) (mkid ("self-" ^ cl_num)))
    expr

(*******************************)

let add_val env loc lab (mut, virt, ty) val_sig =
  let virt =
    try
      let (mut', virt', ty') = Vars.find lab val_sig in
      if virt' = Concrete then virt' else virt
    with Not_found -> virt
  in
  Vars.add lab (mut, virt, ty) val_sig

let rec class_type_field env self_type meths
    (fields, val_sig, concr_meths, inher) ctf =
  let loc = ctf.pctf_loc in
  let mkctf desc = { ctf_desc = desc; ctf_loc = loc; ctf_attributes = ctf.pctf_attributes } in
  match ctf.pctf_desc with
    Pctf_inherit sparent ->
      let parent = class_type env sparent in
      let inher =
        match parent.cltyp_type with
          Cty_constr (p, tl, _) -> (p, tl) :: inher
        | _ -> inher
      in
      let (cl_sig, concr_meths, _) =
        inheritance self_type env None concr_meths Concr.empty sparent.pcty_loc
          parent.cltyp_type
      in
      let val_sig =
        Vars.fold (add_val env sparent.pcty_loc) cl_sig.csig_vars val_sig in
      (mkctf (Tctf_inherit parent) :: fields,
       val_sig, concr_meths, inher)

  | Pctf_val (lab, mut, virt, sty) ->
      let cty = transl_simple_type env false sty in
      let ty = cty.ctyp_type in
      (mkctf (Tctf_val (lab, mut, virt, cty)) :: fields,
      add_val env ctf.pctf_loc lab (mut, virt, ty) val_sig, concr_meths, inher)

  | Pctf_method (lab, priv, virt, sty)  ->
      let cty =
        declare_method env meths self_type lab priv sty  ctf.pctf_loc in
      let concr_meths =
        match virt with
        | Concrete -> Concr.add lab concr_meths
        | Virtual -> concr_meths
      in
      (mkctf (Tctf_method (lab, priv, virt, cty)) :: fields,
        val_sig, concr_meths, inher)

  | Pctf_constraint (sty, sty') ->
      let (cty, cty') = type_constraint env sty sty'  ctf.pctf_loc in
      (mkctf (Tctf_constraint (cty, cty')) :: fields,
        val_sig, concr_meths, inher)

  | Pctf_attribute x ->
      Typetexp.warning_attribute [x];
      (mkctf (Tctf_attribute x) :: fields,
        val_sig, concr_meths, inher)

  | Pctf_extension ext ->
      raise (Error_forward (Typetexp.error_of_extension ext))

and class_signature env {pcsig_self=sty; pcsig_fields=sign} =
  let meths = ref Meths.empty in
  let self_cty = transl_simple_type env false sty in
  let self_cty = { self_cty with
    ctyp_type = Ctype.expand_head env self_cty.ctyp_type } in
  let self_type =  self_cty.ctyp_type in

  (* Check that the binder is a correct type, and introduce a dummy
     method preventing self type from being closed. *)
  let dummy_obj = Ctype.newvar () in
  Ctype.unify env (Ctype.filter_method env dummy_method Private dummy_obj)
    (Ctype.newty (Ttuple []));
  begin try
    Ctype.unify env self_type dummy_obj
  with Ctype.Unify _ ->
    raise(Error(sty.ptyp_loc, env, Pattern_type_clash self_type))
  end;

  (* Class type fields *)
  Typetexp.warning_enter_scope ();
  let (rev_fields, val_sig, concr_meths, inher) =
    List.fold_left (class_type_field env self_type meths)
      ([], Vars.empty, Concr.empty, [])
      sign
  in
  Typetexp.warning_leave_scope ();
  let cty =   {csig_self = self_type;
   csig_vars = val_sig;
   csig_concr = concr_meths;
   csig_inher = inher}
  in
  { csig_self = self_cty;
    csig_fields = List.rev rev_fields;
    csig_type = cty;
  }

and class_type env scty =
  let cltyp desc typ =
    {
     cltyp_desc = desc;
     cltyp_type = typ;
     cltyp_loc = scty.pcty_loc;
     cltyp_env = env;
     cltyp_attributes = scty.pcty_attributes;
    }
  in
  match scty.pcty_desc with
    Pcty_constr (lid, styl) ->
      let (path, decl) = Typetexp.find_class_type env scty.pcty_loc lid.txt in
      if Path.same decl.clty_path unbound_class then
        raise(Error(scty.pcty_loc, env, Unbound_class_type_2 lid.txt));
      let (params, clty) =
        Ctype.instance_class decl.clty_params decl.clty_type
      in
      if List.length params <> List.length styl then
        raise(Error(scty.pcty_loc, env,
                    Parameter_arity_mismatch (lid.txt, List.length params,
                                                   List.length styl)));
      let ctys = List.map2
        (fun sty ty ->
          let cty' = transl_simple_type env false sty in
          let ty' = cty'.ctyp_type in
          begin
           try Ctype.unify env ty' ty with Ctype.Unify trace ->
                  raise(Error(sty.ptyp_loc, env, Parameter_mismatch trace))
            end;
            cty'
        )       styl params
      in
      let typ = Cty_constr (path, params, clty) in
      cltyp (Tcty_constr ( path, lid , ctys)) typ

  | Pcty_signature pcsig ->
      let clsig = class_signature env pcsig in
      let typ = Cty_signature clsig.csig_type in
      cltyp (Tcty_signature clsig) typ

  | Pcty_arrow (l, sty, scty) ->
      let cty = transl_simple_type env false sty in
      let ty = cty.ctyp_type in
      let clty = class_type env scty in
      let typ = Cty_arrow (l, ty, clty.cltyp_type) in
      cltyp (Tcty_arrow (l, cty, clty)) typ
  | Pcty_extension ext ->
      raise (Error_forward (Typetexp.error_of_extension ext))

let class_type env scty =
  delayed_meth_specs := [];
  let cty = class_type env scty in
  List.iter Lazy.force (List.rev !delayed_meth_specs);
  delayed_meth_specs := [];
  cty

(*******************************)

let rec class_field self_loc cl_num self_type meths vars
    (val_env, met_env, par_env, fields, concr_meths, warn_vals, inher,
     local_meths, local_vals)
  cf =
  let loc = cf.pcf_loc in
  let mkcf desc = { cf_desc = desc; cf_loc = loc; cf_attributes = cf.pcf_attributes } in
  match cf.pcf_desc with
    Pcf_inherit (ovf, sparent, super) ->
      let parent = class_expr cl_num val_env par_env sparent in
      let inher =
        match parent.cl_type with
          Cty_constr (p, tl, _) -> (p, tl) :: inher
        | _ -> inher
      in
      let (cl_sig, concr_meths, warn_vals) =
        inheritance self_type val_env (Some ovf) concr_meths warn_vals
          sparent.pcl_loc parent.cl_type
      in
      (* Variables *)
      let (val_env, met_env, par_env, inh_vars) =
        Vars.fold
          (fun lab info (val_env, met_env, par_env, inh_vars) ->
             let mut, vr, ty = info in
             let (id, val_env, met_env, par_env) =
               enter_val cl_num vars true lab mut vr ty val_env met_env par_env
                 sparent.pcl_loc
             in
             (val_env, met_env, par_env, (lab, id) :: inh_vars))
          cl_sig.csig_vars (val_env, met_env, par_env, [])
      in
      (* Inherited concrete methods *)
      let inh_meths =
        Concr.fold (fun lab rem -> (lab, Ident.create lab)::rem)
          cl_sig.csig_concr []
      in
      (* Super *)
      let (val_env, met_env, par_env) =
        match super with
          None ->
            (val_env, met_env, par_env)
        | Some name ->
            let (id, val_env, met_env, par_env) =
              enter_met_env ~check:(fun s -> Warnings.Unused_ancestor s)
                sparent.pcl_loc name (Val_anc (inh_meths, cl_num)) self_type
                val_env met_env par_env
            in
            (val_env, met_env, par_env)
      in
      (val_env, met_env, par_env,
       lazy (mkcf (Tcf_inherit (ovf, parent, super, inh_vars, inh_meths)))
       :: fields,
       concr_meths, warn_vals, inher, local_meths, local_vals)

  | Pcf_val (lab, mut, Cfk_virtual styp) ->
      if !Clflags.principal then Ctype.begin_def ();
      let cty = Typetexp.transl_simple_type val_env false styp in
      let ty = cty.ctyp_type in
      if !Clflags.principal then begin
        Ctype.end_def ();
        Ctype.generalize_structure ty
      end;
      let (id, val_env, met_env', par_env) =
        enter_val cl_num vars false lab.txt mut Virtual ty
          val_env met_env par_env loc
      in
      (val_env, met_env', par_env,
       lazy (mkcf (Tcf_val (lab, mut, id, Tcfk_virtual cty,
                            met_env == met_env')))
             :: fields,
             concr_meths, warn_vals, inher, local_meths, local_vals)

  | Pcf_val (lab, mut, Cfk_concrete (ovf, sexp)) ->
      if Concr.mem lab.txt local_vals then
        raise(Error(loc, val_env, Duplicate ("instance variable", lab.txt)));
      if Concr.mem lab.txt warn_vals then begin
        if ovf = Fresh then
          Location.prerr_warning lab.loc
            (Warnings.Instance_variable_override[lab.txt])
      end else begin
        if ovf = Override then
          raise(Error(loc, val_env,
                      No_overriding ("instance variable", lab.txt)))
      end;
      if !Clflags.principal then Ctype.begin_def ();
      let exp =
        try type_exp val_env sexp with Ctype.Unify [(ty, _)] ->
          raise(Error(loc, val_env, Make_nongen_seltype ty))
      in
      if !Clflags.principal then begin
        Ctype.end_def ();
        Ctype.generalize_structure exp.exp_type
       end;
      let (id, val_env, met_env', par_env) =
        enter_val cl_num vars false lab.txt mut Concrete exp.exp_type
          val_env met_env par_env loc
      in
      (val_env, met_env', par_env,
       lazy (mkcf (Tcf_val (lab, mut, id,
                            Tcfk_concrete (ovf, exp), met_env == met_env')))
       :: fields,
       concr_meths, Concr.add lab.txt warn_vals, inher, local_meths,
       Concr.add lab.txt local_vals)

  | Pcf_method (lab, priv, Cfk_virtual sty) ->
      let cty = virtual_method val_env meths self_type lab.txt priv sty loc in
      (val_env, met_env, par_env,
        lazy (mkcf(Tcf_method (lab, priv, Tcfk_virtual cty)))
       ::fields,
        concr_meths, warn_vals, inher, local_meths, local_vals)

  | Pcf_method (lab, priv, Cfk_concrete (ovf, expr))  ->
      let expr =
        match expr.pexp_desc with
        | Pexp_poly _ -> expr
        | _ -> Ast_helper.Exp.poly ~loc:expr.pexp_loc expr None
      in
      if Concr.mem lab.txt local_meths then
        raise(Error(loc, val_env, Duplicate ("method", lab.txt)));
      if Concr.mem lab.txt concr_meths then begin
        if ovf = Fresh then
          Location.prerr_warning loc (Warnings.Method_override [lab.txt])
      end else begin
        if ovf = Override then
          raise(Error(loc, val_env, No_overriding("method", lab.txt)))
      end;
      let (_, ty) =
        Ctype.filter_self_method val_env lab.txt priv meths self_type
      in
      begin try match expr.pexp_desc with
        Pexp_poly (sbody, sty) ->
          begin match sty with None -> ()
                | Some sty ->
                    let sty = Ast_helper.Typ.force_poly sty in
                    let cty' = Typetexp.transl_simple_type val_env false sty in
                    let ty' = cty'.ctyp_type in
              Ctype.unify val_env ty' ty
          end;
          begin match (Ctype.repr ty).desc with
            Tvar _ ->
              let ty' = Ctype.newvar () in
              Ctype.unify val_env (Ctype.newty (Tpoly (ty', []))) ty;
              Ctype.unify val_env (type_approx val_env sbody) ty'
          | Tpoly (ty1, tl) ->
              let _, ty1' = Ctype.instance_poly false tl ty1 in
              let ty2 = type_approx val_env sbody in
              Ctype.unify val_env ty2 ty1'
          | _ -> assert false
          end
      | _ -> assert false
      with Ctype.Unify trace ->
        raise(Error(loc, val_env,
                    Field_type_mismatch ("method", lab.txt, trace)))
      end;
      let meth_expr = make_method self_loc cl_num expr in
      (* backup variables for Pexp_override *)
      let vars_local = !vars in

      let field =
        lazy begin
          let meth_type =
            Btype.newgenty (Tarrow("", self_type, ty, Cok)) in
          Ctype.raise_nongen_level ();
          vars := vars_local;
          let texp = type_expect met_env meth_expr meth_type in
          Ctype.end_def ();
          mkcf (Tcf_method (lab, priv, Tcfk_concrete (ovf, texp)))
        end in
      (val_env, met_env, par_env, field::fields,
       Concr.add lab.txt concr_meths, warn_vals, inher,
       Concr.add lab.txt local_meths, local_vals)

  | Pcf_constraint (sty, sty') ->
      let (cty, cty') = type_constraint val_env sty sty' loc in
      (val_env, met_env, par_env,
        lazy (mkcf (Tcf_constraint (cty, cty'))) :: fields,
        concr_meths, warn_vals, inher, local_meths, local_vals)

  | Pcf_initializer expr ->
      let expr = make_method self_loc cl_num expr in
      let vars_local = !vars in
      let field =
        lazy begin
          Ctype.raise_nongen_level ();
          let meth_type =
            Ctype.newty
              (Tarrow ("", self_type,
                       Ctype.instance_def Predef.type_unit, Cok)) in
          vars := vars_local;
          let texp = type_expect met_env expr meth_type in
          Ctype.end_def ();
          mkcf (Tcf_initializer texp)
        end in
      (val_env, met_env, par_env, field::fields, concr_meths, warn_vals,
       inher, local_meths, local_vals)
  | Pcf_attribute x ->
      Typetexp.warning_attribute [x];
      (val_env, met_env, par_env,
        lazy (mkcf (Tcf_attribute x)) :: fields,
        concr_meths, warn_vals, inher, local_meths, local_vals)
  | Pcf_extension ext ->
      raise (Error_forward (Typetexp.error_of_extension ext))

and class_structure cl_num final val_env met_env loc
  { pcstr_self = spat; pcstr_fields = str } =
  (* Environment for substructures *)
  let par_env = met_env in

  (* Location of self. Used for locations of self arguments *)
  let self_loc = {spat.ppat_loc with Location.loc_ghost = true} in

  (* Self type, with a dummy method preventing it from being closed/escaped. *)
  let self_type = Ctype.newvar () in
  Ctype.unify val_env
    (Ctype.filter_method val_env dummy_method Private self_type)
    (Ctype.newty (Ttuple []));

  (* Private self is used for private method calls *)
  let private_self = if final then Ctype.newvar () else self_type in

  (* Self binder *)
  let (pat, meths, vars, val_env, meth_env, par_env) =
    type_self_pattern cl_num private_self val_env met_env par_env spat
  in
  let public_self = pat.pat_type in

  (* Check that the binder has a correct type *)
  let ty =
    if final then Ctype.newty (Tobject (Ctype.newvar(), ref None))
    else self_type in
  begin try Ctype.unify val_env public_self ty with
    Ctype.Unify _ ->
      raise(Error(spat.ppat_loc, val_env, Pattern_type_clash public_self))
  end;
  let get_methods ty =
    (fst (Ctype.flatten_fields
            (Ctype.object_fields (Ctype.expand_head val_env ty)))) in
  if final then begin
    (* Copy known information to still empty self_type *)
    List.iter
      (fun (lab,kind,ty) ->
        let k =
          if Btype.field_kind_repr kind = Fpresent then Public else Private in
        try Ctype.unify val_env ty
            (Ctype.filter_method val_env lab k self_type)
        with _ -> assert false)
      (get_methods public_self)
  end;

  (* Typing of class fields *)
  Typetexp.warning_enter_scope ();
  let (_, _, _, fields, concr_meths, _, inher, _local_meths, _local_vals) =
    List.fold_left (class_field self_loc cl_num self_type meths vars)
      (val_env, meth_env, par_env, [], Concr.empty, Concr.empty, [],
       Concr.empty, Concr.empty)
      str
  in
  Typetexp.warning_leave_scope ();
  Ctype.unify val_env self_type (Ctype.newvar ());
  let sign =
    {csig_self = public_self;
     csig_vars = Vars.map (fun (id, mut, vr, ty) -> (mut, vr, ty)) !vars;
     csig_concr = concr_meths;
      csig_inher = inher} in
  let methods = get_methods self_type in
  let priv_meths =
    List.filter (fun (_,kind,_) -> Btype.field_kind_repr kind <> Fpresent)
      methods in
  if final then begin
    (* Unify private_self and a copy of self_type. self_type will not
       be modified after this point *)
    Ctype.close_object self_type;
    let mets = virtual_methods {sign with csig_self = self_type} in
    let vals =
      Vars.fold
        (fun name (mut, vr, ty) l -> if vr = Virtual then name :: l else l)
        sign.csig_vars [] in
    if mets <> [] || vals <> [] then
      raise(Error(loc, val_env, Virtual_class(true, final, mets, vals)));
    let self_methods =
      List.fold_right
        (fun (lab,kind,ty) rem ->
          if lab = dummy_method then
            (* allow public self and private self to be unified *)
            match Btype.field_kind_repr kind with
              Fvar r -> Btype.set_kind r Fabsent; rem
            | _ -> rem
          else
            Ctype.newty(Tfield(lab, Btype.copy_kind kind, ty, rem)))
        methods (Ctype.newty Tnil) in
    begin try
      Ctype.unify val_env private_self
        (Ctype.newty (Tobject(self_methods, ref None)));
      Ctype.unify val_env public_self self_type
    with Ctype.Unify trace -> raise(Error(loc, val_env, Final_self_clash trace))
    end;
  end;

  (* Typing of method bodies *)
  if !Clflags.principal then
    List.iter (fun (_,_,ty) -> Ctype.generalize_spine ty) methods;
  let fields = List.map Lazy.force (List.rev fields) in
  if !Clflags.principal then
    List.iter (fun (_,_,ty) -> Ctype.unify val_env ty (Ctype.newvar ()))
      methods;
  let meths = Meths.map (function (id, ty) -> id) !meths in

  (* Check for private methods made public *)
  let pub_meths' =
    List.filter (fun (_,kind,_) -> Btype.field_kind_repr kind = Fpresent)
      (get_methods public_self) in
  let names = List.map (fun (x,_,_) -> x) in
  let l1 = names priv_meths and l2 = names pub_meths' in
  let added = List.filter (fun x -> List.mem x l1) l2 in
  if added <> [] then
    Location.prerr_warning loc (Warnings.Implicit_public_methods added);
  let sign = if final then sign else
      {sign with csig_self = Ctype.expand_head val_env public_self} in
  {
    cstr_self = pat;
    cstr_fields = fields;
    cstr_type = sign;
    cstr_meths = meths}, sign (* redondant, since already in cstr_type *)

and class_expr cl_num val_env met_env scl =
  match scl.pcl_desc with
    Pcl_constr (lid, styl) ->
      let (path, decl) = Typetexp.find_class val_env scl.pcl_loc lid.txt in
      if Path.same decl.cty_path unbound_class then
        raise(Error(scl.pcl_loc, val_env, Unbound_class_2 lid.txt));
      let tyl = List.map
          (fun sty -> transl_simple_type val_env false sty)
          styl
      in
      let (params, clty) =
        Ctype.instance_class decl.cty_params decl.cty_type
      in
      let clty' = abbreviate_class_type path params clty in
      if List.length params <> List.length tyl then
        raise(Error(scl.pcl_loc, val_env,
                    Parameter_arity_mismatch (lid.txt, List.length params,
                                                   List.length tyl)));
      List.iter2
        (fun cty' ty ->
          let ty' = cty'.ctyp_type in
           try Ctype.unify val_env ty' ty with Ctype.Unify trace ->
             raise(Error(cty'.ctyp_loc, val_env, Parameter_mismatch trace)))
        tyl params;
      let cl =
        rc {cl_desc = Tcl_ident (path, lid, tyl);
            cl_loc = scl.pcl_loc;
            cl_type = clty';
            cl_env = val_env;
            cl_attributes = scl.pcl_attributes;
           }
      in
      let (vals, meths, concrs) = extract_constraints clty in
      rc {cl_desc = Tcl_constraint (cl, None, vals, meths, concrs);
          cl_loc = scl.pcl_loc;
          cl_type = clty';
          cl_env = val_env;
          cl_attributes = []; (* attributes are kept on the inner cl node *)
         }
  | Pcl_structure cl_str ->
      let (desc, ty) =
        class_structure cl_num false val_env met_env scl.pcl_loc cl_str in
      rc {cl_desc = Tcl_structure desc;
          cl_loc = scl.pcl_loc;
          cl_type = Cty_signature ty;
          cl_env = val_env;
          cl_attributes = scl.pcl_attributes;
         }
  | Pcl_fun (l, Some default, spat, sbody) ->
      let loc = default.pexp_loc in
      let open Ast_helper in
      let scases = [
        Exp.case
          (Pat.construct ~loc
             (mknoloc (Longident.(Ldot (Lident "*predef*", "Some"))))
             (Some (Pat.var ~loc (mknoloc "*sth*"))))
          (Exp.ident ~loc (mknoloc (Longident.Lident "*sth*")));

        Exp.case
          (Pat.construct ~loc
             (mknoloc (Longident.(Ldot (Lident "*predef*", "None"))))
             None)
          default;
       ]
      in
      let smatch =
        Exp.match_ ~loc (Exp.ident ~loc (mknoloc (Longident.Lident "*opt*")))
          scases
      in
      let sfun =
        Cl.fun_ ~loc:scl.pcl_loc
          l None
          (Pat.var ~loc (mknoloc "*opt*"))
          (Cl.let_ ~loc:scl.pcl_loc Nonrecursive [Vb.mk spat smatch] sbody)
          (* Note: we don't put the '#default' attribute, as it
             is not detected for class-level let bindings.  See #5975.*)
      in
      class_expr cl_num val_env met_env sfun
  | Pcl_fun (l, None, spat, scl') ->
      if !Clflags.principal then Ctype.begin_def ();
      let (pat, pv, val_env', met_env) =
        Typecore.type_class_arg_pattern cl_num val_env met_env l spat
      in
      if !Clflags.principal then begin
        Ctype.end_def ();
        iter_pattern (fun {pat_type=ty} -> Ctype.generalize_structure ty) pat
      end;
      let pv =
        List.map
          begin fun (id, id_loc, id', ty) ->
            let path = Pident id' in
            (* do not mark the value as being used *)
            let vd = Env.find_value path val_env' in
            (id, id_loc,
             {exp_desc =
              Texp_ident(path, mknoloc (Longident.Lident (Ident.name id)), vd);
              exp_loc = Location.none; exp_extra = [];
              exp_type = Ctype.instance val_env' vd.val_type;
              exp_attributes = []; (* check *)
              exp_env = val_env'})
          end
          pv
      in
      let not_function = function
          Cty_arrow _ -> false
        | _ -> true
      in
      let partial =
        Typecore.check_partial val_env pat.pat_type pat.pat_loc
          [{c_lhs=pat;
            c_guard=None;
            c_rhs = (* Dummy expression *)
            {exp_desc = Texp_constant (Asttypes.Const_int 1);
             exp_loc = Location.none; exp_extra = [];
             exp_type = Ctype.none;
             exp_attributes = [];
             exp_env = Env.empty }}]
      in
      Ctype.raise_nongen_level ();
      let cl = class_expr cl_num val_env' met_env scl' in
      Ctype.end_def ();
      if Btype.is_optional l && not_function cl.cl_type then
        Location.prerr_warning pat.pat_loc
          Warnings.Unerasable_optional_argument;
      rc {cl_desc = Tcl_fun (l, pat, pv, cl, partial);
          cl_loc = scl.pcl_loc;
          cl_type = Cty_arrow
            (l, Ctype.instance_def pat.pat_type, cl.cl_type);
          cl_env = val_env;
          cl_attributes = scl.pcl_attributes;
         }
  | Pcl_apply (scl', sargs) ->
      if sargs = [] then
        Syntaxerr.ill_formed_ast scl.pcl_loc
          "Function application with no argument.";
      if !Clflags.principal then Ctype.begin_def ();
      let cl = class_expr cl_num val_env met_env scl' in
      if !Clflags.principal then begin
        Ctype.end_def ();
        generalize_class_type false cl.cl_type;
      end;
      let rec nonopt_labels ls ty_fun =
        match ty_fun with
        | Cty_arrow (l, _, ty_res) ->
            if Btype.is_optional l then nonopt_labels ls ty_res
            else nonopt_labels (l::ls) ty_res
        | _    -> ls
      in
      let ignore_labels =
        !Clflags.classic ||
        let labels = nonopt_labels [] cl.cl_type in
        List.length labels = List.length sargs &&
        List.for_all (fun (l,_) -> l = "") sargs &&
        List.exists (fun l -> l <> "") labels &&
        begin
          Location.prerr_warning cl.cl_loc Warnings.Labels_omitted;
          true
        end
      in
      let rec type_args args omitted ty_fun ty_fun0 sargs more_sargs =
        match ty_fun, ty_fun0 with
        | Cty_arrow (l, ty, ty_fun), Cty_arrow (_, ty0, ty_fun0)
          when sargs <> [] || more_sargs <> [] ->
            let name = Btype.label_name l
            and optional =
              if Btype.is_optional l then Optional else Required in
            let sargs, more_sargs, arg =
              if ignore_labels && not (Btype.is_optional l) then begin
                match sargs, more_sargs with
                  (l', sarg0)::_, _ ->
                    raise(Error(sarg0.pexp_loc, val_env, Apply_wrong_label l'))
                | _, (l', sarg0)::more_sargs ->
                    if l <> l' && l' <> "" then
                      raise(Error(sarg0.pexp_loc, val_env,
                                  Apply_wrong_label l'))
                    else ([], more_sargs,
                          Some (type_argument val_env sarg0 ty ty0))
                | _ ->
                    assert false
              end else try
                let (l', sarg0, sargs, more_sargs) =
                  try
                    let (l', sarg0, sargs1, sargs2) =
                      Btype.extract_label name sargs
                    in (l', sarg0, sargs1 @ sargs2, more_sargs)
                  with Not_found ->
                    let (l', sarg0, sargs1, sargs2) =
                      Btype.extract_label name more_sargs
                    in (l', sarg0, sargs @ sargs1, sargs2)
                in
                if optional = Required && Btype.is_optional l' then
                  Location.prerr_warning sarg0.pexp_loc
                    (Warnings.Nonoptional_label l);
                sargs, more_sargs,
                if optional = Required || Btype.is_optional l' then
                  Some (type_argument val_env sarg0 ty ty0)
                else
                  let ty' = extract_option_type val_env ty
                  and ty0' = extract_option_type val_env ty0 in
                  let arg = type_argument val_env sarg0 ty' ty0' in
                  Some (option_some arg)
              with Not_found ->
                sargs, more_sargs,
                if Btype.is_optional l &&
                  (List.mem_assoc "" sargs || List.mem_assoc "" more_sargs)
                then
                  Some (option_none ty0 Location.none)
                else None
            in
            let omitted = if arg = None then (l,ty0) :: omitted else omitted in
            type_args ((l,arg,optional)::args) omitted ty_fun ty_fun0
              sargs more_sargs
        | _ ->
            match sargs @ more_sargs with
              (l, sarg0)::_ ->
                if omitted <> [] then
                  raise(Error(sarg0.pexp_loc, val_env, Apply_wrong_label l))
                else
                  raise(Error(cl.cl_loc, val_env, Cannot_apply cl.cl_type))
            | [] ->
                (List.rev args,
                 List.fold_left
                   (fun ty_fun (l,ty) -> Cty_arrow(l,ty,ty_fun))
                   ty_fun0 omitted)
      in
      let (args, cty) =
        let (_, ty_fun0) = Ctype.instance_class [] cl.cl_type in
        if ignore_labels then
          type_args [] [] cl.cl_type ty_fun0 [] sargs
        else
          type_args [] [] cl.cl_type ty_fun0 sargs []
      in
      rc {cl_desc = Tcl_apply (cl, args);
          cl_loc = scl.pcl_loc;
          cl_type = cty;
          cl_env = val_env;
          cl_attributes = scl.pcl_attributes;
         }
  | Pcl_let (rec_flag, sdefs, scl') ->
      let (defs, val_env) =
        try
          Typecore.type_let val_env rec_flag sdefs None
        with Ctype.Unify [(ty, _)] ->
          raise(Error(scl.pcl_loc, val_env, Make_nongen_seltype ty))
      in
      let (vals, met_env) =
        List.fold_right
          (fun (id, id_loc) (vals, met_env) ->
             let path = Pident id in
             (* do not mark the value as used *)
             let vd = Env.find_value path val_env in
             Ctype.begin_def ();
             let expr =
               {exp_desc =
                Texp_ident(path, mknoloc(Longident.Lident (Ident.name id)),vd);
                exp_loc = Location.none; exp_extra = [];
                exp_type = Ctype.instance val_env vd.val_type;
                exp_attributes = [];
                exp_env = val_env;
               }
             in
             Ctype.end_def ();
             Ctype.generalize expr.exp_type;
             let desc =
               {val_type = expr.exp_type; val_kind = Val_ivar (Immutable,
                                                               cl_num);
                val_attributes = [];
                Types.val_loc = vd.Types.val_loc;
               }
             in
             let id' = Ident.create (Ident.name id) in
             ((id', id_loc, expr)
              :: vals,
              Env.add_value id' desc met_env))
          (let_bound_idents_with_loc defs)
          ([], met_env)
      in
      let cl = class_expr cl_num val_env met_env scl' in
      rc {cl_desc = Tcl_let (rec_flag, defs, vals, cl);
          cl_loc = scl.pcl_loc;
          cl_type = cl.cl_type;
          cl_env = val_env;
          cl_attributes = scl.pcl_attributes;
         }
  | Pcl_constraint (scl', scty) ->
      Ctype.begin_class_def ();
      let context = Typetexp.narrow () in
      let cl = class_expr cl_num val_env met_env scl' in
      Typetexp.widen context;
      let context = Typetexp.narrow () in
      let clty = class_type val_env scty in
      Typetexp.widen context;
      Ctype.end_def ();

      limited_generalize (Ctype.row_variable (Ctype.self_type cl.cl_type))
          cl.cl_type;
      limited_generalize (Ctype.row_variable (Ctype.self_type clty.cltyp_type))
        clty.cltyp_type;

      begin match
        Includeclass.class_types val_env cl.cl_type clty.cltyp_type
      with
        []    -> ()
      | error -> raise(Error(cl.cl_loc, val_env, Class_match_failure error))
      end;
      let (vals, meths, concrs) = extract_constraints clty.cltyp_type in
      rc {cl_desc = Tcl_constraint (cl, Some clty, vals, meths, concrs);
          cl_loc = scl.pcl_loc;
          cl_type = snd (Ctype.instance_class [] clty.cltyp_type);
          cl_env = val_env;
          cl_attributes = scl.pcl_attributes;
         }
  | Pcl_extension ext ->
      raise (Error_forward (Typetexp.error_of_extension ext))

(*******************************)

(* Approximate the type of the constructor to allow recursive use *)
(* of optional parameters                                         *)

let var_option = Predef.type_option (Btype.newgenvar ())

let rec approx_declaration cl =
  match cl.pcl_desc with
    Pcl_fun (l, _, _, cl) ->
      let arg =
        if Btype.is_optional l then Ctype.instance_def var_option
        else Ctype.newvar () in
      Ctype.newty (Tarrow (l, arg, approx_declaration cl, Cok))
  | Pcl_let (_, _, cl) ->
      approx_declaration cl
  | Pcl_constraint (cl, _) ->
      approx_declaration cl
  | _ -> Ctype.newvar ()

let rec approx_description ct =
  match ct.pcty_desc with
    Pcty_arrow (l, _, ct) ->
      let arg =
        if Btype.is_optional l then Ctype.instance_def var_option
        else Ctype.newvar () in
      Ctype.newty (Tarrow (l, arg, approx_description ct, Cok))
  | _ -> Ctype.newvar ()

(*******************************)

let temp_abbrev loc env id arity =
  let params = ref [] in
  for _i = 1 to arity do
    params := Ctype.newvar () :: !params
  done;
  let ty = Ctype.newobj (Ctype.newvar ()) in
  let env =
    Env.add_type ~check:true id
      {type_params = !params;
       type_arity = arity;
       type_kind = Type_abstract;
       type_private = Public;
       type_manifest = Some ty;
       type_variance = Misc.replicate_list Variance.full arity;
       type_newtype_level = None;
       type_loc = loc;
       type_attributes = []; (* or keep attrs from the class decl? *)
      }
      env
  in
  (!params, ty, env)

let initial_env define_class approx
    (res, env) (cl, id, ty_id, obj_id, cl_id) =
  (* Temporary abbreviations *)
  let arity = List.length cl.pci_params in
  let (obj_params, obj_ty, env) = temp_abbrev cl.pci_loc env obj_id arity in
  let (cl_params, cl_ty, env) = temp_abbrev cl.pci_loc env cl_id arity in

  (* Temporary type for the class constructor *)
  let constr_type = approx cl.pci_expr in
  if !Clflags.principal then Ctype.generalize_spine constr_type;
  let dummy_cty =
    Cty_signature
      { csig_self = Ctype.newvar ();
        csig_vars = Vars.empty;
        csig_concr = Concr.empty;
        csig_inher = [] }
  in
  let dummy_class =
    {Types.cty_params = [];             (* Dummy value *)
     cty_variance = [];
     cty_type = dummy_cty;        (* Dummy value *)
     cty_path = unbound_class;
     cty_new =
       begin match cl.pci_virt with
       | Virtual  -> None
       | Concrete -> Some constr_type
       end;
     cty_loc = Location.none;
     cty_attributes = [];
    }
  in
  let env =
    Env.add_cltype ty_id
      {clty_params = [];            (* Dummy value *)
       clty_variance = [];
       clty_type = dummy_cty;       (* Dummy value *)
       clty_path = unbound_class;
       clty_loc = Location.none;
       clty_attributes = [];
      }
      (
        if define_class then
          Env.add_class id dummy_class env
        else
          env
      )
  in
  ((cl, id, ty_id,
    obj_id, obj_params, obj_ty,
    cl_id, cl_params, cl_ty,
    constr_type, dummy_class)::res,
   env)

let class_infos define_class kind
    (cl, id, ty_id,
     obj_id, obj_params, obj_ty,
     cl_id, cl_params, cl_ty,
     constr_type, dummy_class)
    (res, env) =

  reset_type_variables ();
  Ctype.begin_class_def ();

  (* Introduce class parameters *)
  let ci_params =
    let make_param (sty, v) =
      try
          (transl_type_param env sty, v)
      with Already_bound ->
        raise(Error(sty.ptyp_loc, env, Repeated_parameter))
    in
      List.map make_param cl.pci_params
  in
  let params = List.map (fun (cty, _) -> cty.ctyp_type) ci_params in

  (* Allow self coercions (only for class declarations) *)
  let coercion_locs = ref [] in

  (* Type the class expression *)
  let (expr, typ) =
    try
      Typecore.self_coercion :=
        (Path.Pident obj_id, coercion_locs) :: !Typecore.self_coercion;
      let res = kind env cl.pci_expr in
      Typecore.self_coercion := List.tl !Typecore.self_coercion;
      res
    with exn ->
      Typecore.self_coercion := []; raise exn
  in

  Ctype.end_def ();

  let sty = Ctype.self_type typ in

  (* First generalize the type of the dummy method (cf PR#6123) *)
  let (fields, _) = Ctype.flatten_fields (Ctype.object_fields sty) in
  List.iter (fun (met, _, ty) -> if met = dummy_method then Ctype.generalize ty)
    fields;
  (* Generalize the row variable *)
  let rv = Ctype.row_variable sty in
  List.iter (Ctype.limited_generalize rv) params;
  limited_generalize rv typ;

  (* Check the abbreviation for the object type *)
  let (obj_params', obj_type) = Ctype.instance_class params typ in
  let constr = Ctype.newconstr (Path.Pident obj_id) obj_params in
  begin
    let ty = Ctype.self_type obj_type in
    Ctype.hide_private_methods ty;
    Ctype.close_object ty;
    begin try
      List.iter2 (Ctype.unify env) obj_params obj_params'
    with Ctype.Unify _ ->
      raise(Error(cl.pci_loc, env,
            Bad_parameters (obj_id, constr,
                            Ctype.newconstr (Path.Pident obj_id)
                                            obj_params')))
    end;
    begin try
      Ctype.unify env ty constr
    with Ctype.Unify _ ->
      raise(Error(cl.pci_loc, env,
        Abbrev_type_clash (constr, ty, Ctype.expand_head env constr)))
    end
  end;

  (* Check the other temporary abbreviation (#-type) *)
  begin
    let (cl_params', cl_type) = Ctype.instance_class params typ in
    let ty = Ctype.self_type cl_type in
    Ctype.hide_private_methods ty;
    Ctype.set_object_name obj_id (Ctype.row_variable ty) cl_params ty;
    begin try
      List.iter2 (Ctype.unify env) cl_params cl_params'
    with Ctype.Unify _ ->
      raise(Error(cl.pci_loc, env,
            Bad_parameters (cl_id,
                            Ctype.newconstr (Path.Pident cl_id)
                                            cl_params,
                            Ctype.newconstr (Path.Pident cl_id)
                                            cl_params')))
    end;
    begin try
      Ctype.unify env ty cl_ty
    with Ctype.Unify _ ->
      let constr = Ctype.newconstr (Path.Pident cl_id) params in
      raise(Error(cl.pci_loc, env, Abbrev_type_clash (constr, ty, cl_ty)))
    end
  end;

  (* Type of the class constructor *)
  begin try
    Ctype.unify env
      (constructor_type constr obj_type)
      (Ctype.instance env constr_type)
  with Ctype.Unify trace ->
    raise(Error(cl.pci_loc, env,
                Constructor_type_mismatch (cl.pci_name.txt, trace)))
  end;

  (* Class and class type temporary definitions *)
  let cty_variance = List.map (fun _ -> Variance.full) params in
  let cltydef =
    {clty_params = params; clty_type = class_body typ;
     clty_variance = cty_variance;
     clty_path = Path.Pident obj_id;
     clty_loc = cl.pci_loc;
     clty_attributes = cl.pci_attributes;
    }
  and clty =
    {cty_params = params; cty_type = typ;
     cty_variance = cty_variance;
     cty_path = Path.Pident obj_id;
     cty_new =
       begin match cl.pci_virt with
       | Virtual  -> None
       | Concrete -> Some constr_type
       end;
     cty_loc = cl.pci_loc;
     cty_attributes = cl.pci_attributes;
    }
  in
  dummy_class.cty_type <- typ;
  let env =
    Env.add_cltype ty_id cltydef (
    if define_class then Env.add_class id clty env else env)
  in

  if cl.pci_virt = Concrete then begin
    let sign = Ctype.signature_of_class_type typ in
    let mets = virtual_methods sign in
    let vals =
      Vars.fold
        (fun name (mut, vr, ty) l -> if vr = Virtual then name :: l else l)
        sign.csig_vars [] in
    if mets <> []  || vals <> [] then
      raise(Error(cl.pci_loc, env, Virtual_class(define_class, false, mets, vals)));
  end;

  (* Misc. *)
  let arity = Ctype.class_type_arity typ in
  let pub_meths =
    let (fields, _) =
      Ctype.flatten_fields (Ctype.object_fields (Ctype.expand_head env obj_ty))
    in
    List.map (function (lab, _, _) -> lab) fields
  in

  (* Final definitions *)
  let (params', typ') = Ctype.instance_class params typ in
  let cltydef =
    {clty_params = params'; clty_type = class_body typ';
     clty_variance = cty_variance;
     clty_path = Path.Pident obj_id;
     clty_loc = cl.pci_loc;
     clty_attributes = cl.pci_attributes;
    }
  and clty =
    {cty_params = params'; cty_type = typ';
     cty_variance = cty_variance;
     cty_path = Path.Pident obj_id;
     cty_new =
       begin match cl.pci_virt with
       | Virtual  -> None
       | Concrete -> Some (Ctype.instance env constr_type)
       end;
     cty_loc = cl.pci_loc;
     cty_attributes = cl.pci_attributes;
    }
  in
  let obj_abbr =
    {type_params = obj_params;
     type_arity = List.length obj_params;
     type_kind = Type_abstract;
     type_private = Public;
     type_manifest = Some obj_ty;
     type_variance = List.map (fun _ -> Variance.full) obj_params;
     type_newtype_level = None;
     type_loc = cl.pci_loc;
     type_attributes = []; (* or keep attrs from cl? *)
    }
  in
  let (cl_params, cl_ty) =
    Ctype.instance_parameterized_type params (Ctype.self_type typ)
  in
  Ctype.hide_private_methods cl_ty;
  Ctype.set_object_name obj_id (Ctype.row_variable cl_ty) cl_params cl_ty;
  let cl_abbr =
    {type_params = cl_params;
     type_arity = List.length cl_params;
     type_kind = Type_abstract;
     type_private = Public;
     type_manifest = Some cl_ty;
     type_variance = List.map (fun _ -> Variance.full) cl_params;
     type_newtype_level = None;
     type_loc = cl.pci_loc;
     type_attributes = []; (* or keep attrs from cl? *)
    }
  in
  ((cl, id, clty, ty_id, cltydef, obj_id, obj_abbr, cl_id, cl_abbr, ci_params,
    arity, pub_meths, List.rev !coercion_locs, expr) :: res,
   env)

let final_decl env define_class
    (cl, id, clty, ty_id, cltydef, obj_id, obj_abbr, cl_id, cl_abbr, ci_params,
     arity, pub_meths, coe, expr) =

  begin try Ctype.collapse_conj_params env clty.cty_params
  with Ctype.Unify trace ->
    raise(Error(cl.pci_loc, env, Non_collapsable_conjunction (id, clty, trace)))
  end;

  List.iter Ctype.generalize clty.cty_params;
  generalize_class_type true clty.cty_type;
  Misc.may  Ctype.generalize clty.cty_new;
  List.iter Ctype.generalize obj_abbr.type_params;
  Misc.may  Ctype.generalize obj_abbr.type_manifest;
  List.iter Ctype.generalize cl_abbr.type_params;
  Misc.may  Ctype.generalize cl_abbr.type_manifest;

  if not (closed_class clty) then
    raise(Error(cl.pci_loc, env, Non_generalizable_class (id, clty)));

  begin match
    Ctype.closed_class clty.cty_params
      (Ctype.signature_of_class_type clty.cty_type)
  with
    None        -> ()
  | Some reason ->
      let printer =
        if define_class
        then function ppf -> Printtyp.class_declaration id ppf clty
        else function ppf -> Printtyp.cltype_declaration id ppf cltydef
      in
      raise(Error(cl.pci_loc, env, Unbound_type_var(printer, reason)))
  end;

  (id, cl.pci_name, clty, ty_id, cltydef, obj_id, obj_abbr, cl_id, cl_abbr,
   arity, pub_meths, coe, expr,
   { ci_loc = cl.pci_loc;
     ci_virt = cl.pci_virt;
     ci_params = ci_params;
(* TODO : check that we have the correct use of identifiers *)
     ci_id_name = cl.pci_name;
     ci_id_class = id;
     ci_id_class_type = ty_id;
     ci_id_object = obj_id;
     ci_id_typesharp = cl_id;
     ci_expr = expr;
     ci_decl = clty;
     ci_type_decl = cltydef;
     ci_attributes = cl.pci_attributes;
 })
(*   (cl.pci_variance, cl.pci_loc)) *)

let extract_type_decls
    (id, id_loc, clty, ty_id, cltydef, obj_id, obj_abbr, cl_id, cl_abbr,
     arity, pub_meths, coe, expr, required) decls =
  (obj_id, obj_abbr, cl_abbr, clty, cltydef, required) :: decls

let merge_type_decls
    (id, id_loc, _clty, ty_id, _cltydef, obj_id, _obj_abbr, cl_id, _cl_abbr,
     arity, pub_meths, coe, expr, req) (obj_abbr, cl_abbr, clty, cltydef) =
  (id, id_loc, clty, ty_id, cltydef, obj_id, obj_abbr, cl_id, cl_abbr,
   arity, pub_meths, coe, expr, req)

let final_env define_class env
    (id, id_loc, clty, ty_id, cltydef, obj_id, obj_abbr, cl_id, cl_abbr,
     arity, pub_meths, coe, expr, req) =
  (* Add definitions after cleaning them *)
  Env.add_type ~check:true obj_id
    (Subst.type_declaration Subst.identity obj_abbr) (
  Env.add_type ~check:true cl_id
    (Subst.type_declaration Subst.identity cl_abbr) (
  Env.add_cltype ty_id (Subst.cltype_declaration Subst.identity cltydef) (
  if define_class then
    Env.add_class id (Subst.class_declaration Subst.identity clty) env
  else env)))

(* Check that #c is coercible to c if there is a self-coercion *)
let check_coercions env
    (id, id_loc, clty, ty_id, cltydef, obj_id, obj_abbr, cl_id, cl_abbr,
     arity, pub_meths, coercion_locs, expr, req) =
  begin match coercion_locs with [] -> ()
  | loc :: _ ->
      let cl_ty, obj_ty =
        match cl_abbr.type_manifest, obj_abbr.type_manifest with
          Some cl_ab, Some obj_ab ->
            let cl_params, cl_ty =
              Ctype.instance_parameterized_type cl_abbr.type_params cl_ab
            and obj_params, obj_ty =
              Ctype.instance_parameterized_type obj_abbr.type_params obj_ab
            in
            List.iter2 (Ctype.unify env) cl_params obj_params;
            cl_ty, obj_ty
        | _ -> assert false
      in
      begin try Ctype.subtype env cl_ty obj_ty ()
      with Ctype.Subtype (tr1, tr2) ->
        raise(Typecore.Error(loc, env, Typecore.Not_subtype(tr1, tr2)))
      end;
      if not (Ctype.opened_object cl_ty) then
        raise(Error(loc, env, Cannot_coerce_self obj_ty))
  end;
  (id, id_loc, clty, ty_id, cltydef, obj_id, obj_abbr, cl_id, cl_abbr,
   arity, pub_meths, req)

(*******************************)

let type_classes define_class approx kind env cls =
  let cls =
    List.map
      (function cl ->
         (cl,
          Ident.create cl.pci_name.txt, Ident.create cl.pci_name.txt,
          Ident.create cl.pci_name.txt, Ident.create ("#" ^ cl.pci_name.txt)))
      cls
  in
  Ctype.init_def (Ident.current_time ());
  Ctype.begin_class_def ();
  let (res, env) =
    List.fold_left (initial_env define_class approx) ([], env) cls
  in
  let (res, env) =
    List.fold_right (class_infos define_class kind) res ([], env)
  in
  Ctype.end_def ();
  let res = List.rev_map (final_decl env define_class) res in
  let decls = List.fold_right extract_type_decls res [] in
  let decls = Typedecl.compute_variance_decls env decls in
  let res = List.map2 merge_type_decls res decls in
  let env = List.fold_left (final_env define_class) env res in
  let res = List.map (check_coercions env) res in
  (res, env)

let class_num = ref 0
let class_declaration env sexpr =
  incr class_num;
  let expr = class_expr (string_of_int !class_num) env env sexpr in
  (expr, expr.cl_type)

let class_description env sexpr =
  let expr = class_type env sexpr in
  (expr, expr.cltyp_type)

let class_declarations env cls =
  type_classes true approx_declaration class_declaration env cls

let class_descriptions env cls =
  type_classes true approx_description class_description env cls

let class_type_declarations env cls =
  let (decl, env) =
    type_classes false approx_description class_description env cls
  in
  (List.map
     (function
       (_, id_loc, _, ty_id, cltydef, obj_id, obj_abbr, cl_id, cl_abbr,
        _, _, ci) ->
       (ty_id, id_loc, cltydef, obj_id, obj_abbr, cl_id, cl_abbr, ci))
     decl,
   env)

let rec unify_parents env ty cl =
  match cl.cl_desc with
    Tcl_ident (p, _, _) ->
      begin try
        let decl = Env.find_class p env in
        let _, body = Ctype.find_cltype_for_path env decl.cty_path in
        Ctype.unify env ty (Ctype.instance env body)
      with
        Not_found -> ()
      | exn -> assert false
      end
  | Tcl_structure st -> unify_parents_struct env ty st
  | Tcl_fun (_, _, _, cl, _)
  | Tcl_apply (cl, _)
  | Tcl_let (_, _, _, cl)
  | Tcl_constraint (cl, _, _, _, _) -> unify_parents env ty cl
and unify_parents_struct env ty st =
  List.iter
    (function {cf_desc = Tcf_inherit (_, cl, _, _, _)} -> unify_parents env ty cl
      | _ -> ())
    st.cstr_fields

let type_object env loc s =
  incr class_num;
  let (desc, sign) =
    class_structure (string_of_int !class_num) true env env loc s in
  let sty = Ctype.expand_head env sign.csig_self in
  Ctype.hide_private_methods sty;
  let (fields, _) = Ctype.flatten_fields (Ctype.object_fields sty) in
  let meths = List.map (fun (s,_,_) -> s) fields in
  unify_parents_struct env sign.csig_self desc;
  (desc, sign, meths)

let () =
  Typecore.type_object := type_object

(*******************************)

(* Approximate the class declaration as class ['params] id = object end *)
let approx_class sdecl =
  let open Ast_helper in
  let self' = Typ.any () in
  let clty' = Cty.signature ~loc:sdecl.pci_expr.pcty_loc (Csig.mk self' []) in
  { sdecl with pci_expr = clty' }

let approx_class_declarations env sdecls =
  fst (class_type_declarations env (List.map approx_class sdecls))

(*******************************)

(* Error report *)

open Format

let report_error env ppf = function
  | Repeated_parameter ->
      fprintf ppf "A type parameter occurs several times"
  | Unconsistent_constraint trace ->
      fprintf ppf "The class constraints are not consistent.@.";
      Printtyp.report_unification_error ppf env trace
        (fun ppf -> fprintf ppf "Type")
        (fun ppf -> fprintf ppf "is not compatible with type")
  | Field_type_mismatch (k, m, trace) ->
      Printtyp.report_unification_error ppf env trace
        (function ppf ->
           fprintf ppf "The %s %s@ has type" k m)
        (function ppf ->
           fprintf ppf "but is expected to have type")
  | Structure_expected clty ->
      fprintf ppf
        "@[This class expression is not a class structure; it has type@ %a@]"
        Printtyp.class_type clty
  | Cannot_apply clty ->
      fprintf ppf
        "This class expression is not a class function, it cannot be applied"
  | Apply_wrong_label l ->
      let mark_label = function
        | "" -> "out label"
        |  l -> sprintf " label ~%s" l in
      fprintf ppf "This argument cannot be applied with%s" (mark_label l)
  | Pattern_type_clash ty ->
      (* XXX Trace *)
      (* XXX Revoir message d'erreur *)
      Printtyp.reset_and_mark_loops ty;
      fprintf ppf "@[%s@ %a@]"
        "This pattern cannot match self: it only matches values of type"
        Printtyp.type_expr ty
  | Unbound_class_2 cl ->
      fprintf ppf "@[The class@ %a@ is not yet completely defined@]"
      Printtyp.longident cl
  | Unbound_class_type_2 cl ->
      fprintf ppf "@[The class type@ %a@ is not yet completely defined@]"
      Printtyp.longident cl
  | Abbrev_type_clash (abbrev, actual, expected) ->
      (* XXX Afficher une trace ? *)
      Printtyp.reset_and_mark_loops_list [abbrev; actual; expected];
      fprintf ppf "@[The abbreviation@ %a@ expands to type@ %a@ \
       but is used with type@ %a@]"
       Printtyp.type_expr abbrev
       Printtyp.type_expr actual
       Printtyp.type_expr expected
  | Constructor_type_mismatch (c, trace) ->
      Printtyp.report_unification_error ppf env trace
        (function ppf ->
           fprintf ppf "The expression \"new %s\" has type" c)
        (function ppf ->
           fprintf ppf "but is used with type")
  | Virtual_class (cl, imm, mets, vals) ->
      let print_mets ppf mets =
        List.iter (function met -> fprintf ppf "@ %s" met) mets in
      let missings =
        match mets, vals with
          [], _ -> "variables"
        | _, [] -> "methods"
        | _ -> "methods and variables"
      in
      let print_msg ppf =
        if imm then fprintf ppf "This object has virtual %s" missings
        else if cl then fprintf ppf "This class should be virtual"
        else fprintf ppf "This class type should be virtual"
      in
      fprintf ppf
        "@[%t.@ @[<2>The following %s are undefined :%a@]@]"
        print_msg missings print_mets (mets @ vals)
  | Parameter_arity_mismatch(lid, expected, provided) ->
      fprintf ppf
        "@[The class constructor %a@ expects %i type argument(s),@ \
           but is here applied to %i type argument(s)@]"
        Printtyp.longident lid expected provided
  | Parameter_mismatch trace ->
      Printtyp.report_unification_error ppf env trace
        (function ppf ->
           fprintf ppf "The type parameter")
        (function ppf ->
           fprintf ppf "does not meet its constraint: it should be")
  | Bad_parameters (id, params, cstrs) ->
      Printtyp.reset_and_mark_loops_list [params; cstrs];
      fprintf ppf
        "@[The abbreviation %a@ is used with parameters@ %a@ \
           wich are incompatible with constraints@ %a@]"
        Printtyp.ident id Printtyp.type_expr params Printtyp.type_expr cstrs
  | Class_match_failure error ->
      Includeclass.report_error ppf error
  | Unbound_val lab ->
      fprintf ppf "Unbound instance variable %s" lab
  | Unbound_type_var (printer, reason) ->
      let print_common ppf kind ty0 real lab ty =
        let ty1 =
          if real then ty0 else Btype.newgenty(Tobject(ty0, ref None)) in
        Printtyp.mark_loops ty1;
        fprintf ppf
          "The %s %s@ has type@;<1 2>%a@ where@ %a@ is unbound"
            kind lab Printtyp.type_expr ty Printtyp.type_expr ty0
      in
      let print_reason ppf = function
      | Ctype.CC_Method (ty0, real, lab, ty) ->
          print_common ppf "method" ty0 real lab ty
      | Ctype.CC_Value (ty0, real, lab, ty) ->
          print_common ppf "instance variable" ty0 real lab ty
      in
      Printtyp.reset ();
      fprintf ppf
        "@[<v>@[Some type variables are unbound in this type:@;<1 2>%t@]@ \
              @[%a@]@]"
       printer print_reason reason
  | Make_nongen_seltype ty ->
      fprintf ppf
        "@[<v>@[Self type should not occur in the non-generic type@;<1 2>\
                %a@]@,\
           It would escape the scope of its class@]"
        Printtyp.type_scheme ty
  | Non_generalizable_class (id, clty) ->
      fprintf ppf
        "@[The type of this class,@ %a,@ \
           contains type variables that cannot be generalized@]"
        (Printtyp.class_declaration id) clty
  | Cannot_coerce_self ty ->
      fprintf ppf
        "@[The type of self cannot be coerced to@ \
           the type of the current class:@ %a.@.\
           Some occurrences are contravariant@]"
        Printtyp.type_scheme ty
  | Non_collapsable_conjunction (id, clty, trace) ->
      fprintf ppf
        "@[The type of this class,@ %a,@ \
           contains non-collapsible conjunctive types in constraints@]"
        (Printtyp.class_declaration id) clty;
      Printtyp.report_unification_error ppf env trace
        (fun ppf -> fprintf ppf "Type")
        (fun ppf -> fprintf ppf "is not compatible with type")
  | Final_self_clash trace ->
      Printtyp.report_unification_error ppf env trace
        (function ppf ->
           fprintf ppf "This object is expected to have type")
        (function ppf ->
           fprintf ppf "but actually has type")
  | Mutability_mismatch (lab, mut) ->
      let mut1, mut2 =
        if mut = Immutable then "mutable", "immutable"
        else "immutable", "mutable" in
      fprintf ppf
        "@[The instance variable is %s;@ it cannot be redefined as %s@]"
        mut1 mut2
  | No_overriding (_, "") ->
      fprintf ppf "@[This inheritance does not override any method@ %s@]"
        "instance variable"
  | No_overriding (kind, name) ->
      fprintf ppf "@[The %s `%s'@ has no previous definition@]" kind name
  | Duplicate (kind, name) ->
      fprintf ppf "@[The %s `%s'@ has multiple definitions in this object@]"
                    kind name

let report_error env ppf err =
  Printtyp.wrap_printing_env env (fun () -> report_error env ppf err)

let () =
  Location.register_error_of_exn
    (function
      | Error (loc, env, err) ->
        Some (Location.error_of_printer loc (report_error env) err)
      | Error_forward err ->
        Some err
      | _ ->
        None
    )

end
module Typemod : sig 
#1 "typemod.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Type-checking of the module language *)

open Types
open Format

val type_module:
        Env.t -> Parsetree.module_expr -> Typedtree.module_expr
val type_structure:
        Env.t -> Parsetree.structure -> Location.t ->
         Typedtree.structure * Types.signature * Env.t
val type_toplevel_phrase:
        Env.t -> Parsetree.structure ->
         Typedtree.structure * Types.signature * Env.t
val type_implementation_more:
  string -> string -> string -> Env.t -> Parsetree.structure ->
  Typedtree.structure * Typedtree.module_coercion * Env.t * Types.signature

val type_implementation:
  string -> string -> string -> Env.t -> Parsetree.structure ->
  Typedtree.structure * Typedtree.module_coercion

val type_interface:
        Env.t -> Parsetree.signature -> Typedtree.signature
val transl_signature:
        Env.t -> Parsetree.signature -> Typedtree.signature
val check_nongen_schemes:
        Env.t -> Typedtree.structure_item list -> unit
val type_open_:
        ?toplevel:bool -> Asttypes.override_flag ->
        Env.t -> Location.t -> Longident.t Asttypes.loc -> Path.t * Env.t
val modtype_of_package:
        Env.t -> Location.t ->
        Path.t -> Longident.t list -> type_expr list -> module_type
val simplify_signature: signature -> signature

val path_of_module : Typedtree.module_expr -> Path.t option

val save_signature:
  string -> Typedtree.signature -> string -> string ->
  Env.t -> Types.signature_item list -> unit

val package_units:
  Env.t -> string list -> string -> string -> Typedtree.module_coercion

type error =
    Cannot_apply of module_type
  | Not_included of Includemod.error list
  | Cannot_eliminate_dependency of module_type
  | Signature_expected
  | Structure_expected of module_type
  | With_no_component of Longident.t
  | With_mismatch of Longident.t * Includemod.error list
  | Repeated_name of string * string
  | Non_generalizable of type_expr
  | Non_generalizable_class of Ident.t * class_declaration
  | Non_generalizable_module of module_type
  | Implementation_is_required of string
  | Interface_not_compiled of string
  | Not_allowed_in_functor_body
  | With_need_typeconstr
  | Not_a_packed_module of type_expr
  | Incomplete_packed_module of type_expr
  | Scoping_pack of Longident.t * type_expr
  | Recursive_module_require_explicit_type
  | Apply_generative

exception Error of Location.t * Env.t * error
exception Error_forward of Location.error

val report_error: Env.t -> formatter -> error -> unit

end = struct
#1 "typemod.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Misc
open Longident
open Path
open Asttypes
open Parsetree
open Types
open Format

type error =
    Cannot_apply of module_type
  | Not_included of Includemod.error list
  | Cannot_eliminate_dependency of module_type
  | Signature_expected
  | Structure_expected of module_type
  | With_no_component of Longident.t
  | With_mismatch of Longident.t * Includemod.error list
  | Repeated_name of string * string
  | Non_generalizable of type_expr
  | Non_generalizable_class of Ident.t * class_declaration
  | Non_generalizable_module of module_type
  | Implementation_is_required of string
  | Interface_not_compiled of string
  | Not_allowed_in_functor_body
  | With_need_typeconstr
  | Not_a_packed_module of type_expr
  | Incomplete_packed_module of type_expr
  | Scoping_pack of Longident.t * type_expr
  | Recursive_module_require_explicit_type
  | Apply_generative

exception Error of Location.t * Env.t * error
exception Error_forward of Location.error

open Typedtree

let fst3 (x,_,_) = x

let rec path_concat head p =
  match p with
    Pident tail -> Pdot (Pident head, Ident.name tail, 0)
  | Pdot (pre, s, pos) -> Pdot (path_concat head pre, s, pos)
  | Papply _ -> assert false

(* Extract a signature from a module type *)

let extract_sig env loc mty =
  match Env.scrape_alias env mty with
    Mty_signature sg -> sg
  | _ -> raise(Error(loc, env, Signature_expected))

let extract_sig_open env loc mty =
  match Env.scrape_alias env mty with
    Mty_signature sg -> sg
  | _ -> raise(Error(loc, env, Structure_expected mty))

(* Compute the environment after opening a module *)

let type_open_ ?toplevel ovf env loc lid =
  let path, md = Typetexp.find_module env lid.loc lid.txt in
  let sg = extract_sig_open env lid.loc md.md_type in
  path, Env.open_signature ~loc ?toplevel ovf path sg env

let type_open ?toplevel env sod =
  let (path, newenv) =
    type_open_ ?toplevel sod.popen_override env sod.popen_loc sod.popen_lid
  in
  let od =
    {
      open_override = sod.popen_override;
      open_path = path;
      open_txt = sod.popen_lid;
      open_attributes = sod.popen_attributes;
      open_loc = sod.popen_loc;
    }
  in
  (path, newenv, od)

(* Record a module type *)
let rm node =
  Stypes.record (Stypes.Ti_mod node);
  node

(* Forward declaration, to be filled in by type_module_type_of *)
let type_module_type_of_fwd :
    (Env.t -> Parsetree.module_expr ->
      Typedtree.module_expr * Types.module_type) ref
  = ref (fun env m -> assert false)

(* Merge one "with" constraint in a signature *)

let rec add_rec_types env = function
    Sig_type(id, decl, Trec_next) :: rem ->
      add_rec_types (Env.add_type ~check:true id decl env) rem
  | _ -> env

let check_type_decl env loc id row_id newdecl decl rs rem =
  let env = Env.add_type ~check:true id newdecl env in
  let env =
    match row_id with
    | None -> env
    | Some id -> Env.add_type ~check:true id newdecl env
  in
  let env = if rs = Trec_not then env else add_rec_types env rem in
  Includemod.type_declarations env id newdecl decl;
  Typedecl.check_coherence env loc id newdecl

let rec make_params n = function
    [] -> []
  | _ :: l -> ("a" ^ string_of_int n) :: make_params (n+1) l

let update_rec_next rs rem =
  match rs with
    Trec_next -> rem
  | Trec_first | Trec_not ->
      match rem with
        Sig_type (id, decl, Trec_next) :: rem ->
          Sig_type (id, decl, rs) :: rem
      | Sig_module (id, mty, Trec_next) :: rem ->
          Sig_module (id, mty, rs) :: rem
      | _ -> rem

let sig_item desc typ env loc = {
  Typedtree.sig_desc = desc; sig_loc = loc; sig_env = env
}

let make p n i =
  let open Variance in
  set May_pos p (set May_neg n (set May_weak n (set Inj i null)))

let merge_constraint initial_env loc sg constr =
  let lid =
    match constr with
    | Pwith_type (lid, _) | Pwith_module (lid, _) -> lid
    | Pwith_typesubst {ptype_name=s} | Pwith_modsubst (s, _) ->
        {loc = s.loc; txt=Lident s.txt}
  in
  let real_id = ref None in
  let rec merge env sg namelist row_id =
    match (sg, namelist, constr) with
      ([], _, _) ->
        raise(Error(loc, env, With_no_component lid.txt))
    | (Sig_type(id, decl, rs) :: rem, [s],
       Pwith_type (_, ({ptype_kind = Ptype_abstract} as sdecl)))
      when Ident.name id = s && Typedecl.is_fixed_type sdecl ->
        let decl_row =
          { type_params =
              List.map (fun _ -> Btype.newgenvar()) sdecl.ptype_params;
            type_arity = List.length sdecl.ptype_params;
            type_kind = Type_abstract;
            type_private = Private;
            type_manifest = None;
            type_variance =
              List.map
                (fun (_, v) ->
                   let (c, n) =
                     match v with
                     | Covariant -> true, false
                     | Contravariant -> false, true
                     | Invariant -> false, false
                   in
                   make (not n) (not c) false
                )
                sdecl.ptype_params;
            type_loc = sdecl.ptype_loc;
            type_newtype_level = None;
            type_attributes = [];
          }
        and id_row = Ident.create (s^"#row") in
        let initial_env =
          Env.add_type ~check:true id_row decl_row initial_env
        in
        let tdecl = Typedecl.transl_with_constraint
                        initial_env id (Some(Pident id_row)) decl sdecl in
        let newdecl = tdecl.typ_type in
        check_type_decl env sdecl.ptype_loc id row_id newdecl decl rs rem;
        let decl_row = {decl_row with type_params = newdecl.type_params} in
        let rs' = if rs = Trec_first then Trec_not else rs in
        (Pident id, lid, Twith_type tdecl),
        Sig_type(id_row, decl_row, rs') :: Sig_type(id, newdecl, rs) :: rem
    | (Sig_type(id, decl, rs) :: rem , [s], Pwith_type (_, sdecl))
      when Ident.name id = s ->
        let tdecl =
          Typedecl.transl_with_constraint initial_env id None decl sdecl in
        let newdecl = tdecl.typ_type in
        check_type_decl env sdecl.ptype_loc id row_id newdecl decl rs rem;
        (Pident id, lid, Twith_type tdecl), Sig_type(id, newdecl, rs) :: rem
    | (Sig_type(id, decl, rs) :: rem, [s], (Pwith_type _ | Pwith_typesubst _))
      when Ident.name id = s ^ "#row" ->
        merge env rem namelist (Some id)
    | (Sig_type(id, decl, rs) :: rem, [s], Pwith_typesubst sdecl)
      when Ident.name id = s ->
        (* Check as for a normal with constraint, but discard definition *)
        let tdecl =
          Typedecl.transl_with_constraint initial_env id None decl sdecl in
        let newdecl = tdecl.typ_type in
        check_type_decl env sdecl.ptype_loc id row_id newdecl decl rs rem;
        real_id := Some id;
        (Pident id, lid, Twith_typesubst tdecl),
        update_rec_next rs rem
    | (Sig_module(id, md, rs) :: rem, [s], Pwith_module (_, lid'))
      when Ident.name id = s ->
        let path, md' = Typetexp.find_module initial_env loc lid'.txt in
        let md'' = {md' with md_type = Mtype.remove_aliases env md'.md_type} in
        let newmd = Mtype.strengthen_decl env md'' path in
        ignore(Includemod.modtypes env newmd.md_type md.md_type);
        (Pident id, lid, Twith_module (path, lid')),
        Sig_module(id, newmd, rs) :: rem
    | (Sig_module(id, md, rs) :: rem, [s], Pwith_modsubst (_, lid'))
      when Ident.name id = s ->
        let path, md' = Typetexp.find_module initial_env loc lid'.txt in
        let newmd = Mtype.strengthen_decl env md' path in
        ignore(Includemod.modtypes env newmd.md_type md.md_type);
        real_id := Some id;
        (Pident id, lid, Twith_modsubst (path, lid')),
        update_rec_next rs rem
    | (Sig_module(id, md, rs) :: rem, s :: namelist, _)
      when Ident.name id = s ->
        let ((path, path_loc, tcstr), newsg) =
          merge env (extract_sig env loc md.md_type) namelist None in
        (path_concat id path, lid, tcstr),
        Sig_module(id, {md with md_type=Mty_signature newsg}, rs) :: rem
    | (item :: rem, _, _) ->
        let (cstr, items) = merge (Env.add_item item env) rem namelist row_id
        in
        cstr, item :: items
  in
  try
    let names = Longident.flatten lid.txt in
    let (tcstr, sg) = merge initial_env sg names None in
    let sg =
    match names, constr with
      [s], Pwith_typesubst sdecl ->
        let id =
          match !real_id with None -> assert false | Some id -> id in
        let lid =
          try match sdecl.ptype_manifest with
          | Some {ptyp_desc = Ptyp_constr (lid, stl)}
            when List.length stl = List.length sdecl.ptype_params ->
              List.iter2 (fun x (y, _) ->
                match x, y with
                  {ptyp_desc=Ptyp_var sx}, {ptyp_desc=Ptyp_var sy}
                    when sx = sy -> ()
                | _, _ -> raise Exit)
                stl sdecl.ptype_params;
              lid
          | _ -> raise Exit
          with Exit ->
            raise(Error(sdecl.ptype_loc, initial_env, With_need_typeconstr))
        in
        let (path, _) =
          try Env.lookup_type lid.txt initial_env with Not_found -> assert false
        in
        let sub = Subst.add_type id path Subst.identity in
        Subst.signature sub sg
    | [s], Pwith_modsubst (_, lid) ->
        let id =
          match !real_id with None -> assert false | Some id -> id in
        let path = Typetexp.lookup_module initial_env loc lid.txt in
        let sub = Subst.add_module id path Subst.identity in
        Subst.signature sub sg
    | _ ->
          sg
    in
    (tcstr, sg)
  with Includemod.Error explanation ->
    raise(Error(loc, initial_env, With_mismatch(lid.txt, explanation)))

(* Add recursion flags on declarations arising from a mutually recursive
   block. *)

let map_rec fn decls rem =
  match decls with
  | [] -> rem
  | d1 :: dl -> fn Trec_first d1 :: map_end (fn Trec_next) dl rem

let map_rec_type ~rec_flag fn decls rem =
  match decls with
  | [] -> rem
  | d1 :: dl ->
      let first =
        match rec_flag with
        | Recursive -> Trec_first
        | Nonrecursive -> Trec_not
      in
      fn first d1 :: map_end (fn Trec_next) dl rem

let rec map_rec_type_with_row_types ~rec_flag fn decls rem =
  match decls with
  | [] -> rem
  | d1 :: dl ->
      if Btype.is_row_name (Ident.name d1.typ_id) then
        fn Trec_not d1 :: map_rec_type_with_row_types ~rec_flag fn dl rem
      else
        map_rec_type ~rec_flag fn decls rem

let rec_flag_of_ptype_declarations tds =
  let is_nonrec =
    List.exists
      (fun td ->
         List.exists (fun (n, _) -> n.txt = "nonrec")
           td.ptype_attributes)
      tds
  in
  if is_nonrec then Nonrecursive else Recursive

(* Add type extension flags to extension contructors *)
let map_ext fn exts rem =
  match exts with
  | [] -> rem
  | d1 :: dl -> fn Text_first d1 :: map_end (fn Text_next) dl rem

(* Auxiliary for translating recursively-defined module types.
   Return a module type that approximates the shape of the given module
   type AST.  Retain only module, type, and module type
   components of signatures.  For types, retain only their arity,
   making them abstract otherwise. *)

let rec approx_modtype env smty =
  match smty.pmty_desc with
    Pmty_ident lid ->
      let (path, info) = Typetexp.find_modtype env smty.pmty_loc lid.txt in
      Mty_ident path
  | Pmty_alias lid ->
      let path = Typetexp.lookup_module env smty.pmty_loc lid.txt in
      Mty_alias path
  | Pmty_signature ssg ->
      Mty_signature(approx_sig env ssg)
  | Pmty_functor(param, sarg, sres) ->
      let arg = may_map (approx_modtype env) sarg in
      let (id, newenv) =
        Env.enter_module ~arg:true param.txt (Btype.default_mty arg) env in
      let res = approx_modtype newenv sres in
      Mty_functor(id, arg, res)
  | Pmty_with(sbody, constraints) ->
      approx_modtype env sbody
  | Pmty_typeof smod ->
      let (_, mty) = !type_module_type_of_fwd env smod in
      mty
  | Pmty_extension ext ->
      raise (Error_forward (Typetexp.error_of_extension ext))

and approx_module_declaration env pmd =
  {
    Types.md_type = approx_modtype env pmd.pmd_type;
    md_attributes = pmd.pmd_attributes;
    md_loc = pmd.pmd_loc;
  }

and approx_sig env ssg =
  match ssg with
    [] -> []
  | item :: srem ->
      match item.psig_desc with
      | Psig_type sdecls ->
          let rec_flag = rec_flag_of_ptype_declarations sdecls in
          let decls = Typedecl.approx_type_decl env sdecls in
          let rem = approx_sig env srem in
          map_rec_type ~rec_flag
            (fun rs (id, info) -> Sig_type(id, info, rs)) decls rem
      | Psig_module pmd ->
          let md = approx_module_declaration env pmd in
          let (id, newenv) =
            Env.enter_module_declaration pmd.pmd_name.txt md env
          in
          Sig_module(id, md, Trec_not) :: approx_sig newenv srem
      | Psig_recmodule sdecls ->
          let decls =
            List.map
              (fun pmd ->
                 (Ident.create pmd.pmd_name.txt,
                  approx_module_declaration env pmd)
              )
              sdecls
          in
          let newenv =
            List.fold_left
              (fun env (id, md) -> Env.add_module_declaration id md env)
              env decls in
          map_rec (fun rs (id, md) -> Sig_module(id, md, rs)) decls
                  (approx_sig newenv srem)
      | Psig_modtype d ->
          let info = approx_modtype_info env d in
          let (id, newenv) = Env.enter_modtype d.pmtd_name.txt info env in
          Sig_modtype(id, info) :: approx_sig newenv srem
      | Psig_open sod ->
          let (path, mty, _od) = type_open env sod in
          approx_sig mty srem
      | Psig_include sincl ->
          let smty = sincl.pincl_mod in
          let mty = approx_modtype env smty in
          let sg = Subst.signature Subst.identity
                     (extract_sig env smty.pmty_loc mty) in
          let newenv = Env.add_signature sg env in
          sg @ approx_sig newenv srem
      | Psig_class sdecls | Psig_class_type sdecls ->
          let decls = Typeclass.approx_class_declarations env sdecls in
          let rem = approx_sig env srem in
          List.flatten
            (map_rec
              (fun rs (i1, _, d1, i2, d2, i3, d3, _) ->
                [Sig_class_type(i1, d1, rs);
                 Sig_type(i2, d2, rs);
                 Sig_type(i3, d3, rs)])
              decls [rem])
      | _ ->
          approx_sig env srem

and approx_modtype_info env sinfo =
  {
   mtd_type = may_map (approx_modtype env) sinfo.pmtd_type;
   mtd_attributes = sinfo.pmtd_attributes;
   mtd_loc = sinfo.pmtd_loc;
  }

(* Additional validity checks on type definitions arising from
   recursive modules *)

let check_recmod_typedecls env sdecls decls =
  let recmod_ids = List.map fst3 decls in
  List.iter2
    (fun pmd (id, _, mty) ->
       let mty = mty.mty_type in
      List.iter
        (fun path ->
          Typedecl.check_recmod_typedecl env pmd.pmd_type.pmty_loc recmod_ids
                                         path (Env.find_type path env))
        (Mtype.type_paths env (Pident id) mty))
    sdecls decls

(* Auxiliaries for checking uniqueness of names in signatures and structures *)

module StringSet =
  Set.Make(struct type t = string let compare (x:t) y = compare x y end)

let check cl loc set_ref name =
  if StringSet.mem name !set_ref
  then raise(Error(loc, Env.empty, Repeated_name(cl, name)))
  else set_ref := StringSet.add name !set_ref

let check_name cl set_ref name =
  check cl name.loc set_ref name.txt

let check_sig_item type_names module_names modtype_names loc = function
    Sig_type(id, _, _) ->
      check "type" loc type_names (Ident.name id)
  | Sig_module(id, _, _) ->
      check "module" loc module_names (Ident.name id)
  | Sig_modtype(id, _) ->
      check "module type" loc modtype_names (Ident.name id)
  | _ -> ()

let rec remove_duplicates val_ids ext_ids = function
    [] -> []
  | Sig_value (id, _) :: rem
    when List.exists (Ident.equal id) val_ids ->
      remove_duplicates val_ids ext_ids rem
  | Sig_typext (id, _, Text_first) :: Sig_typext (id2, ext2, Text_next) :: rem
    when List.exists (Ident.equal id) ext_ids ->
      (* #6510 *)
      remove_duplicates val_ids ext_ids
        (Sig_typext (id2, ext2, Text_first) :: rem)
  | Sig_typext (id, _, _) :: rem
    when List.exists (Ident.equal id) ext_ids ->
      remove_duplicates val_ids ext_ids rem
  | f :: rem -> f :: remove_duplicates val_ids ext_ids rem

let rec get_values = function
    [] -> []
  | Sig_value (id, _) :: rem -> id :: get_values rem
  | f :: rem -> get_values rem

let rec get_extension_constructors = function
    [] -> []
  | Sig_typext (id, _, _) :: rem -> id :: get_extension_constructors rem
  | f :: rem -> get_extension_constructors rem

(* Check and translate a module type expression *)

let transl_modtype_longident loc env lid =
  let (path, info) = Typetexp.find_modtype env loc lid in
  path

let transl_module_alias loc env lid =
  Typetexp.lookup_module env loc lid

let mkmty desc typ env loc attrs =
  let mty = {
    mty_desc = desc;
    mty_type = typ;
    mty_loc = loc;
    mty_env = env;
    mty_attributes = attrs;
    } in
  Cmt_format.add_saved_type (Cmt_format.Partial_module_type mty);
  mty

let mksig desc env loc =
  let sg = { sig_desc = desc; sig_loc = loc; sig_env = env } in
  Cmt_format.add_saved_type (Cmt_format.Partial_signature_item sg);
  sg

(* let signature sg = List.map (fun item -> item.sig_type) sg *)

let rec transl_modtype env smty =
  let loc = smty.pmty_loc in
  match smty.pmty_desc with
    Pmty_ident lid ->
      let path = transl_modtype_longident loc env lid.txt in
      mkmty (Tmty_ident (path, lid)) (Mty_ident path) env loc
        smty.pmty_attributes
  | Pmty_alias lid ->
      let path = transl_module_alias loc env lid.txt in
      mkmty (Tmty_alias (path, lid)) (Mty_alias path) env loc
        smty.pmty_attributes
  | Pmty_signature ssg ->
      let sg = transl_signature env ssg in
      mkmty (Tmty_signature sg) (Mty_signature sg.sig_type) env loc
        smty.pmty_attributes
  | Pmty_functor(param, sarg, sres) ->
      let arg = Misc.may_map (transl_modtype env) sarg in
      let ty_arg = Misc.may_map (fun m -> m.mty_type) arg in
      let (id, newenv) =
        Env.enter_module ~arg:true param.txt (Btype.default_mty ty_arg) env in
      Ctype.init_def(Ident.current_time()); (* PR#6513 *)
      let res = transl_modtype newenv sres in
      mkmty (Tmty_functor (id, param, arg, res))
      (Mty_functor(id, ty_arg, res.mty_type)) env loc
        smty.pmty_attributes
  | Pmty_with(sbody, constraints) ->
      let body = transl_modtype env sbody in
      let init_sg = extract_sig env sbody.pmty_loc body.mty_type in
      let (rev_tcstrs, final_sg) =
        List.fold_left
          (fun (rev_tcstrs,sg) sdecl ->
            let (tcstr, sg) = merge_constraint env smty.pmty_loc sg sdecl
            in
            (tcstr :: rev_tcstrs, sg)
        )
        ([],init_sg) constraints in
      mkmty (Tmty_with ( body, List.rev rev_tcstrs))
        (Mtype.freshen (Mty_signature final_sg)) env loc
        smty.pmty_attributes
  | Pmty_typeof smod ->
      let tmty, mty = !type_module_type_of_fwd env smod in
      mkmty (Tmty_typeof tmty) mty env loc smty.pmty_attributes
  | Pmty_extension ext ->
      raise (Error_forward (Typetexp.error_of_extension ext))


and transl_signature env sg =
  let type_names = ref StringSet.empty
  and module_names = ref StringSet.empty
  and modtype_names = ref StringSet.empty in
  let rec transl_sig env sg =
    Ctype.init_def(Ident.current_time());
    match sg with
      [] -> [], [], env
    | item :: srem ->
        let loc = item.psig_loc in
        match item.psig_desc with
        | Psig_value sdesc ->
            let (tdesc, newenv) =
              Typedecl.transl_value_decl env item.psig_loc sdesc in
            let (trem,rem, final_env) = transl_sig newenv srem in
            mksig (Tsig_value tdesc) env loc :: trem,
            (if List.exists (Ident.equal tdesc.val_id) (get_values rem) then rem
            else Sig_value(tdesc.val_id, tdesc.val_val) :: rem),
              final_env
        | Psig_type sdecls ->
            let rec_flag = rec_flag_of_ptype_declarations sdecls in
            List.iter
              (fun decl ->
                check_name "type" type_names decl.ptype_name)
              sdecls;
            let (decls, newenv) = Typedecl.transl_type_decl env rec_flag sdecls in
            let (trem, rem, final_env) = transl_sig newenv srem in
            mksig (Tsig_type decls) env loc :: trem,
            map_rec_type_with_row_types ~rec_flag
              (fun rs td -> Sig_type(td.typ_id, td.typ_type, rs)) decls rem,
            final_env
        | Psig_typext styext ->
            let (tyext, newenv) =
              Typedecl.transl_type_extension false env item.psig_loc styext
            in
            let (trem, rem, final_env) = transl_sig newenv srem in
            let constructors =
              List.filter
                (fun ext -> not
                  (List.exists (Ident.equal ext.ext_id)
                               (get_extension_constructors rem)))
                tyext.tyext_constructors
            in
              mksig (Tsig_typext tyext) env loc :: trem,
              map_ext (fun es ext ->
                Sig_typext(ext.ext_id, ext.ext_type, es)) constructors rem,
              final_env
        | Psig_exception sext ->
            let (ext, newenv) = Typedecl.transl_exception env sext in
            let (trem, rem, final_env) = transl_sig newenv srem in
            let shadowed =
              List.exists
                (Ident.equal ext.ext_id)
                (get_extension_constructors rem)
            in
            mksig (Tsig_exception ext) env loc :: trem,
            (if shadowed then rem else
               Sig_typext(ext.ext_id, ext.ext_type, Text_exception) :: rem),
            final_env
        | Psig_module pmd ->
            check_name "module" module_names pmd.pmd_name;
            let tmty = transl_modtype env pmd.pmd_type in
            let md = {
              md_type=tmty.mty_type;
              md_attributes=pmd.pmd_attributes;
              md_loc=pmd.pmd_loc;
            }
            in
            let (id, newenv) =
              Env.enter_module_declaration pmd.pmd_name.txt md env in
            let (trem, rem, final_env) = transl_sig newenv srem in
            mksig (Tsig_module {md_id=id; md_name=pmd.pmd_name; md_type=tmty;
                                md_loc=pmd.pmd_loc;
                                md_attributes=pmd.pmd_attributes})
              env loc :: trem,
            Sig_module(id, md, Trec_not) :: rem,
            final_env
        | Psig_recmodule sdecls ->
            List.iter
              (fun pmd -> check_name "module" module_names pmd.pmd_name)
              sdecls;
            let (decls, newenv) =
              transl_recmodule_modtypes item.psig_loc env sdecls in
            let (trem, rem, final_env) = transl_sig newenv srem in
            mksig (Tsig_recmodule decls) env loc :: trem,
            map_rec (fun rs md ->
                let d = {Types.md_type = md.md_type.mty_type;
                         md_attributes = md.md_attributes;
                         md_loc = md.md_loc;
                        } in
                Sig_module(md.md_id, d, rs))
              decls rem,
            final_env
        | Psig_modtype pmtd ->
            let newenv, mtd, sg =
              transl_modtype_decl modtype_names env item.psig_loc pmtd
            in
            let (trem, rem, final_env) = transl_sig newenv srem in
            mksig (Tsig_modtype mtd) env loc :: trem,
            sg :: rem,
            final_env
        | Psig_open sod ->
            let (path, newenv, od) = type_open env sod in
            let (trem, rem, final_env) = transl_sig newenv srem in
            mksig (Tsig_open od) env loc :: trem,
            rem, final_env
        | Psig_include sincl ->
            let smty = sincl.pincl_mod in
            let tmty = transl_modtype env smty in
            let mty = tmty.mty_type in
            let sg = Subst.signature Subst.identity
                       (extract_sig env smty.pmty_loc mty) in
            List.iter
              (check_sig_item type_names module_names modtype_names
                              item.psig_loc)
              sg;
            let newenv = Env.add_signature sg env in
            let incl =
              { incl_mod = tmty;
                incl_type = sg;
                incl_attributes = sincl.pincl_attributes;
                incl_loc = sincl.pincl_loc;
              }
            in
            let (trem, rem, final_env) = transl_sig newenv srem in
            mksig (Tsig_include incl) env loc :: trem,
            remove_duplicates (get_values rem)
              (get_extension_constructors rem) sg @ rem,
            final_env
        | Psig_class cl ->
            List.iter
              (fun {pci_name = name} -> check_name "type" type_names name)
              cl;
            let (classes, newenv) = Typeclass.class_descriptions env cl in
            let (trem, rem, final_env) = transl_sig newenv srem in
            mksig (Tsig_class
                     (List.map2
                        (fun pcl tcl ->
                          let (_, _, _, _, _, _, _, _, _, _, _, tcl) = tcl in
                          tcl)
                        cl classes)) env loc
            :: trem,
            List.flatten
              (map_rec
                 (fun rs (i, _, d, i', d', i'', d'', i''', d''', _, _, _) ->
                   [Sig_class(i, d, rs);
                    Sig_class_type(i', d', rs);
                    Sig_type(i'', d'', rs);
                    Sig_type(i''', d''', rs)])
                 classes [rem]),
            final_env
        | Psig_class_type cl ->
            List.iter
              (fun {pci_name = name} -> check_name "type" type_names name)
              cl;
            let (classes, newenv) = Typeclass.class_type_declarations env cl in
            let (trem,rem, final_env) = transl_sig newenv srem in
            mksig (Tsig_class_type (List.map2 (fun pcl tcl ->
              let (_, _, _, _, _, _, _, tcl) = tcl in
              tcl
            ) cl classes)) env loc :: trem,
            List.flatten
              (map_rec
                 (fun rs (i, _, d, i', d', i'', d'', _) ->
                   [Sig_class_type(i, d, rs);
                    Sig_type(i', d', rs);
                    Sig_type(i'', d'', rs)])
                 classes [rem]),
            final_env
        | Psig_attribute x ->
            Typetexp.warning_attribute [x];
            let (trem,rem, final_env) = transl_sig env srem in
            mksig (Tsig_attribute x) env loc :: trem, rem, final_env
        | Psig_extension (ext, _attrs) ->
            raise (Error_forward (Typetexp.error_of_extension ext))
  in
  let previous_saved_types = Cmt_format.get_saved_types () in
  Typetexp.warning_enter_scope ();
  let (trem, rem, final_env) = transl_sig (Env.in_signature env) sg in
  let sg = { sig_items = trem; sig_type =  rem; sig_final_env = final_env } in
  Typetexp.warning_leave_scope ();
  Cmt_format.set_saved_types
    ((Cmt_format.Partial_signature sg) :: previous_saved_types);
  sg

and transl_modtype_decl modtype_names env loc
    {pmtd_name; pmtd_type; pmtd_attributes; pmtd_loc} =
  check_name "module type" modtype_names pmtd_name;
  let tmty = Misc.may_map (transl_modtype env) pmtd_type in
  let decl =
    {
     Types.mtd_type=may_map (fun t -> t.mty_type) tmty;
     mtd_attributes=pmtd_attributes;
     mtd_loc=pmtd_loc;
    }
  in
  let (id, newenv) = Env.enter_modtype pmtd_name.txt decl env in
  let mtd =
    {
     mtd_id=id;
     mtd_name=pmtd_name;
     mtd_type=tmty;
     mtd_attributes=pmtd_attributes;
     mtd_loc=pmtd_loc;
    }
  in
  newenv, mtd, Sig_modtype(id, decl)

and transl_recmodule_modtypes loc env sdecls =
  let make_env curr =
    List.fold_left
      (fun env (id, _, mty) -> Env.add_module ~arg:true id mty env)
      env curr in
  let make_env2 curr =
    List.fold_left
      (fun env (id, _, mty) -> Env.add_module ~arg:true id mty.mty_type env)
      env curr in
  let transition env_c curr =
    List.map2
      (fun pmd (id, id_loc, mty) ->
        (id, id_loc, transl_modtype env_c pmd.pmd_type))
      sdecls curr in
  let ids = List.map (fun x -> Ident.create x.pmd_name.txt) sdecls in
  let approx_env =
    (*
       cf #5965
       We use a dummy module type in order to detect a reference to one
       of the module being defined during the call to approx_modtype.
       It will be detected in Env.lookup_module.
    *)
    List.fold_left
      (fun env id ->
         let dummy = Mty_ident (Path.Pident (Ident.create "#recmod#")) in
         Env.add_module ~arg:true id dummy env
      )
      env ids
  in
  let init =
    List.map2
      (fun id pmd ->
        (id, pmd.pmd_name, approx_modtype approx_env pmd.pmd_type))
      ids sdecls
  in
  let env0 = make_env init in
  let dcl1 = transition env0 init in
  let env1 = make_env2 dcl1 in
  check_recmod_typedecls env1 sdecls dcl1;
  let dcl2 = transition env1 dcl1 in
(*
  List.iter
    (fun (id, mty) ->
      Format.printf "%a: %a@." Printtyp.ident id Printtyp.modtype mty)
    dcl2;
*)
  let env2 = make_env2 dcl2 in
  check_recmod_typedecls env2 sdecls dcl2;
  let dcl2 =
    List.map2
      (fun pmd (id, id_loc, mty) ->
        {md_id=id; md_name=id_loc; md_type=mty;
         md_loc=pmd.pmd_loc;
         md_attributes=pmd.pmd_attributes})
      sdecls dcl2
  in
  (dcl2, env2)

(* Simplify multiple specifications of a value or an extension in a signature.
   (Other signature components, e.g. types, modules, etc, are checked for
   name uniqueness.)  If multiple specifications with the same name,
   keep only the last (rightmost) one. *)

let simplify_signature sg =
  let rec aux = function
    | [] -> [], StringSet.empty, StringSet.empty
    | (Sig_value(id, descr) as component) :: sg ->
        let (sg, val_names, ext_names) as k = aux sg in
        let name = Ident.name id in
        if StringSet.mem name val_names then k
        else (component :: sg, StringSet.add name val_names, ext_names)
    | (Sig_typext(id, ext, es) as component) :: sg ->
        let (sg, val_names, ext_names) as k = aux sg in
        let name = Ident.name id in
        if StringSet.mem name ext_names then
          (* #6510 *)
          match es, sg with
          | Text_first, Sig_typext(id2, ext2, Text_next) :: rest ->
              (Sig_typext(id2, ext2, Text_first) :: rest,
               val_names, ext_names)
          | _ -> k
        else
          (component :: sg, val_names, StringSet.add name ext_names)
    | component :: sg ->
        let (sg, val_names, ext_names) = aux sg in
        (component :: sg, val_names, ext_names)
  in
  let (sg, _, _) = aux sg in
  sg

(* Try to convert a module expression to a module path. *)

exception Not_a_path

let rec path_of_module mexp =
  match mexp.mod_desc with
    Tmod_ident (p,_) -> p
  | Tmod_apply(funct, arg, coercion) when !Clflags.applicative_functors ->
      Papply(path_of_module funct, path_of_module arg)
  | Tmod_constraint (mexp, _, _, _) ->
      path_of_module mexp
  | _ -> raise Not_a_path

let path_of_module mexp =
 try Some (path_of_module mexp) with Not_a_path -> None

(* Check that all core type schemes in a structure are closed *)

let rec closed_modtype = function
    Mty_ident p -> true
  | Mty_alias p -> true
  | Mty_signature sg -> List.for_all closed_signature_item sg
  | Mty_functor(id, param, body) -> closed_modtype body

and closed_signature_item = function
    Sig_value(id, desc) -> Ctype.closed_schema desc.val_type
  | Sig_module(id, md, _) -> closed_modtype md.md_type
  | _ -> true

let check_nongen_scheme env str =
  match str.str_desc with
    Tstr_value(rec_flag, pat_exp_list) ->
      List.iter
        (fun {vb_expr=exp} ->
          if not (Ctype.closed_schema exp.exp_type) then
            raise(Error(exp.exp_loc, env, Non_generalizable exp.exp_type)))
        pat_exp_list
  | Tstr_module {mb_expr=md;_} ->
      if not (closed_modtype md.mod_type) then
        raise(Error(md.mod_loc, env, Non_generalizable_module md.mod_type))
  | _ -> ()

let check_nongen_schemes env str =
  List.iter (check_nongen_scheme env) str

(* Helpers for typing recursive modules *)

let anchor_submodule name anchor =
  match anchor with None -> None | Some p -> Some(Pdot(p, name, nopos))
let anchor_recmodule id anchor =
  Some (Pident id)

let enrich_type_decls anchor decls oldenv newenv =
  match anchor with
    None -> newenv
  | Some p ->
      List.fold_left
        (fun e info ->
          let id = info.typ_id in
          let info' =
            Mtype.enrich_typedecl oldenv (Pdot(p, Ident.name id, nopos))
              info.typ_type
          in
            Env.add_type ~check:true id info' e)
        oldenv decls

let enrich_module_type anchor name mty env =
  match anchor with
    None -> mty
  | Some p -> Mtype.enrich_modtype env (Pdot(p, name, nopos)) mty

let check_recmodule_inclusion env bindings =
  (* PR#4450, PR#4470: consider
        module rec X : DECL = MOD  where MOD has inferred type ACTUAL
     The "natural" typing condition
        E, X: ACTUAL |- ACTUAL <: DECL
     leads to circularities through manifest types.
     Instead, we "unroll away" the potential circularities a finite number
     of times.  The (weaker) condition we implement is:
        E, X: DECL,
           X1: ACTUAL,
           X2: ACTUAL{X <- X1}/X1
           ...
           Xn: ACTUAL{X <- X(n-1)}/X(n-1)
        |- ACTUAL{X <- Xn}/Xn <: DECL{X <- Xn}
     so that manifest types rooted at X(n+1) are expanded in terms of X(n),
     avoiding circularities.  The strengthenings ensure that
     Xn.t = X(n-1).t = ... = X2.t = X1.t.
     N can be chosen arbitrarily; larger values of N result in more
     recursive definitions being accepted.  A good choice appears to be
     the number of mutually recursive declarations. *)

  let subst_and_strengthen env s id mty =
    Mtype.strengthen env (Subst.modtype s mty)
                         (Subst.module_path s (Pident id)) in

  let rec check_incl first_time n env s =
    if n > 0 then begin
      (* Generate fresh names Y_i for the rec. bound module idents X_i *)
      let bindings1 =
        List.map
          (fun (id, _, mty_decl, modl, mty_actual, _attrs, _loc) ->
             (id, Ident.rename id, mty_actual))
          bindings in
      (* Enter the Y_i in the environment with their actual types substituted
         by the input substitution s *)
      let env' =
        List.fold_left
          (fun env (id, id', mty_actual) ->
             let mty_actual' =
               if first_time
               then mty_actual
               else subst_and_strengthen env s id mty_actual in
             Env.add_module ~arg:false id' mty_actual' env)
          env bindings1 in
      (* Build the output substitution Y_i <- X_i *)
      let s' =
        List.fold_left
          (fun s (id, id', mty_actual) ->
             Subst.add_module id (Pident id') s)
          Subst.identity bindings1 in
      (* Recurse with env' and s' *)
      check_incl false (n-1) env' s'
    end else begin
      (* Base case: check inclusion of s(mty_actual) in s(mty_decl)
         and insert coercion if needed *)
      let check_inclusion (id, id_loc, mty_decl, modl, mty_actual, attrs, loc) =
        let mty_decl' = Subst.modtype s mty_decl.mty_type
        and mty_actual' = subst_and_strengthen env s id mty_actual in
        let coercion =
          try
            Includemod.modtypes env mty_actual' mty_decl'
          with Includemod.Error msg ->
            raise(Error(modl.mod_loc, env, Not_included msg)) in
        let modl' =
            { mod_desc = Tmod_constraint(modl, mty_decl.mty_type,
                Tmodtype_explicit mty_decl, coercion);
              mod_type = mty_decl.mty_type;
              mod_env = env;
              mod_loc = modl.mod_loc;
              mod_attributes = [];
             } in
        {
         mb_id = id;
         mb_name = id_loc;
         mb_expr = modl';
         mb_attributes = attrs;
         mb_loc = loc;
        }
      in
      List.map check_inclusion bindings
    end
  in check_incl true (List.length bindings) env Subst.identity

(* Helper for unpack *)

let rec package_constraints env loc mty constrs =
  if constrs = [] then mty
  else let sg = extract_sig env loc mty in
  let sg' =
    List.map
      (function
        | Sig_type (id, ({type_params=[]} as td), rs)
          when List.mem_assoc [Ident.name id] constrs ->
            let ty = List.assoc [Ident.name id] constrs in
            Sig_type (id, {td with type_manifest = Some ty}, rs)
        | Sig_module (id, md, rs) ->
            let rec aux = function
              | (m :: ((_ :: _) as l), t) :: rest when m = Ident.name id ->
                  (l, t) :: aux rest
              | _ :: rest -> aux rest
              | [] -> []
            in
            let md =
              {md with
               md_type = package_constraints env loc md.md_type (aux constrs)
              }
            in
            Sig_module (id, md, rs)
        | item -> item
      )
      sg
  in
  Mty_signature sg'

let modtype_of_package env loc p nl tl =
  try match (Env.find_modtype p env).mtd_type with
  | Some mty when nl <> [] ->
      package_constraints env loc mty
        (List.combine (List.map Longident.flatten nl) tl)
  | _ ->
      if nl = [] then Mty_ident p
      else raise(Error(loc, env, Signature_expected))
  with Not_found ->
    let error = Typetexp.Unbound_modtype (Ctype.lid_of_path p) in
    raise(Typetexp.Error(loc, env, error))

let package_subtype env p1 nl1 tl1 p2 nl2 tl2 =
  let mkmty p nl tl =
    let ntl =
      List.filter (fun (n,t) -> Ctype.free_variables t = [])
        (List.combine nl tl) in
    let (nl, tl) = List.split ntl in
    modtype_of_package env Location.none p nl tl
  in
  let mty1 = mkmty p1 nl1 tl1 and mty2 = mkmty p2 nl2 tl2 in
  try Includemod.modtypes env mty1 mty2 = Tcoerce_none
  with Includemod.Error msg -> false
    (* raise(Error(Location.none, env, Not_included msg)) *)

let () = Ctype.package_subtype := package_subtype

let wrap_constraint env arg mty explicit =
  let coercion =
    try
      Includemod.modtypes env arg.mod_type mty
    with Includemod.Error msg ->
      raise(Error(arg.mod_loc, env, Not_included msg)) in
  { mod_desc = Tmod_constraint(arg, mty, explicit, coercion);
    mod_type = mty;
    mod_env = env;
    mod_attributes = [];
    mod_loc = arg.mod_loc }

(* Type a module value expression *)

let rec type_module ?(alias=false) sttn funct_body anchor env smod =
  match smod.pmod_desc with
    Pmod_ident lid ->
      let path =
        Typetexp.lookup_module ~load:(not alias) env smod.pmod_loc lid.txt in
      let md = { mod_desc = Tmod_ident (path, lid);
                 mod_type = Mty_alias path;
                 mod_env = env;
                 mod_attributes = smod.pmod_attributes;
                 mod_loc = smod.pmod_loc } in
      let md =
        if alias && not (Env.is_functor_arg path env) then
          (Env.add_required_global (Path.head path); md)
        else match (Env.find_module path env).md_type with
          Mty_alias p1 when not alias ->
            let p1 = Env.normalize_path (Some smod.pmod_loc) env p1 in
            let mty = Includemod.expand_module_alias env [] p1 in
            { md with
              mod_desc = Tmod_constraint (md, mty, Tmodtype_implicit,
                                          Tcoerce_alias (p1, Tcoerce_none));
              mod_type = if sttn then Mtype.strengthen env mty p1 else mty }
        | mty ->
            let mty =
              if sttn then Mtype.strengthen env mty path else mty in
            { md with mod_type = mty }
      in rm md
  | Pmod_structure sstr ->
      let (str, sg, finalenv) =
        type_structure funct_body anchor env sstr smod.pmod_loc in
      let md =
        rm { mod_desc = Tmod_structure str;
             mod_type = Mty_signature sg;
             mod_env = env;
             mod_attributes = smod.pmod_attributes;
             mod_loc = smod.pmod_loc }
      in
      let sg' = simplify_signature sg in
      if List.length sg' = List.length sg then md else
      wrap_constraint (Env.implicit_coercion env) md (Mty_signature sg')
        Tmodtype_implicit
  | Pmod_functor(name, smty, sbody) ->
      let mty = may_map (transl_modtype env) smty in
      let ty_arg = may_map (fun m -> m.mty_type) mty in
      let (id, newenv), funct_body =
        match ty_arg with None -> (Ident.create "*", env), false
        | Some mty -> Env.enter_module ~arg:true name.txt mty env, true in
      let body = type_module sttn funct_body None newenv sbody in
      rm { mod_desc = Tmod_functor(id, name, mty, body);
           mod_type = Mty_functor(id, ty_arg, body.mod_type);
           mod_env = env;
           mod_attributes = smod.pmod_attributes;
           mod_loc = smod.pmod_loc }
  | Pmod_apply(sfunct, sarg) ->
      let arg = type_module true funct_body None env sarg in
      let path = path_of_module arg in
      let funct =
        type_module (sttn && path <> None) funct_body None env sfunct in
      begin match Env.scrape_alias env funct.mod_type with
        Mty_functor(param, mty_param, mty_res) as mty_functor ->
          let generative, mty_param =
            (mty_param = None, Btype.default_mty mty_param) in
          if generative then begin
            if sarg.pmod_desc <> Pmod_structure [] then
              raise (Error (sfunct.pmod_loc, env, Apply_generative));
            if funct_body && Mtype.contains_type env funct.mod_type then
              raise (Error (smod.pmod_loc, env, Not_allowed_in_functor_body));
          end;
          let coercion =
            try
              Includemod.modtypes env arg.mod_type mty_param
            with Includemod.Error msg ->
              raise(Error(sarg.pmod_loc, env, Not_included msg)) in
          let mty_appl =
            match path with
              Some path ->
                Subst.modtype (Subst.add_module param path Subst.identity)
                              mty_res
            | None ->
                if generative then mty_res else
                try
                  Mtype.nondep_supertype
                    (Env.add_module ~arg:true param arg.mod_type env)
                    param mty_res
                with Not_found ->
                  raise(Error(smod.pmod_loc, env,
                              Cannot_eliminate_dependency mty_functor))
          in
          rm { mod_desc = Tmod_apply(funct, arg, coercion);
               mod_type = mty_appl;
               mod_env = env;
               mod_attributes = smod.pmod_attributes;
               mod_loc = smod.pmod_loc }
      | _ ->
          raise(Error(sfunct.pmod_loc, env, Cannot_apply funct.mod_type))
      end
  | Pmod_constraint(sarg, smty) ->
      let arg = type_module ~alias true funct_body anchor env sarg in
      let mty = transl_modtype env smty in
      rm {(wrap_constraint env arg mty.mty_type (Tmodtype_explicit mty)) with
          mod_loc = smod.pmod_loc;
          mod_attributes = smod.pmod_attributes;
         }

  | Pmod_unpack sexp ->
      if !Clflags.principal then Ctype.begin_def ();
      let exp = Typecore.type_exp env sexp in
      if !Clflags.principal then begin
        Ctype.end_def ();
        Ctype.generalize_structure exp.exp_type
      end;
      let mty =
        match Ctype.expand_head env exp.exp_type with
          {desc = Tpackage (p, nl, tl)} ->
            if List.exists (fun t -> Ctype.free_variables t <> []) tl then
              raise (Error (smod.pmod_loc, env,
                            Incomplete_packed_module exp.exp_type));
            if !Clflags.principal &&
              not (Typecore.generalizable (Btype.generic_level-1) exp.exp_type)
            then
              Location.prerr_warning smod.pmod_loc
                (Warnings.Not_principal "this module unpacking");
            modtype_of_package env smod.pmod_loc p nl tl
        | {desc = Tvar _} ->
            raise (Typecore.Error
                     (smod.pmod_loc, env, Typecore.Cannot_infer_signature))
        | _ ->
            raise (Error(smod.pmod_loc, env, Not_a_packed_module exp.exp_type))
      in
      if funct_body && Mtype.contains_type env mty then
        raise (Error (smod.pmod_loc, env, Not_allowed_in_functor_body));
      rm { mod_desc = Tmod_unpack(exp, mty);
           mod_type = mty;
           mod_env = env;
           mod_attributes = smod.pmod_attributes;
           mod_loc = smod.pmod_loc }
  | Pmod_extension ext ->
      raise (Error_forward (Typetexp.error_of_extension ext))

and type_structure ?(toplevel = false) funct_body anchor env sstr scope =
  let type_names = ref StringSet.empty
  and module_names = ref StringSet.empty
  and modtype_names = ref StringSet.empty in

  let type_str_item env srem {pstr_loc = loc; pstr_desc = desc} =
    match desc with
    | Pstr_eval (sexpr, attrs) ->
        let expr = Typecore.type_expression env sexpr in
        Tstr_eval (expr, attrs), [], env
    | Pstr_value(rec_flag, sdefs) ->
        let scope =
          match rec_flag with
          | Recursive ->
              Some (Annot.Idef {scope with
                                Location.loc_start = loc.Location.loc_start})
          | Nonrecursive ->
              let start =
                match srem with
                | [] -> loc.Location.loc_end
                | {pstr_loc = loc2} :: _ -> loc2.Location.loc_start
              in
              Some (Annot.Idef {scope with Location.loc_start = start})
        in
        let (defs, newenv) =
          Typecore.type_binding env rec_flag sdefs scope in
        (* Note: Env.find_value does not trigger the value_used event. Values
           will be marked as being used during the signature inclusion test. *)
        Tstr_value(rec_flag, defs),
        List.map (fun id -> Sig_value(id, Env.find_value (Pident id) newenv))
          (let_bound_idents defs),
        newenv
    | Pstr_primitive sdesc ->
        let (desc, newenv) = Typedecl.transl_value_decl env loc sdesc in
        Tstr_primitive desc, [Sig_value(desc.val_id, desc.val_val)], newenv
    | Pstr_type sdecls ->
        let rec_flag = rec_flag_of_ptype_declarations sdecls in
        List.iter
          (fun decl -> check_name "type" type_names decl.ptype_name)
          sdecls;
        let (decls, newenv) = Typedecl.transl_type_decl env rec_flag sdecls in
        Tstr_type decls,
        map_rec_type_with_row_types ~rec_flag
          (fun rs info -> Sig_type(info.typ_id, info.typ_type, rs))
          decls [],
        enrich_type_decls anchor decls env newenv
    | Pstr_typext styext ->
        let (tyext, newenv) =
          Typedecl.transl_type_extension true env loc styext
        in
        (Tstr_typext tyext,
         map_ext
           (fun es ext -> Sig_typext(ext.ext_id, ext.ext_type, es))
           tyext.tyext_constructors [],
         newenv)
    | Pstr_exception sext ->
        let (ext, newenv) = Typedecl.transl_exception env sext in
        Tstr_exception ext,
        [Sig_typext(ext.ext_id, ext.ext_type, Text_exception)],
        newenv
    | Pstr_module {pmb_name = name; pmb_expr = smodl; pmb_attributes = attrs;
                   pmb_loc;
                  } ->
        check_name "module" module_names name;
        let modl =
          type_module ~alias:true true funct_body
            (anchor_submodule name.txt anchor) env smodl in
        let md =
          { md_type = enrich_module_type anchor name.txt modl.mod_type env;
            md_attributes = attrs;
            md_loc = pmb_loc;
          }
        in
        let (id, newenv) = Env.enter_module_declaration name.txt md env in
        Tstr_module {mb_id=id; mb_name=name; mb_expr=modl;
                     mb_attributes=attrs;  mb_loc=pmb_loc;
                    },
        [Sig_module(id,
                    {md_type = modl.mod_type;
                     md_attributes = attrs;
                     md_loc = pmb_loc;
                    }, Trec_not)],
        newenv
    | Pstr_recmodule sbind ->
        let sbind =
          List.map
            (function
              | {pmb_name = name;
                 pmb_expr = {pmod_desc=Pmod_constraint(expr, typ)};
                 pmb_attributes = attrs;
                 pmb_loc = loc;
                } ->
                  name, typ, expr, attrs, loc
              | mb ->
                  raise (Error (mb.pmb_expr.pmod_loc, env,
                                Recursive_module_require_explicit_type))
            )
            sbind
        in
        List.iter
          (fun (name, _, _, _, _) -> check_name "module" module_names name)
          sbind;
        let (decls, newenv) =
          transl_recmodule_modtypes loc env
            (List.map (fun (name, smty, smodl, attrs, loc) ->
                 {pmd_name=name; pmd_type=smty;
                  pmd_attributes=attrs; pmd_loc=loc}) sbind
            ) in
        let bindings1 =
          List.map2
            (fun {md_id=id; md_type=mty} (name, _, smodl, attrs, loc) ->
               let modl =
                 type_module true funct_body (anchor_recmodule id anchor) newenv
                   smodl in
               let mty' =
                 enrich_module_type anchor (Ident.name id) modl.mod_type newenv
               in
               (id, name, mty, modl, mty', attrs, loc))
            decls sbind in
        let newenv = (* allow aliasing recursive modules from outside *)
          List.fold_left
            (fun env md ->
               let mdecl =
                 {
                   md_type = md.md_type.mty_type;
                   md_attributes = md.md_attributes;
                   md_loc = md.md_loc;
                 }
               in
               Env.add_module_declaration md.md_id mdecl env
            )
            env decls
        in
        let bindings2 =
          check_recmodule_inclusion newenv bindings1 in
        Tstr_recmodule bindings2,
        map_rec (fun rs mb ->
            Sig_module(mb.mb_id, {
                md_type=mb.mb_expr.mod_type;
                md_attributes=mb.mb_attributes;
                md_loc=mb.mb_loc;
              }, rs))
           bindings2 [],
        newenv
    | Pstr_modtype pmtd ->
        (* check that it is non-abstract *)
        let newenv, mtd, sg =
          transl_modtype_decl modtype_names env loc pmtd
        in
        Tstr_modtype mtd, [sg], newenv
    | Pstr_open sod ->
        let (path, newenv, od) = type_open ~toplevel env sod in
        Tstr_open od, [], newenv
    | Pstr_class cl ->
        List.iter
          (fun {pci_name = name} -> check_name "type" type_names name)
          cl;
        let (classes, new_env) = Typeclass.class_declarations env cl in
        Tstr_class
          (List.map (fun (i, _, d, _,_,_,_,_,_, s, m, c) ->
               let vf = if d.cty_new = None then Virtual else Concrete in
               (* (i, s, m, c, vf) *) (c, m, vf))
              classes),
(* TODO: check with Jacques why this is here
      Tstr_class_type
          (List.map (fun (_,_, i, d, _,_,_,_,_,_,c) -> (i, c)) classes) ::
      Tstr_type
          (List.map (fun (_,_,_,_, i, d, _,_,_,_,_) -> (i, d)) classes) ::
      Tstr_type
          (List.map (fun (_,_,_,_,_,_, i, d, _,_,_) -> (i, d)) classes) ::
*)
        List.flatten
          (map_rec
             (fun rs (i, _, d, i', d', i'', d'', i''', d''', _, _, _) ->
                [Sig_class(i, d, rs);
                 Sig_class_type(i', d', rs);
                 Sig_type(i'', d'', rs);
                 Sig_type(i''', d''', rs)])
             classes []),
        new_env
    | Pstr_class_type cl ->
        List.iter
          (fun {pci_name = name} -> check_name "type" type_names name)
          cl;
        let (classes, new_env) = Typeclass.class_type_declarations env cl in
        Tstr_class_type
          (List.map (fun (i, i_loc, d, _, _, _, _, c) ->
               (i, i_loc, c)) classes),
(*  TODO: check with Jacques why this is here
           Tstr_type
             (List.map (fun (_, _, i, d, _, _) -> (i, d)) classes) ::
           Tstr_type
             (List.map (fun (_, _, _, _, i, d) -> (i, d)) classes) :: *)
        List.flatten
          (map_rec
             (fun rs (i, _, d, i', d', i'', d'', _) ->
                [Sig_class_type(i, d, rs);
                 Sig_type(i', d', rs);
                 Sig_type(i'', d'', rs)])
             classes []),
        new_env
    | Pstr_include sincl ->
        let smodl = sincl.pincl_mod in
        let modl = type_module true funct_body None env smodl in
        (* Rename all identifiers bound by this signature to avoid clashes *)
        let sg = Subst.signature Subst.identity
            (extract_sig_open env smodl.pmod_loc modl.mod_type) in
        let sg =
          match modl.mod_desc with
            Tmod_ident (p, _) when not (Env.is_functor_arg p env) ->
              Env.add_required_global (Path.head p);
              let pos = ref 0 in
              List.map
                (function
                  | Sig_module (id, md, rs) ->
                      let n = !pos in incr pos;
                      Sig_module (id, {md with md_type =
                                       Mty_alias (Pdot(p,Ident.name id,n))},
                                  rs)
                  | Sig_value (_, {val_kind=Val_reg})
                  | Sig_typext _ | Sig_class _ as it ->
                      incr pos; it
                  | Sig_value _ | Sig_type _ | Sig_modtype _
                  | Sig_class_type _ as it ->
                      it)
                sg
          | _ -> sg
        in
        List.iter
          (check_sig_item type_names module_names modtype_names loc) sg;
        let new_env = Env.add_signature sg env in
        let incl =
          { incl_mod = modl;
            incl_type = sg;
            incl_attributes = sincl.pincl_attributes;
            incl_loc = sincl.pincl_loc;
          }
        in
        Tstr_include incl, sg, new_env
    | Pstr_extension (ext, _attrs) ->
        raise (Error_forward (Typetexp.error_of_extension ext))
    | Pstr_attribute x ->
        Typetexp.warning_attribute [x];
        Tstr_attribute x, [], env
  in
  let rec type_struct env sstr =
    Ctype.init_def(Ident.current_time());
    match sstr with
    | [] -> ([], [], env)
    | pstr :: srem ->
        let previous_saved_types = Cmt_format.get_saved_types () in
        let desc, sg, new_env = type_str_item env srem pstr in
        let str = { str_desc = desc; str_loc = pstr.pstr_loc; str_env = env } in
        Cmt_format.set_saved_types (Cmt_format.Partial_structure_item str
                                    :: previous_saved_types);
        let (str_rem, sig_rem, final_env) = type_struct new_env srem in
        (str :: str_rem, sg @ sig_rem, final_env)
  in
  if !Clflags.annotations then
    (* moved to genannot *)
    List.iter (function {pstr_loc = l} -> Stypes.record_phrase l) sstr;
  let previous_saved_types = Cmt_format.get_saved_types () in
  Typetexp.warning_enter_scope ();
  let (items, sg, final_env) = type_struct env sstr in
  let str = { str_items = items; str_type = sg; str_final_env = final_env } in
  Typetexp.warning_leave_scope ();
  Cmt_format.set_saved_types
    (Cmt_format.Partial_structure str :: previous_saved_types);
  str, sg, final_env

let type_toplevel_phrase env s =
  Env.reset_required_globals ();
  type_structure ~toplevel:true false None env s Location.none
(*let type_module_alias = type_module ~alias:true true false None*)
let type_module = type_module true false None
let type_structure = type_structure false None

(* Normalize types in a signature *)

let rec normalize_modtype env = function
    Mty_ident p -> ()
  | Mty_alias p -> ()
  | Mty_signature sg -> normalize_signature env sg
  | Mty_functor(id, param, body) -> normalize_modtype env body

and normalize_signature env = List.iter (normalize_signature_item env)

and normalize_signature_item env = function
    Sig_value(id, desc) -> Ctype.normalize_type env desc.val_type
  | Sig_module(id, md, _) -> normalize_modtype env md.md_type
  | _ -> ()

(* Extract the module type of a module expression *)

let type_module_type_of env smod =
  let tmty =
    match smod.pmod_desc with
    | Pmod_ident lid -> (* turn off strengthening in this case *)
        let path, md = Typetexp.find_module env smod.pmod_loc lid.txt in
        rm { mod_desc = Tmod_ident (path, lid);
             mod_type = md.md_type;
             mod_env = env;
             mod_attributes = smod.pmod_attributes;
             mod_loc = smod.pmod_loc }
    | _ -> type_module env smod in
  let mty = tmty.mod_type in
  (* PR#6307: expand aliases at root and submodules *)
  let mty = Mtype.remove_aliases env mty in
  (* PR#5036: must not contain non-generalized type variables *)
  if not (closed_modtype mty) then
    raise(Error(smod.pmod_loc, env, Non_generalizable_module mty));
  tmty, mty

(* For Typecore *)

let rec get_manifest_types = function
    [] -> []
  | Sig_type (id, {type_params=[]; type_manifest=Some ty}, _) :: rem ->
      (Ident.name id, ty) :: get_manifest_types rem
  | _ :: rem -> get_manifest_types rem

let type_package env m p nl tl =
  (* Same as Pexp_letmodule *)
  (* remember original level *)
  let lv = Ctype.get_current_level () in
  Ctype.begin_def ();
  Ident.set_current_time lv;
  let context = Typetexp.narrow () in
  let modl = type_module env m in
  Ctype.init_def(Ident.current_time());
  Typetexp.widen context;
  let (mp, env) =
    match modl.mod_desc with
      Tmod_ident (mp,_) -> (mp, env)
    | _ ->
      let (id, new_env) = Env.enter_module ~arg:true "%M" modl.mod_type env in
      (Pident id, new_env)
  in
  let rec mkpath mp = function
    | Lident name -> Pdot(mp, name, nopos)
    | Ldot (m, name) -> Pdot(mkpath mp m, name, nopos)
    | _ -> assert false
  in
  let tl' =
    List.map
      (fun name -> Btype.newgenty (Tconstr (mkpath mp name,[],ref Mnil)))
      nl in
  (* go back to original level *)
  Ctype.end_def ();
  if nl = [] then
    (wrap_constraint env modl (Mty_ident p) Tmodtype_implicit, [])
  else let mty = modtype_of_package env modl.mod_loc p nl tl' in
  List.iter2
    (fun n ty ->
      try Ctype.unify env ty (Ctype.newvar ())
      with Ctype.Unify _ ->
        raise (Error(m.pmod_loc, env, Scoping_pack (n,ty))))
    nl tl';
  (wrap_constraint env modl mty Tmodtype_implicit, tl')

(* Fill in the forward declarations *)
let () =
  Typecore.type_module := type_module;
  Typetexp.transl_modtype_longident := transl_modtype_longident;
  Typetexp.transl_modtype := transl_modtype;
  Typecore.type_open := type_open_ ?toplevel:None;
  Typecore.type_package := type_package;
  type_module_type_of_fwd := type_module_type_of


(* Typecheck an implementation file *)

let type_implementation_more sourcefile outputprefix modulename initial_env ast =
  Cmt_format.clear ();
  try
  Typecore.reset_delayed_checks ();
  Env.reset_required_globals ();
  begin
    let map = Typetexp.emit_external_warnings in
    ignore (map.Ast_mapper.structure map ast)
  end;

  let (str, sg, finalenv) =
    type_structure initial_env ast (Location.in_file sourcefile) in
  let simple_sg = simplify_signature sg in
  if !Clflags.print_types then begin
    Printtyp.wrap_printing_env initial_env
      (fun () -> fprintf std_formatter "%a@." Printtyp.signature simple_sg);
    (str, Tcoerce_none,finalenv, simple_sg)   (* result is ignored by Compile.implementation *)
  end else begin
    let sourceintf =
      Misc.chop_extension_if_any sourcefile ^ !Config.interface_suffix in
 
    let mli_status = !Clflags.assume_no_mli in 
    if (mli_status = Clflags.Mli_na && Sys.file_exists sourceintf) || (mli_status = Clflags.Mli_exists) then begin

      let intf_file =
        try
          find_in_path_uncap !Config.load_path (modulename ^ ".cmi")
        with Not_found ->
          raise(Error(Location.in_file sourcefile, Env.empty,
                      Interface_not_compiled sourceintf)) in
      let dclsig = Env.read_signature modulename intf_file in
      let coercion =
        Includemod.compunit initial_env sourcefile sg intf_file dclsig in
      Typecore.force_delayed_checks ();
      (* It is important to run these checks after the inclusion test above,
         so that value declarations which are not used internally but exported
         are not reported as being unused. *)
      Cmt_format.save_cmt (outputprefix ^ ".cmt") modulename
        (Cmt_format.Implementation str) (Some sourcefile) initial_env None;
      (str, coercion, finalenv, dclsig)
        (* identifier is useless might read from serialized cmi files*)
    end else begin
      check_nongen_schemes finalenv str.str_items;
      normalize_signature finalenv simple_sg;
      let coercion =
        Includemod.compunit initial_env sourcefile sg
                            "(inferred signature)" simple_sg in
      Typecore.force_delayed_checks ();
      (* See comment above. Here the target signature contains all
         the value being exported. We can still capture unused
         declarations like "let x = true;; let x = 1;;", because in this
         case, the inferred signature contains only the last declaration. *)
      if not !Clflags.dont_write_files then begin
        let sg =
          Env.save_signature simple_sg modulename (outputprefix ^ ".cmi") in
        Cmt_format.save_cmt  (outputprefix ^ ".cmt") modulename
          (Cmt_format.Implementation str)
          (Some sourcefile) initial_env (Some sg);
      end;
      (str, coercion,finalenv, simple_sg)
    end
    end
  with e ->
    Cmt_format.save_cmt  (outputprefix ^ ".cmt") modulename
      (Cmt_format.Partial_implementation
         (Array.of_list (Cmt_format.get_saved_types ())))
      (Some sourcefile) initial_env None;
    raise e
let type_implementation sourcefile outputprefix modulename initial_env ast =
  let (a,b,_,_) = 
    type_implementation_more sourcefile outputprefix modulename initial_env ast in 
  a,b

let save_signature modname tsg outputprefix source_file initial_env cmi =
  Cmt_format.save_cmt  (outputprefix ^ ".cmti") modname
    (Cmt_format.Interface tsg) (Some source_file) initial_env (Some cmi)

let type_interface env ast =
  begin
    let map = Typetexp.emit_external_warnings in
    ignore (map.Ast_mapper.signature map ast)
  end;
  transl_signature env ast

(* "Packaging" of several compilation units into one unit
   having them as sub-modules.  *)

let rec package_signatures subst = function
    [] -> []
  | (name, sg) :: rem ->
      let sg' = Subst.signature subst sg in
      let oldid = Ident.create_persistent name
      and newid = Ident.create name in
      Sig_module(newid, {md_type=Mty_signature sg';
                         md_attributes=[];
                         md_loc=Location.none;
                        },
                 Trec_not) ::
      package_signatures (Subst.add_module oldid (Pident newid) subst) rem

let package_units initial_env objfiles cmifile modulename =
  (* Read the signatures of the units *)
  let units =
    List.map
      (fun f ->
         let pref = chop_extensions f in
         let modname = String.capitalize(Filename.basename pref) in
         let sg = Env.read_signature modname (pref ^ ".cmi") in
         if Filename.check_suffix f ".cmi" &&
            not(Mtype.no_code_needed_sig Env.initial_safe_string sg)
         then raise(Error(Location.none, Env.empty,
                          Implementation_is_required f));
         (modname, Env.read_signature modname (pref ^ ".cmi")))
      objfiles in
  (* Compute signature of packaged unit *)
  Ident.reinit();
  let sg = package_signatures Subst.identity units in
  (* See if explicit interface is provided *)
  let prefix = chop_extension_if_any cmifile in
  let mlifile = prefix ^ !Config.interface_suffix in

  let mli_status = !Clflags.assume_no_mli in 
  if (mli_status = Clflags.Mli_na && Sys.file_exists mlifile) || (mli_status = Clflags.Mli_exists) then begin

    if not (Sys.file_exists cmifile) then begin
      raise(Error(Location.in_file mlifile, Env.empty,
                  Interface_not_compiled mlifile))
    end;
    let dclsig = Env.read_signature modulename cmifile in
    Cmt_format.save_cmt  (prefix ^ ".cmt") modulename
      (Cmt_format.Packed (sg, objfiles)) None initial_env  None ;
    Includemod.compunit initial_env "(obtained by packing)" sg mlifile dclsig
  end else begin
    (* Determine imports *)
    let unit_names = List.map fst units in
    let imports =
      List.filter
        (fun (name, crc) -> not (List.mem name unit_names))
        (Env.imports()) in
    (* Write packaged signature *)
    if not !Clflags.dont_write_files then begin
      let sg =
        Env.save_signature_with_imports sg modulename
          (prefix ^ ".cmi") imports in
      Cmt_format.save_cmt (prefix ^ ".cmt")  modulename
        (Cmt_format.Packed (sg, objfiles)) None initial_env (Some sg)
    end;
    Tcoerce_none
  end

(* Error report *)

open Printtyp

let report_error ppf = function
    Cannot_apply mty ->
      fprintf ppf
        "@[This module is not a functor; it has type@ %a@]" modtype mty
  | Not_included errs ->
      fprintf ppf
        "@[<v>Signature mismatch:@ %a@]" Includemod.report_error errs
  | Cannot_eliminate_dependency mty ->
      fprintf ppf
        "@[This functor has type@ %a@ \
           The parameter cannot be eliminated in the result type.@  \
           Please bind the argument to a module identifier.@]" modtype mty
  | Signature_expected -> fprintf ppf "This module type is not a signature"
  | Structure_expected mty ->
      fprintf ppf
        "@[This module is not a structure; it has type@ %a" modtype mty
  | With_no_component lid ->
      fprintf ppf
        "@[The signature constrained by `with' has no component named %a@]"
        longident lid
  | With_mismatch(lid, explanation) ->
      fprintf ppf
        "@[<v>\
           @[In this `with' constraint, the new definition of %a@ \
             does not match its original definition@ \
             in the constrained signature:@]@ \
           %a@]"
        longident lid Includemod.report_error explanation
  | Repeated_name(kind, name) ->
      fprintf ppf
        "@[Multiple definition of the %s name %s.@ \
           Names must be unique in a given structure or signature.@]" kind name
  | Non_generalizable typ ->
      fprintf ppf
        "@[The type of this expression,@ %a,@ \
           contains type variables that cannot be generalized@]" type_scheme typ
  | Non_generalizable_class (id, desc) ->
      fprintf ppf
        "@[The type of this class,@ %a,@ \
           contains type variables that cannot be generalized@]"
        (class_declaration id) desc
  | Non_generalizable_module mty ->
      fprintf ppf
        "@[The type of this module,@ %a,@ \
           contains type variables that cannot be generalized@]" modtype mty
  | Implementation_is_required intf_name ->
      fprintf ppf
        "@[The interface %a@ declares values, not just types.@ \
           An implementation must be provided.@]"
        Location.print_filename intf_name
  | Interface_not_compiled intf_name ->
      fprintf ppf
        "@[Could not find the .cmi file for interface@ %a.@]"
        Location.print_filename intf_name
  | Not_allowed_in_functor_body ->
      fprintf ppf
        "@[This expression creates fresh types.@ %s@]"
        "It is not allowed inside applicative functors."
  | With_need_typeconstr ->
      fprintf ppf
        "Only type constructors with identical parameters can be substituted."
  | Not_a_packed_module ty ->
      fprintf ppf
        "This expression is not a packed module. It has type@ %a"
        type_expr ty
  | Incomplete_packed_module ty ->
      fprintf ppf
        "The type of this packed module contains variables:@ %a"
        type_expr ty
  | Scoping_pack (lid, ty) ->
      fprintf ppf
        "The type %a in this module cannot be exported.@ " longident lid;
      fprintf ppf
        "Its type contains local dependencies:@ %a" type_expr ty
  | Recursive_module_require_explicit_type ->
      fprintf ppf "Recursive modules require an explicit module type."
  | Apply_generative ->
      fprintf ppf "This is a generative functor. It can only be applied to ()"

let report_error env ppf err =
  Printtyp.wrap_printing_env env (fun () -> report_error ppf err)

let () =
  Location.register_error_of_exn
    (function
      | Error (loc, env, err) ->
        Some (Location.error_of_printer loc (report_error env) err)
      | Error_forward err ->
        Some err
      | _ ->
        None
    )

end
module Compmisc : sig 
#1 "compmisc.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*      Fabrice Le Fessant, EPI Gallium, INRIA Paris-Rocquencourt      *)
(*                                                                     *)
(*  Copyright 2013 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

val init_path : bool -> unit
val initial_env : unit -> Env.t

end = struct
#1 "compmisc.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*      Fabrice Le Fessant, EPI Gallium, INRIA Paris-Rocquencourt      *)
(*                                                                     *)
(*  Copyright 2013 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Compenv

(* Initialize the search path.
   The current directory is always searched first,
   then the directories specified with the -I option (in command-line order),
   then the standard library directory (unless the -nostdlib option is given).
 *)

let init_path native =
  let dirs =
    if !Clflags.use_threads then "+threads" :: !Clflags.include_dirs
    else if !Clflags.use_vmthreads && not native then
      "+vmthreads" :: !Clflags.include_dirs
    else
      !last_include_dirs @
      !Clflags.include_dirs @
      !first_include_dirs
  in
  let exp_dirs =
    List.map (Misc.expand_directory Config.standard_library) dirs in
 
    Config.load_path :=
      (if !Clflags.no_implicit_current_dir then 
         List.rev_append exp_dirs (Clflags.std_include_dir ())
       else 
         "" :: List.rev_append exp_dirs (Clflags.std_include_dir ()));

  Env.reset_cache ()

(* Return the initial environment in which compilation proceeds. *)

(* Note: do not do init_path() in initial_env, this breaks
   toplevel initialization (PR#1775) *)

let open_implicit_module m env =
  let open Asttypes in
  let lid = {loc = Location.in_file "command line";
             txt = Longident.Lident m } in
  snd (Typemod.type_open_ Override env lid.loc lid)

let initial_env () =
  Ident.reinit();
  let initial =
    if !Clflags.unsafe_string then Env.initial_unsafe_string
    else Env.initial_safe_string
  in
  let env =
    if !Clflags.nopervasives then initial else
    open_implicit_module "Pervasives" initial
  in
  List.fold_left (fun env m ->
    open_implicit_module m env
  ) env (!implicit_modules @ List.rev !Clflags.open_modules)

end
module Ext_io : sig 
#1 "ext_io.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

val load_file : string -> string

val rev_lines_of_file : string -> string list

val write_file : string -> string -> unit

end = struct
#1 "ext_io.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


(** on 32 bit , there are 16M limitation *)
let load_file f =
  Ext_pervasives.finally (open_in_bin f) close_in begin fun ic ->   
    let n = in_channel_length ic in
    let s = Bytes.create n in
    really_input ic s 0 n;
    Bytes.unsafe_to_string s
  end


let rev_lines_of_file file = 
  Ext_pervasives.finally (open_in_bin file) close_in begin fun chan -> 
    let rec loop acc = 
      match input_line chan with
      | line -> loop (line :: acc)
      | exception End_of_file -> close_in chan ; acc in
    loop []
  end

let write_file f content = 
  Ext_pervasives.finally (open_out_bin f) close_out begin fun oc ->   
    output_string oc content
  end

end
module Ext_log : sig 
#1 "ext_log.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** A Poor man's logging utility
    
    Example:
    {[ 
    err __LOC__ "xx"
    ]}
 *)



type 'a logging =  ('a, Format.formatter, unit, unit, unit, unit) format6 -> 'a


val err : string -> 'a logging
val ierr : bool -> string -> 'a logging 
val warn : string -> 'a logging
val iwarn : bool -> string -> 'a logging 
val dwarn : string -> 'a logging 
val info : string -> 'a logging
val iinfo : bool -> string -> 'a logging

end = struct
#1 "ext_log.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)










type 'a logging =  ('a, Format.formatter, unit, unit, unit, unit) format6 -> 'a

let err str f  =
  Format.fprintf Format.err_formatter ("%s " ^^ f ^^ "@.") str  

let ierr b str f  =
  if b then 
    Format.fprintf Format.err_formatter ("%s " ^^ f) str  
  else
    Format.ifprintf Format.err_formatter ("%s " ^^ f) str  

let warn str f  =
  Format.fprintf Format.err_formatter ("WARN: %s " ^^ f ^^ "@.") str  



let iwarn b str f  = 
  if b then 
    Format.fprintf Format.err_formatter ("WARN: %s " ^^ f) str  
  else 
    Format.ifprintf Format.err_formatter ("WARN: %s " ^^ f) str 

(* TODO: add {[@.]} later for all *)
let dwarn str f  = 
  if Js_config.is_same_file () then   
    Format.fprintf Format.err_formatter ("WARN: %s " ^^ f ^^ "@.") str  
  else 
    Format.ifprintf Format.err_formatter ("WARN: %s " ^^ f ^^ "@.") str  

let info str f  =
  Format.fprintf Format.err_formatter ("INFO: %s " ^^ f) str  

let iinfo b str f  =
  if b then 
    Format.fprintf Format.err_formatter ("INFO: %s " ^^ f) str  
  else
    Format.fprintf Format.err_formatter ("INFO: %s " ^^ f) str  


end
module Ext_namespace : sig 
#1 "ext_namespace.mli"
(* Copyright (C) 2017- Authors of BuckleScript
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


val make : ns:string -> string -> string 



(* Note  we have to output uncapitalized file Name, 
  or at least be consistent, since by reading cmi file on Case insensitive OS, we don't really know it is `list.cmi` or `List.cmi`, so that `require (./list.js)` or `require(./List.js)`
  relevant issues: #1609, #913  
  
  #1933 when removing ns suffix, don't pass the bound
  of basename
*)
val js_name_of_basename :  string -> string 
val js_name_of_modulename : little:bool -> string -> string
val namespace_of_package_name : string -> string

end = struct
#1 "ext_namespace.ml"

(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


(* Note the build system should check the validity of filenames
   espeically, it should not contain '-'
*)
let ns_sep_char = '-'
let ns_sep = "-"

let make ~ns cunit  = 
  cunit ^ ns_sep ^ ns

let path_char = Filename.dir_sep.[0]

let rec rindex_rec s i  =
  if i < 0 then i else
    let char = String.unsafe_get s i in
    if char = path_char then -1 
    else if char = ns_sep_char then i 
    else
      rindex_rec s (i - 1) 

let remove_ns_suffix name =
  let i = rindex_rec name (String.length name - 1)  in 
  if i < 0 then name 
  else String.sub name 0 i 


let js_name_of_basename s = 
  remove_ns_suffix  s ^ Literals.suffix_js

let js_name_of_modulename ~little s = 
  if little then 
    remove_ns_suffix (String.uncapitalize s) ^ Literals.suffix_js
  else 
    remove_ns_suffix s ^ Literals.suffix_js

    
let namespace_of_package_name (s : string) : string = 
  let len = String.length s in 
  let buf = Buffer.create len in 
  let add capital ch = 
    Buffer.add_char buf 
      (if capital then 
         (Char.uppercase ch)
       else ch) in    
  let rec aux capital off len =     
    if off >= len then ()
    else 
      let ch = String.unsafe_get s off in
      match ch with 
      | 'a' .. 'z' 
      | 'A' .. 'Z' 
      | '0' .. '9'
        ->
        add capital ch ; 
        aux false (off + 1) len 
      | '-' -> 
        aux true (off + 1) len 
      | _ -> aux capital (off+1) len
  in 
  aux true 0 len ;
  Buffer.contents buf 

end
module Config_util : sig 
#1 "config_util.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** A simple wrapper around [Config] module in compiler-libs, so that the search path
    is the same
*)


val find_opt : string -> string option
(** [find filename] Input is a file name, output is absolute path *)


end = struct
#1 "config_util.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






let find_in_path_uncap path name =
  let uname = String.uncapitalize name in
  let rec try_dir = function
    | [] -> None
    | dir::rem ->      
      let ufullname = Filename.concat dir uname in
      if Sys.file_exists ufullname then Some ufullname
      else 
        let fullname = Filename.concat dir name   in
        if Sys.file_exists fullname then Some fullname
        else try_dir rem
  in try_dir path



(* ATTENTION: lazy to wait [Config.load_path] populated *)
let find_opt file =  find_in_path_uncap !Config.load_path file 





end
module Ext_filename : sig 
#1 "ext_filename.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)





(* TODO:
   Change the module name, this code is not really an extension of the standard 
    library but rather specific to JS Module name convention. 
*)





(** An extension module to calculate relative path follow node/npm style. 
    TODO : this short name will have to change upon renaming the file.
*)

(** Js_output is node style, which means 
    separator is only '/'

    if the path contains 'node_modules', 
    [node_relative_path] will discard its prefix and 
    just treat it as a library instead
*)

val cwd : string Lazy.t

(* It is lazy so that it will not hit errors when in script mode *)
val package_dir : string Lazy.t


val simple_convert_node_path_to_os_path : string -> string


end = struct
#1 "ext_filename.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








type t = Ext_path.t

let cwd = lazy (Sys.getcwd ())




(* Input must be absolute directory *)
let rec find_root_filename ~cwd filename   = 
  if Sys.file_exists ( Filename.concat cwd  filename) then cwd
  else 
    let cwd' = Filename.dirname cwd in 
    if String.length cwd' < String.length cwd then  
      find_root_filename ~cwd:cwd'  filename 
    else 
      Ext_pervasives.failwithf 
        ~loc:__LOC__
        "%s not found from %s" filename cwd


let find_package_json_dir cwd  = 
  find_root_filename ~cwd  Literals.bsconfig_json

let package_dir = lazy (find_package_json_dir (Lazy.force cwd))








let simple_convert_node_path_to_os_path =
  if Sys.unix then fun x -> x 
  else if Sys.win32 || Sys.cygwin then 
    Ext_string.replace_slash_backward 
  else failwith ("Unknown OS : " ^ Sys.os_type)



end
module Ext_sys : sig 
#1 "ext_sys.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


(* Not used yet *)
(* val is_directory_no_exn : string -> bool *)


val is_windows_or_cygwin : bool 
end = struct
#1 "ext_sys.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

(** TODO: not exported yet, wait for Windows Fix*)
let is_directory_no_exn f = 
  try Sys.is_directory f with _ -> false 


let is_windows_or_cygwin = Sys.win32 || Sys.cygwin
end
module Hash_set_gen
= struct
#1 "hash_set_gen.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


(* We do dynamic hashing, and resize the table and rehash the elements
   when buckets become too long. *)

type 'a t =
  { mutable size: int;                        (* number of entries *)
    mutable data: 'a list array;  (* the buckets *)
    initial_size: int;                        (* initial array size *)
  }




let create  initial_size =
  let s = Ext_util.power_2_above 16 initial_size in
  { initial_size = s; size = 0; data = Array.make s [] }

let clear h =
  h.size <- 0;
  let len = Array.length h.data in
  for i = 0 to len - 1 do
    Array.unsafe_set h.data i  []
  done

let reset h =
  h.size <- 0;
  h.data <- Array.make h.initial_size [ ]


let copy h = { h with data = Array.copy h.data }

let length h = h.size

let iter f h =
  let rec do_bucket = function
    | [ ] ->
      ()
    | k ::  rest ->
      f k ; do_bucket rest in
  let d = h.data in
  for i = 0 to Array.length d - 1 do
    do_bucket (Array.unsafe_get d i)
  done

let fold f h init =
  let rec do_bucket b accu =
    match b with
      [ ] ->
      accu
    | k ::  rest ->
      do_bucket rest (f k  accu) in
  let d = h.data in
  let accu = ref init in
  for i = 0 to Array.length d - 1 do
    accu := do_bucket (Array.unsafe_get d i) !accu
  done;
  !accu

let resize indexfun h =
  let odata = h.data in
  let osize = Array.length odata in
  let nsize = osize * 2 in
  if nsize < Sys.max_array_length then begin
    let ndata = Array.make nsize [ ] in
    h.data <- ndata;          (* so that indexfun sees the new bucket count *)
    let rec insert_bucket = function
        [ ] -> ()
      | key :: rest ->
        let nidx = indexfun h key in
        ndata.(nidx) <- key :: ndata.(nidx);
        insert_bucket rest
    in
    for i = 0 to osize - 1 do
      insert_bucket (Array.unsafe_get odata i)
    done
  end

let elements set = 
  fold  (fun k  acc ->  k :: acc) set []




let stats h =
  let mbl =
    Array.fold_left (fun m b -> max m (List.length b)) 0 h.data in
  let histo = Array.make (mbl + 1) 0 in
  Array.iter
    (fun b ->
       let l = List.length b in
       histo.(l) <- histo.(l) + 1)
    h.data;
  {Hashtbl.num_bindings = h.size;
   num_buckets = Array.length h.data;
   max_bucket_length = mbl;
   bucket_histogram = histo }

let rec small_bucket_mem eq_key key lst =
  match lst with 
  | [] -> false 
  | key1::rest -> 
    eq_key key   key1 ||
    match rest with 
    | [] -> false 
    | key2 :: rest -> 
      eq_key key   key2 ||
      match rest with 
      | [] -> false 
      | key3 :: rest -> 
        eq_key key   key3 ||
        small_bucket_mem eq_key key rest 

let rec remove_bucket eq_key key (h : _ t) buckets = 
  match buckets with 
  | [ ] ->
    [ ]
  | k :: next ->
    if  eq_key k   key
    then begin h.size <- h.size - 1; next end
    else k :: remove_bucket eq_key key h next    

module type S =
sig
  type key
  type t
  val create: int ->  t
  val clear : t -> unit
  val reset : t -> unit
  val copy: t -> t
  val remove:  t -> key -> unit
  val add :  t -> key -> unit
  val of_array : key array -> t 
  val check_add : t -> key -> bool
  val mem :  t -> key -> bool
  val iter: (key -> unit) ->  t -> unit
  val fold: (key -> 'b -> 'b) ->  t -> 'b -> 'b
  val length:  t -> int
  val stats:  t -> Hashtbl.statistics
  val elements : t -> key list 
end

end
module String_hash_set : sig 
#1 "string_hash_set.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


include Hash_set_gen.S with type key = string

end = struct
#1 "string_hash_set.ml"
# 1 "ext/hash_set.cppo.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)
# 31
type key = string 
let key_index (h :  _ Hash_set_gen.t ) (key : key) =
  (Bs_hash_stubs.hash_string  key) land (Array.length h.data - 1)
let eq_key = Ext_string.equal 
type  t = key  Hash_set_gen.t 


# 62
let create = Hash_set_gen.create
let clear = Hash_set_gen.clear
let reset = Hash_set_gen.reset
let copy = Hash_set_gen.copy
let iter = Hash_set_gen.iter
let fold = Hash_set_gen.fold
let length = Hash_set_gen.length
let stats = Hash_set_gen.stats
let elements = Hash_set_gen.elements



let remove (h : _ Hash_set_gen.t) key =  
  let i = key_index h key in
  let h_data = h.data in
  let old_h_size = h.size in 
  let new_bucket = Hash_set_gen.remove_bucket eq_key key h (Array.unsafe_get h_data i) in
  if old_h_size <> h.size then  
    Array.unsafe_set h_data i new_bucket



let add (h : _ Hash_set_gen.t) key =
  let i = key_index h key  in 
  let h_data = h.data in 
  let old_bucket = (Array.unsafe_get h_data i) in
  if not (Hash_set_gen.small_bucket_mem eq_key key old_bucket) then 
    begin 
      Array.unsafe_set h_data i (key :: old_bucket);
      h.size <- h.size + 1 ;
      if h.size > Array.length h_data lsl 1 then Hash_set_gen.resize key_index h
    end

let of_array arr = 
  let len = Array.length arr in 
  let tbl = create len in 
  for i = 0 to len - 1  do
    add tbl (Array.unsafe_get arr i);
  done ;
  tbl 
  
    
let check_add (h : _ Hash_set_gen.t) key =
  let i = key_index h key  in 
  let h_data = h.data in  
  let old_bucket = (Array.unsafe_get h_data i) in
  if not (Hash_set_gen.small_bucket_mem eq_key key old_bucket) then 
    begin 
      Array.unsafe_set h_data i  (key :: old_bucket);
      h.size <- h.size + 1 ;
      if h.size > Array.length h_data lsl 1 then Hash_set_gen.resize key_index h;
      true 
    end
  else false 


let mem (h :  _ Hash_set_gen.t) key =
  Hash_set_gen.small_bucket_mem eq_key key (Array.unsafe_get h.data (key_index h key)) 

  

end
module Ext_ident : sig 
#1 "ext_ident.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** A wrapper around [Ident] module in compiler-libs*)

 val is_js : Ident.t -> bool 

val is_js_object : Ident.t -> bool

(** create identifiers for predefined [js] global variables *)
val create_js : string -> Ident.t

val create : string -> Ident.t

 val make_js_object : Ident.t -> unit 

val reset : unit -> unit

val create_tmp :  ?name:string -> unit -> Ident.t

val make_unused : unit -> Ident.t 



(**
   Invariant: if name is not converted, the reference should be equal
*)
val convert : string -> string


val undefined : Ident.t 
val is_js_or_global : Ident.t -> bool
 val nil : Ident.t 


val compare : Ident.t -> Ident.t -> int
val equal : Ident.t -> Ident.t -> bool 

end = struct
#1 "ext_ident.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








let js_flag = 0b1_000 (* check with ocaml compiler *)

(* let js_module_flag = 0b10_000 (\* javascript external modules *\) *)
(* TODO:
    check name conflicts with javascript conventions
   {[
     Ext_ident.convert "^";;
     - : string = "$caret"
   ]}
*)
let js_object_flag = 0b100_000 (* javascript object flags *)

let is_js (i : Ident.t) = 
  i.flags land js_flag <> 0 

let is_js_or_global (i : Ident.t) = 
  i.flags land (8 lor 1) <> 0 


let is_js_object (i : Ident.t) = 
  i.flags land js_object_flag <> 0 

let make_js_object (i : Ident.t) = 
  i.flags <- i.flags lor js_object_flag 

(* It's a js function hard coded by js api, so when printing,
   it should preserve the name 
*)
let create_js (name : string) : Ident.t  = 
  { name = name; flags = js_flag ; stamp = 0}

let create = Ident.create

(* FIXME: no need for `$' operator *)
let create_tmp ?(name=Literals.tmp) () = create name 


let js_module_table : Ident.t String_hashtbl.t = String_hashtbl.create 31 

(* This is for a js exeternal module, we can change it when printing
   for example
   {[
     var React$1 = require('react');
     React$1.render(..)
   ]}

   Given a name, if duplicated, they should  have the same id
*)
let create_js_module (name : string) : Ident.t = 
  let name = 
    String.concat "" @@ Ext_list.map (Ext_string.capitalize_ascii ) @@ 
    Ext_string.split name '-' in
  (* TODO: if we do such transformation, we should avoid       collision for example:
      react-dom 
      react--dom
      check collision later
  *)
  match String_hashtbl.find_exn js_module_table name  with 
  | exception Not_found -> 
    let ans = Ident.create name in
    (* let ans = { v with flags = js_module_flag} in  *)
    String_hashtbl.add js_module_table name ans;
    ans
  | v -> (* v *) Ident.rename v  


let reserved_words = 
  [|
    (* keywork *)
    "break";
    "case"; "catch"; "continue";
    "debugger";"default";"delete";"do";
    "else";
    "finally";"for";"function";
    "if"; "then"; "in";"instanceof";
    "new";
    "return";
    "switch";
    "this"; "throw"; "try"; "typeof";
    "var"; "void"; "while"; "with";

    (* reserved in ECMAScript 5 *)
    "class"; "enum"; "export"; "extends"; "import"; "super";

    "implements";"interface";
    "let";
    "package";"private";"protected";"public";
    "static";
    "yield";

    (* other *)
    "null";
    "true";
    "false";
    "NaN";


    "undefined";
    "this";

    (* also reserved in ECMAScript 3 *)
    "abstract"; "boolean"; "byte"; "char"; "const"; "double";
    "final"; "float"; "goto"; "int"; "long"; "native"; "short";
    "synchronized"; 
    (* "throws";  *)
    (* seems to be fine, like nodejs [assert.throws] *)
    "transient"; "volatile";

    (* also reserved in ECMAScript 6 *)
    "await";

    "event";
    "location";
    "window";
    "document";
    "eval";
    "navigator";
    (* "self"; *)

    "Array";
    "Date";
    "Math";
    "JSON";
    "Object";
    "RegExp";
    "String";
    "Boolean";
    "Number";

    "Map"; (* es6*)
    "Set";

    "Infinity";
    "isFinite";

    "ActiveXObject";
    "XMLHttpRequest";
    "XDomainRequest";

    "DOMException";
    "Error";
    "SyntaxError";
    "arguments";

    "decodeURI";
    "decodeURIComponent";
    "encodeURI";
    "encodeURIComponent";
    "escape";
    "unescape";

    "isNaN";
    "parseFloat";
    "parseInt";

    (** reserved for commonjs and NodeJS globals*)   
    "require";
    "exports";
    "module";
    "clearImmediate";
    "clearInterval";
    "clearTimeout";
    "console";
    "global";
    "process";
    "require";
    "setImmediate";
    "setInterval";
    "setTimeout";
    "__dirname";
    "__filename";
    "__esModule"
  |]

let reserved_map = 
  let len = Array.length reserved_words in 
  let set =  String_hash_set.create 1024 in (* large hash set for perfect hashing *)
  for i = 0 to len - 1 do 
    String_hash_set.add set reserved_words.(i);
  done ;
  set 



exception Not_normal_letter of int 
let name_mangle name = 

  let len = String.length name  in
  try
    for i  = 0 to len - 1 do 
      match String.unsafe_get name i with 
      | 'a' .. 'z' | 'A' .. 'Z'
      | '0' .. '9' | '_' | '$'
        -> ()
      | _ -> raise (Not_normal_letter i)
    done;
    name (* Normal letter *)
  with 
  | Not_normal_letter 0 ->

    let buffer = Buffer.create len in 
    for j = 0 to  len - 1 do 
      let c = String.unsafe_get name j in
      match c with 
      | '*' -> Buffer.add_string buffer "$star"
      | '\'' -> Buffer.add_string buffer "$prime"
      | '!' -> Buffer.add_string buffer "$bang"
      | '>' -> Buffer.add_string buffer "$great"
      | '<' -> Buffer.add_string buffer "$less"
      | '=' -> Buffer.add_string buffer "$eq"
      | '+' -> Buffer.add_string buffer "$plus"
      | '-' -> Buffer.add_string buffer "$neg"
      | '@' -> Buffer.add_string buffer "$at"
      | '^' -> Buffer.add_string buffer "$caret"
      | '/' -> Buffer.add_string buffer "$slash"
      | '|' -> Buffer.add_string buffer "$pipe"
      | '.' -> Buffer.add_string buffer "$dot"
      | '%' -> Buffer.add_string buffer "$percent"
      | '~' -> Buffer.add_string buffer "$tilde"
      | '#' -> Buffer.add_string buffer "$hash"
      | 'a'..'z' | 'A'..'Z'| '_' 
      | '$'
      | '0'..'9'-> Buffer.add_char buffer  c
      | _ -> Buffer.add_string buffer "$unknown"
    done; Buffer.contents buffer
  | Not_normal_letter i -> 
    String.sub name 0 i ^
    (let buffer = Buffer.create len in 
     for j = i to  len - 1 do 
       let c = String.unsafe_get name j in
       match c with 
       | '*' -> Buffer.add_string buffer "$star"
       | '\'' -> Buffer.add_string buffer "$prime"
       | '!' -> Buffer.add_string buffer "$bang"
       | '>' -> Buffer.add_string buffer "$great"
       | '<' -> Buffer.add_string buffer "$less"
       | '=' -> Buffer.add_string buffer "$eq"
       | '+' -> Buffer.add_string buffer "$plus"
       | '-' -> Buffer.add_string buffer "$" 
        (* Note ocaml compiler also has [self-] *)
       | '@' -> Buffer.add_string buffer "$at"
       | '^' -> Buffer.add_string buffer "$caret"
       | '/' -> Buffer.add_string buffer "$slash"
       | '|' -> Buffer.add_string buffer "$pipe"
       | '.' -> Buffer.add_string buffer "$dot"
       | '%' -> Buffer.add_string buffer "$percent"
       | '~' -> Buffer.add_string buffer "$tilde"
       | '#' -> Buffer.add_string buffer "$hash"
       | '$' -> Buffer.add_string buffer "$dollar"
       | 'a'..'z' | 'A'..'Z'| '_'        
       | '0'..'9'-> Buffer.add_char buffer  c
       | _ -> Buffer.add_string buffer "$unknown"
     done; Buffer.contents buffer)
(* TODO:
    check name conflicts with javascript conventions
   {[
     Ext_ident.convert "^";;
     - : string = "$caret"
   ]}
   [convert name] if [name] is a js keyword,add "$$"
   otherwise do the name mangling to make sure ocaml identifier it is 
   a valid js identifier
*)
let convert (name : string) = 
  if  String_hash_set.mem reserved_map name  then "$$" ^ name 
  else name_mangle name 

(** keyword could be used in property *)

(* It is currently made a persistent ident to avoid fresh ids 
    which would result in different signature files
    - other solution: use lazy values
*)
let make_unused () = create "_"



let reset () = 
  String_hashtbl.clear js_module_table


let undefined = create_js "undefined"
let nil = create_js "null"

(* Has to be total order, [x < y] 
   and [x > y] should be consistent
   flags are not relevant here 
*)
let compare (x : Ident.t ) ( y : Ident.t) = 
  let u = x.stamp - y.stamp in
  if u = 0 then 
    Ext_string.compare x.name y.name 
  else u 

let equal ( x : Ident.t) ( y : Ident.t) = 
  if x.stamp <> 0 then x.stamp = y.stamp
  else y.stamp = 0 && x.name = y.name


end
module Hash_set : sig 
#1 "hash_set.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

(** Ideas are based on {!Hashtbl}, 
    however, {!Hashtbl.add} does not really optimize and has a bad semantics for {!Hash_set}, 
    This module fixes the semantics of [add].
    [remove] is not optimized since it is not used too much 
*)





module Make ( H : Hashtbl.HashedType) : (Hash_set_gen.S with type key = H.t)
(** A naive t implementation on top of [hashtbl], the value is [unit]*)


end = struct
#1 "hash_set.ml"
# 1 "ext/hash_set.cppo.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)
# 43
module Make (H: Hashtbl.HashedType) : (Hash_set_gen.S with type key = H.t) = struct 
type key = H.t 
let eq_key = H.equal
let key_index (h :  _ Hash_set_gen.t ) key =
  (H.hash  key) land (Array.length h.data - 1)
type t = key Hash_set_gen.t



# 62
let create = Hash_set_gen.create
let clear = Hash_set_gen.clear
let reset = Hash_set_gen.reset
let copy = Hash_set_gen.copy
let iter = Hash_set_gen.iter
let fold = Hash_set_gen.fold
let length = Hash_set_gen.length
let stats = Hash_set_gen.stats
let elements = Hash_set_gen.elements



let remove (h : _ Hash_set_gen.t) key =  
  let i = key_index h key in
  let h_data = h.data in
  let old_h_size = h.size in 
  let new_bucket = Hash_set_gen.remove_bucket eq_key key h (Array.unsafe_get h_data i) in
  if old_h_size <> h.size then  
    Array.unsafe_set h_data i new_bucket



let add (h : _ Hash_set_gen.t) key =
  let i = key_index h key  in 
  let h_data = h.data in 
  let old_bucket = (Array.unsafe_get h_data i) in
  if not (Hash_set_gen.small_bucket_mem eq_key key old_bucket) then 
    begin 
      Array.unsafe_set h_data i (key :: old_bucket);
      h.size <- h.size + 1 ;
      if h.size > Array.length h_data lsl 1 then Hash_set_gen.resize key_index h
    end

let of_array arr = 
  let len = Array.length arr in 
  let tbl = create len in 
  for i = 0 to len - 1  do
    add tbl (Array.unsafe_get arr i);
  done ;
  tbl 
  
    
let check_add (h : _ Hash_set_gen.t) key =
  let i = key_index h key  in 
  let h_data = h.data in  
  let old_bucket = (Array.unsafe_get h_data i) in
  if not (Hash_set_gen.small_bucket_mem eq_key key old_bucket) then 
    begin 
      Array.unsafe_set h_data i  (key :: old_bucket);
      h.size <- h.size + 1 ;
      if h.size > Array.length h_data lsl 1 then Hash_set_gen.resize key_index h;
      true 
    end
  else false 


let mem (h :  _ Hash_set_gen.t) key =
  Hash_set_gen.small_bucket_mem eq_key key (Array.unsafe_get h.data (key_index h key)) 

# 122
end
  

end
module Hashtbl_make : sig 
#1 "hashtbl_make.mli"


module Make (Key : Hashtbl.HashedType) : Hashtbl_gen.S with type key = Key.t

end = struct
#1 "hashtbl_make.ml"
# 22 "ext/hashtbl.cppo.ml"
module Make (Key : Hashtbl.HashedType) = struct 
  type key = Key.t 
  type 'a t = (key, 'a)  Hashtbl_gen.t 
  let key_index (h : _ t ) (key : key) =
    (Key.hash  key ) land (Array.length h.data - 1)
  let eq_key = Key.equal   


# 33
type ('a, 'b) bucketlist = ('a,'b) Hashtbl_gen.bucketlist
let create = Hashtbl_gen.create
let clear = Hashtbl_gen.clear
let reset = Hashtbl_gen.reset
let copy = Hashtbl_gen.copy
let iter = Hashtbl_gen.iter
let fold = Hashtbl_gen.fold
let length = Hashtbl_gen.length
let stats = Hashtbl_gen.stats



let add (h : _ t) key info =
  let i = key_index h key in
  let h_data = h.data in   
  Array.unsafe_set h_data i (Cons(key, info, (Array.unsafe_get h_data i)));
  h.size <- h.size + 1;
  if h.size > Array.length h_data lsl 1 then Hashtbl_gen.resize key_index h

(* after upgrade to 4.04 we should provide an efficient [replace_or_init] *)
let modify_or_init (h : _ t) key modf default =
  let rec find_bucket (bucketlist : _ bucketlist)  =
    match bucketlist with
    | Cons(k,i,next) ->
      if eq_key k key then begin modf i; false end
      else find_bucket next 
    | Empty -> true in
  let i = key_index h key in 
  let h_data = h.data in 
  if find_bucket (Array.unsafe_get h_data i) then
    begin 
      Array.unsafe_set h_data i  (Cons(key,default (), Array.unsafe_get h_data i));
      h.size <- h.size + 1 ;
      if h.size > Array.length h_data lsl 1 then Hashtbl_gen.resize key_index h 
    end


let rec remove_bucket key (h : _ t) (bucketlist : _ bucketlist) : _ bucketlist = 
  match bucketlist with  
  | Empty ->
    Empty
  | Cons(k, i, next) ->
    if eq_key k key 
    then begin h.size <- h.size - 1; next end
    else Cons(k, i, remove_bucket key h next) 

let remove (h : _ t ) key =
  let i = key_index h key in
  let h_data = h.data in 
  let old_h_szie = h.size in 
  let new_bucket = remove_bucket key h (Array.unsafe_get h_data i) in  
  if old_h_szie <> h.size then 
    Array.unsafe_set h_data i  new_bucket

let rec find_rec key (bucketlist : _ bucketlist) = match bucketlist with  
  | Empty ->
    raise Not_found
  | Cons(k, d, rest) ->
    if eq_key key k then d else find_rec key rest

let find_exn (h : _ t) key =
  match Array.unsafe_get h.data (key_index h key) with
  | Empty -> raise Not_found
  | Cons(k1, d1, rest1) ->
    if eq_key key k1 then d1 else
      match rest1 with
      | Empty -> raise Not_found
      | Cons(k2, d2, rest2) ->
        if eq_key key k2 then d2 else
          match rest2 with
          | Empty -> raise Not_found
          | Cons(k3, d3, rest3) ->
            if eq_key key k3  then d3 else find_rec key rest3

let find_opt (h : _ t) key =
  Hashtbl_gen.small_bucket_opt eq_key key (Array.unsafe_get h.data (key_index h key))

let find_key_opt (h : _ t) key =
  Hashtbl_gen.small_bucket_key_opt eq_key key (Array.unsafe_get h.data (key_index h key))
  
let find_default (h : _ t) key default = 
  Hashtbl_gen.small_bucket_default eq_key key default (Array.unsafe_get h.data (key_index h key))
let find_all (h : _ t) key =
  let rec find_in_bucket (bucketlist : _ bucketlist) = match bucketlist with 
    | Empty ->
      []
    | Cons(k, d, rest) ->
      if eq_key k key 
      then d :: find_in_bucket rest
      else find_in_bucket rest in
  find_in_bucket (Array.unsafe_get h.data (key_index h key))

let replace h key info =
  let rec replace_bucket (bucketlist : _ bucketlist) : _ bucketlist = match bucketlist with 
    | Empty ->
      raise_notrace Not_found
    | Cons(k, i, next) ->
      if eq_key k key
      then Cons(key, info, next)
      else Cons(k, i, replace_bucket next) in
  let i = key_index h key in
  let h_data = h.data in 
  let l = Array.unsafe_get h_data i in
  try
    Array.unsafe_set h_data i  (replace_bucket l)
  with Not_found ->
    begin 
      Array.unsafe_set h_data i (Cons(key, info, l));
      h.size <- h.size + 1;
      if h.size > Array.length h_data lsl 1 then Hashtbl_gen.resize key_index h;
    end 

let mem (h : _ t) key =
  let rec mem_in_bucket (bucketlist : _ bucketlist) = match bucketlist with 
    | Empty ->
      false
    | Cons(k, d, rest) ->
      eq_key k key  || mem_in_bucket rest in
  mem_in_bucket (Array.unsafe_get h.data (key_index h key))


let of_list2 ks vs = 
  let len = List.length ks in 
  let map = create len in 
  List.iter2 (fun k v -> add map k v) ks vs ; 
  map

# 161
end

end
module Set_gen
= struct
#1 "set_gen.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the GNU Library General Public License, with    *)
(*  the special exception on linking described in file ../LICENSE.     *)
(*                                                                     *)
(***********************************************************************)

(** balanced tree based on stdlib distribution *)

type 'a t = 
  | Empty 
  | Node of 'a t * 'a * 'a t * int 

type 'a enumeration = 
  | End | More of 'a * 'a t * 'a enumeration


let rec cons_enum s e = 
  match s with 
  | Empty -> e 
  | Node(l,v,r,_) -> cons_enum l (More(v,r,e))

let rec height = function
  | Empty -> 0 
  | Node(_,_,_,h) -> h   

(* Smallest and greatest element of a set *)

let rec min_elt = function
    Empty -> raise Not_found
  | Node(Empty, v, r, _) -> v
  | Node(l, v, r, _) -> min_elt l

let rec max_elt = function
    Empty -> raise Not_found
  | Node(l, v, Empty, _) -> v
  | Node(l, v, r, _) -> max_elt r




let empty = Empty

let is_empty = function Empty -> true | _ -> false

let rec cardinal_aux acc  = function
  | Empty -> acc 
  | Node (l,_,r, _) -> 
    cardinal_aux  (cardinal_aux (acc + 1)  r ) l 

let cardinal s = cardinal_aux 0 s 

let rec elements_aux accu = function
  | Empty -> accu
  | Node(l, v, r, _) -> elements_aux (v :: elements_aux accu r) l

let elements s =
  elements_aux [] s

let choose = min_elt

let rec iter f = function
  | Empty -> ()
  | Node(l, v, r, _) -> iter f l; f v; iter f r

let rec fold f s accu =
  match s with
  | Empty -> accu
  | Node(l, v, r, _) -> fold f r (f v (fold f l accu))

let rec for_all p = function
  | Empty -> true
  | Node(l, v, r, _) -> p v && for_all p l && for_all p r

let rec exists p = function
  | Empty -> false
  | Node(l, v, r, _) -> p v || exists p l || exists p r


let max_int3 (a : int) b c = 
  if a >= b then 
    if a >= c then a 
    else c
  else 
  if b >=c then b
  else c     
let max_int_2 (a : int) b =  
  if a >= b then a else b 



exception Height_invariant_broken
exception Height_diff_borken 

let rec check_height_and_diff = 
  function 
  | Empty -> 0
  | Node(l,_,r,h) -> 
    let hl = check_height_and_diff l in
    let hr = check_height_and_diff r in
    if h <>  max_int_2 hl hr + 1 then raise Height_invariant_broken
    else  
      let diff = (abs (hl - hr)) in  
      if  diff > 2 then raise Height_diff_borken 
      else h     

let check tree = 
  ignore (check_height_and_diff tree)
(* 
    Invariants: 
    1. {[ l < v < r]}
    2. l and r balanced 
    3. [height l] - [height r] <= 2
*)
let create l v r = 
  let hl = match l with Empty -> 0 | Node (_,_,_,h) -> h in
  let hr = match r with Empty -> 0 | Node (_,_,_,h) -> h in
  Node(l,v,r, if hl >= hr then hl + 1 else hr + 1)         

(* Same as create, but performs one step of rebalancing if necessary.
    Invariants:
    1. {[ l < v < r ]}
    2. l and r balanced 
    3. | height l - height r | <= 3.

    Proof by indunction

    Lemma: the height of  [bal l v r] will bounded by [max l r] + 1 
*)
(*
let internal_bal l v r =
  match l with
  | Empty ->
    begin match r with 
      | Empty -> Node(Empty,v,Empty,1)
      | Node(rl,rv,rr,hr) -> 
        if hr > 2 then
          begin match rl with
            | Empty -> create (* create l v rl *) (Node (Empty,v,Empty,1)) rv rr 
            | Node(rll,rlv,rlr,hrl) -> 
              let hrr = height rr in 
              if hrr >= hrl then 
                Node  
                  ((Node (Empty,v,rl,hrl+1))(* create l v rl *),
                   rv, rr, if hrr = hrl then hrr + 2 else hrr + 1) 
              else 
                let hrll = height rll in 
                let hrlr = height rlr in 
                create
                  (Node(Empty,v,rll,hrll + 1)) 
                  (* create l v rll *) 
                  rlv 
                  (Node (rlr,rv,rr, if hrlr > hrr then hrlr + 1 else hrr + 1))
                  (* create rlr rv rr *)    
          end 
        else Node (l,v,r, hr + 1)  
    end
  | Node(ll,lv,lr,hl) ->
    begin match r with 
      | Empty ->
        if hl > 2 then 
          (*if height ll >= height lr then create ll lv (create lr v r)
            else*)
          begin match lr with 
            | Empty -> 
              create ll lv (Node (Empty,v,Empty, 1)) 
            (* create lr v r *)  
            | Node(lrl,lrv,lrr,hlr) -> 
              if height ll >= hlr then 
                create ll lv
                  (Node(lr,v,Empty,hlr+1)) 
                  (*create lr v r*)
              else 
                let hlrr = height lrr in  
                create 
                  (create ll lv lrl)
                  lrv
                  (Node(lrr,v,Empty,hlrr + 1)) 
                  (*create lrr v r*)
          end 
        else Node(l,v,r, hl+1)    
      | Node(rl,rv,rr,hr) ->
        if hl > hr + 2 then           
          begin match lr with 
            | Empty ->   create ll lv (create lr v r)
            | Node(lrl,lrv,lrr,_) ->
              if height ll >= height lr then create ll lv (create lr v r)
              else 
                create (create ll lv lrl) lrv (create lrr v r)
          end 
        else
        if hr > hl + 2 then             
          begin match rl with 
            | Empty ->
              let hrr = height rr in   
              Node(
                (Node (l,v,Empty,hl + 1))
                (*create l v rl*)
                ,
                rv,
                rr,
                if hrr > hr then hrr + 1 else hl + 2 
              )
            | Node(rll,rlv,rlr,_) ->
              let hrr = height rr in 
              let hrl = height rl in 
              if hrr >= hrl then create (create l v rl) rv rr else 
                create (create l v rll) rlv (create rlr rv rr)
          end
        else  
          Node(l,v,r, if hl >= hr then hl+1 else hr + 1)
    end
*)
let internal_bal l v r =
  let hl = match l with Empty -> 0 | Node(_,_,_,h) -> h in
  let hr = match r with Empty -> 0 | Node(_,_,_,h) -> h in
  if hl > hr + 2 then begin
    match l with
      Empty -> assert false
    | Node(ll, lv, lr, _) ->   
      if height ll >= height lr then
        (* [ll] >~ [lr] 
           [ll] >~ [r] 
           [ll] ~~ [ lr ^ r]  
        *)
        create ll lv (create lr v r)
      else begin
        match lr with
          Empty -> assert false
        | Node(lrl, lrv, lrr, _)->
          (* [lr] >~ [ll]
             [lr] >~ [r]
             [ll ^ lrl] ~~ [lrr ^ r]   
          *)
          create (create ll lv lrl) lrv (create lrr v r)
      end
  end else if hr > hl + 2 then begin
    match r with
      Empty -> assert false
    | Node(rl, rv, rr, _) ->
      if height rr >= height rl then
        create (create l v rl) rv rr
      else begin
        match rl with
          Empty -> assert false
        | Node(rll, rlv, rlr, _) ->
          create (create l v rll) rlv (create rlr rv rr)
      end
  end else
    Node(l, v, r, (if hl >= hr then hl + 1 else hr + 1))    

let rec remove_min_elt = function
    Empty -> invalid_arg "Set.remove_min_elt"
  | Node(Empty, v, r, _) -> r
  | Node(l, v, r, _) -> internal_bal (remove_min_elt l) v r

let singleton x = Node(Empty, x, Empty, 1)    

(* 
   All elements of l must precede the elements of r.
       Assume | height l - height r | <= 2.
   weak form of [concat] 
*)

let internal_merge l r =
  match (l, r) with
  | (Empty, t) -> t
  | (t, Empty) -> t
  | (_, _) -> internal_bal l (min_elt r) (remove_min_elt r)

(* Beware: those two functions assume that the added v is *strictly*
    smaller (or bigger) than all the present elements in the tree; it
    does not test for equality with the current min (or max) element.
    Indeed, they are only used during the "join" operation which
    respects this precondition.
*)

let rec add_min_element v = function
  | Empty -> singleton v
  | Node (l, x, r, h) ->
    internal_bal (add_min_element v l) x r

let rec add_max_element v = function
  | Empty -> singleton v
  | Node (l, x, r, h) ->
    internal_bal l x (add_max_element v r)

(** 
    Invariants:
    1. l < v < r 
    2. l and r are balanced 

    Proof by induction
    The height of output will be ~~ (max (height l) (height r) + 2)
    Also use the lemma from [bal]
*)
let rec internal_join l v r =
  match (l, r) with
    (Empty, _) -> add_min_element v r
  | (_, Empty) -> add_max_element v l
  | (Node(ll, lv, lr, lh), Node(rl, rv, rr, rh)) ->
    if lh > rh + 2 then 
      (* proof by induction:
         now [height of ll] is [lh - 1] 
      *)
      internal_bal ll lv (internal_join lr v r) 
    else
    if rh > lh + 2 then internal_bal (internal_join l v rl) rv rr 
    else create l v r


(*
    Required Invariants: 
    [t1] < [t2]  
*)
let internal_concat t1 t2 =
  match (t1, t2) with
  | (Empty, t) -> t
  | (t, Empty) -> t
  | (_, _) -> internal_join t1 (min_elt t2) (remove_min_elt t2)

let rec filter p = function
  | Empty -> Empty
  | Node(l, v, r, _) ->
    (* call [p] in the expected left-to-right order *)
    let l' = filter p l in
    let pv = p v in
    let r' = filter p r in
    if pv then internal_join l' v r' else internal_concat l' r'


let rec partition p = function
  | Empty -> (Empty, Empty)
  | Node(l, v, r, _) ->
    (* call [p] in the expected left-to-right order *)
    let (lt, lf) = partition p l in
    let pv = p v in
    let (rt, rf) = partition p r in
    if pv
    then (internal_join lt v rt, internal_concat lf rf)
    else (internal_concat lt rt, internal_join lf v rf)

let of_sorted_list l =
  let rec sub n l =
    match n, l with
    | 0, l -> Empty, l
    | 1, x0 :: l -> Node (Empty, x0, Empty, 1), l
    | 2, x0 :: x1 :: l -> Node (Node(Empty, x0, Empty, 1), x1, Empty, 2), l
    | 3, x0 :: x1 :: x2 :: l ->
      Node (Node(Empty, x0, Empty, 1), x1, Node(Empty, x2, Empty, 1), 2),l
    | n, l ->
      let nl = n / 2 in
      let left, l = sub nl l in
      match l with
      | [] -> assert false
      | mid :: l ->
        let right, l = sub (n - nl - 1) l in
        create left mid right, l
  in
  fst (sub (List.length l) l)

let of_sorted_array l =   
  let rec sub start n l  =
    if n = 0 then Empty else 
    if n = 1 then 
      let x0 = Array.unsafe_get l start in
      Node (Empty, x0, Empty, 1)
    else if n = 2 then     
      let x0 = Array.unsafe_get l start in 
      let x1 = Array.unsafe_get l (start + 1) in 
      Node (Node(Empty, x0, Empty, 1), x1, Empty, 2) else
    if n = 3 then 
      let x0 = Array.unsafe_get l start in 
      let x1 = Array.unsafe_get l (start + 1) in
      let x2 = Array.unsafe_get l (start + 2) in
      Node (Node(Empty, x0, Empty, 1), x1, Node(Empty, x2, Empty, 1), 2)
    else 
      let nl = n / 2 in
      let left = sub start nl l in
      let mid = start + nl in 
      let v = Array.unsafe_get l mid in 
      let right = sub (mid + 1) (n - nl - 1) l in        
      create left v right
  in
  sub 0 (Array.length l) l 

let is_ordered cmp tree =
  let rec is_ordered_min_max tree =
    match tree with
    | Empty -> `Empty
    | Node(l,v,r,_) -> 
      begin match is_ordered_min_max l with
        | `No -> `No 
        | `Empty ->
          begin match is_ordered_min_max r with
            | `No  -> `No
            | `Empty -> `V (v,v)
            | `V(l,r) ->
              if cmp v l < 0 then
                `V(v,r)
              else
                `No
          end
        | `V(min_v,max_v)->
          begin match is_ordered_min_max r with
            | `No -> `No
            | `Empty -> 
              if cmp max_v v < 0 then 
                `V(min_v,v)
              else
                `No 
            | `V(min_v_r, max_v_r) ->
              if cmp max_v min_v_r < 0 then
                `V(min_v,max_v_r)
              else `No
          end
      end  in 
  is_ordered_min_max tree <> `No 

let invariant cmp t = 
  check t ; 
  is_ordered cmp t 

let rec compare_aux cmp e1 e2 =
  match (e1, e2) with
    (End, End) -> 0
  | (End, _)  -> -1
  | (_, End) -> 1
  | (More(v1, r1, e1), More(v2, r2, e2)) ->
    let c = cmp v1 v2 in
    if c <> 0
    then c
    else compare_aux cmp (cons_enum r1 e1) (cons_enum r2 e2)

let compare cmp s1 s2 =
  compare_aux cmp (cons_enum s1 End) (cons_enum s2 End)


module type S = sig
  type elt 
  type t
  val empty: t
  val is_empty: t -> bool
  val iter: (elt -> unit) -> t -> unit
  val fold: (elt -> 'a -> 'a) -> t -> 'a -> 'a
  val for_all: (elt -> bool) -> t -> bool
  val exists: (elt -> bool) -> t -> bool
  val singleton: elt -> t
  val cardinal: t -> int
  val elements: t -> elt list
  val min_elt: t -> elt
  val max_elt: t -> elt
  val choose: t -> elt
  val of_sorted_list : elt list -> t 
  val of_sorted_array : elt array -> t
  val partition: (elt -> bool) -> t -> t * t

  val mem: elt -> t -> bool
  val add: elt -> t -> t
  val remove: elt -> t -> t
  val union: t -> t -> t
  val inter: t -> t -> t
  val diff: t -> t -> t
  val compare: t -> t -> int
  val equal: t -> t -> bool
  val subset: t -> t -> bool
  val filter: (elt -> bool) -> t -> t

  val split: elt -> t -> t * bool * t
  val find: elt -> t -> elt
  val of_list: elt list -> t
  val of_sorted_list : elt list ->  t
  val of_sorted_array : elt array -> t 
  val invariant : t -> bool 
end 

end
module Ident_set : sig 
#1 "ident_set.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


include Set_gen.S with type elt = Ident.t





end = struct
#1 "ident_set.ml"
# 1 "ext/set.cppo.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


# 31
type elt = Ident.t
let compare_elt (x : elt) (y : elt) = 
  let a =  Pervasives.compare (x.stamp : int) y.stamp in 
  if a <> 0 then a 
  else 
    let b = Pervasives.compare (x.name : string) y.name in 
    if b <> 0 then b 
    else Pervasives.compare (x.flags : int) y.flags     
type  t = elt Set_gen.t 


# 57
let empty = Set_gen.empty 
let is_empty = Set_gen.is_empty
let iter = Set_gen.iter
let fold = Set_gen.fold
let for_all = Set_gen.for_all 
let exists = Set_gen.exists 
let singleton = Set_gen.singleton 
let cardinal = Set_gen.cardinal
let elements = Set_gen.elements
let min_elt = Set_gen.min_elt
let max_elt = Set_gen.max_elt
let choose = Set_gen.choose 
let of_sorted_list = Set_gen.of_sorted_list
let of_sorted_array = Set_gen.of_sorted_array
let partition = Set_gen.partition 
let filter = Set_gen.filter 
let of_sorted_list = Set_gen.of_sorted_list
let of_sorted_array = Set_gen.of_sorted_array

let rec split x (tree : _ Set_gen.t) : _ Set_gen.t * bool * _ Set_gen.t =  match tree with 
  | Empty ->
    (Empty, false, Empty)
  | Node(l, v, r, _) ->
    let c = compare_elt x v in
    if c = 0 then (l, true, r)
    else if c < 0 then
      let (ll, pres, rl) = split x l in (ll, pres, Set_gen.internal_join rl v r)
    else
      let (lr, pres, rr) = split x r in (Set_gen.internal_join l v lr, pres, rr)
let rec add x (tree : _ Set_gen.t) : _ Set_gen.t =  match tree with 
  | Empty -> Node(Empty, x, Empty, 1)
  | Node(l, v, r, _) as t ->
    let c = compare_elt x v in
    if c = 0 then t else
    if c < 0 then Set_gen.internal_bal (add x l) v r else Set_gen.internal_bal l v (add x r)

let rec union (s1 : _ Set_gen.t) (s2 : _ Set_gen.t) : _ Set_gen.t  =
  match (s1, s2) with
  | (Empty, t2) -> t2
  | (t1, Empty) -> t1
  | (Node(l1, v1, r1, h1), Node(l2, v2, r2, h2)) ->
    if h1 >= h2 then
      if h2 = 1 then add v2 s1 else begin
        let (l2, _, r2) = split v1 s2 in
        Set_gen.internal_join (union l1 l2) v1 (union r1 r2)
      end
    else
    if h1 = 1 then add v1 s2 else begin
      let (l1, _, r1) = split v2 s1 in
      Set_gen.internal_join (union l1 l2) v2 (union r1 r2)
    end    

let rec inter (s1 : _ Set_gen.t)  (s2 : _ Set_gen.t) : _ Set_gen.t  =
  match (s1, s2) with
  | (Empty, t2) -> Empty
  | (t1, Empty) -> Empty
  | (Node(l1, v1, r1, _), t2) ->
    begin match split v1 t2 with
      | (l2, false, r2) ->
        Set_gen.internal_concat (inter l1 l2) (inter r1 r2)
      | (l2, true, r2) ->
        Set_gen.internal_join (inter l1 l2) v1 (inter r1 r2)
    end 

let rec diff (s1 : _ Set_gen.t) (s2 : _ Set_gen.t) : _ Set_gen.t  =
  match (s1, s2) with
  | (Empty, t2) -> Empty
  | (t1, Empty) -> t1
  | (Node(l1, v1, r1, _), t2) ->
    begin match split v1 t2 with
      | (l2, false, r2) ->
        Set_gen.internal_join (diff l1 l2) v1 (diff r1 r2)
      | (l2, true, r2) ->
        Set_gen.internal_concat (diff l1 l2) (diff r1 r2)    
    end


let rec mem x (tree : _ Set_gen.t) =  match tree with 
  | Empty -> false
  | Node(l, v, r, _) ->
    let c = compare_elt x v in
    c = 0 || mem x (if c < 0 then l else r)

let rec remove x (tree : _ Set_gen.t) : _ Set_gen.t = match tree with 
  | Empty -> Empty
  | Node(l, v, r, _) ->
    let c = compare_elt x v in
    if c = 0 then Set_gen.internal_merge l r else
    if c < 0 then Set_gen.internal_bal (remove x l) v r else Set_gen.internal_bal l v (remove x r)

let compare s1 s2 = Set_gen.compare compare_elt s1 s2 


let equal s1 s2 =
  compare s1 s2 = 0

let rec subset (s1 : _ Set_gen.t) (s2 : _ Set_gen.t) =
  match (s1, s2) with
  | Empty, _ ->
    true
  | _, Empty ->
    false
  | Node (l1, v1, r1, _), (Node (l2, v2, r2, _) as t2) ->
    let c = compare_elt v1 v2 in
    if c = 0 then
      subset l1 l2 && subset r1 r2
    else if c < 0 then
      subset (Node (l1, v1, Empty, 0)) l2 && subset r1 t2
    else
      subset (Node (Empty, v1, r1, 0)) r2 && subset l1 t2




let rec find x (tree : _ Set_gen.t) = match tree with
  | Empty -> raise Not_found
  | Node(l, v, r, _) ->
    let c = compare_elt x v in
    if c = 0 then v
    else find x (if c < 0 then l else r)



let of_list l =
  match l with
  | [] -> empty
  | [x0] -> singleton x0
  | [x0; x1] -> add x1 (singleton x0)
  | [x0; x1; x2] -> add x2 (add x1 (singleton x0))
  | [x0; x1; x2; x3] -> add x3 (add x2 (add x1 (singleton x0)))
  | [x0; x1; x2; x3; x4] -> add x4 (add x3 (add x2 (add x1 (singleton x0))))
  | _ -> of_sorted_list (List.sort_uniq compare_elt l)

let of_array l = 
  Array.fold_left (fun  acc x -> add x acc) empty l

(* also check order *)
let invariant t =
  Set_gen.check t ;
  Set_gen.is_ordered compare_elt t          






end
module Js_call_info : sig 
#1 "js_call_info.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Type for collecting call site information, used in JS IR *) 

type arity = 
  | Full 
  | NA 


type call_info = 
  | Call_ml (* called by plain ocaml expression *)
  | Call_builtin_runtime (* built-in externals *)
  | Call_na 
  (* either from [@@bs.val] or not available, 
     such calls does not follow such rules
     {[ fun x y -> f x y === f ]} when [f] is an atom     
  *) 


type t = { 
  call_info : call_info;
  arity : arity;

}

val dummy : t
val builtin_runtime_call : t

val ml_full_call : t 

end = struct
#1 "js_call_info.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








type arity = 
  | Full 
  | NA 

type call_info = 
  | Call_ml (* called by plain ocaml expression *)
  | Call_builtin_runtime (* built-in externals *)
  | Call_na 
  (* either from [@@bs.val] or not available, 
     such calls does not follow such rules
     {[ fun x y -> (f x y) === f ]} when [f] is an atom     

  *) 

type t = { 
  call_info : call_info;
  arity : arity
}

let dummy = { arity = NA; call_info = Call_na }

let builtin_runtime_call = {arity = Full; call_info = Call_builtin_runtime}

let ml_full_call = {arity = Full; call_info = Call_ml}

end
module Js_closure : sig 
#1 "js_closure.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Define a type used in JS IR to help convert lexical scope to JS [var] 
    based scope convention
 *)

type t = {
  mutable outer_loop_mutable_values :  Ident_set.t 
}

val empty : unit -> t

val get_lexical_scope : t -> Ident_set.t

val set_lexical_scope : t -> Ident_set.t -> unit

end = struct
#1 "js_closure.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








type t = {
  mutable outer_loop_mutable_values :  Ident_set.t ;
}

let empty () = {
  outer_loop_mutable_values  = Ident_set.empty
}

let set_lexical_scope t v = t.outer_loop_mutable_values <- v 

let get_lexical_scope t = t.outer_loop_mutable_values 

end
module Js_fun_env : sig 
#1 "js_fun_env.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Define type t used in JS IR to collect some meta data for a function, like its closures, etc 
  *)

type t 

val empty :  ?immutable_mask:bool array  -> int -> t

val is_tailcalled : t -> bool

val is_empty : t -> bool 

val set_unbounded :  t -> Ident_set.t -> unit



val set_lexical_scope : t -> Ident_set.t -> unit

val get_lexical_scope : t -> Ident_set.t

val to_string : t -> string

val mark_unused : t -> int -> unit 

val get_unused : t -> int -> bool

val get_mutable_params : Ident.t list -> t -> Ident.t list

val get_unbounded : t -> Ident_set.t

val get_length : t -> int

end = struct
#1 "js_fun_env.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(* Make it mutable so that we can do
   in-place change without constructing a new one
  -- however, it's a design choice -- to be reviewed later
*)

type immutable_mask = 
  | All_immutable_and_no_tail_call 
     (** iff not tailcalled 
         if tailcalled, in theory, it does not need change params, 
         for example
         {[
         let rec f  (n : int ref) = 
            if !n > 0 then decr n; print_endline "hi"
            else  f n
         ]}
         in this case, we still create [Immutable_mask], 
         since the inline behavior is slightly different
      *)
  | Immutable_mask of bool array

type t = { 
  mutable unbounded : Ident_set.t;
  mutable bound_loop_mutable_values : Ident_set.t; 
  used_mask : bool array;
  immutable_mask : immutable_mask; 
}
(** Invariant: unused param has to be immutable *)

let empty ?immutable_mask n = { 
  unbounded =  Ident_set.empty ;
  used_mask = Array.make n false;
  immutable_mask = 
    (match immutable_mask with 
     | Some x -> Immutable_mask x 
     | None -> All_immutable_and_no_tail_call
    );
  bound_loop_mutable_values =Ident_set.empty;
}

let is_tailcalled x = x.immutable_mask <> All_immutable_and_no_tail_call

let mark_unused  t i = 
  t.used_mask.(i) <- true

let get_unused t i = 
  t.used_mask.(i)

let get_length t = Array.length t.used_mask

let to_string env =  
  String.concat "," 
    (Ext_list.map (fun (id : Ident.t) -> Printf.sprintf "%s/%d" id.name id.stamp)
       (Ident_set.elements  env.unbounded ))

let get_mutable_params (params : Ident.t list) (x : t ) = 
  match x.immutable_mask with 
  | All_immutable_and_no_tail_call -> []
  | Immutable_mask xs -> 
      Ext_list.filter_mapi 
        (fun i p -> if not xs.(i) then Some p else None)  params


let get_unbounded t = t.unbounded

let set_unbounded env v = 
  (* Ext_log.err "%s -- set @." (to_string env); *)
  (* if Ident_set.is_empty env.bound then *)
  env.unbounded <- v 
 (* else assert false *)

let set_lexical_scope env bound_loop_mutable_values = 
  env.bound_loop_mutable_values <- bound_loop_mutable_values

let get_lexical_scope env =  
  env.bound_loop_mutable_values

(* TODO:  can be refined if it 
    only enclose toplevel variables 
 *)
let is_empty t = Ident_set.is_empty t.unbounded

end
module Lambda : sig 
#1 "lambda.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* The "lambda" intermediate code *)

open Asttypes

type compile_time_constant =
  | Big_endian
  | Word_size
  | Ostype_unix
  | Ostype_win32
  | Ostype_cygwin

type loc_kind =
  | Loc_FILE
  | Loc_LINE
  | Loc_MODULE
  | Loc_LOC
  | Loc_POS



type tag_info = 
  | Blk_constructor of string * int (* Number of non-const constructors*)
  | Blk_tuple
  | Blk_array
  | Blk_variant of string 
  | Blk_record of string array
  | Blk_module of string list option
  | Blk_exception
  | Blk_extension
  | Blk_na

val default_tag_info : tag_info

type field_dbg_info = 
  | Fld_na
  | Fld_record of string
  | Fld_module of string 

type set_field_dbg_info = 
  | Fld_set_na
  | Fld_record_set of string 

type pointer_info = 
  | Pt_constructor of string
  | Pt_variant of string 
  | Pt_module_alias
  | Pt_na 

val default_pointer_info : pointer_info

type primitive =
  | Pidentity
  | Pbytes_to_string
  | Pbytes_of_string
  | Pignore
  | Prevapply 
  | Pdirapply
  | Ploc of loc_kind
    (* Globals *)
  | Pgetglobal of Ident.t
  | Psetglobal of Ident.t
  (* Operations on heap blocks *)
  | Pmakeblock of int * tag_info * mutable_flag
  | Pfield of int * field_dbg_info
  | Psetfield of int * bool * set_field_dbg_info
  (* could have field info at least for record *)
  | Pfloatfield of int * field_dbg_info
  | Psetfloatfield of int * set_field_dbg_info
  | Pduprecord of Types.record_representation * int
  (* Force lazy values *)
  | Plazyforce
  (* External call *)
  | Pccall of Primitive.description
  (* Exceptions *)
  | Praise of raise_kind
  (* Boolean operations *)
  | Psequand | Psequor | Pnot
  (* Integer operations *)
  | Pnegint | Paddint | Psubint | Pmulint | Pdivint | Pmodint
  | Pandint | Porint | Pxorint
  | Plslint | Plsrint | Pasrint
  | Pintcomp of comparison
  | Poffsetint of int
  | Poffsetref of int
  (* Float operations *)
  | Pintoffloat | Pfloatofint
  | Pnegfloat | Pabsfloat
  | Paddfloat | Psubfloat | Pmulfloat | Pdivfloat
  | Pfloatcomp of comparison
  (* String operations *)
  | Pstringlength 
  | Pstringrefu 
  | Pstringsetu
  | Pstringrefs
  | Pstringsets

  | Pbyteslength
  | Pbytesrefu
  | Pbytessetu 
  | Pbytesrefs
  | Pbytessets
  (* Array operations *)
  | Pmakearray of array_kind
  | Parraylength of array_kind
  | Parrayrefu of array_kind
  | Parraysetu of array_kind
  | Parrayrefs of array_kind
  | Parraysets of array_kind
  (* Test if the argument is a block or an immediate integer *)
  | Pisint
  (* Test if the (integer) argument is outside an interval *)
  | Pisout
  (* Bitvect operations *)
  | Pbittest
  (* Operations on boxed integers (Nativeint.t, Int32.t, Int64.t) *)
  | Pbintofint of boxed_integer
  | Pintofbint of boxed_integer
  | Pcvtbint of boxed_integer (*source*) * boxed_integer (*destination*)
  | Pnegbint of boxed_integer
  | Paddbint of boxed_integer
  | Psubbint of boxed_integer
  | Pmulbint of boxed_integer
  | Pdivbint of boxed_integer
  | Pmodbint of boxed_integer
  | Pandbint of boxed_integer
  | Porbint of boxed_integer
  | Pxorbint of boxed_integer
  | Plslbint of boxed_integer
  | Plsrbint of boxed_integer
  | Pasrbint of boxed_integer
  | Pbintcomp of boxed_integer * comparison
  (* Operations on big arrays: (unsafe, #dimensions, kind, layout) *)
  | Pbigarrayref of bool * int * bigarray_kind * bigarray_layout
  | Pbigarrayset of bool * int * bigarray_kind * bigarray_layout
  (* size of the nth dimension of a big array *)
  | Pbigarraydim of int
  (* load/set 16,32,64 bits from a string: (unsafe)*)
  | Pstring_load_16 of bool
  | Pstring_load_32 of bool
  | Pstring_load_64 of bool
  | Pstring_set_16 of bool
  | Pstring_set_32 of bool
  | Pstring_set_64 of bool
  (* load/set 16,32,64 bits from a
     (char, int8_unsigned_elt, c_layout) Bigarray.Array1.t : (unsafe) *)
  | Pbigstring_load_16 of bool
  | Pbigstring_load_32 of bool
  | Pbigstring_load_64 of bool
  | Pbigstring_set_16 of bool
  | Pbigstring_set_32 of bool
  | Pbigstring_set_64 of bool
  (* Compile time constants *)
  | Pctconst of compile_time_constant
  (* byte swap *)
  | Pbswap16
  | Pbbswap of boxed_integer
  (* Integer to external pointer *)
  | Pint_as_pointer

and comparison =
    Ceq | Cneq | Clt | Cgt | Cle | Cge

and array_kind =
    Pgenarray | Paddrarray | Pintarray | Pfloatarray

and boxed_integer =
    Pnativeint | Pint32 | Pint64

and bigarray_kind =
    Pbigarray_unknown
  | Pbigarray_float32 | Pbigarray_float64
  | Pbigarray_sint8 | Pbigarray_uint8
  | Pbigarray_sint16 | Pbigarray_uint16
  | Pbigarray_int32 | Pbigarray_int64
  | Pbigarray_caml_int | Pbigarray_native_int
  | Pbigarray_complex32 | Pbigarray_complex64

and bigarray_layout =
    Pbigarray_unknown_layout
  | Pbigarray_c_layout
  | Pbigarray_fortran_layout

and raise_kind =
  | Raise_regular
  | Raise_reraise
  | Raise_notrace

type structured_constant =
    Const_base of constant
  | Const_pointer of int * pointer_info
  | Const_block of int * tag_info * structured_constant list
  | Const_float_array of string list
  | Const_immstring of string

type function_kind = Curried | Tupled

type let_kind = Strict | Alias | StrictOpt | Variable
(* Meaning of kinds for let x = e in e':
    Strict: e may have side-effets; always evaluate e first
      (If e is a simple expression, e.g. a variable or constant,
       we may still substitute e'[x/e].)
    Alias: e is pure, we can substitute e'[x/e] if x has 0 or 1 occurrences
      in e'
    StrictOpt: e does not have side-effects, but depend on the store;
      we can discard e if x does not appear in e'
    Variable: the variable x is assigned later in e' *)
type public_info = string option  (* label name *)

type meth_kind = Self | Public of public_info | Cached

type shared_code = (int * int) list     (* stack size -> code label *)


type lambda =
    Lvar of Ident.t
  | Lconst of structured_constant
  | Lapply of lambda * lambda list * Location.t
  | Lfunction of function_kind * Ident.t list * lambda
  | Llet of let_kind * Ident.t * lambda * lambda
  | Lletrec of (Ident.t * lambda) list * lambda
  | Lprim of primitive * lambda list * Location.t
  | Lswitch of lambda * lambda_switch
(* switch on strings, clauses are sorted by string order,
   strings are pairwise distinct *)
  | Lstringswitch of lambda * (string * lambda) list * lambda option * Location.t
  | Lstaticraise of int * lambda list
  | Lstaticcatch of lambda * (int * Ident.t list) * lambda
  | Ltrywith of lambda * Ident.t * lambda
  | Lifthenelse of lambda * lambda * lambda
  | Lsequence of lambda * lambda
  | Lwhile of lambda * lambda
  | Lfor of Ident.t * lambda * lambda * direction_flag * lambda
  | Lassign of Ident.t * lambda
  | Lsend of meth_kind * lambda * lambda * lambda list * Location.t
  | Levent of lambda * lambda_event
  | Lifused of Ident.t * lambda

and lambda_switch =
  { sw_numconsts: int;                  (* Number of integer cases *)
    sw_consts: (int * lambda) list;     (* Integer cases *)
    sw_numblocks: int;                  (* Number of tag block cases *)
    sw_blocks: (int * lambda) list;     (* Tag block cases *)
    sw_failaction : lambda option}      (* Action to take if failure *)
and lambda_event =
  { lev_loc: Location.t;
    lev_kind: lambda_event_kind;
    lev_repr: int ref option;
    lev_env: Env.summary }

and lambda_event_kind =
    Lev_before
  | Lev_after of Types.type_expr
  | Lev_function

(* Sharing key *)
val make_key: lambda -> lambda option

val const_unit: structured_constant
val lambda_unit: lambda
val name_lambda: let_kind -> lambda -> (Ident.t -> lambda) -> lambda
val name_lambda_list: lambda list -> (lambda list -> lambda) -> lambda

val iter: (lambda -> unit) -> lambda -> unit
module IdentSet: Set.S with type elt = Ident.t
val free_variables: lambda -> IdentSet.t
val free_methods: lambda -> IdentSet.t

val transl_normal_path: Path.t -> lambda   (* Path.t is already normal *)
val transl_path: ?loc:Location.t -> Env.t -> Path.t -> lambda
val make_sequence: ('a -> lambda) -> 'a list -> lambda

val subst_lambda: lambda Ident.tbl -> lambda -> lambda
val bind : let_kind -> Ident.t -> lambda -> lambda -> lambda

val commute_comparison : comparison -> comparison
val negate_comparison : comparison -> comparison

(***********************)
(* For static failures *)
(***********************)

(* Get a new static failure ident *)
val next_raise_count : unit -> int
val next_negative_raise_count : unit -> int
  (* Negative raise counts are used to compile 'match ... with
     exception x -> ...'.  This disabled some simplifications
     performed by the Simplif module that assume that static raises
     are in tail position in their handler. *)

val staticfail : lambda (* Anticipated static failure *)

(* Check anticipated failure, substitute its final value *)
val is_guarded: lambda -> bool
val patch_guarded : lambda -> lambda -> lambda

val raise_kind: raise_kind -> string
val lam_of_loc : loc_kind -> Location.t -> lambda

val reset: unit -> unit

end = struct
#1 "lambda.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Misc
open Path
open Asttypes

type compile_time_constant =
  | Big_endian
  | Word_size
  | Ostype_unix
  | Ostype_win32
  | Ostype_cygwin

type loc_kind =
  | Loc_FILE
  | Loc_LINE
  | Loc_MODULE
  | Loc_LOC
  | Loc_POS

type tag_info = 
  | Blk_constructor of string * int (* Number of non-const constructors*)
  | Blk_tuple
  | Blk_array
  | Blk_variant of string 
  | Blk_record of string array (* when its empty means we dont get such information *)
  | Blk_module of string list option
  | Blk_exception
  | Blk_extension
  | Blk_na

let default_tag_info : tag_info = Blk_na

type field_dbg_info = 
  | Fld_na
  | Fld_record of string
  | Fld_module of string 

type set_field_dbg_info = 
  | Fld_set_na
  | Fld_record_set of string 

type primitive =
  | Pidentity
  | Pbytes_to_string
  | Pbytes_of_string
  | Pignore
  | Prevapply 
  | Pdirapply 
  | Ploc of loc_kind
    (* Globals *)
  | Pgetglobal of Ident.t
  | Psetglobal of Ident.t
  (* Operations on heap blocks *)
  | Pmakeblock of int * tag_info * mutable_flag
  | Pfield of int * field_dbg_info
  | Psetfield of int * bool * set_field_dbg_info
  | Pfloatfield of int * field_dbg_info
  | Psetfloatfield of int * set_field_dbg_info
  | Pduprecord of Types.record_representation * int
  (* Force lazy values *)
  | Plazyforce
  (* External call *)
  | Pccall of  Primitive.description
  (* Exceptions *)
  | Praise of raise_kind
  (* Boolean operations *)
  | Psequand | Psequor | Pnot
  (* Integer operations *)
  | Pnegint | Paddint | Psubint | Pmulint | Pdivint | Pmodint
  | Pandint | Porint | Pxorint
  | Plslint | Plsrint | Pasrint
  | Pintcomp of comparison
  | Poffsetint of int
  | Poffsetref of int
  (* Float operations *)
  | Pintoffloat | Pfloatofint
  | Pnegfloat | Pabsfloat
  | Paddfloat | Psubfloat | Pmulfloat | Pdivfloat
  | Pfloatcomp of comparison
  (* String operations *)
  | Pstringlength 
  | Pstringrefu 
  | Pstringsetu
  | Pstringrefs
  | Pstringsets

  | Pbyteslength
  | Pbytesrefu
  | Pbytessetu 
  | Pbytesrefs
  | Pbytessets
  (* Array operations *)
  | Pmakearray of array_kind
  | Parraylength of array_kind
  | Parrayrefu of array_kind
  | Parraysetu of array_kind
  | Parrayrefs of array_kind
  | Parraysets of array_kind
  (* Test if the argument is a block or an immediate integer *)
  | Pisint
  (* Test if the (integer) argument is outside an interval *)
  | Pisout
  (* Bitvect operations *)
  | Pbittest
  (* Operations on boxed integers (Nativeint.t, Int32.t, Int64.t) *)
  | Pbintofint of boxed_integer
  | Pintofbint of boxed_integer
  | Pcvtbint of boxed_integer (*source*) * boxed_integer (*destination*)
  | Pnegbint of boxed_integer
  | Paddbint of boxed_integer
  | Psubbint of boxed_integer
  | Pmulbint of boxed_integer
  | Pdivbint of boxed_integer
  | Pmodbint of boxed_integer
  | Pandbint of boxed_integer
  | Porbint of boxed_integer
  | Pxorbint of boxed_integer
  | Plslbint of boxed_integer
  | Plsrbint of boxed_integer
  | Pasrbint of boxed_integer
  | Pbintcomp of boxed_integer * comparison
  (* Operations on big arrays: (unsafe, #dimensions, kind, layout) *)
  | Pbigarrayref of bool * int * bigarray_kind * bigarray_layout
  | Pbigarrayset of bool * int * bigarray_kind * bigarray_layout
  (* size of the nth dimension of a big array *)
  | Pbigarraydim of int
  (* load/set 16,32,64 bits from a string: (unsafe)*)
  | Pstring_load_16 of bool
  | Pstring_load_32 of bool
  | Pstring_load_64 of bool
  | Pstring_set_16 of bool
  | Pstring_set_32 of bool
  | Pstring_set_64 of bool
  (* load/set 16,32,64 bits from a
     (char, int8_unsigned_elt, c_layout) Bigarray.Array1.t : (unsafe) *)
  | Pbigstring_load_16 of bool
  | Pbigstring_load_32 of bool
  | Pbigstring_load_64 of bool
  | Pbigstring_set_16 of bool
  | Pbigstring_set_32 of bool
  | Pbigstring_set_64 of bool
  (* Compile time constants *)
  | Pctconst of compile_time_constant
  (* byte swap *)
  | Pbswap16
  | Pbbswap of boxed_integer
  (* Integer to external pointer *)
  | Pint_as_pointer

and comparison =
    Ceq | Cneq | Clt | Cgt | Cle | Cge

and array_kind =
    Pgenarray | Paddrarray | Pintarray | Pfloatarray

and boxed_integer =
    Pnativeint | Pint32 | Pint64

and bigarray_kind =
    Pbigarray_unknown
  | Pbigarray_float32 | Pbigarray_float64
  | Pbigarray_sint8 | Pbigarray_uint8
  | Pbigarray_sint16 | Pbigarray_uint16
  | Pbigarray_int32 | Pbigarray_int64
  | Pbigarray_caml_int | Pbigarray_native_int
  | Pbigarray_complex32 | Pbigarray_complex64

and bigarray_layout =
    Pbigarray_unknown_layout
  | Pbigarray_c_layout
  | Pbigarray_fortran_layout

and raise_kind =
  | Raise_regular
  | Raise_reraise
  | Raise_notrace

type pointer_info = 
  | Pt_constructor of string
  | Pt_variant of string 
  | Pt_module_alias
  | Pt_na

let default_pointer_info = Pt_na

type structured_constant =
    Const_base of constant
  | Const_pointer of int * pointer_info
  | Const_block of int * tag_info * structured_constant list
  | Const_float_array of string list
  | Const_immstring of string

type function_kind = Curried | Tupled

type let_kind = Strict | Alias | StrictOpt | Variable

type public_info = string option  (* label name *)

type meth_kind = Self | Public of public_info | Cached



type shared_code = (int * int) list

type lambda =
    Lvar of Ident.t
  | Lconst of structured_constant
  | Lapply of lambda * lambda list * Location.t
  | Lfunction of function_kind * Ident.t list * lambda
  | Llet of let_kind * Ident.t * lambda * lambda
  | Lletrec of (Ident.t * lambda) list * lambda
  | Lprim of primitive * lambda list * Location.t 
  | Lswitch of lambda * lambda_switch
  | Lstringswitch of lambda * (string * lambda) list * lambda option * Location.t
  | Lstaticraise of int * lambda list
  | Lstaticcatch of lambda * (int * Ident.t list) * lambda
  | Ltrywith of lambda * Ident.t * lambda
  | Lifthenelse of lambda * lambda * lambda
  | Lsequence of lambda * lambda
  | Lwhile of lambda * lambda
  | Lfor of Ident.t * lambda * lambda * direction_flag * lambda
  | Lassign of Ident.t * lambda
  | Lsend of meth_kind * lambda * lambda * lambda list * Location.t
  | Levent of lambda * lambda_event
  | Lifused of Ident.t * lambda

and lambda_switch =
  { sw_numconsts: int;
    sw_consts: (int * lambda) list;
    sw_numblocks: int;
    sw_blocks: (int * lambda) list;
    sw_failaction : lambda option}

and lambda_event =
  { lev_loc: Location.t;
    lev_kind: lambda_event_kind;
    lev_repr: int ref option;
    lev_env: Env.summary }

and lambda_event_kind =
    Lev_before
  | Lev_after of Types.type_expr
  | Lev_function

let const_unit = Const_pointer (0, default_pointer_info)

let lambda_unit = Lconst const_unit

(* Build sharing keys *)
(*
   Those keys are later compared with Pervasives.compare.
   For that reason, they should not include cycles.
*)

exception Not_simple

let max_raw = 32

let make_key e =
  let count = ref 0   (* Used for controling size *)
  and make_key = Ident.make_key_generator () in
  (* make_key is used for normalizing let-bound variables *)
  let rec tr_rec env e =
    incr count ;
    if !count > max_raw then raise Not_simple ; (* Too big ! *)
    match e with
    | Lvar id ->
      begin
        try Ident.find_same id env
        with Not_found -> e
      end
    | Lconst  (Const_base (Const_string _)|Const_float_array _) ->
        (* Mutable constants are not shared *)
        raise Not_simple
    | Lconst _ -> e
    | Lapply (e,es,loc) ->
        Lapply (tr_rec env e,tr_recs env es, Location.none)
    | Llet (Alias,x,ex,e) -> (* Ignore aliases -> substitute *)
        let ex = tr_rec env ex in
        tr_rec (Ident.add x ex env) e
    | Llet (str,x,ex,e) ->
     (* Because of side effects, keep other lets with normalized names *)
        let ex = tr_rec env ex in
        let y = make_key x in
        Llet (str,y,ex,tr_rec (Ident.add x (Lvar y) env) e)
    | Lprim (p,es,_) ->
        Lprim (p,tr_recs env es, Location.none)
    | Lswitch (e,sw) ->
        Lswitch (tr_rec env e,tr_sw env sw)
    | Lstringswitch (e,sw,d,_) ->
        Lstringswitch
          (tr_rec env e,
           List.map (fun (s,e) -> s,tr_rec env e) sw,
           tr_opt env d, Location.none)
    | Lstaticraise (i,es) ->
        Lstaticraise (i,tr_recs env es)
    | Lstaticcatch (e1,xs,e2) ->
        Lstaticcatch (tr_rec env e1,xs,tr_rec env e2)
    | Ltrywith (e1,x,e2) ->
        Ltrywith (tr_rec env e1,x,tr_rec env e2)
    | Lifthenelse (cond,ifso,ifnot) ->
        Lifthenelse (tr_rec env cond,tr_rec env ifso,tr_rec env ifnot)
    | Lsequence (e1,e2) ->
        Lsequence (tr_rec env e1,tr_rec env e2)
    | Lassign (x,e) ->
        Lassign (x,tr_rec env e)
    | Lsend (m,e1,e2,es,loc) ->
        Lsend (m,tr_rec env e1,tr_rec env e2,tr_recs env es,Location.none)
    | Lifused (id,e) -> Lifused (id,tr_rec env e)
    | Lletrec _|Lfunction _
    | Lfor _ | Lwhile _
(* Beware: (PR#6412) the event argument to Levent
   may include cyclic structure of type Type.typexpr *)
    | Levent _  ->
        raise Not_simple

  and tr_recs env es = List.map (tr_rec env) es

  and tr_sw env sw =
    { sw with
      sw_consts = List.map (fun (i,e) -> i,tr_rec env e) sw.sw_consts ;
      sw_blocks = List.map (fun (i,e) -> i,tr_rec env e) sw.sw_blocks ;
      sw_failaction = tr_opt env sw.sw_failaction ; }

  and tr_opt env = function
    | None -> None
    | Some e -> Some (tr_rec env e) in

  try
    Some (tr_rec Ident.empty e)
  with Not_simple -> None

(***************)

let name_lambda strict arg fn =
  match arg with
    Lvar id -> fn id
  | _ -> let id = Ident.create "let" in Llet(strict, id, arg, fn id)

let name_lambda_list args fn =
  let rec name_list names = function
    [] -> fn (List.rev names)
  | (Lvar id as arg) :: rem ->
      name_list (arg :: names) rem
  | arg :: rem ->
      let id = Ident.create "let" in
      Llet(Strict, id, arg, name_list (Lvar id :: names) rem) in
  name_list [] args


let iter_opt f = function
  | None -> ()
  | Some e -> f e

let iter f = function
    Lvar _
  | Lconst _ -> ()
  | Lapply(fn, args, _) ->
      f fn; List.iter f args
  | Lfunction(kind, params, body) ->
      f body
  | Llet(str, id, arg, body) ->
      f arg; f body
  | Lletrec(decl, body) ->
      f body;
      List.iter (fun (id, exp) -> f exp) decl
  | Lprim(p, args, _loc) ->
      List.iter f args
  | Lswitch(arg, sw) ->
      f arg;
      List.iter (fun (key, case) -> f case) sw.sw_consts;
      List.iter (fun (key, case) -> f case) sw.sw_blocks;
      iter_opt f sw.sw_failaction
  | Lstringswitch (arg,cases,default,_) ->
      f arg ;
      List.iter (fun (_,act) -> f act) cases ;
      iter_opt f default
  | Lstaticraise (_,args) ->
      List.iter f args
  | Lstaticcatch(e1, (_,vars), e2) ->
      f e1; f e2
  | Ltrywith(e1, exn, e2) ->
      f e1; f e2
  | Lifthenelse(e1, e2, e3) ->
      f e1; f e2; f e3
  | Lsequence(e1, e2) ->
      f e1; f e2
  | Lwhile(e1, e2) ->
      f e1; f e2
  | Lfor(v, e1, e2, dir, e3) ->
      f e1; f e2; f e3
  | Lassign(id, e) ->
      f e
  | Lsend (k, met, obj, args, _) ->
      List.iter f (met::obj::args)
  | Levent (lam, evt) ->
      f lam
  | Lifused (v, e) ->
      f e


module IdentSet =
  Set.Make(struct
    type t = Ident.t
    let compare = compare
  end)

let free_ids get l =
  let fv = ref IdentSet.empty in
  let rec free l =
    iter free l;
    fv := List.fold_right IdentSet.add (get l) !fv;
    match l with
      Lfunction(kind, params, body) ->
        List.iter (fun param -> fv := IdentSet.remove param !fv) params
    | Llet(str, id, arg, body) ->
        fv := IdentSet.remove id !fv
    | Lletrec(decl, body) ->
        List.iter (fun (id, exp) -> fv := IdentSet.remove id !fv) decl
    | Lstaticcatch(e1, (_,vars), e2) ->
        List.iter (fun id -> fv := IdentSet.remove id !fv) vars
    | Ltrywith(e1, exn, e2) ->
        fv := IdentSet.remove exn !fv
    | Lfor(v, e1, e2, dir, e3) ->
        fv := IdentSet.remove v !fv
    | Lassign(id, e) ->
        fv := IdentSet.add id !fv
    | Lvar _ | Lconst _ | Lapply _
    | Lprim _ | Lswitch _ | Lstringswitch _ | Lstaticraise _
    | Lifthenelse _ | Lsequence _ | Lwhile _
    | Lsend _ | Levent _ | Lifused _ -> ()
  in free l; !fv

let free_variables l =
  free_ids (function Lvar id -> [id] | _ -> []) l

let free_methods l =
  free_ids (function Lsend(Self, Lvar meth, obj, _, _) -> [meth] | _ -> []) l

(* Check if an action has a "when" guard *)
let raise_count = ref 0

let next_raise_count () =
  incr raise_count ;
  !raise_count

let negative_raise_count = ref 0

let next_negative_raise_count () =
  decr negative_raise_count ;
  !negative_raise_count

(* Anticipated staticraise, for guards *)
let staticfail = Lstaticraise (0,[])

let rec is_guarded = function
  | Lifthenelse( cond, body, Lstaticraise (0,[])) -> true
  | Llet(str, id, lam, body) -> is_guarded body
  | Levent(lam, ev) -> is_guarded lam
  | _ -> false

let rec patch_guarded patch = function
  | Lifthenelse (cond, body, Lstaticraise (0,[])) ->
      Lifthenelse (cond, body, patch)
  | Llet(str, id, lam, body) ->
      Llet (str, id, lam, patch_guarded patch body)
  | Levent(lam, ev) ->
      Levent (patch_guarded patch lam, ev)
  | _ -> fatal_error "Lambda.patch_guarded"

(* Translate an access path *)

let rec transl_normal_path = function
    Pident id ->
      if Ident.global id then Lprim(Pgetglobal id, [], Location.none) else Lvar id
  | Pdot(p, s, pos) ->
      Lprim(Pfield (pos, Fld_module s ), [transl_normal_path p],Location.none)
  | Papply(p1, p2) ->
      fatal_error "Lambda.transl_path"

(* Translation of value identifiers *)

let transl_path ?(loc=Location.none) env path =
  transl_normal_path (Env.normalize_path (Some loc) env path)

(* Compile a sequence of expressions *)

let rec make_sequence fn = function
    [] -> lambda_unit
  | [x] -> fn x
  | x::rem ->
      let lam = fn x in Lsequence(lam, make_sequence fn rem)

(* Apply a substitution to a lambda-term.
   Assumes that the bound variables of the lambda-term do not
   belong to the domain of the substitution.
   Assumes that the image of the substitution is out of reach
   of the bound variables of the lambda-term (no capture). *)

let subst_lambda s lam =
  let rec subst = function
    Lvar id as l ->
      begin try Ident.find_same id s with Not_found -> l end
  | Lconst sc as l -> l
  | Lapply(fn, args, loc) -> Lapply(subst fn, List.map subst args, loc)
  | Lfunction(kind, params, body) -> Lfunction(kind, params, subst body)
  | Llet(str, id, arg, body) -> Llet(str, id, subst arg, subst body)
  | Lletrec(decl, body) -> Lletrec(List.map subst_decl decl, subst body)
  | Lprim(p, args, loc) -> Lprim(p, List.map subst args, loc)
  | Lswitch(arg, sw) ->
      Lswitch(subst arg,
              {sw with sw_consts = List.map subst_case sw.sw_consts;
                       sw_blocks = List.map subst_case sw.sw_blocks;
                       sw_failaction = subst_opt  sw.sw_failaction; })
  | Lstringswitch (arg,cases,default,loc) ->
      Lstringswitch
        (subst arg,List.map subst_strcase cases,subst_opt default, loc)
  | Lstaticraise (i,args) ->  Lstaticraise (i, List.map subst args)
  | Lstaticcatch(e1, io, e2) -> Lstaticcatch(subst e1, io, subst e2)
  | Ltrywith(e1, exn, e2) -> Ltrywith(subst e1, exn, subst e2)
  | Lifthenelse(e1, e2, e3) -> Lifthenelse(subst e1, subst e2, subst e3)
  | Lsequence(e1, e2) -> Lsequence(subst e1, subst e2)
  | Lwhile(e1, e2) -> Lwhile(subst e1, subst e2)
  | Lfor(v, e1, e2, dir, e3) -> Lfor(v, subst e1, subst e2, dir, subst e3)
  | Lassign(id, e) -> Lassign(id, subst e)
  | Lsend (k, met, obj, args, loc) ->
      Lsend (k, subst met, subst obj, List.map subst args, loc)
  | Levent (lam, evt) -> Levent (subst lam, evt)
  | Lifused (v, e) -> Lifused (v, subst e)
  and subst_decl (id, exp) = (id, subst exp)
  and subst_case (key, case) = (key, subst case)
  and subst_strcase (key, case) = (key, subst case)
  and subst_opt = function
    | None -> None
    | Some e -> Some (subst e)
  in subst lam


(* To let-bind expressions to variables *)

let bind str var exp body =
  match exp with
    Lvar var' when Ident.same var var' -> body
  | _ -> Llet(str, var, exp, body)

and commute_comparison = function
| Ceq -> Ceq| Cneq -> Cneq
| Clt -> Cgt | Cle -> Cge
| Cgt -> Clt | Cge -> Cle

and negate_comparison = function
| Ceq -> Cneq| Cneq -> Ceq
| Clt -> Cge | Cle -> Cgt
| Cgt -> Cle | Cge -> Clt

let raise_kind = function
  | Raise_regular -> "raise"
  | Raise_reraise -> "reraise"
  | Raise_notrace -> "raise_notrace"

let lam_of_loc kind loc =
  let loc_start = loc.Location.loc_start in
  let (file, lnum, cnum) = Location.get_pos_info loc_start in
  let enum = loc.Location.loc_end.Lexing.pos_cnum -
      loc_start.Lexing.pos_cnum + cnum in
  match kind with
  | Loc_POS ->
    Lconst (Const_block (0, Blk_tuple, [
          Const_immstring file;
          Const_base (Const_int lnum);
          Const_base (Const_int cnum);
          Const_base (Const_int enum);
        ]))
  | Loc_FILE -> Lconst (Const_immstring file)
  | Loc_MODULE ->
    let filename = Filename.basename file in
    let name = Env.get_unit_name () in
    let module_name = if name = "" then "//"^filename^"//" else name in
    Lconst (Const_immstring module_name)
  | Loc_LOC ->
    let loc = Printf.sprintf "File %S, line %d, characters %d-%d"
        file lnum cnum enum in
    Lconst (Const_immstring loc)
  | Loc_LINE -> Lconst (Const_base (Const_int lnum))

let reset () =
  raise_count := 0

end
module Js_op
= struct
#1 "js_op.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)










(** Define some basic types used in JS IR *)

type binop =
  | Eq  
  (* acutally assignment ..
     TODO: move it into statement, so that all expressions 
     are side efffect free (except function calls)
   *)

  | Or
  | And
  | EqEqEq
  | NotEqEq
  | InstanceOf

  | Lt
  | Le
  | Gt
  | Ge

  | Bor
  | Bxor
  | Band
  | Lsl
  | Lsr
  | Asr

  | Plus
  | Minus
  | Mul
  | Div
  | Mod

(**
note that we don't need raise [Div_by_zero] in BuckleScript

{[
let add x y = x + y  (* | 0 *)
let minus x y = x - y (* | 0 *)
let mul x y = x * y   (* caml_mul | Math.imul *)
let div x y = x / y (* caml_div (x/y|0)*)
let imod x y = x mod y  (* caml_mod (x%y) (zero_divide)*)

let bor x y = x lor y   (* x  | y *)
let bxor x y = x lxor y (* x ^ y *)
let band x y = x land y (* x & y *)
let ilnot  y  = lnot y (* let lnot x = x lxor (-1) *)
let ilsl x y = x lsl y (* x << y*)
let ilsr x y = x lsr y  (* x >>> y | 0 *)
let iasr  x y = x asr y (* x >> y *)
]}


Note that js treat unsigned shift 0 bits in a special way
   Unsigned shifts convert their left-hand side to Uint32, 
   signed shifts convert it to Int32.
   Shifting by 0 digits returns the converted value.
   {[
    function ToUint32(x) {
        return x >>> 0;
    }
    function ToInt32(x) {
        return x >> 0;
    }
   ]}
   So in Js, [-1 >>>0] will be the largest Uint32, while [-1>>0] will remain [-1]
   and [-1 >>> 0 >> 0 ] will be [-1]
*)
type int_op = 
    
  | Bor
  | Bxor
  | Band
  | Lsl
  | Lsr
  | Asr

  | Plus
      (* for [+], given two numbers 
         x + y | 0
       *)
  | Minus
      (* x - y | 0 *)
  | Mul
      (* *)
  | Div
      (* x / y | 0 *)
  | Mod
      (* x  % y *)

(* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Bitwise_operators
    {[
    ~
    ]}
    ~0xff -> -256
    design; make sure each operation type is consistent
 *)
type level = 
  | Log 
  | Info
  | Warn
  | Error

type kind = 
  | Ml
  | Runtime 
  | External of string

type property = Lambda.let_kind = 
  | Strict
  | Alias
  | StrictOpt 
  | Variable


type property_name = (* private *)
  (* TODO: FIXME [caml_uninitialized_obj] seems to be a bug*)
  | Key of string
  | Int_key of int 
  | Tag 
  | Length

type 'a access = 
  | Getter
  | Setter
type jsint = Int32.t

type int_or_char = 
    { i : jsint; 
      (* we can not use [int] on 32 bit platform, if we dont use 
          [Int32.t], we need a configuration step          
      *)
      c : char option
    }

 (* literal char *)
type float_lit = { f :  string }
type number = 
  | Float of float_lit 
  | Int of int_or_char
  | Uint of int32
  | Nint of nativeint
  (* becareful when constant folding +/-, 
     since we treat it as js nativeint, bitwise operators:
     https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators
     The operands of all bitwise operators are converted to signed 32-bit integers in two's complement format.'
  *)      

type mutable_flag = 
  | Mutable
  | Immutable
  | NA

(* 
    {[
    let rec x = 1 :: y 
    and y = 1 :: x
    ]}
 *)
type recursive_info = 
  | SingleRecursive 
  | NonRecursie
  | NA

type used_stats = 
  | Dead_pure 
        (* only [Dead] should be taken serious, 
            other status can be converted during
            inlining
            -- all exported symbols can not be dead
            -- once a symbole is called Dead_pure, 
            it can not be alive anymore, we should avoid iterating it
            
          *)
  | Dead_non_pure 
      (* we still need iterating it, 
         just its bindings does not make sense any more *)
  | Exported (* Once it's exported, shall we change its status anymore? *)
      (* In general, we should count in one pass, and eliminate code in another 
         pass, you can not do it in a single pass, however, some simple 
         dead code can be detected in a single pass
       *)
  | Once_pure (* used only once so that, if we do the inlining, it will be [Dead] *)
  | Used (**)
  | Scanning_pure
  | Scanning_non_pure
  | NA


type ident_info = {
    (* mutable recursive_info : recursive_info; *)
    mutable used_stats : used_stats;
  }

type exports = Ident.t list 

type module_id = { id : Ident.t; kind  : kind}

type required_modules = module_id list


type tag_info = Lambda.tag_info = 
  | Blk_constructor of string * int
  | Blk_tuple
  | Blk_array
  | Blk_variant of string 
  | Blk_record of string array
  | Blk_module of string list option
  | Blk_exception
  | Blk_extension
  | Blk_na

type length_object = 
  | Array 
  | String
  | Bytes
  | Function
  | Caml_block

type code_info = 
  | Exp (* of int option *)
  | Stmt
(** TODO: define constant - for better constant folding  *)
(* type constant =  *)
(*   | Const_int of int *)
(*   | Const_ *)

end
module J
= struct
#1 "j.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Javascript IR
  
    It's a subset of Javascript AST specialized for OCaml lambda backend

    Note it's not exactly the same as Javascript, the AST itself follows lexical
    convention and [Block] is just a sequence of statements, which means it does 
    not introduce new scope
*)

type label = string

and binop = Js_op.binop

and int_op = Js_op.int_op
 
and kind = Js_op.kind

and property = Js_op.property

and number = Js_op.number 

and mutable_flag = Js_op.mutable_flag 

and ident_info = Js_op.ident_info

and exports = Js_op.exports

and tag_info = Js_op.tag_info 
 
and required_modules = Js_op.required_modules

and code_info = Js_op.code_info 
(** object literal, if key is ident, in this case, it might be renamed by 
    Google Closure  optimizer,
    currently we always use quote
 *)
and property_name =  Js_op.property_name
and jsint = Js_op.jsint
and ident = Ident.t 

and vident = 
  | Id of ident
  | Qualified of ident * kind * string option
    (* Since camldot is only available for toplevel module accessors,
       we don't need print  `A.length$2`
       just print `A.length` - it's guarateed to be unique
       
       when the third one is None, it means the whole module 

       TODO: 
       invariant, when [kind] is [Runtime], then we can ignore [ident], 
       since all [runtime] functions are unique, when do the 
       pattern match we can ignore the first one for simplicity
       for example       
       {[
         Qualified (_, Runtime, Some "caml_int_compare")         
       ]}       
     *)

and exception_ident = ident 

and for_ident = ident 

and for_direction = Asttypes.direction_flag

and property_map = 
    (property_name * expression) list
and length_object = Js_op.length_object
and expression_desc =
  | Math of string * expression list
  | Length of expression * length_object
  | Char_of_int of expression
  | Char_to_int of expression 
  | Is_null_undefined_to_boolean of expression 
    (** where we use a trick [== null ] *)
  | Array_of_size of expression 
    (* used in [#create_array] primitive, note having
       uninitilized array is not as bad as in ocaml, 
       since GC does not rely on it
     *)
  | Array_copy of expression (* shallow copy, like [x.slice] *)
  | Array_append of expression * expression (* For [caml_array_append]*)
  (* | Tag_ml_obj of expression *)
  | String_append of expression * expression 

  | Int_of_boolean of expression 
  | Anything_to_number of expression
  | Bool of bool (* js true/false*)
  (* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence 
     [typeof] is an operator     
  *)
  | Typeof of expression
  | Caml_not of expression (* 1 - v *)
  | Js_not of expression (* !v *)
  | String_of_small_int_array of expression 
    (* String.fromCharCode.apply(null, args) *)
    (* Convert JS boolean into OCaml boolean 
       like [+true], note this ast talks using js
       terminnology unless explicity stated                       
     *)
  | Json_stringify of expression 
  (* TODO: in the future, it might make sense to group primitivie by type,
     which makes optimizations easier
     {[ JSON.stringify(value, replacer[, space]) ]}
  *)
  | Anything_to_string of expression
  (* for debugging utitlites, 
     TODO:  [Dump] is not necessary with this primitive 
     Note that the semantics is slightly different from [JSON.stringify]     
     {[
       JSON.stringify("x")       
     ]}
     {[
       ""x""       
     ]}     
     {[
       JSON.stringify(undefined)       
     ]}     
     {[
       undefined       
     ]}
     {[ '' + undefined
     ]}     
     {[ 'undefined'
     ]}     
  *)      
  | Dump of Js_op.level * expression list
  (* TODO: 
     add 
     {[ Assert of bool * expression ]}     
  *)              
    (* to support 
       val log1 : 'a -> unit
       val log2 : 'a -> 'b -> unit 
       val log3 : 'a -> 'b -> 'c -> unit 
     *)

  (* TODO: Add some primitives so that [js inliner] can do a better job *)  
  | Seq of expression * expression
  | Cond of expression * expression * expression
  | Bin of binop * expression * expression

  (* [int_op] will guarantee return [int32] bits 
     https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators  *)
  (* | Int32_bin of int_op * expression * expression *)
  | FlatCall of expression * expression 
    (* f.apply(null,args) -- Fully applied guaranteed 
       TODO: once we know args's shape --
       if it's know at compile time, we can turn it into
       f(args[0], args[1], ... )
     *)
  | Bind of expression * expression
  (* {[ Bind (a,b) ]}
     is literally
     {[ a.bind(b) ]}
  *)
  | Call of expression * expression list * Js_call_info.t
    (* Analysze over J expression is hard since, 
        some primitive  call is translated 
        into a plain call, it's better to keep them
    *) 
  | String_access of expression * expression 
  | Access of expression * expression 
    (* Invariant: 
       The second argument has to be type of [int],
       This can be constructed either in a static way [E.index] or a dynamic way 
       [E.access]
     *)
  | Dot of expression * string * bool
    (* The third argument bool indicates whether we should 
       print it as 
       a["idd"] -- false
       or 
       a.idd  -- true
       There are several kinds of properties
       1. OCaml module dot (need to be escaped or not)
          All exported declarations have to be OCaml identifiers
       2. Javascript dot (need to be preserved/or using quote)
     *)
  | New of expression * expression list option (* TODO: option remove *)
  | Var of vident
  | Fun of bool * ident list  * block * Js_fun_env.t
  (* The first parameter by default is false, 
     it will be true when it's a method
  *)
  | Str of bool * string 
    (* A string is UTF-8 encoded, the string may contain
       escape sequences.
       The first argument is used to mark it is non-pure, please
       don't optimize it, since it does have side effec, 
       examples like "use asm;" and our compiler may generate "error;..." 
       which is better to leave it alone
       The last argument is passed from as `j` from `{j||j}`
     *)
  | Unicode of string 
    (* It is escaped string, print delimited by '"'*)   
  | Raw_js_code of string * code_info
  (* literally raw JS code 
  *)
  | Array of expression list * mutable_flag
  | Caml_block of expression list * mutable_flag * expression * tag_info 
  (* The third argument is [tag] , forth is [tag_info] *)
  | Caml_uninitialized_obj of expression * expression
  (* [tag] and [size] tailed  for [Obj.new_block] *)

  (* For setter, it still return the value of expression, 
     we can not use 
     {[
       type 'a access = Get | Set of 'a
     ]}
     in another module, since it will break our code generator
     [Caml_block_tag] can return [undefined], 
     you have to use [E.tag] in a safe way     
  *)
  | Caml_block_tag of expression
  | Caml_block_set_tag of expression * expression
  | Caml_block_set_length of expression * expression
  (* It will just fetch tag, to make it safe, when creating it, 
     we need apply "|0", we don't do it in the 
     last step since "|0" can potentially be optimized
  *)      
  | Number of number
  | Object of property_map

and for_ident_expression = expression (* pure*)

and finish_ident_expression = expression (* pure *)
(* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block
   block can be nested, specified in ES3 
 *)

(* Delay some units like [primitive] into JS layer ,
   benefit: better cross module inlining, and smaller IR size?
 *)

(* 
  [closure] captured loop mutable values in the outer loop

  check if it contains loop mutable values, happens in nested loop
  when closured, it's no longer loop mutable value. 
  which means the outer loop mutable value can not peek into the inner loop
  {[
  var i = f ();
  for(var finish = 32; i < finish; ++i){
  }
  ]}
  when [for_ident_expression] is [None], [var i] has to 
  be initialized outside, so 

  {[
  var i = f ()
  (function (xxx){
  for(var finish = 32; i < finish; ++i)
  }(..i))
  ]}
  This happens rare it's okay

  this is because [i] has to be initialized outside, if [j] 
  contains a block side effect
  TODO: create such example
*)

(* Since in OCaml, 
   
  [for i = 0 to k end do done ]
  k is only evaluated once , to encode this invariant in JS IR,
  make sure [ident] is defined in the first b

  TODO: currently we guarantee that [bound] was only 
  excecuted once, should encode this in AST level
*)

(* Can be simplified to keep the semantics of OCaml
   For (var i, e, ...){
     let  j = ... 
   }

   if [i] or [j] is captured inside closure

   for (var i , e, ...){
     (function (){
     })(i)
   }
*)

(* Single return is good for ininling..
   However, when you do tail-call optmization
   you loose the expression oriented semantics
   Block is useful for implementing goto
   {[
   xx:{
   break xx;
   }
   ]}
*)


and statement_desc =
  | Block of block
  | Variable of variable_declaration
        (* Function declaration and Variable declaration  *)
  | Exp of expression
  | If of expression * block * block option
  | While of label option *  expression * block 
        * Js_closure.t (* check if it contains loop mutable values, happens in nested loop *)
  | ForRange of for_ident_expression option * finish_ident_expression * 
        for_ident  *  for_direction * block
        * Js_closure.t  
  | Continue of label 
  | Break (* only used when inline a fucntion *)
  | Return of return_expression   (* Here we need track back a bit ?, move Return to Function ...
                              Then we can only have one Return, which is not good *)
  | Int_switch of expression * int case_clause list * block option 
  | String_switch of expression * string case_clause list * block option 
  | Throw of expression
  | Try of block * (exception_ident * block) option * block option
  | Debugger
and return_expression = {
 (* since in ocaml, it's expression oriented langauge, [return] in
    general has no jumps, it only happens when we do 
    tailcall conversion, in that case there is a jump.
    However, currently  a single [break] is good to cover
    our compilation strategy 

    Attention: we should not insert [break] arbitrarily, otherwise 
    it would break the semantics
    A more robust signature would be 
    {[ goto : label option ; ]}
  *)
  return_value : expression
}   

and expression = {
  expression_desc : expression_desc; 
  comment : string option;
} 

and statement = { 
  statement_desc :  statement_desc; 
  comment : string option;
}

and variable_declaration = { 
  ident : ident ;
  value : expression  option;
  property : property;
  ident_info : ident_info;
}

and 'a case_clause = { 
  case : 'a ; 
  body : block * bool ;  (* true means break *)
}

(* TODO: For efficency: block should not be a list, it should be able to 
   be concatenated in both ways 
 *)
and block =  statement list

and program = {
  name :  string;

  block : block ;
  exports : exports ;
  export_set : Ident_set.t ;

}
and deps_program = 
  {
    program : program ; 
    modules : required_modules ;
    side_effect : string option (* None: no, Some reason  *)
  }

end
module Lam_module_ident : sig 
#1 "lam_module_ident.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)











(** A type for qualified identifiers in Lambda IR 
 *)

type t = Js_op.module_id = private { id : Ident.t ; kind : Js_op.kind }


val id : t -> Ident.t 

val name : t -> string

val mk : J.kind -> Ident.t -> t

val of_ml : Ident.t -> t

val of_external : Ident.t -> string -> t

val of_runtime : Ident.t -> t 

module Hash : Hashtbl_gen.S with type key = t
module Hash_set : Hash_set_gen.S with type key = t
end = struct
#1 "lam_module_ident.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)









type t = Js_op.module_id = 
  { id : Ident.t ; kind : Js_op.kind }



let id x = x.id 

let of_ml id = { id ; kind =  Ml}

let of_external id name =  {id ; kind = External name}

let of_runtime id = { id ; kind = Runtime }

let mk kind id = {id; kind}

let name  x : string  = 
  match (x.kind : J.kind) with 
  | Ml  | Runtime ->  x.id.name
  | External v -> v  

module Cmp = struct 
  type nonrec t = t
  let equal (x : t) y = 
    match x.kind with 
    | External x_kind-> 
      begin match y.kind with 
        | External y_kind -> 
          x_kind = (y_kind : string)
        | _ -> false 
      end
    | Ml 
    | Runtime -> Ext_ident.equal x.id y.id 
  (* #1556
     Note the main difference between [Ml] and [Runtime] is 
     that we have more assumptions about [Runtime] module, 
     like its purity etc, and its name uniqueues, in the pattern match 
     {[
       Qualified (_,Runtime, Some "caml_int_compare")
     ]}
     and we could do more optimziations.
     However, here if it is [hit] 
     (an Ml module = an Runtime module), which means both exists, 
     so adding either does not matter
     if it is not hit, fine
  *)
  (* | Ml -> y.kind = Ml &&  *)
  (* | Runtime ->  *)
  (*   y.kind = Runtime  && Ext_ident.equal x.id y.id *)
  let hash (x : t) = 
    match x.kind with 
    | External x_kind -> Bs_hash_stubs.hash_string x_kind 
    | Ml 
    | Runtime -> 
      let x_id = x.id in 
      Bs_hash_stubs.hash_stamp_and_name x_id.stamp x_id.name 
end

module Hash = Hashtbl_make.Make (Cmp)

module Hash_set = Hash_set.Make (Cmp)

end
module Js_packages_info : sig 
#1 "js_packages_info.mli"
(* Copyright (C) 2017 Authors of BuckleScript
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


type module_system = 
  | NodeJS 
  | AmdJS
  | Es6
  | Es6_global
  | AmdJS_global (* affect [.cmj] format*)

type package_info = 
  module_system * string 

type package_name  = string


type t =
  private {
  name : package_name ;
  module_systems :  package_info  list
}

val empty : t 
val from_name : string -> t 
val is_empty : t -> bool 
val dump_packages_info : 
  Format.formatter -> t -> unit


(** used by command line option *)
val add_npm_package_path : 
  string -> t -> t  



(**
   generate the mdoule path so that it can be spliced here:
   {[
     var Xx = require("package/path/to/xx.js")
   ]}
   Note that it has to be consistent to how it is generated
*)  
val string_of_module_id :
  output_dir:string -> 
  module_system ->
  t ->
  (Lam_module_ident.t ->
   (string * t * bool ) option ) -> 
  Lam_module_ident.t -> string
end = struct
#1 "js_packages_info.ml"
(* Copyright (C) 2017 Authors of BuckleScript
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


type path = string

type module_system =
  | NodeJS 
  | AmdJS 
  | Es6
  | Es6_global (* ignore node_modules, just calcluating relative path *)
  | AmdJS_global (* see ^ *)

(* ocamlopt could not optimize such simple case..*)
let compatible (exist : module_system) 
    (query : module_system) =
  match query with 
  | NodeJS -> exist = NodeJS 
  | AmdJS -> exist = AmdJS
  | Es6  -> exist = Es6
  | Es6_global  
    -> exist = Es6_global || exist = Es6
  | AmdJS_global 
    -> exist = AmdJS_global || exist = AmdJS
(* As a dependency Leaf Node, it is the same either [global] or [not] *)


type package_info =
  module_system * string 

type package_name  = string
type t =
  { 
    name : package_name ;
    module_systems: package_info  list
  }
(* we don't want force people to use package *) 

(** 
   TODO: not allowing user to provide such specific package name 
   For empty package, [-bs-package-output] does not make sense
   it is only allowed to generate commonjs file in the same directory
*)  
let empty = 
  { name = "_";
    module_systems =  []
  }
let from_name name =
  {
    name ;
    module_systems = [] 
  }
let is_empty  (x : t) =
  match x with 
  | { name = "_" } -> true 
  | _ -> false 

let string_of_module_system (ms : module_system) = 
  match ms with 
  | NodeJS -> "NodeJS"
  | AmdJS -> "AmdJS"
  | Es6 -> "Es6"
  | Es6_global -> "Es6_global"
  | AmdJS_global -> "AmdJS_globl"


let module_system_of_string package_name : module_system option = 
  match package_name with
  | "commonjs" -> Some NodeJS
  | "amdjs" -> Some AmdJS
  | "es6" -> Some Es6
  | "es6-global" -> Some Es6_global
  | "amdjs-global" -> Some AmdJS_global 
  | _ -> None 

let dump_package_info 
    (fmt : Format.formatter)
    ((ms, name) : package_info)
  = 
  Format.fprintf
    fmt 
    "@[%s:@ %s@]"
    (string_of_module_system ms)
    name 


let dump_packages_info 
    (fmt : Format.formatter) 
    ({name ; module_systems = ls } : t) = 
  Format.fprintf fmt "@[%s;@ @[%a@]@]"
    name
    (Format.pp_print_list
       ~pp_sep:(fun fmt () -> Format.pp_print_space fmt ())
       dump_package_info 
    ) ls

type info_query =
  | Package_script 
  | Package_found of package_name * string
  | Package_not_found 



let query_package_infos 
    (package_info : t) module_system : info_query =
  if is_empty package_info then Package_script 
  else 
    match List.find (fun (k, _) -> 
        compatible k  module_system) package_info.module_systems with
    | (_, x) -> Package_found (package_info.name, x)
    | exception _ -> Package_not_found



let get_js_path module_system 
    ({module_systems } : t ) = 
  match List.find (fun (k,_) -> 
      compatible k  module_system) module_systems with
  | (_, path) ->  path
  |  exception _ -> assert false

(* for a single pass compilation, [output_dir]
   can be cached
*)
let get_output_dir ~package_dir module_system 
    (info: t ) =
  Filename.concat package_dir 
    (get_js_path module_system info)




let add_npm_package_path s (packages_info : t)  : t =
  if is_empty packages_info then 
    Ext_pervasives.bad_argf "please set package name first using -bs-package-name "
  else   
    let env, path =
      match Ext_string.split ~keep_empty:false s ':' with
      | [ module_system; path]  ->
        (match module_system_of_string module_system with
         | Some x -> x
         | None ->
           Ext_pervasives.bad_argf "invalid module system %s" module_system), path
      | [path] ->
        NodeJS, path
      | _ ->
        Ext_pervasives.bad_argf "invalid npm package path: %s" s
    in
    { packages_info with module_systems = (env,path)::packages_info.module_systems}




let (//) = Filename.concat 




let string_of_module_id 
    ~output_dir:(output_dir : string )
    (module_system : module_system)    
    (current_package_info : t)
    (get_package_path_from_cmj : 
       Lam_module_ident.t -> (string * t * bool) option
    )
    (dep_module_id : Lam_module_ident.t) : string =
  let result = 
    match dep_module_id.kind  with 
    | External name -> name (* the literal string for external package *)
    (** This may not be enough, 
        1. For cross packages, we may need settle 
        down a single js package
        2. We may need es6 path for dead code elimination
         But frankly, very few JS packages have no dependency, 
         so having plugin may sound not that bad   
    *)
    | Runtime  
    | Ml  -> 
      let id = dep_module_id.id in
      
      let current_pkg_info = 
        query_package_infos current_package_info
          module_system  
      in


      match get_package_path_from_cmj dep_module_id with 
      | None -> 
        Bs_exception.error (Missing_ml_dependency dep_module_id.id.name)
      | Some (cmj_path, package_info, little) -> 
        let js_file =  Ext_namespace.js_name_of_modulename ~little id.name in 
        let dependency_pkg_info =  
          query_package_infos package_info module_system 
        in 
        match dependency_pkg_info, current_pkg_info with
        | Package_not_found , _  -> 
          Bs_exception.error (Missing_ml_dependency dep_module_id.id.name)
        | Package_script , Package_found _  -> 
          Bs_exception.error (Dependency_script_module_dependent_not js_file)
        | (Package_script  | Package_found _ ), Package_not_found -> assert false

        | Package_found(dep_package_name, dep_path), 
          Package_script 
          ->    
          dep_package_name // dep_path // js_file

        | Package_found(dep_package_name, dep_path),
          Package_found(cur_package_name, cur_path) -> 
          if  cur_package_name = dep_package_name then 
            Ext_path.node_rebase_file
              ~from:cur_path
              ~to_:dep_path 
              js_file
              (** TODO: we assume that both [x] and [path] could only be relative path
                  which is guaranteed by [-bs-package-output]
              *)
          else  
            begin match module_system with 
              | AmdJS | NodeJS | Es6 -> 
                dep_package_name // dep_path // js_file
              (** Note we did a post-processing when working on Windows *)
              | Es6_global 
              | AmdJS_global -> 
                (** lib/ocaml/xx.cmj --               
                    HACKING: FIXME
                    maybe we can caching relative package path calculation or employ package map *)
                (* assert false  *)

                begin 
                  Ext_path.rel_normalized_absolute_path              
                    ~from:(get_output_dir 
                             ~package_dir:(Lazy.force Ext_filename.package_dir)
                             module_system 
                             current_package_info
                          )
                    ((Filename.dirname 
                        (Filename.dirname (Filename.dirname cmj_path))) // dep_path // js_file)              
                end
            end
        | Package_script , 
          Package_script 
          -> 
          begin match Config_util.find_opt js_file with 
            | Some file -> 
              let basename = Filename.basename file in 
              let dirname = Filename.dirname file in 
              Ext_path.node_rebase_file
                ~from:(
                  Ext_path.absolute_path 
                  Ext_filename.cwd output_dir)
                ~to_:(
                  Ext_path.absolute_path 
                  Ext_filename.cwd
                  dirname
                )
                basename  
            | None -> 
              Bs_exception.error (Js_not_found js_file)
          end
  in 
  if Ext_sys.is_windows_or_cygwin then 
    Ext_string.replace_backward_slash result 
  else result 



(* support es6 modules instead
   TODO: enrich ast to support import export 
   http://www.ecma-international.org/ecma-262/6.0/#sec-imports
   For every module, we need [Ident.t] for accessing and [filename] for import, 
   they are not necessarily the same.

   Es6 modules is not the same with commonjs, we use commonjs currently
   (play better with node)

   FIXME: the module order matters?
*)


end
module Ext_array : sig 
#1 "ext_array.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






(** Some utilities for {!Array} operations *)
val reverse_range : 'a array -> int -> int -> unit
val reverse_in_place : 'a array -> unit
val reverse : 'a array -> 'a array 
val reverse_of_list : 'a list -> 'a array

val filter : ('a -> bool) -> 'a array -> 'a array

val filter_map : ('a -> 'b option) -> 'a array -> 'b array

val range : int -> int -> int array

val map2i : (int -> 'a -> 'b -> 'c ) -> 'a array -> 'b array -> 'c array

val to_list_map : ('a -> 'b option) -> 'a array -> 'b list 

val to_list_map_acc : 
  ('a -> 'b option) -> 
  'a array -> 
  'b list -> 
  'b list 

val of_list_map : ('a -> 'b) -> 'a list -> 'b array 

val rfind_with_index : 'a array -> ('a -> 'b -> bool) -> 'b -> int


type 'a split = [ `No_split | `Split of 'a array * 'a array ]

val rfind_and_split : 
  'a array ->
  ('a -> 'b -> bool) ->
  'b -> 'a split

val find_and_split : 
  'a array ->
  ('a -> 'b -> bool) ->
  'b -> 'a split

val exists : ('a -> bool) -> 'a array -> bool 

val is_empty : 'a array -> bool 

val for_all2_no_exn : 
  ('a -> 'b -> bool) -> 
  'a array ->
  'b array -> 
  bool
end = struct
#1 "ext_array.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)





let reverse_range a i len =
  if len = 0 then ()
  else
    for k = 0 to (len-1)/2 do
      let t = Array.unsafe_get a (i+k) in
      Array.unsafe_set a (i+k) ( Array.unsafe_get a (i+len-1-k));
      Array.unsafe_set a (i+len-1-k) t;
    done


let reverse_in_place a =
  reverse_range a 0 (Array.length a)

let reverse a =
  let b_len = Array.length a in
  if b_len = 0 then [||] else  
  let b = Array.copy a in  
  for i = 0 to  b_len - 1 do
      Array.unsafe_set b i (Array.unsafe_get a (b_len - 1 -i )) 
  done;
  b  

let reverse_of_list =  function
  | [] -> [||]
  | hd::tl as l ->
    let len = List.length l in
    let a = Array.make len hd in
    let rec fill i = function
      | [] -> a
      | hd::tl -> Array.unsafe_set a (len - i - 2) hd; fill (i+1) tl in
    fill 0 tl

let filter f a =
  let arr_len = Array.length a in
  let rec aux acc i =
    if i = arr_len 
    then reverse_of_list acc 
    else
      let v = Array.unsafe_get a i in
      if f  v then 
        aux (v::acc) (i+1)
      else aux acc (i + 1) 
  in aux [] 0


let filter_map (f : _ -> _ option) a =
  let arr_len = Array.length a in
  let rec aux acc i =
    if i = arr_len 
    then reverse_of_list acc 
    else
      let v = Array.unsafe_get a i in
      match f  v with 
      | Some v -> 
        aux (v::acc) (i+1)
      | None -> 
        aux acc (i + 1) 
  in aux [] 0

let range from to_ =
  if from > to_ then invalid_arg "Ext_array.range"  
  else Array.init (to_ - from + 1) (fun i -> i + from)

let map2i f a b = 
  let len = Array.length a in 
  if len <> Array.length b then 
    invalid_arg "Ext_array.map2i"  
  else
    Array.mapi (fun i a -> f i  a ( Array.unsafe_get b i )) a 


 let rec tolist_aux a f  i res =
    if i < 0 then res else
      let v = Array.unsafe_get a i in
      tolist_aux a f  (i - 1)
        (match f v with
         | Some v -> v :: res
         | None -> res) 

let to_list_map f a = 
  tolist_aux a f (Array.length a - 1) []

let to_list_map_acc f a acc = 
  tolist_aux a f (Array.length a - 1) acc


(* TODO: What would happen if [f] raise, memory leak? *)
let of_list_map f a = 
  match a with 
  | [] -> [||]
  | h::tl -> 
    let hd = f h in 
    let len = List.length tl + 1 in 
    let arr = Array.make len hd  in
    let rec fill i = function
    | [] -> arr 
    | hd :: tl -> 
      Array.unsafe_set arr i (f hd); 
      fill (i + 1) tl in 
    fill 1 tl
  
(**
{[
# rfind_with_index [|1;2;3|] (=) 2;;
- : int = 1
# rfind_with_index [|1;2;3|] (=) 1;;
- : int = 0
# rfind_with_index [|1;2;3|] (=) 3;;
- : int = 2
# rfind_with_index [|1;2;3|] (=) 4;;
- : int = -1
]}
*)
let rfind_with_index arr cmp v = 
  let len = Array.length arr in 
  let rec aux i = 
    if i < 0 then i
    else if  cmp (Array.unsafe_get arr i) v then i
    else aux (i - 1) in 
  aux (len - 1)

type 'a split = [ `No_split | `Split of 'a array * 'a array ]
let rfind_and_split arr cmp v : _ split = 
  let i = rfind_with_index arr cmp v in 
  if  i < 0 then 
    `No_split 
  else 
    `Split (Array.sub arr 0 i , Array.sub arr  (i + 1 ) (Array.length arr - i - 1 ))


let find_with_index arr cmp v = 
  let len  = Array.length arr in 
  let rec aux i len = 
    if i >= len then -1 
    else if cmp (Array.unsafe_get arr i ) v then i 
    else aux (i + 1) len in 
  aux 0 len

let find_and_split arr cmp v : _ split = 
  let i = find_with_index arr cmp v in 
  if i < 0 then 
    `No_split
  else
    `Split (Array.sub arr 0 i, Array.sub arr (i + 1 ) (Array.length arr - i - 1))        

(** TODO: available since 4.03, use {!Array.exists} *)

let exists p a =
  let n = Array.length a in
  let rec loop i =
    if i = n then false
    else if p (Array.unsafe_get a i) then true
    else loop (succ i) in
  loop 0


let is_empty arr =
  Array.length arr = 0


let rec unsafe_loop index len p xs ys  = 
  if index >= len then true
  else 
    p 
      (Array.unsafe_get xs index)
      (Array.unsafe_get ys index) &&
      unsafe_loop (succ index) len p xs ys 
   
let for_all2_no_exn p xs ys = 
  let len_xs = Array.length xs in 
  let len_ys = Array.length ys in 
  len_xs = len_ys &&    
  unsafe_loop 0 len_xs p xs ys
end
module Ext_json_types
= struct
#1 "ext_json_types.ml"
(* Copyright (C) 2015-2017 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type loc = Lexing.position
type json_str = 
  { str : string ; loc : loc}

type json_flo  =
  { flo : string ; loc : loc}
type json_array =
  { content : t array ; 
    loc_start : loc ; 
    loc_end : loc ; 
  }

and json_map = 
  { map : t String_map.t ; loc :  loc }
and t = 
  | True of loc 
  | False of loc 
  | Null of loc 
  | Flo of json_flo
  | Str of json_str
  | Arr  of json_array
  | Obj of json_map
   

end
module Ext_position : sig 
#1 "ext_position.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


type t = Lexing.position = {
    pos_fname : string ;
    pos_lnum : int ;
    pos_bol : int ;
    pos_cnum : int
}


val print : Format.formatter -> t -> unit 
end = struct
#1 "ext_position.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


type t = Lexing.position = {
    pos_fname : string ;
    pos_lnum : int ;
    pos_bol : int ;
    pos_cnum : int
}


let print fmt (pos : t) =
  Format.fprintf fmt "(line %d, column %d)" pos.pos_lnum (pos.pos_cnum - pos.pos_bol)






end
module Ext_json_parse : sig 
#1 "ext_json_parse.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type error_info

exception Error of error_info

val pp_error : Format.formatter -> error_info -> unit 

val parse_json : Lexing.lexbuf -> Ext_json_types.t 
val parse_json_from_string : string -> Ext_json_types.t 

val parse_json_from_chan : in_channel -> Ext_json_types.t 

val parse_json_from_file  : string -> Ext_json_types.t


end = struct
#1 "ext_json_parse.ml"
# 1 "ext/ext_json_parse.mll"
 
type error =
  | Illegal_character of char
  | Unterminated_string
  | Unterminated_comment
  | Illegal_escape of string
  | Unexpected_token 
  | Expect_comma_or_rbracket
  | Expect_comma_or_rbrace
  | Expect_colon
  | Expect_string_or_rbrace 
  | Expect_eof 
  (* | Trailing_comma_in_obj *)
  (* | Trailing_comma_in_array *)
exception Error of error * Lexing.position * Lexing.position;;

let fprintf  = Format.fprintf
let report_error ppf = function
  | Illegal_character c ->
      fprintf ppf "Illegal character (%s)" (Char.escaped c)
  | Illegal_escape s ->
      fprintf ppf "Illegal backslash escape in string or character (%s)" s
  | Unterminated_string -> 
      fprintf ppf "Unterminated_string"
  | Expect_comma_or_rbracket ->
    fprintf ppf "Expect_comma_or_rbracket"
  | Expect_comma_or_rbrace -> 
    fprintf ppf "Expect_comma_or_rbrace"
  | Expect_colon -> 
    fprintf ppf "Expect_colon"
  | Expect_string_or_rbrace  -> 
    fprintf ppf "Expect_string_or_rbrace"
  | Expect_eof  -> 
    fprintf ppf "Expect_eof"
  | Unexpected_token 
    ->
    fprintf ppf "Unexpected_token"
  (* | Trailing_comma_in_obj  *)
  (*   -> fprintf ppf "Trailing_comma_in_obj" *)
  (* | Trailing_comma_in_array  *)
  (*   -> fprintf ppf "Trailing_comma_in_array" *)
  | Unterminated_comment 
    -> fprintf ppf "Unterminated_comment"
         

type  error_info  = 
  { error : error ;
    loc_start : Lexing.position; 
    loc_end :Lexing.position;
  }

let pp_error fmt {error; loc_start ; loc_end } = 
  Format.fprintf fmt "@[%a:@ %a@ -@ %a)@]" 
    report_error error
    Ext_position.print loc_start
    Ext_position.print loc_end

exception Error of error_info



let () = 
  Printexc.register_printer
    (function x -> 
     match x with 
     | Error error_info -> 
       Some (Format.asprintf "%a" pp_error error_info)

     | _ -> None
    )





type token = 
  | Comma
  | Eof
  | False
  | Lbrace
  | Lbracket
  | Null
  | Colon
  | Number of string
  | Rbrace
  | Rbracket
  | String of string
  | True   
  
let error  (lexbuf : Lexing.lexbuf) e = 
  raise (Error { error =  e; 
                 loc_start =  lexbuf.lex_start_p; 
                 loc_end = lexbuf.lex_curr_p})


let lexeme_len (x : Lexing.lexbuf) =
  x.lex_curr_pos - x.lex_start_pos

let update_loc ({ lex_curr_p; _ } as lexbuf : Lexing.lexbuf) diff =
  lexbuf.lex_curr_p <-
    {
      lex_curr_p with
      pos_lnum = lex_curr_p.pos_lnum + 1;
      pos_bol = lex_curr_p.pos_cnum - diff;
    }

let char_for_backslash = function
  | 'n' -> '\010'
  | 'r' -> '\013'
  | 'b' -> '\008'
  | 't' -> '\009'
  | c -> c

let dec_code c1 c2 c3 =
  100 * (Char.code c1 - 48) + 10 * (Char.code c2 - 48) + (Char.code c3 - 48)

let hex_code c1 c2 =
  let d1 = Char.code c1 in
  let val1 =
    if d1 >= 97 then d1 - 87
    else if d1 >= 65 then d1 - 55
    else d1 - 48 in
  let d2 = Char.code c2 in
  let val2 =
    if d2 >= 97 then d2 - 87
    else if d2 >= 65 then d2 - 55
    else d2 - 48 in
  val1 * 16 + val2

let lf = '\010'

# 134 "ext/ext_json_parse.ml"
let __ocaml_lex_tables = {
  Lexing.lex_base = 
   "\000\000\239\255\240\255\241\255\000\000\025\000\011\000\244\255\
    \245\255\246\255\247\255\248\255\249\255\000\000\000\000\000\000\
    \041\000\001\000\254\255\005\000\005\000\253\255\001\000\002\000\
    \252\255\000\000\000\000\003\000\251\255\001\000\003\000\250\255\
    \079\000\089\000\099\000\121\000\131\000\141\000\153\000\163\000\
    \001\000\253\255\254\255\023\000\255\255\006\000\246\255\189\000\
    \248\255\215\000\255\255\249\255\249\000\181\000\252\255\009\000\
    \063\000\075\000\234\000\251\255\032\001\250\255";
  Lexing.lex_backtrk = 
   "\255\255\255\255\255\255\255\255\013\000\013\000\016\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\016\000\016\000\016\000\
    \016\000\016\000\255\255\000\000\012\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\013\000\255\255\013\000\255\255\013\000\255\255\
    \255\255\255\255\255\255\001\000\255\255\255\255\255\255\008\000\
    \255\255\255\255\255\255\255\255\006\000\006\000\255\255\006\000\
    \001\000\002\000\255\255\255\255\255\255\255\255";
  Lexing.lex_default = 
   "\001\000\000\000\000\000\000\000\255\255\255\255\255\255\000\000\
    \000\000\000\000\000\000\000\000\000\000\255\255\255\255\255\255\
    \255\255\255\255\000\000\255\255\020\000\000\000\255\255\255\255\
    \000\000\255\255\255\255\255\255\000\000\255\255\255\255\000\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \042\000\000\000\000\000\255\255\000\000\047\000\000\000\047\000\
    \000\000\051\000\000\000\000\000\255\255\255\255\000\000\255\255\
    \255\255\255\255\255\255\000\000\255\255\000\000";
  Lexing.lex_trans = 
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\019\000\018\000\018\000\019\000\017\000\019\000\255\255\
    \048\000\019\000\255\255\057\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \019\000\000\000\003\000\000\000\000\000\019\000\000\000\000\000\
    \050\000\000\000\000\000\043\000\008\000\006\000\033\000\016\000\
    \004\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\007\000\004\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\005\000\005\000\005\000\032\000\044\000\033\000\
    \056\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\005\000\021\000\057\000\000\000\000\000\000\000\
    \020\000\000\000\000\000\012\000\000\000\011\000\032\000\056\000\
    \000\000\025\000\049\000\000\000\000\000\032\000\014\000\024\000\
    \028\000\000\000\000\000\057\000\026\000\030\000\013\000\031\000\
    \000\000\000\000\022\000\027\000\015\000\029\000\023\000\000\000\
    \000\000\000\000\039\000\010\000\039\000\009\000\032\000\038\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\037\000\000\000\037\000\000\000\
    \035\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\255\255\
    \035\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\038\000\038\000\038\000\038\000\000\000\000\000\255\255\
    \000\000\056\000\000\000\000\000\055\000\058\000\058\000\058\000\
    \058\000\058\000\058\000\058\000\058\000\058\000\058\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\054\000\
    \000\000\054\000\000\000\000\000\000\000\000\000\054\000\000\000\
    \002\000\041\000\000\000\000\000\000\000\255\255\046\000\053\000\
    \053\000\053\000\053\000\053\000\053\000\053\000\053\000\053\000\
    \053\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\255\255\059\000\059\000\059\000\059\000\059\000\059\000\
    \059\000\059\000\059\000\059\000\000\000\000\000\000\000\000\000\
    \000\000\060\000\060\000\060\000\060\000\060\000\060\000\060\000\
    \060\000\060\000\060\000\054\000\000\000\000\000\000\000\000\000\
    \000\000\054\000\060\000\060\000\060\000\060\000\060\000\060\000\
    \000\000\000\000\000\000\000\000\000\000\054\000\000\000\000\000\
    \000\000\054\000\000\000\054\000\000\000\000\000\000\000\052\000\
    \061\000\061\000\061\000\061\000\061\000\061\000\061\000\061\000\
    \061\000\061\000\060\000\060\000\060\000\060\000\060\000\060\000\
    \000\000\061\000\061\000\061\000\061\000\061\000\061\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\061\000\061\000\061\000\061\000\061\000\061\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\255\255\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\255\255\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000";
  Lexing.lex_check = 
   "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\000\000\017\000\000\000\000\000\019\000\020\000\
    \045\000\019\000\020\000\055\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\255\255\000\000\255\255\255\255\019\000\255\255\255\255\
    \045\000\255\255\255\255\040\000\000\000\000\000\004\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\004\000\043\000\005\000\
    \056\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\005\000\016\000\057\000\255\255\255\255\255\255\
    \016\000\255\255\255\255\000\000\255\255\000\000\005\000\056\000\
    \255\255\014\000\045\000\255\255\255\255\004\000\000\000\023\000\
    \027\000\255\255\255\255\057\000\025\000\029\000\000\000\030\000\
    \255\255\255\255\015\000\026\000\000\000\013\000\022\000\255\255\
    \255\255\255\255\032\000\000\000\032\000\000\000\005\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\035\000\255\255\035\000\255\255\
    \034\000\035\000\035\000\035\000\035\000\035\000\035\000\035\000\
    \035\000\035\000\035\000\036\000\036\000\036\000\036\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\047\000\
    \034\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\038\000\038\000\039\000\039\000\039\000\039\000\039\000\
    \039\000\039\000\039\000\039\000\039\000\255\255\255\255\047\000\
    \255\255\049\000\255\255\255\255\049\000\053\000\053\000\053\000\
    \053\000\053\000\053\000\053\000\053\000\053\000\053\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\049\000\
    \255\255\049\000\255\255\255\255\255\255\255\255\049\000\255\255\
    \000\000\040\000\255\255\255\255\255\255\020\000\045\000\049\000\
    \049\000\049\000\049\000\049\000\049\000\049\000\049\000\049\000\
    \049\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\047\000\058\000\058\000\058\000\058\000\058\000\058\000\
    \058\000\058\000\058\000\058\000\255\255\255\255\255\255\255\255\
    \255\255\052\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \052\000\052\000\052\000\049\000\255\255\255\255\255\255\255\255\
    \255\255\049\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \255\255\255\255\255\255\255\255\255\255\049\000\255\255\255\255\
    \255\255\049\000\255\255\049\000\255\255\255\255\255\255\049\000\
    \060\000\060\000\060\000\060\000\060\000\060\000\060\000\060\000\
    \060\000\060\000\052\000\052\000\052\000\052\000\052\000\052\000\
    \255\255\060\000\060\000\060\000\060\000\060\000\060\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\060\000\060\000\060\000\060\000\060\000\060\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\047\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\049\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255";
  Lexing.lex_base_code = 
   "";
  Lexing.lex_backtrk_code = 
   "";
  Lexing.lex_default_code = 
   "";
  Lexing.lex_trans_code = 
   "";
  Lexing.lex_check_code = 
   "";
  Lexing.lex_code = 
   "";
}

let rec lex_json buf lexbuf =
    __ocaml_lex_lex_json_rec buf lexbuf 0
and __ocaml_lex_lex_json_rec buf lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 152 "ext/ext_json_parse.mll"
          ( lex_json buf lexbuf)
# 324 "ext/ext_json_parse.ml"

  | 1 ->
# 153 "ext/ext_json_parse.mll"
                   ( 
    update_loc lexbuf 0;
    lex_json buf  lexbuf
  )
# 332 "ext/ext_json_parse.ml"

  | 2 ->
# 157 "ext/ext_json_parse.mll"
                ( comment buf lexbuf)
# 337 "ext/ext_json_parse.ml"

  | 3 ->
# 158 "ext/ext_json_parse.mll"
         ( True)
# 342 "ext/ext_json_parse.ml"

  | 4 ->
# 159 "ext/ext_json_parse.mll"
          (False)
# 347 "ext/ext_json_parse.ml"

  | 5 ->
# 160 "ext/ext_json_parse.mll"
         (Null)
# 352 "ext/ext_json_parse.ml"

  | 6 ->
# 161 "ext/ext_json_parse.mll"
       (Lbracket)
# 357 "ext/ext_json_parse.ml"

  | 7 ->
# 162 "ext/ext_json_parse.mll"
       (Rbracket)
# 362 "ext/ext_json_parse.ml"

  | 8 ->
# 163 "ext/ext_json_parse.mll"
       (Lbrace)
# 367 "ext/ext_json_parse.ml"

  | 9 ->
# 164 "ext/ext_json_parse.mll"
       (Rbrace)
# 372 "ext/ext_json_parse.ml"

  | 10 ->
# 165 "ext/ext_json_parse.mll"
       (Comma)
# 377 "ext/ext_json_parse.ml"

  | 11 ->
# 166 "ext/ext_json_parse.mll"
        (Colon)
# 382 "ext/ext_json_parse.ml"

  | 12 ->
# 167 "ext/ext_json_parse.mll"
                      (lex_json buf lexbuf)
# 387 "ext/ext_json_parse.ml"

  | 13 ->
# 169 "ext/ext_json_parse.mll"
         ( Number (Lexing.lexeme lexbuf))
# 392 "ext/ext_json_parse.ml"

  | 14 ->
# 171 "ext/ext_json_parse.mll"
      (
  let pos = Lexing.lexeme_start_p lexbuf in
  scan_string buf pos lexbuf;
  let content = (Buffer.contents  buf) in 
  Buffer.clear buf ;
  String content 
)
# 403 "ext/ext_json_parse.ml"

  | 15 ->
# 178 "ext/ext_json_parse.mll"
       (Eof )
# 408 "ext/ext_json_parse.ml"

  | 16 ->
let
# 179 "ext/ext_json_parse.mll"
       c
# 414 "ext/ext_json_parse.ml"
= Lexing.sub_lexeme_char lexbuf lexbuf.Lexing.lex_start_pos in
# 179 "ext/ext_json_parse.mll"
          ( error lexbuf (Illegal_character c ))
# 418 "ext/ext_json_parse.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; 
      __ocaml_lex_lex_json_rec buf lexbuf __ocaml_lex_state

and comment buf lexbuf =
    __ocaml_lex_comment_rec buf lexbuf 40
and __ocaml_lex_comment_rec buf lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 181 "ext/ext_json_parse.mll"
              (lex_json buf lexbuf)
# 430 "ext/ext_json_parse.ml"

  | 1 ->
# 182 "ext/ext_json_parse.mll"
     (comment buf lexbuf)
# 435 "ext/ext_json_parse.ml"

  | 2 ->
# 183 "ext/ext_json_parse.mll"
       (error lexbuf Unterminated_comment)
# 440 "ext/ext_json_parse.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; 
      __ocaml_lex_comment_rec buf lexbuf __ocaml_lex_state

and scan_string buf start lexbuf =
    __ocaml_lex_scan_string_rec buf start lexbuf 45
and __ocaml_lex_scan_string_rec buf start lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 187 "ext/ext_json_parse.mll"
      ( () )
# 452 "ext/ext_json_parse.ml"

  | 1 ->
# 189 "ext/ext_json_parse.mll"
  (
        let len = lexeme_len lexbuf - 2 in
        update_loc lexbuf len;

        scan_string buf start lexbuf
      )
# 462 "ext/ext_json_parse.ml"

  | 2 ->
# 196 "ext/ext_json_parse.mll"
      (
        let len = lexeme_len lexbuf - 3 in
        update_loc lexbuf len;
        scan_string buf start lexbuf
      )
# 471 "ext/ext_json_parse.ml"

  | 3 ->
let
# 201 "ext/ext_json_parse.mll"
                                               c
# 477 "ext/ext_json_parse.ml"
= Lexing.sub_lexeme_char lexbuf (lexbuf.Lexing.lex_start_pos + 1) in
# 202 "ext/ext_json_parse.mll"
      (
        Buffer.add_char buf (char_for_backslash c);
        scan_string buf start lexbuf
      )
# 484 "ext/ext_json_parse.ml"

  | 4 ->
let
# 206 "ext/ext_json_parse.mll"
                 c1
# 490 "ext/ext_json_parse.ml"
= Lexing.sub_lexeme_char lexbuf (lexbuf.Lexing.lex_start_pos + 1)
and
# 206 "ext/ext_json_parse.mll"
                               c2
# 495 "ext/ext_json_parse.ml"
= Lexing.sub_lexeme_char lexbuf (lexbuf.Lexing.lex_start_pos + 2)
and
# 206 "ext/ext_json_parse.mll"
                                             c3
# 500 "ext/ext_json_parse.ml"
= Lexing.sub_lexeme_char lexbuf (lexbuf.Lexing.lex_start_pos + 3)
and
# 206 "ext/ext_json_parse.mll"
                                                    s
# 505 "ext/ext_json_parse.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos (lexbuf.Lexing.lex_start_pos + 4) in
# 207 "ext/ext_json_parse.mll"
      (
        let v = dec_code c1 c2 c3 in
        if v > 255 then
          error lexbuf (Illegal_escape s) ;
        Buffer.add_char buf (Char.chr v);

        scan_string buf start lexbuf
      )
# 516 "ext/ext_json_parse.ml"

  | 5 ->
let
# 215 "ext/ext_json_parse.mll"
                        c1
# 522 "ext/ext_json_parse.ml"
= Lexing.sub_lexeme_char lexbuf (lexbuf.Lexing.lex_start_pos + 2)
and
# 215 "ext/ext_json_parse.mll"
                                         c2
# 527 "ext/ext_json_parse.ml"
= Lexing.sub_lexeme_char lexbuf (lexbuf.Lexing.lex_start_pos + 3) in
# 216 "ext/ext_json_parse.mll"
      (
        let v = hex_code c1 c2 in
        Buffer.add_char buf (Char.chr v);

        scan_string buf start lexbuf
      )
# 536 "ext/ext_json_parse.ml"

  | 6 ->
let
# 222 "ext/ext_json_parse.mll"
             c
# 542 "ext/ext_json_parse.ml"
= Lexing.sub_lexeme_char lexbuf (lexbuf.Lexing.lex_start_pos + 1) in
# 223 "ext/ext_json_parse.mll"
      (
        Buffer.add_char buf '\\';
        Buffer.add_char buf c;

        scan_string buf start lexbuf
      )
# 551 "ext/ext_json_parse.ml"

  | 7 ->
# 230 "ext/ext_json_parse.mll"
      (
        update_loc lexbuf 0;
        Buffer.add_char buf lf;

        scan_string buf start lexbuf
      )
# 561 "ext/ext_json_parse.ml"

  | 8 ->
# 237 "ext/ext_json_parse.mll"
      (
        let ofs = lexbuf.lex_start_pos in
        let len = lexbuf.lex_curr_pos - ofs in
        Buffer.add_substring buf lexbuf.lex_buffer ofs len;

        scan_string buf start lexbuf
      )
# 572 "ext/ext_json_parse.ml"

  | 9 ->
# 245 "ext/ext_json_parse.mll"
      (
        error lexbuf Unterminated_string
      )
# 579 "ext/ext_json_parse.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; 
      __ocaml_lex_scan_string_rec buf start lexbuf __ocaml_lex_state

;;

# 249 "ext/ext_json_parse.mll"
 






let rec parse_json lexbuf =
  let buf = Buffer.create 64 in 
  let look_ahead = ref None in
  let token () : token = 
    match !look_ahead with 
    | None ->  
      lex_json buf lexbuf 
    | Some x -> 
      look_ahead := None ;
      x 
  in
  let push e = look_ahead := Some e in 
  let rec json (lexbuf : Lexing.lexbuf) : Ext_json_types.t = 
    match token () with 
    | True -> True lexbuf.lex_start_p
    | False -> False lexbuf.lex_start_p
    | Null -> Null lexbuf.lex_start_p
    | Number s ->  Flo {flo = s; loc = lexbuf.lex_start_p}  
    | String s -> Str { str = s; loc =    lexbuf.lex_start_p}
    | Lbracket -> parse_array  lexbuf.lex_start_p lexbuf.lex_curr_p [] lexbuf
    | Lbrace -> parse_map lexbuf.lex_start_p String_map.empty lexbuf
    |  _ -> error lexbuf Unexpected_token
(** Note if we remove [trailing_comma] support 
    we should report errors (actually more work), for example 
    {[
    match token () with 
    | Rbracket ->
      if trailing_comma then
        error lexbuf Trailing_comma_in_array
      else
    ]} 
    {[
    match token () with 
    | Rbrace -> 
      if trailing_comma then
        error lexbuf Trailing_comma_in_obj
      else

    ]}   
 *)
  and parse_array   loc_start loc_finish acc lexbuf 
    : Ext_json_types.t =
    match token () with 
    | Rbracket ->
        Arr {loc_start ; content = Ext_array.reverse_of_list acc ; 
              loc_end = lexbuf.lex_curr_p }
    | x -> 
      push x ;
      let new_one = json lexbuf in 
      begin match token ()  with 
      | Comma -> 
          parse_array  loc_start loc_finish (new_one :: acc) lexbuf 
      | Rbracket 
        -> Arr {content = (Ext_array.reverse_of_list (new_one::acc));
                     loc_start ; 
                     loc_end = lexbuf.lex_curr_p }
      | _ -> 
        error lexbuf Expect_comma_or_rbracket
      end
  and parse_map loc_start  acc lexbuf : Ext_json_types.t = 
    match token () with 
    | Rbrace -> 
        Obj { map = acc ; loc = loc_start}
    | String key -> 
      begin match token () with 
      | Colon ->
        let value = json lexbuf in
        begin match token () with 
        | Rbrace -> Obj {map = String_map.add key value acc ; loc = loc_start}
        | Comma -> 
          parse_map loc_start  (String_map.add key value acc) lexbuf 
        | _ -> error lexbuf Expect_comma_or_rbrace
        end
      | _ -> error lexbuf Expect_colon
      end
    | _ -> error lexbuf Expect_string_or_rbrace
  in 
  let v = json lexbuf in 
  match token () with 
  | Eof -> v 
  | _ -> error lexbuf Expect_eof

let parse_json_from_string s = 
  parse_json (Lexing.from_string s )

let parse_json_from_chan in_chan = 
  let lexbuf = Lexing.from_channel in_chan in 
  parse_json lexbuf 

let parse_json_from_file s = 
  let in_chan = open_in s in 
  let lexbuf = Lexing.from_channel in_chan in 
  match parse_json lexbuf with 
  | exception e -> close_in in_chan ; raise e
  | v  -> close_in in_chan;  v





# 694 "ext/ext_json_parse.ml"

end
module Ast_arg : sig 
#1 "ast_arg.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type cst = private
  | Arg_int_lit of int 
  | Arg_string_lit of string 
  (* | Arg_js_true *)
  (* | Arg_js_false *)
  | Arg_js_null
  | Arg_js_true
  | Arg_js_false
  | Arg_js_json of string
type label = private
  | Label of string * cst option 
  | Empty of cst option
  | Optional of string 
  (* it will be ignored , side effect will be recorded *)

type ty = 
  | NullString of (int * string) list (* `a does not have any value*)
  | NonNullString of (int * string) list (* `a of int *)
  | Int of (int * int ) list (* ([`a | `b ] [@bs.int])*)
  | Arg_cst of cst
  | Fn_uncurry_arity of int (* annotated with [@bs.uncurry ] or [@bs.uncurry 2]*)
    (* maybe we can improve it as a combination of {!Asttypes.constant} and tuple *)
  | Array 
  | Extern_unit
  | Nothing
  | Ignore
  | Unwrap

type kind = 
  {
    arg_type : ty;
    arg_label :label
  }

val cst_json : Location.t -> string -> cst 
val cst_int : int -> cst 
val cst_string : string -> cst 

val empty_label : label
val empty_lit : cst -> label 
val label :  string -> cst option -> label
val optional  : string -> label
val empty_kind : ty -> kind

end = struct
#1 "ast_arg.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

(** type definitions for external argument *)

type cst = 
  | Arg_int_lit of int 
  | Arg_string_lit of string 

  | Arg_js_null
  | Arg_js_true
  | Arg_js_false
  | Arg_js_json of string
type label = 
  | Label of string * cst option 
  | Empty of cst option
  | Optional of string 
  (* it will be ignored , side effect will be recorded *)

type ty = 
  | NullString of (int * string) list (* `a does not have any value*)
  | NonNullString of (int * string) list (* `a of int *)
  | Int of (int * int ) list (* ([`a | `b ] [@bs.int])*)
  | Arg_cst of cst
  | Fn_uncurry_arity of int (* annotated with [@bs.uncurry ] or [@bs.uncurry 2]*)
    (* maybe we can improve it as a combination of {!Asttypes.constant} and tuple *)
  | Array 
  | Extern_unit
  | Nothing
  | Ignore
  | Unwrap

type kind = 
  {
    arg_type : ty;
    arg_label : label
  }

type invalid_json = Ext_json_parse.error_info

let pp_invaild_json fmt err = 
  Format.fprintf fmt "@[Invalid json literal:  %a@]@." 
    Ext_json_parse.pp_error err 
exception Error of Location.t * invalid_json

let () = 
  Location.register_error_of_exn (function 
    | Error (loc,err) -> 
      Some (Location.error_of_printer loc pp_invaild_json err)
    | _ -> None
    )


let cst_json loc s : cst  =
  match Ext_json_parse.parse_json (Lexing.from_string s) with 
  | True _ -> Arg_js_true
  | False _ -> Arg_js_false 
  | Null _ -> Arg_js_null 
  | _ -> Arg_js_json s 
  | exception Ext_json_parse.Error error_info
    -> raise (Error (loc , error_info))

let cst_int i = Arg_int_lit i 
let cst_string s = Arg_string_lit s 
let empty_label = Empty None 
let empty_lit s = Empty (Some s) 
let label s cst = Label(s,cst)
let optional s = Optional s 

let empty_kind arg_type = { arg_label = empty_label ; arg_type }

end
module Ast_ffi_types : sig 
#1 "ast_ffi_types.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


type external_module_name = 
  { bundle : string ; 
    bind_name : string option
  }

type pipe = bool 
type js_call = { 
  name : string;
  external_module_name : external_module_name option;
  splice : bool ;
  scopes : string list 
}

type js_send = { 
  name : string ;
  splice : bool ; 
  pipe : pipe  ;
  js_send_scopes : string list; 
} (* we know it is a js send, but what will happen if you pass an ocaml objct *)

type js_global_val = {
  name : string ; 
  external_module_name : external_module_name option;
  scopes : string list
}

type js_new_val = {
  name : string ; 
  external_module_name : external_module_name option;
  splice : bool ;
  scopes : string list;
}

type js_module_as_fn = 
  { external_module_name : external_module_name;
    splice : bool 
  }

type arg_type = Ast_arg.ty

type arg_label = Ast_arg.label 


type obj_create = Ast_arg.kind list

type js_get =  
  { js_get_name : string   ;
    js_get_scopes :  string list;
  }

type js_set = 
  { js_set_name : string  ;
    js_set_scopes : string list 
  }


type js_get_index =   {
  js_get_index_scopes : string list 
}

type js_set_index = {
  js_set_index_scopes : string list 
} 

(*val empty_js_get_index : js_get_index
val empty_js_set_index : js_set_index  *)


type ffi = 
  (* | Obj_create of obj_create*)
  | Js_global of js_global_val 
  | Js_module_as_var of  external_module_name
  | Js_module_as_fn of js_module_as_fn
  | Js_module_as_class of external_module_name             
  | Js_call of js_call 
  | Js_send of js_send
  | Js_new of js_new_val
  | Js_set of js_set
  | Js_get of js_get
  | Js_get_index of js_get_index
  | Js_set_index of js_set_index 

type return_wrapper = 
  | Return_unset 
  | Return_identity
  | Return_undefined_to_opt  
  | Return_null_to_opt
  | Return_null_undefined_to_opt
  | Return_to_ocaml_bool
  | Return_replaced_with_unit    

type t  = 
  | Ffi_bs of Ast_arg.kind list  *
     return_wrapper * ffi
  | Ffi_obj_create of obj_create
  | Ffi_normal 
  (* When it's normal, it is handled as normal c functional ffi call *)


val name_of_ffi : ffi -> string

val check_ffi : ?loc:Location.t ->  ffi -> unit 

val to_string : t -> string 

(** Note *)
val from_string : string -> t 


end = struct
#1 "ast_ffi_types.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


type external_module_name = 
  { bundle : string ; 
    bind_name : string option
  }

type pipe = bool 
type js_call = { 
  name : string;
  external_module_name : external_module_name option;
  splice : bool ;
  scopes : string list ; 
}

type js_send = { 
  name : string ;
  splice : bool ; 
  pipe : pipe   ;
  js_send_scopes : string list; 
} (* we know it is a js send, but what will happen if you pass an ocaml objct *)

type js_global_val = {
  name : string ; 
  external_module_name : external_module_name option;
  scopes : string list ;
}

type js_new_val = {
  name : string ; 
  external_module_name : external_module_name option;
  splice : bool ;
  scopes : string list;
}

type js_module_as_fn = 
  { external_module_name : external_module_name;
    splice : bool ;

  }
type js_get =  
  { js_get_name : string   ;
    js_get_scopes :  string list;
  }

type js_set = 
  { js_set_name : string  ;
    js_set_scopes : string list 
  }

type js_get_index =   {
  js_get_index_scopes : string list 
}

type js_set_index = {
  js_set_index_scopes : string list 
}  
(** TODO: information between [arg_type] and [arg_label] are duplicated, 
  design a more compact representation so that it is also easy to seralize by hand
*)  
type arg_type = Ast_arg.ty

type arg_label = Ast_arg.label


(**TODO: maybe we can merge [arg_label] and [arg_type] *)
type obj_create = Ast_arg.kind list

type ffi = 
  (* | Obj_create of obj_create *)
  | Js_global of js_global_val 
  | Js_module_as_var of  external_module_name
  | Js_module_as_fn of js_module_as_fn
  | Js_module_as_class of external_module_name             
  | Js_call of js_call 
  | Js_send of js_send
  | Js_new of js_new_val
  | Js_set of js_set
  | Js_get of js_get
  | Js_get_index of js_get_index
  | Js_set_index of js_set_index 

let name_of_ffi ffi =
  match ffi with 
  | Js_get_index _scope -> "[@@bs.get_index ..]"
  | Js_set_index _scope -> "[@@bs.set_index ..]"
  | Js_get { js_get_name = s} -> Printf.sprintf "[@@bs.get %S]" s 
  | Js_set { js_set_name = s} -> Printf.sprintf "[@@bs.set %S]" s 
  | Js_call v  -> Printf.sprintf "[@@bs.val %S]" v.name
  | Js_send v  -> Printf.sprintf "[@@bs.send %S]" v.name
  | Js_module_as_fn v  -> Printf.sprintf "[@@bs.val %S]" v.external_module_name.bundle
  | Js_new v  -> Printf.sprintf "[@@bs.new %S]" v.name                    
  | Js_module_as_class v
    -> Printf.sprintf "[@@bs.module] %S " v.bundle
  | Js_module_as_var v
    -> 
    Printf.sprintf "[@@bs.module] %S " v.bundle
  | Js_global v 
    -> 
    Printf.sprintf "[@@bs.val] %S " v.name                    
(* | Obj_create _ -> 
   Printf.sprintf "[@@bs.obj]" *)

type return_wrapper = 
  | Return_unset 
  | Return_identity
  | Return_undefined_to_opt  
  | Return_null_to_opt
  | Return_null_undefined_to_opt
  | Return_to_ocaml_bool
  | Return_replaced_with_unit    
type t  = 
  | Ffi_bs of Ast_arg.kind list  *
     return_wrapper * ffi 
  (**  [Ffi_bs(args,return,ffi) ]
       [return] means return value is unit or not, 
        [true] means is [unit]  
  *)
  | Ffi_obj_create of obj_create
  | Ffi_normal 
  (* When it's normal, it is handled as normal c functional ffi call *)



let valid_js_char =
  let a = Array.init 256 (fun i ->
      let c = Char.chr i in
      (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c = '_' || c = '$'
    ) in
  (fun c -> Array.unsafe_get a (Char.code c))

let valid_first_js_char = 
  let a = Array.init 256 (fun i ->
      let c = Char.chr i in
      (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c = '_' || c = '$'
    ) in
  (fun c -> Array.unsafe_get a (Char.code c))

(** Approximation could be improved *)
let valid_ident (s : string) =
  let len = String.length s in
  len > 0 && valid_js_char s.[0] && valid_first_js_char s.[0] &&
  (let module E = struct exception E end in
   try
     for i = 1 to len - 1 do
       if not (valid_js_char (String.unsafe_get s i)) then
         raise E.E         
     done ;
     true     
   with E.E -> false )  

let valid_global_name ?loc txt =
  if not (valid_ident txt) then
    let v = Ext_string.split_by ~keep_empty:true (fun x -> x = '.') txt in
    List.iter
      (fun s ->
         if not (valid_ident s) then
           Location.raise_errorf ?loc "Not a valid global name %s"  txt
      ) v      

let valid_method_name ?loc txt =         
  if not (valid_ident txt) then
    Location.raise_errorf ?loc "Not a valid method name %s"  txt



let check_external_module_name ?loc x = 
  match x with 
  | {bundle = ""; _ } | {bind_name = Some ""} -> 
    Location.raise_errorf ?loc "empty name encountered"
  | _ -> ()
let check_external_module_name_opt ?loc x = 
  match x with 
  | None -> ()
  | Some v -> check_external_module_name ?loc v 


let check_ffi ?loc ffi = 
  match ffi with 
  | Js_global {name} -> valid_global_name ?loc  name
  | Js_send {name } 
  | Js_set  {js_set_name = name}
  | Js_get { js_get_name = name}
    ->  valid_method_name ?loc name
  (* | Obj_create _ -> () *)
  | Js_get_index  _ (* TODO: check scopes *)
  | Js_set_index _
    -> ()

  | Js_module_as_var external_module_name
  | Js_module_as_fn {external_module_name; _}
  | Js_module_as_class external_module_name             
    -> check_external_module_name external_module_name
  | Js_new {external_module_name ;  name}
  | Js_call {external_module_name ;  name ; _}
    -> 
    check_external_module_name_opt ?loc external_module_name ;
    valid_global_name ?loc name     

let bs_prefix = "BS:"
let bs_prefix_length = String.length bs_prefix 


(** TODO: Make sure each version is not prefix of each other
    Solution:
    1. fixed length 
    2. non-prefix approach
*)
let bs_external = bs_prefix ^ Bs_version.version 


let bs_external_length = String.length bs_external


let to_string  t = 
  bs_external ^ Marshal.to_string t []


(* TODO:  better error message when version mismatch *)
let from_string s : t = 
  let s_len = String.length s in 
  if s_len >= bs_prefix_length &&
     String.unsafe_get s 0 = 'B' &&
     String.unsafe_get s 1 = 'S' &&
     String.unsafe_get s 2 = ':' then 
    if Ext_string.starts_with s bs_external then 
      Marshal.from_string s bs_external_length 
    else 
      Ext_pervasives.failwithf 
        ~loc:__LOC__
        "compiler version mismatch, please do a clean build"
  else Ffi_normal    

end
module Vec_gen
= struct
#1 "vec_gen.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


module type ResizeType = 
sig 
  type t 
  val null : t (* used to populate new allocated array checkout {!Obj.new_block} for more performance *)
end

module type S = 
sig 
  type elt 
  type t
  val length : t -> int 
  val compact : t -> unit
  val singleton : elt -> t 
  val empty : unit -> t 
  val make : int -> t 
  val init : int -> (int -> elt) -> t
  val is_empty : t -> bool
  val of_array : elt array -> t
  val of_sub_array : elt array -> int -> int -> t

  (** Exposed for some APIs which only take array as input, 
      when exposed   
  *)
  val unsafe_internal_array : t -> elt array
  val reserve : t -> int -> unit
  val push :  elt -> t -> unit
  val delete : t -> int -> unit 
  val pop : t -> unit
  val get_last_and_pop : t -> elt
  val delete_range : t -> int -> int -> unit 
  val get_and_delete_range : t -> int -> int -> t
  val clear : t -> unit 
  val reset : t -> unit 
  val to_list : t -> elt list 
  val of_list : elt list -> t
  val to_array : t -> elt array 
  val of_array : elt array -> t
  val copy : t -> t 
  val reverse_in_place : t -> unit
  val iter : (elt -> unit) -> t -> unit 
  val iteri : (int -> elt -> unit ) -> t -> unit 
  val iter_range : from:int -> to_:int -> (elt -> unit) -> t -> unit 
  val iteri_range : from:int -> to_:int -> (int -> elt -> unit) -> t -> unit
  val map : (elt -> elt) -> t ->  t
  val mapi : (int -> elt -> elt) -> t -> t
  val map_into_array : (elt -> 'f) -> t -> 'f array
  val map_into_list : (elt -> 'f) -> t -> 'f list 
  val fold_left : ('f -> elt -> 'f) -> 'f -> t -> 'f
  val fold_right : (elt -> 'g -> 'g) -> t -> 'g -> 'g
  val filter : (elt -> bool) -> t -> t
  val inplace_filter : (elt -> bool) -> t -> unit
  val inplace_filter_with : (elt -> bool) -> cb_no:(elt -> 'a -> 'a) -> 'a -> t -> 'a 
  val inplace_filter_from : int -> (elt -> bool) -> t -> unit 
  val equal : (elt -> elt -> bool) -> t -> t -> bool 
  val get : t -> int -> elt
  val unsafe_get : t -> int -> elt
  val last : t -> elt
  val capacity : t -> int
  val exists : (elt -> bool) -> t -> bool
  val sub : t -> int -> int  -> t 
end


end
module Int_vec : sig 
#1 "int_vec.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

include Vec_gen.S with type elt = int

end = struct
#1 "int_vec.ml"
# 1 "ext/vec.cppo.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

# 34
type elt = int 
let null = 0 (* can be optimized *)
let unsafe_blit = Bs_hash_stubs.int_unsafe_blit

# 41
external unsafe_sub : 'a array -> int -> int -> 'a array = "caml_array_sub"

type  t = {
  mutable arr : elt array ;
  mutable len : int ;  
}

let length d = d.len

let compact d =
  let d_arr = d.arr in 
  if d.len <> Array.length d_arr then 
    begin
      let newarr = unsafe_sub d_arr 0 d.len in 
      d.arr <- newarr
    end
let singleton v = 
  {
    len = 1 ; 
    arr = [|v|]
  }

let empty () =
  {
    len = 0;
    arr = [||];
  }

let is_empty d =
  d.len = 0

let reset d = 
  d.len <- 0; 
  d.arr <- [||]


(* For [to_*] operations, we should be careful to call {!Array.*} function 
   in case we operate on the whole array
*)
let to_list d =
  let rec loop (d_arr : elt array) idx accum =
    if idx < 0 then accum else loop d_arr (idx - 1) (Array.unsafe_get d_arr idx :: accum)
  in
  loop d.arr (d.len - 1) []


let of_list lst =
  let arr = Array.of_list lst in 
  { arr ; len = Array.length arr}


let to_array d = 
  unsafe_sub d.arr 0 d.len

let of_array src =
  {
    len = Array.length src;
    arr = Array.copy src;
    (* okay to call {!Array.copy}*)
  }
let of_sub_array arr off len = 
  { 
    len = len ; 
    arr = Array.sub arr off len  
  }  
let unsafe_internal_array v = v.arr  
(* we can not call {!Array.copy} *)
let copy src =
  let len = src.len in
  {
    len ;
    arr = unsafe_sub src.arr 0 len ;
  }

(* FIXME *)
let reverse_in_place src = 
  Ext_array.reverse_range src.arr 0 src.len 




(* {!Array.sub} is not enough for error checking, it 
   may contain some garbage
 *)
let sub (src : t) start len =
  let src_len = src.len in 
  if len < 0 || start > src_len - len then invalid_arg "Vec.sub"
  else 
  { len ; 
    arr = unsafe_sub src.arr start len }

let iter f d = 
  let arr = d.arr in 
  for i = 0 to d.len - 1 do
    f (Array.unsafe_get arr i)
  done

let iteri f d =
  let arr = d.arr in
  for i = 0 to d.len - 1 do
    f i (Array.unsafe_get arr i)
  done

let iter_range ~from ~to_ f d =
  if from < 0 || to_ >= d.len then invalid_arg "Resize_array.iter_range"
  else 
    let d_arr = d.arr in 
    for i = from to to_ do 
      f  (Array.unsafe_get d_arr i)
    done

let iteri_range ~from ~to_ f d =
  if from < 0 || to_ >= d.len then invalid_arg "Resize_array.iteri_range"
  else 
    let d_arr = d.arr in 
    for i = from to to_ do 
      f i (Array.unsafe_get d_arr i)
    done

let map_into_array f src =
  let src_len = src.len in 
  let src_arr = src.arr in 
  if src_len = 0 then [||]
  else 
    let first_one = f (Array.unsafe_get src_arr 0) in 
    let arr = Array.make  src_len  first_one in
    for i = 1 to src_len - 1 do
      Array.unsafe_set arr i (f (Array.unsafe_get src_arr i))
    done;
    arr 
let map_into_list f src = 
  let src_len = src.len in 
  let src_arr = src.arr in 
  if src_len = 0 then []
  else 
    let acc = ref [] in         
    for i =  src_len - 1 downto 0 do
      acc := f (Array.unsafe_get src_arr i) :: !acc
    done;
    !acc

let mapi f src =
  let len = src.len in 
  if len = 0 then { len ; arr = [| |] }
  else 
    let src_arr = src.arr in 
    let arr = Array.make len (Array.unsafe_get src_arr 0) in
    for i = 1 to len - 1 do
      Array.unsafe_set arr i (f i (Array.unsafe_get src_arr i))
    done;
    {
      len ;
      arr ;
    }

let fold_left f x a =
  let rec loop a_len (a_arr : elt array) idx x =
    if idx >= a_len then x else 
      loop a_len a_arr (idx + 1) (f x (Array.unsafe_get a_arr idx))
  in
  loop a.len a.arr 0 x

let fold_right f a x =
  let rec loop (a_arr : elt array) idx x =
    if idx < 0 then x
    else loop a_arr (idx - 1) (f (Array.unsafe_get a_arr idx) x)
  in
  loop a.arr (a.len - 1) x

(**  
   [filter] and [inplace_filter]
*)
let filter f d =
  let new_d = copy d in 
  let new_d_arr = new_d.arr in 
  let d_arr = d.arr in
  let p = ref 0 in
  for i = 0 to d.len  - 1 do
    let x = Array.unsafe_get d_arr i in
    (* TODO: can be optimized for segments blit *)
    if f x  then
      begin
        Array.unsafe_set new_d_arr !p x;
        incr p;
      end;
  done;
  new_d.len <- !p;
  new_d 

let equal eq x y : bool = 
  if x.len <> y.len then false 
  else 
    let rec aux x_arr y_arr i =
      if i < 0 then true else  
      if eq (Array.unsafe_get x_arr i) (Array.unsafe_get y_arr i) then 
        aux x_arr y_arr (i - 1)
      else false in 
    aux x.arr y.arr (x.len - 1)

let get d i = 
  if i < 0 || i >= d.len then invalid_arg "Resize_array.get"
  else Array.unsafe_get d.arr i
let unsafe_get d i = Array.unsafe_get d.arr i 
let last d = 
  if d.len <= 0 then invalid_arg   "Resize_array.last"
  else Array.unsafe_get d.arr (d.len - 1)

let capacity d = Array.length d.arr

(* Attention can not use {!Array.exists} since the bound is not the same *)  
let exists p d = 
  let a = d.arr in 
  let n = d.len in   
  let rec loop i =
    if i = n then false
    else if p (Array.unsafe_get a i) then true
    else loop (succ i) in
  loop 0

let map f src =
  let src_len = src.len in 
  if src_len = 0 then { len = 0 ; arr = [||]}
  (* TODO: we may share the empty array 
     but sharing mutable state is very challenging, 
     the tricky part is to avoid mutating the immutable array,
     here it looks fine -- 
     invariant: whenever [.arr] mutated, make sure  it is not an empty array
     Actually no: since starting from an empty array 
     {[
       push v (* the address of v should not be changed *)
     ]}
  *)
  else 
    let src_arr = src.arr in 
    let first = f (Array.unsafe_get src_arr 0 ) in 
    let arr = Array.make  src_len first in
    for i = 1 to src_len - 1 do
      Array.unsafe_set arr i (f (Array.unsafe_get src_arr i))
    done;
    {
      len = src_len;
      arr = arr;
    }

let init len f =
  if len < 0 then invalid_arg  "Resize_array.init"
  else if len = 0 then { len = 0 ; arr = [||] }
  else 
    let first = f 0 in 
    let arr = Array.make len first in
    for i = 1 to len - 1 do
      Array.unsafe_set arr i (f i)
    done;
    {

      len ;
      arr 
    }



  let make initsize : t =
    if initsize < 0 then invalid_arg  "Resize_array.make" ;
    {

      len = 0;
      arr = Array.make  initsize null ;
    }



  let reserve (d : t ) s = 
    let d_len = d.len in 
    let d_arr = d.arr in 
    if s < d_len || s < Array.length d_arr then ()
    else 
      let new_capacity = min Sys.max_array_length s in 
      let new_d_arr = Array.make new_capacity null in 
       unsafe_blit d_arr 0 new_d_arr 0 d_len;
      d.arr <- new_d_arr 

  let push v (d : t) =
    let d_len = d.len in
    let d_arr = d.arr in 
    let d_arr_len = Array.length d_arr in
    if d_arr_len = 0 then
      begin 
        d.len <- 1 ;
        d.arr <- [| v |]
      end
    else  
      begin 
        if d_len = d_arr_len then 
          begin
            if d_len >= Sys.max_array_length then 
              failwith "exceeds max_array_length";
            let new_capacity = min Sys.max_array_length d_len * 2 
            (* [d_len] can not be zero, so [*2] will enlarge   *)
            in
            let new_d_arr = Array.make new_capacity null in 
            d.arr <- new_d_arr;
             unsafe_blit d_arr 0 new_d_arr 0 d_len ;
          end;
        d.len <- d_len + 1;
        Array.unsafe_set d.arr d_len v
      end

(** delete element at offset [idx], will raise exception when have invalid input *)
  let delete (d : t) idx =
    let d_len = d.len in 
    if idx < 0 || idx >= d_len then invalid_arg "Resize_array.delete" ;
    let arr = d.arr in 
     unsafe_blit arr (idx + 1) arr idx  (d_len - idx - 1);
    let idx = d_len - 1 in 
    d.len <- idx
    
# 362
(** pop the last element, a specialized version of [delete] *)
  let pop (d : t) = 
    let idx  = d.len - 1  in
    if idx < 0 then invalid_arg "Resize_array.pop";
    d.len <- idx
  
# 373
(** pop and return the last element *)  
  let get_last_and_pop (d : t) = 
    let idx  = d.len - 1  in
    if idx < 0 then invalid_arg "Resize_array.get_last_and_pop";
    let last = Array.unsafe_get d.arr idx in 
    d.len <- idx 
    
# 384
    ;
    last 

(** delete elements start from [idx] with length [len] *)
  let delete_range (d : t) idx len =
    let d_len = d.len in 
    if len < 0 || idx < 0 || idx + len > d_len then invalid_arg  "Resize_array.delete_range"  ;
    let arr = d.arr in 
     unsafe_blit arr (idx + len) arr idx (d_len  - idx - len);
    d.len <- d_len - len

# 402
(** delete elements from [idx] with length [len] return the deleted elements as a new vec*)
  let get_and_delete_range (d : t) idx len : t = 
    let d_len = d.len in 
    if len < 0 || idx < 0 || idx + len > d_len then invalid_arg  "Resize_array.get_and_delete_range"  ;
    let arr = d.arr in 
    let value =  unsafe_sub arr idx len in
     unsafe_blit arr (idx + len) arr idx (d_len  - idx - len);
    d.len <- d_len - len; 
    
# 416
    {len = len ; arr = value}


  (** Below are simple wrapper around normal Array operations *)  

  let clear (d : t ) =
    
# 428
    d.len <- 0



  let inplace_filter f (d : t) : unit = 
    let d_arr = d.arr in     
    let d_len = d.len in
    let p = ref 0 in
    for i = 0 to d_len - 1 do 
      let x = Array.unsafe_get d_arr i in 
      if f x then 
        begin 
          let curr_p = !p in 
          (if curr_p <> i then 
             Array.unsafe_set d_arr curr_p x) ;
          incr p
        end
    done ;
    let last = !p  in 
    
# 448
    d.len <-  last 
    (* INT , there is not need to reset it, since it will cause GC behavior *)

  
# 454
  let inplace_filter_from start f (d : t) : unit = 
    if start < 0 then invalid_arg "Vec.inplace_filter_from"; 
    let d_arr = d.arr in     
    let d_len = d.len in
    let p = ref start in    
    for i = start to d_len - 1 do 
      let x = Array.unsafe_get d_arr i in 
      if f x then 
        begin 
          let curr_p = !p in 
          (if curr_p <> i then 
             Array.unsafe_set d_arr curr_p x) ;
          incr p
        end
    done ;
    let last = !p  in 
    
# 471
    d.len <-  last 


# 477
(** inplace filter the elements and accumulate the non-filtered elements *)
  let inplace_filter_with  f ~cb_no acc (d : t)  = 
    let d_arr = d.arr in     
    let p = ref 0 in
    let d_len = d.len in
    let acc = ref acc in 
    for i = 0 to d_len - 1 do 
      let x = Array.unsafe_get d_arr i in 
      if f x then 
        begin 
          let curr_p = !p in 
          (if curr_p <> i then 
             Array.unsafe_set d_arr curr_p x) ;
          incr p
        end
      else 
        acc := cb_no  x  !acc
    done ;
    let last = !p  in 
    
# 497
    d.len <-  last 
    (* INT , there is not need to reset it, since it will cause GC behavior *)
    
# 502
    ; !acc 




end
module Resize_array : sig 
#1 "resize_array.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

module Make ( Resize : Vec_gen.ResizeType) : Vec_gen.S with type elt = Resize.t 



end = struct
#1 "resize_array.ml"
# 1 "ext/vec.cppo.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)
# 25
external unsafe_blit : 
    'a array -> int -> 'a array -> int -> int -> unit = "caml_array_blit"
module Make ( Resize :  Vec_gen.ResizeType) = struct
  type elt = Resize.t 

  let null = Resize.null 
  

# 41
external unsafe_sub : 'a array -> int -> int -> 'a array = "caml_array_sub"

type  t = {
  mutable arr : elt array ;
  mutable len : int ;  
}

let length d = d.len

let compact d =
  let d_arr = d.arr in 
  if d.len <> Array.length d_arr then 
    begin
      let newarr = unsafe_sub d_arr 0 d.len in 
      d.arr <- newarr
    end
let singleton v = 
  {
    len = 1 ; 
    arr = [|v|]
  }

let empty () =
  {
    len = 0;
    arr = [||];
  }

let is_empty d =
  d.len = 0

let reset d = 
  d.len <- 0; 
  d.arr <- [||]


(* For [to_*] operations, we should be careful to call {!Array.*} function 
   in case we operate on the whole array
*)
let to_list d =
  let rec loop (d_arr : elt array) idx accum =
    if idx < 0 then accum else loop d_arr (idx - 1) (Array.unsafe_get d_arr idx :: accum)
  in
  loop d.arr (d.len - 1) []


let of_list lst =
  let arr = Array.of_list lst in 
  { arr ; len = Array.length arr}


let to_array d = 
  unsafe_sub d.arr 0 d.len

let of_array src =
  {
    len = Array.length src;
    arr = Array.copy src;
    (* okay to call {!Array.copy}*)
  }
let of_sub_array arr off len = 
  { 
    len = len ; 
    arr = Array.sub arr off len  
  }  
let unsafe_internal_array v = v.arr  
(* we can not call {!Array.copy} *)
let copy src =
  let len = src.len in
  {
    len ;
    arr = unsafe_sub src.arr 0 len ;
  }

(* FIXME *)
let reverse_in_place src = 
  Ext_array.reverse_range src.arr 0 src.len 




(* {!Array.sub} is not enough for error checking, it 
   may contain some garbage
 *)
let sub (src : t) start len =
  let src_len = src.len in 
  if len < 0 || start > src_len - len then invalid_arg "Vec.sub"
  else 
  { len ; 
    arr = unsafe_sub src.arr start len }

let iter f d = 
  let arr = d.arr in 
  for i = 0 to d.len - 1 do
    f (Array.unsafe_get arr i)
  done

let iteri f d =
  let arr = d.arr in
  for i = 0 to d.len - 1 do
    f i (Array.unsafe_get arr i)
  done

let iter_range ~from ~to_ f d =
  if from < 0 || to_ >= d.len then invalid_arg "Resize_array.iter_range"
  else 
    let d_arr = d.arr in 
    for i = from to to_ do 
      f  (Array.unsafe_get d_arr i)
    done

let iteri_range ~from ~to_ f d =
  if from < 0 || to_ >= d.len then invalid_arg "Resize_array.iteri_range"
  else 
    let d_arr = d.arr in 
    for i = from to to_ do 
      f i (Array.unsafe_get d_arr i)
    done

let map_into_array f src =
  let src_len = src.len in 
  let src_arr = src.arr in 
  if src_len = 0 then [||]
  else 
    let first_one = f (Array.unsafe_get src_arr 0) in 
    let arr = Array.make  src_len  first_one in
    for i = 1 to src_len - 1 do
      Array.unsafe_set arr i (f (Array.unsafe_get src_arr i))
    done;
    arr 
let map_into_list f src = 
  let src_len = src.len in 
  let src_arr = src.arr in 
  if src_len = 0 then []
  else 
    let acc = ref [] in         
    for i =  src_len - 1 downto 0 do
      acc := f (Array.unsafe_get src_arr i) :: !acc
    done;
    !acc

let mapi f src =
  let len = src.len in 
  if len = 0 then { len ; arr = [| |] }
  else 
    let src_arr = src.arr in 
    let arr = Array.make len (Array.unsafe_get src_arr 0) in
    for i = 1 to len - 1 do
      Array.unsafe_set arr i (f i (Array.unsafe_get src_arr i))
    done;
    {
      len ;
      arr ;
    }

let fold_left f x a =
  let rec loop a_len (a_arr : elt array) idx x =
    if idx >= a_len then x else 
      loop a_len a_arr (idx + 1) (f x (Array.unsafe_get a_arr idx))
  in
  loop a.len a.arr 0 x

let fold_right f a x =
  let rec loop (a_arr : elt array) idx x =
    if idx < 0 then x
    else loop a_arr (idx - 1) (f (Array.unsafe_get a_arr idx) x)
  in
  loop a.arr (a.len - 1) x

(**  
   [filter] and [inplace_filter]
*)
let filter f d =
  let new_d = copy d in 
  let new_d_arr = new_d.arr in 
  let d_arr = d.arr in
  let p = ref 0 in
  for i = 0 to d.len  - 1 do
    let x = Array.unsafe_get d_arr i in
    (* TODO: can be optimized for segments blit *)
    if f x  then
      begin
        Array.unsafe_set new_d_arr !p x;
        incr p;
      end;
  done;
  new_d.len <- !p;
  new_d 

let equal eq x y : bool = 
  if x.len <> y.len then false 
  else 
    let rec aux x_arr y_arr i =
      if i < 0 then true else  
      if eq (Array.unsafe_get x_arr i) (Array.unsafe_get y_arr i) then 
        aux x_arr y_arr (i - 1)
      else false in 
    aux x.arr y.arr (x.len - 1)

let get d i = 
  if i < 0 || i >= d.len then invalid_arg "Resize_array.get"
  else Array.unsafe_get d.arr i
let unsafe_get d i = Array.unsafe_get d.arr i 
let last d = 
  if d.len <= 0 then invalid_arg   "Resize_array.last"
  else Array.unsafe_get d.arr (d.len - 1)

let capacity d = Array.length d.arr

(* Attention can not use {!Array.exists} since the bound is not the same *)  
let exists p d = 
  let a = d.arr in 
  let n = d.len in   
  let rec loop i =
    if i = n then false
    else if p (Array.unsafe_get a i) then true
    else loop (succ i) in
  loop 0

let map f src =
  let src_len = src.len in 
  if src_len = 0 then { len = 0 ; arr = [||]}
  (* TODO: we may share the empty array 
     but sharing mutable state is very challenging, 
     the tricky part is to avoid mutating the immutable array,
     here it looks fine -- 
     invariant: whenever [.arr] mutated, make sure  it is not an empty array
     Actually no: since starting from an empty array 
     {[
       push v (* the address of v should not be changed *)
     ]}
  *)
  else 
    let src_arr = src.arr in 
    let first = f (Array.unsafe_get src_arr 0 ) in 
    let arr = Array.make  src_len first in
    for i = 1 to src_len - 1 do
      Array.unsafe_set arr i (f (Array.unsafe_get src_arr i))
    done;
    {
      len = src_len;
      arr = arr;
    }

let init len f =
  if len < 0 then invalid_arg  "Resize_array.init"
  else if len = 0 then { len = 0 ; arr = [||] }
  else 
    let first = f 0 in 
    let arr = Array.make len first in
    for i = 1 to len - 1 do
      Array.unsafe_set arr i (f i)
    done;
    {

      len ;
      arr 
    }



  let make initsize : t =
    if initsize < 0 then invalid_arg  "Resize_array.make" ;
    {

      len = 0;
      arr = Array.make  initsize null ;
    }



  let reserve (d : t ) s = 
    let d_len = d.len in 
    let d_arr = d.arr in 
    if s < d_len || s < Array.length d_arr then ()
    else 
      let new_capacity = min Sys.max_array_length s in 
      let new_d_arr = Array.make new_capacity null in 
       unsafe_blit d_arr 0 new_d_arr 0 d_len;
      d.arr <- new_d_arr 

  let push v (d : t) =
    let d_len = d.len in
    let d_arr = d.arr in 
    let d_arr_len = Array.length d_arr in
    if d_arr_len = 0 then
      begin 
        d.len <- 1 ;
        d.arr <- [| v |]
      end
    else  
      begin 
        if d_len = d_arr_len then 
          begin
            if d_len >= Sys.max_array_length then 
              failwith "exceeds max_array_length";
            let new_capacity = min Sys.max_array_length d_len * 2 
            (* [d_len] can not be zero, so [*2] will enlarge   *)
            in
            let new_d_arr = Array.make new_capacity null in 
            d.arr <- new_d_arr;
             unsafe_blit d_arr 0 new_d_arr 0 d_len ;
          end;
        d.len <- d_len + 1;
        Array.unsafe_set d.arr d_len v
      end

(** delete element at offset [idx], will raise exception when have invalid input *)
  let delete (d : t) idx =
    let d_len = d.len in 
    if idx < 0 || idx >= d_len then invalid_arg "Resize_array.delete" ;
    let arr = d.arr in 
     unsafe_blit arr (idx + 1) arr idx  (d_len - idx - 1);
    let idx = d_len - 1 in 
    d.len <- idx
    
# 358
    ;
    Array.unsafe_set arr idx  null
    
# 362
(** pop the last element, a specialized version of [delete] *)
  let pop (d : t) = 
    let idx  = d.len - 1  in
    if idx < 0 then invalid_arg "Resize_array.pop";
    d.len <- idx
    
# 369
    ;    
    Array.unsafe_set d.arr idx null
  
# 373
(** pop and return the last element *)  
  let get_last_and_pop (d : t) = 
    let idx  = d.len - 1  in
    if idx < 0 then invalid_arg "Resize_array.get_last_and_pop";
    let last = Array.unsafe_get d.arr idx in 
    d.len <- idx 
    
# 381
    ;
    Array.unsafe_set d.arr idx null
    
# 384
    ;
    last 

(** delete elements start from [idx] with length [len] *)
  let delete_range (d : t) idx len =
    let d_len = d.len in 
    if len < 0 || idx < 0 || idx + len > d_len then invalid_arg  "Resize_array.delete_range"  ;
    let arr = d.arr in 
     unsafe_blit arr (idx + len) arr idx (d_len  - idx - len);
    d.len <- d_len - len
    
# 396
    ;
    for i = d_len - len to d_len - 1 do
      Array.unsafe_set arr i null
    done

# 402
(** delete elements from [idx] with length [len] return the deleted elements as a new vec*)
  let get_and_delete_range (d : t) idx len : t = 
    let d_len = d.len in 
    if len < 0 || idx < 0 || idx + len > d_len then invalid_arg  "Resize_array.get_and_delete_range"  ;
    let arr = d.arr in 
    let value =  unsafe_sub arr idx len in
     unsafe_blit arr (idx + len) arr idx (d_len  - idx - len);
    d.len <- d_len - len; 
    
# 412
    for i = d_len - len to d_len - 1 do
      Array.unsafe_set arr i null
    done;
    
# 416
    {len = len ; arr = value}


  (** Below are simple wrapper around normal Array operations *)  

  let clear (d : t ) =
    
# 424
    for i = 0 to d.len - 1 do 
      Array.unsafe_set d.arr i null
    done;
    
# 428
    d.len <- 0



  let inplace_filter f (d : t) : unit = 
    let d_arr = d.arr in     
    let d_len = d.len in
    let p = ref 0 in
    for i = 0 to d_len - 1 do 
      let x = Array.unsafe_get d_arr i in 
      if f x then 
        begin 
          let curr_p = !p in 
          (if curr_p <> i then 
             Array.unsafe_set d_arr curr_p x) ;
          incr p
        end
    done ;
    let last = !p  in 
    
# 451
    delete_range d last  (d_len - last)

  
# 454
  let inplace_filter_from start f (d : t) : unit = 
    if start < 0 then invalid_arg "Vec.inplace_filter_from"; 
    let d_arr = d.arr in     
    let d_len = d.len in
    let p = ref start in    
    for i = start to d_len - 1 do 
      let x = Array.unsafe_get d_arr i in 
      if f x then 
        begin 
          let curr_p = !p in 
          (if curr_p <> i then 
             Array.unsafe_set d_arr curr_p x) ;
          incr p
        end
    done ;
    let last = !p  in 
    
# 473
    delete_range d last  (d_len - last)


# 477
(** inplace filter the elements and accumulate the non-filtered elements *)
  let inplace_filter_with  f ~cb_no acc (d : t)  = 
    let d_arr = d.arr in     
    let p = ref 0 in
    let d_len = d.len in
    let acc = ref acc in 
    for i = 0 to d_len - 1 do 
      let x = Array.unsafe_get d_arr i in 
      if f x then 
        begin 
          let curr_p = !p in 
          (if curr_p <> i then 
             Array.unsafe_set d_arr curr_p x) ;
          incr p
        end
      else 
        acc := cb_no  x  !acc
    done ;
    let last = !p  in 
    
# 500
    delete_range d last  (d_len - last)
    
# 502
    ; !acc 



# 507
end

end
module Int_vec_vec : sig 
#1 "int_vec_vec.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

include Vec_gen.S with type elt = Int_vec.t

end = struct
#1 "int_vec_vec.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


include Resize_array.Make(struct type t = Int_vec.t let null = Int_vec.empty () end)

end
module Ext_scc : sig 
#1 "ext_scc.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)
 



type node = Int_vec.t
(** Assume input is int array with offset from 0 
    Typical input 
    {[
      [|
        [ 1 ; 2 ]; // 0 -> 1,  0 -> 2 
        [ 1 ];   // 0 -> 1 
        [ 2 ]  // 0 -> 2 
      |]
    ]}
    Note that we can tell how many nodes by calculating 
    [Array.length] of the input 
*)
val graph : Int_vec.t array -> Int_vec_vec.t


(** Used for unit test *)
val graph_check : node array -> int * int list 

end = struct
#1 "ext_scc.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)
 
type node = Int_vec.t 
(** 
   [int] as data for this algorithm
   Pros:
   1. Easy to eoncode algorithm (especially given that the capacity of node is known)
   2. Algorithms itself are much more efficient
   3. Node comparison semantics is clear
   4. Easy to print output
   Cons:
   1. post processing input data  
 *)
let min_int (x : int) y = if x < y then x else y  


let graph  e =
  let index = ref 0 in 
  let s = Int_vec.empty () in

  let output = Int_vec_vec.empty () in (* collect output *)
  let node_numes = Array.length e in
  
  let on_stack_array = Array.make node_numes false in
  let index_array = Array.make node_numes (-1) in 
  let lowlink_array = Array.make node_numes (-1) in
  
  let rec scc v_data  =
    let new_index = !index + 1 in 
    index := new_index ;
    Int_vec.push  v_data s ; 

    index_array.(v_data) <- new_index ;  
    lowlink_array.(v_data) <- new_index ; 
    on_stack_array.(v_data) <- true ;
    
    let v = e.(v_data) in 
    v
    |> Int_vec.iter (fun w_data  ->
        if Array.unsafe_get index_array w_data < 0 then (* not processed *)
          begin  
            scc w_data;
            Array.unsafe_set lowlink_array v_data  
              (min_int (Array.unsafe_get lowlink_array v_data) (Array.unsafe_get lowlink_array w_data))
          end  
        else if Array.unsafe_get on_stack_array w_data then 
          (* successor is in stack and hence in current scc *)
          begin 
            Array.unsafe_set lowlink_array v_data  
              (min_int (Array.unsafe_get lowlink_array v_data) (Array.unsafe_get lowlink_array w_data))
          end
      ) ; 

    if Array.unsafe_get lowlink_array v_data = Array.unsafe_get index_array v_data then
      (* start a new scc *)
      begin
        let s_len = Int_vec.length s in
        let last_index = ref (s_len - 1) in 
        let u = ref (Int_vec.unsafe_get s !last_index) in
        while  !u <> v_data do 
          Array.unsafe_set on_stack_array (!u)  false ; 
          last_index := !last_index - 1;
          u := Int_vec.unsafe_get s !last_index
        done ;
        on_stack_array.(v_data) <- false; (* necessary *)
        Int_vec_vec.push   (Int_vec.get_and_delete_range s !last_index (s_len  - !last_index)) output;
      end   
  in
  for i = 0 to node_numes - 1 do 
    if Array.unsafe_get index_array i < 0 then scc i
  done ;
  output 

let graph_check v = 
  let v = graph v in 
  Int_vec_vec.length v, 
  Int_vec_vec.fold_left (fun acc x -> Int_vec.length x :: acc ) [] v  

end
module Hash_set_ident_mask : sig 
#1 "hash_set_ident_mask.mli"


(** Based on [hash_set] specialized for mask operations  *)
type ident = Ident.t  


type t
val create: int ->  t


(* add one ident *)
val add_unmask :  t -> ident -> unit


(** [check_mask h key] if [key] exists mask it otherwise nothing
    return true if all keys are masked otherwise false
*)
val mask_check_all_hit : ident ->  t -> bool

(** [iter_and_unmask f h] iterating the collection and mask all idents,
    dont consul the collection in function [f]
    TODO: what happens if an exception raised in the callback,
    would the hashtbl still be in consistent state?
*)
val iter_and_unmask: (ident -> bool ->  unit) ->  t -> unit



  

end = struct
#1 "hash_set_ident_mask.ml"

(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)



type ident = Ident.t

type key = {ident : ident ; mutable mask : bool }

type t = {
  mutable size : int ; 
  mutable data : key list array;
  initial_size : int ; 
  mutable mask_size : int (* mark how many idents are marked *)
}



let key_index_by_ident (h : t) (key : Ident.t) =    
  (Bs_hash_stubs.hash_string_int  key.name key.stamp) land (Array.length h.data - 1)

let key_index (h :  t ) ({ident = key} : key) =
  key_index_by_ident h key 


let create  initial_size =
  let s = Ext_util.power_2_above 8 initial_size in
  { initial_size = s; size = 0; data = Array.make s [] ; mask_size = 0}

let iter_and_unmask f h =
  let rec do_bucket buckets = 
    match buckets with 
    | [ ] ->
      ()
    | k ::  rest ->    
      f k.ident k.mask ;
      if k.mask then 
        begin 
          k.mask <- false ;
          (* we can set [h.mask_size] to zero,
             however, it would result inconsistent state
             once [f] throw
          *)
          h.mask_size <- h.mask_size - 1
        end; 
      do_bucket rest 
  in
  let d = h.data in
  for i = 0 to Array.length d - 1 do
    do_bucket (Array.unsafe_get d i)
  done
  

let rec small_bucket_mem key lst =
  match lst with 
  | [] -> false 
  | {ident = key1 }::rest -> 
    Ext_ident.equal key   key1 ||
    match rest with 
    | [] -> false 
    | {ident = key2} :: rest -> 
      Ext_ident.equal key   key2 ||
      match rest with 
      | [] -> false 
      | {ident = key3; _} :: rest -> 
        Ext_ident.equal key   key3 ||
        small_bucket_mem key rest 

let resize indexfun h =
  let odata = h.data in
  let osize = Array.length odata in
  let nsize = osize * 2 in
  if nsize < Sys.max_array_length then begin
    let ndata = Array.make nsize [ ] in
    h.data <- ndata;          (* so that indexfun sees the new bucket count *)
    let rec insert_bucket = function
        [ ] -> ()
      | key :: rest ->
        let nidx = indexfun h key in
        ndata.(nidx) <- key :: ndata.(nidx);
        insert_bucket rest
    in
    for i = 0 to osize - 1 do
      insert_bucket (Array.unsafe_get odata i)
    done
  end

let add_unmask (h : t) (key : Ident.t) =
  let i = key_index_by_ident h key  in 
  let h_data = h.data in 
  let old_bucket = Array.unsafe_get h_data i in
  if not (small_bucket_mem key old_bucket) then 
    begin 
      Array.unsafe_set h_data i ({ident = key; mask = false} :: old_bucket);
      h.size <- h.size + 1 ;
      if h.size > Array.length h_data lsl 1 then resize key_index h
    end




let rec small_bucket_mask  key lst =
  match lst with 
  | [] -> false 
  | key1::rest -> 
    if Ext_ident.equal key   key1.ident  then 
      if key1.mask then false else (key1.mask <- true ; true) 
    else 
      match rest with 
      | [] -> false
      | key2 :: rest -> 
        if Ext_ident.equal key key2.ident  then 
          if key2.mask then false else (key2.mask <- true ; true)
        else 
          match rest with 
          | [] -> false
          | key3 :: rest -> 
            if Ext_ident.equal key key3.ident then 
              if key3.mask then false else (key3.mask <- true ; true)
            else 
              small_bucket_mask  key rest 

let mask_check_all_hit (key : Ident.t) (h : t)  =     
  if 
    small_bucket_mask key 
      (Array.unsafe_get h.data (key_index_by_ident h key )) then 
    begin 
      h.mask_size <- h.mask_size + 1 
    end;
  h.size = h.mask_size 




end
module Ident_hash_set : sig 
#1 "ident_hash_set.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


include Hash_set_gen.S with type key = Ident.t

end = struct
#1 "ident_hash_set.ml"
# 1 "ext/hash_set.cppo.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)
# 37
type key = Ident.t
let key_index (h :  _ Hash_set_gen.t ) (key : key) =
  (Bs_hash_stubs.hash_string_int  key.name key.stamp) land (Array.length h.data - 1)
let eq_key = Ext_ident.equal
type t = key Hash_set_gen.t


# 62
let create = Hash_set_gen.create
let clear = Hash_set_gen.clear
let reset = Hash_set_gen.reset
let copy = Hash_set_gen.copy
let iter = Hash_set_gen.iter
let fold = Hash_set_gen.fold
let length = Hash_set_gen.length
let stats = Hash_set_gen.stats
let elements = Hash_set_gen.elements



let remove (h : _ Hash_set_gen.t) key =  
  let i = key_index h key in
  let h_data = h.data in
  let old_h_size = h.size in 
  let new_bucket = Hash_set_gen.remove_bucket eq_key key h (Array.unsafe_get h_data i) in
  if old_h_size <> h.size then  
    Array.unsafe_set h_data i new_bucket



let add (h : _ Hash_set_gen.t) key =
  let i = key_index h key  in 
  let h_data = h.data in 
  let old_bucket = (Array.unsafe_get h_data i) in
  if not (Hash_set_gen.small_bucket_mem eq_key key old_bucket) then 
    begin 
      Array.unsafe_set h_data i (key :: old_bucket);
      h.size <- h.size + 1 ;
      if h.size > Array.length h_data lsl 1 then Hash_set_gen.resize key_index h
    end

let of_array arr = 
  let len = Array.length arr in 
  let tbl = create len in 
  for i = 0 to len - 1  do
    add tbl (Array.unsafe_get arr i);
  done ;
  tbl 
  
    
let check_add (h : _ Hash_set_gen.t) key =
  let i = key_index h key  in 
  let h_data = h.data in  
  let old_bucket = (Array.unsafe_get h_data i) in
  if not (Hash_set_gen.small_bucket_mem eq_key key old_bucket) then 
    begin 
      Array.unsafe_set h_data i  (key :: old_bucket);
      h.size <- h.size + 1 ;
      if h.size > Array.length h_data lsl 1 then Hash_set_gen.resize key_index h;
      true 
    end
  else false 


let mem (h :  _ Hash_set_gen.t) key =
  Hash_set_gen.small_bucket_mem eq_key key (Array.unsafe_get h.data (key_index h key)) 

  

end
module Ident_hashtbl : sig 
#1 "ident_hashtbl.mli"


include Hashtbl_gen.S with type key = Ident.t 



end = struct
#1 "ident_hashtbl.ml"
# 2 "ext/hashtbl.cppo.ml"
type key = Ident.t 
type 'a t = (key, 'a)  Hashtbl_gen.t 
let key_index (h : _ t ) (key : key) =
  (Bs_hash_stubs.hash_stamp_and_name  key.stamp key.name ) land (Array.length h.data - 1)
(* (Bs_hash_stubs.hash_string_int  key.name key.stamp ) land (Array.length h.data - 1) *)
let eq_key = Ext_ident.equal 

# 33
type ('a, 'b) bucketlist = ('a,'b) Hashtbl_gen.bucketlist
let create = Hashtbl_gen.create
let clear = Hashtbl_gen.clear
let reset = Hashtbl_gen.reset
let copy = Hashtbl_gen.copy
let iter = Hashtbl_gen.iter
let fold = Hashtbl_gen.fold
let length = Hashtbl_gen.length
let stats = Hashtbl_gen.stats



let add (h : _ t) key info =
  let i = key_index h key in
  let h_data = h.data in   
  Array.unsafe_set h_data i (Cons(key, info, (Array.unsafe_get h_data i)));
  h.size <- h.size + 1;
  if h.size > Array.length h_data lsl 1 then Hashtbl_gen.resize key_index h

(* after upgrade to 4.04 we should provide an efficient [replace_or_init] *)
let modify_or_init (h : _ t) key modf default =
  let rec find_bucket (bucketlist : _ bucketlist)  =
    match bucketlist with
    | Cons(k,i,next) ->
      if eq_key k key then begin modf i; false end
      else find_bucket next 
    | Empty -> true in
  let i = key_index h key in 
  let h_data = h.data in 
  if find_bucket (Array.unsafe_get h_data i) then
    begin 
      Array.unsafe_set h_data i  (Cons(key,default (), Array.unsafe_get h_data i));
      h.size <- h.size + 1 ;
      if h.size > Array.length h_data lsl 1 then Hashtbl_gen.resize key_index h 
    end


let rec remove_bucket key (h : _ t) (bucketlist : _ bucketlist) : _ bucketlist = 
  match bucketlist with  
  | Empty ->
    Empty
  | Cons(k, i, next) ->
    if eq_key k key 
    then begin h.size <- h.size - 1; next end
    else Cons(k, i, remove_bucket key h next) 

let remove (h : _ t ) key =
  let i = key_index h key in
  let h_data = h.data in 
  let old_h_szie = h.size in 
  let new_bucket = remove_bucket key h (Array.unsafe_get h_data i) in  
  if old_h_szie <> h.size then 
    Array.unsafe_set h_data i  new_bucket

let rec find_rec key (bucketlist : _ bucketlist) = match bucketlist with  
  | Empty ->
    raise Not_found
  | Cons(k, d, rest) ->
    if eq_key key k then d else find_rec key rest

let find_exn (h : _ t) key =
  match Array.unsafe_get h.data (key_index h key) with
  | Empty -> raise Not_found
  | Cons(k1, d1, rest1) ->
    if eq_key key k1 then d1 else
      match rest1 with
      | Empty -> raise Not_found
      | Cons(k2, d2, rest2) ->
        if eq_key key k2 then d2 else
          match rest2 with
          | Empty -> raise Not_found
          | Cons(k3, d3, rest3) ->
            if eq_key key k3  then d3 else find_rec key rest3

let find_opt (h : _ t) key =
  Hashtbl_gen.small_bucket_opt eq_key key (Array.unsafe_get h.data (key_index h key))

let find_key_opt (h : _ t) key =
  Hashtbl_gen.small_bucket_key_opt eq_key key (Array.unsafe_get h.data (key_index h key))
  
let find_default (h : _ t) key default = 
  Hashtbl_gen.small_bucket_default eq_key key default (Array.unsafe_get h.data (key_index h key))
let find_all (h : _ t) key =
  let rec find_in_bucket (bucketlist : _ bucketlist) = match bucketlist with 
    | Empty ->
      []
    | Cons(k, d, rest) ->
      if eq_key k key 
      then d :: find_in_bucket rest
      else find_in_bucket rest in
  find_in_bucket (Array.unsafe_get h.data (key_index h key))

let replace h key info =
  let rec replace_bucket (bucketlist : _ bucketlist) : _ bucketlist = match bucketlist with 
    | Empty ->
      raise_notrace Not_found
    | Cons(k, i, next) ->
      if eq_key k key
      then Cons(key, info, next)
      else Cons(k, i, replace_bucket next) in
  let i = key_index h key in
  let h_data = h.data in 
  let l = Array.unsafe_get h_data i in
  try
    Array.unsafe_set h_data i  (replace_bucket l)
  with Not_found ->
    begin 
      Array.unsafe_set h_data i (Cons(key, info, l));
      h.size <- h.size + 1;
      if h.size > Array.length h_data lsl 1 then Hashtbl_gen.resize key_index h;
    end 

let mem (h : _ t) key =
  let rec mem_in_bucket (bucketlist : _ bucketlist) = match bucketlist with 
    | Empty ->
      false
    | Cons(k, d, rest) ->
      eq_key k key  || mem_in_bucket rest in
  mem_in_bucket (Array.unsafe_get h.data (key_index h key))


let of_list2 ks vs = 
  let len = List.length ks in 
  let map = create len in 
  List.iter2 (fun k v -> add map k v) ks vs ; 
  map


end
module Ext_int : sig 
#1 "ext_int.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


type t = int
val compare : t -> t -> int 
val equal : t -> t -> bool 

end = struct
#1 "ext_int.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


type t = int

let compare (x : t) (y : t) = Pervasives.compare x y 

let equal (x : t) (y : t) = x = y

end
module Int_hashtbl : sig 
#1 "int_hashtbl.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)



include Hashtbl_gen.S with type key = int




end = struct
#1 "int_hashtbl.ml"
# 15 "ext/hashtbl.cppo.ml"
type key = int 
type 'a t = (key, 'a)  Hashtbl_gen.t 
let key_index (h : _ t ) (key : key) =
  (Bs_hash_stubs.hash_int  key ) land (Array.length h.data - 1)
let eq_key = Ext_int.equal   


# 33
type ('a, 'b) bucketlist = ('a,'b) Hashtbl_gen.bucketlist
let create = Hashtbl_gen.create
let clear = Hashtbl_gen.clear
let reset = Hashtbl_gen.reset
let copy = Hashtbl_gen.copy
let iter = Hashtbl_gen.iter
let fold = Hashtbl_gen.fold
let length = Hashtbl_gen.length
let stats = Hashtbl_gen.stats



let add (h : _ t) key info =
  let i = key_index h key in
  let h_data = h.data in   
  Array.unsafe_set h_data i (Cons(key, info, (Array.unsafe_get h_data i)));
  h.size <- h.size + 1;
  if h.size > Array.length h_data lsl 1 then Hashtbl_gen.resize key_index h

(* after upgrade to 4.04 we should provide an efficient [replace_or_init] *)
let modify_or_init (h : _ t) key modf default =
  let rec find_bucket (bucketlist : _ bucketlist)  =
    match bucketlist with
    | Cons(k,i,next) ->
      if eq_key k key then begin modf i; false end
      else find_bucket next 
    | Empty -> true in
  let i = key_index h key in 
  let h_data = h.data in 
  if find_bucket (Array.unsafe_get h_data i) then
    begin 
      Array.unsafe_set h_data i  (Cons(key,default (), Array.unsafe_get h_data i));
      h.size <- h.size + 1 ;
      if h.size > Array.length h_data lsl 1 then Hashtbl_gen.resize key_index h 
    end


let rec remove_bucket key (h : _ t) (bucketlist : _ bucketlist) : _ bucketlist = 
  match bucketlist with  
  | Empty ->
    Empty
  | Cons(k, i, next) ->
    if eq_key k key 
    then begin h.size <- h.size - 1; next end
    else Cons(k, i, remove_bucket key h next) 

let remove (h : _ t ) key =
  let i = key_index h key in
  let h_data = h.data in 
  let old_h_szie = h.size in 
  let new_bucket = remove_bucket key h (Array.unsafe_get h_data i) in  
  if old_h_szie <> h.size then 
    Array.unsafe_set h_data i  new_bucket

let rec find_rec key (bucketlist : _ bucketlist) = match bucketlist with  
  | Empty ->
    raise Not_found
  | Cons(k, d, rest) ->
    if eq_key key k then d else find_rec key rest

let find_exn (h : _ t) key =
  match Array.unsafe_get h.data (key_index h key) with
  | Empty -> raise Not_found
  | Cons(k1, d1, rest1) ->
    if eq_key key k1 then d1 else
      match rest1 with
      | Empty -> raise Not_found
      | Cons(k2, d2, rest2) ->
        if eq_key key k2 then d2 else
          match rest2 with
          | Empty -> raise Not_found
          | Cons(k3, d3, rest3) ->
            if eq_key key k3  then d3 else find_rec key rest3

let find_opt (h : _ t) key =
  Hashtbl_gen.small_bucket_opt eq_key key (Array.unsafe_get h.data (key_index h key))

let find_key_opt (h : _ t) key =
  Hashtbl_gen.small_bucket_key_opt eq_key key (Array.unsafe_get h.data (key_index h key))
  
let find_default (h : _ t) key default = 
  Hashtbl_gen.small_bucket_default eq_key key default (Array.unsafe_get h.data (key_index h key))
let find_all (h : _ t) key =
  let rec find_in_bucket (bucketlist : _ bucketlist) = match bucketlist with 
    | Empty ->
      []
    | Cons(k, d, rest) ->
      if eq_key k key 
      then d :: find_in_bucket rest
      else find_in_bucket rest in
  find_in_bucket (Array.unsafe_get h.data (key_index h key))

let replace h key info =
  let rec replace_bucket (bucketlist : _ bucketlist) : _ bucketlist = match bucketlist with 
    | Empty ->
      raise_notrace Not_found
    | Cons(k, i, next) ->
      if eq_key k key
      then Cons(key, info, next)
      else Cons(k, i, replace_bucket next) in
  let i = key_index h key in
  let h_data = h.data in 
  let l = Array.unsafe_get h_data i in
  try
    Array.unsafe_set h_data i  (replace_bucket l)
  with Not_found ->
    begin 
      Array.unsafe_set h_data i (Cons(key, info, l));
      h.size <- h.size + 1;
      if h.size > Array.length h_data lsl 1 then Hashtbl_gen.resize key_index h;
    end 

let mem (h : _ t) key =
  let rec mem_in_bucket (bucketlist : _ bucketlist) = match bucketlist with 
    | Empty ->
      false
    | Cons(k, d, rest) ->
      eq_key k key  || mem_in_bucket rest in
  mem_in_bucket (Array.unsafe_get h.data (key_index h key))


let of_list2 ks vs = 
  let len = List.length ks in 
  let map = create len in 
  List.iter2 (fun k v -> add map k v) ks vs ; 
  map


end
module Int_vec_util : sig 
#1 "int_vec_util.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


val mem : int -> Int_vec.t -> bool
end = struct
#1 "int_vec_util.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


let rec unsafe_mem_aux arr  i (key : int) bound = 
    if i <= bound then 
        if Array.unsafe_get arr i = (key : int) then 
            true 
         else unsafe_mem_aux arr (i + 1) key bound    
    else false 
    


let mem key (x : Int_vec.t) =
    let internal_array = Int_vec.unsafe_internal_array x in 
    let len = Int_vec.length x in 
    unsafe_mem_aux internal_array 0 key (len - 1)
    
end
module Ocaml_stdlib_slots
= struct
#1 "ocaml_stdlib_slots.ml"

(* Generated by scripts/gen_slots.ml, should be updated everytime when we upgrade the compiler *)
let pervasives = [| "invalid_arg";"failwith";"Exit";"min";"max";"abs";"max_int";"min_int";"lnot";"infinity";"neg_infinity";"nan";"max_float";"min_float";"epsilon_float";"^";"char_of_int";"string_of_bool";"bool_of_string";"string_of_int";"string_of_float";"@";"stdin";"stdout";"stderr";"print_char";"print_string";"print_bytes";"print_int";"print_float";"print_endline";"print_newline";"prerr_char";"prerr_string";"prerr_bytes";"prerr_int";"prerr_float";"prerr_endline";"prerr_newline";"read_line";"read_int";"read_float";"open_out";"open_out_bin";"open_out_gen";"flush";"flush_all";"output_char";"output_string";"output_bytes";"output";"output_substring";"output_byte";"output_binary_int";"output_value";"seek_out";"pos_out";"out_channel_length";"close_out";"close_out_noerr";"set_binary_mode_out";"open_in";"open_in_bin";"open_in_gen";"input_char";"input_line";"input";"really_input";"really_input_string";"input_byte";"input_binary_int";"input_value";"seek_in";"pos_in";"in_channel_length";"close_in";"close_in_noerr";"set_binary_mode_in";"LargeFile";"string_of_format";"^^";"exit";"at_exit";"valid_float_lexem";"unsafe_really_input";"do_at_exit" |]
let camlinternalOO = [| "public_method_label";"new_method";"new_variable";"new_methods_variables";"get_variable";"get_variables";"get_method_label";"get_method_labels";"get_method";"set_method";"set_methods";"narrow";"widen";"add_initializer";"dummy_table";"create_table";"init_class";"inherits";"make_class";"make_class_store";"dummy_class";"copy";"create_object";"create_object_opt";"run_initializers";"run_initializers_opt";"create_object_and_run_initializers";"lookup_tables";"params";"stats" |]
let camlinternalMod = [| "init_mod";"update_mod" |]
let string = [| "make";"init";"copy";"sub";"fill";"blit";"concat";"iter";"iteri";"map";"mapi";"trim";"escaped";"index";"rindex";"index_from";"rindex_from";"contains";"contains_from";"rcontains_from";"uppercase";"lowercase";"capitalize";"uncapitalize";"compare" |]
let array = [| "init";"make_matrix";"create_matrix";"append";"concat";"sub";"copy";"fill";"blit";"to_list";"of_list";"iter";"map";"iteri";"mapi";"fold_left";"fold_right";"sort";"stable_sort";"fast_sort" |]
let list = [| "length";"hd";"tl";"nth";"rev";"append";"rev_append";"concat";"flatten";"iter";"iteri";"map";"mapi";"rev_map";"fold_left";"fold_right";"iter2";"map2";"rev_map2";"fold_left2";"fold_right2";"for_all";"exists";"for_all2";"exists2";"mem";"memq";"find";"filter";"find_all";"partition";"assoc";"assq";"mem_assoc";"mem_assq";"remove_assoc";"remove_assq";"split";"combine";"sort";"stable_sort";"fast_sort";"sort_uniq";"merge" |]
    

end
module Ordered_hash_map_gen
= struct
#1 "ordered_hash_map_gen.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


(* does not support [remove], 
    so that the adding order is strict and continous  
 *)

module type S =
sig
  type key
  type 'value t
  val create: int ->  'value t
  val clear : 'vaulue t -> unit
  val reset : 'value t -> unit
  val copy: 'value t -> 'value t
  val add : 'value t -> key -> 'value -> unit
  val mem : 'value t -> key -> bool
  val rank : 'value t -> key -> int (* -1 if not found*)
  val find_value : 'value t -> key -> 'value (* raise if not found*)
  val iter: (key -> 'value -> int -> unit) ->  'value t -> unit
  val fold: (key -> 'value -> int -> 'b -> 'b) ->  'value t -> 'b -> 'b
  val length:  'value t -> int
  val stats: 'value t -> Hashtbl.statistics
  val elements : 'value t -> key list 
  val choose : 'value t -> key 
  val to_sorted_array: 'value t -> key array
end

(* We do dynamic hashing, and resize the table and rehash the elements
   when buckets become too long. *)
type ('a,'b) bucket = 
  | Empty 
  | Cons of 'a * int * 'b  * ('a,'b) bucket

type ('a,'b) t =
  { mutable size: int;                        (* number of entries *)
    mutable data: ('a,'b) bucket array;  (* the buckets *)
    initial_size: int;                        (* initial array size *)
  }




let create  initial_size =
  let s = Ext_util.power_2_above 16 initial_size in
  { initial_size = s; size = 0; data = Array.make s Empty }

let clear h =
  h.size <- 0;
  let len = Array.length h.data in
  for i = 0 to len - 1 do
    Array.unsafe_set h.data i  Empty
  done

let reset h =
  h.size <- 0;
  h.data <- Array.make h.initial_size Empty


let copy h = { h with data = Array.copy h.data }

let length h = h.size

let resize indexfun h =
  let odata = h.data in
  let osize = Array.length odata in
  let nsize = osize * 2 in
  if nsize < Sys.max_array_length then begin
    let ndata = Array.make nsize Empty in
    h.data <- ndata;          (* so that indexfun sees the new bucket count *)
    let rec insert_bucket = function
        Empty -> ()
      | Cons(key,info,data,rest) ->
        let nidx = indexfun h key in
        ndata.(nidx) <- Cons(key,info,data, ndata.(nidx));
        insert_bucket rest
    in
    for i = 0 to osize - 1 do
      insert_bucket (Array.unsafe_get odata i)
    done
  end

let iter f h =
  let rec do_bucket = function
    | Empty ->
      ()
    | Cons(k ,i, value, rest) ->
      f k value i; do_bucket rest in
  let d = h.data in
  for i = 0 to Array.length d - 1 do
    do_bucket (Array.unsafe_get d i)
  done

let choose h = 
  let rec aux arr offset len = 
    if offset >= len then raise Not_found
    else 
      match Array.unsafe_get arr offset with 
      | Empty -> aux arr (offset + 1) len 
      | Cons (k,_,_,rest) -> k 
  in
  aux h.data 0 (Array.length h.data)

let to_sorted_array h = 
  if h.size = 0 then [||]
  else 
    let v = choose h in 
    let arr = Array.make h.size v in
    iter (fun k _ i -> Array.unsafe_set arr i k) h;
    arr 

let fold f h init =
  let rec do_bucket b accu =
    match b with
      Empty ->
      accu
    | Cons( k , i,  value, rest) ->
      do_bucket rest (f k  value i  accu) in
  let d = h.data in
  let accu = ref init in
  for i = 0 to Array.length d - 1 do
    accu := do_bucket (Array.unsafe_get d i) !accu
  done;
  !accu

let elements set = 
  fold  (fun k  _  _ acc  ->  k :: acc) set []


let rec bucket_length acc (x : _ bucket) = 
  match x with 
  | Empty -> 0
  | Cons(_,_,_,rest) -> bucket_length (acc + 1) rest  

let stats h =
  let mbl =
    Array.fold_left (fun m b -> max m (bucket_length 0 b)) 0 h.data in
  let histo = Array.make (mbl + 1) 0 in
  Array.iter
    (fun b ->
       let l = bucket_length 0 b in
       histo.(l) <- histo.(l) + 1)
    h.data;
  { Hashtbl.num_bindings = h.size;
    num_buckets = Array.length h.data;
    max_bucket_length = mbl;
    bucket_histogram = histo }



end
module Ordered_hash_map_local_ident : sig 
#1 "ordered_hash_map_local_ident.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)



(** Hash algorithm only hash 
    stamp, this makes sense when  all identifiers are local (no global)
*)
include Ordered_hash_map_gen.S with type key = Ident.t

end = struct
#1 "ordered_hash_map_local_ident.ml"
  
# 10 "ext/ordered_hash_map.cppo.ml"
  type key = Ident.t
  type   'value t = (key,'value) Ordered_hash_map_gen.t
  let key_index (h : _ t) (key : key) =
    (Bs_hash_stubs.hash_int  key.stamp) land (Array.length h.data - 1)
  let equal_key = Ext_ident.equal


# 20
open Ordered_hash_map_gen

let create = create
let clear = clear
let reset = reset
let copy = copy
let iter = iter
let fold = fold
let length = length
let stats = stats
let elements = elements
let choose = choose
let to_sorted_array = to_sorted_array



let rec small_bucket_mem key lst =
  match lst with 
  | Empty -> false 
  | Cons(key1,_, _, rest) -> 
    equal_key key key1 ||
    match rest with 
    | Empty -> false 
    | Cons(key2 , _,_, rest) -> 
      equal_key key  key2 ||
      match rest with 
      | Empty -> false 
      | Cons(key3,_, _, rest) -> 
        equal_key key  key3 ||
        small_bucket_mem key rest 

let rec small_bucket_rank key lst =
  match lst with 
  | Empty -> -1
  | Cons(key1,i,_, rest) -> 
    if equal_key key key1 then i 
    else match rest with 
      | Empty -> -1 
      | Cons(key2,i2, _, rest) -> 
        if equal_key key  key2 then i2 else
          match rest with 
          | Empty -> -1 
          | Cons(key3,i3, _, rest) -> 
            if equal_key key  key3 then i3 else
              small_bucket_rank key rest 
let rec small_bucket_find_value  key (lst : (_,_) bucket)   =
  match lst with 
  | Empty -> raise Not_found
  | Cons(key1,_,value, rest) -> 
    if equal_key key  key1 then value 
    else match rest with 
      | Empty -> raise Not_found 
      | Cons(key2,_,value, rest) -> 
        if equal_key key  key2 then value else
          match rest with 
          | Empty -> raise Not_found 
          | Cons(key3, _ , value, rest) -> 
            if equal_key key  key3 then value else
              small_bucket_find_value key rest 

let add h key value =
  let i = key_index h key  in 
  if not (small_bucket_mem key  h.data.(i)) then 
    begin 
      h.data.(i) <- Cons(key,h.size, value, h.data.(i));
      h.size <- h.size + 1 ;
      if h.size > Array.length h.data lsl 1 then resize key_index h
    end

let mem h key =
  small_bucket_mem key (Array.unsafe_get h.data (key_index h key)) 
let rank h key = 
  small_bucket_rank key(Array.unsafe_get h.data (key_index h key))  

let find_value h key =
  small_bucket_find_value key (Array.unsafe_get h.data (key_index h key))













end
module Lam : sig 
#1 "lam.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type array_kind = Lambda.array_kind
type boxed_integer = Lambda.boxed_integer
type comparison = Lambda.comparison 
type bigarray_kind = Lambda.bigarray_kind
type bigarray_layout = Lambda.bigarray_layout
type compile_time_constant = Lambda.compile_time_constant

type tag_info = Lambda.tag_info
type mutable_flag = Asttypes.mutable_flag
type field_dbg_info = Lambda.field_dbg_info 
type set_field_dbg_info = Lambda.set_field_dbg_info

type ident = Ident.t

type let_kind = Lambda.let_kind
    = Strict
    | Alias
    | StrictOpt
    | Variable

type meth_kind = Lambda.meth_kind 
  = Self 
  | Public of string option 
  | Cached 

type function_kind 
   = Curried
   (* | Tupled *)

type constant = 
  | Const_int of int
  | Const_char of char
  | Const_string of string 
  | Const_unicode of string 
  | Const_float of string
  | Const_int32 of int32
  | Const_int64 of int64
  | Const_nativeint of nativeint
  | Const_pointer of int * Lambda.pointer_info
  | Const_block of int * Lambda.tag_info * constant list
  | Const_float_array of string list
  | Const_immstring of string

type primitive = 
  | Pbytes_to_string
  | Pbytes_of_string
  | Pglobal_exception of ident 
  | Pmakeblock of int * Lambda.tag_info * Asttypes.mutable_flag
  | Pfield of int * Lambda.field_dbg_info
  | Psetfield of int * bool * Lambda.set_field_dbg_info
  | Pfloatfield of int * Lambda.field_dbg_info
  | Psetfloatfield of int * Lambda.set_field_dbg_info
  | Pduprecord of Types.record_representation * int
  | Plazyforce

  | Pccall of  Primitive.description    
  | Pjs_call of
    (* Location.t *  [loc] is passed down *)
    string *  (* prim_name *)
    Ast_arg.kind list * (* arg_types *)
    (* Ast_external_attributes.return_wrapper *) (* result_type *)
    Ast_ffi_types.ffi  (* ffi *)
  | Pjs_object_create of Ast_ffi_types.obj_create

  | Praise 
  | Psequand | Psequor | Pnot
  | Pnegint | Paddint | Psubint | Pmulint | Pdivint | Pmodint
  | Pandint | Porint | Pxorint
  | Plslint | Plsrint | Pasrint
  | Pintcomp of Lambda.comparison
  | Poffsetint of int
  | Poffsetref of int
  | Pintoffloat | Pfloatofint
  | Pnegfloat | Pabsfloat
  | Paddfloat | Psubfloat | Pmulfloat | Pdivfloat
  | Pfloatcomp of Lambda.comparison
  | Pjscomp of Lambda.comparison
  | Pjs_apply (*[f;arg0;arg1; arg2; ... argN]*)
  | Pjs_runtime_apply (* [f; [...]] *)
  | Pstringlength 
  | Pstringrefu 
  | Pstringrefs
  | Pstringadd    
  | Pbyteslength
  | Pbytesrefu
  | Pbytessetu 
  | Pbytesrefs
  | Pbytessets
  (* Array operations *)
  | Pmakearray of array_kind
  | Parraylength of array_kind
  | Parrayrefu of array_kind
  | Parraysetu of array_kind
  | Parrayrefs of array_kind
  | Parraysets of array_kind
  (* Test if the argument is a block or an immediate integer *)
  | Pisint
  (* Test if the (integer) argument is outside an interval *)
  | Pisout
  (* Bitvect operations *)
  | Pbittest
  (* Operations on boxed integers (Nativeint.t, Int32.t, Int64.t) *)
  | Pbintofint of boxed_integer
  | Pintofbint of boxed_integer
  | Pcvtbint of boxed_integer (*source*) * boxed_integer (*destination*)
  | Pnegbint of boxed_integer
  | Paddbint of boxed_integer
  | Psubbint of boxed_integer
  | Pmulbint of boxed_integer
  | Pdivbint of boxed_integer
  | Pmodbint of boxed_integer
  | Pandbint of boxed_integer
  | Porbint of boxed_integer
  | Pxorbint of boxed_integer
  | Plslbint of boxed_integer
  | Plsrbint of boxed_integer
  | Pasrbint of boxed_integer
  | Pbintcomp of boxed_integer * comparison
  (* Operations on big arrays: (unsafe, #dimensions, kind, layout) *)
  | Pbigarrayref of bool * int * bigarray_kind * bigarray_layout
  | Pbigarrayset of bool * int * bigarray_kind * bigarray_layout
  (* size of the nth dimension of a big array *)
  | Pbigarraydim of int
  (* load/set 16,32,64 bits from a string: (unsafe)*)
  | Pstring_load_16 of bool
  | Pstring_load_32 of bool
  | Pstring_load_64 of bool
  | Pstring_set_16 of bool
  | Pstring_set_32 of bool
  | Pstring_set_64 of bool
  (* load/set 16,32,64 bits from a
     (char, int8_unsigned_elt, c_layout) Bigarray.Array1.t : (unsafe) *)
  | Pbigstring_load_16 of bool
  | Pbigstring_load_32 of bool
  | Pbigstring_load_64 of bool
  | Pbigstring_set_16 of bool
  | Pbigstring_set_32 of bool
  | Pbigstring_set_64 of bool
  (* Compile time constants *)
  | Pctconst of compile_time_constant
  (* byte swap *)
  | Pbswap16
  | Pbbswap of boxed_integer
  (* Integer to external pointer *)

  | Pdebugger
  | Pjs_unsafe_downgrade of string * Location.t
  | Pinit_mod
  | Pupdate_mod

  | Praw_js_code_exp of string 
  | Praw_js_code_stmt of string 
  
  | Pjs_fn_make of int 
  | Pjs_fn_run of int 
  | Pjs_fn_method of int 
  | Pjs_fn_runmethod of int 
  | Pundefined_to_opt
  | Pnull_to_opt
  | Pnull_undefined_to_opt 
  
  | Pis_null
  | Pis_undefined
  | Pis_null_undefined

  | Pjs_boolean_to_bool
  | Pjs_typeof
  | Pjs_function_length 

  | Pjs_string_of_small_array
  | Pjs_is_instance_array
  | Pcaml_obj_length
  | Pcaml_obj_set_length
  | Pwrap_exn (* convert either JS exception or OCaml exception into OCaml format *)  

  (* | Pcreate_exception of string  *)
  | Pcreate_extension of string 

type switch  =
  { sw_numconsts: int;
    sw_consts: (int * t) list;
    sw_numblocks: int;
    sw_blocks: (int * t) list;
    sw_failaction : t option}
and apply_status =
  | App_na
  | App_ml_full
  | App_js_full      
and apply_info = private
  { fn : t ; 
    args : t list ; 
    loc : Location.t;
    status : apply_status
  }

and prim_info = private
  { primitive : primitive ; 
    args : t list ; 
    loc : Location.t 
  }
and function_info = private
  { arity : int ; 
    function_kind : function_kind ; 
    params : ident list ;
    body : t 
  }
and  t =  private
  | Lvar of ident
  | Lglobal_module of ident
  | Lconst of constant
  | Lapply of apply_info
  | Lfunction of function_info
  | Llet of let_kind * ident * t * t
  | Lletrec of (ident * t) list * t
  | Lprim of prim_info
  | Lswitch of t * switch
  | Lstringswitch of t * (string * t) list * t option
  | Lstaticraise of int * t list
  | Lstaticcatch of t * (int * ident list) * t
  | Ltrywith of t * ident * t
  | Lifthenelse of t * t * t
  | Lsequence of t * t
  | Lwhile of t * t
  | Lfor of ident * t * t * Asttypes.direction_flag * t
  | Lassign of ident * t
  | Lsend of Lambda.meth_kind * t * t * t list * Location.t
  | Lifused of ident * t
  (* | Levent of t * Lambda.lambda_event 
     [Levent] in the branch hurt pattern match, 
     we should use record for trivial debugger info
  *)





type binop = t -> t -> t 

type triop = t -> t -> t -> t 

type unop = t ->  t

val inner_map : (t -> t) -> t -> t
val inner_iter : (t -> unit) -> t -> unit 
val free_variables : t -> Ident_set.t

val no_bounded_variables : t -> bool 

val hit_any_variables : Ident_set.t -> t -> bool
val check : string -> t -> t 
type bindings = (Ident.t * t) list

val scc_bindings : bindings -> bindings list 
val scc : bindings -> t -> t  -> t 

val var : ident -> t
val global_module : ident -> t 
val const : constant -> t

val apply : t -> t list -> Location.t -> apply_status -> t
val function_ : 
  arity:int ->
  function_kind:function_kind -> params:ident list -> body:t -> t

val let_ : let_kind -> ident -> t -> t -> t
val letrec : (ident * t) list -> t -> t
val if_ : triop
val switch : t -> switch  -> t 
val stringswitch : t -> (string * t) list -> t option -> t 

val true_ : t 
val false_ : t 
val unit : t 

val sequor : binop
val sequand : binop
val not_ : Location.t ->  unop
val seq : binop
val while_ : binop
(* val event : t -> Lambda.lambda_event -> t   *)
val try_ : t -> ident -> t  -> t 
val ifused : ident -> t -> t
val assign : ident -> t -> t 

val send : 
  Lambda.meth_kind ->
  t -> t -> t list -> 
  Location.t -> t 

val prim : primitive:primitive -> args:t list -> Location.t  ->  t

val staticcatch : 
  t -> int * ident list -> t -> t

val staticraise : 
  int -> t list -> t

val for_ : 
  ident ->
  t  ->
  t -> Asttypes.direction_flag -> t -> t 




(** In this pass we also synchronized aliases so that 
    {[
      let a1 = a0 in 
      let a2 = a1 in 
      let a3 = a2 in 
      let a4 = a3 in 
    ]}
    converted to 
    {[
      let a1 = a0 in 
      let a2 = a0 in 
      let a3 = a0 in 
      let a4 = a0 in 
    ]}
    we dont eliminate unused let bindings to leave it for {!Lam_pass_lets_dce}
    we should remove all those let aliases, otherwise, it will be
    pushed into alias table again
 *)
val convert :  Ident_set.t -> Lambda.lambda -> t * Lam_module_ident.Hash_set.t



end = struct
#1 "lam.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type array_kind = Lambda.array_kind
type boxed_integer = Lambda.boxed_integer
type comparison = Lambda.comparison 
type bigarray_kind = Lambda.bigarray_kind
type bigarray_layout = Lambda.bigarray_layout
type compile_time_constant = Lambda.compile_time_constant

type tag_info = Lambda.tag_info
type mutable_flag = Asttypes.mutable_flag
type field_dbg_info = Lambda.field_dbg_info 
type set_field_dbg_info = Lambda.set_field_dbg_info

type ident = Ident.t

type function_kind
  = Curried 
(* | Tupled *)


type let_kind = Lambda.let_kind
= Strict
| Alias
| StrictOpt
| Variable

type meth_kind = Lambda.meth_kind 
= Self 
| Public of string option 
| Cached 

type constant = 
  | Const_int of int
  | Const_char of char
  | Const_string of string  (* use record later *)
  | Const_unicode of string 
  | Const_float of string
  | Const_int32 of int32
  | Const_int64 of int64
  | Const_nativeint of nativeint
  | Const_pointer of int * Lambda.pointer_info
  | Const_block of int * Lambda.tag_info * constant list
  | Const_float_array of string list
  | Const_immstring of string

type primitive = 
  | Pbytes_to_string
  | Pbytes_of_string
  | Pglobal_exception of ident       
  (* Operations on heap blocks *)
  | Pmakeblock of int * tag_info * mutable_flag
  | Pfield of int * field_dbg_info
  | Psetfield of int * bool * set_field_dbg_info
  (* could have field info at least for record *)
  | Pfloatfield of int * field_dbg_info
  | Psetfloatfield of int * set_field_dbg_info
  | Pduprecord of Types.record_representation * int
  (* Force lazy values *)
  | Plazyforce
  (* External call *)
  | Pccall of  Primitive.description
  | Pjs_call of
      string *  (* prim_name *)
      Ast_arg.kind list * (* arg_types *)
      Ast_ffi_types.ffi  (* ffi *)
  | Pjs_object_create of Ast_ffi_types.obj_create
  (* Exceptions *)
  | Praise
  (* Boolean operations *)
  | Psequand | Psequor | Pnot
  (* Integer operations *)
  | Pnegint | Paddint | Psubint | Pmulint | Pdivint | Pmodint
  | Pandint | Porint | Pxorint
  | Plslint | Plsrint | Pasrint
  | Pintcomp of comparison
  | Poffsetint of int
  | Poffsetref of int
  (* Float operations *)
  | Pintoffloat | Pfloatofint
  | Pnegfloat | Pabsfloat
  | Paddfloat | Psubfloat | Pmulfloat | Pdivfloat
  | Pfloatcomp of comparison
  | Pjscomp of comparison
  | Pjs_apply (*[f;arg0;arg1; arg2; ... argN]*)
  | Pjs_runtime_apply (* [f; [...]] *)
  (* String operations *)
  | Pstringlength 
  | Pstringrefu 
  | Pstringrefs
  | Pstringadd  
  | Pbyteslength
  | Pbytesrefu
  | Pbytessetu 
  | Pbytesrefs
  | Pbytessets
  (* Array operations *)
  | Pmakearray of array_kind
  | Parraylength of array_kind
  | Parrayrefu of array_kind
  | Parraysetu of array_kind
  | Parrayrefs of array_kind
  | Parraysets of array_kind
  (* Test if the argument is a block or an immediate integer *)
  | Pisint
  (* Test if the (integer) argument is outside an interval *)
  | Pisout
  (* Bitvect operations *)
  | Pbittest
  (* Operations on boxed integers (Nativeint.t, Int32.t, Int64.t) *)
  | Pbintofint of boxed_integer
  | Pintofbint of boxed_integer
  | Pcvtbint of boxed_integer (*source*) * boxed_integer (*destination*)
  | Pnegbint of boxed_integer
  | Paddbint of boxed_integer
  | Psubbint of boxed_integer
  | Pmulbint of boxed_integer
  | Pdivbint of boxed_integer
  | Pmodbint of boxed_integer
  | Pandbint of boxed_integer
  | Porbint of boxed_integer
  | Pxorbint of boxed_integer
  | Plslbint of boxed_integer
  | Plsrbint of boxed_integer
  | Pasrbint of boxed_integer
  | Pbintcomp of boxed_integer * comparison
  (* Operations on big arrays: (unsafe, #dimensions, kind, layout) *)
  | Pbigarrayref of bool * int * bigarray_kind * bigarray_layout
  | Pbigarrayset of bool * int * bigarray_kind * bigarray_layout
  (* size of the nth dimension of a big array *)
  | Pbigarraydim of int
  (* load/set 16,32,64 bits from a string: (unsafe)*)
  | Pstring_load_16 of bool
  | Pstring_load_32 of bool
  | Pstring_load_64 of bool
  | Pstring_set_16 of bool
  | Pstring_set_32 of bool
  | Pstring_set_64 of bool
  (* load/set 16,32,64 bits from a
     (char, int8_unsigned_elt, c_layout) Bigarray.Array1.t : (unsafe) *)
  | Pbigstring_load_16 of bool
  | Pbigstring_load_32 of bool
  | Pbigstring_load_64 of bool
  | Pbigstring_set_16 of bool
  | Pbigstring_set_32 of bool
  | Pbigstring_set_64 of bool
  (* Compile time constants *)
  | Pctconst of compile_time_constant
  (* byte swap *)
  | Pbswap16
  | Pbbswap of boxed_integer
  (* Integer to external pointer *)

  | Pdebugger 
  | Pjs_unsafe_downgrade of string * Location.t
  | Pinit_mod
  | Pupdate_mod
  | Praw_js_code_exp of string 
  | Praw_js_code_stmt of string 
  | Pjs_fn_make of int 
  | Pjs_fn_run of int 
  | Pjs_fn_method of int 
  | Pjs_fn_runmethod of int

  | Pundefined_to_opt
  | Pnull_to_opt
  | Pnull_undefined_to_opt 
  | Pis_null
  | Pis_undefined
  | Pis_null_undefined
  | Pjs_boolean_to_bool
  | Pjs_typeof
  | Pjs_function_length 

  | Pjs_string_of_small_array
  | Pjs_is_instance_array
  | Pcaml_obj_length
  | Pcaml_obj_set_length
  | Pwrap_exn (* convert either JS exception or OCaml exception into OCaml format *)

  (* | Pcreate_exception of string  *)
  | Pcreate_extension of string 

type apply_status =
  | App_na
  | App_ml_full
  | App_js_full    


module Types = struct 
  type switch = 
    { sw_numconsts: int;
      sw_consts: (int * t) list;
      sw_numblocks: int;
      sw_blocks: (int * t) list;
      sw_failaction : t option}
  (* Note that failaction would appear in both
     {[
       match x with 
       | ..
       | ..
       | _ -> 2 
     ]}
     since compiler would first test [x] is a const pointer
     or not then the [default] applies to each branch.

     In most cases: {[
       let sw =
         {sw_numconsts = cstr.cstr_consts; sw_consts = consts;
          sw_numblocks = cstr.cstr_nonconsts; sw_blocks = nonconsts;
          sw_failaction = None} in
     ]}

     but there are some edge cases (see MPR#6033)
     one predicate used is 
     {[
       (sw.sw_numconsts - List.length sw.sw_consts) +
       (sw.sw_numblocks - List.length sw.sw_blocks) > 1
     ]}
     if [= 1] with [some fail] -- called once
     if [= 0] could not have [some fail]
  *)   
  and prim_info = 
    { primitive : primitive ; 
      args : t list ;
      loc : Location.t;
    }
  and apply_info = 
    { fn : t ; 
      args : t list ; 
      loc : Location.t;
      status : apply_status
    }
  and function_info = 
    { arity : int ; 
      function_kind : function_kind ; 
      params : ident list ;
      body : t 
    }
  and t = 
    | Lvar of ident
    | Lglobal_module of ident
    | Lconst of constant
    | Lapply of apply_info
    | Lfunction of function_info
    | Llet of let_kind * ident * t * t
    | Lletrec of (ident * t) list * t
    | Lprim of prim_info
    | Lswitch of t * switch
    | Lstringswitch of t * (string * t) list * t option
    | Lstaticraise of int * t list
    | Lstaticcatch of t * (int * ident list) * t
    | Ltrywith of t * ident * t
    | Lifthenelse of t * t * t
    | Lsequence of t * t
    | Lwhile of t * t
    | Lfor of ident * t * t * Asttypes.direction_flag * t
    | Lassign of ident * t
    | Lsend of meth_kind * t * t * t list * Location.t
    | Lifused of ident * t
end 

module X = struct 
  type switch
    = Types.switch
    =
      { sw_numconsts: int;
        sw_consts: (int * t) list;
        sw_numblocks: int;
        sw_blocks: (int * t) list;
        sw_failaction : t option}
  and prim_info
    =  Types.prim_info
    =
      { primitive : primitive ; 
        args : t list ;
        loc : Location.t;
      }
  and apply_info
    = Types.apply_info
    =
      { fn : t ; 
        args : t list ; 
        loc : Location.t;
        status : apply_status
      }

  and function_info
    = Types.function_info
    =
      { arity : int ; 
        function_kind : function_kind ; 
        params : ident list ;
        body : t 
      }
  and t
    = Types.t
    =
      | Lvar of ident
      | Lglobal_module of ident 
      | Lconst of constant
      | Lapply of apply_info
      | Lfunction of function_info
      | Llet of let_kind * ident * t * t
      | Lletrec of (ident * t) list * t
      | Lprim of prim_info
      | Lswitch of t * switch
      | Lstringswitch of t * (string * t) list * t option
      | Lstaticraise of int * t list
      | Lstaticcatch of t * (int * ident list) * t
      | Ltrywith of t * ident * t
      | Lifthenelse of t * t * t
      | Lsequence of t * t
      | Lwhile of t * t
      | Lfor of ident * t * t * Asttypes.direction_flag * t
      | Lassign of ident * t
      | Lsend of meth_kind * t * t * t list * Location.t
      | Lifused of ident * t
end
include Types 
(** apply [f] to direct successor which has type [Lam.t] *)
let inner_map (f : t -> X.t ) (l : t) : X.t = 
  match l  with 
  | Lvar (_ : ident)
  | Lconst (_ : constant) -> 
    ( (* Obj.magic *) l : X.t)
  | Lapply ({fn; args; loc; status} )  ->
    let fn = f fn in
    let args = Ext_list.map f args in 
    Lapply { fn ; args; loc; status }
  | Lfunction({body; arity; function_kind; params } ) ->
    let body = f body in 
    Lfunction {body; arity; function_kind ; params}
  | Llet(str, id, arg, body) ->
    let arg = f arg in let body =  f body in
    Llet(str,id,arg,body)
  | Lletrec(decl, body) ->
    let body = f body in 
    let decl = Ext_list.map (fun (id, exp) -> id, f exp) decl in 
    Lletrec(decl,body)
  | Lglobal_module _ -> (l : X.t)      
  | Lprim {args; primitive ; loc}  ->
    let args = Ext_list.map f args in 
    Lprim { args; primitive; loc}

  | Lswitch(arg, {sw_consts; sw_numconsts; sw_blocks; sw_numblocks; sw_failaction}) ->
    let arg = f arg in 
    let sw_consts = Ext_list.map (fun (key, case) -> key , f case) sw_consts in 
    let sw_blocks = Ext_list.map (fun (key, case) -> key, f case) sw_blocks in 
    let sw_failaction = begin match sw_failaction with
      | None -> None
      | Some a -> Some (f a)
    end in
    Lswitch(arg, { sw_consts; sw_blocks; sw_failaction; sw_numblocks; sw_numconsts})
  | Lstringswitch (arg,cases,default) ->
    let arg = f arg  in 
    let cases = Ext_list.map (fun (k,act) -> k,f act) cases  in
    let default = begin match default with 
      | None -> None
      | Some a -> Some (f a) 
    end in 
    Lstringswitch(arg,cases,default)
  | Lstaticraise (id,args) ->
    let args = Ext_list.map f args in 
    Lstaticraise(id,args)
  | Lstaticcatch(e1, vars , e2) ->
    let e1 = f e1 in 
    let e2 = f e2 in 
    Lstaticcatch(e1, vars, e2)
  | Ltrywith(e1, exn, e2) ->
    let e1  = f e1 in 
    let e2 =  f e2 in 
    Ltrywith(e1,exn,e2)
  | Lifthenelse(e1, e2, e3) ->
    let e1 = f e1 in let e2 =  f e2 in let e3 =  f e3 in 
    Lifthenelse(e1,e2,e3)
  | Lsequence(e1, e2) ->
    let e1 = f e1 in let e2 =  f e2 in 
    Lsequence(e1,e2)
  | Lwhile(e1, e2) ->
    let e1 = f e1 in let e2 =  f e2 in 
    Lwhile(e1,e2)
  | Lfor(v, e1, e2, dir, e3) ->
    let e1 = f e1 in let e2 =  f e2 in let e3 =  f e3 in 
    Lfor(v,e1,e2,dir,e3)
  | Lassign(id, e) ->
    let e = f e in 
    Lassign(id,e)
  | Lsend (k, met, obj, args, loc) ->
    let met = f met in 
    let obj = f obj in 
    let args = Ext_list.map f args in 
    Lsend(k,met,obj,args,loc)

  | Lifused (v, e) ->
    let e = f e in 
    Lifused(v,e)

let inner_iter (f : t -> unit ) (l : t) : unit = 
  match l  with 
  | Lvar (_ : ident)
  | Lconst (_ : constant) -> ()
  | Lapply ({fn; args; loc; status} )  ->
    f fn;
    List.iter f args 
  | Lfunction({body; arity; function_kind; params } ) ->
    f body
  | Llet(str, id, arg, body) ->
    f arg ;
    f body;
  | Lletrec(decl, body) ->
    f body;
    List.iter (fun (id, exp) ->  f exp) decl
  | Lglobal_module (_ )
    ->  ()    
  | Lprim {args; primitive ; loc}  ->
    List.iter f args;
  | Lswitch(arg, {sw_consts; sw_numconsts; sw_blocks; sw_numblocks; sw_failaction}) ->
    f arg;
    List.iter (fun (key, case) -> f case) sw_consts;
    List.iter (fun (key, case) ->  f case) sw_blocks ;
    begin match sw_failaction with
      | None -> ()
      | Some a ->  f a
    end 
  | Lstringswitch (arg,cases,default) ->
    f arg;
    List.iter (fun (k,act) -> f act) cases  ;
    begin match default with 
      | None -> ()
      | Some a -> f a
    end
  | Lstaticraise (id,args) ->
    List.iter f args;
  | Lstaticcatch(e1, vars , e2) ->
    f e1;
    f e2
  | Ltrywith(e1, exn, e2) ->
    f e1;
    f e2 
  | Lifthenelse(e1, e2, e3) ->
    f e1;  f e2 ;  f e3
  | Lsequence(e1, e2) ->
    f e1 ;  f e2
  | Lwhile(e1, e2) ->
    f e1 ;  f e2 
  | Lfor(v, e1, e2, dir, e3) ->
    f e1 ;  f e2;  f e3 
  | Lassign(id, e) ->
    f e 
  | Lsend (k, met, obj, args, loc) ->
    f met; f obj; List.iter f args 
  | Lifused (v, e) ->
    f e 


(*
let add_list lst set = 
    List.fold_left (fun acc x -> Ident_set.add x acc) set lst 
let free_variables l =
  let rec free bounded acc (l : t) =
      match (l : t) with 
      | Lvar id ->
        if Ident_set.mem id bounded then acc 
        else Ident_set.add id acc 
      | Lconst _ -> acc
      | Lapply{fn; args; _} ->
        let acc = free bounded  acc fn in
        List.fold_left (fun acc arg -> free bounded acc arg) acc args  
      | Lfunction{body;params} ->
        let bounded = add_list params bounded in  
        free bounded acc  body        
      | Llet(str, id, arg, body) ->        
        let acc = free bounded acc  arg in
        let bounded =  Ident_set.add id bounded in 
        free bounded acc body
      | Lletrec(decl, body) ->
        let bounded = 
          List.fold_left (fun acc (x,_) -> Ident_set.add x acc) bounded decl
        in
        let acc = List.fold_left (fun acc (_,exp) -> free bounded acc exp ) acc decl in
        free bounded acc body          
      | Lprim {args; _} ->
        List.fold_left (fun acc arg -> free bounded acc arg) acc args         
      | Lswitch(arg, {sw_consts; sw_blocks; sw_failaction}) ->
        let acc = free bounded acc arg in 
        let acc = List.fold_left 
          (fun acc (key, case) -> free  bounded acc case) acc sw_consts in 
        let acc = 
          List.fold_left 
          (fun acc (key, case) -> free bounded acc  case) acc sw_blocks in 
        begin match sw_failaction with 
          | None -> acc 
          | Some a -> free bounded acc a  
        end
      | Lstringswitch (arg,cases,default) ->
        let acc = free bounded acc arg  in 
        let acc = List.fold_left (fun acc  (_,act) -> free bounded acc act) acc cases  in
        begin match default with 
          | None -> acc 
          | Some a -> free bounded acc a  
        end
      | Lstaticraise (_,args) ->
        List.fold_left (fun acc arg -> free bounded acc arg) acc args
      | Lstaticcatch(e1, (_,vars), e2) ->
        let acc = free  bounded acc e1 in
        let bounded = add_list vars bounded in 
        free bounded acc e2                 
      | Ltrywith(e1, exn, e2) ->
        let acc = free  bounded acc e1 in
        let bounded = Ident_set.add exn bounded in  
        free  bounded acc e2          
      | Lifthenelse(e1, e2, e3) ->
        let acc = free  bounded acc e1 in 
        let acc = free  bounded acc e2 in 
        free bounded acc e3
      | Lwhile(e1, e2) 
      | Lsequence(e1, e2) ->
        let acc = free bounded acc e1 in 
        free bounded acc e2
      | Lfor(v, e1, e2, dir, e3) ->

        let acc = free  bounded acc e1 in 
        let acc = free  bounded acc e2 in
        let bounded = Ident_set.add v bounded in 
        free bounded acc e3
      | Lassign(id, e) ->
        let acc = free bounded acc  e in 
        if Ident_set.mem id bounded then acc 
        else Ident_set.add id acc 
      | Lsend (k, met, obj, args, _) ->
        let acc = free bounded acc met in
        let acc = free bounded acc obj in
        List.fold_left (fun ac arg -> free bounded acc arg) acc args            
      | Lifused (v, e) ->
        free bounded acc e
  in free Ident_set.empty Ident_set.empty l
*)  

(**
        [hit_any_variables fv l]
        check the lambda expression [l] if has some free 
        variables captured by [fv].
        Note it does not do any checking like below
        [Llet(str,id,arg,body)]
        it only check [arg] or [body] is hit or not, there
        is an case that [id] is hit in [arg] but also exists 
        in [fv], this is ignored.
*)
let hit_any_variables (fv : Ident_set.t) l : bool  =
  let rec hit (l : t) =
    begin
      match (l : t) with 
      | Lvar id -> Ident_set.mem id fv       
      | Lassign(id, e) ->
        Ident_set.mem id fv || hit e
      | Lstaticcatch(e1, (_,vars), e2) ->
        hit e1 || hit e2
      | Ltrywith(e1, exn, e2) ->
        hit e1 || hit e2
      | Lfunction{body;params} ->
        hit body;
      | Llet(str, id, arg, body) ->
        hit arg || hit body
      | Lletrec(decl, body) ->
        hit body ||
        List.exists (fun (id, exp) -> hit exp) decl
      | Lfor(v, e1, e2, dir, e3) ->
        hit e1 || hit e2 || hit e3
      | Lconst _ -> false 
      | Lapply{fn; args; _} ->
        hit fn || List.exists hit args
      | Lglobal_module _  (* global persistent module, play safe *)
        -> false        
      | Lprim {args; _} ->
        List.exists hit args
      | Lswitch(arg, sw) ->
        hit arg ||
        List.exists (fun (key, case) -> hit case) sw.sw_consts ||
        List.exists (fun (key, case) -> hit case) sw.sw_blocks ||
        begin match sw.sw_failaction with 
          | None -> false
          | Some a -> hit a 
        end
      | Lstringswitch (arg,cases,default) ->
        hit arg ||
        List.exists (fun (_,act) -> hit act) cases ||
        begin match default with 
          | None -> false
          | Some a -> hit a 
        end
      | Lstaticraise (_,args) ->
        List.exists hit args
      | Lifthenelse(e1, e2, e3) ->
        hit e1 || hit e2 || hit e3
      | Lsequence(e1, e2) ->
        hit e1 || hit e2
      | Lwhile(e1, e2) ->
        hit e1 || hit e2
      | Lsend (k, met, obj, args, _) ->
        hit met || hit obj || List.exists hit args 
      | Lifused (v, e) ->
        hit e
    end;
  in hit l

(** A conservative approach to avoid packing exceptions 
    for lambda expression like {[
      try { ... }catch(id){body}
    ]}    
    we approximate that if [id] is destructed or not.
    If it is destructed, we need pack it in case it is JS exception.
    Note it is not guaranteed that exception raised(or re-raised) is a structured 
    ocaml exception but it is guaranteed that if such exception is processed it would
    still be an ocaml exception.
    for example {[
      match x with 
      | exception e -> raise e 
    ]}
    it will re-raise an exception as it is (we are not packing it anywhere)

    It is hard to judge an exception is destructed or escaped, any potential 
    alias(or if it is passed as an argument) would cause it to be leaked
*)
let exception_id_escaped (fv : Ident.t) l : bool  =
  let rec hit (l : t) =
    begin
      match (l : t) with 
      | Lprim {primitive = Pintcomp _ ; 
               args = ([x;y ])  } ->    
        begin match x,y with 
          | Lvar _, Lvar _ -> false 
          | Lvar _, _ -> hit y 
          | _, Lvar _ -> hit x 
          | _, _  -> hit x || hit y 
        end      
      | Lprim {primitive = Praise ; args = [Lvar _]} -> false 
      | Lprim {primitive ; args; _} ->
        List.exists hit args
      | Lvar id ->
        Ext_log.dwarn __LOC__ "[HIT]%s/%d@." id.name id.stamp ; 
        Ident.same id fv       
      | Lassign(id, e) ->
        Ident.same id fv || hit e
      | Lstaticcatch(e1, (_,vars), e2) ->
        hit e1 || hit e2
      | Ltrywith(e1, exn, e2) ->
        hit e1 || hit e2
      | Lfunction{body;params} ->
        hit body;
      | Llet(str, id, arg, body) ->
        hit arg || hit body
      | Lletrec(decl, body) ->
        hit body ||
        List.exists (fun (id, exp) -> hit exp) decl
      | Lfor(v, e1, e2, dir, e3) ->
        hit e1 || hit e2 || hit e3
      | Lconst _ -> false 
      | Lapply{fn; args; _} ->
        hit fn || List.exists hit args
      | Lglobal_module _  (* global persistent module, play safe *)
        -> false        
      | Lswitch(arg, sw) ->
        hit arg ||
        List.exists (fun (key, case) -> hit case) sw.sw_consts ||
        List.exists (fun (key, case) -> hit case) sw.sw_blocks ||
        begin match sw.sw_failaction with 
          | None -> false
          | Some a -> hit a 
        end
      | Lstringswitch (arg,cases,default) ->
        hit arg ||
        List.exists (fun (_,act) -> hit act) cases ||
        begin match default with 
          | None -> false
          | Some a -> hit a 
        end
      | Lstaticraise (_,args) ->
        List.exists hit args
      | Lifthenelse(e1, e2, e3) ->
        hit e1 || hit e2 || hit e3
      | Lsequence(e1, e2) ->
        hit e1 || hit e2
      | Lwhile(e1, e2) ->
        hit e1 || hit e2
      | Lsend (k, met, obj, args, _) ->
        hit met || hit obj || List.exists hit args 
      | Lifused (v, e) ->
        hit e
    end;
  in hit l  


(**
    [hit_mask mask lambda] iters through the lambda
    set the bit of corresponding [id] if [id] is hit.
    As an optimization step if [mask_check_all_hit], 
    there is no need to iter such lambda any more
*)  
let hit_mask ( mask : Hash_set_ident_mask.t) l =
  let rec hit (l : t) =
    begin
      match (l : t) with 
      | Lvar id -> Hash_set_ident_mask.mask_check_all_hit id mask 
      | Lassign(id, e) ->
        Hash_set_ident_mask.mask_check_all_hit id mask || hit e
      | Lstaticcatch(e1, (_,vars), e2) ->
        hit e1 || hit e2
      | Ltrywith(e1, exn, e2) ->
        hit e1 || hit e2
      | Lfunction{body;params} ->
        hit body;
      | Llet(str, id, arg, body) ->
        hit arg || hit body
      | Lletrec(decl, body) ->
        hit body ||
        List.exists (fun (id, exp) -> hit exp) decl
      | Lfor(v, e1, e2, dir, e3) ->
        hit e1 || hit e2 || hit e3
      | Lconst _ -> false 
      | Lapply{fn; args; _} ->
        hit fn || List.exists hit args
      | Lglobal_module id (* playsafe *)        
        -> false
      | Lprim {args; _} ->
        List.exists hit args
      | Lswitch(arg, sw) ->
        hit arg ||
        List.exists (fun (key, case) -> hit case) sw.sw_consts ||
        List.exists (fun (key, case) -> hit case) sw.sw_blocks ||
        begin match sw.sw_failaction with 
          | None -> false
          | Some a -> hit a 
        end
      | Lstringswitch (arg,cases,default) ->
        hit arg ||
        List.exists (fun (_,act) -> hit act) cases ||
        begin match default with 
          | None -> false
          | Some a -> hit a 
        end
      | Lstaticraise (_,args) ->
        List.exists hit args
      | Lifthenelse(e1, e2, e3) ->
        hit e1 || hit e2 || hit e3
      | Lsequence(e1, e2) ->
        hit e1 || hit e2
      | Lwhile(e1, e2) ->
        hit e1 || hit e2
      | Lsend (k, met, obj, args, _) ->
        hit met || hit obj || List.exists hit args 
      | Lifused (v, e) ->
        hit e
    end;
  in hit l

let free_variables l =
  let fv = ref Ident_set.empty in
  let rec free (l : t) =
    begin
      match (l : t) with 
      | Lvar id -> fv := Ident_set.add id !fv
      | Lassign(id, e) ->
        free e;
        fv := Ident_set.add id !fv        
      | Lstaticcatch(e1, (_,vars), e2) ->
        free e1; free e2;
        List.iter (fun id -> fv := Ident_set.remove id !fv) vars
      | Ltrywith(e1, exn, e2) ->
        free e1; free e2;
        fv := Ident_set.remove exn !fv
      | Lfunction{body;params} ->
        free body;
        List.iter (fun param -> fv := Ident_set.remove param !fv) params
      | Llet(str, id, arg, body) ->
        free arg; free body;
        fv := Ident_set.remove id !fv
      | Lletrec(decl, body) ->
        free body;
        List.iter (fun (id, exp) -> free exp) decl;
        List.iter (fun (id, exp) -> fv := Ident_set.remove id !fv) decl
      | Lfor(v, e1, e2, dir, e3) ->
        free e1; free e2; free e3;
        fv := Ident_set.remove v !fv
      | Lconst _ -> ()
      | Lapply{fn; args; _} ->
        free fn; List.iter free args
      | Lglobal_module _ -> () 
      (* according to the existing semantics: 
         [primitive] is not counted
      *)        
      | Lprim {args; _} ->
        List.iter free args
      | Lswitch(arg, sw) ->
        free arg;
        List.iter (fun (key, case) -> free case) sw.sw_consts;
        List.iter (fun (key, case) -> free case) sw.sw_blocks;
        begin match sw.sw_failaction with 
          | None -> ()
          | Some a -> free a 
        end
      | Lstringswitch (arg,cases,default) ->
        free arg ;
        List.iter (fun (_,act) -> free act) cases ;
        begin match default with 
          | None -> ()
          | Some a -> free a 
        end
      | Lstaticraise (_,args) ->
        List.iter free args
      | Lifthenelse(e1, e2, e3) ->
        free e1; free e2; free e3
      | Lsequence(e1, e2) ->
        free e1; free e2
      | Lwhile(e1, e2) ->
        free e1; free e2
      | Lsend (k, met, obj, args, _) ->
        free met; free obj; List.iter free args 
      | Lifused (v, e) ->
        free e
    end;
  in free l; 
  !fv


(**
        [no_bounded_varaibles lambda]
        checks if [lambda] contains bounded variable, for 
        example [Llet (str,id,arg,body) ] will fail such check.
        This is used to indicate such lambda expression if it is okay
        to inline directly since if it contains bounded variables it 
        must be rebounded before inlining
*)
let rec no_bounded_variables (l : t) =
  match (l : t) with 
  | Lvar _ -> true 
  | Lconst _ -> true
  | Lassign(_id, e) ->
    no_bounded_variables e
  | Lapply{fn; args; _} ->
    no_bounded_variables fn && List.for_all no_bounded_variables args
  | Lglobal_module _ -> true
  | Lprim {args; primitive = _ ; } ->
    List.for_all no_bounded_variables args
  | Lswitch(arg, sw) ->
    no_bounded_variables arg &&
    List.for_all (fun (key, case) -> no_bounded_variables case) sw.sw_consts &&
    List.for_all (fun (key, case) -> no_bounded_variables case) sw.sw_blocks &&
    begin match sw.sw_failaction with 
      | None -> true
      | Some a -> no_bounded_variables a 
    end
  | Lstringswitch (arg,cases,default) ->
    no_bounded_variables arg &&
    List.for_all (fun (_,act) -> no_bounded_variables act) cases &&
    begin match default with 
      | None -> true
      | Some a -> no_bounded_variables a 
    end
  | Lstaticraise (_,args) ->
    List.for_all no_bounded_variables args
  | Lifthenelse(e1, e2, e3) ->
    no_bounded_variables e1 && no_bounded_variables e2 && no_bounded_variables e3
  | Lsequence(e1, e2) ->
    no_bounded_variables e1 && no_bounded_variables e2
  | Lwhile(e1, e2) ->
    no_bounded_variables e1 && no_bounded_variables e2
  | Lsend (k, met, obj, args, _) ->
    no_bounded_variables met  &&
    no_bounded_variables obj &&
    List.for_all no_bounded_variables args 
  | Lifused (v, e) ->
    no_bounded_variables e


  | Lstaticcatch(e1, (_,vars), e2) ->
    vars = [] && no_bounded_variables e1 &&  no_bounded_variables e2    
  | Lfunction{body;params} ->
    params = [] && no_bounded_variables body;
  | Lfor _  -> false   
  | Ltrywith _ -> false      
  | Llet _ ->false
  | Lletrec(decl, body) -> decl = [] && no_bounded_variables body 




(**
   checks  
   1. variables are not bound twice 
   2. all variables are of right scope 
*)
let check file lam = 
  let defined_variables = Ident_hash_set.create 1000 in 
  let success = ref true in 
  let use (id : Ident.t)  = 
    if not @@ Ident_hash_set.mem defined_variables id  then 
      begin 
        Format.fprintf Format.err_formatter "\n[SANITY]:%s/%d used before defined in %s\n" id.name id.stamp file ;
        success := false
      end        
  in 
  let def (id : Ident.t) =
    if Ident_hash_set.mem defined_variables id  then 
      begin 
        Format.fprintf Format.err_formatter "\n[SANITY]:%s/%d bound twice in %s\n" id.name id.stamp  file ;
        success := false 
      end
    else Ident_hash_set.add defined_variables id 
  in 
  let rec iter (l : t) =
    begin
      match (l : t) with 
      | Lvar id -> use id 
      | Lglobal_module _ -> ()
      | Lprim {args; _} ->
        List.iter iter args
      | Lconst _ -> ()
      | Lapply{fn; args; _} ->
        iter fn; List.iter iter args
      | Lfunction{body;params} ->
        List.iter def params;
        iter body
      | Llet(str, id, arg, body) ->
        iter arg;
        def id;
        iter body
      | Lletrec(decl, body) ->
        List.iter (fun (id, exp) ->  def id) decl;
        List.iter (fun (id, exp) -> iter exp) decl;
        iter body

      | Lswitch(arg, sw) ->
        iter arg;
        List.iter (fun (key, case) -> iter case) sw.sw_consts;
        List.iter (fun (key, case) -> iter case) sw.sw_blocks;
        begin match sw.sw_failaction with 
          | None -> ()
          | Some a -> iter a 
        end
      | Lstringswitch (arg,cases,default) ->
        iter arg ;
        List.iter (fun (_,act) -> iter act) cases ;
        begin match default with 
          | None -> ()
          | Some a -> iter a 
        end
      | Lstaticraise (_,args) ->
        List.iter iter args
      | Lstaticcatch(e1, (_,vars), e2) ->
        iter e1; 
        List.iter def vars;
        iter e2
      | Ltrywith(e1, exn, e2) ->
        iter e1; 
        def exn; 
        iter e2
      | Lifthenelse(e1, e2, e3) ->
        iter e1; iter e2; iter e3
      | Lsequence(e1, e2) ->
        iter e1; iter e2
      | Lwhile(e1, e2) ->
        iter e1; iter e2
      | Lfor(v, e1, e2, dir, e3) ->
        iter e1; iter e2; 
        def v; 
        iter e3;
      | Lassign(id, e) ->
        use id ; 
        iter e
      | Lsend (k, met, obj, args, _) ->
        iter met; iter obj; 
        List.iter iter args
      | Lifused (v, e) ->
        iter e
    end;
  in 
  begin 
    iter lam; 
    assert (!success) ; 
    lam 
  end      

type binop = t -> t -> t 

type triop = t -> t -> t -> t 

type unop = t -> t 



exception Not_simple_form 

(** Simplfiy such behavior
    {[ 
      (apply
         (function prim/1024 prim/1023 prim/1022
                     ([js] (js_fn_make_2 prim/1024) prim/1023 prim/1022)) .. )
    ]}
    Note that [external] functions are forced to do eta-conversion
    when combined with [|>] operator, we need to make sure beta-reduction 
    is applied though since `[@bs.splice]` needs such guarantee.
    Since `[@bs.splice] is the tail position
*)
let rec is_eta_conversion_exn
    params inner_args outer_args : t list = 
  match params, inner_args, outer_args with 
  | x::xs, Lvar y::ys, r::rest 
    when Ident.same x y ->
    r :: is_eta_conversion_exn xs ys rest 
  | x::xs, 
    (Lprim ({primitive = Pjs_fn_make _; 
             args = [Lvar y] } as p ) ::ys),
    r :: rest when Ident.same x y -> 
    Lprim ({p with args = [ r]}) :: 
    is_eta_conversion_exn xs ys rest 
  | [], [], [] -> []
  | _, _, _ -> raise_notrace Not_simple_form


let var id : t = Lvar id
let global_module id = Lglobal_module id 
let const ct : t = Lconst ct 


(** FIXME: more robust inlining check later, we should inline it before we add stub code
*)
let apply fn args loc status : t = 
  match fn with 
  | Lfunction {function_kind ; params ;  
               body = Lprim {primitive = 
                               (Pundefined_to_opt | Pnull_to_opt | Pnull_undefined_to_opt | Pis_null | Pis_null_undefined | Pjs_boolean_to_bool | Pjs_typeof ) as wrap;
                             args = [Lprim ({primitive; args = inner_args} as primitive_call)]
                            } 
              } ->
    begin match is_eta_conversion_exn params inner_args args with
      | args 
        -> 
        Lprim {primitive = wrap ; args = [Lprim { primitive_call with args ; loc = loc }] ; loc }
      | exception _ -> 
        Lapply { fn; args; loc; status }
    end  
  | Lfunction {function_kind ; params; 
               body = Lsequence (Lprim ({primitive; args = inner_args}as primitive_call), (Lconst _ as const )) }
    ->  
    begin match is_eta_conversion_exn params inner_args args with
      | args 
        -> 
        Lsequence(Lprim { primitive_call with args ; loc = loc }, const)
      | exception _ -> 
        Lapply { fn; args;  loc;    status }
    end 
  | Lfunction {function_kind ; params; 
               body =Lprim ({primitive; args = inner_args}as primitive_call) } 

    ->
    begin match is_eta_conversion_exn params inner_args args with
      | args 
        -> 
        Lprim { primitive_call with args ; loc = loc }
      | exception _ -> 
        Lapply { fn; args;  loc;    status }
    end 

  (*  | Lfunction {kind; params ; 
                 body = Lapply {fn = new_fn ; args = inner_args; status }
                } when is_eta_conversion params inner_args args ->
      Lapply {fn = new_fn ; args ; loc = loc; status } 
  *)
  (* same as previous App status*)
  | _ -> 
    Lapply { fn; args;  loc  ;
             status }


let function_ ~arity ~function_kind ~params ~body : t = 
  Lfunction { arity; function_kind; params ; body}

let let_ kind id e body :  t 
  = Llet (kind,id,e,body)
let letrec bindings body : t = 
  Lletrec(bindings,body)

let if_ (a : t) (b : t) c = 
  match a with
  | Lconst v ->
    begin match v with
      | Const_pointer (x, _)  | (Const_int x)
        ->
        if x <> 0 then b else c
      | (Const_char x) ->
        if Char.code x <> 0 then b else c
      | (Const_int32 x) ->
        if x <> 0l then b else c
      |  (Const_int64 x) ->
        if x <> 0L then b else c
      | (Const_nativeint x) ->
        if x <> 0n then b else c
      | Const_string _ 
      | Const_float _
      | Const_unicode _
      | Const_block _
      | Const_float_array _
      | Const_immstring _ -> b
    end
  | _ ->  Lifthenelse (a,b,c)

let happens_to_be_diff 
    (sw_consts :
       (int * Lambda.lambda) list) : int option =   
  match sw_consts with 
  | (a, Lconst (Const_pointer (a0,_)| Const_base (Const_int a0)))::
    (b, Lconst (Const_pointer (b0,_)| Const_base (Const_int b0)))::
    rest ->
    let diff = a0 - a in 
    if b0 - b = diff then 
      if List.for_all (fun (x, (lam : Lambda.lambda )) -> 
          match lam with 
          | Lconst (Const_pointer(x0,_) | Const_base(Const_int x0)) ->
            x0 - x = diff 
          | _ -> false
        ) rest  then 
        Some diff 
      else 
        None
    else None 
  | _ -> None


let switch lam (lam_switch : switch) : t =
  match lam with
  | Lconst ((Const_pointer (i,_) |  (Const_int i)))
    ->
    Ext_list.assoc_by_int lam_switch.sw_failaction i lam_switch.sw_consts
  | Lconst (Const_block (i,_,_)) ->
    Ext_list.assoc_by_int lam_switch.sw_failaction i lam_switch.sw_blocks
  | _ -> 
    Lswitch(lam,lam_switch)

let stringswitch (lam : t) cases default : t = 
  match lam with
  | Lconst (Const_string a) ->    
    Ext_list.assoc_by_string default a cases     
  | _ -> Lstringswitch(lam, cases, default)


let true_ : t =
  Lconst (Const_pointer ( 1, Pt_constructor "true")) 

let false_ : t =
  Lconst (Const_pointer( 0, Pt_constructor "false"))

let unit : t = 
  Lconst (Const_pointer( 0, Pt_constructor "()"))

let assert_false_unit : t = 
  Lconst (Const_pointer( 0, Pt_constructor "impossible branch"))

(** [l || r ] *)
let sequor l r = if_ l true_ r 

(** [l && r ] *)
let sequand l r = if_ l r false_

let seq a b : t = 
  Lsequence (a, b)

let append_unit a  = 
  Lsequence (a,unit)

let while_ a b : t  = 
  Lwhile(a,b)

let try_  body id  handler : t = 
  Ltrywith(body,id,handler)

let for_ v e1 e2 dir e3 : t  = 
  Lfor(v,e1,e2,dir,e3)



let ifused v l : t  = 
  Lifused (v,l)

let assign v l : t = Lassign(v,l)

let send u m o ll v : t = 
  Lsend(u, m, o, ll, v)

let staticcatch  a b c : t = Lstaticcatch(a,b,c)

let staticraise a b : t = Lstaticraise(a,b)

let comparison (cmp : comparison) a b : bool = 
  match cmp with 
  | Ceq -> a = b 
  | Cneq -> a <> b 
  | Cgt -> a > b 
  | Cle -> a <= b 
  | Clt -> a < b 
  | Cge -> a >= b 

module Lift = struct 
  let int i : t =
    Lconst ((Const_int i))


  let int32 i : t =
    Lconst ((Const_int32 i))

  let bool b = if b then true_ else false_

  (* ATTENTION: [float, nativeint] constant propogaton is not done
     yet , due to cross platform problem
  *) 
  let float b  : t = 
    Lconst ((Const_float b))

  let nativeint b : t = 
    Lconst ((Const_nativeint b))

  let int32 b : t = 
    Lconst ((Const_int32 b))

  let int64 b : t =
    Lconst ((Const_int64 b))
  let string b : t =
    Lconst ((Const_string (b)))
  let char b : t =
    Lconst ((Const_char b))    
end

let prim ~primitive:(prim : primitive) ~args:(ll : t list) loc  : t = 
  let default () : t = Lprim { primitive = prim ;args =  ll ; loc} in 
  match ll with 
  | [Lconst a] -> 
    begin match prim, a  with 
      | Pnegint, ((Const_int a))
        -> Lift.int (- a)
      (* | Pfloatofint, ( (Const_int a)) *)
      (*   -> Lift.float (float_of_int a) *)
      | Pintoffloat, ( (Const_float a))
        -> 
        Lift.int (int_of_float (float_of_string a))
      (* | Pnegfloat -> Lift.float (-. a) *)
      (* | Pabsfloat -> Lift.float (abs_float a) *)
      | Pstringlength, Const_string a
        -> 
        Lift.int (String.length a)
      (* | Pnegbint Pnativeint, ( (Const_nativeint i)) *)
      (*   ->   *)
      (*   Lift.nativeint (Nativeint.neg i) *)
      | Pnegbint Pint32, Const_int32 a
        -> 
        Lift.int32 (Int32.neg a)
      | Pnegbint Pint64, Const_int64 a
        -> 
        Lift.int64 (Int64.neg a)
      | Pnot , Const_pointer (a,_) 
        -> Lift.bool (a = 0 )
      | _ -> default ()
    end


  | [Lconst a ; Lconst b] -> 
    begin match prim, a, b  with 
      | Pbintcomp(_, cmp),  (Const_int32 a),  (Const_int32 b)
        -> Lift.bool (comparison cmp a b)
      | Pbintcomp(_, cmp),  (Const_int64 a),  (Const_int64 b)
        -> Lift.bool (comparison cmp a b)
      | Pbintcomp(_, cmp),  (Const_nativeint a),  (Const_nativeint b)
        -> Lift.bool (comparison cmp a b)
      | Pfloatcomp  cmp,  (Const_nativeint a),  (Const_nativeint b)
        -> Lift.bool (comparison cmp a b)
      | Pintcomp cmp ,
        ( (Const_int a) | Const_pointer (a,_)),
        ( (Const_int b) | Const_pointer (b,_))
        -> Lift.bool (comparison cmp a b)
      | (Paddint
        | Psubint
        | Pmulint
        | Pdivint
        | Pmodint
        | Pandint
        | Porint
        | Pxorint
        | Plslint
        | Plsrint
        | Pasrint), (Const_int a),   (Const_int b)
        ->
        (* WE SHOULD keep it as [int], to preserve types *)
        let aa,bb = Int32.of_int a, Int32.of_int  b in 
        let int_ v = Lift.int (Int32.to_int v ) in 
        begin match prim with 
          | Paddint -> int_ (Int32.add aa bb)
          | Psubint -> int_ (Int32.sub aa bb)
          | Pmulint -> int_ (Int32.mul aa  bb)
          | Pdivint -> 
            if bb = 0l then default ()
            else int_ (Int32.div aa bb)
          | Pmodint ->
            if bb = 0l then default ()
            else int_ (Int32.rem aa bb)
          | Pandint -> int_ (Int32.logand aa bb)
          | Porint -> int_ (Int32.logor aa bb)
          | Pxorint -> int_ (Int32.logxor aa bb)
          | Plslint -> int_ (Int32.shift_left  aa b )
          | Plsrint -> int_ (Int32.shift_right_logical aa  b)
          | Pasrint -> int_ (Int32.shift_right aa b)
          | _ -> default ()
        end
      | (Paddbint Pint32
        | Psubbint Pint32
        | Pmulbint Pint32
        | Pdivbint Pint32
        | Pmodbint Pint32
        | Pandbint Pint32
        | Porbint Pint32
        | Pxorbint Pint32
        ),  (Const_int32 aa),   (Const_int32 bb)
        -> 
        begin match prim with 
          | Paddbint _  -> Lift.int32 (Int32.add aa bb)
          | Psubbint _  -> Lift.int32 (Int32.sub aa bb)
          | Pmulbint _ -> Lift.int32 (Int32.mul aa  bb)
          | Pdivbint _ ->  (try Lift.int32 (Int32.div aa  bb) with _  -> default ())
          | Pmodbint _ -> (try Lift.int32 (Int32.rem aa  bb) with _ -> default ())
          | Pandbint _ -> Lift.int32 (Int32.logand aa bb)
          | Porbint _ -> Lift.int32 (Int32.logor aa bb)
          | Pxorbint _ -> Lift.int32 (Int32.logxor aa bb)
          | _ -> default ()
        end
      | Plslbint Pint32,  (Const_int32 aa),  (Const_int b)
        -> Lift.int32 (Int32.shift_left  aa b )
      | Plsrbint Pint32,  (Const_int32 aa),  (Const_int b)
        -> Lift.int32 (Int32.shift_right_logical  aa b )
      | Pasrbint Pint32,  (Const_int32 aa),  (Const_int b)
        -> Lift.int32 (Int32.shift_right  aa b )

      | (Paddbint Pint64
        | Psubbint Pint64
        | Pmulbint Pint64
        | Pdivbint Pint64
        | Pmodbint Pint64
        | Pandbint Pint64
        | Porbint Pint64
        | Pxorbint Pint64
        ),  (Const_int64 aa),   (Const_int64 bb)
        -> 
        begin match prim with 
          | Paddbint _  -> Lift.int64 (Int64.add aa bb)
          | Psubbint _  -> Lift.int64 (Int64.sub aa bb)
          | Pmulbint _ -> Lift.int64 (Int64.mul aa  bb)
          | Pdivbint _ -> (try Lift.int64 (Int64.div aa  bb) with _ -> default ())
          | Pmodbint _ -> (try Lift.int64 (Int64.rem aa  bb) with _ -> default ())
          | Pandbint _ -> Lift.int64 (Int64.logand aa bb)
          | Porbint _ -> Lift.int64 (Int64.logor aa bb)
          | Pxorbint _ -> Lift.int64 (Int64.logxor aa bb)
          | _ -> default ()
        end
      | Plslbint Pint64,  (Const_int64 aa),  (Const_int b)
        -> Lift.int64 (Int64.shift_left  aa b )
      | Plsrbint Pint64,  (Const_int64 aa),  (Const_int b)
        -> Lift.int64 (Int64.shift_right_logical  aa b )
      | Pasrbint Pint64,  (Const_int64 aa),  (Const_int b)
        -> Lift.int64 (Int64.shift_right  aa b )
      | Psequand, Const_pointer (a, _), Const_pointer( b, _)
        -> 
        Lift.bool (a = 1 && b = 1)
      | Psequor, Const_pointer (a, _), Const_pointer( b, _)
        -> 
        Lift.bool (a = 1 || b = 1)
      | Pstringadd, (Const_string (a)),
        (Const_string (b))
        ->
        Lift.string (a ^ b)
      | (Pstringrefs | Pstringrefu), (Const_string(a)),
        ((Const_int b)| Const_pointer (b,_))
        ->
        begin try Lift.char (String.get a b)
          with  _ -> default ()
        end                       
      | _ -> default ()
    end

  | _ -> default ()


let not_ loc x  : t = 
  prim ~primitive:Pnot ~args:[x] loc

let may_depend = Lam_module_ident.Hash_set.add 


let rec no_auto_uncurried_arg_types 
    (xs : Ast_arg.kind list)  = 
  match xs with 
  | [] -> true 
  | {arg_type = Fn_uncurry_arity _ } :: _ ->
    false 
  | _ :: xs -> no_auto_uncurried_arg_types xs 


let result_wrap loc (result_type : Ast_ffi_types.return_wrapper) result  = 
  begin match result_type with 
    | Return_replaced_with_unit  
      -> append_unit result              
    | Ast_ffi_types.Return_null_to_opt -> prim ~primitive:(Pnull_to_opt) ~args:[result] loc 
    | Ast_ffi_types.Return_null_undefined_to_opt -> prim ~primitive:(Pnull_undefined_to_opt) ~args:[result] loc 
    | Ast_ffi_types.Return_undefined_to_opt -> prim ~primitive:(Pundefined_to_opt) ~args:[result] loc 
    | Ast_ffi_types.Return_to_ocaml_bool ->
      prim ~primitive:(Pjs_boolean_to_bool) ~args:[result] loc 
    | Return_unset
    | Return_identity -> 
      result 

  end 
(* TODO: sort out the order here
   consolidate {!Lam_compile_external_call.assemble_args_splice}
*)
let rec transform_uncurried_arg_type loc (arg_types : Ast_arg.kind list) 
    (args : t list ) = 
  match arg_types,args with 
  | { arg_type = Fn_uncurry_arity n ; arg_label } :: xs,
    y::ys -> 
    let (o_arg_types, o_args) = 
      transform_uncurried_arg_type loc xs ys in 
    { Ast_arg.arg_type = Nothing ; arg_label } :: o_arg_types , 
    prim ~primitive:(Pjs_fn_make n) ~args:[y] loc :: o_args 
  |  x  ::xs, y::ys -> 
    begin match x with 
      | {arg_type = Arg_cst _ }  -> 
        let o_arg_types, o_args = transform_uncurried_arg_type loc xs args in 
        x :: o_arg_types , o_args 
      | _ -> 
        let o_arg_types, o_args = transform_uncurried_arg_type loc xs ys in 
        x :: o_arg_types , y:: o_args 
    end
  | [] , [] 
  | _::_, [] 
  | [], _::_ as ok -> ok    


(** drop Lseq (List! ) etc *)
let rec drop_global_marker (lam : t) =
  match lam with 
  | Lsequence (Lglobal_module id, rest) -> 
    drop_global_marker rest
  | _ -> lam


let lam_prim ~primitive:( p : Lambda.primitive) ~args loc : t = 
  match p with 
  | Pint_as_pointer 
  | Pidentity ->  
    begin match args with [x] -> x | _ -> assert false end
  | Pccall _ -> assert false      
  | Prevapply -> assert false     
  | Pdirapply -> assert false 
  | Ploc loc -> assert false (* already compiled away here*)    

  | Pbytes_to_string (* handled very early *) 
    -> prim ~primitive:Pbytes_to_string ~args loc
  | Pbytes_of_string -> prim ~primitive:Pbytes_of_string ~args loc
  | Pignore -> (* Pignore means return unit, it is not an nop *)
    begin match args with [x] -> seq x unit | _ -> assert false end  
  | Pgetglobal id ->
    assert false 
  | Psetglobal id -> 
    (* we discard [Psetglobal] in the beginning*)
    begin match args with 
      | [biglambda] -> 
        drop_global_marker biglambda 
      | _ -> assert false 
    end
  (* prim ~primitive:(Psetglobal id) ~args loc *)
  | Pmakeblock (tag,info, mutable_flag) 
    -> prim ~primitive:(Pmakeblock (tag,info,mutable_flag)) ~args loc
  | Pfield (id,info) 
    -> prim ~primitive:(Pfield (id,info)) ~args loc

  | Psetfield (id,b,info)
    -> prim ~primitive:(Psetfield (id,b,info)) ~args loc

  | Pfloatfield (id,info)
    -> prim ~primitive:(Pfloatfield (id,info)) ~args loc
  | Psetfloatfield (id,info) 
    -> prim ~primitive:(Psetfloatfield (id,info)) ~args loc
  | Pduprecord (repr,i) 
    -> prim ~primitive:(Pduprecord(repr,i)) ~args loc
  | Plazyforce -> prim ~primitive:Plazyforce ~args loc


  | Praise _ ->
    if Js_config.get_no_any_assert () then 
      begin match args with 
        | [Lprim {primitive = Pmakeblock (0, _, _) ; 
                  args = [ 
                    Lprim {primitive = Pglobal_exception ({name = "Assert_failure"} as id); args =  []}; 
                    _ (* can be destructed [match Predef.path_assert_failure with Pident x -> x | _ -> assert false] [Predef.builtin_idents] 
                         [Predef.builtin_values] *)
                  ]
                 } ] when Ident.global id
          -> assert_false_unit
        | _ -> prim ~primitive:Praise ~args loc 
      end
    else prim ~primitive:Praise ~args loc 
  | Psequand -> prim ~primitive:Psequand ~args loc
  | Psequor -> prim ~primitive:Psequor ~args loc
  | Pnot -> prim ~primitive:Pnot ~args loc 
  | Pnegint -> prim ~primitive:Pnegint ~args  loc 
  | Paddint -> prim ~primitive:Paddint ~args loc 
  | Psubint -> prim ~primitive:Psubint ~args loc 
  | Pmulint -> prim ~primitive:Pmulint ~args loc 
  | Pdivint -> prim ~primitive:Pdivint ~args loc 
  | Pmodint -> prim ~primitive:Pmodint ~args loc 
  | Pandint -> prim ~primitive:Pandint ~args loc 
  | Porint -> prim ~primitive:Porint ~args loc 
  | Pxorint -> prim ~primitive:Pxorint ~args loc 
  | Plslint -> prim ~primitive:Plslint ~args loc 
  | Plsrint -> prim ~primitive:Plsrint ~args loc 
  | Pasrint -> prim ~primitive:Pasrint ~args loc 
  | Pstringlength -> prim ~primitive:Pstringlength ~args loc 
  | Pstringrefu -> prim ~primitive:Pstringrefu ~args loc 
  | Pstringsetu 
  | Pstringsets -> assert false
  | Pstringrefs -> prim ~primitive:Pstringrefs ~args loc 

  | Pbyteslength -> prim ~primitive:Pbyteslength ~args loc 
  | Pbytesrefu -> prim ~primitive:Pbytesrefu ~args loc
  | Pbytessetu -> prim ~primitive:Pbytessetu ~args  loc 
  | Pbytesrefs -> prim ~primitive:Pbytesrefs ~args loc 
  | Pbytessets -> prim ~primitive:Pbytessets ~args loc 
  | Pisint -> prim ~primitive:Pisint ~args loc 
  | Pisout -> prim ~primitive:Pisout ~args loc 
  | Pbittest -> prim ~primitive:Pbittest ~args loc 
  | Pintoffloat -> prim ~primitive:Pintoffloat ~args loc
  | Pfloatofint -> prim ~primitive:Pfloatofint ~args loc 
  | Pnegfloat -> prim ~primitive:Pnegfloat ~args loc 
  | Pabsfloat -> prim ~primitive:Pabsfloat ~args loc 
  | Paddfloat -> prim ~primitive:Paddfloat ~args loc 
  | Psubfloat -> prim ~primitive:Psubfloat ~args loc 
  | Pmulfloat -> prim ~primitive:Pmulfloat ~args loc 
  | Pdivfloat -> prim ~primitive:Pdivfloat ~args loc 

  | Pbswap16 -> prim ~primitive:Pbswap16 ~args loc 
  | Pintcomp x -> prim ~primitive:(Pintcomp x)  ~args loc 
  | Poffsetint x -> prim ~primitive:(Poffsetint x) ~args loc 
  | Poffsetref x -> prim ~primitive:(Poffsetref x) ~args  loc
  | Pfloatcomp x -> prim ~primitive:(Pfloatcomp x) ~args loc 
  | Pmakearray x -> prim ~primitive:(Pmakearray x) ~args  loc 
  | Parraylength x -> prim ~primitive:(Parraylength x) ~args loc
  | Parrayrefu x -> prim ~primitive:(Parrayrefu x) ~args loc
  | Parraysetu x -> prim ~primitive:(Parraysetu x) ~args loc 
  | Parrayrefs x -> prim ~primitive:(Parrayrefs x) ~args loc 
  | Parraysets x -> prim ~primitive:(Parraysets x) ~args loc 
  | Pbintofint x -> prim ~primitive:(Pbintofint x) ~args loc 
  | Pintofbint x -> prim ~primitive:(Pintofbint x) ~args loc 
  | Pnegbint x -> prim ~primitive:(Pnegbint x) ~args loc 
  | Paddbint x -> prim ~primitive:(Paddbint x) ~args loc 
  | Psubbint x -> prim ~primitive:(Psubbint x) ~args loc 
  | Pmulbint x -> prim ~primitive:(Pmulbint x) ~args loc 
  | Pdivbint x -> prim ~primitive:(Pdivbint x) ~args loc 
  | Pmodbint x -> prim ~primitive:(Pmodbint x) ~args loc 
  | Pandbint x -> prim ~primitive:(Pandbint x) ~args loc 
  | Porbint x -> prim ~primitive:(Porbint x) ~args loc 
  | Pxorbint x -> prim ~primitive:(Pxorbint x) ~args loc 
  | Plslbint x -> prim ~primitive:(Plslbint x) ~args loc 
  | Plsrbint x -> prim ~primitive:(Plsrbint x) ~args loc 
  | Pasrbint x -> prim ~primitive:(Pasrbint x) ~args loc 
  | Pbigarraydim x -> prim ~primitive:(Pbigarraydim x) ~args loc 
  | Pstring_load_16 x -> prim ~primitive:(Pstring_load_16 x) ~args loc 
  | Pstring_load_32 x -> prim ~primitive:(Pstring_load_32 x) ~args loc 
  | Pstring_load_64 x -> prim ~primitive:(Pstring_load_64 x) ~args loc 
  | Pstring_set_16 x -> prim ~primitive:(Pstring_set_16 x) ~args loc 
  | Pstring_set_32 x -> prim ~primitive:(Pstring_set_32 x) ~args loc 
  | Pstring_set_64 x -> prim ~primitive:(Pstring_set_64 x) ~args loc 
  | Pbigstring_load_16 x -> prim ~primitive:(Pbigstring_load_16 x) ~args loc 
  | Pbigstring_load_32 x -> prim ~primitive:(Pbigstring_load_32 x) ~args loc 
  | Pbigstring_load_64 x -> prim ~primitive:(Pbigstring_load_64 x) ~args loc 
  | Pbigstring_set_16 x -> prim ~primitive:(Pbigstring_set_16 x) ~args loc 
  | Pbigstring_set_32 x -> prim ~primitive:(Pbigstring_set_32 x) ~args loc 
  | Pbigstring_set_64 x -> prim ~primitive:(Pbigstring_set_64 x) ~args loc 
  | Pctconst x ->
    begin match x with
      | Word_size ->
        Lift.int 32 (* TODO: documentation*)        
      | _ -> prim ~primitive:(Pctconst x) ~args loc          
    end

  | Pbbswap x -> prim ~primitive:(Pbbswap x) ~args loc 
  | Pcvtbint (a,b) -> prim ~primitive:(Pcvtbint (a,b)) ~args loc 
  | Pbintcomp (a,b) -> prim ~primitive:(Pbintcomp (a,b)) ~args loc 
  | Pbigarrayref (a,b,c,d) -> prim ~primitive:(Pbigarrayref (a,b,c,d)) ~args loc 
  | Pbigarrayset (a,b,c,d) -> prim ~primitive:(Pbigarrayset (a,b,c,d)) ~args loc 



type bindings = (Ident.t * t) list


let preprocess_deps (groups : bindings) : _ * Ident.t array * Int_vec.t array   = 
  let len = List.length groups in 
  let domain : _ Ordered_hash_map_local_ident.t = 
    Ordered_hash_map_local_ident.create len in 
  let mask = Hash_set_ident_mask.create len in   
  List.iter (fun (x,lam) -> 
      Ordered_hash_map_local_ident.add domain x lam;
      Hash_set_ident_mask.add_unmask mask x;
    ) groups ;
  let int_mapping = Ordered_hash_map_local_ident.to_sorted_array domain in 
  let node_vec = Array.make (Array.length int_mapping) (Int_vec.empty ()) in
  domain
  |> Ordered_hash_map_local_ident.iter ( fun id lam key_index ->        
      let base_key =  node_vec.(key_index) in 
      ignore (hit_mask mask lam) ;
      mask |> Hash_set_ident_mask.iter_and_unmask (fun ident hit  -> 
          if hit then 
            begin 
              let key = Ordered_hash_map_local_ident.rank domain ident in 
              Int_vec.push key base_key;
            end
        );

    ) ;
  domain, int_mapping , node_vec


let is_function_bind (_, (x : t)) = 
  match x with 
  | Lfunction _ -> true 
  | _ -> false 

let sort_single_binding_group (group : bindings) = 
  if List.for_all is_function_bind group then group
  else 
    List.sort (fun (_,lama) (_,lamb) -> 
        match lama,lamb with 
        | Lfunction _, Lfunction _ ->  0 
        | Lfunction _ , _ -> -1 
        | _, Lfunction _ -> 1 
        | _,_ -> 0
      ) group

(** TODO: even for a singleton recursive function, tell whehter it is recursive or not ? *)
let scc_bindings (groups : bindings) : bindings list = 
  match groups with 
  | [ _ ] -> [ sort_single_binding_group groups ]
  | _ -> 
    let domain, int_mapping, node_vec = preprocess_deps groups in 
    let clusters : Int_vec_vec.t = Ext_scc.graph node_vec in 
    if Int_vec_vec.length clusters <= 1 then [ sort_single_binding_group groups]
    else 
      Int_vec_vec.fold_right (fun  (v : Int_vec.t) acc ->
          let bindings =
            Int_vec.map_into_list (fun i -> 
                let id = int_mapping.(i) in 
                let lam  = Ordered_hash_map_local_ident.find_value domain  id in  
                (id,lam)
              ) v  in 
          sort_single_binding_group bindings :: acc 
        )  clusters []
(* single binding, it does not make sense to do scc,
   we can eliminate {[ let rec f x = x + x  ]}, but it happens rarely in real world 
*)
let scc  (groups :  bindings)  ( lam : t) ( body : t)
  =     
  begin match groups with 
    | [ (id,bind) ] ->
      if hit_any_variables (Ident_set.singleton id) bind 
      then 
        lam  
      else let_ Strict id bind body  
    | _ ->    
      let (domain, int_mapping, node_vec)  = preprocess_deps groups in 
      let clusters = Ext_scc.graph node_vec in 
      if Int_vec_vec.length clusters <= 1 then lam 
      else          
        Int_vec_vec.fold_right (fun  (v : Int_vec.t) acc ->
            let bindings =
              Int_vec.map_into_list (fun i -> 
                  let id = int_mapping.(i) in 
                  let lam  = Ordered_hash_map_local_ident.find_value domain  id in  
                  (id,lam)
                ) v  in 
            match bindings with 
            | [ id,lam ] ->
              let base_key = Ordered_hash_map_local_ident.rank domain id in    
              if Int_vec_util.mem base_key node_vec.(base_key) then       
                letrec bindings acc 
              else  let_ Strict id lam acc    
            | _ ->  
              letrec bindings  acc 
          )  clusters body 
  end


type required_modules = Lam_module_ident.Hash_set.t


let convert exports lam : _ * _  = 
  let alias_tbl = Ident_hashtbl.create 64 in 
  let exit_map = Int_hashtbl.create 0 in 
  let may_depends = Lam_module_ident.Hash_set.create 0 in 

  let rec
    aux_js_primitive (p: Primitive.description) (args : Lambda.lambda list) loc =
    let s = p.prim_name in
    if s = "#raw_expr" then 
      begin match args with 
        | [Lconst( Const_base (Const_string(s,_)))] -> 
          prim ~primitive:(Praw_js_code_exp s)
            ~args:[] loc 
        | _ -> assert false 
      end  
    else if s = "#raw_stmt" then 
      begin match args with 
        | [Lconst( Const_base (Const_string(s,_)))] -> 
          prim ~primitive:(Praw_js_code_stmt s)
            ~args:[] loc         
        | _ -> assert false 
      end 
    else if s =  "#debugger"  then 
      (* ATT: Currently, the arity is one due to PPX *)
      prim ~primitive:Pdebugger ~args:[] loc 
    else 
      let args = Ext_list.map aux args in 
      let primitive = match s with 
        | "#apply" -> Pjs_runtime_apply
        | "#apply1"
        | "#apply2"
        | "#apply3"
        | "#apply4"
        | "#apply5"
        | "#apply6"
        | "#apply7"
        | "#apply8" -> Pjs_apply
        | "#undefined_to_opt" -> Pundefined_to_opt
        | "#null_undefined_to_opt" -> Pnull_undefined_to_opt
        | "#null_to_opt" -> Pnull_to_opt
        | "#is_nil"  -> Pis_null
        | "#is_undef" -> Pis_undefined
        | "#is_nil_undef" -> Pis_null_undefined
        | "#string_append" -> Pstringadd

        | "#is_instance_array" -> Pjs_is_instance_array
        | "#string_of_small_int_array" -> Pjs_string_of_small_array
        (* {[String.fromCharCode.apply(null,x)]} 
           Note if we have better suport [@bs.splice],
           we can get rid of it*)
        | "#obj_set_length" -> Pcaml_obj_set_length
        | "#obj_length" -> Pcaml_obj_length
        | "#boolean_to_bool" -> Pjs_boolean_to_bool

        | "#function_length" -> Pjs_function_length

        | "#unsafe_lt" -> Pjscomp Clt 
        | "#unsafe_gt" -> Pjscomp Cgt 
        | "#unsafe_le" -> Pjscomp Cle 
        | "#unsafe_ge" -> Pjscomp Cge
        | "#unsafe_eq" -> Pjscomp Ceq
        | "#unsafe_neq" -> Pjscomp Cneq

        | "#typeof" -> Pjs_typeof
        | "#fn_run" | "#method_run" -> Pjs_fn_run(int_of_string p.prim_native_name)
        | "#fn_mk" -> Pjs_fn_make (int_of_string p.prim_native_name)
        | "#fn_method" -> Pjs_fn_method (int_of_string p.prim_native_name)
        | "#unsafe_downgrade" -> Pjs_unsafe_downgrade (Ext_string.empty,loc)
        | _ -> Location.raise_errorf ~loc
                 "@{<error>Error:@} internal error, using unrecorgnized primitive %s" s 
      in
      prim ~primitive ~args loc 
  and aux_constant ( const : Lambda.structured_constant) : constant = 
    match const with 
    | Const_base (Const_int i) -> (Const_int i)
    | Const_base (Const_char i) -> (Const_char i)
    | Const_base (Const_string(i,opt)) ->
      begin match opt with 
        | Some opt when 
            Ext_string.equal opt Literals.escaped_j_delimiter ->
          Const_unicode i
        | _ ->   
          Const_string i
      end 
    | Const_base (Const_float i) -> (Const_float i)
    | Const_base (Const_int32 i) -> (Const_int32 i)
    | Const_base (Const_int64 i) -> (Const_int64 i)
    | Const_base (Const_nativeint i) -> (Const_nativeint i)
    | Const_pointer(i,p) -> Const_pointer (i,p)
    | Const_float_array (s) -> Const_float_array(s)
    | Const_immstring s -> Const_immstring s 
    | Const_block (i,t,xs) -> 
      Const_block (i,t, Ext_list.map aux_constant xs)
  and aux (lam : Lambda.lambda) : t = 
    match lam with 
    | Lvar x -> 
      let var = Ident_hashtbl.find_default alias_tbl x x in
      if Ident.persistent var then 
        Lglobal_module var 
      else       
        Lvar var       
    | Lconst x -> 
      Lconst (aux_constant x )
    | Lapply (fn,args,loc) 
      ->  
      begin match fn with 
        | Lprim (
            Pfield (id, _),
            [
              Lprim (
                Pgetglobal { name = "CamlinternalMod" },
                _,_
              )
            ],loc
          ) -> (* replace all {!CamlinternalMod} function *)
          let args = Ext_list.map aux args in
          begin match Ocaml_stdlib_slots.camlinternalMod.(id), args  with
            | "init_mod" ,  [_loc ; shape]  -> 
              begin match shape with 
                | Lconst (Const_block (0, _, [Const_block (0, _, [])])) 
                  -> unit  (* see {!Translmod.init_shape}*)
                | _ ->  prim ~primitive:Pinit_mod ~args loc 
              end
            | "update_mod", [shape ;  _obj1; _obj2] -> 
              (* here array access will have side effect .. *)
              begin match shape with 
                | Lconst (Const_block (0, _, [Const_block (0, _, [])]))
                  -> unit (* see {!Translmod.init_shape}*)
                | _ -> prim ~primitive:Pupdate_mod ~args loc
              end
            | _ -> assert false
          end

        | Lprim ( Pfield (id, _),
                  [Lprim (Pgetglobal ({name  = "Pervasives"} ), _,_)],loc              
                )
          ->
          let args = Ext_list.map aux args in
          begin match Ocaml_stdlib_slots.pervasives.(id) , args  with
            | "^", [ l; r ] 
              ->
              prim ~primitive:Pstringadd ~args:[l;r] loc 
            | _ ->  apply (aux fn) args loc  App_na
          end
        (*  
        | Lfunction(kind,params,Lprim(prim,inner_args,inner_loc))
          when List.for_all2_no_exn (fun x y -> 
          match y with 
          | Lambda.Lvar y when Ident.same x y -> true
          | _ -> false 
           ) params inner_args
          -> 
          let rec aux outer_args params = 
            match outer_args, params with 
            | x::xs , _::ys -> 
              x :: aux xs ys 
            | [], [] -> []
            | x::xs, [] -> 
            | [], y::ys 
          if Ext_list.same_length inner_args args then 
            aux (Lprim(prim,args,inner_loc))
          else 

           {[
             (fun x y -> f x y) (computation;e) --> 
             (fun y -> f (computation;e) y) 
           ]}
              is wrong

              or 
           {[
             (fun x y -> f x y ) ([|1;2;3|]) --> 
             (fun y -> f [|1;2;3|] y) 
           ]}
              is also wrong.

              It seems, we need handle [@bs.splice] earlier

              or 
           {[
             (fun x y -> f x y) ([|1;2;3|]) --> 
             let x0, x1, x2 =1,2,3 in 
             (fun y -> f [|x0;x1;x2|] y)                
           ]}
              But this still need us to know [@bs.splice] in advance


           we should not remove it immediately, since we have to be careful 
                  where it is used, it can be [exported], [Lvar] or [Lassign] etc 
                  The other common mistake is that 
           {[
             let x = y (* elimiated x/y*)
             let u = x  (* eliminated u/x *)
           ]}

            however, [x] is already eliminated 
           To improve the algorithm
           {[
             let x = y (* x/y *)
             let u = x (* u/y *)
           ]}
                  This looks more correct, but lets be conservative here

                  global module inclusion {[ include List ]}
                  will cause code like {[ let include =a Lglobal_module (list)]}

                  when [u] is global, it can not be bound again, 
                  it should always be the leaf 
        *)
        | _ -> 

          (** we need do this eargly in case [aux fn] add some wrapper *)
          apply (aux fn) (Ext_list.map aux args) 
            loc App_na
      end
    | Lfunction (Tupled,_,_) -> assert false
    | Lfunction (Curried,  params,body)
      ->  function_ 
            ~arity:(List.length params) ~function_kind:Curried ~params 
            ~body:(aux body)
    | Llet (kind,id,e,body) 
      ->

      begin match kind, e with 
        | Alias , (Lvar u ) ->
          let new_u = (Ident_hashtbl.find_default alias_tbl u u) in
          Ident_hashtbl.add alias_tbl id new_u ;
          if Ident_set.mem id exports then 
            Llet(kind, id, Lvar new_u, aux body)
          else aux body   
        | Alias ,  Lprim (Pgetglobal u,[], _) when not (Ident.is_predef_exn u)
          ->         
          Ident_hashtbl.add alias_tbl id u;          
          may_depend may_depends (Lam_module_ident.of_ml u);

          if Ident_set.mem id exports then 
            Llet(kind, id, Lvar u, aux body)
          else aux body   

        | _, _ -> Llet(kind,id,aux e, aux body)
      end
    | Lletrec (bindings,body)
      -> 
      let bindings = Ext_list.map (fun (id, e) -> id, aux e) bindings in
      let body = aux body in 
      let lam = Lletrec (bindings, body) in 
      scc bindings lam body  
    (* inlining will affect how mututal recursive behave *)
    | Lprim(Prevapply, [x ; f ],  outer_loc) 
    | Lprim(Pdirapply, [f ; x],  outer_loc) -> 
      begin match f with 
        (* [x|>f] 
           TODO: [airty = 0] when arity =0, it can not be escaped user can only
           write  [f x ] instead of [x |> f ]
        *)
        | Lfunction(kind, [param],Lprim(external_fn,[Lvar inner_arg],inner_loc))
          when Ident.same param inner_arg 
          -> 
          aux  (Lprim(external_fn,  [x], outer_loc))

        |  Lapply(Lfunction(kind, params,Lprim(external_fn,inner_args,inner_loc)), args, outer_loc ) (* x |> f a *) 

          when Ext_list.for_all2_no_exn (fun x y -> match y with Lambda.Lvar y when Ident.same x y  -> true | _ -> false ) params inner_args
               &&            
               Ext_list.length_larger_than_n 1 inner_args args
          -> 

          aux (Lprim(external_fn, Ext_list.append args [x], outer_loc))
        | _ -> 
          let x  = aux x in 
          let f =  aux f in 
          begin match  f with 
            | Lapply{fn;args} ->
              apply fn (args @[x]) outer_loc App_na 
            | _ -> 
              apply f [x] outer_loc App_na        
          end 
      end
    | Lprim (Prevapply, _, _ ) -> assert false       
    | Lprim(Pdirapply, _, _) -> assert false   
    | Lprim(Pccall a, args, loc)  -> 
      let prim_name = a.prim_name in    
      let prim_name_len  = String.length prim_name in 
      begin match Ast_ffi_types.from_string a.prim_native_name with 
        | Ffi_normal ->
          if prim_name_len > 0 && String.unsafe_get prim_name 0 = '#' then 
            aux_js_primitive a args loc 
          else 
            (* COMPILER CHECK *)
            (* Here the invariant we should keep is that all exception 
               created should be captured
            *)
          if a.prim_name = "caml_set_oo_id" then (**)
            begin match  args with 
              | [ Lprim (Pmakeblock(tag,( Blk_exception| Blk_extension), _),
                         Lconst (Const_base(Const_string(name,_))) :: _,
                         loc
                        )] 
                -> prim ~primitive:(Pcreate_extension name) ~args:[] loc 
              | _ -> 
                let args = Ext_list.map aux args in 
                prim ~primitive:(Pccall a) ~args loc
            end
          else  
            let args = Ext_list.map aux args in 
            prim ~primitive:(Pccall a) ~args loc
        | Ffi_obj_create labels ->
          let args = Ext_list.map aux args in 
          prim ~primitive:(Pjs_object_create labels) ~args loc 
        | Ffi_bs(arg_types, result_type, ffi) ->
          let args = Ext_list.map aux args in 
          if no_auto_uncurried_arg_types arg_types then   
            result_wrap loc result_type @@ prim ~primitive:(Pjs_call(prim_name, arg_types, ffi)) 
              ~args loc 
          else 
            let n_arg_types, n_args = 
              transform_uncurried_arg_type loc  arg_types args in 
            result_wrap loc result_type @@
            prim ~primitive:(Pjs_call (prim_name, n_arg_types, ffi))
              ~args:n_args loc 
      end
    | Lprim (Pgetglobal id, args, loc) ->   
      let args = Ext_list.map aux args in 
      if Ident.is_predef_exn id then 
        Lprim {primitive = Pglobal_exception id; args ; loc}
      else 
        begin 
          may_depend may_depends (Lam_module_ident.of_ml id);
          assert (args = []);
          Lglobal_module id 
        end  
    | Lprim (primitive,args, loc) 
      -> 
      let args = Ext_list.map aux args in
      lam_prim ~primitive ~args loc 
    | Lswitch (e,s) -> 
      let  e = aux e in 
      begin match s with 
        | {
          sw_failaction = None ;
          sw_blocks = [];
          sw_numblocks = 0;
          sw_consts ; 
          sw_numconsts ;
        } ->
          begin match happens_to_be_diff sw_consts with 
            | Some 0 -> e
            | Some _ 
            | None ->
              Lswitch(e,  
                      {sw_failaction = None; 
                       sw_blocks = []; 
                       sw_numblocks = 0;
                       sw_consts =
                         Ext_list.map (fun (i,lam) -> i, aux lam) sw_consts;
                       sw_numconsts
                      })
          end
        | _ -> Lswitch ( e, aux_switch s)
      end
    | Lstringswitch (e, cases, default,_) -> 
      Lstringswitch (aux e, Ext_list.map (fun (x, b) -> x, aux b ) cases, 
                     match default with 
                     | None -> None
                     | Some x -> Some (aux x)
                    )    
    | Lstaticraise (id,[]) ->
      begin match Int_hashtbl.find_opt exit_map id  with
        | None -> Lstaticraise (id,[])
        | Some new_id -> Lstaticraise (new_id,[])
      end               
    | Lstaticraise (id, args) -> 
      Lstaticraise (id, Ext_list.map aux args)
    | Lstaticcatch (b, (i,[]), Lstaticraise (j,[]) ) 
      -> (* peep-hole [i] aliased to [j] *)

      let new_i = Int_hashtbl.find_default exit_map j j in 
      Int_hashtbl.add exit_map i new_i ; 
      aux b
    | Lstaticcatch (b, (i, ids), handler) -> 
      Lstaticcatch (aux b, (i,ids), aux handler)
    | Ltrywith (b, id, handler) ->
      let body = aux b in 
      let handler = aux handler in 
      if exception_id_escaped id handler then 
        let newId = Ident.create ("raw_" ^ id.name) in 
        Ltrywith (body, newId, 
                  let_ StrictOpt id 
                    (prim ~primitive:Pwrap_exn ~args:[var newId] Location.none)
                    handler
                 ) 
      else 
        Ltrywith( body, id, handler)
    | Lifthenelse (b,then_,else_) -> 
      Lifthenelse (aux b, aux then_, aux else_)
    | Lsequence (a,b) 
      -> Lsequence (aux a, aux b)
    | Lwhile (b,body) -> 
      Lwhile (aux b, aux body)
    | Lfor (id, from_, to_, dir, loop) -> 
      Lfor (id, aux from_, aux to_, dir, aux loop)
    | Lassign (id, body) -> 
      Lassign (id, aux body)    
    | Lsend (kind, a,b,ls, loc) -> 
      (* Format.fprintf Format.err_formatter "%a@." Printlambda.lambda b ; *)
      begin match aux b with 
        | Lprim {primitive =  Pjs_unsafe_downgrade(_,loc);  args} 
          -> 
          begin match kind, ls with 
            | Public (Some name), [] -> 
              prim ~primitive:(Pjs_unsafe_downgrade (name,loc)) 
                ~args loc 
            | _ -> assert false 
          end
        | b ->     
          Lsend(kind, aux a,  b, Ext_list.map aux ls, loc )
      end
    | Levent (e, event) ->
      (* disabled by upstream*)
      assert false
    | Lifused (id, e) -> 
      Lifused(id, aux e) (* TODO: remove it ASAP *)
  and aux_switch (s : Lambda.lambda_switch) : switch = 
    { sw_numconsts = s.sw_numconsts ; 
      sw_consts = Ext_list.map (fun (i, lam) -> i, aux lam) s.sw_consts;
      sw_numblocks = s.sw_numblocks;
      sw_blocks = Ext_list.map (fun (i,lam) -> i, aux lam ) s.sw_blocks;
      sw_failaction = 
        match s.sw_failaction with 
        | None -> None 
        | Some a -> Some (aux a)
    }  in 
  aux lam , may_depends



end
module Lam_arity : sig 
#1 "lam_arity.mli"
(* Copyright (C) Authors of BuckleScript
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


type t = 
  | Determin of bool * (int * Ident.t list option) list  * bool
    (**
      when the first argument is true, it is for sure 
      the last one means it can take any params later, 
      for an exception: it is (Determin (true,[], true))
      1. approximation sound but not complete 
      
   *)
  | NA 

val print : Format.formatter -> t -> unit   

val print_arities_tbl : 
  Format.formatter -> 
  (Ident.t, t ref) Hashtbl.t -> 
  unit 

end = struct
#1 "lam_arity.ml"
(* Copyright (C) Authors of BuckleScript
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


type t = 
  | Determin of bool * (int * Ident.t list option) list  * bool
    (**
      when the first argument is true, it is for sure 
      the last one means it can take any params later, 
      for an exception: it is (Determin (true,[], true))
      1. approximation sound but not complete 
      
   *)
  | NA 

let pp = Format.fprintf

let print (fmt : Format.formatter) (x : t) = 
  match x with 
  | NA -> pp fmt "?"
  | Determin (b,ls,tail) -> 
    begin 
      pp fmt "@[";
      (if not b 
       then 
         pp fmt "~");
      pp fmt "[";
      Format.pp_print_list ~pp_sep:(fun fmt () -> pp fmt ",")
        (fun fmt  (x,_) -> Format.pp_print_int fmt x)
        fmt ls ;
      if tail 
      then pp fmt "@ *";
      pp fmt "]@]";
    end
  
  let print_arities_tbl 
    (fmt : Format.formatter) 
    (arities_tbl : (Ident.t, t ref) Hashtbl.t) = 
  Hashtbl.fold (fun (i:Ident.t) (v : t ref) _ -> 
      pp Format.err_formatter "@[%s -> %a@]@."i.name print !v ) arities_tbl ()

end
module Js_cmj_format : sig 
#1 "js_cmj_format.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Define intemediate format to be serialized for cross module optimization
 *)

(** In this module, 
    currently only arity information is  exported, 

    Short term: constant literals are also exported 

    Long term:
    Benefit? since Google Closure Compiler already did such huge amount of work
    TODO: simple expression, literal small function  can be stored, 
    but what would happen if small function captures other environment
    for example 

    {[
      let f  = fun x -> g x 
    ]}

    {[
      let f = g 
    ]}
*)

type arity = 
  | Single of Lam_arity.t
  | Submodule of Lam_arity.t array

type cmj_value = {
  arity : arity ; 
  closed_lambda : Lam.t option ; 
  (* Either constant or closed functor *)
}

type effect = string option



type t = {
  values : cmj_value String_map.t;
  effect : effect;
  npm_package_path : Js_packages_info.t;
  case : bool;
}

val single_na : arity
val pure_dummy : t
val no_pure_dummy : t


val from_file : string -> t
val from_string : string -> t

val to_file : string -> t -> unit


end = struct
#1 "js_cmj_format.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






type arity = 
  | Single of Lam_arity.t
  | Submodule of Lam_arity.t array

(* TODO: add a magic number *)
type cmj_value = {
  arity : arity ;
  closed_lambda : Lam.t option ; 
  (** Either constant or closed functor *)
}

type effect = string option


let single_na = Single NA
(** we don't force people to use package *)

type t = {
  values : cmj_value String_map.t;
  effect : effect;
  npm_package_path : Js_packages_info.t ;
  case : bool; (* little case -> true *)
}

let cmj_magic_number =  "BUCKLE20170907"
let cmj_magic_number_length = 
  String.length cmj_magic_number

let pure_dummy = 
  {
    values = String_map.empty;
    effect = None;
    npm_package_path = Js_packages_info.empty;
    case = true;
  }

let no_pure_dummy = 
  {
    values = String_map.empty;
    effect = Some Ext_string.empty;
    npm_package_path = Js_packages_info.empty;  
    case = true;
  }



let from_file name : t =
  let ic = open_in_bin name in 
  let buffer = really_input_string ic cmj_magic_number_length in 
  if buffer <> cmj_magic_number then
    Ext_pervasives.failwithf ~loc:__LOC__ 
      "cmj files have incompatible versions, please rebuilt using the new compiler : %s" 
        __LOC__
  else 
    let v  : t = input_value ic in 
    close_in ic ;
    v 


let from_string s : t = 
  let magic_number = String.sub s 0 cmj_magic_number_length in 
  if magic_number = cmj_magic_number then 
    Marshal.from_string s  cmj_magic_number_length
  else 
    Ext_pervasives.failwithf ~loc:__LOC__ 
      "cmj files have incompatible versions, please rebuilt using the new compiler : %s"
        __LOC__

let to_file name (v : t) = 
  let oc = open_out_bin name in 
  output_string oc cmj_magic_number;
  output_value oc v;
  close_out oc 



end
module Js_cmj_load : sig 
#1 "js_cmj_load.mli"
(* Copyright (C) Authors of BuckleScript
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


 (** This module is platform dependent, on browser environment, 
    it depends on {!Js_cmj_datasets}, for non-browser environment, it fails
 *)



(** return path and meta data *)
val find_cmj : string -> string * Js_cmj_format.t

end = struct
#1 "js_cmj_load.ml"
(* Copyright (C) Authors of BuckleScript
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

(* strategy:
   If not installed, use the distributed [cmj] files, 
   make sure that the distributed files are platform independent
*)
let find_cmj file : string * Js_cmj_format.t = 
  match Config_util.find_opt file with
  | Some f
    -> 
    f, Js_cmj_format.from_file f             
  | None -> 
    (* ONLY read the stored cmj data in browser environment *)

        Bs_exception.error (Cmj_not_found file)
        


end
module Js_fold
= struct
#1 "js_fold.ml"
(* BuckleScript compiler
 * Copyright (C) 2015-2016 Bloomberg Finance L.P.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, with linking exception;
 * either version 2.1 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 *)
(* Author: Hongbo Zhang  *)
(** GENERATED CODE for fold visitor patten of JS IR  *)
open J
  
class virtual fold =
  object ((o : 'self_type))
    method string : string -> 'self_type = o#unknown
    method option :
      'a. ('self_type -> 'a -> 'self_type) -> 'a option -> 'self_type =
      fun _f_a -> function | None -> o | Some _x -> let o = _f_a o _x in o
    method list :
      'a. ('self_type -> 'a -> 'self_type) -> 'a list -> 'self_type =
      fun _f_a ->
        function
        | [] -> o
        | _x :: _x_i1 -> let o = _f_a o _x in let o = o#list _f_a _x_i1 in o
    method int : int -> 'self_type = o#unknown
    method bool : bool -> 'self_type = function | false -> o | true -> o
    method vident : vident -> 'self_type =
      function
      | Id _x -> let o = o#ident _x in o
      | Qualified (_x, _x_i1, _x_i2) ->
          let o = o#ident _x in
          let o = o#kind _x_i1 in
          let o = o#option (fun o -> o#string) _x_i2 in o
    method variable_declaration : variable_declaration -> 'self_type =
      fun { ident = _x; value = _x_i1; property = _x_i2; ident_info = _x_i3 }
        ->
        let o = o#ident _x in
        let o = o#option (fun o -> o#expression) _x_i1 in
        let o = o#property _x_i2 in let o = o#ident_info _x_i3 in o
    method tag_info : tag_info -> 'self_type = o#unknown
    method statement_desc : statement_desc -> 'self_type =
      function
      | Block _x -> let o = o#block _x in o
      | Variable _x -> let o = o#variable_declaration _x in o
      | Exp _x -> let o = o#expression _x in o
      | If (_x, _x_i1, _x_i2) ->
          let o = o#expression _x in
          let o = o#block _x_i1 in
          let o = o#option (fun o -> o#block) _x_i2 in o
      | While (_x, _x_i1, _x_i2, _x_i3) ->
          let o = o#option (fun o -> o#label) _x in
          let o = o#expression _x_i1 in
          let o = o#block _x_i2 in let o = o#unknown _x_i3 in o
      | ForRange (_x, _x_i1, _x_i2, _x_i3, _x_i4, _x_i5) ->
          let o = o#option (fun o -> o#for_ident_expression) _x in
          let o = o#finish_ident_expression _x_i1 in
          let o = o#for_ident _x_i2 in
          let o = o#for_direction _x_i3 in
          let o = o#block _x_i4 in let o = o#unknown _x_i5 in o
      | Continue _x -> let o = o#label _x in o
      | Break -> o
      | Return _x -> let o = o#return_expression _x in o
      | Int_switch (_x, _x_i1, _x_i2) ->
          let o = o#expression _x in
          let o =
            o#list
              (fun o ->
                 (* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)
                 (** Javascript IR
  
    It's a subset of Javascript AST specialized for OCaml lambda backend

    Note it's not exactly the same as Javascript, the AST itself follows lexical
    convention and [Block] is just a sequence of statements, which means it does 
    not introduce new scope
*)
                 (** object literal, if key is ident, in this case, it might be renamed by 
    Google Closure  optimizer,
    currently we always use quote
 *)
                 (* Since camldot is only available for toplevel module accessors,
       we don't need print  `A.length$2`
       just print `A.length` - it's guarateed to be unique
       
       when the third one is None, it means the whole module 

       TODO: 
       invariant, when [kind] is [Runtime], then we can ignore [ident], 
       since all [runtime] functions are unique, when do the 
       pattern match we can ignore the first one for simplicity
       for example       
       {[
         Qualified (_, Runtime, Some "caml_int_compare")         
       ]}       
     *)
                 (** where we use a trick [== null ] *)
                 (* used in [#create_array] primitive, note having
       uninitilized array is not as bad as in ocaml, 
       since GC does not rely on it
     *)
                 (* shallow copy, like [x.slice] *)
                 (* For [caml_array_append]*)
                 (* | Tag_ml_obj of expression *) (* js true/false*)
                 (* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence 
     [typeof] is an operator     
  *)
                 (* 1 - v *) (* !v *)
                 (* String.fromCharCode.apply(null, args) *)
                 (* Convert JS boolean into OCaml boolean 
       like [+true], note this ast talks using js
       terminnology unless explicity stated                       
     *)
                 (* TODO: in the future, it might make sense to group primitivie by type,
     which makes optimizations easier
     {[ JSON.stringify(value, replacer[, space]) ]}
  *)
                 (* for debugging utitlites, 
     TODO:  [Dump] is not necessary with this primitive 
     Note that the semantics is slightly different from [JSON.stringify]     
     {[
       JSON.stringify("x")       
     ]}
     {[
       ""x""       
     ]}     
     {[
       JSON.stringify(undefined)       
     ]}     
     {[
       undefined       
     ]}
     {[ '' + undefined
     ]}     
     {[ 'undefined'
     ]}     
  *)
                 (* TODO: 
     add 
     {[ Assert of bool * expression ]}     
  *)
                 (* to support 
       val log1 : 'a -> unit
       val log2 : 'a -> 'b -> unit 
       val log3 : 'a -> 'b -> 'c -> unit 
     *)
                 (* TODO: Add some primitives so that [js inliner] can do a better job *)
                 (* [int_op] will guarantee return [int32] bits 
     https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators  *)
                 (* | Int32_bin of int_op * expression * expression *)
                 (* f.apply(null,args) -- Fully applied guaranteed 
       TODO: once we know args's shape --
       if it's know at compile time, we can turn it into
       f(args[0], args[1], ... )
     *)
                 (* {[ Bind (a,b) ]}
     is literally
     {[ a.bind(b) ]}
  *)
                 (* Analysze over J expression is hard since, 
        some primitive  call is translated 
        into a plain call, it's better to keep them
    *)
                 (* Invariant: 
       The second argument has to be type of [int],
       This can be constructed either in a static way [E.index] or a dynamic way 
       [E.access]
     *)
                 (* The third argument bool indicates whether we should 
       print it as 
       a["idd"] -- false
       or 
       a.idd  -- true
       There are several kinds of properties
       1. OCaml module dot (need to be escaped or not)
          All exported declarations have to be OCaml identifiers
       2. Javascript dot (need to be preserved/or using quote)
     *)
                 (* TODO: option remove *)
                 (* The first parameter by default is false, 
     it will be true when it's a method
  *)
                 (* A string is UTF-8 encoded, the string may contain
       escape sequences.
       The first argument is used to mark it is non-pure, please
       don't optimize it, since it does have side effec, 
       examples like "use asm;" and our compiler may generate "error;..." 
       which is better to leave it alone
       The last argument is passed from as `j` from `{j||j}`
     *)
                 (* It is escaped string, print delimited by '"'*)
                 (* literally raw JS code 
  *)
                 (* The third argument is [tag] , forth is [tag_info] *)
                 (* [tag] and [size] tailed  for [Obj.new_block] *)
                 (* For setter, it still return the value of expression, 
     we can not use 
     {[
       type 'a access = Get | Set of 'a
     ]}
     in another module, since it will break our code generator
     [Caml_block_tag] can return [undefined], 
     you have to use [E.tag] in a safe way     
  *)
                 (* It will just fetch tag, to make it safe, when creating it, 
     we need apply "|0", we don't do it in the 
     last step since "|0" can potentially be optimized
  *)
                 (* pure*) (* pure *)
                 (* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block
   block can be nested, specified in ES3 
 *)
                 (* Delay some units like [primitive] into JS layer ,
   benefit: better cross module inlining, and smaller IR size?
 *)
                 (* 
  [closure] captured loop mutable values in the outer loop

  check if it contains loop mutable values, happens in nested loop
  when closured, it's no longer loop mutable value. 
  which means the outer loop mutable value can not peek into the inner loop
  {[
  var i = f ();
  for(var finish = 32; i < finish; ++i){
  }
  ]}
  when [for_ident_expression] is [None], [var i] has to 
  be initialized outside, so 

  {[
  var i = f ()
  (function (xxx){
  for(var finish = 32; i < finish; ++i)
  }(..i))
  ]}
  This happens rare it's okay

  this is because [i] has to be initialized outside, if [j] 
  contains a block side effect
  TODO: create such example
*)
                 (* Since in OCaml, 
   
  [for i = 0 to k end do done ]
  k is only evaluated once , to encode this invariant in JS IR,
  make sure [ident] is defined in the first b

  TODO: currently we guarantee that [bound] was only 
  excecuted once, should encode this in AST level
*)
                 (* Can be simplified to keep the semantics of OCaml
   For (var i, e, ...){
     let  j = ... 
   }

   if [i] or [j] is captured inside closure

   for (var i , e, ...){
     (function (){
     })(i)
   }
*)
                 (* Single return is good for ininling..
   However, when you do tail-call optmization
   you loose the expression oriented semantics
   Block is useful for implementing goto
   {[
   xx:{
   break xx;
   }
   ]}
*)
                 (* Function declaration and Variable declaration  *)
                 (* check if it contains loop mutable values, happens in nested loop *)
                 (* only used when inline a fucntion *)
                 (* Here we need track back a bit ?, move Return to Function ...
                              Then we can only have one Return, which is not good *)
                 o#case_clause (fun o -> o#int))
              _x_i1 in
          let o = o#option (fun o -> o#block) _x_i2 in o
      | String_switch (_x, _x_i1, _x_i2) ->
          let o = o#expression _x in
          let o =
            o#list (fun o -> o#case_clause (fun o -> o#string)) _x_i1 in
          let o = o#option (fun o -> o#block) _x_i2 in o
      | Throw _x -> let o = o#expression _x in o
      | Try (_x, _x_i1, _x_i2) ->
          let o = o#block _x in
          let o =
            o#option
              (fun o (_x, _x_i1) ->
                 let o = o#exception_ident _x in let o = o#block _x_i1 in o)
              _x_i1 in
          let o = o#option (fun o -> o#block) _x_i2 in o
      | Debugger -> o
    method statement : statement -> 'self_type =
      fun { statement_desc = _x; comment = _x_i1 } ->
        let o = o#statement_desc _x in
        let o = o#option (fun o -> o#string) _x_i1 in o
    method return_expression : return_expression -> 'self_type =
      fun { return_value = _x } -> let o = o#expression _x in o
    method required_modules : required_modules -> 'self_type = o#unknown
    method property_name : property_name -> 'self_type = o#unknown
    method property_map : property_map -> 'self_type =
      o#list
        (fun o (_x, _x_i1) ->
           let o = o#property_name _x in let o = o#expression _x_i1 in o)
    method property : property -> 'self_type = o#unknown
    method program : program -> 'self_type =
      fun { name = _x; block = _x_i1; exports = _x_i2; export_set = _x_i3 }
        ->
        let o = o#string _x in
        let o = o#block _x_i1 in
        let o = o#exports _x_i2 in let o = o#unknown _x_i3 in o
    method number : number -> 'self_type = o#unknown
    method mutable_flag : mutable_flag -> 'self_type = o#unknown
    method length_object : length_object -> 'self_type = o#unknown
    method label : label -> 'self_type = o#string
    method kind : kind -> 'self_type = o#unknown
    method jsint : jsint -> 'self_type = o#unknown
    method int_op : int_op -> 'self_type = o#unknown
    method ident_info : ident_info -> 'self_type = o#unknown
    method ident : ident -> 'self_type = o#unknown
    method for_ident_expression : for_ident_expression -> 'self_type =
      o#expression
    method for_ident : for_ident -> 'self_type = o#ident
    method for_direction : for_direction -> 'self_type = o#unknown
    method finish_ident_expression : finish_ident_expression -> 'self_type =
      o#expression
    method expression_desc : expression_desc -> 'self_type =
      function
      | Math (_x, _x_i1) ->
          let o = o#string _x in
          let o = o#list (fun o -> o#expression) _x_i1 in o
      | Length (_x, _x_i1) ->
          let o = o#expression _x in let o = o#length_object _x_i1 in o
      | Char_of_int _x -> let o = o#expression _x in o
      | Char_to_int _x -> let o = o#expression _x in o
      | Is_null_undefined_to_boolean _x -> let o = o#expression _x in o
      | Array_of_size _x -> let o = o#expression _x in o
      | Array_copy _x -> let o = o#expression _x in o
      | Array_append (_x, _x_i1) ->
          let o = o#expression _x in let o = o#expression _x_i1 in o
      | String_append (_x, _x_i1) ->
          let o = o#expression _x in let o = o#expression _x_i1 in o
      | Int_of_boolean _x -> let o = o#expression _x in o
      | Anything_to_number _x -> let o = o#expression _x in o
      | Bool _x -> let o = o#bool _x in o
      | Typeof _x -> let o = o#expression _x in o
      | Caml_not _x -> let o = o#expression _x in o
      | Js_not _x -> let o = o#expression _x in o
      | String_of_small_int_array _x -> let o = o#expression _x in o
      | Json_stringify _x -> let o = o#expression _x in o
      | Anything_to_string _x -> let o = o#expression _x in o
      | Dump (_x, _x_i1) ->
          let o = o#unknown _x in
          let o = o#list (fun o -> o#expression) _x_i1 in o
      | Seq (_x, _x_i1) ->
          let o = o#expression _x in let o = o#expression _x_i1 in o
      | Cond (_x, _x_i1, _x_i2) ->
          let o = o#expression _x in
          let o = o#expression _x_i1 in let o = o#expression _x_i2 in o
      | Bin (_x, _x_i1, _x_i2) ->
          let o = o#binop _x in
          let o = o#expression _x_i1 in let o = o#expression _x_i2 in o
      | FlatCall (_x, _x_i1) ->
          let o = o#expression _x in let o = o#expression _x_i1 in o
      | Bind (_x, _x_i1) ->
          let o = o#expression _x in let o = o#expression _x_i1 in o
      | Call (_x, _x_i1, _x_i2) ->
          let o = o#expression _x in
          let o = o#list (fun o -> o#expression) _x_i1 in
          let o = o#unknown _x_i2 in o
      | String_access (_x, _x_i1) ->
          let o = o#expression _x in let o = o#expression _x_i1 in o
      | Access (_x, _x_i1) ->
          let o = o#expression _x in let o = o#expression _x_i1 in o
      | Dot (_x, _x_i1, _x_i2) ->
          let o = o#expression _x in
          let o = o#string _x_i1 in let o = o#bool _x_i2 in o
      | New (_x, _x_i1) ->
          let o = o#expression _x in
          let o = o#option (fun o -> o#list (fun o -> o#expression)) _x_i1
          in o
      | Var _x -> let o = o#vident _x in o
      | Fun (_x, _x_i1, _x_i2, _x_i3) ->
          let o = o#bool _x in
          let o = o#list (fun o -> o#ident) _x_i1 in
          let o = o#block _x_i2 in let o = o#unknown _x_i3 in o
      | Str (_x, _x_i1) -> let o = o#bool _x in let o = o#string _x_i1 in o
      | Unicode _x -> let o = o#string _x in o
      | Raw_js_code (_x, _x_i1) ->
          let o = o#string _x in let o = o#code_info _x_i1 in o
      | Array (_x, _x_i1) ->
          let o = o#list (fun o -> o#expression) _x in
          let o = o#mutable_flag _x_i1 in o
      | Caml_block (_x, _x_i1, _x_i2, _x_i3) ->
          let o = o#list (fun o -> o#expression) _x in
          let o = o#mutable_flag _x_i1 in
          let o = o#expression _x_i2 in let o = o#tag_info _x_i3 in o
      | Caml_uninitialized_obj (_x, _x_i1) ->
          let o = o#expression _x in let o = o#expression _x_i1 in o
      | Caml_block_tag _x -> let o = o#expression _x in o
      | Caml_block_set_tag (_x, _x_i1) ->
          let o = o#expression _x in let o = o#expression _x_i1 in o
      | Caml_block_set_length (_x, _x_i1) ->
          let o = o#expression _x in let o = o#expression _x_i1 in o
      | Number _x -> let o = o#number _x in o
      | Object _x -> let o = o#property_map _x in o
    method expression : expression -> 'self_type =
      fun { expression_desc = _x; comment = _x_i1 } ->
        let o = o#expression_desc _x in
        let o = o#option (fun o -> o#string) _x_i1 in o
    method exports : exports -> 'self_type = o#unknown
    method exception_ident : exception_ident -> 'self_type = o#ident
    method deps_program : deps_program -> 'self_type =
      fun { program = _x; modules = _x_i1; side_effect = _x_i2 } ->
        let o = o#program _x in
        let o = o#required_modules _x_i1 in
        let o = o#option (fun o -> o#string) _x_i2 in o
    method code_info : code_info -> 'self_type = o#unknown
    method case_clause :
      (* since in ocaml, it's expression oriented langauge, [return] in
    general has no jumps, it only happens when we do 
    tailcall conversion, in that case there is a jump.
    However, currently  a single [break] is good to cover
    our compilation strategy 

    Attention: we should not insert [break] arbitrarily, otherwise 
    it would break the semantics
    A more robust signature would be 
    {[ goto : label option ; ]}
  *)
        'a. ('self_type -> 'a -> 'self_type) -> 'a case_clause -> 'self_type =
      fun _f_a { case = _x; body = _x_i1 } ->
        let o = _f_a o _x in
        let o =
          (fun (_x, _x_i1) -> let o = o#block _x in let o = o#bool _x_i1 in o)
            _x_i1
        in o
    method block : block -> 'self_type = (* true means break *)
      (* TODO: For efficency: block should not be a list, it should be able to 
   be concatenated in both ways 
 *)
      o#list (fun o -> o#statement)
    method binop : binop -> 'self_type = o#unknown
    method unknown : 'a. 'a -> 'self_type = fun _ -> o
  end
  


end
module Js_analyzer : sig 
#1 "js_analyzer.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Analyzing utilities for [J] module *) 

(** for example, whether it has side effect or not.
*)

val free_variables_of_statement : 
  Ident_set.t -> Ident_set.t -> J.statement -> Ident_set.t

val free_variables_of_expression : 
  Ident_set.t -> Ident_set.t -> J.finish_ident_expression -> Ident_set.t

val no_side_effect_expression_desc :
  J.expression_desc -> bool   
val no_side_effect_expression : 
  J.expression -> bool
(** [no_side_effect] means this expression has no side effect, 
    but it might *depend on value store*, so you can not just move it around,

    for example,
    when you want to do a deep copy, the expression passed to you is pure
    but you still have to call the function to make a copy, 
    since it maybe changed later
*)

val no_side_effect_statement : 
  J.statement -> bool
(** 
    here we say 
   {[ var x = no_side_effect_expression ]}
    is [no side effect], but it is actually side effect, 
    since  we are defining a variable, however, if it is not exported or used, 
    then it's fine, so we delay this check later
*)

val eq_expression :
  J.expression -> J.expression -> bool

val eq_statement : 
  J.statement -> J.statement -> bool

val rev_flatten_seq : J.expression -> J.block 

val rev_toplevel_flatten : J.block -> J.block
(** return the block in reverse order *)

val is_constant : J.expression -> bool


(** Simple expression, 
    no computation involved so that  it is okay to be duplicated
*)

val is_simple_no_side_effect_expression 
  : J.expression -> bool
end = struct
#1 "js_analyzer.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)










(* Assume that functions already calculated closure correctly 
   Maybe in the future, we should add a dirty flag, to mark the calcuated 
   closure is correct or not

   Note such shaking is done in the toplevel, so that it requires us to 
   flatten the statement first 
*)
let free_variables used_idents defined_idents = 
  object (self)
    inherit Js_fold.fold as super
    val defined_idents = defined_idents
    val used_idents = used_idents 
    method! variable_declaration st = 
      match st with 
      | { ident; value = None}
        -> 
        {< defined_idents = Ident_set.add ident defined_idents >}
      | { ident; value = Some v}
        -> 
        {< defined_idents = Ident_set.add ident defined_idents >} # expression v
    method! ident id = 
      if Ident_set.mem id defined_idents then self
      else {<used_idents = Ident_set.add id used_idents >}
    method! expression exp = 

      match exp.expression_desc with
      | Fun(_, _,_, env)
        (** a optimization to avoid walking into funciton again
            if it's already comuted
        *)
        ->
        {< used_idents = 
             Ident_set.union (Js_fun_env.get_unbounded env) used_idents  >}

      | _
        ->
        super#expression exp

    method get_depenencies = 
      Ident_set.diff used_idents defined_idents
    method get_used_idents = used_idents
    method get_defined_idents = defined_idents 
  end 

let free_variables_of_statement used_idents defined_idents st = 
  ((free_variables used_idents defined_idents)#statement st) # get_depenencies

let free_variables_of_expression used_idents defined_idents st = 
  ((free_variables used_idents defined_idents)#expression st) # get_depenencies

let rec no_side_effect_expression_desc (x : J.expression_desc)  = 
  match x with 
  | Bool _ 
  | Var _ 
  | Unicode _ -> true 
  | Fun _ -> true
  | Number _ -> true (* Can be refined later *)
  | Access (a,b) -> no_side_effect a && no_side_effect b 
  | Is_null_undefined_to_boolean b -> no_side_effect b 
  | Str (b,_) -> b    
  | Array (xs,_mutable_flag)  
  | Caml_block (xs, _mutable_flag, _, _)
    ->
    (** create [immutable] block,
        does not really mean that this opreation itself is [pure].

        the block is mutable does not mean this operation is non-pure
    *)
    List.for_all no_side_effect  xs 
  | Bind(fn, obj) -> no_side_effect fn && no_side_effect obj
  | Object kvs -> 
    List.for_all (fun (_property_name, y) -> no_side_effect y ) kvs 
  | Array_append (a,b) 
  | String_append (a,b)
  | Seq (a,b) -> no_side_effect a && no_side_effect b 
  | Length (e, _)
  | Char_of_int e 
  | Char_to_int e 
  | Caml_block_tag e 
  | Typeof e
    -> no_side_effect e 
  | Bin (op, a, b) -> 
    op <> Eq && no_side_effect a && no_side_effect b     
  | Math _ 
  | Array_of_size _
  | Array_copy _ 
  (* | Tag_ml_obj _ *)
  | Int_of_boolean _ 
  | J.Anything_to_number _
  | Caml_not _ 
  | Js_not _
  | String_of_small_int_array _ 
  | Json_stringify _ 
  | Anything_to_string _ 
  | Dump _ 
  | Cond _ 

  | FlatCall _ 
  | Call _ 
  | Dot _ 
  | New _ 
  | Caml_uninitialized_obj _
  | String_access _
  | Raw_js_code _ 
  | Caml_block_set_tag _ 
  | Caml_block_set_length _ (* actually true? *)
    -> false 
and no_side_effect (x : J.expression)  = 
  no_side_effect_expression_desc x.expression_desc

let no_side_effect_expression (x : J.expression) = no_side_effect x 

let no_side_effect init = 
  object (self)
    inherit Js_fold.fold as super
    val no_side_effect = init
    method get_no_side_effect = no_side_effect

    method! statement s = 
      if not no_side_effect then self else 
        match s.statement_desc with 
        | Throw _ 
        | Debugger 
        | Break 
        | Variable _ 
        | Continue _ ->  
          {< no_side_effect = false>}
        | Exp e -> self#expression e 
        | Int_switch _ | String_switch _ | ForRange _ 
        | If _ | While _   | Block _ | Return _ | Try _  -> super#statement s 
    method! list f x = 
      if not self#get_no_side_effect then self else super#list f x 
    method! expression s = 
      if not no_side_effect then self
      else  {< no_side_effect = no_side_effect_expression s >}

    (** only expression would cause side effec *)
  end
let no_side_effect_statement st = ((no_side_effect true)#statement st)#get_no_side_effect

(* TODO: generate [fold2] 
   This make sense, for example:
   {[
     let string_of_formatting_gen : type a b c d e f .
       (a, b, c, d, e, f) formatting_gen -> string =
       fun formatting_gen -> match formatting_gen with
         | Open_tag (Format (_, str)) -> str
         | Open_box (Format (_, str)) -> str

   ]}
*)
let rec eq_expression 
    ({expression_desc = x0}  : J.expression) 
    ({expression_desc = y0}  : J.expression) = 
  begin match x0  with 
    | Number (Int i) -> 
      begin match y0 with  
        | Number (Int j)   -> i = j 
        | _ -> false 
      end
    | Number (Float i) -> 
      begin match y0 with 
        | Number (Float j) ->
          false (* conservative *)
        | _ -> false 
      end
    | Math  (name00,args00) -> 
      begin match y0 with 
        |Math(name10,args10) -> 
          name00 = name10 && eq_expression_list args00 args10 
        | _ -> false 
      end
    | Access (a0,a1) -> 
      begin match y0 with 
        | Access(b0,b1) -> 
          eq_expression a0 b0 && eq_expression a1 b1
        | _ -> false 
      end
    | Call (a0,args00,_) -> 
      begin match y0 with 
        | Call(b0,args10,_) ->
          eq_expression a0 b0 &&  eq_expression_list args00 args10
        | _ -> false 
      end 
    | Var (Id i) -> 
      begin match y0 with 
        | Var (Id j) ->
          Ident.same i j
        | _ -> false
      end
    | Bin (op0, a0,b0) -> 
      begin match y0 with 
        | Bin(op1,a1,b1) -> 
          op0 = op1 && eq_expression a0 a1 && eq_expression b0 b1
        | _ -> false 
      end 
    | Str(a0,b0) -> 
      begin match y0 with 
        | Str(a1,b1) -> a0 = a1  && b0 = b1
        | _ -> false 
      end     
    | Var (Qualified (id0,k0,opts0)) -> 
      begin match y0 with 
        | Var (Qualified (id1,k1,opts1)) ->
          Ident.same id0 id1 &&
          k0 = k1 &&
          opts0 = opts1
        | _ -> false
      end
    | Dot (e0,p0,b0) -> 
      begin match y0 with 
        | Dot(e1,p1,b1) -> 
          p0 = p1 && b0 =  b1 && eq_expression e0 e1
        |  _ -> false 
      end
    | Dump (l0,es0) -> 
      begin match y0 with 
        | Dump(l1,es1) -> 
          l0 = l1 && eq_expression_list es0 es1
        | _ -> false     
      end
    | Seq (a0,b0) -> 
      begin match y0 with       
        | Seq(a1,b1) -> 
          eq_expression a0 a1 && eq_expression b0 b1
        | _ -> false 
      end
    | Bool a0 -> 
      begin match y0 with 
        | Bool b0 -> a0 = b0
        | _ -> false 
      end
    | Length _ 
    | Char_of_int _
    | Char_to_int _ 
    | Is_null_undefined_to_boolean _ 
    | Array_of_size _
    | Array_copy _ 
    | Array_append _ 
    | String_append _ 
    | Int_of_boolean _ 
    | Anything_to_number _ 

    | Typeof _ 
    | Caml_not _
    | Js_not _ 
    | String_of_small_int_array _ 
    | Json_stringify _ 
    | Anything_to_string _ 


    | Cond _ 
    | FlatCall  _
    | Bind _ 
    | String_access _ 

    | New _ 
    | Fun _ 
    | Unicode _ 
    | Raw_js_code _
    | Array _ 
    | Caml_block _ 
    | Caml_uninitialized_obj _ 
    | Caml_block_tag _ 
    | Caml_block_set_tag _ 
    | Caml_block_set_length _ 
    | Object _ 
    | Number (Uint _ | Nint _)

      ->  false 
  end
and eq_expression_list xs ys =
  let rec aux xs ys =
    match xs,ys with
    | [], [] -> true
    | [], _  -> false 
    | _ , [] -> false
    | x::xs, y::ys -> eq_expression x y && aux xs ys 
  in
  aux xs ys
and eq_statement_list xs ys =
  let rec aux xs ys =
    match xs,ys with
    | [], [] -> true
    | [], _  -> false 
    | _ , [] -> false
    | x::xs, y::ys -> eq_statement x y && aux xs ys 
  in
  aux xs ys
and eq_statement 
    ({statement_desc = x0} : J.statement)
    ({statement_desc = y0} : J.statement) = 
  match x0  with 
  | Exp a -> 
    begin match y0 with 
      | Exp b -> eq_expression a b 
      | _ -> false
    end
  | Return { return_value = a ; _} -> 
    begin match y0 with 
      | Return { return_value = b; _} ->
        eq_expression a b
      | _ -> false 
    end
  | Debugger -> y0 = Debugger  
  | Break -> y0 = Break 
  | Block xs0 -> 
    begin match y0 with 
    | Block ys0 -> 
      eq_statement_list xs0 ys0
    | _ -> false 
  end
  | Variable _ 
  | If _ 
  | While _ 
  | ForRange _ 
  | Continue _ 
  
  | Int_switch _ 
  | String_switch _ 
  | Throw _ 
  | Try _ 
    -> 
    false 

let rev_flatten_seq (x : J.expression) = 
  let rec aux acc (x : J.expression) : J.block = 
    match x.expression_desc with
    | Seq(a,b) -> aux (aux acc a) b 
    | _ -> { statement_desc = Exp x; comment = None} :: acc in
  aux [] x 

(* TODO: optimization, 
    counter the number to know if needed do a loop gain instead of doing a diff 
*)

let rev_toplevel_flatten block = 
  let rec aux  acc (xs : J.block) : J.block  = 
    match xs with 
    | [] -> acc
    | {statement_desc =
         Variable (
           {ident_info = {used_stats = Dead_pure } ; _} 
         | {ident_info = {used_stats = Dead_non_pure}; value = None })
      } :: xs -> aux acc xs 
    | {statement_desc = Block b; _ } ::xs -> aux (aux acc b ) xs 

    | x :: xs -> aux (x :: acc) xs  in
  aux [] block

let rec is_constant (x : J.expression)  = 
  match x.expression_desc with 
  | Access (a,b) -> is_constant a && is_constant b 
  | Str (b,_) -> b
  | Number _ -> true (* Can be refined later *)
  | Array (xs,_mutable_flag)  -> List.for_all is_constant  xs 
  | Caml_block(xs, Immutable, tag, _) 
    -> List.for_all is_constant xs && is_constant tag 
  | Bin (op, a, b) -> 
    is_constant a && is_constant b     
  | _ -> false 


let rec is_simple_no_side_effect_expression (e : J.expression) = 
  match e.expression_desc with  
  | Var _ 
  | Bool _ 
  | Str _ 
  | Number _ -> true
  | Dot (e, (_ : string), _) -> is_simple_no_side_effect_expression e 
  | _ -> false 

end
module Js_op_util : sig 
#1 "js_op_util.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Some basic utilties around {!Js_op} module *)

val op_prec : Js_op.binop -> int * int * int

val op_str : Js_op.binop -> string

val op_int_prec : Js_op.int_op -> int * int * int

val op_int_str : Js_op.int_op -> string

val str_of_used_stats : Js_op.used_stats -> string

val update_used_stats : J.ident_info -> Js_op.used_stats -> unit

val same_vident : J.vident -> J.vident -> bool

val of_lam_mutable_flag : Asttypes.mutable_flag -> Js_op.mutable_flag 

end = struct
#1 "js_op_util.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)









(* Refer https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence
  for precedence   
*)

let op_prec (op : Js_op.binop ) =
  match op with
  | Eq -> 1, 13, 1
  | Or -> 3, 3, 3
  | And -> 4, 4, 4
  | EqEqEq | NotEqEq -> 8, 8, 9
  | Gt | Ge | Lt | Le | InstanceOf -> 9, 9, 10
  | Bor -> 5, 5, 5
  | Bxor -> 6, 6, 6
  | Band -> 7, 7, 7
  | Lsl | Lsr | Asr -> 10, 10, 11
  | Plus | Minus -> 11, 11, 12
  | Mul | Div | Mod -> 12, 12, 13

let op_int_prec (op : Js_op.int_op) = 
  match op with
  | Bor -> 5, 5, 5
  | Bxor -> 6, 6, 6
  | Band -> 7, 7, 7
  | Lsl | Lsr | Asr -> 10, 10, 11
  | Plus | Minus -> 11, 11, 12
  | Mul | Div | Mod -> 12, 12, 13


let op_str (op : Js_op.binop) =
  match op with
  | Bor     -> "|"
  | Bxor    -> "^"
  | Band    -> "&"
  | Lsl     -> "<<"
  | Lsr     -> ">>>"
  | Asr     -> ">>"
  | Plus    -> "+"
  | Minus   -> "-"
  | Mul     -> "*"
  | Div     -> "/"
  | Mod     -> "%"

  | Eq      -> "="
  | Or      -> "||"
  | And     -> "&&"
  | EqEqEq  -> "==="
  | NotEqEq -> "!=="
  | Lt      -> "<"
  | Le      -> "<="
  | Gt      -> ">"
  | Ge      -> ">="
  | InstanceOf -> "instanceof"

let op_int_str (op : Js_op.int_op) = 
  match op with
  | Bor     -> "|"
  | Bxor    -> "^"
  | Band    -> "&"
  | Lsl     -> "<<"
  | Lsr     -> ">>>"
  | Asr     -> ">>"
  | Plus    -> "+"
  | Minus   -> "-"
  | Mul     -> "*"
  | Div     -> "/"
  | Mod     -> "%"
  
let str_of_used_stats x = 
  match (x : Js_op.used_stats) with
  | Js_op.Dead_pure ->  "Dead_pure"
  | Dead_non_pure -> "Dead_non_pure"
  | Exported -> "Exported" 
  | Once_pure -> "Once_pure"
  | Used -> "Used"
  | Scanning_pure -> "Scanning_pure"
  | Scanning_non_pure -> "Scanning_non_pure"
  | NA -> "NA"

let update_used_stats (ident_info : J.ident_info) used_stats = 
  match ident_info.used_stats with 
  | Dead_pure | Dead_non_pure | Exported  -> ()
  | Scanning_pure 
  | Scanning_non_pure
  | Used
  | Once_pure
  | NA  -> 
    ident_info.used_stats <- used_stats

let same_kind (x : Js_op.kind) (y : Js_op.kind)  =
  match x , y with
  | Ml, Ml
  | Runtime, Runtime -> true
  | External (u : string), External v ->  u = v 
  | _, _ -> false

let same_str_opt ( x : string option  ) (y : string option) = 
  match x ,y with
  | None, None -> true
  | Some x0, Some y0 -> x0 = y0
  | None, Some _ 
  | Some _ , None 
    -> false 
  
let same_vident (x : J.vident) (y : J.vident) = 
  match x, y with 
  | Id x0, Id y0 -> Ident.same x0 y0
  | Qualified(x0,k0,str_opt0), Qualified(y0,k1,str_opt1) -> 
      Ident.same x0 y0 && same_kind k0 k1 && same_str_opt str_opt0 str_opt1
  | Id _, Qualified _ 
  | Qualified _, Id _ -> false

let of_lam_mutable_flag (x : Asttypes.mutable_flag)  : Js_op.mutable_flag = 
  match x with 
  | Immutable -> Immutable
  | Mutable -> Mutable

end
module Js_runtime_modules
= struct
#1 "js_runtime_modules.ml"
(* Copyright (C) 2017 Authors of BuckleScript
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

let builtin_exceptions = "Caml_builtin_exceptions"
let exceptions = "Caml_exceptions"
let io = "Caml_io"
let sys = "Caml_sys"
let lexer = "Caml_lexer"
let parser = "Caml_parser"
let obj_runtime = "Caml_obj"
let array = "Caml_array"
let format = "Caml_format"
let string = "Caml_string"
let bytes = "Caml_bytes"
let float = "Caml_float"
let hash = "Caml_hash"
let oo = "Caml_oo"
let curry = "Curry"
let caml_oo_curry = "Caml_oo_curry"
let int64 = "Caml_int64"
let md5 = "Caml_md5"
let weak = "Caml_weak"
let backtrace = "Caml_backtrace"
let gc = "Caml_gc"
let int32 = "Caml_int32"
let block = "Block"
let js_primitive = "Js_primitive"
let module_ = "Caml_module"
let missing_polyfill = "Caml_missing_polyfill"
let exn = "Js_exn"
end
module Lam_compile_util : sig 
#1 "lam_compile_util.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)









(** Some utilities for lambda compilation*)

val jsop_of_comp : Lambda.comparison -> Js_op.binop

val comment_of_tag_info : Lambda.tag_info -> string option

val comment_of_pointer_info : Lambda.pointer_info -> string option

end = struct
#1 "lam_compile_util.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)










let jsop_of_comp (cmp : Lambda.comparison) : Js_op.binop = 
  match cmp with 
  | Ceq -> EqEqEq (* comparison*)
  | Cneq -> NotEqEq
  | Clt -> Lt 
  | Cgt  -> Gt 
  | Cle -> Le 
  | Cge  -> Ge

let comment_of_tag_info  (x : Lambda.tag_info) = 
  match x with 
  | Blk_constructor (n, _) -> Some n 
  | Blk_tuple -> Some "tuple"
  | Blk_variant x -> Some ("`" ^  x)
  | Blk_record _ -> Some "record"

  | Blk_array -> Some "array"
  | Blk_module _ ->  
     (* Turn it on next time to save some noise diff*)
    Some "module"
  | Blk_exception -> Some "exception"
  | Blk_extension -> Some "extension"
  | Blk_na -> None 
let comment_of_pointer_info (x :  Lambda.pointer_info)= 
  match x with 
  | Pt_constructor x -> Some x 
  | Pt_variant x -> Some x 
  | Lambda.Pt_module_alias -> None (* FIXME *)
  | Pt_na -> None

end
module Js_exp_make : sig 
#1 "js_exp_make.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Creator utilities for the [J] module *) 






(** check if a javascript ast is constant 

    The better signature might be 
    {[
      J.expresssion -> Js_output.t
    ]}
    for exmaple
    {[
      e ?print_int(3) :  0
                         --->
                         if(e){print_int(3)}
    ]}
*)
type t = J.expression 
val extract_non_pure : t -> t option

type binary_op =   ?comment:string -> t -> t -> t 

type unary_op =  ?comment:string -> t -> t

(** simplify 
    {[if b then ]}
    there is no need to convert b into OCaml boolean under this scenario
*)
val ocaml_boolean_under_condition : t -> t 


(* val bin : ?comment:string -> J.binop -> t -> t -> t *)
val mk :
  ?comment:string -> J.expression_desc -> t

val access : binary_op

val string_access : binary_op

val var : ?comment:string  -> J.ident -> t 

val runtime_var_dot : ?comment:string -> string -> string -> t

val runtime_var_vid : string -> string -> J.vident

val ml_var_dot : ?comment:string -> Ident.t -> string -> t

val external_var_dot : ?comment:string ->  external_name:string -> ?dot:string -> Ident.t -> t



val ml_var : ?comment:string -> Ident.t -> t

val runtime_call : ?comment:string -> string -> string -> t list -> t
val public_method_call : string -> t -> t -> Int32.t -> t list -> t
val runtime_ref : string -> string -> t

val str : 
  ?pure:bool -> 
  ?comment:string -> 
  string -> 
  t 

val unicode : 
  ?comment:string -> 
  string -> 
  t
  
val ocaml_fun : ?comment:string ->
  ?immutable_mask:bool array -> J.ident list -> J.block -> t

val method_ : ?comment:string ->
  ?immutable_mask:bool array -> J.ident list -> J.block -> t

val econd : ?comment:string -> t -> t -> t -> t

val int : ?comment:string -> ?c:char ->  int32 -> t 
val nint : ?comment:string -> nativeint -> t 
val small_int : int -> t
val float : ?comment:string -> string -> t

val empty_string_literal : t 
(* TODO: we can do hash consing for small integers *)
val zero_int_literal : t
val one_int_literal : t
val zero_float_lit : t 
val obj_int_tag_literal : t

(** [is_out e range] is equivalent to [e > range or e <0]

*)
val is_out : binary_op
val dot : ?comment:string -> t -> string -> t

val array_length : unary_op

val string_length : unary_op

val string_of_small_int_array : unary_op

val bytes_length :  unary_op

val function_length : unary_op

val char_of_int : unary_op

val char_to_int : unary_op

val array_append : binary_op

val array_copy : unary_op
val string_append : binary_op
(**
   When in ES6 mode, we can use Symbol to guarantee its uniquess,
   we can not tag [js] object, since it can be frozen 
*)



val var_dot : ?comment:string -> Ident.t -> string -> t
val bind_var_call : ?comment:string -> Ident.t -> string -> t list -> t 
val bind_call : ?comment:string -> J.expression -> string -> J.expression list -> t
val js_global_dot : ?comment:string -> string -> string -> t

val index : ?comment:string -> t -> Int32.t -> t

(** if the expression is a temporay block which has no side effect,
    write to it does not really make sense, optimize it away *)
val index_addr : ?comment:string -> yes:(t -> t) -> no:t -> t -> Js_op.jsint -> t

val assign :  binary_op

val triple_equal : binary_op
(* TODO: reduce [triple_equal] use *)    

val float_equal : binary_op
val int_equal : binary_op
val string_equal : binary_op    
val is_type_number : unary_op
val typeof : unary_op

val to_int32 : unary_op
val to_uint32 : unary_op

val unchecked_int32_add : binary_op
val int32_add : binary_op
val unchecked_int32_minus : binary_op
val int32_minus : binary_op
val int32_mul : binary_op
val unchecked_int32_mul : binary_op

val int32_div : checked:bool -> binary_op
val int32_mod : checked:bool -> binary_op

val int32_lsl : binary_op
val int32_lsr : binary_op
val int32_asr : binary_op

val int32_bxor : binary_op
val int32_band : binary_op
val int32_bor : binary_op

val float_add : binary_op
val float_minus : binary_op
val float_mul : binary_op
val float_div : binary_op
val float_notequal : binary_op
val float_mod : binary_op  

val int_comp : Lambda.comparison -> binary_op
val string_comp : Js_op.binop -> binary_op
val float_comp :  Lambda.comparison -> binary_op
val js_comp :  Lambda.comparison -> binary_op


val not : t -> t

val call : ?comment:string  -> info:Js_call_info.t -> t -> t list -> t 

val flat_call : binary_op

val dump : ?comment:string -> Js_op.level -> t list -> t

val anything_to_string : unary_op

(** see {!https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Unary_plus}*)
val to_number : unary_op
val int_to_string : unary_op
val to_json_string : unary_op

val new_ : ?comment:string -> J.expression -> J.expression list -> t

val arr : ?comment:string -> J.mutable_flag -> J.expression list -> t

val make_block : 
  ?comment:string ->
  J.expression -> J.tag_info -> J.expression list -> J.mutable_flag -> t

val uninitialized_object : 
  ?comment:string -> J.expression -> J.expression -> t

val uninitialized_array : unary_op

val seq : binary_op
val fuse_to_seq : t -> t list -> t 

val obj : ?comment:string -> J.property_map -> t 

val caml_true : t 

val caml_false : t

val bool : bool -> t



val unit :   t
(** [unit] in ocaml will be compiled into [0]  in js *)

val js_var : ?comment:string -> string -> t

val js_global : ?comment:string -> string -> t

val undefined : t
val is_caml_block : ?comment:string -> t -> t
val math : ?comment:string -> string -> t list -> t
(** [math "abs"] --> Math["abs"] *)    





val tag : ?comment:string -> J.expression -> t
val set_tag : ?comment:string -> J.expression -> J.expression -> t

(** Note that this is coupled with how we encode block, if we use the 
    `Object.defineProperty(..)` since the array already hold the length,
    this should be a nop 
*)

val set_length : ?comment:string -> J.expression -> J.expression -> t
val obj_length : ?comment:string -> J.expression -> t
val bool_of_boolean : unary_op

val and_ : binary_op
val or_ : binary_op

(** we don't expose a general interface, since a general interface is generally not safe *)
val is_instance_array  : unary_op
(** used combined with [caml_update_dummy]*)
val dummy_obj : ?comment:string ->  unit -> t 

(** convert a block to expresion by using IIFE *)    
val of_block : ?comment:string -> ?e:J.expression -> J.statement list -> t

val bind : binary_op

val raw_js_code : ?comment:string -> J.code_info ->  string -> t

val nil : t 
val is_nil : unary_op

val js_bool :  ?comment:string -> bool -> t 
val is_undef : unary_op
val is_null_undefined : unary_op
val not_implemented : ?comment:string -> string -> t

end = struct
#1 "js_exp_make.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






let no_side_effect = Js_analyzer.no_side_effect_expression

type binary_op =   ?comment:string -> J.expression -> J.expression -> J.expression 
type unary_op =  ?comment:string -> J.expression -> J.expression
(*
  remove pure part of the expression
  and keep the non-pure part while preserve the semantics 
  (modulo return value)
 *)
let rec extract_non_pure (x : J.expression)  = 
  match x.expression_desc with 
  | Var _
  | Str _
  | Number _ -> None (* Can be refined later *)
  | Access (a,b) -> 
    begin match extract_non_pure a , extract_non_pure b with 
      | None, None -> None
      | _, _ -> Some x 
    end
  | Array (xs,_mutable_flag)  ->
    if List.for_all (fun x -> extract_non_pure x = None)  xs then
      None 
    else Some x 
  | Seq (a,b) -> 
    begin match extract_non_pure a , extract_non_pure b with 
      | None, None  ->  None
      | Some u, Some v ->  
        Some { x with expression_desc =  Seq(u,v)}
      (* may still have some simplification*)
      | None, (Some _ as v) ->  v
      | (Some _ as u), None -> u 
    end
  | _ -> Some x 

type t = J.expression 

let mk ?comment exp : t = 
  {expression_desc = exp ; comment  }

let var ?comment  id  : t = 
  {expression_desc = Var (Id id); comment }

let runtime_var_dot ?comment (x : string)  (e1 : string) : J.expression = 
  {expression_desc = 
     Var (Qualified(Ext_ident.create_js x,Runtime, Some e1)); comment }

let runtime_var_vid  x  e1 : J.vident = 
  Qualified(Ext_ident.create_js x,Runtime, Some e1)

let ml_var_dot ?comment ( id  : Ident.t) e : J.expression =     
  {expression_desc = Var (Qualified(id, Ml, Some e)); comment }

(** 
   module as a value 
   {[
     var http = require("http")
   ]}
*)
let external_var_dot ?comment  ~external_name:name ?dot (id : Ident.t) : t = 
  {expression_desc = Var (Qualified(id, External name,  dot)); comment }


let ml_var ?comment (id : Ident.t) : t  = 
  {expression_desc = Var (Qualified (id, Ml, None)); comment}

let str ?(pure=true)  ?comment s : t =  
  {expression_desc = Str (pure,s); comment}

let unicode ?comment s : t = 
  {expression_desc = Unicode (s); comment}

let raw_js_code ?comment info s : t =
  {expression_desc = Raw_js_code (s,info) ; comment }

let anything_to_string ?comment (e : t) : t =  
  match e.expression_desc with 
  | Str _ -> e 
  | _ -> {expression_desc = Anything_to_string e ; comment}

let arr ?comment mt es : t  = 
  {expression_desc = Array (es,mt) ; comment}

let sep = " : "
let merge_outer_comment comment (e : t )  = 
  match e.comment with
  | None -> {e with comment = Some comment}
  | Some s -> { e with 
                comment 
                = Some (comment ^ sep ^ s)} 

let make_block ?comment tag tag_info es mutable_flag : t = 
  let comment = 
    match comment with 
    | None -> Lam_compile_util.comment_of_tag_info tag_info 
    | _ -> comment in
  let es = 
    match tag_info with 
    | Blk_record des 
      when Array.length des <> 0 
      -> 
      List.mapi (fun i (e : t) -> merge_outer_comment des.(i) e) es
    (* TODO: may overriden its previous comments *)
    | Blk_module (Some des) 
      ->  List.map2  merge_outer_comment 
            des es
    | _ -> es 
  in
  {
    expression_desc = Caml_block( es, mutable_flag, tag,tag_info) ;
    comment 
  }    

let uninitialized_object ?comment tag size : t = 
  { expression_desc = Caml_uninitialized_obj(tag,size); comment }

let uninitialized_array ?comment (e : t) : t  = 
  match e.expression_desc with 
  | Number (Int {i = 0l; _}) -> arr ?comment NA []
  | _ -> {comment; expression_desc = Array_of_size e}


module L = Literals
(* Invariant: this is relevant to how we encode string
*)           
let typeof ?comment (e : t) : t = 
  match e.expression_desc with 
  | Number _ 
  | Length _ 
    -> str ?comment L.js_type_number
  | Str _ 
    -> str ?comment L.js_type_string
  | Array _
    -> str ?comment L.js_type_object
  | _ -> {expression_desc = Typeof e ; comment }




let new_ ?comment e0 args : t = 
  { expression_desc = New (e0,  Some args ); comment}


let unit   : t = 
  {expression_desc = Number (Int {i = 0l; c = None}) ; comment = Some "()" }



let math ?comment v args  : t = 
  {comment ; expression_desc = Math(v,args)}

(* we can do constant folding here, but need to make sure the result is consistent
   {[
     let f x = string_of_int x        
     ;; f 3            
   ]}     
   {[
     string_of_int 3
   ]}
*)
let int_to_string ?comment (e : t) : t = 
  anything_to_string ?comment e 

(* Attention: Shared *mutable state* is evil, [Js_fun_env.empty] is a mutable state ..
*)    

let ocaml_fun 
    ?comment  
    ?immutable_mask
    params block  : t = 
  let len = List.length params in
  {
    expression_desc = 
      Fun (false, params,block, Js_fun_env.empty ?immutable_mask len ); 
    comment
  }

let method_
    ?comment  
    ?immutable_mask
    params block  : t = 
  let len = List.length params in
  {
    expression_desc = 
      Fun (true, params,block, Js_fun_env.empty ?immutable_mask len ); 
    comment
  }

(** This is coupuled with {!Caml_obj.caml_update_dummy} *)
let dummy_obj ?comment ()  : t = 
  {comment  ; expression_desc = J.Array ([],Mutable)}

let is_instance_array ?comment e : t = 
  {comment; expression_desc = Bin(InstanceOf, e , str L.js_array_ctor) }

(* TODO: complete 
    pure ...
*)        
let rec seq ?comment (e0 : t) (e1 : t) : t = 
  match e0.expression_desc, e1.expression_desc with 
  | (Seq( a, {expression_desc = Number _ ;  })
    | Seq( {expression_desc = Number _ ;  },a)), _
    -> 
    seq ?comment a e1
  | _, ( Seq( {expression_desc = Number _ ;  }, a)) -> 
    (* Return value could not be changed*)
    seq ?comment e0 a
  | _, ( Seq(a,( {expression_desc = Number _ ;  } as v ) ))-> 
    (* Return value could not be changed*)
    seq ?comment (seq  e0 a) v

  | _ -> 
    {expression_desc = Seq(e0,e1); comment}

let fuse_to_seq x xs = 
  if xs = [] then x  
  else List.fold_left seq x xs 

let empty_string_literal : t = 
  {expression_desc = Str (true,""); comment = None}  

let zero_int_literal : t =   
  {expression_desc = Number (Int {i = 0l; c = None}) ; comment = None}
let one_int_literal : t = 
  {expression_desc = Number (Int {i = 1l; c = None}) ; comment = None}
let two_int_literal : t = 
  {expression_desc = Number (Int {i = 2l; c = None}) ; comment = None}
let three_int_literal : t = 
  {expression_desc = Number (Int {i = 3l; c = None}) ; comment = None}
let four_int_literal : t =   
  {expression_desc = Number (Int {i = 4l; c = None}) ; comment = None}
let five_int_literal : t = 
  {expression_desc = Number (Int {i = 5l; c = None}) ; comment = None}
let six_int_literal : t = 
  {expression_desc = Number (Int {i = 6l; c = None}) ; comment = None}
let seven_int_literal : t = 
  {expression_desc = Number (Int {i = 7l; c = None}) ; comment = None}
let eight_int_literal : t = 
  {expression_desc = Number (Int {i = 8l; c = None}) ; comment = None}
let nine_int_literal : t = 
  {expression_desc = Number (Int {i = 9l; c = None}) ; comment = None}

let obj_int_tag_literal : t =
  {expression_desc = Number (Int {i = 248l; c = None}) ; comment = None}

(* let small_int_array = Array.create 100  None *)


let int ?comment ?c  i : t = 
  {expression_desc = Number (Int {i; c}) ; comment}

let small_int i : t = 
  match i with 
  | 0 -> zero_int_literal
  | 1 -> one_int_literal
  | 2 -> two_int_literal
  | 3 -> three_int_literal
  | 4 -> four_int_literal
  | 5 -> five_int_literal
  | 6 -> six_int_literal
  | 7 -> seven_int_literal
  | 8 -> eight_int_literal
  | 9 -> nine_int_literal
  | 248 -> obj_int_tag_literal
  | i -> int (Int32.of_int i) 


let access ?comment (e0 : t)  (e1 : t) : t =
  match e0.expression_desc, e1.expression_desc with
  | Array (l,_mutable_flag) , Number (Int {i; _}) when no_side_effect e0-> 
    List.nth l  (Int32.to_int i)  (* Float i -- should not appear here *)
  | _ ->
    { expression_desc = Access (e0,e1); comment} 

let string_access ?comment (e0 : t)  (e1 : t) : t = 
  match e0.expression_desc, e1.expression_desc with
  | Str (_,s) , Number (Int {i; _}) 
    ->  (* Don't optimize {j||j} *)
    let i = Int32.to_int i  in
    if i >= 0 && i < String.length s then 
      (* TODO: check exception when i is out of range..
         RangeError?
      *)
      str (String.make 1 s.[i])
    else     { expression_desc = String_access (e0,e1); comment} 
  | _ ->
    { expression_desc = String_access (e0,e1); comment} 

let index ?comment (e0 : t)  e1 : t = 
  match e0.expression_desc with
  | Array (l,_mutable_flag)  when no_side_effect e0 -> 
    List.nth l  (Int32.to_int e1)  (* Float i -- should not appear here *)
  | Caml_block (l,_mutable_flag, _, _)  when no_side_effect e0 -> 
    List.nth l  (Int32.to_int e1)  (* Float i -- should not appear here *)
  | _ -> { expression_desc = Access (e0, int ?comment e1); comment = None} 


let index_addr ?comment ~yes ~no (e0 : t)  e1 : t = 
  match e0.expression_desc with
  | Array (l,_mutable_flag)  when no_side_effect e0 -> 
    no
  | Caml_block (l,_mutable_flag, _, _)  when no_side_effect e0 -> 
    no
  | _ ->
    yes ({ expression_desc = Access (e0, int ?comment e1); comment = None} : t) 

let call ?comment ~info e0 args : t = 
  {expression_desc = Call(e0,args,info); comment }

let flat_call ?comment e0 es : t = 
  (* TODO: optimization when es is known at compile time
      to be an array
  *)
  {expression_desc = FlatCall (e0,es); comment }

(* Dot .....................**)        
let runtime_call ?comment module_name fn_name args = 
  call ?comment 
    ~info:Js_call_info.builtin_runtime_call
    (runtime_var_dot  module_name fn_name) args

let runtime_ref module_name fn_name = 
  runtime_var_dot  module_name fn_name


(* only used in property access, 
    Invariant: it should not call an external module .. *)
let js_var ?comment  (v : string) =
  var ?comment (Ext_ident.create_js v )

let js_global ?comment  (v : string) =
  var ?comment (Ext_ident.create_js v )

(** used in normal property
    like [e.length], no dependency introduced
*)
let dot ?comment (e0 : t)  (e1 : string) : t = 
  { expression_desc = Dot (e0,  e1, true); comment} 


let undefined  = var Ext_ident.undefined


let nil = var Ext_ident.nil

(** coupled with the runtime *)
let is_caml_block ?comment (e : t) : t = 
  {expression_desc = Bin ( NotEqEq, dot e L.js_prop_length , undefined); 
   comment}

(* This is a property access not external module *)

let array_length ?comment (e : t) : t = 
  match e.expression_desc with 
  (* TODO: use array instead? *)
  | (Array (l, _) | Caml_block(l,_,_,_)) when no_side_effect e 
    -> int ?comment (Int32.of_int (List.length l))
  | _ -> { expression_desc = Length (e, Array) ; comment }

let string_length ?comment (e : t) : t =
  match e.expression_desc with 
  | Str(_,v) -> int ?comment (Int32.of_int (String.length v)) 
  (* No optimization for {j||j}*)
  | _ -> { expression_desc = Length (e, String) ; comment }

let bytes_length ?comment (e : t) : t = 
  match e.expression_desc with 
  (* TODO: use array instead? *)
  | Array (l, _) -> int ?comment (Int32.of_int (List.length l))
  | Str(_,v) -> int ?comment (Int32.of_int @@ String.length v)
  (* No optimization for unicode *)
  | _ -> { expression_desc = Length (e, Bytes) ; comment }

let function_length ?comment (e : t) : t = 
  match e.expression_desc with 
  | Fun(b, params, _, _) -> 
    let params_length = 
      List.length params in
    int ?comment 
      (Int32.of_int 
         (if b then params_length - 1 
          else params_length))
  (* TODO: optimize if [e] is know at compile time *)
  | _ -> { expression_desc = Length (e, Function) ; comment }

(** no dependency introduced *)
let js_global_dot ?comment (x : string)  (e1 : string) : t = 
  { expression_desc = Dot (js_var x,  e1, true); comment} 

let char_of_int ?comment (v : t) : t = 
  match v.expression_desc with
  | Number (Int {i; _}) ->
    str  (String.make 1(Char.chr (Int32.to_int i)))
  | Char_to_int v -> v 
  | _ ->  {comment ; expression_desc = Char_of_int v}

let char_to_int ?comment (v : t) : t = 
  match v.expression_desc with 
  | Str (_, x) -> (* No optimization for .. *)
    assert (String.length x = 1) ;
    int ~comment:(Printf.sprintf "%S"  x )  
      (Int32.of_int @@ Char.code x.[0])
  | Char_of_int v -> v 
  | _ -> {comment; expression_desc = Char_to_int v }

let array_append ?comment e el : t = 
  { comment ; expression_desc = Array_append (e, el)}

let array_copy ?comment e : t = 
  { comment ; expression_desc = Array_copy e}

(* Note that this return [undefined] in JS, 
    it should be wrapped to avoid leak [undefined] into 
    OCaml
*)    
let dump ?comment level el : t = 
  {comment ; expression_desc = Dump(level,el)}

let to_json_string ?comment e : t = 
  { comment; expression_desc = Json_stringify e }

let rec string_append ?comment (e : t) (el : t) : t = 
  match e.expression_desc , el.expression_desc  with 
  | Str(_,a), String_append ({expression_desc = Str(_,b)}, c) ->
    string_append ?comment (str (a ^ b)) c 
  | String_append (c,{expression_desc = Str(_,b)}), Str(_,a) ->
    string_append ?comment c (str (b ^ a))
  | String_append (a,{expression_desc = Str(_,b)}),
    String_append ({expression_desc = Str(_,c)} ,d) ->
    string_append ?comment (string_append a (str (b ^ c))) d 
  | Str (_,a), Str (_,b) -> str ?comment (a ^ b)
  | _, Anything_to_string b -> string_append ?comment e b 
  | Anything_to_string b, _ -> string_append ?comment b el
  | _, _ -> {comment ; expression_desc = String_append(e,el)}


let obj ?comment properties : t = 
  {expression_desc = Object properties; comment }

(* currently only in method call, no dependency introduced
*)
let var_dot ?comment (x : Ident.t)  (e1 : string) : t = 
  {expression_desc = Dot (var x,  e1, true); comment} 


let bind_call ?comment obj  (e1 : string) args  : t = 
  call ~info:Js_call_info.dummy {expression_desc = 
                                   Bind ({expression_desc = Dot (obj,  e1, true); comment} , obj);
                                 comment = None } args 

let bind_var_call ?comment (x : Ident.t)  (e1 : string) args  : t = 
  let obj =  var x in 
  call ~info:Js_call_info.dummy {expression_desc = 
                                   Bind ({expression_desc = Dot (obj,  e1, true); comment} , obj);
                                 comment = None } args 


(* Dot .....................**)        




let assign ?comment e0 e1 : t = {expression_desc = Bin(Eq, e0,e1); comment}


(** Convert a javascript boolean to ocaml boolean
    It's necessary for return value
     this should be optmized away for [if] ,[cond] to produce 
    more readable code
*)         
let bool_of_boolean ?comment (e : t) : t = 
  match e.expression_desc with 
  | Int_of_boolean _
  | Number _ -> e 
  | _ -> {comment ; expression_desc = Int_of_boolean e}

let to_number ?comment (e : t) : t = 
  match e.expression_desc with 
  | Int_of_boolean _
  | Anything_to_number _
  | Number _ -> e 
  | _ -> {comment ; expression_desc = Anything_to_number e}

let caml_true  = int ~comment:"true" 1l (* var (Jident.create_js "true") *)

let caml_false  = int ~comment:"false" 0l

let bool v = if  v then caml_true else caml_false

(** Here we have to use JS [===], and therefore, we are introducing 
    Js boolean, so be sure to convert it back to OCaml boolean
*)
let rec triple_equal ?comment (e0 : t) (e1 : t ) : t = 
  match e0.expression_desc, e1.expression_desc with
  | Var (Id ({name = "undefined"|"null"} as id)), 
    (Char_of_int _ | Char_to_int _ 
    | Bool _ | Number _ | Typeof _ | Int_of_boolean _ 
    | Fun _ | Array _ | Caml_block _ )
    when Ext_ident.is_js id && no_side_effect e1 -> 
    caml_false (* TODO: rename it as [caml_false] *)
  | 
    (Char_of_int _ | Char_to_int _ 
    | Bool _ | Number _ | Typeof _ | Int_of_boolean _ 
    | Fun _ | Array _ | Caml_block _ ),  Var (Id ({name = "undefined"|"null"; } as id))
    when Ext_ident.is_js id && no_side_effect e0 -> 
    caml_false
  | Str (_,x), Str (_,y) ->  (* CF*)
    bool (Ext_string.equal x y)
  | Char_to_int a , Char_to_int b -> 
    triple_equal ?comment a b 
  | Char_to_int a , Number (Int {i; c = Some v}) 
  | Number (Int {i; c = Some v}), Char_to_int a  -> 
    triple_equal ?comment a (str (String.make 1 v))
  | Number (Int {i = i0; _}), Number (Int {i = i1; _}) 
    -> 
    bool (i0 = i1)      
  | Char_of_int a , Char_of_int b -> 
    triple_equal ?comment a b 
  | _ -> 
    bool_of_boolean  {expression_desc = Bin(EqEqEq, e0,e1); comment}


(** Arith operators *)
(* Dot .....................**)        

let float ?comment f : t = 
  {expression_desc = Number (Float {f}); comment}

let zero_float_lit : t = 
  {expression_desc = Number (Float {f = "0." }); comment = None}


let float_mod ?comment e1 e2 : J.expression = 
  { comment ; 
    expression_desc = Bin (Mod, e1,e2)
  }

let bin ?comment (op : J.binop) e0 e1 : t =
  match op with
  | EqEqEq -> triple_equal ?comment e0 e1
  | _ -> {expression_desc = Bin(op,e0,e1); comment}

(* | (Bin (NotEqEq, e1,  *)
(*         {expression_desc = Var (Id ({name = "undefined"; _} as id))}) *)
(*   | Bin (NotEqEq,  *)
(*          {expression_desc = Var (Id ({name = "undefined"; _} as id))},  *)
(*          e1) *)
(*   ),  *)
(*   _ when Ext_ident.is_js id ->  *)
(*   and_ e1 e2 *)
(* TODO: Constant folding, Google Closure will do that?,
   Even if Google Clsoure can do that, we will see how it interact with other
   optimizations
   We wrap all boolean functions here, since OCaml boolean is a 
   bit different from Javascript, so that we can change it in the future
*)
let rec and_ ?comment (e1 : t) (e2 : t) : t = 
  match e1.expression_desc, e2.expression_desc with 
  |  Int_of_boolean e1 , Int_of_boolean e2 ->
    bool_of_boolean @@ and_ ?comment e1 e2

  (*
     {[ a && (b && c) === (a && b ) && c ]}
     is not used: benefit is not clear 
     | Int_of_boolean e10, Bin(And, {expression_desc = Int_of_boolean e20 }, e3) 
      -> 
      and_ ?comment 
        { e1 with expression_desc 
                  = 
                    J.Int_of_boolean { expression_desc = Bin (And, e10,e20); comment = None}
        }
        e3
  *)
  (* Note that 
     {[ "" && 3 ]}
     return  "" instead of false, so [e1] is indeed useful
  *)

  (* optimization if [e1 = e2], then and_ e1 e2 -> e2
     be careful for side effect        
  *)
  | Var i, Var j when Js_op_util.same_vident  i j 
    -> 
    e1
  | Var i, 
    (Bin (And,   {expression_desc = Var j ; _}, _) 
    | Bin (And ,  _, {expression_desc = Var j ; _}))
    when Js_op_util.same_vident  i j 
    ->
    e2          
  | _, _ ->     
    { expression_desc = Bin(And, e1,e2) ; comment }


let rec or_ ?comment (e1 : t) (e2 : t) = 
  match e1.expression_desc, e2.expression_desc with 
  | Int_of_boolean e1 , Int_of_boolean e2
    ->
    bool_of_boolean @@ or_ ?comment e1 e2
  | Var i, Var j when Js_op_util.same_vident  i j 
    -> 
    e1
  | Var i, 
    (Bin (Or,   {expression_desc = Var j ; _}, _) 
    | Bin (Or ,  _, {expression_desc = Var j ; _}))
    when Js_op_util.same_vident  i j 
    -> e2          
  | _, _ ->     
    {expression_desc = Bin(Or, e1,e2); comment }


(* return a value of type boolean *)
(* TODO: 
     when comparison with Int
     it is right that !(x > 3 ) -> x <= 3 *)
let rec not ({expression_desc; comment} as e : t) : t =
  match expression_desc with 
  | Number (Int {i; _}) -> 
    if i <> 0l then caml_false else caml_true
  | Int_of_boolean  x -> js_not  x  e
  | Caml_not e -> e
  | Js_not e -> e 
  (* match expression_desc with  *)
  (* can still hapen after some optimizations *)
  | Bin(EqEqEq , e0,e1) 
    -> {expression_desc = Bin(NotEqEq, e0,e1); comment}
  | Bin(NotEqEq , e0,e1) -> {expression_desc = Bin(EqEqEq, e0,e1); comment}
  | Bin(Lt, a, b) -> {e with expression_desc = Bin (Ge,a,b)}
  | Bin(Ge,a,b) -> {e with expression_desc = Bin (Lt,a,b)}
  | Bin(Le,a,b) -> {e with expression_desc = Bin (Gt,a,b)}
  | Bin(Gt,a,b) -> {e with expression_desc = Bin (Le,a,b)}
  | x -> {expression_desc = Caml_not e ; comment = None}
and js_not ({expression_desc; comment} as e : t) origin : t =
  match expression_desc with 
  | Bin(EqEqEq , e0,e1) 
    -> 
    bool_of_boolean {expression_desc = Bin(NotEqEq, e0,e1); comment}
  | Bin(NotEqEq , e0,e1) -> 
    bool_of_boolean {expression_desc = Bin(EqEqEq, e0,e1); comment}
  | Bin(Lt, a, b) -> 
    bool_of_boolean {e with expression_desc = Bin (Ge,a,b)}
  | Bin(Ge,a,b) -> 
    bool_of_boolean {e with expression_desc = Bin (Lt,a,b)}
  | Bin(Le,a,b) -> 
    bool_of_boolean {e with expression_desc = Bin (Gt,a,b)}
  | Bin(Gt,a,b) -> 
    bool_of_boolean {e with expression_desc = Bin (Le,a,b)}
  | _ -> {expression_desc = Caml_not origin; comment = None}

let rec ocaml_boolean_under_condition (b : t) =
  match b.expression_desc with 
  | Int_of_boolean b -> ocaml_boolean_under_condition b 
  | Bin (And, x,y) -> 
    let x' = ocaml_boolean_under_condition x in 
    let y' = ocaml_boolean_under_condition y in 
    if x == x' && y==y' then b 
    else {b with expression_desc = Bin(And,x',y')}
  | Bin(Or,x,y) ->
    let x' = ocaml_boolean_under_condition x in 
    let y' = ocaml_boolean_under_condition y in 
    if x == x' && y == y' then b 
    else {b with expression_desc = Bin(Or,x',y')}
  (** TODO: settle down Not semantics *)
  | Caml_not u
    -> 
    let u' = ocaml_boolean_under_condition u in 
    {b with expression_desc = Js_not u'}
  | Js_not u 
    -> 
    let u' = ocaml_boolean_under_condition u in 
    if u' == u then b 
    else {b with expression_desc = Js_not u'} 
  | _ -> b 

let rec econd ?comment (b : t) (t : t) (f : t) : t = 
  match b.expression_desc , t.expression_desc, f.expression_desc with

  | Number ((Int { i = 0l; _}) ), _, _ 
    -> f  (* TODO: constant folding: could be refined *)
  | (Number _ | Array _ | Caml_block _), _, _ when no_side_effect b 
    -> t  (* a block can not be false in OCAML, CF - relies on flow inference*)

  | Bool true, _, _ -> t 
  | Bool false,  _, _ -> f
  | (Bin (Bor, v , {expression_desc = Number (Int {i = 0l ; _})})), _, _
    -> econd v t f 
  (* TODO: could be more non undefined cases 
     check [caml_obj_is_block]
     acutally we should avoid introducing undefined
     as much as we can, this kind of inlining and mirco-optimization
     can be done after we can inline runtime in the future 
  *)
  (* | Bin (NotEqEq, ({expression_desc = Length _; _} as e1) , *)
  (*        {expression_desc = Var (Id ({name = "undefined"; _} as id))}), *)
  (*   _, _  *)
  (*   when Ext_ident.is_js id -> *)
  (*   econd e1 t f *)

  | ((Bin ((EqEqEq, {expression_desc = Number (Int { i = 0l; _}); _},x)) 
     | Bin (EqEqEq, x,{expression_desc = Number (Int { i = 0l; _});_}))), _, _ 
    -> 
    econd ?comment x f t 

  | (Bin (Ge, 
          ({expression_desc = Length _ ;
            _}), {expression_desc = Number (Int { i = 0l ; _})})), _, _ 
    -> f

  | (Bin (Gt, 
          ({expression_desc = Length _;
            _} as pred ), {expression_desc = Number (Int {i = 0l; })})), _, _
    ->
    (** Add comment when simplified *)
    econd ?comment pred t f 

  | _, (Cond (p1, branch_code0, branch_code1)), _
    when Js_analyzer.eq_expression branch_code1 f
    ->
    (* {[
         if b then (if p1 then branch_code0 else branch_code1)
         else branch_code1         
       ]}
       is equivalent to         
       {[
         if b && p1 then branch_code0 else branch_code1           
       ]}         
    *)      
    econd (and_ b p1) branch_code0 f
  | _, (Cond (p1, branch_code0, branch_code1)), _
    when Js_analyzer.eq_expression branch_code0 f
    ->
    (* the same as above except we revert the [cond] expression *)      
    econd (and_ b (not p1)) branch_code1 f

  | _, _, (Cond (p1', branch_code0, branch_code1))
    when Js_analyzer.eq_expression t branch_code0 
    (*
       {[
         if b then branch_code0 else (if p1' then branch_code0 else branch_code1)           
       ]}         
       is equivalent to         
       {[
         if b or p1' then branch_code0 else branch_code1           
       ]}         
    *)
    ->
    econd (or_ b p1') t branch_code1
  | _, _, (Cond (p1', branch_code0, branch_code1))
    when Js_analyzer.eq_expression t branch_code1
    ->
    (* the same as above except we revert the [cond] expression *)      
    econd (or_ b (not p1')) t branch_code0

  | Caml_not e, _, _ 
  | Js_not e, _, _ 
    ->
    econd ?comment e f t 
  | Int_of_boolean  b, _, _  -> econd ?comment  b t f
  (* | Bin (And ,{expression_desc = Int_of_boolean b0},b1), _, _  -> *)
  (*   econd ?comment { b with expression_desc = Bin (And , b0,b1)} t f *)
  | _ -> 
    let b  = ocaml_boolean_under_condition b in 
    (* if b' != b then *)
    (*   econd ?comment b' t f  *)
    (* else  *)
    if Js_analyzer.eq_expression t f then
      if no_side_effect b then t else seq  ?comment b t
    else
      {expression_desc = Cond(b,t,f); comment}


let rec float_equal ?comment (e0 : t) (e1 : t) : t = 
  match e0.expression_desc, e1.expression_desc with     
  | Number (Int {i = i0 ; _}), Number (Int {i = i1; }) -> 
    bool (i0 = i1)
  | (Bin(Bor, 
         {expression_desc = Number(Int {i = 0l; _})}, 
         ({expression_desc = Caml_block_tag _; _} as a ))
    |
      Bin(Bor, 
          ({expression_desc = Caml_block_tag _; _} as a),
          {expression_desc = Number (Int {i = 0l; _})})), 
    Number (Int {i = 0l; _})
    ->  (** (x.tag | 0) === 0  *)
    not  a     
  | (Bin(Bor, 
         {expression_desc = Number(Int {i = 0l; _})}, 
         ({expression_desc = Caml_block_tag _; _} as a ))
    |
      Bin(Bor, 
          ({expression_desc = Caml_block_tag _; _} as a),
          {expression_desc = Number (Int {i = 0l; _})}))
  , Number _  ->  (* for sure [i <> 0 ]*)
    (* since a is integer, if we guarantee there is no overflow 
       of a
       then [a | 0] is a nop unless a is undefined
       (which is applicable when applied to tag),
       obviously tag can not be overflowed. 
       if a is undefined, then [ a|0===0 ] is true 
       while [a === 0 ] is not true
       [a|0 === non_zero] is false and [a===non_zero] is false
       so we can not eliminate when the tag is zero          
    *)
    float_equal ?comment a e1
  | Number (Float {f = f0; _}), Number (Float {f = f1 ; }) when f0 = f1 -> 
    caml_true

  | Char_to_int a , Char_to_int b ->
    float_equal ?comment a b
  | Char_to_int a , Number (Int {i; c = Some v})
  | Number (Int {i; c = Some v}), Char_to_int a  ->
    float_equal ?comment a (str (String.make 1 v))
  | Char_of_int a , Char_of_int b ->
    float_equal ?comment a b

  | _ ->  
    bool_of_boolean {expression_desc = Bin(EqEqEq, e0,e1); comment}


let int_equal = float_equal 
let rec string_equal ?comment (e0 : t) (e1 : t) : t = 
  match e0.expression_desc, e1.expression_desc with     
  | Str (_, a0), Str(_, b0) 
    -> bool  (Ext_string.equal a0 b0)
  | Unicode a0, Unicode b0 -> bool (Ext_string.equal a0 b0)
  | _ , _ 
    ->
    bool_of_boolean {expression_desc = Bin(EqEqEq, e0,e1); comment}     


let is_type_number ?comment (e : t) : t = 
  string_equal ?comment (typeof e) (str "number")    


let string_of_small_int_array ?comment xs : t = 
  {expression_desc = String_of_small_int_array xs; comment}



(* we are calling [Caml_primitive.primitive_name], since it's under our
   control, we should make it follow the javascript name convention, and
   call plain [dot]
*)          

let null ?comment () =     
  js_global ?comment "null"

let tag ?comment e : t = 
  {expression_desc = 
     Bin (Bor, {expression_desc = Caml_block_tag e; comment }, zero_int_literal );
   comment = None }    


let bind ?comment fn obj  : t = 
  {expression_desc = Bind (fn, obj) ; comment }


(* according to the compiler, [Btype.hash_variant], 
   it's reduced to 31 bits for hash
*)

let public_method_call meth_name obj label cache args = 
  let len = List.length args in 
  (* econd (int_equal (tag obj ) obj_int_tag_literal) *)
  if len <= 7 then          
    runtime_call Js_runtime_modules.caml_oo_curry 
      ("js" ^ string_of_int (len + 1) )
      (label:: ( int cache) :: obj::args)
  else 
    runtime_call Js_runtime_modules.caml_oo_curry "js"
      [label; 
       int cache;
       obj ;  
       arr NA (obj::args)
      ]

(* TODO: handle arbitrary length of args .. 
   we can reduce part of the overhead by using
   `__js` -- a easy ppx {{ x ##.hh }} 
   the downside is that no way to swap ocaml/js implementation 
   for object part, also need encode arity..
   how about x#|getElementById|2|
*)
(* ( *)
(*   let fn = bind (dot obj meth_name) obj in *)
(*   if len = 0 then  *)
(*     dot obj meth_name *)
(*     (\* Note that when no args supplied,  *)
(*        it is not necessarily a function, [bind] *)
(*        is dangerous *)
(*        so if user write such code *)
(*        {[ *)
(*          let  u = x # say in *)
(*          u 3               *)
(*        ]}     *)
(*        It's reasonable to drop [this] support        *)
(*     *\) *)
(*   else if len <=8 then  *)
(*     let len_str = string_of_int len in *)
(*     runtime_call Js_config.curry (Literals.app ^len_str)  *)
(*       (fn ::  args) *)
(*   else  *)
(*     runtime_call Js_config.curry Literals.app_array            *)
(*       [fn  ; arr NA args ]             *)
(* ) *)

let set_tag ?comment e tag : t = 
  seq {expression_desc = Caml_block_set_tag (e,tag); comment } unit 


(* Note that [lsr] or [bor] are js semantics *)
let rec int32_bor ?comment (e1 : J.expression) (e2 : J.expression) : J.expression = 
  match e1.expression_desc, e2.expression_desc with 
  | Number (Int {i = i1} | Uint i1), Number (Int {i = i2})
    -> int ?comment (Int32.logor i1 i2)

  | _, (Bin(Lsr,e2, {expression_desc = Number(Int{i=0l} | Uint 0l | Nint 0n) ; _})) ->
    int32_bor  e1 e2
  | (Bin(Lsr,e1, {expression_desc = Number(Int{i=0l} | Uint 0l | Nint 0n) ; _})), _ ->
    int32_bor  e1 e2
  | (Bin(Lsr,_, {expression_desc = Number(Int{i} | Uint i ) ; _})),
    Number(Int{i=0l} | Uint 0l | Nint 0n)
    when i > 0l  -> (* a >>> 3 | 0 -> a >>> 3 *)
    e1

  | Bin (Bor, e1, {expression_desc = Number(Int{i=0l} | Uint 0l | Nint 0n) ; _} ), 
    Number(Int{i=0l} | Uint 0l | Nint 0n) ->
    int32_bor e1 e2  
  | _ -> 
    { comment ; 
      expression_desc = Bin (Bor, e1,e2)
    }

(* Arithmatic operations
   TODO: distinguish between int and float
   TODO: Note that we have to use Int64 to avoid integer overflow, this is fine
   since Js only have .

   like code below 
   {[
     MAX_INT_VALUE - (MAX_INT_VALUE - 100) + 20
   ]}

   {[
     MAX_INT_VALUE - x + 30
   ]}

   check: Re-association: avoid integer overflow
*) 
let  to_int32  ?comment (e : J.expression)  : J.expression = 
  int32_bor ?comment e zero_int_literal
(* TODO: if we already know the input is int32, [x|0] can be reduced into [x] *)
let nint ?comment n : J.expression =
  {expression_desc = Number (Nint n); comment }

let uint32 ?comment n : J.expression =
  {expression_desc = Number (Uint n); comment }



let string_comp cmp ?comment  e0 e1 = 
  bool_of_boolean @@ bin ?comment cmp e0 e1

let set_length ?comment e tag : t = 
  seq {expression_desc = Caml_block_set_length (e,tag); comment } unit 
let obj_length ?comment e : t = 
  to_int32 {expression_desc = Length (e, Caml_block); comment }

let rec int_comp (cmp : Lambda.comparison) ?comment  (e0 : t) (e1 : t) = 
  match cmp, e0.expression_desc, e1.expression_desc with
  | _, Call ({
      expression_desc = 
        Var (Qualified 
               (_, Runtime, 
                Some ("caml_int_compare" | "caml_int32_compare"))); _}, 
      [l;r], _), 
    Number (Int {i = 0l})
    -> int_comp cmp l r (* = 0 > 0 < 0 *)
  | Ceq, _, _ -> int_equal e0 e1 
  | _ ->          
    bool_of_boolean @@ bin ?comment (Lam_compile_util.jsop_of_comp cmp) e0 e1

let float_comp cmp ?comment  e0 e1 = 
  bool_of_boolean @@ bin ?comment (Lam_compile_util.jsop_of_comp cmp) e0 e1

let js_comp cmp ?comment  e0 e1 = 
  bool_of_boolean @@ bin ?comment (Lam_compile_util.jsop_of_comp cmp) e0 e1


let rec int32_lsr ?comment
    (e1 : J.expression) 
    (e2 : J.expression) : J.expression =
  let aux i1 i =
    uint32 (Int32.shift_right_logical i1 i) in    
  match e1.expression_desc, e2.expression_desc with
  | Number (Int { i = i1} | Uint i1 ), Number( Int {i = i2} | Uint i2)
    -> aux i1 (Int32.to_int i2)
  | Number (Nint i1), Number( Int {i = i2} | Uint i2)
    ->
    aux (Nativeint.to_int32 i1) (Int32.to_int i2)    
  | Number (Nint i1), Number (Nint i2)
    ->
    aux (Nativeint.to_int32 i1) (Nativeint.to_int i2)
  | (Bin(Lsr, _, _)), Number (Int {i = 0l} | Uint 0l | Nint 0n) 
    ->  e1 (* TODO: more opportunities here *)
  | Bin(Bor, e1, {expression_desc = Number (Int {i=0l;_} | Uint 0l | Nint 0n) ; _}),
    Number (Int {i = 0l} | Uint 0l | Nint 0n) 
    -> int32_lsr ?comment e1 e2
  | _, _ ->
    { comment ; 
      expression_desc = Bin (Lsr, e1,e2) (* uint32 *)
    }

let to_uint32 ?comment (e : J.expression)  : J.expression =
  int32_lsr ?comment e zero_int_literal


(* TODO: 
   we can apply a more general optimization here, 
   do some algebraic rewerite rules to rewrite [triple_equal]           
*)        
let rec is_out ?comment (e : t) (range : t) : t  = 
  begin match range.expression_desc, e.expression_desc with 

    | Number (Int {i = 1l}), Var _ 
      ->         
      not (or_ (triple_equal e zero_int_literal) (triple_equal e one_int_literal))                  
    | Number (Int {i = 1l}), 
      (
        Bin (Plus , {expression_desc = Number (Int {i ; _}) }, {expression_desc = Var _; _})
      | Bin (Plus, {expression_desc = Var _; _}, {expression_desc = Number (Int {i ; _}) }))

      ->
      not (or_ (triple_equal e (int (Int32.neg i ))) (triple_equal e (int (Int32.sub Int32.one  i))))        
    | Number (Int {i = 1l}), 
      Bin (Minus ,  ({expression_desc = Var _; _} as x), {expression_desc = Number (Int {i ; _}) })        
      ->           
      not (or_ (triple_equal x (int (Int32.add i  1l ))) (triple_equal x (int i)))        
    (* (x - i >>> 0 ) > k *)          
    | Number (Int {i = k}), 
      Bin (Minus ,  ({expression_desc = Var _; _} as x), 
           {expression_desc = Number (Int {i ; _}) })        
      ->           
      (or_ (int_comp Cgt x (int (Int32.add i  k)))  (int_comp Clt x  (int i)))
    | Number (Int {i = k}), Var _  
      -> 
      (* Note that js support [ 1 < x < 3], 
         we can optimize it into [ not ( 0<= x <=  k)]           
      *)        
      or_ (int_comp Cgt e (int ( k)))  (int_comp Clt e  zero_int_literal)

    | _, Bin (Bor ,
              ({expression_desc =
                  (Bin((Plus | Minus ) ,
                       {expression_desc = Number (Int {i ; _}) }, {expression_desc = Var _; _})
                  |Bin((Plus | Minus ) ,
                       {expression_desc = Var _; _}, {expression_desc = Number (Int {i ; _}) } ))
               } as e), {expression_desc = Number (Int {i=0l} | Uint 0l | Nint 0n); _})
      ->  
      (* TODO: check correctness *)
      is_out ?comment e range 
    | _, _ ->
      int_comp ?comment Cgt (to_uint32 e)  range 
  end

let rec float_add ?comment (e1 : t) (e2 : t) = 
  match e1.expression_desc, e2.expression_desc with 
  | Number (Int {i;_}), Number (Int {i = j;_}) -> 
    int ?comment (Int32.add i  j)
  | _, Number (Int {i = j; c}) when j < 0l -> 
    float_minus ?comment e1 
      {e2 with expression_desc = Number (Int {i = Int32.neg j; c})}       

  | Bin(Plus, a1 , ({expression_desc = Number (Int {i = k; _})}  )), 
    Number (Int { i =j; _}) -> 
    {comment ; expression_desc = Bin(Plus, a1,  (int (Int32.add k  j)))}
  (* bin ?comment Plus a1 (int (k + j)) *)

  (* TODO remove commented code  ?? *)
  (* | Bin(Plus, a0 , ({expression_desc = Number (Int a1)}  )), *)
  (*     Bin(Plus, b0 , ({expression_desc = Number (Int b1)}  )) *)
  (*   ->  *)
  (*   bin ?comment Plus a1 (int (a1 + b1)) *)

  (* | _, Bin(Plus,  b0, ({expression_desc = Number _}  as v)) *)
  (*   -> *)
  (*     bin ?comment Plus (bin ?comment Plus e1 b0) v *)
  (* | Bin(Plus, a1 , ({expression_desc = Number _}  as v)), _ *)
  (* | Bin(Plus, ({expression_desc = Number _}  as v),a1), _ *)
  (*   ->  *)
  (*     bin ?comment Plus (bin ?comment Plus a1 e2 ) v  *)
  (* | Number _, _ *)
  (*   ->  *)
  (*     bin ?comment Plus  e2 e1 *)
  | _ -> {comment ; expression_desc = Bin(Plus, e1,e2)}
(* bin ?comment Plus e1 e2 *)
(* associative is error prone due to overflow *)
and float_minus ?comment  (e1 : t) (e2 : t) : t = 
  match e1.expression_desc, e2.expression_desc with 
  | Number (Int {i;_}), Number (Int {i = j;_}) -> 
    int ?comment (Int32.sub i  j)
  | _ ->  {comment ; expression_desc = Bin(Minus, e1,e2)}
(* bin ?comment Minus e1 e2 *)



let unchecked_int32_add ?comment e1 e2 = 
  float_add ?comment e1 e2

let int32_add ?comment e1 e2 = 
  to_int32 @@ float_add ?comment e1 e2


let int32_minus ?comment e1 e2 : J.expression = 
  to_int32 @@  float_minus ?comment e1 e2

let unchecked_int32_minus ?comment e1 e2 : J.expression = 
  float_minus ?comment e1 e2



let float_div ?comment e1 e2 = 
  bin ?comment Div e1 e2 
let float_notequal ?comment e1 e2 = 
  bin ?comment NotEqEq e1 e2


let int32_asr ?comment e1 e2 : J.expression = 
  { comment ; 
    expression_desc = Bin (Asr, e1,e2)
  }

(** Division by zero is undefined behavior*)
let int32_div ~checked ?comment 
    (e1 : t) (e2 : t) : t = 
  match e1.expression_desc, e2.expression_desc with 
  | Length _ , Number (Int {i = 2l} | Uint 2l | Nint 2n)
    -> int32_asr e1 one_int_literal 
  | e1_desc , Number (Int {i = i1} ) when i1 <> 0l
    -> 
    begin match e1_desc with 
      | Number(Int {i = i0})
        -> 
        int (Int32.div i0 i1)
      | _ -> to_int32 (float_div ?comment e1 e2)
    end
  | _, _ -> 
    if checked  then 
      runtime_call Js_runtime_modules.int32 "div" [e1; e2]
    else to_int32 (float_div ?comment e1 e2)


let int32_mod ~checked ?comment e1 (e2 : t) : J.expression = 
  match e2.expression_desc with 
  | Number (Int {i }) when i <> 0l 
    -> 
    { comment ; 
      expression_desc = Bin (Mod, e1,e2)
    }

  | _ -> 
    if checked then 
      runtime_call Js_runtime_modules.int32 "mod_" [e1;e2]
    else 
      { comment ; 
        expression_desc = Bin (Mod, e1,e2)
      }


let float_mul ?comment e1 e2 = 
  bin ?comment Mul e1 e2 




let int32_lsl ?comment (e1 : J.expression) (e2 : J.expression) : J.expression = 
  match e1, e2  with 
  | {expression_desc = Number (Int {i = i0} | Uint i0)}, 
    {expression_desc = Number (Int {i = i1} | Uint i1)}
    -> int ?comment (Int32.shift_left i0 (Int32.to_int i1))
  | _ -> 
    { comment ; 
      expression_desc = Bin (Lsl, e1,e2)
    }


let int32_mul ?comment 
    (e1 : J.expression) 
    (e2 : J.expression) : J.expression = 
  match e1, e2 with 
  | {expression_desc = Number (Int {i = 0l}|  Uint 0l | Nint 0n); _}, x
  | x, {expression_desc = Number (Int {i = 0l}|  Uint 0l | Nint 0n); _} 
    when Js_analyzer.no_side_effect_expression x 
    -> zero_int_literal
  | {expression_desc = Number (Int{i = i0}); _}, {expression_desc = Number (Int {i = i1}); _}
    -> int (Int32.mul i0 i1)
  | e , {expression_desc = Number (Int {i = i0} | Uint i0 ); _}
  | {expression_desc = Number (Int {i = i0} | Uint i0 ); _}, e 
    -> 
    let i =  Ext_pervasives.is_pos_pow i0  in 
    if i >= 0 then 
      int32_lsl e (small_int i)
    else 
      runtime_call ?comment Js_runtime_modules.int32 Literals.imul [e1;e2]
  | _ -> 
    runtime_call ?comment Js_runtime_modules.int32 Literals.imul [e1;e2]

let unchecked_int32_mul ?comment e1 e2 : J.expression = 
  { comment ; 
    expression_desc = Bin (Mul, e1,e2)
  }



let rec int32_bxor ?comment (e1 : t) (e2 : t) : J.expression = 
  match e1.expression_desc, e2.expression_desc with 
  | Number (Int {i = i1}), Number (Int {i = i2})
    -> int ?comment (Int32.logxor i1 i2)
  | _, (Bin(Lsr,e2, {expression_desc = Number(Int{i=0l} | Uint 0l | Nint 0n) ; _})) ->
    int32_bxor  e1 e2
  | (Bin(Lsr,e1, {expression_desc = Number(Int{i=0l} | Uint 0l | Nint 0n) ; _})), _ ->
    int32_bxor  e1 e2

  | _ -> 
    { comment ; 
      expression_desc = Bin (Bxor, e1,e2)
    }

let rec int32_band ?comment (e1 : J.expression) (e2 : J.expression) : J.expression = 
  match e1.expression_desc with 
  | Bin (Bor ,a, {expression_desc = Number (Int {i = 0l})})
    -> 
    (* Note that in JS
       {[ -1 >>> 0 & 0xffffffff = -1]} is the same as 
       {[ (-1 >>> 0 | 0 ) & 0xffffff ]}
    *)
    int32_band a e2
  | _  ->
    { comment ; 
      expression_desc = Bin (Band, e1,e2)
    }


(* let int32_bin ?comment op e1 e2 : J.expression =  *)
(*   {expression_desc = Int32_bin(op,e1, e2); comment} *)


(* TODO -- alpha conversion 
    remember to add parens..
*)
let of_block ?comment ?e block : t = 
  call ~info:Js_call_info.ml_full_call
    {
      comment ;
      expression_desc = 
        Fun (false, [], 
             begin match e with 
               | None -> block 
               | Some e -> 
                 Ext_list.append block  
                   [{J.statement_desc = Return {return_value = e } ;
                     comment}]
             end
            , Js_fun_env.empty 0)
    } []

let is_nil ?comment x = triple_equal ?comment x nil 

let js_bool ?comment x : t = 
  { comment; 
    expression_desc = Bool x
  }

let is_undef ?comment x = triple_equal ?comment x undefined

let is_null_undefined ?comment (x: t) : t = 
  match x.expression_desc with 
  | Var (Id ({name = "undefined" | "null"} as id))
    when Ext_ident.is_js id 
    -> caml_true
  | Number _ | Array _ | Caml_block _ -> caml_false
  | _ -> 
    bool_of_boolean
      { comment ; 
        expression_desc = Is_null_undefined_to_boolean x 
      }
let not_implemented ?comment (s : string) : t =  
  runtime_call
    Js_runtime_modules.missing_polyfill
    "not_implemented" 
    [str (s ^ " not implemented by bucklescript yet\n")]

(* call ~info:Js_call_info.ml_full_call *)
(*   { *)
(*     comment ; *)
(*     expression_desc =  *)
(*       Fun (false,[], ( *)
(*           [{J.statement_desc = *)
(*               Throw (str ?comment  *)
(*                        (s ^ " not implemented by bucklescript yet\n")) ; *)
(*             comment}]) , *)
(*            Js_fun_env.empty 0) *)
(*   } [] *)



end
module Ident_map : sig 
#1 "ident_map.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

include Map_gen.S with type key = Ident.t
end = struct
#1 "ident_map.ml"

# 2 "ext/map.cppo.ml"
(* we don't create [map_poly], since some operations require raise an exception which carries [key] *)


  
# 16
  type key = Ident.t
  let compare_key = Ext_ident.compare

# 22
type 'a t = (key,'a) Map_gen.t
exception Duplicate_key of key 

let empty = Map_gen.empty 
let is_empty = Map_gen.is_empty
let iter = Map_gen.iter
let fold = Map_gen.fold
let for_all = Map_gen.for_all 
let exists = Map_gen.exists 
let singleton = Map_gen.singleton 
let cardinal = Map_gen.cardinal
let bindings = Map_gen.bindings
let keys = Map_gen.keys
let choose = Map_gen.choose 
let partition = Map_gen.partition 
let filter = Map_gen.filter 
let map = Map_gen.map 
let mapi = Map_gen.mapi
let bal = Map_gen.bal 
let height = Map_gen.height 
let max_binding_exn = Map_gen.max_binding_exn
let min_binding_exn = Map_gen.min_binding_exn


let rec add x data (tree : _ Map_gen.t as 'a) : 'a = match tree with 
  | Empty ->
    Node(Empty, x, data, Empty, 1)
  | Node(l, v, d, r, h) ->
    let c = compare_key x v in
    if c = 0 then
      Node(l, x, data, r, h)
    else if c < 0 then
      bal (add x data l) v d r
    else
      bal l v d (add x data r)


let rec adjust x data replace (tree : _ Map_gen.t as 'a) : 'a = 
  match tree with 
  | Empty ->
    Node(Empty, x, data (), Empty, 1)
  | Node(l, v, d, r, h) ->
    let c = compare_key x v in
    if c = 0 then
      Node(l, x, replace  d , r, h)
    else if c < 0 then
      bal (adjust x data replace l) v d r
    else
      bal l v d (adjust x data replace r)


let rec find_exn x (tree : _ Map_gen.t )  = match tree with 
  | Empty ->
    raise Not_found
  | Node(l, v, d, r, _) ->
    let c = compare_key x v in
    if c = 0 then d
    else find_exn x (if c < 0 then l else r)

let rec find_opt x (tree : _ Map_gen.t )  = match tree with 
  | Empty -> None 
  | Node(l, v, d, r, _) ->
    let c = compare_key x v in
    if c = 0 then Some d
    else find_opt x (if c < 0 then l else r)

let rec find_default x (tree : _ Map_gen.t ) default     = match tree with 
  | Empty -> default  
  | Node(l, v, d, r, _) ->
    let c = compare_key x v in
    if c = 0 then  d
    else find_default x   (if c < 0 then l else r) default

let rec mem x (tree : _ Map_gen.t )   = match tree with 
  | Empty ->
    false
  | Node(l, v, d, r, _) ->
    let c = compare_key x v in
    c = 0 || mem x (if c < 0 then l else r)

let rec remove x (tree : _ Map_gen.t as 'a) : 'a = match tree with 
  | Empty ->
    Empty
  | Node(l, v, d, r, h) ->
    let c = compare_key x v in
    if c = 0 then
      Map_gen.merge l r
    else if c < 0 then
      bal (remove x l) v d r
    else
      bal l v d (remove x r)


let rec split x (tree : _ Map_gen.t as 'a) : 'a * _ option * 'a  = match tree with 
  | Empty ->
    (Empty, None, Empty)
  | Node(l, v, d, r, _) ->
    let c = compare_key x v in
    if c = 0 then (l, Some d, r)
    else if c < 0 then
      let (ll, pres, rl) = split x l in (ll, pres, Map_gen.join rl v d r)
    else
      let (lr, pres, rr) = split x r in (Map_gen.join l v d lr, pres, rr)

let rec merge f (s1 : _ Map_gen.t) (s2  : _ Map_gen.t) : _ Map_gen.t =
  match (s1, s2) with
  | (Empty, Empty) -> Empty
  | (Node (l1, v1, d1, r1, h1), _) when h1 >= height s2 ->
    let (l2, d2, r2) = split v1 s2 in
    Map_gen.concat_or_join (merge f l1 l2) v1 (f v1 (Some d1) d2) (merge f r1 r2)
  | (_, Node (l2, v2, d2, r2, h2)) ->
    let (l1, d1, r1) = split v2 s1 in
    Map_gen.concat_or_join (merge f l1 l2) v2 (f v2 d1 (Some d2)) (merge f r1 r2)
  | _ ->
    assert false

let rec disjoint_merge  (s1 : _ Map_gen.t) (s2  : _ Map_gen.t) : _ Map_gen.t =
  match (s1, s2) with
  | (Empty, Empty) -> Empty
  | (Node (l1, v1, d1, r1, h1), _) when h1 >= height s2 ->
    begin match split v1 s2 with 
    | l2, None, r2 -> 
      Map_gen.join (disjoint_merge  l1 l2) v1 d1 (disjoint_merge r1 r2)
    | _, Some _, _ ->
      raise (Duplicate_key  v1)
    end        
  | (_, Node (l2, v2, d2, r2, h2)) ->
    begin match  split v2 s1 with 
    | (l1, None, r1) -> 
      Map_gen.join (disjoint_merge  l1 l2) v2 d2 (disjoint_merge  r1 r2)
    | (_, Some _, _) -> 
      raise (Duplicate_key v2)
    end
  | _ ->
    assert false



let compare cmp m1 m2 = Map_gen.compare compare_key cmp m1 m2

let equal cmp m1 m2 = Map_gen.equal compare_key cmp m1 m2 

let add_list (xs : _ list ) init = 
  List.fold_left (fun acc (k,v) -> add k v acc) init xs 

let of_list xs = add_list xs empty

let of_array xs = 
  Array.fold_left (fun acc (k,v) -> add k v acc) empty xs

end
module Lam_analysis : sig 
#1 "lam_analysis.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






(** A module which provides some basic analysis over lambda expression *)

(** No side effect, but it might depend on data store *)
val no_side_effects : Lam.t -> bool 

val size : Lam.t -> int

val ok_to_inline_fun_when_app : body:Lam.t -> Lam.ident list -> Lam.t list -> bool
  
val eq_lambda : Lam.t -> Lam.t -> bool 
(** a conservative version of comparing two lambdas, mostly 
    for looking for similar cases in switch
 *)

val small_inline_size : int  
val exit_inline_size : int  


val safe_to_inline : Lam.t -> bool

end = struct
#1 "lam_analysis.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)




(**used in effect analysis, it is sound but not-complete *)
let not_zero_constant ( x : Lam.constant) =  
  match x with 
  | Const_int i  -> i <> 0
  | Const_int32 i  -> i <> 0l
  | Const_int64 i  -> i <> 0L
  | Const_nativeint i -> i <> 0n
  | _ -> false 

let rec no_side_effects (lam : Lam.t) : bool = 
  match lam with 
  | Lvar _ 
  | Lconst _ 
  | Lfunction _ -> true
  | Lam.Lglobal_module _ -> true 
    (* we record side effect in the global level, 
      this expression itself is side effect free
    *)
  | Lprim {primitive;  args; _} -> 
    List.for_all no_side_effects args && 
    (
      match primitive with 
      | Pccall {prim_name ; _} ->
        begin 
          match prim_name,args with 
          | ("caml_register_named_value"
            (* register to c runtime does not make sense  in ocaml *)
            (* | "caml_set_oo_id"  *) (* it does have side effect, just in creation path it happens not to have *)
            | "caml_is_js"
            | "caml_int64_float_of_bits"
             (* more safe to check if arguments are constant *)
            (* non-observable side effect *)    
            | "caml_sys_get_config"
            | "caml_sys_get_argv" (* should be fine *)

            | "caml_create_string" (* TODO: add more *)
            | "caml_make_vect"
            | "caml_obj_dup"
            | "caml_obj_block"
            ), _  -> true 
          | "caml_ml_open_descriptor_in", [Lconst (  (Const_int 0))] -> true 
          | "caml_ml_open_descriptor_out", 
            [Lconst (  (Const_int (1|2))) ]
            -> true
          (* we can not mark it pure
             only when we guarantee this exception is caught...
           *)
          | _ , _-> false
        end 
      | Pmodint
      | Pdivint 
      | Pdivbint _
      | Pmodbint _ 
        -> begin match args with 
          | [_ ; Lconst cst ] -> not_zero_constant cst 
          | _ -> false 
        end
      
      | Pcreate_extension _
      (* | Pcreate_exception _ *)
      | Pjs_boolean_to_bool
      | Pjs_typeof
      | Pis_null
      | Pis_undefined
      | Pis_null_undefined
      | Pnull_to_opt       
      | Pundefined_to_opt         
      | Pnull_undefined_to_opt 
      | Pjs_fn_make _         
      | Pjs_object_create _
        (** TODO: check *)      
      | Pbytes_to_string 
      | Pbytes_of_string 
      | Pglobal_exception _
      | Pmakeblock _  (* whether it's mutable or not *)
      | Pfield _
      | Pfloatfield _ 
      | Pduprecord _ 
      (* Boolean operations *)
      | Psequand | Psequor | Pnot
      (* Integer operations *)
      | Pnegint | Paddint | Psubint | Pmulint 
     
      | Pandint | Porint | Pxorint
      | Plslint | Plsrint | Pasrint
      | Pintcomp _ 
      (* Float operations *)
      | Pintoffloat | Pfloatofint
      | Pnegfloat | Pabsfloat
      | Paddfloat | Psubfloat | Pmulfloat 
      | Pdivfloat
      | Pfloatcomp _ 
      | Pjscomp _
      (* String operations *)
      | Pstringlength 
      | Pstringrefu 
      | Pstringrefs
      | Pbyteslength
      | Pbytesrefu
      | Pbytesrefs
      | Pmakearray _ 
      | Parraylength _ 
      | Parrayrefu _
      | Parrayrefs _ 
      (* Test if the argument is a block or an immediate integer *)
      | Pisint
      (* Test if the (integer) argument is outside an interval *)
      | Pisout
      | Pbintofint _
      | Pintofbint _
      | Pcvtbint _
      | Pnegbint _
      | Paddbint _
      | Psubbint _
      | Pmulbint _
      | Pandbint _
      | Porbint _
      | Pxorbint _
      | Plslbint _
      | Plsrbint _
      | Pasrbint _
      | Pbintcomp _
      (* Operations on big arrays: (unsafe, #dimensions, kind, layout) *)
      | Pbigarrayref _ (* TODO it may raise an exception....*)
      (* Compile time constants *)
      | Pctconst _
      (* Integer to external pointer *)

      | Poffsetint _
      | Pstringadd 
      | Pjs_function_length
      | Pcaml_obj_length
      | Pjs_is_instance_array
      | Pwrap_exn
        -> true
      | Pjs_string_of_small_array
      | Pcaml_obj_set_length        
      | Pjs_apply
      | Pjs_runtime_apply
      | Pjs_call _ 
      | Pinit_mod
      | Pupdate_mod
      | Pjs_unsafe_downgrade _
      | Pdebugger 
      | Pjs_fn_run _ 
      | Pjs_fn_method _ | Pjs_fn_runmethod _
      (* TODO *)
      | Praw_js_code_exp _ 
      | Praw_js_code_stmt _
      | Pbytessetu 
      | Pbytessets
      (* Bitvect operations *)
      | Pbittest
      (* Operations on boxed integers (Nativeint.t, Int32.t, Int64.t) *)
      | Parraysets _
      | Pbigarrayset _
      (* size of the nth dimension of a big array *)
      | Pbigarraydim _
      (* load/set 16,32,64 bits from a string: (unsafe)*)
      | Pstring_load_16 _
      | Pstring_load_32 _
      | Pstring_load_64 _
      | Pstring_set_16 _
      | Pstring_set_32 _
      | Pstring_set_64 _
      (* load/set 16,32,64 bits from a
         (char, int8_unsigned_elt, c_layout) Bigarray.Array1.t : (unsafe) *)
      | Pbigstring_load_16 _
      | Pbigstring_load_32 _
      | Pbigstring_load_64 _
      | Pbigstring_set_16 _
      | Pbigstring_set_32 _
      | Pbigstring_set_64 _
      (* byte swap *)
      | Pbswap16
      | Pbbswap _
      | Parraysetu _ 
      | Poffsetref _ 
      | Praise
      | Plazyforce 
      | Psetfield _ 
      | Psetfloatfield _
      (* | Psetglobal _  *)
        -> false 
    )
  | Llet (_,_, arg,body) -> no_side_effects arg && no_side_effects body 
  | Lswitch (_,_) -> false 
  | Lstringswitch (_,_,_) -> false
  | Lstaticraise _ -> false
  | Lstaticcatch _ -> false 

  (* | "caml_sys_getenv" , [Lconst( (Const_string _))] *)
  (*         -> true *)
  (** not enough, we need know that 
      if it [Not_found], there are no other exceptions 
      can be thrown
  *)
  | Ltrywith (Lprim { primitive = Pccall{prim_name = "caml_sys_getenv"};
                    args = [Lconst _]; _},exn,
              Lifthenelse(Lprim{args =  
                                  [Lvar exn1; 
                                   Lprim {primitive = Pglobal_exception ({name="Not_found"}); args = []; _}]
                               ; _},
                          then_, _)) when Ident.same exn1 exn
    (** we might put this in an optimization pass 
        also make sure when we wrap this in [js] we 
        should follow the same patten, raise [Not_found] 
    *)
    -> no_side_effects then_
  (** It would be nice that we can also analysis some small functions 
      for example [String.contains], 
      [Format.make_queue_elem]
  *)
  | Ltrywith (body,exn,handler) 
    -> no_side_effects body && no_side_effects handler

  | Lifthenelse  (a,b,c) -> 
    no_side_effects a && no_side_effects b && no_side_effects c
  | Lsequence (a,b) -> no_side_effects a && no_side_effects b
  | Lletrec (bindings, body) ->
    List.for_all (fun (_,b) -> no_side_effects b) bindings && no_side_effects body
  | Lwhile _ -> false (* conservative here, non-terminating loop does have side effect *)
  | Lfor _ -> false 
  | Lassign _ -> false (* actually it depends ... *)
  | Lsend _ -> false 
  | Lifused _ -> false 
  | Lapply _ -> false (* we need purity analysis .. *)
  


(* 
    Estimate the size of lambda for better inlining 
    threshold is 1000 - so that we 
 *)
exception Too_big_to_inline

let really_big () = raise Too_big_to_inline

let big_lambda = 1000

let rec size (lam : Lam.t) = 
  try 
    match lam with 
    | Lvar _ ->  1
    | Lconst c -> size_constant c
    | Llet(_, _, l1, l2) -> 1 + size l1 + size l2 
    | Lletrec _ -> really_big ()
    | Lprim{primitive = Pfield _; 
            args =  [ Lglobal_module _]
           ;  _}
      -> 1
    | Lprim {primitive = Praise ; args =  [l ];  _} 
      -> size l
    | Lam.Lglobal_module _ -> 1       
    | Lprim {args = ll; _} -> size_lams 1 ll

    (** complicated 
        1. inline this function
        2. ...
        exports.Make=
        function(funarg)
        {var $$let=Make(funarg);
        return [0, $$let[5],... $$let[16]]}
     *)      
    | Lapply{ fn;
             args; _} -> size_lams (size fn) args
    (* | Lfunction(_, params, l) -> really_big () *)
    | Lfunction {body} -> size body 
    | Lswitch(_, _) -> really_big ()
    | Lstringswitch(_,_,_) -> really_big ()
    | Lstaticraise (i,ls) -> 
        List.fold_left (fun acc x -> size x + acc) 1 ls 
    | Lstaticcatch(l1, (i,x), l2) -> really_big () 
    | Ltrywith(l1, v, l2) -> really_big ()
    | Lifthenelse(l1, l2, l3) -> 1 + size  l1 + size  l2 +  size  l3
    | Lsequence(l1, l2) -> size  l1  +  size  l2
    | Lwhile(l1, l2) -> really_big ()
    | Lfor(flag, l1, l2, dir, l3) -> really_big () 
    | Lassign (_,v) -> 1 + size v  (* This is side effectful,  be careful *)
    | Lsend _  ->  really_big ()
    | Lifused(v, l) -> size l 
  with Too_big_to_inline ->  1000 
and size_constant x = 
  match x with 
  | Const_int _ | Const_char _ 
  | Const_string _  
  | Const_unicode _
  | Const_float _  | Const_int32 _ | Const_int64 _ 
  | Const_nativeint _ 
  | Const_immstring _
  | Const_pointer _ 
    -> 1 
  | Const_block (_, _, str) 
    ->  List.fold_left (fun acc x -> acc + size_constant x ) 0 str
  | Const_float_array xs  -> List.length xs

and size_lams acc (lams : Lam.t list) = 
  List.fold_left (fun acc l -> acc  + size l ) acc lams
let args_all_const args =
  List.for_all (fun x -> match x with Lam.Lconst _ -> true | _ -> false) args
    
let exit_inline_size = 7 
let small_inline_size = 5

(** destruct pattern will work better 
    if it is closed lambda, otherwise
    you can not do full evaluation

    We still should avoid inline too big code, 

    ideally we should also evaluate its size after inlining, 
    since after partial evaluation, it might still be *very big*
*)
let destruct_pattern (body : Lam.t) params args =
  let rec aux v params args =
    match params, args with
    | x::xs, b::bs ->
      if Ident.same x v then Some b
      else aux v xs bs
    | [] , _ -> None
    | x::xs, [] -> assert false                  
  in   
  match body with
  | Lswitch (Lvar v , switch)
    ->
    begin match aux v params args with
      | Some (Lam.Lconst _ as lam) ->
        size (Lam.switch lam switch) < small_inline_size
      | Some _ | None -> false
    end        
  | Lifthenelse(Lvar v, then_, else_)
    ->
    begin match aux v params args with
      | Some (Lconst _ as lam) ->
        size (Lam.if_ lam then_ else_) < small_inline_size
      | Some _ | None -> false          
    end      
  | _ -> false
    
(** Hints to inlining *)
let ok_to_inline_fun_when_app ~body params args =
  let s = size body in
  s < small_inline_size ||
  (destruct_pattern body params args) ||  
  (args_all_const args &&
   (s < 10 && no_side_effects body )) 


let eq_comparison ( p : Lam.comparison) (p1:Lam.comparison) = 
  match p with 
  | Cge -> p1 =  Cge
  | Cgt -> p1 =  Cgt
  | Cle -> p1 =  Cle
  | Clt -> p1 =  Clt 
  | Ceq -> p1 =  Ceq 
  | Cneq -> p1 =  Cneq 

let eq_array_kind (p : Lam.array_kind) (p1 : Lam.array_kind) = 
  match p with 
  | Pgenarray -> p1 = Pgenarray
  | Paddrarray -> p1 = Paddrarray 
  | Pintarray -> p1 = Pintarray
  | Pfloatarray -> p1 = Pfloatarray 

let eq_boxed_integer (p : Lam.boxed_integer) (p1 : Lam.boxed_integer ) = 
  match p with 
  | Pnativeint -> p1 = Pnativeint 
  | Pint32 -> p1 = Pint32
  | Pint64 -> p1 = Pint64

let eq_bigarray_kind (p : Lam.bigarray_kind) (p1 : Lam.bigarray_kind) = 
  match p with   
  | Pbigarray_unknown -> p1 = Pbigarray_unknown
  | Pbigarray_float32 -> p1 = Pbigarray_float32
  | Pbigarray_float64 -> p1 =  Pbigarray_float64
  | Pbigarray_sint8 -> p1 = Pbigarray_sint8
  | Pbigarray_uint8 -> p1 = Pbigarray_uint8
  | Pbigarray_sint16 -> p1 = Pbigarray_sint16 
  | Pbigarray_uint16 -> p1 = Pbigarray_uint16
  | Pbigarray_int32  -> p1 = Pbigarray_int32
  | Pbigarray_int64 -> p1 = Pbigarray_int64
  | Pbigarray_caml_int -> p1 = Pbigarray_caml_int
  | Pbigarray_native_int -> p1 = Pbigarray_native_int
  | Pbigarray_complex32  -> p1 = Pbigarray_complex32
  | Pbigarray_complex64 -> p1 = Pbigarray_complex64

let eq_bigarray_layout (p : Lam.bigarray_layout) (p1 : Lam.bigarray_layout) = 
  match p with 
  | Pbigarray_unknown_layout -> p1 = Pbigarray_unknown_layout
  | Pbigarray_c_layout -> p1 = Pbigarray_c_layout
  | Pbigarray_fortran_layout -> p1 = Pbigarray_fortran_layout

let eq_compile_time_constant ( p : Lam.compile_time_constant) (p1 : Lam.compile_time_constant) = 
  match p with 
  | Big_endian -> p1 = Big_endian
  | Word_size -> p1 = Word_size 
  | Ostype_unix -> p1 = Ostype_unix
  | Ostype_win32 -> p1 = Ostype_win32
  | Ostype_cygwin -> p1 = Ostype_cygwin 

let eq_record_representation ( p : Types.record_representation) ( p1 : Types.record_representation) = 
  match p with 
  | Record_float -> p1 = Record_float
  | Record_regular -> p1 = Record_regular
(* compared two lambdas in case analysis, note that we only compare some small lambdas
    Actually this patten is quite common in GADT, people have to write duplicated code 
    due to the type system restriction
*)
let rec 
  eq_lambda (l1 : Lam.t) (l2 : Lam.t) =
  match l1 with 
  | Lglobal_module i1 -> 
    begin match l2 with  Lglobal_module i2 -> Ident.same i1  i2  | _ -> false end
  | Lvar i1 -> 
    begin match l2 with  Lvar i2 ->  Ident.same i1 i2 | _ -> false end 
  | Lconst c1 -> 
    begin match l2 with  Lconst c2 -> c1 = c2 (* FIXME *) | _ -> false end 
  | Lapply {fn = l1; args = args1; _} -> 
    begin match l2 with Lapply {fn = l2; args = args2; _} ->
    eq_lambda l1 l2  && Ext_list.for_all2_no_exn eq_lambda args1 args2
    |_ -> false end 
  | Lifthenelse (a,b,c) -> 
    begin match l2 with  Lifthenelse (a0,b0,c0) ->
    eq_lambda a a0 && eq_lambda b b0 && eq_lambda c c0
    | _ -> false end 
  | Lsequence (a,b) -> 
    begin match l2 with Lsequence (a0,b0) ->
    eq_lambda a a0 && eq_lambda b b0
    | _ -> false end 
  | Lwhile (p,b) -> 
    begin match l2 with  Lwhile (p0,b0) -> eq_lambda p p0 && eq_lambda b b0
    | _ -> false end   
  | Lassign(v0,l0) -> 
    begin match l2 with  Lassign(v1,l1) -> Ident.same v0 v1 && eq_lambda l0 l1
    | _ -> false end 
  | Lstaticraise(id,ls) -> 
    begin match l2 with  Lstaticraise(id1,ls1) -> 
    (id : int) = id1 && Ext_list.for_all2_no_exn eq_lambda ls ls1 
    | _ -> false end 
  | Lprim {primitive = p; args = ls; } -> 
    begin match l2 with 
    Lprim {primitive = p1; args = ls1} ->
    eq_primitive p p1 && Ext_list.for_all2_no_exn eq_lambda ls ls1
    | _ -> false end 
  | Lfunction _  
  | Llet (_,_,_,_)
  | Lletrec _
  | Lswitch _ 
  | Lstringswitch _ 
  | Lstaticcatch _ 
  | Ltrywith _ 
  | Lfor (_,_,_,_,_) 
  | Lsend _
  | Lifused _ -> false    

  
and eq_primitive ( lhs : Lam.primitive) (rhs : Lam.primitive) = 
  match lhs with 
  | Pcreate_extension a -> begin match rhs with Pcreate_extension b -> a = (b : string) | _ -> false end
  (* | Pcreate_exception a -> begin match rhs with Pcreate_exception b -> a = (b : string) | _ -> false end *)
  | Pwrap_exn -> rhs = Pwrap_exn
  | Pbytes_to_string ->  rhs = Pbytes_to_string 
  | Pbytes_of_string ->  rhs = Pbytes_of_string
  | Praise -> rhs = Praise
  | Psequand -> rhs = Psequand
  | Psequor -> rhs = Psequor 
  | Pnot -> rhs = Pnot 
  | Pnegint -> rhs = Pnegint
  | Paddint -> rhs = Paddint 
  | Psubint -> rhs = Psubint
  | Pmulint -> rhs = Pmulint
  | Pdivint -> rhs = Pdivint
  | Pmodint -> rhs = Pmodint 
  | Pandint -> rhs = Pandint
  | Porint  -> rhs = Porint
  | Pxorint -> rhs = Pxorint
  | Plslint -> rhs = Plslint
  | Plsrint -> rhs = Plsrint
  | Pasrint -> rhs = Pasrint      
  | Plazyforce -> rhs = Plazyforce
  | Pintoffloat -> rhs = Pintoffloat
  | Pfloatofint -> rhs = Pfloatofint
  | Pnegfloat -> rhs =  Pnegfloat
  | Pabsfloat -> rhs = Pabsfloat
  | Paddfloat -> rhs = Paddfloat
  | Psubfloat -> rhs = Psubfloat
  | Pmulfloat -> rhs = Pmulfloat
  | Pdivfloat -> rhs = Pdivfloat
  | Pjs_apply -> rhs = Pjs_apply
  | Pjs_runtime_apply -> rhs = Pjs_runtime_apply
  | Pstringlength ->  rhs = Pstringlength
  | Pstringrefu ->  rhs = Pstringrefu
  | Pstringrefs ->  rhs = Pstringrefs
  | Pstringadd  ->  rhs = Pstringadd   
  | Pbyteslength -> rhs = Pbyteslength
  | Pbytesrefu ->   rhs = Pbytesrefu
  | Pbytessetu ->   rhs = Pbytessetu
  | Pbytesrefs ->   rhs = Pbytesrefs
  | Pbytessets ->   rhs = Pbytessets  
  | Pundefined_to_opt -> rhs = Pundefined_to_opt
  | Pnull_to_opt -> rhs = Pnull_to_opt
  | Pnull_undefined_to_opt -> rhs = Pnull_undefined_to_opt  
  | Pis_null -> rhs = Pis_null
  | Pis_undefined -> rhs = Pis_undefined
  | Pis_null_undefined -> rhs = Pis_null_undefined
  | Pjs_boolean_to_bool -> rhs = Pjs_boolean_to_bool
  | Pjs_typeof -> rhs = Pjs_typeof
  | Pisint -> rhs = Pisint
  | Pisout -> rhs = Pisout
  | Pbittest -> rhs = Pbittest
  | Pdebugger -> rhs = Pdebugger    
  | Pinit_mod -> rhs = Pinit_mod
  | Pupdate_mod -> rhs = Pupdate_mod
  | Pbswap16 -> rhs = Pbswap16
  | Pjs_function_length -> rhs = Pjs_function_length
  | Pjs_string_of_small_array -> rhs = Pjs_string_of_small_array
  | Pjs_is_instance_array -> rhs = Pjs_is_instance_array
  | Pcaml_obj_length -> rhs = Pcaml_obj_length
  | Pcaml_obj_set_length -> rhs = Pcaml_obj_set_length
  | Pccall {prim_name = n0 ;  prim_native_name = nn0} ->  (match rhs with Pccall {prim_name = n1; prim_native_name = nn1} ->    n0 = n1 && nn0 = nn1 | _ -> false )    
  | Pfield (n0, _dbg_info0) ->  (match rhs with Pfield (n1, _dbg_info1) ->  n0 = n1  | _ -> false )    
  | Psetfield(i0, b0, _dbg_info0) -> (match rhs with Psetfield(i1, b1, _dbg_info1) ->  i0 = i1 && b0 = b1 | _ -> false)
  | Pglobal_exception ident -> (match rhs with Pglobal_exception ident2 ->  Ident.same ident ident2 | _ -> false )
  | Pmakeblock (i, _tag_info, mutable_flag) -> (match rhs with Pmakeblock(i1,_,mutable_flag1) ->  i = i1 && mutable_flag = mutable_flag1  | _ -> false)
  | Pfloatfield (i0,_dbg_info) -> (match rhs with Pfloatfield (i1,_) -> i0 = i1   | _ -> false)
  | Psetfloatfield (i0,_dbg_info) ->  (match rhs with Psetfloatfield(i1,_) -> i0 = i1  | _ -> false)
  | Pduprecord (record_repesentation0,i1) -> (match rhs with Pduprecord(record_repesentation1,i2) ->  eq_record_representation record_repesentation0 record_repesentation1 && i1 = i2    | _ -> false)
  | Pjs_call (prim_name, arg_types, ffi) ->  ( match rhs with Pjs_call(prim_name1, arg_types1,ffi1) -> prim_name = prim_name1 && arg_types = arg_types1 && ffi = ffi1 | _ -> false)
  | Pjs_object_create obj_create -> (match rhs with Pjs_object_create obj_create1 -> obj_create = obj_create1 | _ -> false )
  | Pintcomp comparison -> (match rhs with Pintcomp comparison1 -> eq_comparison comparison  comparison1  | _ -> false )    
  | Pfloatcomp comparison -> (match rhs with Pfloatcomp comparison1 -> eq_comparison comparison  comparison1 | _ -> false)
  | Pjscomp comparison ->  (match rhs with  Pjscomp comparison1 -> eq_comparison comparison  comparison1  | _ -> false )    
  | Poffsetint i0 ->   (match rhs with  Poffsetint i1 -> i0 = i1 | _ -> false )   
  | Poffsetref i0 ->  (match rhs with Poffsetref i1 -> i0 = i1   | _ -> false)
  | Pmakearray array_kind -> (match rhs with Pmakearray array_kind1 -> eq_array_kind array_kind array_kind1 | _ -> false  )
  | Parraylength  array_kind -> (match rhs with Parraylength array_kind1 -> eq_array_kind array_kind array_kind1 | _ -> false  )
  | Parrayrefu  array_kind -> (match rhs with Parrayrefu array_kind1 -> eq_array_kind array_kind array_kind1 | _ -> false  )
  | Parraysetu  array_kind -> (match rhs with Parraysetu array_kind1 -> eq_array_kind array_kind array_kind1 | _ -> false  ) 
  | Parrayrefs array_kind -> (match rhs with Parrayrefs array_kind1 -> eq_array_kind array_kind array_kind1 | _ -> false  )
  | Parraysets  array_kind -> (match rhs with Parraysets array_kind1 -> eq_array_kind array_kind array_kind1 | _ -> false  )  
  | Pbintofint  boxed_integer -> (match rhs with Pbintofint boxed_integer1 -> eq_boxed_integer boxed_integer boxed_integer1 | _ -> false )
  | Pintofbint  boxed_integer -> (match rhs with Pintofbint boxed_integer1 -> eq_boxed_integer boxed_integer boxed_integer1 | _ -> false )
  | Pnegbint  boxed_integer -> (match rhs with Pnegbint boxed_integer1 -> eq_boxed_integer boxed_integer boxed_integer1 | _ -> false )
  | Paddbint  boxed_integer -> (match rhs with Paddbint boxed_integer1 -> eq_boxed_integer boxed_integer boxed_integer1 | _ -> false )
  | Psubbint  boxed_integer -> (match rhs with Psubbint boxed_integer1 -> eq_boxed_integer boxed_integer boxed_integer1 | _ -> false )
  | Pmulbint  boxed_integer -> (match rhs with Pmulbint boxed_integer1 -> eq_boxed_integer boxed_integer boxed_integer1 | _ -> false )
  | Pdivbint  boxed_integer -> (match rhs with Pdivbint boxed_integer1 -> eq_boxed_integer boxed_integer boxed_integer1 | _ -> false )
  | Pmodbint  boxed_integer -> (match rhs with Pmodbint boxed_integer1 -> eq_boxed_integer boxed_integer boxed_integer1 | _ -> false )
  | Pandbint  boxed_integer -> (match rhs with Pandbint boxed_integer1 -> eq_boxed_integer boxed_integer boxed_integer1 | _ -> false )
  | Porbint boxed_integer ->   (match rhs with Porbint  boxed_integer1 -> eq_boxed_integer boxed_integer boxed_integer1 | _ -> false )
  | Pxorbint  boxed_integer -> (match rhs with Pxorbint boxed_integer1 -> eq_boxed_integer boxed_integer boxed_integer1 | _ -> false )
  | Plslbint  boxed_integer -> (match rhs with Plslbint boxed_integer1 -> eq_boxed_integer boxed_integer boxed_integer1 | _ -> false )
  | Plsrbint  boxed_integer -> (match rhs with Plsrbint boxed_integer1 -> eq_boxed_integer boxed_integer boxed_integer1 | _ -> false )
  | Pasrbint  boxed_integer -> (match rhs with Pasrbint boxed_integer1 -> eq_boxed_integer boxed_integer boxed_integer1 | _ -> false )
  | Pbbswap boxed_integer ->   (match rhs with Pbbswap boxed_integer1  -> eq_boxed_integer boxed_integer boxed_integer1 | _ -> false )
  | Pcvtbint  (boxed_integer, boxed_integer1) -> (match rhs with Pcvtbint (boxed_integer10, boxed_integer11) -> eq_boxed_integer boxed_integer boxed_integer10 && eq_boxed_integer boxed_integer1 boxed_integer11 | _ -> false )
  | Pbintcomp  (boxed_integer , comparison) -> (match rhs with Pbintcomp(boxed_integer1, comparison1) -> eq_boxed_integer boxed_integer boxed_integer1 && eq_comparison comparison comparison1 | _ -> false)  
  | Pbigarraydim dim -> (match rhs with Pbigarraydim dim1 -> dim = dim1 | _ -> false )
  | Pstring_load_16 str ->  (match  rhs with Pstring_load_16 str1 -> str = str1  | _ -> false )
  | Pstring_load_32 b -> (match rhs with Pstring_load_32 b1 -> b = b1 | _ -> false )    
  | Pstring_load_64 b -> (match rhs with Pstring_load_64 b1 -> b = b1 | _ -> false )    
  | Pstring_set_16 b -> (match rhs with Pstring_set_16 b1 -> b = b1 | _ -> false )    
  | Pstring_set_32 b -> (match rhs with Pstring_set_32 b1 -> b = b1 | _ -> false )    
  | Pstring_set_64 b -> (match rhs with Pstring_set_64 b1 -> b = b1 | _ -> false )      
  | Pbigstring_load_16 b -> (match rhs with Pbigstring_load_16 b1 -> b = b1 | _ -> false )      
  | Pbigstring_load_32 b -> (match rhs with Pbigstring_load_32 b1 -> b = b1 | _ -> false )      
  | Pbigstring_load_64 b -> (match rhs with Pbigstring_load_64 b1 -> b = b1 | _ -> false )      
  | Pbigstring_set_16 b -> (match rhs with Pbigstring_set_16 b1 -> b = b1 | _ -> false )      
  | Pbigstring_set_32 b -> (match rhs with Pbigstring_set_32 b1 -> b = b1 | _ -> false )      
  | Pbigstring_set_64 b -> (match rhs with Pbigstring_set_64 b1 -> b = b1 | _ -> false )      
  | Pctconst compile_time_constant -> (match rhs with Pctconst compile_time_constant1 -> eq_compile_time_constant compile_time_constant compile_time_constant1 | _ -> false)
  | Pjs_unsafe_downgrade ( s,_loc) -> (match rhs with Pjs_unsafe_downgrade (s1,_) -> s = s1 | _ -> false)  
  | Pjs_fn_make i -> (match rhs with Pjs_fn_make i1 -> i = i1 | _ -> false)
  | Pjs_fn_run i -> (match rhs with Pjs_fn_run i1 -> i = i1 | _ -> false)
  | Pjs_fn_method i -> (match rhs with Pjs_fn_method i1 -> i = i1 | _ ->  false )
  | Pjs_fn_runmethod i -> (match rhs with Pjs_fn_runmethod i1 -> i = i1 | _ -> false ) 

  | Pbigarrayref  _ 
  | Pbigarrayset _ 
  | Praw_js_code_exp _ 
  | Praw_js_code_stmt _ -> false (* TOO lazy, here comparison is only approximation*)
  


(* TODO:  We can relax this a bit later,
    but decide whether to inline it later in the call site
 *)
let safe_to_inline (lam : Lam.t) = 
  match lam with 
  | Lfunction _ ->  true
  | Lconst (Const_pointer _  | Const_immstring _ ) -> true
  | _ -> false

end
module Lam_id_kind : sig 
#1 "lam_id_kind.mli"
(* Copyright (C) Authors of BuckleScript
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


type rec_flag = 
  | Rec 
  | Non_rec

type function_id = {
  mutable arity : Lam_arity.t;
  lambda  : Lam.t ;
  (* TODO: This may contain some closure environment,
     check how it will interact with dead code elimination
  *)
  rec_flag : rec_flag
}

type element = 
  | NA 
  | SimpleForm of Lam.t 

type boxed_nullable
  = 
  | Undefined 
  | Null 
  | Null_undefined
  | Normal 

type t = 
  | ImmutableBlock of element array * boxed_nullable
  | MutableBlock of element array
  | Constant of Lam.constant
  | Module of Ident.t
        (** TODO: static module vs first class module *)
  | FunctionId of function_id 
  | Exception 
  | Parameter
      (** For this case, it can help us determine whether it should be inlined or not *)

  | NA (** Not such information is associated with an identifier, it is immutable, 
           if you only associate a property to an identifier 
           we should consider [Lassign]
        *)
(** 
       {[ let v/2 =  Pnull_to_opt u]} 

       {[ let v/2 = Pnull_to_opt exp]}
       can be translated into 
       {[
         let v/1 = exp in 
         let v/2 =a Pnull_to_opt exp 
       ]}
       so that [Pfield v/2 0] will be replaced by [v/1], 
       [Lif(v/1)] will be translated into [Lif (v/2 === undefined )]
*)        



val print : Format.formatter -> t -> unit
end = struct
#1 "lam_id_kind.ml"
(* Copyright (C) Authors of BuckleScript
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

(** Keep track of which identifiers are aliased
  *)



type rec_flag = 
  | Rec 
  | Non_rec


type function_id = {

  mutable arity : Lam_arity.t;
  lambda  : Lam.t ;
  (* TODO: This may contain some closure environment,
     check how it will interact with dead code elimination
  *)
  rec_flag : rec_flag
}

type element = 
  | NA 
  | SimpleForm of Lam.t 

type boxed_nullable
  = 
  | Undefined 
  | Null 
  | Null_undefined
  | Normal 

type t = 
  | ImmutableBlock of element array * boxed_nullable
  | MutableBlock of element array
  | Constant of Lam.constant
  | Module of Ident.t
        (** TODO: static module vs first class module *)
  | FunctionId of function_id 
  | Exception 
  | Parameter
      (** For this case, it can help us determine whether it should be inlined or not *)

  | NA (** Not such information is associated with an identifier, it is immutable, 
           if you only associate a property to an identifier 
           we should consider [Lassign]
        *)

let pp = Format.fprintf 

let print fmt (kind : t) = 
  match kind with 
  | ImmutableBlock (arr,_) -> 
    pp fmt "Imm(%d)" (Array.length arr)
  | MutableBlock (arr) ->     
    pp fmt "Mutable(%d)" (Array.length arr)
  | Constant _  ->
    pp fmt "Constant"
  | Module id -> 
    pp fmt "%s/%d" id.name id.stamp 
  | FunctionId _ -> 
    pp fmt "FunctionID"
  | Exception ->
    pp fmt "Exception" 
  | Parameter -> 
    pp fmt "Parameter"  
  | NA -> 
    pp fmt "NA"       
end
module Lam_print : sig 
#1 "lam_print.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

val lambda : Format.formatter -> Lam.t -> unit

val primitive: Format.formatter -> Lam.primitive -> unit

val seriaize : 'a -> string -> Lam.t -> unit

val env_lambda : Env.t -> Format.formatter -> Lam.t -> unit

end = struct
#1 "lam_print.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)
[@@@ocaml.warning "-40"]
open Format
open Asttypes
open Primitive
open Types



let rec struct_const ppf (cst : Lam.constant) =
  match cst with 
  |  (Const_int n) -> fprintf ppf "%i" n
  |  (Const_char c) -> fprintf ppf "%C" c
  |  (Const_string s) -> fprintf ppf "%S" s
  |  (Const_unicode s) -> fprintf ppf "%S" s
  | Const_immstring s -> fprintf ppf "#%S" s
  |  (Const_float f) -> fprintf ppf "%s" f
  |  (Const_int32 n) -> fprintf ppf "%lil" n
  |  (Const_int64 n) -> fprintf ppf "%LiL" n
  |  (Const_nativeint n) -> fprintf ppf "%nin" n
  | Const_pointer (n,_) -> fprintf ppf "%ia" n
  | Const_block(tag,_, []) ->
    fprintf ppf "[%i]" tag
  | Const_block(tag,_, sc1::scl) ->
    let sconsts ppf scl =
      List.iter (fun sc -> fprintf ppf "@ %a" struct_const sc) scl in
    fprintf ppf "@[<1>[%i:@ @[%a%a@]]@]" tag struct_const sc1 sconsts scl
  | Const_float_array [] ->
    fprintf ppf "[| |]"
  | Const_float_array (f1 :: fl) ->
    let floats ppf fl =
      List.iter (fun f -> fprintf ppf "@ %s" f) fl in
    fprintf ppf "@[<1>[|@[%s%a@]|]@]" f1 floats fl

let boxed_integer_name (i : Lambda.boxed_integer) =
  match i with 
  | Pnativeint -> "nativeint"
  | Pint32 -> "int32"
  | Pint64 -> "int64"

let print_boxed_integer name ppf bi =
  fprintf ppf "%s_%s" (boxed_integer_name bi) name

let print_boxed_integer_conversion ppf bi1 bi2 =
  fprintf ppf "%s_of_%s" (boxed_integer_name bi2) (boxed_integer_name bi1)

let boxed_integer_mark name (i : Lambda.boxed_integer) = 
  match i with 
  | Pnativeint -> Printf.sprintf "Nativeint.%s" name
  | Pint32 -> Printf.sprintf "Int32.%s" name
  | Pint64 -> Printf.sprintf "Int64.%s" name

let print_boxed_integer name ppf bi =
  fprintf ppf "%s" (boxed_integer_mark name bi);;

let print_bigarray name unsafe (kind : Lambda.bigarray_kind) ppf 
    (layout : Lambda.bigarray_layout) =
  fprintf ppf "Bigarray.%s[%s,%s]"
    (if unsafe then "unsafe_"^ name else name)
    (match kind with
     | Lambda.Pbigarray_unknown -> "generic"
     | Pbigarray_float32 -> "float32"
     | Pbigarray_float64 -> "float64"
     | Pbigarray_sint8 -> "sint8"
     | Pbigarray_uint8 -> "uint8"
     | Pbigarray_sint16 -> "sint16"
     | Pbigarray_uint16 -> "uint16"
     | Pbigarray_int32 -> "int32"
     | Pbigarray_int64 -> "int64"
     | Pbigarray_caml_int -> "camlint"
     | Pbigarray_native_int -> "nativeint"
     | Pbigarray_complex32 -> "complex32"
     | Pbigarray_complex64 -> "complex64")
    (match layout with
     | Lambda.Pbigarray_unknown_layout -> "unknown"
     | Pbigarray_c_layout -> "C"
     | Pbigarray_fortran_layout -> "Fortran")

let record_rep ppf r =
  match r with
  | Record_regular -> fprintf ppf "regular"
  | Record_float -> fprintf ppf "float"
;;

let string_of_loc_kind (loc : Lambda.loc_kind) =
  match loc with 
  | Loc_FILE -> "loc_FILE"
  | Loc_LINE -> "loc_LINE"
  | Loc_MODULE -> "loc_MODULE"
  | Loc_POS -> "loc_POS"
  | Loc_LOC -> "loc_LOC"

let primitive ppf (prim : Lam.primitive) = match prim with 
  (* | Pcreate_exception s -> fprintf ppf "[exn-create]%S" s  *)
  | Pcreate_extension s -> fprintf ppf "[ext-create]%S" s 
  | Pwrap_exn -> fprintf ppf "#exn"
  | Pjs_string_of_small_array -> fprintf ppf "#string_of_small_array"
  | Pjs_is_instance_array -> fprintf ppf "#is_instance_array"
  | Pcaml_obj_length -> fprintf ppf "#obj_length"
  | Pcaml_obj_set_length -> fprintf ppf "#obj_set_length"
  | Pinit_mod -> fprintf ppf "init_mod!"
  | Pupdate_mod -> fprintf ppf "update_mod!"
  | Pbytes_to_string -> fprintf ppf "bytes_to_string"
  | Pbytes_of_string -> fprintf ppf "bytes_of_string"
  | Pjs_apply -> fprintf ppf "#apply"
  | Pjs_runtime_apply -> fprintf ppf "#runtime_apply"
  | Pjs_unsafe_downgrade (s,_loc) -> fprintf ppf "##%s" s 
  | Pjs_function_length -> fprintf ppf "#function_length"
  | Pjs_fn_run i -> fprintf ppf "#fn_run_%i" i 
  | Pjs_fn_make i -> fprintf ppf "js_fn_make_%i" i
  | Pjs_fn_method i -> fprintf ppf "js_fn_method_%i" i 
  | Pjs_fn_runmethod i -> fprintf ppf "js_fn_runmethod_%i" i 
  | Pdebugger -> fprintf ppf "debugger"
  | Lam.Praw_js_code_exp _ -> fprintf ppf "[raw.exp]"
  | Lam.Praw_js_code_stmt _ -> fprintf ppf "[raw.stmt]"
  | Pglobal_exception id ->
    fprintf ppf "global exception %a" Ident.print id       
  | Pjs_boolean_to_bool -> fprintf ppf "[boolean->bool]"
  | Pjs_typeof -> fprintf ppf "[typeof]"
  | Pnull_to_opt -> fprintf ppf "[null->opt]"              
  | Pundefined_to_opt -> fprintf ppf "[undefined->opt]"     
  | Pnull_undefined_to_opt -> 
    fprintf ppf "[null/undefined->opt]"         
  | Pis_null -> fprintf ppf "[?null]"
  | Pis_undefined -> fprintf ppf "[?undefined]"
  | Pis_null_undefined -> fprintf ppf "[?null?undefined]"
  (* | Psetglobal id -> fprintf ppf "setglobal %a" Ident.print id *)
  | Pmakeblock(tag, _, Immutable) -> fprintf ppf "makeblock %i" tag
  | Pmakeblock(tag, _, Mutable) -> fprintf ppf "makemutable %i" tag
  | Pfield (n,_) -> fprintf ppf "field %i" n
  | Psetfield(n, ptr, _) ->
    let instr = if ptr then "setfield_ptr " else "setfield_imm " in
    fprintf ppf "%s%i" instr n
  | Pfloatfield (n,_) -> fprintf ppf "floatfield %i" n
  | Psetfloatfield (n,_) -> fprintf ppf "setfloatfield %i" n
  | Pduprecord (rep, size) -> fprintf ppf "duprecord %a %i" record_rep rep size
  | Plazyforce -> fprintf ppf "force"
  | Pccall p -> fprintf ppf "%s" p.prim_name
  | Pjs_call (prim_name, _, _) -> 
    fprintf ppf  "%s[js]" prim_name 
  | Pjs_object_create obj_create -> 
    fprintf ppf "[js.obj]"
  | Praise  -> fprintf ppf "raise"
  | Psequand -> fprintf ppf "&&"
  | Psequor -> fprintf ppf "||"
  | Pnot -> fprintf ppf "not"
  | Pnegint -> fprintf ppf "~"
  | Paddint -> fprintf ppf "+"
  | Pstringadd -> fprintf ppf "+*"                 
  | Psubint -> fprintf ppf "-"
  | Pmulint -> fprintf ppf "*"
  | Pdivint -> fprintf ppf "/"
  | Pmodint -> fprintf ppf "mod"
  | Pandint -> fprintf ppf "and"
  | Porint -> fprintf ppf "or"
  | Pxorint -> fprintf ppf "xor"
  | Plslint -> fprintf ppf "lsl"
  | Plsrint -> fprintf ppf "lsr"
  | Pasrint -> fprintf ppf "asr"
  | Pintcomp(Ceq) -> fprintf ppf "==[int]"
  | Pintcomp(Cneq) -> fprintf ppf "!=[int]"
  | Pintcomp(Clt) -> fprintf ppf "<"
  | Pintcomp(Cle) -> fprintf ppf "<="
  | Pintcomp(Cgt) -> fprintf ppf ">"
  | Pintcomp(Cge) -> fprintf ppf ">="
  | Poffsetint n -> fprintf ppf "%i+" n
  | Poffsetref n -> fprintf ppf "+:=%i"n
  | Pintoffloat -> fprintf ppf "int_of_float"
  | Pfloatofint -> fprintf ppf "float_of_int"
  | Pnegfloat -> fprintf ppf "~."
  | Pabsfloat -> fprintf ppf "abs."
  | Paddfloat -> fprintf ppf "+."
  | Psubfloat -> fprintf ppf "-."
  | Pmulfloat -> fprintf ppf "*."
  | Pdivfloat -> fprintf ppf "/."
  | Pfloatcomp(Ceq) -> fprintf ppf "==."
  | Pfloatcomp(Cneq) -> fprintf ppf "!=."
  | Pfloatcomp(Clt) -> fprintf ppf "<."
  | Pfloatcomp(Cle) -> fprintf ppf "<=."
  | Pfloatcomp(Cgt) -> fprintf ppf ">."
  | Pfloatcomp(Cge) -> fprintf ppf ">=."
  | Pjscomp(Ceq) -> fprintf ppf "#=="
  | Pjscomp(Cneq) -> fprintf ppf "#!="
  | Pjscomp(Clt) -> fprintf ppf "#<"
  | Pjscomp(Cle) -> fprintf ppf "#<="
  | Pjscomp(Cgt) -> fprintf ppf "#>"
  | Pjscomp(Cge) -> fprintf ppf "#>="

  | Pstringlength -> fprintf ppf "string.length"
  | Pstringrefu -> fprintf ppf "string.unsafe_get"
  | Pstringrefs -> fprintf ppf "string.get"
  | Pbyteslength -> fprintf ppf "bytes.length"
  | Pbytesrefu -> fprintf ppf "bytes.unsafe_get"
  | Pbytessetu -> fprintf ppf "bytes.unsafe_set"
  | Pbytesrefs -> fprintf ppf "bytes.get"
  | Pbytessets -> fprintf ppf "bytes.set"

  | Parraylength _ -> fprintf ppf "array.length"
  | Pmakearray _ -> fprintf ppf "makearray "
  | Parrayrefu _ -> fprintf ppf "array.unsafe_get"
  | Parraysetu _ -> fprintf ppf "array.unsafe_set"
  | Parrayrefs _ -> fprintf ppf "array.get"
  | Parraysets _ -> fprintf ppf "array.set"
  | Pctconst c ->
    let const_name = match c with
      | Big_endian -> "big_endian"
      | Word_size -> "word_size"
      | Ostype_unix -> "ostype_unix"
      | Ostype_win32 -> "ostype_win32"
      | Ostype_cygwin -> "ostype_cygwin" in
    fprintf ppf "sys.constant_%s" const_name
  | Pisint -> fprintf ppf "isint"
  | Pisout -> fprintf ppf "isout"
  | Pbittest -> fprintf ppf "testbit"
  | Pbintofint bi -> print_boxed_integer "of_int" ppf bi
  | Pintofbint bi -> print_boxed_integer "to_int" ppf bi
  | Pcvtbint (bi1, bi2) -> print_boxed_integer_conversion ppf bi1 bi2
  | Pnegbint bi -> print_boxed_integer "neg" ppf bi
  | Paddbint bi -> print_boxed_integer "add" ppf bi
  | Psubbint bi -> print_boxed_integer "sub" ppf bi
  | Pmulbint bi -> print_boxed_integer "mul" ppf bi
  | Pdivbint bi -> print_boxed_integer "div" ppf bi
  | Pmodbint bi -> print_boxed_integer "mod" ppf bi
  | Pandbint bi -> print_boxed_integer "and" ppf bi
  | Porbint bi -> print_boxed_integer "or" ppf bi
  | Pxorbint bi -> print_boxed_integer "xor" ppf bi
  | Plslbint bi -> print_boxed_integer "lsl" ppf bi
  | Plsrbint bi -> print_boxed_integer "lsr" ppf bi
  | Pasrbint bi -> print_boxed_integer "asr" ppf bi
  | Pbintcomp(bi, Ceq) -> print_boxed_integer "==[bint]" ppf bi
  | Pbintcomp(bi, Cneq) -> print_boxed_integer "!=" ppf bi
  | Pbintcomp(bi, Clt) -> print_boxed_integer "<" ppf bi
  | Pbintcomp(bi, Cgt) -> print_boxed_integer ">" ppf bi
  | Pbintcomp(bi, Cle) -> print_boxed_integer "<=" ppf bi
  | Pbintcomp(bi, Cge) -> print_boxed_integer ">=" ppf bi
  | Pbigarrayref(unsafe, n, kind, layout) ->
    print_bigarray "get" unsafe kind ppf layout
  | Pbigarrayset(unsafe, n, kind, layout) ->
    print_bigarray "set" unsafe kind ppf layout
  | Pbigarraydim(n) -> fprintf ppf "Bigarray.dim_%i" n
  | Pstring_load_16(unsafe) ->
    if unsafe then fprintf ppf "string.unsafe_get16"
    else fprintf ppf "string.get16"
  | Pstring_load_32(unsafe) ->
    if unsafe then fprintf ppf "string.unsafe_get32"
    else fprintf ppf "string.get32"
  | Pstring_load_64(unsafe) ->
    if unsafe then fprintf ppf "string.unsafe_get64"
    else fprintf ppf "string.get64"
  | Pstring_set_16(unsafe) ->
    if unsafe then fprintf ppf "string.unsafe_set16"
    else fprintf ppf "string.set16"
  | Pstring_set_32(unsafe) ->
    if unsafe then fprintf ppf "string.unsafe_set32"
    else fprintf ppf "string.set32"
  | Pstring_set_64(unsafe) ->
    if unsafe then fprintf ppf "string.unsafe_set64"
    else fprintf ppf "string.set64"
  | Pbigstring_load_16(unsafe) ->
    if unsafe then fprintf ppf "bigarray.array1.unsafe_get16"
    else fprintf ppf "bigarray.array1.get16"
  | Pbigstring_load_32(unsafe) ->
    if unsafe then fprintf ppf "bigarray.array1.unsafe_get32"
    else fprintf ppf "bigarray.array1.get32"
  | Pbigstring_load_64(unsafe) ->
    if unsafe then fprintf ppf "bigarray.array1.unsafe_get64"
    else fprintf ppf "bigarray.array1.get64"
  | Pbigstring_set_16(unsafe) ->
    if unsafe then fprintf ppf "bigarray.array1.unsafe_set16"
    else fprintf ppf "bigarray.array1.set16"
  | Pbigstring_set_32(unsafe) ->
    if unsafe then fprintf ppf "bigarray.array1.unsafe_set32"
    else fprintf ppf "bigarray.array1.set32"
  | Pbigstring_set_64(unsafe) ->
    if unsafe then fprintf ppf "bigarray.array1.unsafe_set64"
    else fprintf ppf "bigarray.array1.set64"
  | Pbswap16 -> fprintf ppf "bswap16"
  | Pbbswap(bi) -> print_boxed_integer "bswap" ppf bi


type print_kind = 
  | Alias 
  | Strict 
  | StrictOpt 
  | Variable 
  | Recursive 

let kind = function
  | Alias -> "a"
  | Strict -> ""
  | StrictOpt -> "o"
  | Variable -> "v" 
  | Recursive -> "r"

let to_print_kind (k : Lam.let_kind) : print_kind = 
  match k with 
  | Alias -> Alias 
  | Strict -> Strict
  | StrictOpt -> StrictOpt
  | Variable -> Variable

let rec aux (acc : (print_kind * Ident.t * Lam.t ) list) (lam : Lam.t) = 
  match lam with 
  | Llet (str3, id3, arg3, body3) ->
    aux ((to_print_kind str3,id3, arg3)::acc) body3
  | Lletrec (bind_args, body) ->
    aux 
      (Ext_list.append (Ext_list.map (fun (id,l) -> (Recursive,id,l)) bind_args)
       @@ acc) body
  | e ->  (acc , e) 

type left_var = 
  {
    kind : print_kind ;
    id : Ident.t
  }

type left = 
  | Id of left_var
  | Nop




let  flatten (lam : Lam.t) : (print_kind * Ident.t * Lam.t ) list * Lam.t = 
  match lam with 
  | Llet(str,id, arg, body) ->
    aux [to_print_kind str, id, arg] body
  | Lletrec(bind_args, body) ->
    aux 
      (Ext_list.map (fun (id,l) -> (Recursive, id,l)) bind_args) 
      body
  | _ -> assert false


let get_string ((id : Ident.t), (pos : int)) (env : Env.t) : string = 
  match  Env.find_module (Pident id) env with 
  | {md_type = Mty_signature signature  ; _ } -> 
    (* Env.prefix_idents, could be cached  *)
    let serializable_sigs = 
      List.filter (fun x ->
          match x with 
          | Sig_typext _ 
          | Sig_module _
          | Sig_class _ -> true
          | Sig_value(_, {val_kind = Val_prim _}) -> false
          | Sig_value _ -> true
          | _ -> false
        ) signature  in
    (begin match List.nth  serializable_sigs  pos  with 
       | Sig_value (i,_) 
       | Sig_module (i,_,_) -> i 
       | Sig_typext (i,_,_) -> i 
       | Sig_modtype(i,_) -> i 
       | Sig_class (i,_,_) -> i 
       | Sig_class_type(i,_,_) -> i 
       | Sig_type(i,_,_) -> i 
     end).name
  | _ -> assert false



let lambda use_env env ppf v  =
  let rec lam ppf (l : Lam.t) = match l with 
    | Lvar id ->
      Ident.print ppf id
    | Lam.Lglobal_module id -> 
      fprintf ppf "global %a" Ident.print id
    | Lconst cst ->
      struct_const ppf cst
    | Lapply { fn; args; } ->
      let lams ppf args =
        List.iter (fun l -> fprintf ppf "@ %a" lam l) args in
      fprintf ppf "@[<2>(apply@ %a%a)@]" lam fn lams args
    | Lfunction{ function_kind; params; body; _} ->
      let pr_params ppf params =
        match function_kind with
        | Curried ->
          List.iter (fun param -> fprintf ppf "@ %a" Ident.print param) params
          (* | Tupled -> *)
          (*     fprintf ppf " ("; *)
          (*     let first = ref true in *)
          (*     List.iter *)
          (*       (fun param -> *)
          (*         if !first then first := false else fprintf ppf ",@ "; *)
          (*         Ident.print ppf param) *)
          (*       params; *)
          (*     fprintf ppf ")"  *)
      in
      fprintf ppf "@[<2>(function%a@ %a)@]" pr_params params lam body
    | Llet _ | Lletrec _ as x ->
      let args, body =   flatten x  in
      let bindings ppf id_arg_list =
        let spc = ref false in
        List.iter
          (fun (k, id, l) ->
             if !spc then fprintf ppf "@ " else spc := true;
             fprintf ppf "@[<2>%a =%s@ %a@]" Ident.print id (kind k) lam l)
          id_arg_list in
      fprintf ppf
        "@[<2>(let@ (@[<hv 1>%a@]" bindings (List.rev args);
      fprintf ppf ")@ %a)@]"  lam body
    | Lprim { 
        primitive = Pfield (n,_); 
        args = [ Lglobal_module id ]
        ;  _} when use_env ->
      fprintf ppf "%s.%s/%d" id.name (get_string (id,n) env) n

    | Lprim { 
        primitive  = Psetfield (n,_,_); 
        args = [ Lglobal_module id  ;
                 e ]
        ;  _} when use_env  ->
      fprintf ppf "@[<2>(%s.%s/%d <- %a)@]" id.name (get_string (id,n) env) n
        lam e
    | Lprim{primitive = prim; args = largs;  _} ->
      let lams ppf largs =
        List.iter (fun l -> fprintf ppf "@ %a" lam l) largs in
      fprintf ppf "@[<2>(%a%a)@]" primitive prim lams largs
    | Lswitch(larg, sw) ->
      let switch ppf (sw : Lam.switch) =
        let spc = ref false in
        List.iter
          (fun (n, l) ->
             if !spc then fprintf ppf "@ " else spc := true;
             fprintf ppf "@[<hv 1>case int %i:@ %a@]" n lam l)
          sw.sw_consts;
        List.iter
          (fun (n, l) ->
             if !spc then fprintf ppf "@ " else spc := true;
             fprintf ppf "@[<hv 1>case tag %i:@ %a@]" n lam l)
          sw.sw_blocks ;
        begin match sw.sw_failaction with
          | None  -> ()
          | Some l ->
            if !spc then fprintf ppf "@ " else spc := true;
            fprintf ppf "@[<hv 1>default:@ %a@]" lam l
        end in
      fprintf ppf
        "@[<1>(%s %a@ @[<v 0>%a@])@]"
        (match sw.sw_failaction with None -> "switch*" | _ -> "switch")
        lam larg switch sw
    | Lstringswitch(arg, cases, default) ->
      let switch ppf cases =
        let spc = ref false in
        List.iter
          (fun (s, l) ->
             if !spc then fprintf ppf "@ " else spc := true;
             fprintf ppf "@[<hv 1>case \"%s\":@ %a@]" (String.escaped s) lam l)
          cases;
        begin match default with
          | Some default ->
            if !spc then fprintf ppf "@ " else spc := true;
            fprintf ppf "@[<hv 1>default:@ %a@]" lam default
          | None -> ()
        end in
      fprintf ppf
        "@[<1>(stringswitch %a@ @[<v 0>%a@])@]" lam arg switch cases
    | Lstaticraise (i, ls)  ->
      let lams ppf largs =
        List.iter (fun l -> fprintf ppf "@ %a" lam l) largs in
      fprintf ppf "@[<2>(exit@ %d%a)@]" i lams ls;
    | Lstaticcatch(lbody, (i, vars), lhandler) ->
      fprintf ppf "@[<2>(catch@ %a@;<1 -1>with (%d%a)@ %a)@]"
        lam lbody i
        (fun ppf vars -> match vars with
           | [] -> ()
           | _ ->
             List.iter
               (fun x -> fprintf ppf " %a" Ident.print x)
               vars)
        vars
        lam lhandler
    | Ltrywith(lbody, param, lhandler) ->
      fprintf ppf "@[<2>(try@ %a@;<1 -1>with %a@ %a)@]"
        lam lbody Ident.print param lam lhandler
    | Lifthenelse(lcond, lif, lelse) ->
      fprintf ppf "@[<2>(if@ %a@ %a@ %a)@]" lam lcond lam lif lam lelse
    | Lsequence(l1, l2) ->
      fprintf ppf "@[<2>(seq@ %a@ %a)@]" lam l1 sequence l2
    | Lwhile(lcond, lbody) ->
      fprintf ppf "@[<2>(while@ %a@ %a)@]" lam lcond lam lbody
    | Lfor(param, lo, hi, dir, body) ->
      fprintf ppf "@[<2>(for %a@ %a@ %s@ %a@ %a)@]"
        Ident.print param lam lo
        (match dir with Upto -> "to" | Downto -> "downto")
        lam hi lam body
    | Lassign(id, expr) ->
      fprintf ppf "@[<2>(assign@ %a@ %a)@]" Ident.print id lam expr
    | Lsend (k, met, obj, largs, _) ->
      let args ppf largs =
        List.iter (fun l -> fprintf ppf "@ %a" lam l) largs in
      let kind =
        if k = Self then "self" else if k = Cached then "cache" else "" in
      fprintf ppf "@[<2>(send%s@ %a@ %a%a)@]" kind lam obj lam met args largs
    | Lifused(id, expr) ->
      fprintf ppf "@[<2>(ifused@ %a@ %a)@]" Ident.print id lam expr

  and sequence ppf = function
    | Lsequence(l1, l2) ->
      fprintf ppf "%a@ %a" sequence l1 sequence l2
    | l ->
      lam ppf l
  in 
  lam ppf v

let structured_constant = struct_const

let env_lambda = lambda true 
let lambda = lambda false Env.empty

let rec flatten_seq acc (lam : Lam.t) =
  match lam with 
  | Lsequence(l1,l2) -> 
    flatten_seq (flatten_seq acc l1) l2
  | x -> x :: acc 

exception Not_a_module

let rec flat (acc : (left * Lam.t) list ) (lam : Lam.t) = 
  match lam with 
  | Llet (str,id,arg,body) ->
    flat ( (Id {kind = to_print_kind str;  id}, arg) :: acc) body 
  | Lletrec (bind_args, body) ->
    flat 
      (Ext_list.append 
        (Ext_list.map (fun (id, arg ) -> (Id {kind = Recursive;  id}, arg)) bind_args) @@ acc) 
      body 
  | Lsequence (l,r) -> 
    flat (flat acc l) r
  | x -> (Nop, x) :: acc 

let lambda_as_module env  ppf (lam : Lam.t) = 
  try
    (* match lam with *)
    (* | Lprim {primitive = Psetglobal id ; args =  [biglambda]; _} *)
    (* might be wrong in toplevel *) 
    (* -> *)

    begin match flat [] lam  with 
      | (Nop, Lprim {primitive = Pmakeblock (_, _, _); args =  toplevels; _})
        :: rest ->
        (* let spc = ref false in *)
        List.iter
          (fun (left, l) ->
             match left with 
             | Id { kind = k; id } ->
               fprintf ppf "@[<2>%a =%s@ %a@]@." Ident.print id (kind k) (env_lambda env) l
             | Nop -> 

               fprintf ppf "@[<2>%a@]@."   (env_lambda env) l
          )

        @@ List.rev rest


      | _ -> raise Not_a_module
    end
  (* | _ -> raise Not_a_module *)
  with _ -> 
    env_lambda env ppf lam;
    fprintf ppf "; lambda-failure"
let seriaize env (filename : string) (lam : Lam.t) : unit =
  let ou = open_out filename  in
  let old = Format.get_margin () in
  let () = Format.set_margin 10000 in
  let fmt = Format.formatter_of_out_channel ou in
  begin
    (* lambda_as_module env fmt lambda; *)
    lambda fmt lam;
    Format.pp_print_flush fmt ();
    close_out ou;
    Format.set_margin old
  end

end
module Lam_stats : sig 
#1 "lam_stats.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Types defined for lambda analysis *)

type alias_tbl =  Ident.t Ident_hashtbl.t

(** Keep track of which identifiers are aliased
  *)



type ident_tbl = Lam_id_kind.t Ident_hashtbl.t 



type t = {
  env : Env.t;
  filename : string ;
  export_idents : Ident_set.t ;
  exports : Ident.t list ;
  alias_tbl : alias_tbl; 
  

  ident_tbl : ident_tbl;
  (** we don't need count arities for all identifiers, for identifiers
      for sure it's not a function, there is no need to count them
   *)


}


val print : Format.formatter -> t -> unit 
end = struct
#1 "lam_stats.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(* It can be useful for common sub expression elimination ? 
    if two lambdas are not equal, it should return false, other wise, 
    it might return true , this is only used as a way of optimizaton

    Use case :
    1. switch case -- common fall through
 *)

(* lambda pass for alpha conversion 
    and alias
    we need think about the order of the pass, might be the alias pass can be done 
    in the  beginning, when we do alpha conversion, we can instrument the table 
 *)



type alias_tbl =  Ident.t Ident_hashtbl.t



type ident_tbl = Lam_id_kind.t Ident_hashtbl.t 



type t = {
  env : Env.t;
  filename : string ;
  export_idents : Ident_set.t ;
  exports : Ident.t list ; (*It is kept since order matters? *)

  alias_tbl : alias_tbl; 
  ident_tbl : ident_tbl;
  (** we don't need count arities for all identifiers, for identifiers
      for sure it's not a function, there is no need to count them
  *)
  
}

let pp = Format.fprintf

let pp_alias_tbl fmt (tbl : alias_tbl) = 
  Ident_hashtbl.iter (fun k v -> pp fmt "@[%a -> %a@]@." Ident.print k Ident.print v)
    tbl



let pp_ident_tbl fmt (ident_tbl : ident_tbl) = 
  Ident_hashtbl.iter (fun k v -> pp fmt "@[%a -> %a@]@." 
    Ident.print k Lam_id_kind.print v)
    ident_tbl

let print fmt (v : t) = 
    pp fmt "@[Alias table:@ @[%a@]@]" pp_alias_tbl v.alias_tbl ;    
    pp fmt "@[Ident table:@ @[%a@]@]" pp_ident_tbl v.ident_tbl ;
    pp fmt "@[exports:@ @[%a@]@]"
        (Format.pp_print_list 
            ~pp_sep:(fun fmt () -> pp fmt "@ ;")             
            Ident.print
        ) v.exports
end
module Lam_util : sig 
#1 "lam_util.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








val string_of_lambda : Lam.t -> string 

val string_of_primitive : Lam.primitive -> string

val kind_of_lambda_block : Lam_id_kind.boxed_nullable -> Lam.t list -> Lam_id_kind.t


(** [field_flattern_get cb v i tbl]
    try to remove the indirection of [v.(i)], if not 
    call [cb ()].
    Note due to different control flow, a constant block
    may result in out-of bound access.
    {[
      (let
  (myShape/1011 =a [0: 10]
    area/1012 =
      (switch* myShape/1011
       case tag 0:
        (let (r/1013 =a (field 0 myShape/1011))
          ( *. (float_of_int ( * r/1013 r/1013)) 3.14))
       case tag 1:
        (let
          (h/1015 =a (field 1 myShape/1011) w/1014 =a (field 0 myShape/1011))
          (float_of_int ( * w/1014 h/1015)))))
  (makeblock 0 myShape/1011 area/1012))
    ]}
    Here [(field 1 myShape]) is out of bounds
*)
val field_flatten_get : 
  (unit -> Lam.t) -> Ident.t -> int -> Lam_stats.ident_tbl -> Lam.t





val alias_ident_or_global : Lam_stats.t ->
  Ident.t -> Ident.t -> Lam_id_kind.t -> Lam.let_kind -> unit 


val refine_let : 
    kind:Lam.let_kind  ->
      Ident.t -> Lam.t -> Lam.t -> Lam.t


val generate_label : ?name:string -> unit -> J.label

(* val sort_dag_args : J.expression Ident_map.t -> Ident.t list option *)
(** if [a] depends on [b] a is ahead of [b] as [a::b]

    TODO: make it a stable sort 
 *)


(** [dump] when {!Js_config.is_same_file}*)
val dump : Env.t   -> string -> Lam.t -> Lam.t


val print_ident_set : Format.formatter -> Ident_set.t -> unit



val not_function : Lam.t -> bool 
val is_function : Lam.t -> bool 




val subst_lambda : Lam.t Ident_map.t -> Lam.t -> Lam.t




end = struct
#1 "lam_util.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








let string_of_lambda = Format.asprintf "%a" Lam_print.lambda 

let string_of_primitive = Format.asprintf "%a" Lam_print.primitive






(*
let add_required_modules ( x : Ident.t list) (meta : Lam_stats.t) = 
  let meta_require_modules = meta.required_modules in
  List.iter (fun x -> add meta_require_modules (Lam_module_ident.of_ml x)) x 
*)
  
(* Apply a substitution to a lambda-term.
   Assumes that the bound variables of the lambda-term do not
   belong to the domain of the substitution.
   Assumes that the image of the substitution is out of reach
   of the bound variables of the lambda-term (no capture). *)

let subst_lambda (s : Lam.t Ident_map.t) lam =
  let rec subst (x : Lam.t) : Lam.t =
    match x with 
    | Lvar id as l ->
      Ident_map.find_default id s l
    | Lconst sc as l -> l
    | Lapply{fn; args; loc; status} -> 
      Lam.apply (subst fn) (Ext_list.map subst args) loc status
    | Lfunction {arity; function_kind; params; body} -> 
      Lam.function_ ~arity ~function_kind  ~params ~body:(subst body)
    | Llet(str, id, arg, body) -> 
      Lam.let_ str id (subst arg) (subst body)
    | Lletrec(decl, body) -> 
      Lam.letrec (Ext_list.map subst_decl decl) (subst body)
    | Lprim { primitive ; args; loc} -> 
      Lam.prim ~primitive ~args:(Ext_list.map subst args) loc
    | Lam.Lglobal_module _ -> x  
    | Lswitch(arg, sw) ->
      Lam.switch (subst arg)
        {sw with sw_consts = Ext_list.map subst_case sw.sw_consts;
                 sw_blocks = Ext_list.map subst_case sw.sw_blocks;
                 sw_failaction = subst_opt  sw.sw_failaction; }
    | Lstringswitch (arg,cases,default) ->
      Lam.stringswitch
        (subst arg) (Ext_list.map subst_strcase cases) (subst_opt default)
    | Lstaticraise (i,args)
      ->  Lam.staticraise i (Ext_list.map subst args)
    | Lstaticcatch(e1, io, e2)
      -> Lam.staticcatch (subst e1) io (subst e2)
    | Ltrywith(e1, exn, e2)
      -> Lam.try_ (subst e1) exn (subst e2)
    | Lifthenelse(e1, e2, e3)
      -> Lam.if_ (subst e1) (subst e2) (subst e3)
    | Lsequence(e1, e2)
      -> Lam.seq (subst e1) (subst e2)
    | Lwhile(e1, e2) 
      -> Lam.while_ (subst e1) (subst e2)
    | Lfor(v, e1, e2, dir, e3) 
      -> Lam.for_ v (subst e1) (subst e2) dir (subst e3)
    | Lassign(id, e) -> 
      Lam.assign id (subst e)
    | Lsend (k, met, obj, args, loc) ->
      Lam.send k (subst met) (subst obj) (Ext_list.map subst args) loc
    | Lifused (v, e) -> Lam.ifused v (subst e)
  and subst_decl (id, exp) = (id, subst exp)
  and subst_case (key, case) = (key, subst case)
  and subst_strcase (key, case) = (key, subst case)
  and subst_opt = function
    | None -> None
    | Some e -> Some (subst e)
  in subst lam

(* 
    It's impossible to have a case like below:
   {[
     (let export_f = ... in export_f)
   ]}
    Even so, it's still correct
*)
let refine_let
    ~kind param
    (arg : Lam.t) (l : Lam.t)  : Lam.t =

  match (kind : Lam.let_kind ), arg, l  with 
  | _, _, Lvar w when Ident.same w param 
    (* let k = xx in k
      there is no [rec] so [k] would not appear in [xx]
     *)
    -> arg (* TODO: optimize here -- it's safe to do substitution here *)
  | _, _, Lprim {primitive ; args =  [Lvar w]; loc ; _} when Ident.same w param 
                                                          &&  (function | Lam.Pmakeblock _ -> false | _ ->  true) primitive
    (* don't inline inside a block *)
    ->  Lam.prim ~primitive ~args:[arg]  loc 
  (* we can not do this substitution when capttured *)
  (* | _, Lvar _, _ -> (\** let u = h in xxx*\) *)
  (*     (\* assert false *\) *)
  (*     Ext_log.err "@[substitution >> @]@."; *)
  (*     let v= subst_lambda (Ident_map.singleton param arg ) l in *)
  (*     Ext_log.err "@[substitution << @]@."; *)
  (* v *)
  | _, _, Lapply {fn; args = [Lvar w]; loc; status} when
   Ident.same w param &&
    (not (Lam.hit_any_variables (Ident_set.singleton param) fn ))
   -> 
    (** does not work for multiple args since 
        evaluation order unspecified, does not apply 
        for [js] in general, since the scope of js ir is loosen

        here we remove the definition of [param]
        {[ let k = v in (body) k 
        ]}
        #1667 make sure body does not hit k 
    *)
    Lam.apply fn [arg] loc status
  | (Strict | StrictOpt ),
    ( Lvar _    | Lconst  _ | 
      Lprim {primitive = Pfield _ ;  
             args = [ Lglobal_module _ ]; _}) , _ ->
    (* (match arg with  *)
    (* | Lconst _ ->  *)
    (*     Ext_log.err "@[%a %s@]@."  *)
    (*       Ident.print param (string_of_lambda arg) *)
    (* | _ -> ()); *)
    (* No side effect and does not depend on store,
        since function evaluation is always delayed
    *)
    Lam.let_ Alias param arg l
  | ( (Strict | StrictOpt ) ), (Lfunction _ ), _ ->
    (*It can be promoted to [Alias], however, 
        we don't want to do this, since we don't want the 
        function to be inlined to a block, for example
      {[
        let f = fun _ -> 1 in
        [0, f]
      ]}
        TODO: punish inliner to inline functions 
        into a block 
    *)
    Lam.let_ StrictOpt  param arg l
  (* Not the case, the block itself can have side effects 
      we can apply [no_side_effects] pass 
      | Some Strict, Lprim(Pmakeblock (_,_,Immutable),_) ->  
        Llet(StrictOpt, param, arg, l) 
  *)      
  | Strict, _ ,_  when Lam_analysis.no_side_effects arg ->
    Lam.let_ StrictOpt param arg l
  | Variable, _, _ -> 
    Lam.let_ Variable  param arg l
  | kind, _, _ -> 
    Lam.let_ kind  param arg l
  (* | None , _, _ -> 
    Lam.let_ Strict param arg  l *)

let alias_ident_or_global (meta : Lam_stats.t) (k:Ident.t) (v:Ident.t) 
    (v_kind : Lam_id_kind.t) (let_kind : Lam.let_kind) =
  (** treat rec as Strict, k is assigned to v 
      {[ let k = v ]}
  *)
  begin 
    match v_kind with 
    | NA ->
      begin 
        match Ident_hashtbl.find_opt meta.ident_tbl v  with 
        | None -> ()
        | Some ident_info -> Ident_hashtbl.add meta.ident_tbl k ident_info
      end
    | ident_info -> Ident_hashtbl.add meta.ident_tbl k ident_info
  end ;
  (* share -- it is safe to share most properties,
      for arity, we might be careful, only [Alias] can share,
      since two values have same type, can have different arities
      TODO: check with reference pass, it might break 
      since it will create new identifier, we can avoid such issue??

      actually arity is a dynamic property, for a reference, it can 
      be changed across 
      we should treat
      reference specially. or maybe we should track any 
      mutable reference
  *)
  begin match let_kind with 
    | Alias -> 
      if not @@ Ident_set.mem k meta.export_idents 
      then
        Ident_hashtbl.add meta.alias_tbl k v 
    (** For [export_idents], we don't want to do such simplification
        if we do substitution, then it will affect exports...
    *)
    | Strict | StrictOpt(*can discard but not be substitued *) | Variable  -> ()
  end




(* How we destruct the immutable block 
   depend on the block name itself, 
   good hints to do aggressive destructing
   1. the variable is not exported
      like [matched] -- these are blocks constructed temporary
   2. how the variable is used 
      if it is guarateed to be 
      - non export 
      - and non escaped (there is no place it is used as a whole)
      then we can always destruct it 
      if some fields are used in multiple places, we can create 
      a temporary field 

   3. It would be nice that when the block is mutable, its 
       mutable fields are explicit, since wen can not inline an mutable block access
*)

let element_of_lambda (lam : Lam.t) : Lam_id_kind.element = 
  match lam with 
  | Lvar _ 
  | Lconst _ 
  | Lprim {primitive = Pfield _ ; 
           args =  [ Lglobal_module _ ];
           _} -> SimpleForm lam
  (* | Lfunction _  *)
  | _ -> NA 

let kind_of_lambda_block kind (xs : Lam.t list) : Lam_id_kind.t = 
  ImmutableBlock( Ext_array.of_list_map (fun x -> 
  element_of_lambda x ) xs , kind)

let field_flatten_get
   lam v i (tbl : Lam_id_kind.t Ident_hashtbl.t) : Lam.t =
  match Ident_hashtbl.find_opt tbl v  with 
  | Some (Module g) -> 
    Lam.prim ~primitive:(Pfield (i, Lambda.Fld_na)) 
      ~args:[ Lam.global_module g ] Location.none
  | Some (ImmutableBlock (arr, _)) -> 
    begin match arr.(i) with 
      | NA -> lam ()
      | SimpleForm l -> l
      | exception _ -> lam ()
    end
  | Some (Constant (Const_block (_,_,ls))) -> 
    begin match Ext_list.nth_opt ls i with 
    | None -> lam  ()
    | Some x -> Lam.const x
    end
  | Some _
  | None -> lam ()


(* TODO: check that if label belongs to a different 
    namesape
*)
let count = ref 0 

let generate_label ?(name="") ()  = 
  incr count; 
  Printf.sprintf "%s_tailcall_%04d" name !count

let log_counter = ref 0


let dump env ext  lam = 

      lam
      
  




let print_ident_set fmt s = 
  Format.fprintf fmt   "@[<v>{%a}@]@."
    (fun fmt s   -> 
       Ident_set.iter 
         (fun e -> Format.fprintf fmt "@[<v>%a@],@ " Ident.print e) s
    )
    s     




let is_function (lam : Lam.t) = 
  match lam with 
  | Lfunction _ -> true | _ -> false

let not_function (lam : Lam.t) = 
  match lam with 
  | Lfunction _ -> false | _ -> true 

(* TODO: we need create 
   1. a smart [let] combinator, reusable beta-reduction 
   2. [lapply fn args info] 
   here [fn] should get the last tail
   for example 
   {[
     lapply (let a = 3 in let b = 4 in fun x y -> x + y) 2 3 
   ]}   
*)









end
module Js_stmt_make : sig 
#1 "js_stmt_make.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Creator utilities for the [J] module *) 


type t = J.statement 

val mk :  ?comment:string  -> J.statement_desc -> t

val empty : ?comment:string  ->  unit -> t

val throw : ?comment:string  -> J.expression -> t

val if_ : 
  ?comment:string  ->
  ?declaration: Lam.let_kind * Ident.t ->
  (* when it's not None, we also need make a variable declaration in the
     begininnig, however, we can optmize such case
  *)
  ?else_:J.block ->  
  J.expression -> 
  J.block -> 
  t

val block : ?comment:string  -> J.block -> t

val int_switch :
  ?comment:string -> ?declaration:Lam.let_kind * Ident.t -> 
  ?default:J.block -> J.expression -> int J.case_clause list -> t 

val string_switch : ?comment:string -> ?declaration:Lam.let_kind * Ident.t -> 
  ?default:J.block -> J.expression -> string J.case_clause list -> t

val declare_variable : ?comment:string ->
  ?ident_info:J.ident_info 
  -> kind:Lam.let_kind -> Ident.t -> t

val define : 
  ?comment:string ->
  ?ident_info:J.ident_info ->
  kind:Lam.let_kind -> Ident.t -> J.expression  -> t

val alias_variable :
  ?comment:string -> ?exp:J.expression -> Ident.t -> t
val assign : ?comment:string  -> J.ident -> J.expression -> t

val assign_unit : ?comment:string  -> J.ident -> t

val declare_unit : ?comment:string  -> J.ident -> t

val while_ : ?comment:string ->
  ?label:J.label -> ?env:Js_closure.t -> J.expression -> J.block -> t

val for_ : 
  ?comment:string ->
  ?env:Js_closure.t ->
  J.for_ident_expression option ->
  J.finish_ident_expression ->
  J.for_ident  -> J.for_direction -> J.block -> t

val try_ :
  ?comment:string  ->
  ?with_:J.ident * J.block -> ?finally:J.block -> J.block -> t

val exp : ?comment:string  -> J.expression -> t

val return : ?comment:string  -> J.expression -> t

val unknown_lambda : ?comment:string  -> Lam.t -> t

val return_unit : ?comment:string -> unit -> t
(** for ocaml function which returns unit 
    it will be compiled into [return 0] in js *)

val break : ?comment:string  -> unit -> t

(** if [label] is not set, it will default to empty *)  
val continue : ?comment:string  -> ?label:J.label -> unit  -> t

val debugger :  t

end = struct
#1 "js_stmt_make.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






module E = Js_exp_make 

type t = J.statement 

let return ?comment e : t = 
  {statement_desc = Return {return_value = e; } ; comment}

let return_unit ?comment () : t =              
  return ?comment  E.unit 

let break ?comment () : t = 
  {comment ; statement_desc = Break }

let mk ?comment  statement_desc : t = 
  {statement_desc; comment}

let empty ?comment  () : t = { statement_desc = Block []; comment}

let throw ?comment v : t = { statement_desc = J.Throw v; comment}

(* avoid nested block *)
let  rec block ?comment  (b : J.block)   : t =  
  match b with 
  | [{statement_desc = Block bs }  ] -> block bs
  | [b] -> b
  | [] -> empty ?comment ()
  | _ -> {statement_desc = Block b  ; comment}

(* It's a statement, we can discard some values *)       
let rec exp ?comment (e : E.t) : t = 
  match e.expression_desc with 
  | (Seq( {expression_desc = Number _}, b) 
    | Seq( b, {expression_desc = Number _})) -> exp ?comment b 
  | Number _ -> block []
  (* TODO: we can do more *)      
  (* | _ when is_pure e ->  block [] *)
  |  _ -> 
    { statement_desc = Exp e; comment}

let declare_variable ?comment  ?ident_info  ~kind (v:Ident.t)  : t=
  let property : J.property =  kind in
  let ident_info  : J.ident_info  = 
    match ident_info with
    | None ->  {used_stats = NA}
    | Some x -> x in
  {statement_desc = 
     Variable { ident = v; value = None; property ; 
                ident_info ;};
   comment}

let define ?comment  ?ident_info ~kind (v:Ident.t) exp    : t=
  let property : J.property =  kind in
  let ident_info  : J.ident_info  = 
    match ident_info with
    | None ->  {used_stats = NA}
    | Some x -> x in
  {statement_desc = 
     Variable { ident = v; value =  Some exp; property ; 
                ident_info ;};
   comment}

let int_switch ?comment   ?declaration ?default (e : J.expression)  clauses : t = 
  match e.expression_desc with 
  | Number (Int {i; _}) -> 
    let continuation =  
      begin match List.find (fun (x : _ J.case_clause) -> x.case = (Int32.to_int i)) clauses
        with 
        | case -> fst case.body
        | exception Not_found -> 
          begin match default with
            | Some x ->  x 
            | None -> assert false
          end 
      end in
    begin match declaration, continuation with 
      | Some (kind, did), 
        [ {statement_desc = Exp {expression_desc = Bin(Eq,  {expression_desc = Var (Id id) ; _}, e0); _}; _}]
        when Ident.same did id 
        -> 
        define ?comment ~kind id e0
      | Some(kind,did), _ 
        -> 
        block (declare_variable ?comment ~kind did :: continuation)
      | None, _ -> block continuation
    end

  | _ -> 
    match declaration with 
    | Some (kind, did) -> 
      block [declare_variable ?comment ~kind did ;
             { statement_desc = J.Int_switch (e,clauses, default); comment}]
    | None ->  { statement_desc = J.Int_switch (e,clauses, default); comment}

let string_switch ?comment ?declaration  ?default (e : J.expression)  clauses : t= 
  match e.expression_desc with 
  | Str (_,s) -> 
    let continuation = 
      begin match List.find 
                    (fun  (x : string J.case_clause) -> x.case = s) clauses
        with 
        | case ->  (fst case.body)
        | exception Not_found -> 
          begin match default with 
            | Some x -> x 
            | None -> assert false 
          end
      end in
    begin match declaration, continuation with 
      | Some (kind, did),
        [ {statement_desc = Exp {expression_desc = Bin(Eq,  {expression_desc = Var (Id id); _}, e0);_} ; _}]
        when Ident.same did id 
        -> 
        define ?comment ~kind id e0
      | Some(kind,did), _ 
        -> 
        block @@ declare_variable ?comment ~kind did :: continuation
      | None, _ -> block continuation
    end
  | _  -> 
    match declaration with 
    | Some (kind,did) -> 
      block [declare_variable ?comment ~kind did ;
             { statement_desc = String_switch (e,clauses, default); comment}]
    | None -> { statement_desc = String_switch (e,clauses, default); comment}


(* TODO: it also make sense  to extract some common statements 
    between those two branches, it does happen since in OCaml you 
    have to write some duplicated code due to the types system restriction
    example:
   {[
     | Format_subst (pad_opt, fmtty, rest) ->
       buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;
       bprint_pad_opt buf pad_opt; buffer_add_char buf '(';
       bprint_fmtty buf fmtty; buffer_add_char buf '%'; buffer_add_char buf ')';
       fmtiter rest false;

       | Scan_char_set (width_opt, char_set, rest) ->
       buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;
       bprint_pad_opt buf width_opt; bprint_char_set buf char_set;
       fmtiter rest false;
   ]}
*)
let rec if_ ?comment  ?declaration ?else_ (e : J.expression) (then_ : J.block)   : t = 
  let declared = ref false in
  let rec aux ?comment (e : J.expression) (then_ : J.block) (else_ : J.block ) acc   =
    match e.expression_desc, then_, (else_ : J.block ) with 
    | _, [ {statement_desc = Return {return_value = b; _}; _}], 
      [ {statement_desc = Return {return_value = a; _}; _}]
      ->
      return (E.econd e b a ) :: acc 
    | _,  [ {statement_desc = 
               Exp {expression_desc = Bin(Eq, ({expression_desc = Var (Id id0); _} as l0), a0); _}; _}], 
      [ {statement_desc = 
           Exp ({ expression_desc = Bin(Eq, 
                                        {expression_desc = Var (Id id1); _}, b0); _}); _}]
      when Ident.same id0 id1 -> 
      begin match declaration with 
        | Some (kind,did)  when Ident.same did id0 -> 
          declared := true;
          define ~kind id0 (E.econd e a0 b0) :: acc 
        (* To hit this branch, we also need [declaration] passed down 
           TODO: check how we compile [Lifthenelse]
        *)
        | _ -> 
          exp (E.assign l0 (E.econd e a0 b0)) :: acc 
      end

    | _,  _,  
      [ {statement_desc = Exp {expression_desc = Number _}; _}]
      ->
      aux ?comment e then_ [] acc 
    | _, [ {statement_desc = Exp {expression_desc = Number _}; _}], _
      ->
      aux ?comment e [] else_ acc 

    | _,  [ {statement_desc = Exp b; _}],  [ {statement_desc = Exp a; _}]
      ->
      exp (E.econd e b a) :: acc 
    | _, [], []                                   
      -> exp e :: acc 
    | Caml_not e, _ , _ :: _
    | Js_not e, _ , _ :: _
      -> aux ?comment e else_ then_ acc
    | _, [], _
      ->
      aux ?comment (E.not e) else_ [] acc
    (* Be careful that this re-write may result in non-terminating effect *)
    | _, (y::ys),  (x::xs)
      when Js_analyzer.(eq_statement x y && no_side_effect_expression e)
      ->
      (** here we do agressive optimization, because it can help optimization later,
          move code outside of branch is generally helpful later
      *)
      aux ?comment e ys xs (y::acc)

    |  Number ( Int { i = 0l; _}) , _,  _
      ->  
      begin match else_ with 
        | [] -> acc 
        | _ -> block else_ ::acc
      end
    |  (Number _ , _, _
       | (Bin (Ge, 
               ({expression_desc = Length _;
                 _}), {expression_desc = Number (Int { i = 0l; _})})), _ , _)
      (* TODO: always 
          turn [Le] -> into [Ge]
      *)
      -> block then_ :: acc 
    | Bin (Bor , a, {expression_desc = Number (Int { i = 0l ; _})}), _, _ 
    | Bin (Bor , {expression_desc = Number (Int { i = 0l ; _})}, a), _, _ 
      -> 
      aux ?comment a  then_ else_ acc

    | (
      (Bin (((EqEqEq ), {expression_desc = Number (Int {i = 0l; _}); _},e)) |
       Bin ((EqEqEq ), e,{expression_desc = Number (Int {i = 0l; _});_}))
    ),  _,  else_ 
      (* TODO: optimize in general of preciate information based on type system 
          like: [if_], [econd]
      *)
      ->
      aux ?comment e else_  then_ acc 

    (* | Bin (NotEqEq, e1,  *)
    (*        {expression_desc = Var (Id ({name = "undefined"; _} as id))}), *)
    (*   _, _ *)
    (*   when Ext_ident.is_js id ->  *)
    (*   aux ?comment e1 then_ else_ acc  *)

    | ((Bin (Gt, 
             ({expression_desc = 
                 Length _;
               _} as e ), {expression_desc = Number (Int { i = 0l; _})}))

      | Int_of_boolean e), _ , _
      ->
      (** Add comment when simplified *)
      aux ?comment e then_ else_ acc 

    | _ -> 
      let e = E.ocaml_boolean_under_condition e in 
      { statement_desc = If (e, 
                             then_,
                             (match else_ with 
                              | [] -> None
                              |  v -> Some  v)); 
        comment } :: acc in
  let if_block = 
    aux ?comment e then_ (match else_ with None -> [] | Some v -> v) [] in

  match !declared, declaration with 
  | true , _ 
  | _    , None  ->  block (List.rev if_block)
  | false, Some (kind, did) -> block (declare_variable ~kind did :: List.rev if_block )



let alias_variable ?comment  ?exp (v:Ident.t)  : t=
  {statement_desc = 
     Variable {
       ident = v; value = exp; property = Alias;
       ident_info = {used_stats = NA }   };
   comment}

let assign ?comment  id e : t = 
  {
    statement_desc = J.Exp ( E.assign (E.var id) e ) ;
    comment
  }
let assign_unit ?comment  id :  t = 
  {
    statement_desc = J.Exp( E.assign (E.var id) E.unit);
    comment
  }
let declare_unit ?comment  id :  t = 
  {
    statement_desc = 
      J.Variable { ident =  id; 
                   value = Some E.unit;
                   property = Variable;
                   ident_info = {used_stats = NA}
                 };
    comment
  }

let rec while_  ?comment  ?label ?env (e : E.t) (st : J.block) : t = 
  match e with 
  (* | {expression_desc = Int_of_boolean e; _} ->  *)
  (*   while_ ?comment  ?label  e st *)
  | _ -> 
    let e = E.ocaml_boolean_under_condition e in
    let env = 
      match env with 
      | None -> Js_closure.empty ()
      | Some x -> x in
    {
      statement_desc = While (label, e, st, env);
      comment
    }

let for_ ?comment   ?env 
    for_ident_expression
    finish_ident_expression id direction (b : J.block) : t =
  let env = 
    match env with 
    | None -> Js_closure.empty ()
    | Some x -> x 
  in
  {
    statement_desc = 
      ForRange (for_ident_expression, finish_ident_expression, id, direction, b, env);
    comment
  }

let try_ ?comment   ?with_ ?finally body : t = 
  {
    statement_desc = Try (body, with_, finally) ;
    comment
  }

let unknown_lambda ?(comment="unknown")  (lam : Lam.t ) : t = 
  exp @@ E.str ~comment ~pure:false (Lam_util.string_of_lambda lam) 

(* TODO: 
    actually, only loops can be labelled
*)    
let continue  ?comment   ?(label="") unit  : t = 
  { 
    statement_desc = J.Continue  label;
    comment;
  }

let debugger : t = 
  { statement_desc = J.Debugger ; 
    comment = None 
  }

end
module Printlambda : sig 
#1 "printlambda.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Lambda

open Format

val structured_constant: formatter -> structured_constant -> unit

val env_lambda : Env.t -> formatter -> lambda -> unit
val lambda : formatter -> lambda -> unit
val primitive: formatter -> primitive -> unit

val lambda_as_module : Env.t  -> Format.formatter -> Lambda.lambda -> unit


val seriaize: Env.t -> string -> lambda -> unit

val serialize_raw_js: 
    (Env.t -> Types.signature ->  string  -> lambda  -> unit) ref
val serialize_js: (Env.t -> string  -> lambda  -> unit) ref

end = struct
#1 "printlambda.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)
[@@@ocaml.warning "-40"]
open Format
open Asttypes
open Primitive
open Types
open Lambda


let rec struct_const ppf = function
  | Const_base(Const_int n) -> fprintf ppf "%i" n
  | Const_base(Const_char c) -> fprintf ppf "%C" c
  | Const_base(Const_string (s, _)) -> fprintf ppf "%S" s
  | Const_immstring s -> fprintf ppf "#%S" s
  | Const_base(Const_float f) -> fprintf ppf "%s" f
  | Const_base(Const_int32 n) -> fprintf ppf "%lil" n
  | Const_base(Const_int64 n) -> fprintf ppf "%LiL" n
  | Const_base(Const_nativeint n) -> fprintf ppf "%nin" n
  | Const_pointer (n,_) -> fprintf ppf "%ia" n
  | Const_block(tag,_, []) ->
      fprintf ppf "[%i]" tag
  | Const_block(tag,_, sc1::scl) ->
      let sconsts ppf scl =
        List.iter (fun sc -> fprintf ppf "@ %a" struct_const sc) scl in
      fprintf ppf "@[<1>[%i:@ @[%a%a@]]@]" tag struct_const sc1 sconsts scl
  | Const_float_array [] ->
      fprintf ppf "[| |]"
  | Const_float_array (f1 :: fl) ->
      let floats ppf fl =
        List.iter (fun f -> fprintf ppf "@ %s" f) fl in
      fprintf ppf "@[<1>[|@[%s%a@]|]@]" f1 floats fl

let boxed_integer_name = function
  | Pnativeint -> "nativeint"
  | Pint32 -> "int32"
  | Pint64 -> "int64"

let print_boxed_integer name ppf bi =
  fprintf ppf "%s_%s" (boxed_integer_name bi) name

let print_boxed_integer_conversion ppf bi1 bi2 =
  fprintf ppf "%s_of_%s" (boxed_integer_name bi2) (boxed_integer_name bi1)

let boxed_integer_mark name = function
  | Pnativeint -> Printf.sprintf "Nativeint.%s" name
  | Pint32 -> Printf.sprintf "Int32.%s" name
  | Pint64 -> Printf.sprintf "Int64.%s" name

let print_boxed_integer name ppf bi =
  fprintf ppf "%s" (boxed_integer_mark name bi);;

let print_bigarray name unsafe kind ppf layout =
  fprintf ppf "Bigarray.%s[%s,%s]"
    (if unsafe then "unsafe_"^ name else name)
    (match kind with
     | Pbigarray_unknown -> "generic"
     | Pbigarray_float32 -> "float32"
     | Pbigarray_float64 -> "float64"
     | Pbigarray_sint8 -> "sint8"
     | Pbigarray_uint8 -> "uint8"
     | Pbigarray_sint16 -> "sint16"
     | Pbigarray_uint16 -> "uint16"
     | Pbigarray_int32 -> "int32"
     | Pbigarray_int64 -> "int64"
     | Pbigarray_caml_int -> "camlint"
     | Pbigarray_native_int -> "nativeint"
     | Pbigarray_complex32 -> "complex32"
     | Pbigarray_complex64 -> "complex64")
    (match layout with
    |  Pbigarray_unknown_layout -> "unknown"
     | Pbigarray_c_layout -> "C"
     | Pbigarray_fortran_layout -> "Fortran")

let record_rep ppf r =
  match r with
  | Record_regular -> fprintf ppf "regular"
  | Record_float -> fprintf ppf "float"
;;

let string_of_loc_kind = function
  | Loc_FILE -> "loc_FILE"
  | Loc_LINE -> "loc_LINE"
  | Loc_MODULE -> "loc_MODULE"
  | Loc_POS -> "loc_POS"
  | Loc_LOC -> "loc_LOC"

let primitive ppf = function
  | Pidentity -> fprintf ppf "id"
  | Pbytes_to_string -> fprintf ppf "bytes_to_string"
  | Pbytes_of_string -> fprintf ppf "bytes_of_string"
  | Pignore -> fprintf ppf "ignore"
  | Prevapply  -> fprintf ppf "revapply"
  | Pdirapply  -> fprintf ppf "dirapply"
  | Ploc kind -> fprintf ppf "%s" (string_of_loc_kind kind)
  | Pgetglobal id -> fprintf ppf "global %a" Ident.print id
  | Psetglobal id -> fprintf ppf "setglobal %a" Ident.print id
  | Pmakeblock(tag, _, Immutable) -> fprintf ppf "makeblock %i" tag
  | Pmakeblock(tag, _, Mutable) -> fprintf ppf "makemutable %i" tag
  | Pfield (n,_) -> fprintf ppf "field %i" n
  | Psetfield(n, ptr, _) ->
      let instr = if ptr then "setfield_ptr " else "setfield_imm " in
      fprintf ppf "%s%i" instr n
  | Pfloatfield (n,_) -> fprintf ppf "floatfield %i" n
  | Psetfloatfield (n,_) -> fprintf ppf "setfloatfield %i" n
  | Pduprecord (rep, size) -> fprintf ppf "duprecord %a %i" record_rep rep size
  | Plazyforce -> fprintf ppf "force"
  | Pccall p -> fprintf ppf "%s" p.prim_name
  | Praise k -> fprintf ppf "%s" (Lambda.raise_kind k)
  | Psequand -> fprintf ppf "&&"
  | Psequor -> fprintf ppf "||"
  | Pnot -> fprintf ppf "not"
  | Pnegint -> fprintf ppf "~"
  | Paddint -> fprintf ppf "+"
  | Psubint -> fprintf ppf "-"
  | Pmulint -> fprintf ppf "*"
  | Pdivint -> fprintf ppf "/"
  | Pmodint -> fprintf ppf "mod"
  | Pandint -> fprintf ppf "and"
  | Porint -> fprintf ppf "or"
  | Pxorint -> fprintf ppf "xor"
  | Plslint -> fprintf ppf "lsl"
  | Plsrint -> fprintf ppf "lsr"
  | Pasrint -> fprintf ppf "asr"
  | Pintcomp(Ceq) -> fprintf ppf "=="
  | Pintcomp(Cneq) -> fprintf ppf "!="
  | Pintcomp(Clt) -> fprintf ppf "<"
  | Pintcomp(Cle) -> fprintf ppf "<="
  | Pintcomp(Cgt) -> fprintf ppf ">"
  | Pintcomp(Cge) -> fprintf ppf ">="
  | Poffsetint n -> fprintf ppf "%i+" n
  | Poffsetref n -> fprintf ppf "+:=%i"n
  | Pintoffloat -> fprintf ppf "int_of_float"
  | Pfloatofint -> fprintf ppf "float_of_int"
  | Pnegfloat -> fprintf ppf "~."
  | Pabsfloat -> fprintf ppf "abs."
  | Paddfloat -> fprintf ppf "+."
  | Psubfloat -> fprintf ppf "-."
  | Pmulfloat -> fprintf ppf "*."
  | Pdivfloat -> fprintf ppf "/."
  | Pfloatcomp(Ceq) -> fprintf ppf "==."
  | Pfloatcomp(Cneq) -> fprintf ppf "!=."
  | Pfloatcomp(Clt) -> fprintf ppf "<."
  | Pfloatcomp(Cle) -> fprintf ppf "<=."
  | Pfloatcomp(Cgt) -> fprintf ppf ">."
  | Pfloatcomp(Cge) -> fprintf ppf ">=."
  | Pstringlength -> fprintf ppf "string.length"
  | Pstringrefu -> fprintf ppf "string.unsafe_get"
  | Pstringsetu -> fprintf ppf "string.unsafe_set"
  | Pstringrefs -> fprintf ppf "string.get"
  | Pstringsets -> fprintf ppf "string.set"
  | Pbyteslength -> fprintf ppf "bytes.length"
  | Pbytesrefu -> fprintf ppf "bytes.unsafe_get"
  | Pbytessetu -> fprintf ppf "bytes.unsafe_set"
  | Pbytesrefs -> fprintf ppf "bytes.get"
  | Pbytessets -> fprintf ppf "bytes.set"

  | Parraylength _ -> fprintf ppf "array.length"
  | Pmakearray _ -> fprintf ppf "makearray "
  | Parrayrefu _ -> fprintf ppf "array.unsafe_get"
  | Parraysetu _ -> fprintf ppf "array.unsafe_set"
  | Parrayrefs _ -> fprintf ppf "array.get"
  | Parraysets _ -> fprintf ppf "array.set"
  | Pctconst c ->
     let const_name = match c with
       | Big_endian -> "big_endian"
       | Word_size -> "word_size"
       | Ostype_unix -> "ostype_unix"
       | Ostype_win32 -> "ostype_win32"
       | Ostype_cygwin -> "ostype_cygwin" in
     fprintf ppf "sys.constant_%s" const_name
  | Pisint -> fprintf ppf "isint"
  | Pisout -> fprintf ppf "isout"
  | Pbittest -> fprintf ppf "testbit"
  | Pbintofint bi -> print_boxed_integer "of_int" ppf bi
  | Pintofbint bi -> print_boxed_integer "to_int" ppf bi
  | Pcvtbint (bi1, bi2) -> print_boxed_integer_conversion ppf bi1 bi2
  | Pnegbint bi -> print_boxed_integer "neg" ppf bi
  | Paddbint bi -> print_boxed_integer "add" ppf bi
  | Psubbint bi -> print_boxed_integer "sub" ppf bi
  | Pmulbint bi -> print_boxed_integer "mul" ppf bi
  | Pdivbint bi -> print_boxed_integer "div" ppf bi
  | Pmodbint bi -> print_boxed_integer "mod" ppf bi
  | Pandbint bi -> print_boxed_integer "and" ppf bi
  | Porbint bi -> print_boxed_integer "or" ppf bi
  | Pxorbint bi -> print_boxed_integer "xor" ppf bi
  | Plslbint bi -> print_boxed_integer "lsl" ppf bi
  | Plsrbint bi -> print_boxed_integer "lsr" ppf bi
  | Pasrbint bi -> print_boxed_integer "asr" ppf bi
  | Pbintcomp(bi, Ceq) -> print_boxed_integer "==" ppf bi
  | Pbintcomp(bi, Cneq) -> print_boxed_integer "!=" ppf bi
  | Pbintcomp(bi, Clt) -> print_boxed_integer "<" ppf bi
  | Pbintcomp(bi, Cgt) -> print_boxed_integer ">" ppf bi
  | Pbintcomp(bi, Cle) -> print_boxed_integer "<=" ppf bi
  | Pbintcomp(bi, Cge) -> print_boxed_integer ">=" ppf bi
  | Pbigarrayref(unsafe, n, kind, layout) ->
      print_bigarray "get" unsafe kind ppf layout
  | Pbigarrayset(unsafe, n, kind, layout) ->
      print_bigarray "set" unsafe kind ppf layout
  | Pbigarraydim(n) -> fprintf ppf "Bigarray.dim_%i" n
  | Pstring_load_16(unsafe) ->
     if unsafe then fprintf ppf "string.unsafe_get16"
     else fprintf ppf "string.get16"
  | Pstring_load_32(unsafe) ->
     if unsafe then fprintf ppf "string.unsafe_get32"
     else fprintf ppf "string.get32"
  | Pstring_load_64(unsafe) ->
     if unsafe then fprintf ppf "string.unsafe_get64"
     else fprintf ppf "string.get64"
  | Pstring_set_16(unsafe) ->
     if unsafe then fprintf ppf "string.unsafe_set16"
     else fprintf ppf "string.set16"
  | Pstring_set_32(unsafe) ->
     if unsafe then fprintf ppf "string.unsafe_set32"
     else fprintf ppf "string.set32"
  | Pstring_set_64(unsafe) ->
     if unsafe then fprintf ppf "string.unsafe_set64"
     else fprintf ppf "string.set64"
  | Pbigstring_load_16(unsafe) ->
     if unsafe then fprintf ppf "bigarray.array1.unsafe_get16"
     else fprintf ppf "bigarray.array1.get16"
  | Pbigstring_load_32(unsafe) ->
     if unsafe then fprintf ppf "bigarray.array1.unsafe_get32"
     else fprintf ppf "bigarray.array1.get32"
  | Pbigstring_load_64(unsafe) ->
     if unsafe then fprintf ppf "bigarray.array1.unsafe_get64"
     else fprintf ppf "bigarray.array1.get64"
  | Pbigstring_set_16(unsafe) ->
     if unsafe then fprintf ppf "bigarray.array1.unsafe_set16"
     else fprintf ppf "bigarray.array1.set16"
  | Pbigstring_set_32(unsafe) ->
     if unsafe then fprintf ppf "bigarray.array1.unsafe_set32"
     else fprintf ppf "bigarray.array1.set32"
  | Pbigstring_set_64(unsafe) ->
     if unsafe then fprintf ppf "bigarray.array1.unsafe_set64"
     else fprintf ppf "bigarray.array1.set64"
  | Pbswap16 -> fprintf ppf "bswap16"
  | Pbbswap(bi) -> print_boxed_integer "bswap" ppf bi
  | Pint_as_pointer -> fprintf ppf "int_as_pointer"

type print_kind = 
  | Alias 
  | Strict 
  | StrictOpt 
  | Variable 
  | Recursive 

let kind = function
  | Alias -> "a"
  | Strict -> ""
  | StrictOpt -> "o"
  | Variable -> "v" 
  | Recursive -> "r"

let to_print_kind (k : Lambda.let_kind) : print_kind = 
  match k with 
  | Alias -> Alias 
  | Strict -> Strict
  | StrictOpt -> StrictOpt
  | Variable -> Variable
  
let rec aux (acc : (print_kind * Ident.t * lambda ) list) lam = 
  match lam with 
  | Llet (str3, id3, arg3, body3) ->
      aux ((to_print_kind str3,id3, arg3)::acc) body3
  | Lletrec (bind_args, body) ->
      aux 
        (List.map (fun (id,l) -> (Recursive,id,l)) bind_args 
         @ acc) body
  | e ->  (acc , e) 

type left_var = 
    {
     kind : print_kind ;
     id : Ident.t
   }

type left = 
  | Id of left_var
  | Nop




let  flatten lam : (print_kind * Ident.t * lambda ) list * lambda = 
  match lam with 
  | Llet(str,id, arg, body) ->
      aux [to_print_kind str, id, arg] body
  | Lletrec(bind_args, body) ->
      aux 
        (List.map (fun (id,l) -> (Recursive, id,l)) bind_args) 
        body
  | _ -> assert false

        
let get_string ((id : Ident.t), (pos : int)) (env : Env.t) : string = 
  match  Env.find_module (Pident id) env with 
  | {md_type = Mty_signature signature  ; _ } -> 
      (* Env.prefix_idents, could be cached  *)
      let serializable_sigs = 
        List.filter (fun x ->
            match x with 
            | Sig_typext _ 
            | Sig_module _
            | Sig_class _ -> true
            | Sig_value(_, {val_kind = Val_prim _}) -> false
            | Sig_value _ -> true
            | _ -> false
                    ) signature  in
      (begin match List.nth  serializable_sigs  pos  with 
      | Sig_value (i,_) 
      | Sig_module (i,_,_) -> i 
      | Sig_typext (i,_,_) -> i 
      | Sig_modtype(i,_) -> i 
      | Sig_class (i,_,_) -> i 
      | Sig_class_type(i,_,_) -> i 
      | Sig_type(i,_,_) -> i 
      end).name
  | _ -> assert false



let lambda use_env env ppf v  =
  let rec lam ppf = function
  | Lvar id ->
      Ident.print ppf id
  | Lconst cst ->
      struct_const ppf cst
  | Lapply(lfun, largs, _) ->
      let lams ppf largs =
        List.iter (fun l -> fprintf ppf "@ %a" lam l) largs in
      fprintf ppf "@[<2>(apply@ %a%a)@]" lam lfun lams largs
  | Lfunction(kind, params, body) ->
      let pr_params ppf params =
        match kind with
        | Curried ->
            List.iter (fun param -> fprintf ppf "@ %a" Ident.print param) params
        | Tupled ->
            fprintf ppf " (";
            let first = ref true in
            List.iter
              (fun param ->
                if !first then first := false else fprintf ppf ",@ ";
                Ident.print ppf param)
              params;
            fprintf ppf ")" in
      fprintf ppf "@[<2>(function%a@ %a)@]" pr_params params lam body
  | Llet _ | Lletrec _ as x ->
      let args, body =   flatten x  in
      let bindings ppf id_arg_list =
        let spc = ref false in
        List.iter
          (fun (k, id, l) ->
            if !spc then fprintf ppf "@ " else spc := true;
            fprintf ppf "@[<2>%a =%s@ %a@]" Ident.print id (kind k) lam l)
          id_arg_list in
      fprintf ppf
        "@[<2>(let@ (@[<hv 1>%a@]" bindings (List.rev args);
      fprintf ppf ")@ %a)@]"  lam body
  | Lprim(Pfield (n,_), [ Lprim(Pgetglobal id,[],_)],_) when use_env ->
      fprintf ppf "%s.%s/%d" id.name (get_string (id,n) env) n

  | Lprim(Psetfield (n,_,_), [ Lprim(Pgetglobal id,[],_) ;  e ], _) when use_env  ->
      fprintf ppf "@[<2>(%s.%s/%d <- %a)@]" id.name (get_string (id,n) env) n
        lam e
  | Lprim(prim, largs,_) ->
      let lams ppf largs =
        List.iter (fun l -> fprintf ppf "@ %a" lam l) largs in
      fprintf ppf "@[<2>(%a%a)@]" primitive prim lams largs
  | Lswitch(larg, sw) ->
      let switch ppf sw =
        let spc = ref false in
        List.iter
         (fun (n, l) ->
           if !spc then fprintf ppf "@ " else spc := true;
           fprintf ppf "@[<hv 1>case int %i:@ %a@]" n lam l)
         sw.sw_consts;
        List.iter
          (fun (n, l) ->
            if !spc then fprintf ppf "@ " else spc := true;
            fprintf ppf "@[<hv 1>case tag %i:@ %a@]" n lam l)
          sw.sw_blocks ;
        begin match sw.sw_failaction with
        | None  -> ()
        | Some l ->
            if !spc then fprintf ppf "@ " else spc := true;
            fprintf ppf "@[<hv 1>default:@ %a@]" lam l
        end in
      fprintf ppf
       "@[<1>(%s %a@ @[<v 0>%a@])@]"
       (match sw.sw_failaction with None -> "switch*" | _ -> "switch")
       lam larg switch sw
  | Lstringswitch(arg, cases, default,_) ->
      let switch ppf cases =
        let spc = ref false in
        List.iter
         (fun (s, l) ->
           if !spc then fprintf ppf "@ " else spc := true;
           fprintf ppf "@[<hv 1>case \"%s\":@ %a@]" (String.escaped s) lam l)
          cases;
        begin match default with
        | Some default ->
            if !spc then fprintf ppf "@ " else spc := true;
            fprintf ppf "@[<hv 1>default:@ %a@]" lam default
        | None -> ()
        end in
      fprintf ppf
       "@[<1>(stringswitch %a@ @[<v 0>%a@])@]" lam arg switch cases
  | Lstaticraise (i, ls)  ->
      let lams ppf largs =
        List.iter (fun l -> fprintf ppf "@ %a" lam l) largs in
      fprintf ppf "@[<2>(exit@ %d%a)@]" i lams ls;
  | Lstaticcatch(lbody, (i, vars), lhandler) ->
      fprintf ppf "@[<2>(catch@ %a@;<1 -1>with (%d%a)@ %a)@]"
        lam lbody i
        (fun ppf vars -> match vars with
          | [] -> ()
          | _ ->
              List.iter
                (fun x -> fprintf ppf " %a" Ident.print x)
                vars)
        vars
        lam lhandler
  | Ltrywith(lbody, param, lhandler) ->
      fprintf ppf "@[<2>(try@ %a@;<1 -1>with %a@ %a)@]"
        lam lbody Ident.print param lam lhandler
  | Lifthenelse(lcond, lif, lelse) ->
      fprintf ppf "@[<2>(if@ %a@ %a@ %a)@]" lam lcond lam lif lam lelse
  | Lsequence(l1, l2) ->
      fprintf ppf "@[<2>(seq@ %a@ %a)@]" lam l1 sequence l2
  | Lwhile(lcond, lbody) ->
      fprintf ppf "@[<2>(while@ %a@ %a)@]" lam lcond lam lbody
  | Lfor(param, lo, hi, dir, body) ->
      fprintf ppf "@[<2>(for %a@ %a@ %s@ %a@ %a)@]"
       Ident.print param lam lo
       (match dir with Upto -> "to" | Downto -> "downto")
       lam hi lam body
  | Lassign(id, expr) ->
      fprintf ppf "@[<2>(assign@ %a@ %a)@]" Ident.print id lam expr
  | Lsend (k, met, obj, largs, _) ->
      let args ppf largs =
        List.iter (fun l -> fprintf ppf "@ %a" lam l) largs in
      let kind =
        if k = Self then "self" else if k = Cached then "cache" else "" in
      fprintf ppf "@[<2>(send%s@ %a@ %a%a)@]" kind lam obj lam met args largs
  | Levent(expr, ev) ->
       let kind = 
        match ev.lev_kind with 
        | Lev_before -> "before" 
        | Lev_after _  -> "after" 
        | Lev_function -> "funct-body" in 
       fprintf ppf "@[<2>(%s %s(%i)%s:%i-%i@ %a)@]" kind 
               ev.lev_loc.Location.loc_start.Lexing.pos_fname 
               ev.lev_loc.Location.loc_start.Lexing.pos_lnum 
               (if ev.lev_loc.Location.loc_ghost then "<ghost>" else "") 
               ev.lev_loc.Location.loc_start.Lexing.pos_cnum 
               ev.lev_loc.Location.loc_end.Lexing.pos_cnum 
               lam expr 
  | Lifused(id, expr) ->
      fprintf ppf "@[<2>(ifused@ %a@ %a)@]" Ident.print id lam expr

and sequence ppf = function
  | Lsequence(l1, l2) ->
      fprintf ppf "%a@ %a" sequence l1 sequence l2
  | l ->
      lam ppf l
  in 
  lam ppf v

let structured_constant = struct_const

let env_lambda = lambda true 
let lambda = lambda false Env.empty

let rec flatten_seq acc lam =
  match lam with 
  | Lsequence(l1,l2) -> 
      flatten_seq (flatten_seq acc l1) l2
  | x -> x :: acc 

exception Not_a_module

let rec flat (acc : (left * lambda) list ) (lam : lambda) = 
  match lam with 
  | Llet (str,id,arg,body) ->
      flat ( (Id {kind = to_print_kind str;  id}, arg) :: acc) body 
  | Lletrec (bind_args, body) ->
      flat ( List.map (fun (id, arg ) -> (Id {kind = Recursive;  id}, arg)) bind_args @ acc) body 
  | Lsequence (l,r) -> 
      flat (flat acc l) r
  | x -> (Nop, x) :: acc 

let lambda_as_module env  ppf lam = 
  try
  match lam with
  | Lprim(Psetglobal(id), [biglambda],_)  (* might be wrong in toplevel *) ->
      
      begin match flat [] biglambda  with 
      | (Nop, Lprim (Pmakeblock (_, _, _), toplevels,_)) :: rest ->
          (* let spc = ref false in *)
          List.iter
            (fun (left, l) ->
              match left with 
              | Id { kind = k; id } ->
                  fprintf ppf "@[<2>%a =%s@ %a@]@." Ident.print id (kind k) (env_lambda env) l
              | Nop -> 

                  fprintf ppf "@[<2>%a@]@."   (env_lambda env) l
            )

            @@ List.rev rest
          
          
      | _ -> raise Not_a_module
      end
  | _ -> raise Not_a_module
  with _ -> 
    env_lambda env ppf lam;
    fprintf ppf "; lambda-failure"
let seriaize env (filename : string) (lam : Lambda.lambda) : unit =
  let ou = open_out filename  in
  let old = Format.get_margin () in
  let () = Format.set_margin 10000 in
  let fmt = Format.formatter_of_out_channel ou in
  begin
    (* lambda_as_module env fmt lambda; *)
    lambda fmt lam;
    Format.pp_print_flush fmt ();
    close_out ou;
    Format.set_margin old
  end

let serialize_raw_js = ref(fun _ _ _ _ -> ())    
let serialize_js = ref (fun _ _ _ -> ())

end
module Switch : sig 
#1 "switch.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Luc Maranget, projet Moscova, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 2000 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(*
  This module transforms generic switches in combinations
  of if tests and switches.
*)

(* For detecting action sharing, object style *)

(* Store for actions in object style:
  act_store : store an action, returns index in table
              In case an action with equal key exists, returns index
              of the stored action. Otherwise add entry in table.
  act_store_shared : This stored action will always be shared.
  act_get   : retrieve table
  act_get_shared : retrieve table, with sharing explicit
*)

type 'a shared = Shared of 'a | Single of 'a

type 'a t_store =
    {act_get : unit -> 'a array ;
     act_get_shared : unit -> 'a shared array ;
     act_store : 'a -> int ;
     act_store_shared : 'a -> int ; }

exception Not_simple

module type Stored = sig
  type t
  type key
  val make_key : t -> key option
end

module Store(A:Stored) :
    sig
      val mk_store : unit -> A.t t_store
    end

(* Arguments to the Make functor *)
module type S =
  sig
    (* type of basic tests *)
    type primitive
    (* basic tests themselves *)
    val eqint : primitive
    val neint : primitive
    val leint : primitive
    val ltint : primitive
    val geint : primitive
    val gtint : primitive
    (* type of actions *)
    type act

    (* Various constructors, for making a binder,
        adding one integer, etc. *)
    val bind : act -> (act -> act) -> act
    val make_const : int -> act
    val make_offset : act -> int -> act
    val make_prim : primitive -> act list -> act
    val make_isout : act -> act -> act
    val make_isin : act -> act -> act
    val make_if : act -> act -> act -> act
   (* construct an actual switch :
      make_switch arg cases acts
      NB:  cases is in the value form *)
    val make_switch :
        act -> int array -> act array -> act
   (* Build last minute sharing of action stuff *)
   val make_catch : act -> int * (act -> act)
   val make_exit : int -> act

  end


(*
  Make.zyva arg low high cases actions where
    - arg is the argument of the switch.
    - low, high are the interval limits.
    - cases is a list of sub-interval and action indices
    - actions is an array of actions.

  All these arguments specify a switch construct and zyva
  returns an action that performs the switch,
*)
module Make :
  functor (Arg : S) ->
    sig
(* Standard entry point, sharing is tracked *)
      val zyva :
          (int * int) ->
           Arg.act ->
           (int * int * int) array ->
           Arg.act t_store ->
           Arg.act

(* Output test sequence, sharing tracked *)
     val test_sequence :
           Arg.act ->
           (int * int * int) array ->
           Arg.act t_store ->
           Arg.act
    end

end = struct
#1 "switch.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Luc Maranget, projet Moscova, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 2000 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)


type 'a shared = Shared of 'a | Single of 'a

let share_out = function
  | Shared act|Single act -> act


type 'a t_store =
    {act_get : unit -> 'a array ;
     act_get_shared : unit -> 'a shared array ;
     act_store : 'a -> int ;
     act_store_shared : 'a -> int ; }

exception Not_simple

module type Stored = sig
  type t
  type key
  val make_key : t -> key option
end

module Store(A:Stored) = struct
  module AMap =
    Map.Make(struct type t = A.key let compare = Pervasives.compare end)

  type intern =
      { mutable map : (bool * int)  AMap.t ;
        mutable next : int ;
        mutable acts : (bool * A.t) list; }

  let mk_store () =
    let st =
      { map = AMap.empty ;
        next = 0 ;
        acts = [] ; } in

    let add mustshare act =
      let i = st.next in
      st.acts <- (mustshare,act) :: st.acts ;
      st.next <- i+1 ;
      i in

    let store mustshare act = match A.make_key act with
    | Some key ->
        begin try
          let (shared,i) = AMap.find key st.map in
          if not shared then st.map <- AMap.add key (true,i) st.map ;
          i
        with Not_found ->
          let i = add mustshare act in
          st.map <- AMap.add key (mustshare,i) st.map ;
          i
        end
    | None ->
        add mustshare act

    and get () = Array.of_list (List.rev_map (fun (_,act) -> act) st.acts)

    and get_shared () =
      let acts =
        Array.of_list
          (List.rev_map
             (fun (shared,act) ->
               if shared then Shared act else Single act)
             st.acts) in
      AMap.iter
        (fun _ (shared,i) ->
          if shared then match acts.(i) with
          | Single act -> acts.(i) <- Shared act
          | Shared _ -> ())
        st.map ;
      acts in
    {act_store = store false ; act_store_shared = store true ;
     act_get = get; act_get_shared = get_shared; }
end



module type S =
 sig
   type primitive
   val eqint : primitive
   val neint : primitive
   val leint : primitive
   val ltint : primitive
   val geint : primitive
   val gtint : primitive
   type act

   val bind : act -> (act -> act) -> act
   val make_const : int -> act
   val make_offset : act -> int -> act
   val make_prim : primitive -> act list -> act
   val make_isout : act -> act -> act
   val make_isin : act -> act -> act
   val make_if : act -> act -> act -> act
   val make_switch : act -> int array -> act array -> act
   val make_catch : act -> int * (act -> act)
   val make_exit : int -> act
 end

(* The module will ``produce good code for the case statement'' *)
(*
  Adaptation of
   R.L. Berstein
   ``Producing good code for the case statement''
   Sofware Practice and Experience, 15(10) (1985)
 and
   D.L. Spuler
    ``Two-Way Comparison Search Trees, a Generalisation of Binary Search Trees
      and Split Trees''
    ``Compiler Code Generation for Multiway Branch Statement as
      a Static Search Problem''
   Technical Reports, James Cook University
*)
(*
  Main adaptation is considering interval tests
 (implemented as one addition + one unsigned test and branch)
  which leads to exhaustive search for finding the optimal
  test sequence in small cases and heuristics otherwise.
*)
module Make (Arg : S) =
  struct

    type 'a inter =
        {cases : (int * int * int) array ;
          actions : 'a array}

type 'a t_ctx =  {off : int ; arg : 'a}

let cut = ref 8
and more_cut = ref 16

let pint chan i =
  if i = min_int then Printf.fprintf chan "-oo"
  else if i=max_int then Printf.fprintf chan "oo"
  else Printf.fprintf chan "%d" i

let pcases chan cases =
  for i =0 to Array.length cases-1 do
    let l,h,act = cases.(i) in
    if l=h then
      Printf.fprintf chan "%d:%d " l act
    else
      Printf.fprintf chan "%a..%a:%d " pint l pint h act
  done

    let prerr_inter i = Printf.fprintf stderr
        "cases=%a" pcases i.cases

let get_act cases i =
  let _,_,r = cases.(i) in
  r
and get_low cases i =
  let r,_,_ = cases.(i) in
  r

type ctests = {
    mutable n : int ;
    mutable ni : int ;
  }

let too_much = {n=max_int ; ni=max_int}

let ptests chan {n=n ; ni=ni} =
  Printf.fprintf chan "{n=%d ; ni=%d}" n ni

let pta chan t =
  for i =0 to Array.length t-1 do
    Printf.fprintf chan "%d: %a\n" i ptests t.(i)
  done

let count_tests s =
  let r =
    Array.init
      (Array.length s.actions)
      (fun _ -> {n=0 ; ni=0 }) in
  let c = s.cases in
  let imax = Array.length c-1 in
  for i=0 to imax do
    let l,h,act = c.(i) in
    let x = r.(act) in
    x.n <- x.n+1 ;
    if l < h && i<> 0 && i<>imax then
      x.ni <- x.ni+1 ;
  done ;
  r


let less_tests c1 c2 =
  if c1.n < c2.n then
    true
  else if c1.n = c2.n then begin
    if c1.ni < c2.ni then
      true
    else
      false
  end else
    false

and eq_tests c1 c2 = c1.n = c2.n && c1.ni=c2.ni

let min_tests c1 c2 = if less_tests c1 c2 then c1 else c2

let less2tests (c1,d1) (c2,d2) =
  if eq_tests c1 c2 then
    less_tests d1 d2
  else
    less_tests c1 c2

let add_test t1 t2 =
  t1.n <- t1.n + t2.n ;
  t1.ni <- t1.ni + t2.ni ;

type t_ret = Inter of int * int  | Sep of int | No

let pret chan = function
  | Inter (i,j)-> Printf.fprintf chan "Inter %d %d" i j
  | Sep i -> Printf.fprintf chan "Sep %d" i
  | No -> Printf.fprintf chan "No"

let coupe cases i =
  let l,_,_ = cases.(i) in
  l,
  Array.sub cases 0 i,
  Array.sub cases i (Array.length cases-i)


let case_append c1 c2 =
  let len1 = Array.length c1
  and len2 = Array.length c2 in
  match len1,len2 with
  | 0,_ -> c2
  | _,0 -> c1
  | _,_ ->
      let l1,h1,act1 = c1.(Array.length c1-1)
      and l2,h2,act2 = c2.(0) in
      if act1 = act2 then
        let r = Array.make (len1+len2-1) c1.(0) in
        for i = 0 to len1-2 do
          r.(i) <- c1.(i)
        done ;

        let l =
          if len1-2 >= 0 then begin
            let _,h,_ = r.(len1-2) in
            if h+1 < l1 then
              h+1
            else
              l1
          end else
            l1
        and h =
          if 1 < len2-1 then begin
            let l,_,_ = c2.(1) in
            if h2+1 < l then
              l-1
            else
              h2
          end else
            h2 in
        r.(len1-1) <- (l,h,act1) ;
        for i=1 to len2-1  do
          r.(len1-1+i) <- c2.(i)
        done ;
        r
      else if h1 > l1 then
        let r = Array.make (len1+len2) c1.(0) in
        for i = 0 to len1-2 do
          r.(i) <- c1.(i)
        done ;
        r.(len1-1) <- (l1,l2-1,act1) ;
        for i=0 to len2-1  do
          r.(len1+i) <- c2.(i)
        done ;
        r
      else if h2 > l2 then
        let r = Array.make (len1+len2) c1.(0) in
        for i = 0 to len1-1 do
          r.(i) <- c1.(i)
        done ;
        r.(len1) <- (h1+1,h2,act2) ;
        for i=1 to len2-1  do
          r.(len1+i) <- c2.(i)
        done ;
        r
      else
        Array.append c1 c2


let coupe_inter i j cases =
  let lcases = Array.length cases in
  let low,_,_ = cases.(i)
  and _,high,_ = cases.(j) in
  low,high,
  Array.sub cases i (j-i+1),
  case_append (Array.sub cases 0 i) (Array.sub cases (j+1) (lcases-(j+1)))

type kind = Kvalue of int | Kinter of int | Kempty

let pkind chan = function
  | Kvalue i ->Printf.fprintf chan "V%d" i
  | Kinter i -> Printf.fprintf chan "I%d" i
  | Kempty -> Printf.fprintf chan "E"

let rec pkey chan  = function
  | [] -> ()
  | [k] -> pkind chan k
  | k::rem ->
      Printf.fprintf chan "%a %a" pkey rem pkind k

let t = Hashtbl.create 17

let make_key  cases =
  let seen = ref []
  and count = ref 0 in
  let rec got_it act = function
    | [] ->
        seen := (act,!count):: !seen ;
        let r = !count in
        incr count ;
        r
    | (act0,index) :: rem ->
        if act0 = act then
          index
        else
          got_it act rem in

  let make_one l h act =
    if l=h then
      Kvalue (got_it act !seen)
    else
      Kinter (got_it act !seen) in

  let rec make_rec i pl =
    if i < 0 then
      []
    else
      let l,h,act = cases.(i) in
      if pl = h+1 then
        make_one l h act::make_rec (i-1) l
      else
        Kempty::make_one l h act::make_rec (i-1) l in

  let l,h,act = cases.(Array.length cases-1) in
  make_one l h act::make_rec (Array.length cases-2) l


    let same_act t =
      let len = Array.length t in
      let a = get_act t (len-1) in
      let rec do_rec i =
        if i < 0 then true
        else
          let b = get_act t i in
          b=a && do_rec (i-1) in
      do_rec (len-2)


(*
  Intervall test x in [l,h] works by checking x-l in [0,h-l]
   * This may be false for arithmetic modulo 2^31
   * Subtracting l may change the relative ordering of values
     and invalid the invariant that matched values are given in
     increasing order

   To avoid this, interval check is allowed only when the
   integers indeed present in the whole case interval are
   in [-2^16 ; 2^16]

   This condition is checked by zyva
*)

let inter_limit = 1 lsl 16

let ok_inter = ref false

let rec opt_count top cases =
  let key = make_key cases in
  try
    let r = Hashtbl.find t key in
    r
  with
  | Not_found ->
      let r =
        let lcases = Array.length cases in
        match lcases with
        | 0 -> assert false
        | _ when same_act cases -> No, ({n=0; ni=0},{n=0; ni=0})
        | _ ->
            if lcases < !cut then
              enum top cases
            else if lcases < !more_cut then
              heuristic top cases
            else
              divide top cases in
      Hashtbl.add t key r ;
      r

and divide top cases =
  let lcases = Array.length cases in
  let m = lcases/2 in
  let _,left,right = coupe cases m in
  let ci = {n=1 ; ni=0}
  and cm = {n=1 ; ni=0}
  and _,(cml,cleft) = opt_count false left
  and _,(cmr,cright) = opt_count false right in
  add_test ci cleft ;
  add_test ci cright ;
  if less_tests cml cmr then
    add_test cm cmr
  else
    add_test cm cml ;
  Sep m,(cm, ci)

and heuristic top cases =
  let lcases = Array.length cases in

  let sep,csep = divide false cases

  and inter,cinter =
    if !ok_inter then begin
      let _,_,act0 = cases.(0)
      and _,_,act1 = cases.(lcases-1) in
      if act0 = act1 then begin
        let low, high, inside, outside = coupe_inter 1 (lcases-2) cases in
        let _,(cmi,cinside) = opt_count false inside
        and _,(cmo,coutside) = opt_count false outside
        and cmij = {n=1 ; ni=(if low=high then 0 else 1)}
        and cij = {n=1 ; ni=(if low=high then 0 else 1)} in
        add_test cij cinside ;
        add_test cij coutside ;
        if less_tests cmi cmo then
          add_test cmij cmo
        else
          add_test cmij cmi ;
        Inter (1,lcases-2),(cmij,cij)
      end else
        Inter (-1,-1),(too_much, too_much)
    end else
      Inter (-1,-1),(too_much, too_much) in
  if less2tests csep cinter then
    sep,csep
  else
    inter,cinter


and enum top cases =
  let lcases = Array.length cases in
  let lim, with_sep =
    let best = ref (-1) and best_cost = ref (too_much,too_much) in

    for i = 1 to lcases-(1) do
      let _,left,right = coupe cases i in
      let ci = {n=1 ; ni=0}
      and cm = {n=1 ; ni=0}
      and _,(cml,cleft) = opt_count false left
      and _,(cmr,cright) = opt_count false right in
      add_test ci cleft ;
      add_test ci cright ;
      if less_tests cml cmr then
        add_test cm cmr
      else
        add_test cm cml ;

      if
        less2tests (cm,ci) !best_cost
      then begin
        if top then
          Printf.fprintf stderr "Get it: %d\n" i ;
        best := i ;
        best_cost := (cm,ci)
      end
    done ;
    !best, !best_cost in

  let ilow, ihigh, with_inter =
    if not !ok_inter then
      let rlow = ref (-1) and rhigh = ref (-1)
      and best_cost= ref (too_much,too_much) in
      for i=1 to lcases-2 do
        let low, high, inside, outside = coupe_inter i i cases in
         if low=high then begin
           let _,(cmi,cinside) = opt_count false inside
           and _,(cmo,coutside) = opt_count false outside
           and cmij = {n=1 ; ni=0}
           and cij = {n=1 ; ni=0} in
           add_test cij cinside ;
           add_test cij coutside ;
           if less_tests cmi cmo then
             add_test cmij cmo
           else
             add_test cmij cmi ;
           if less2tests (cmij,cij) !best_cost then begin
             rlow := i ;
             rhigh := i ;
             best_cost := (cmij,cij)
           end
         end
      done ;
      !rlow, !rhigh, !best_cost
    else
      let rlow = ref (-1) and rhigh = ref (-1)
      and best_cost= ref (too_much,too_much) in
      for i=1 to lcases-2 do
        for j=i to lcases-2 do
          let low, high, inside, outside = coupe_inter i j cases in
          let _,(cmi,cinside) = opt_count false inside
          and _,(cmo,coutside) = opt_count false outside
          and cmij = {n=1 ; ni=(if low=high then 0 else 1)}
          and cij = {n=1 ; ni=(if low=high then 0 else 1)} in
          add_test cij cinside ;
          add_test cij coutside ;
          if less_tests cmi cmo then
            add_test cmij cmo
          else
            add_test cmij cmi ;
          if less2tests (cmij,cij) !best_cost then begin
            rlow := i ;
            rhigh := j ;
            best_cost := (cmij,cij)
          end
        done
      done ;
      !rlow, !rhigh, !best_cost in
  let r = ref (Inter (ilow,ihigh)) and rc = ref with_inter in
  if less2tests with_sep !rc then begin
    r := Sep lim ; rc := with_sep
  end ;
  !r, !rc

    let make_if_test test arg i ifso ifnot =
      Arg.make_if
        (Arg.make_prim test [arg ; Arg.make_const i])
        ifso ifnot

    let make_if_lt arg i  ifso ifnot = match i with
    | 1 ->
        make_if_test Arg.leint arg 0 ifso ifnot
    | _ ->
        make_if_test Arg.ltint arg i ifso ifnot

    and make_if_le arg i ifso ifnot = match i with
    | -1 ->
        make_if_test Arg.ltint arg 0 ifso ifnot
    | _ ->
        make_if_test Arg.leint arg i ifso ifnot

    and make_if_gt arg i  ifso ifnot = match i with
    | -1 ->
        make_if_test Arg.geint arg 0 ifso ifnot
    | _ ->
        make_if_test Arg.gtint arg i ifso ifnot

    and make_if_ge arg i  ifso ifnot = match i with
    | 1 ->
        make_if_test Arg.gtint arg 0 ifso ifnot
    | _ ->
        make_if_test Arg.geint arg i ifso ifnot

    and make_if_eq  arg i ifso ifnot =
      make_if_test Arg.eqint arg i ifso ifnot

    and make_if_ne  arg i ifso ifnot =
      make_if_test Arg.neint arg i ifso ifnot

    let do_make_if_out h arg ifso ifno =
      Arg.make_if (Arg.make_isout h arg) ifso ifno

    let make_if_out ctx l d mk_ifso mk_ifno = match l with
    | 0 ->
        do_make_if_out
          (Arg.make_const d) ctx.arg (mk_ifso ctx) (mk_ifno ctx)
    | _ ->
        Arg.bind
          (Arg.make_offset ctx.arg (-l))
          (fun arg ->
            let ctx = {off= (-l+ctx.off) ; arg=arg} in
            do_make_if_out
              (Arg.make_const d) arg (mk_ifso ctx) (mk_ifno ctx))

    let do_make_if_in h arg ifso ifno =
      Arg.make_if (Arg.make_isin h arg) ifso ifno

    let make_if_in ctx l d mk_ifso mk_ifno = match l with
    | 0 ->
        do_make_if_in
          (Arg.make_const d) ctx.arg (mk_ifso ctx) (mk_ifno ctx)
    | _ ->
        Arg.bind
          (Arg.make_offset ctx.arg (-l))
          (fun arg ->
            let ctx = {off= (-l+ctx.off) ; arg=arg} in
            do_make_if_in
              (Arg.make_const d) arg (mk_ifso ctx) (mk_ifno ctx))

    let rec c_test ctx ({cases=cases ; actions=actions} as s) =
      let lcases = Array.length cases in
      assert(lcases > 0) ;
      if lcases = 1 then
        actions.(get_act cases 0) ctx

      else begin

        let w,c = opt_count false cases in
(*
  Printf.fprintf stderr
  "off=%d tactic=%a for %a\n"
  ctx.off pret w pcases cases ;
  *)
    match w with
    | No -> actions.(get_act cases 0) ctx
    | Inter (i,j) ->
        let low,high,inside, outside = coupe_inter i j cases in
        let _,(cinside,_) = opt_count false inside
        and _,(coutside,_) = opt_count false outside in
(* Costs are retrieved to put the code with more remaining tests
   in the privileged (positive) branch of ``if'' *)
        if low=high then begin
          if less_tests coutside cinside then
            make_if_eq
              ctx.arg
              (low+ctx.off)
              (c_test ctx {s with cases=inside})
              (c_test ctx {s with cases=outside})
          else
            make_if_ne
              ctx.arg
              (low+ctx.off)
              (c_test ctx {s with cases=outside})
              (c_test ctx {s with cases=inside})
        end else begin
          if less_tests coutside cinside then
            make_if_in
              ctx
              (low+ctx.off)
              (high-low)
              (fun ctx -> c_test ctx {s with cases=inside})
              (fun ctx -> c_test ctx {s with cases=outside})
          else
            make_if_out
              ctx
              (low+ctx.off)
              (high-low)
              (fun ctx -> c_test ctx {s with cases=outside})
              (fun ctx -> c_test ctx {s with cases=inside})
        end
    | Sep i ->
        let lim,left,right = coupe cases i in
        let _,(cleft,_) = opt_count false left
        and _,(cright,_) = opt_count false right in
        let left = {s with cases=left}
        and right = {s with cases=right} in

        if i=1 && (lim+ctx.off)=1 && get_low cases 0+ctx.off=0 then
          make_if_ne
            ctx.arg 0
            (c_test ctx right) (c_test ctx left)
        else if less_tests cright cleft then
          make_if_lt
            ctx.arg (lim+ctx.off)
            (c_test ctx left) (c_test ctx right)
        else
          make_if_ge
             ctx.arg (lim+ctx.off)
            (c_test ctx right) (c_test ctx left)

  end


(* Minimal density of switches *)
let theta = ref 0.33333

(* Minmal number of tests to make a switch *)
let switch_min = ref 3

(* Particular case 0, 1, 2 *)
let particular_case cases i j =
  j-i = 2 &&
  (let l1,h1,act1 = cases.(i)
  and  l2,h2,act2 = cases.(i+1)
  and  l3,h3,act3 = cases.(i+2) in
  l1+1=l2 && l2+1=l3 && l3=h3 &&
  act1 <> act3)

let approx_count cases i j n_actions =
  let l = j-i+1 in
  if l < !cut then
     let _,(_,{n=ntests}) = opt_count false (Array.sub cases i l) in
     ntests
  else
    l-1

(* Sends back a boolean that says whether is switch is worth or not *)

let dense {cases=cases ; actions=actions} i j =
  if i=j then true
  else
    let l,_,_ = cases.(i)
    and _,h,_ = cases.(j) in
    let ntests =  approx_count cases i j (Array.length actions) in
(*
  (ntests+1) >= theta * (h-l+1)
*)
    particular_case cases i j ||
    (ntests >= !switch_min &&
    float_of_int ntests +. 1.0 >=
    !theta *. (float_of_int h -. float_of_int l +. 1.0))

(* Compute clusters by dynamic programming
   Adaptation of the correction to Bernstein
   ``Correction to `Producing Good Code for the Case Statement' ''
   S.K. Kannan and T.A. Proebsting
   Software Practice and Exprience Vol. 24(2) 233 (Feb 1994)
*)

let comp_clusters ({cases=cases ; actions=actions} as s) =
  let len = Array.length cases in
  let min_clusters = Array.make len max_int
  and k = Array.make len 0 in
  let get_min i = if i < 0 then 0 else min_clusters.(i) in

  for i = 0 to len-1 do
    for j = 0 to i do
      if
        dense s j i &&
        get_min (j-1) + 1 < min_clusters.(i)
      then begin
        k.(i) <- j ;
        min_clusters.(i) <- get_min (j-1) + 1
      end
    done ;
  done ;
  min_clusters.(len-1),k

(* Assume j > i *)
let make_switch  {cases=cases ; actions=actions} i j =
  let ll,_,_ = cases.(i)
  and _,hh,_ = cases.(j) in
  let tbl = Array.make (hh-ll+1) 0
  and t = Hashtbl.create 17
  and index = ref 0 in
  let get_index act =
    try
      Hashtbl.find t act
    with
    | Not_found ->
        let i = !index in
        incr index ;
        Hashtbl.add t act i ;
        i in

  for k=i to j do
    let l,h,act = cases.(k) in
    let index = get_index act in
    for kk=l-ll to h-ll do
      tbl.(kk) <- index
    done
  done ;
  let acts = Array.make !index actions.(0) in
  Hashtbl.iter
    (fun act i -> acts.(i) <- actions.(act))
    t ;
  (fun ctx ->
    match -ll-ctx.off with
    | 0 -> Arg.make_switch ctx.arg tbl acts
    | _ ->
        Arg.bind
          (Arg.make_offset ctx.arg (-ll-ctx.off))
          (fun arg -> Arg.make_switch arg tbl acts))


let make_clusters ({cases=cases ; actions=actions} as s) n_clusters k =
  let len = Array.length cases in
  let r = Array.make n_clusters (0,0,0)
  and t = Hashtbl.create 17
  and index = ref 0
  and bidon = ref (Array.length actions) in
  let get_index act =
    try
      let i,_ = Hashtbl.find t act in
      i
    with
    | Not_found ->
        let i = !index in
        incr index ;
        Hashtbl.add
          t act
          (i,(fun _ -> actions.(act))) ;
        i
  and add_index act =
    let i = !index in
    incr index ;
    incr bidon ;
    Hashtbl.add t !bidon (i,act) ;
    i in

  let rec zyva j ir =
    let i = k.(j) in
    begin if i=j then
      let l,h,act = cases.(i) in
      r.(ir) <- (l,h,get_index act)
    else (* assert i < j *)
      let l,_,_ = cases.(i)
      and _,h,_ = cases.(j) in
      r.(ir) <- (l,h,add_index (make_switch s i j))
    end ;
    if i > 0 then zyva (i-1) (ir-1) in

  zyva (len-1) (n_clusters-1) ;
  let acts = Array.make !index (fun _ -> assert false) in
  Hashtbl.iter (fun _ (i,act) -> acts.(i) <- act) t ;
  {cases = r ; actions = acts}
;;


let do_zyva (low,high) arg cases actions =
  let old_ok = !ok_inter in
  ok_inter := (abs low <= inter_limit && abs high <= inter_limit) ;
  if !ok_inter <> old_ok then Hashtbl.clear t ;

  let s = {cases=cases ; actions=actions} in
(*
  Printf.eprintf "ZYVA: %b\n" !ok_inter ;
  pcases stderr cases ;
  prerr_endline "" ;
*)
  let n_clusters,k = comp_clusters s in
  let clusters = make_clusters s n_clusters k in
  let r = c_test {arg=arg ; off=0} clusters in
  r

let abstract_shared actions =
  let handlers = ref (fun x -> x) in
  let actions =
    Array.map
      (fun act -> match  act with
      | Single act -> act
      | Shared act ->
          let i,h = Arg.make_catch act in
          let oh = !handlers in
          handlers := (fun act -> h (oh act)) ;
          Arg.make_exit i)
      actions in
  !handlers,actions

let zyva lh arg cases actions =
  let actions = actions.act_get_shared () in
  let hs,actions = abstract_shared actions in
  hs (do_zyva lh arg cases actions)

and test_sequence arg cases actions =
  let actions = actions.act_get_shared () in
  let hs,actions = abstract_shared actions in
  let old_ok = !ok_inter in
  ok_inter := false ;
  if !ok_inter <> old_ok then Hashtbl.clear t ;
  let s =
    {cases=cases ;
    actions=Array.map (fun act -> (fun _ -> act)) actions} in
(*
  Printf.eprintf "SEQUENCE: %b\n" !ok_inter ;
  pcases stderr cases ;
  prerr_endline "" ;
*)
  hs (c_test {arg=arg ; off=0} s)
;;

end

end
module Typeopt : sig 
#1 "typeopt.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Auxiliaries for type-based optimizations, e.g. array kinds *)

val has_base_type : Typedtree.expression -> Path.t -> bool
val maybe_pointer : Typedtree.expression -> bool
val array_kind : Typedtree.expression -> Lambda.array_kind
val array_pattern_kind : Typedtree.pattern -> Lambda.array_kind
val bigarray_kind_and_layout :
      Typedtree.expression -> Lambda.bigarray_kind * Lambda.bigarray_layout

end = struct
#1 "typeopt.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Auxiliaries for type-based optimizations, e.g. array kinds *)

open Path
open Types
open Typedtree
open Lambda

let scrape env ty =
  (Ctype.repr (Ctype.expand_head_opt env (Ctype.correct_levels ty))).desc

let has_base_type exp base_ty_path =
  match scrape exp.exp_env exp.exp_type with
  | Tconstr(p, _, _) -> Path.same p base_ty_path
  | _ -> false

let maybe_pointer exp =
  match scrape exp.exp_env exp.exp_type with
  | Tconstr(p, args, abbrev) ->
      not (Path.same p Predef.path_int) &&
      not (Path.same p Predef.path_char) &&
      begin try
        match Env.find_type p exp.exp_env with
        | {type_kind = Type_variant []} -> true (* type exn *)
        | {type_kind = Type_variant cstrs} ->
            List.exists (fun c -> c.Types.cd_args <> []) cstrs
        | _ -> true
      with Not_found -> true
        (* This can happen due to e.g. missing -I options,
           causing some .cmi files to be unavailable.
           Maybe we should emit a warning. *)
      end
  | _ -> true

let array_element_kind env ty =
  match scrape env ty with
  | Tvar _ | Tunivar _ ->
      Pgenarray
  | Tconstr(p, args, abbrev) ->
      if Path.same p Predef.path_int || Path.same p Predef.path_char then
        Pintarray
      else if Path.same p Predef.path_float then
        Pfloatarray
      else if Path.same p Predef.path_string
           || Path.same p Predef.path_array
           || Path.same p Predef.path_nativeint
           || Path.same p Predef.path_int32
           || Path.same p Predef.path_int64 then
        Paddrarray
      else begin
        try
          match Env.find_type p env with
            {type_kind = Type_abstract} ->
              Pgenarray
          | {type_kind = Type_variant cstrs}
            when List.for_all (fun c -> c.Types.cd_args = []) cstrs ->
              Pintarray
          | {type_kind = _} ->
              Paddrarray
        with Not_found ->
          (* This can happen due to e.g. missing -I options,
             causing some .cmi files to be unavailable.
             Maybe we should emit a warning. *)
          Pgenarray
      end
  | _ ->
      Paddrarray

let array_kind_gen ty env =
  match scrape env ty with
  | Tconstr(p, [elt_ty], _) | Tpoly({desc = Tconstr(p, [elt_ty], _)}, _)
    when Path.same p Predef.path_array ->
      array_element_kind env elt_ty
  | _ ->
      (* This can happen with e.g. Obj.field *)
      Pgenarray

let array_kind exp = array_kind_gen exp.exp_type exp.exp_env

let array_pattern_kind pat = array_kind_gen pat.pat_type pat.pat_env

let bigarray_decode_type env ty tbl dfl =
  match scrape env ty with
  | Tconstr(Pdot(Pident mod_id, type_name, _), [], _)
    when Ident.name mod_id = "Bigarray" ->
      begin try List.assoc type_name tbl with Not_found -> dfl end
  | _ ->
      dfl

let kind_table =
  ["float32_elt", Pbigarray_float32;
   "float64_elt", Pbigarray_float64;
   "int8_signed_elt", Pbigarray_sint8;
   "int8_unsigned_elt", Pbigarray_uint8;
   "int16_signed_elt", Pbigarray_sint16;
   "int16_unsigned_elt", Pbigarray_uint16;
   "int32_elt", Pbigarray_int32;
   "int64_elt", Pbigarray_int64;
   "int_elt", Pbigarray_caml_int;
   "nativeint_elt", Pbigarray_native_int;
   "complex32_elt", Pbigarray_complex32;
   "complex64_elt", Pbigarray_complex64]

let layout_table =
  ["c_layout", Pbigarray_c_layout;
   "fortran_layout", Pbigarray_fortran_layout]

let bigarray_kind_and_layout exp =
  match scrape exp.exp_env exp.exp_type with
  | Tconstr(p, [caml_type; elt_type; layout_type], abbrev) ->
      (bigarray_decode_type exp.exp_env elt_type kind_table Pbigarray_unknown,
       bigarray_decode_type exp.exp_env layout_type layout_table
                            Pbigarray_unknown_layout)
  | _ ->
      (Pbigarray_unknown, Pbigarray_unknown_layout)

end
module Matching : sig 
#1 "matching.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Compilation of pattern-matching *)

open Typedtree
open Lambda


(* Entry points to match compiler *)
val for_function:
        Location.t -> int ref option -> lambda -> (pattern * lambda) list ->
        partial -> lambda
val for_trywith:
        lambda -> (pattern * lambda) list -> lambda
val for_let:
        Location.t -> lambda -> pattern -> lambda -> lambda
val for_multiple_match:
        Location.t -> lambda list -> (pattern * lambda) list -> partial ->
        lambda

val for_tupled_function:
        Location.t -> Ident.t list -> (pattern list * lambda) list ->
        partial -> lambda

exception Cannot_flatten

val flatten_pattern: int -> pattern -> pattern list

(* Expand stringswitch to  string test tree *)
val expand_stringswitch:
    Location.t -> lambda -> (string * lambda) list -> lambda option -> lambda

val inline_lazy_force : lambda -> Location.t -> lambda

end = struct
#1 "matching.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Compilation of pattern matching *)

open Misc
open Asttypes
open Primitive
open Types
open Typedtree
open Lambda
open Parmatch
open Printf


let dbg = false

(*  See Peyton-Jones, ``The Implementation of functional programming
    languages'', chapter 5. *)
(*
  Bon, au commencement du monde c'etait vrai.
  Now, see Lefessant-Maranget ``Optimizing Pattern-Matching'' ICFP'2001
*)


(*
   Many functions on the various data structures of the algorithm :
     - Pattern matrices.
     - Default environments: mapping from matrices to exit numbers.
     - Contexts:  matrices whose column are partitioned into
       left and right.
     - Jump summaries: mapping from exit numbers to contexts
*)

let string_of_lam lam =
  Printlambda.lambda Format.str_formatter lam ;
  Format.flush_str_formatter ()

type matrix = pattern list list

let add_omega_column pss = List.map (fun ps -> omega::ps) pss

type ctx = {left:pattern list ; right:pattern list}

let pretty_ctx ctx =
  List.iter
    (fun {left=left ; right=right} ->
      prerr_string "LEFT:" ;
      pretty_line left ;
      prerr_string " RIGHT:" ;
      pretty_line right ;
      prerr_endline "")
    ctx

let le_ctx c1 c2 =
  le_pats c1.left c2.left &&
  le_pats c1.right c2.right

let lshift {left=left ; right=right} = match right with
| x::xs -> {left=x::left ; right=xs}
| _ ->  assert false

let lforget {left=left ; right=right} = match right with
| x::xs -> {left=omega::left ; right=xs}
|  _ -> assert false

let rec small_enough n = function
  | [] -> true
  | _::rem ->
      if n <= 0 then false
      else small_enough (n-1) rem

let ctx_lshift ctx =
  if small_enough 31 ctx then
    List.map lshift ctx
  else (* Context pruning *) begin
    get_mins le_ctx (List.map lforget ctx)
  end

let  rshift {left=left ; right=right} = match left with
| p::ps -> {left=ps ; right=p::right}
| _ -> assert false

let ctx_rshift ctx = List.map rshift ctx

let rec nchars n ps =
  if n <= 0 then [],ps
  else match ps with
  | p::rem ->
    let chars, cdrs = nchars (n-1) rem in
    p::chars,cdrs
  | _ -> assert false

let  rshift_num n {left=left ; right=right} =
  let shifted,left = nchars n left in
  {left=left ; right = shifted@right}

let ctx_rshift_num n ctx = List.map (rshift_num n) ctx

(* Recombination of contexts (eg: (_,_)::p1::p2::rem ->  (p1,p2)::rem)
  All mutable fields are replaced by '_', since side-effects in
  guards can alter these fields *)

let combine {left=left ; right=right} = match left with
| p::ps -> {left=ps ; right=set_args_erase_mutable p right}
| _ -> assert false

let ctx_combine ctx = List.map combine ctx

let ncols = function
  | [] -> 0
  | ps::_ -> List.length ps


exception NoMatch
exception OrPat

let filter_matrix matcher pss =

  let rec filter_rec = function
    | (p::ps)::rem ->
        begin match p.pat_desc with
        | Tpat_alias (p,_,_) ->
            filter_rec ((p::ps)::rem)
        | Tpat_var _ ->
            filter_rec ((omega::ps)::rem)
        | _ ->
            begin
              let rem = filter_rec rem in
              try
                matcher p ps::rem
              with
              | NoMatch -> rem
              | OrPat   ->
                match p.pat_desc with
                | Tpat_or (p1,p2,_) -> filter_rec [(p1::ps) ;(p2::ps)]@rem
                | _ -> assert false
            end
        end
    | [] -> []
    | _ ->
        pretty_matrix pss ;
        fatal_error "Matching.filter_matrix" in
  filter_rec pss

let make_default matcher env =
  let rec make_rec = function
    | [] -> []
    | ([[]],i)::_ -> [[[]],i]
    | (pss,i)::rem ->
        let rem = make_rec rem in
        match filter_matrix matcher pss with
        | [] -> rem
        | ([]::_) -> ([[]],i)::rem
        | pss -> (pss,i)::rem in
  make_rec env

let ctx_matcher p =
  let p = normalize_pat p in
  match p.pat_desc with
  | Tpat_construct (_, cstr,omegas) ->
      begin match cstr.cstr_tag with
      | Cstr_extension _ ->
          let nargs = List.length omegas in
          (fun q rem -> match q.pat_desc with
          | Tpat_construct (_, cstr',args)
            when List.length args = nargs ->
                p,args @ rem
          | Tpat_any -> p,omegas @ rem
          | _ -> raise NoMatch)
      | _ ->
          (fun q rem -> match q.pat_desc with
          | Tpat_construct (_, cstr',args)
            when cstr.cstr_tag=cstr'.cstr_tag ->
              p,args @ rem
          | Tpat_any -> p,omegas @ rem
          | _ -> raise NoMatch)
      end
  | Tpat_constant cst ->
      (fun q rem -> match q.pat_desc with
      | Tpat_constant cst' when const_compare cst cst' = 0 ->
          p,rem
      | Tpat_any -> p,rem
      | _ -> raise NoMatch)
  | Tpat_variant (lab,Some omega,_) ->
      (fun q rem -> match q.pat_desc with
      | Tpat_variant (lab',Some arg,_) when lab=lab' ->
          p,arg::rem
      | Tpat_any -> p,omega::rem
      | _ -> raise NoMatch)
  | Tpat_variant (lab,None,_) ->
      (fun q rem -> match q.pat_desc with
      | Tpat_variant (lab',None,_) when lab=lab' ->
          p,rem
      | Tpat_any -> p,rem
      | _ -> raise NoMatch)
  | Tpat_array omegas ->
      let len = List.length omegas in
      (fun q rem -> match q.pat_desc with
      | Tpat_array args when List.length args=len ->
          p,args @ rem
      | Tpat_any -> p, omegas @ rem
      | _ -> raise NoMatch)
  | Tpat_tuple omegas ->
      (fun q rem -> match q.pat_desc with
      | Tpat_tuple args -> p,args @ rem
      | _          -> p, omegas @ rem)
  | Tpat_record (l,_) -> (* Records are normalized *)
      (fun q rem -> match q.pat_desc with
      | Tpat_record (l',_) ->
          let l' = all_record_args l' in
          p, List.fold_right (fun (_, _,p) r -> p::r) l' rem
      | _ -> p,List.fold_right (fun (_, _,p) r -> p::r) l rem)
  | Tpat_lazy omega ->
      (fun q rem -> match q.pat_desc with
      | Tpat_lazy arg -> p, (arg::rem)
      | _          -> p, (omega::rem))
 | _ -> fatal_error "Matching.ctx_matcher"




let filter_ctx q ctx =

  let matcher = ctx_matcher q in

  let rec filter_rec = function
    | ({right=p::ps} as l)::rem ->
        begin match p.pat_desc with
        | Tpat_or (p1,p2,_) ->
            filter_rec ({l with right=p1::ps}::{l with right=p2::ps}::rem)
        | Tpat_alias (p,_,_) ->
            filter_rec ({l with right=p::ps}::rem)
        | Tpat_var _ ->
            filter_rec ({l with right=omega::ps}::rem)
        | _ ->
            begin let rem = filter_rec rem in
            try
              let to_left, right = matcher p ps in
              {left=to_left::l.left ; right=right}::rem
            with
            | NoMatch -> rem
            end
        end
    | [] -> []
    | _ ->  fatal_error "Matching.filter_ctx" in

  filter_rec ctx

let select_columns pss ctx =
  let n = ncols pss in
  List.fold_right
    (fun ps r ->
      List.fold_right
        (fun {left=left ; right=right} r ->
          let transfert, right = nchars n right in
          try
            {left = lubs transfert ps @ left ; right=right}::r
          with
          | Empty -> r)
        ctx r)
    pss []

let ctx_lub p ctx =
  List.fold_right
    (fun {left=left ; right=right} r ->
      match right with
      | q::rem ->
          begin try
            {left=left ; right = lub p q::rem}::r
          with
          | Empty -> r
          end
      | _ -> fatal_error "Matching.ctx_lub")
    ctx []

let ctx_match ctx pss =
  List.exists
    (fun {right=qs} ->
      List.exists
        (fun ps -> compats qs ps)
        pss)
    ctx

type jumps = (int * ctx list) list

let pretty_jumps (env : jumps) = match env with
| [] -> ()
| _ ->
    List.iter
      (fun (i,ctx) ->
        Printf.fprintf stderr "jump for %d\n" i ;
        pretty_ctx ctx)
      env


let rec jumps_extract i = function
  | [] -> [],[]
  | (j,pss) as x::rem as all ->
      if i=j then pss,rem
      else if j < i then [],all
      else
        let r,rem = jumps_extract i rem in
        r,(x::rem)

let rec jumps_remove i = function
  | [] -> []
  | (j,_)::rem when i=j -> rem
  | x::rem -> x::jumps_remove i rem

let jumps_empty = []
and jumps_is_empty = function
  |  [] -> true
  |  _ -> false

let jumps_singleton i = function
  | []  -> []
  | ctx ->  [i,ctx]

let jumps_add i pss jumps = match pss with
| [] -> jumps
| _  ->
    let rec add = function
      | [] -> [i,pss]
      | (j,qss) as x::rem as all ->
          if j > i then x::add rem
      else if j < i then (i,pss)::all
      else (i,(get_mins le_ctx (pss@qss)))::rem in
    add jumps


let rec jumps_union (env1:(int*ctx list)list) env2 = match env1,env2 with
| [],_ -> env2
| _,[] -> env1
| ((i1,pss1) as x1::rem1), ((i2,pss2) as x2::rem2) ->
    if i1=i2 then
      (i1,get_mins le_ctx (pss1@pss2))::jumps_union rem1 rem2
    else if i1 > i2 then
      x1::jumps_union rem1 env2
    else
      x2::jumps_union env1 rem2


let rec merge = function
  | env1::env2::rem ->  jumps_union env1 env2::merge rem
  | envs -> envs

let rec jumps_unions envs = match envs with
  | [] -> []
  | [env] -> env
  | _ -> jumps_unions (merge envs)

let jumps_map f env =
  List.map
    (fun (i,pss) -> i,f pss)
    env

(* Pattern matching before any compilation *)

type pattern_matching =
  { mutable cases : (pattern list * lambda) list;
    args : (lambda * let_kind) list ;
    default : (matrix * int) list}

(* Pattern matching after application of both the or-pat rule and the
   mixture rule *)

type pm_or_compiled =
  {body : pattern_matching ;
   handlers : (matrix * int * Ident.t list * pattern_matching) list ;
   or_matrix : matrix ; }

type pm_half_compiled =
  | PmOr of pm_or_compiled
  | PmVar of pm_var_compiled
  | Pm of pattern_matching

and pm_var_compiled =
    {inside : pm_half_compiled ; var_arg : lambda ; }

type pm_half_compiled_info =
    {me : pm_half_compiled ;
     matrix : matrix ;
     top_default : (matrix * int) list ; }

let pretty_cases cases =
  List.iter
    (fun ((ps),l) ->
      List.iter
        (fun p ->
          Parmatch.top_pretty Format.str_formatter p ;
          prerr_string " " ;
          prerr_string (Format.flush_str_formatter ()))
        ps ;
(*
      prerr_string " -> " ;
      Printlambda.lambda Format.str_formatter l ;
      prerr_string (Format.flush_str_formatter ()) ;
*)
      prerr_endline "")
    cases

let pretty_def def =
  prerr_endline "+++++ Defaults +++++" ;
  List.iter
    (fun (pss,i) ->
      Printf.fprintf stderr "Matrix for %d\n"  i ;
      pretty_matrix pss)
    def ;
  prerr_endline "+++++++++++++++++++++"

let pretty_pm pm = pretty_cases pm.cases


let rec pretty_precompiled = function
  | Pm pm ->
      prerr_endline "++++ PM ++++" ;
      pretty_pm pm
  | PmVar x ->
      prerr_endline "++++ VAR ++++" ;
      pretty_precompiled x.inside
  | PmOr x ->
      prerr_endline "++++ OR ++++" ;
      pretty_pm x.body ;
      pretty_matrix x.or_matrix ;
      List.iter
        (fun (_,i,_,pm) ->
          eprintf "++ Handler %d ++\n" i ;
          pretty_pm pm)
        x.handlers

let pretty_precompiled_res first nexts =
  pretty_precompiled first ;
  List.iter
    (fun (e, pmh) ->
      eprintf "** DEFAULT %d **\n" e ;
      pretty_precompiled pmh)
    nexts



(* Identifing some semantically equivalent lambda-expressions,
   Our goal here is also to
   find alpha-equivalent (simple) terms *)

(* However, as shown by PR#6359 such sharing may hinders the
   lambda-code invariant that all bound idents are unique,
   when switchs are compiled to test sequences.
   The definitive fix is the systematic introduction of exit/catch
   in case action sharing is present.
*)


module StoreExp =
  Switch.Store
    (struct
      type t = lambda
      type key = lambda
      let make_key = Lambda.make_key
    end)


let make_exit i = Lstaticraise (i,[])

(* Introduce a catch, if worth it *)
let make_catch d k = match d with
| Lstaticraise (_,[]) -> k d
| _ ->
    let e = next_raise_count () in
    Lstaticcatch (k (make_exit e),(e,[]),d)

(* Introduce a catch, if worth it, delayed version *)
let rec as_simple_exit = function
  | Lstaticraise (i,[]) -> Some i
  | Llet (Alias,_,_,e) -> as_simple_exit e
  | _ -> None


let make_catch_delayed handler = match as_simple_exit handler with
| Some i -> i,(fun act -> act)
| None ->
    let i = next_raise_count () in
(*
    Printf.eprintf "SHARE LAMBDA: %i\n%s\n" i (string_of_lam handler);
*)
    i,
    (fun body -> match body with
    | Lstaticraise (j,_) ->
        if i=j then handler else body
    | _ -> Lstaticcatch (body,(i,[]),handler))


let raw_action l =
  match make_key l with | Some l -> l | None -> l


let tr_raw act = match make_key act with
| Some act -> act
| None -> raise Exit

let same_actions = function
  | [] -> None
  | [_,act] -> Some act
  | (_,act0) :: rem ->
      try
        let raw_act0 = tr_raw act0 in
        let rec s_rec = function
          | [] -> Some act0
          | (_,act)::rem ->
              if raw_act0 = tr_raw act then
                s_rec rem
              else
                None in
        s_rec rem
      with
      | Exit -> None


(* Test for swapping two clauses *)

let up_ok_action act1 act2 =
  try
    let raw1 = tr_raw act1
    and raw2 = tr_raw act2 in
    raw1 = raw2
  with
  | Exit -> false

(* Nothing is kown about exception/extension patterns,
   because of potential rebind *)
let rec exc_inside p = match p.pat_desc with
  | Tpat_construct (_,{cstr_tag=Cstr_extension _},_) -> true
  | Tpat_any|Tpat_constant _|Tpat_var _
  | Tpat_construct (_,_,[])
  | Tpat_variant (_,None,_)
    -> false
  | Tpat_construct (_,_,ps)
  | Tpat_tuple ps
  | Tpat_array ps
      -> exc_insides ps
  | Tpat_variant (_, Some q,_)
  | Tpat_alias (q,_,_)
  | Tpat_lazy q
    -> exc_inside q
  | Tpat_record (lps,_) ->
      List.exists (fun (_,_,p) -> exc_inside p) lps
  | Tpat_or (p1,p2,_) -> exc_inside p1 || exc_inside p2

and exc_insides ps = List.exists exc_inside ps

let up_ok (ps,act_p) l =
  if exc_insides ps then match l with [] -> true | _::_ -> false
  else
    List.for_all
      (fun (qs,act_q) ->
        up_ok_action act_p act_q ||
        not (Parmatch.compats ps qs))
      l


(*
   Simplify fonction normalize the first column of the match
     - records are expanded so that they posses all fields
     - aliases are removed and replaced by bindings in actions.
   However or-patterns are simplified differently,
     - aliases are not removed
     - or patterns (_|p) are changed into _
*)

exception Var of pattern

let simplify_or p =
  let rec simpl_rec p = match p with
    | {pat_desc = Tpat_any|Tpat_var _} -> raise (Var p)
    | {pat_desc = Tpat_alias (q,id,s)} ->
        begin try
          {p with pat_desc = Tpat_alias (simpl_rec q,id,s)}
        with
        | Var q -> raise (Var {p with pat_desc = Tpat_alias (q,id,s)})
        end
    | {pat_desc = Tpat_or (p1,p2,o)} ->
        let q1 = simpl_rec p1 in
        begin try
          let q2 = simpl_rec p2 in
          {p with pat_desc = Tpat_or (q1, q2, o)}
        with
        | Var q2 -> raise (Var {p with pat_desc = Tpat_or (q1, q2, o)})
        end
    | {pat_desc = Tpat_record (lbls,closed)} ->
        let all_lbls = all_record_args lbls in
        {p with pat_desc=Tpat_record (all_lbls, closed)}
    | _ -> p in
  try
    simpl_rec p
  with
  | Var p -> p

let simplify_cases args cls = match args with
| [] -> assert false
| (arg,_)::_ ->
    let rec simplify = function
      | [] -> []
      | ((pat :: patl, action) as cl) :: rem ->
          begin match pat.pat_desc with
          | Tpat_var (id, _) ->
              (omega :: patl, bind Alias id arg action) ::
              simplify rem
          | Tpat_any ->
              cl :: simplify rem
          | Tpat_alias(p, id,_) ->
              simplify ((p :: patl, bind Alias id arg action) :: rem)
          | Tpat_record ([],_) ->
              (omega :: patl, action)::
              simplify rem
          | Tpat_record (lbls, closed) ->
              let all_lbls = all_record_args lbls in
              let full_pat =
                {pat with pat_desc=Tpat_record (all_lbls, closed)} in
              (full_pat::patl,action)::
              simplify rem
          | Tpat_or _ ->
              let pat_simple  = simplify_or pat in
              begin match pat_simple.pat_desc with
              | Tpat_or _ ->
                  (pat_simple :: patl, action) ::
                  simplify rem
              | _ ->
                  simplify ((pat_simple::patl,action) :: rem)
              end
          | _ -> cl :: simplify rem
          end
      | _ -> assert false in

    simplify cls



(* Once matchings are simplified one easily finds
   their nature *)

let rec what_is_cases cases = match cases with
| ({pat_desc=Tpat_any} :: _, _) :: rem -> what_is_cases rem
| (({pat_desc=(Tpat_var _|Tpat_or (_,_,_)|Tpat_alias (_,_,_))}::_),_)::_
  -> assert false (* applies to simplified matchings only *)
| (p::_,_)::_ -> p
| [] -> omega
| _ -> assert false



(* A few operation on default environments *)
let as_matrix cases = get_mins le_pats (List.map (fun (ps,_) -> ps) cases)

(* For extension matching, record no imformation in matrix *)
let as_matrix_omega cases =
  get_mins le_pats
    (List.map
       (fun (ps,_) ->
         match ps with
         | [] -> assert false
         | _::ps -> omega::ps)
       cases)

let cons_default matrix raise_num default =
  match matrix with
  | [] -> default
  | _ -> (matrix,raise_num)::default

let default_compat p def =
  List.fold_right
    (fun (pss,i) r ->
      let qss =
        List.fold_right
          (fun qs r -> match qs with
            | q::rem when Parmatch.compat p q -> rem::r
            | _ -> r)
          pss [] in
      match qss with
      | [] -> r
      | _  -> (qss,i)::r)
    def []

(* Or-pattern expansion, variables are a complication w.r.t. the article *)
let rec extract_vars r p = match p.pat_desc with
| Tpat_var (id, _) -> IdentSet.add id r
| Tpat_alias (p, id,_ ) ->
    extract_vars (IdentSet.add id r) p
| Tpat_tuple pats ->
    List.fold_left extract_vars r pats
| Tpat_record (lpats,_) ->
    List.fold_left
      (fun r (_, _, p) -> extract_vars r p)
      r lpats
| Tpat_construct (_, _, pats) ->
    List.fold_left extract_vars r pats
| Tpat_array pats ->
    List.fold_left extract_vars r pats
| Tpat_variant (_,Some p, _) -> extract_vars r p
| Tpat_lazy p -> extract_vars r p
| Tpat_or (p,_,_) -> extract_vars r p
| Tpat_constant _|Tpat_any|Tpat_variant (_,None,_) -> r

exception Cannot_flatten

let mk_alpha_env arg aliases ids =
  List.map
    (fun id -> id,
      if List.mem id aliases then
        match arg with
        | Some v -> v
        | _      -> raise Cannot_flatten
      else
        Ident.create (Ident.name id))
    ids

let rec explode_or_pat arg patl mk_action rem vars aliases = function
  | {pat_desc = Tpat_or (p1,p2,_)} ->
      explode_or_pat
        arg patl mk_action
        (explode_or_pat arg patl mk_action rem vars aliases p2)
        vars aliases p1
  | {pat_desc = Tpat_alias (p,id, _)} ->
      explode_or_pat arg patl mk_action rem vars (id::aliases) p
  | {pat_desc = Tpat_var (x, _)} ->
      let env = mk_alpha_env arg (x::aliases) vars in
      (omega::patl,mk_action (List.map snd env))::rem
  | p ->
      let env = mk_alpha_env arg aliases vars in
      (alpha_pat env p::patl,mk_action (List.map snd env))::rem

let pm_free_variables {cases=cases} =
  List.fold_right
    (fun (_,act) r -> IdentSet.union (free_variables act) r)
    cases IdentSet.empty


(* Basic grouping predicates *)
let pat_as_constr = function
  | {pat_desc=Tpat_construct (_, cstr,_)} -> cstr
  | _ -> fatal_error "Matching.pat_as_constr"

let group_constant = function
  | {pat_desc= Tpat_constant _} -> true
  | _                           -> false

and group_constructor = function
  | {pat_desc = Tpat_construct (_,_,_)} -> true
  | _ -> false

and group_variant = function
  | {pat_desc = Tpat_variant (_, _, _)} -> true
  | _ -> false

and group_var = function
  | {pat_desc=Tpat_any} -> true
  | _ -> false

and group_tuple = function
  | {pat_desc = (Tpat_tuple _|Tpat_any)} -> true
  | _ -> false

and group_record = function
  | {pat_desc = (Tpat_record _|Tpat_any)} -> true
  | _ -> false

and group_array = function
  | {pat_desc=Tpat_array _} -> true
  | _ -> false

and group_lazy = function
  | {pat_desc = Tpat_lazy _} -> true
  | _ -> false

let get_group p = match p.pat_desc with
| Tpat_any -> group_var
| Tpat_constant _ -> group_constant
| Tpat_construct _ -> group_constructor
| Tpat_tuple _ -> group_tuple
| Tpat_record _ -> group_record
| Tpat_array _ -> group_array
| Tpat_variant (_,_,_) -> group_variant
| Tpat_lazy _ -> group_lazy
|  _ -> fatal_error "Matching.get_group"



let is_or p = match p.pat_desc with
| Tpat_or _ -> true
| _ -> false

(* Conditions for appending to the Or matrix *)
let conda p q = not (compat p q)
and condb act ps qs =  not (is_guarded act) && Parmatch.le_pats qs ps

let or_ok p ps l =
  List.for_all
    (function
      | ({pat_desc=Tpat_or _} as q::qs,act) ->
          conda p q || condb act ps qs
      | _ -> true)
    l

(* Insert or append a pattern in the Or matrix *)

let equiv_pat p q = le_pat p q && le_pat q p

let rec get_equiv p l = match l with
  | (q::_,_) as cl::rem ->
      if equiv_pat p q then
        let others,rem = get_equiv p rem in
        cl::others,rem
      else
        [],l
  | _ -> [],l


let insert_or_append p ps act ors no =
  let rec attempt seen = function
    | (q::qs,act_q) as cl::rem ->
        if is_or q then begin
          if compat p q then
            if
              IdentSet.is_empty (extract_vars IdentSet.empty p) &&
              IdentSet.is_empty (extract_vars IdentSet.empty q) &&
              equiv_pat p q
            then (* attempt insert, for equivalent orpats with no variables *)
              let _, not_e = get_equiv q rem in
              if
                or_ok p ps not_e && (* check append condition for head of O *)
                List.for_all        (* check insert condition for tail of O *)
                  (fun cl -> match cl with
                  | (q::_,_) -> not (compat p q)
                  | _        -> assert false)
                  seen
              then (* insert *)
                List.rev_append seen ((p::ps,act)::cl::rem), no
              else (* fail to insert or append *)
                ors,(p::ps,act)::no
            else if condb act_q ps qs then (* check condition (b) for append *)
              attempt (cl::seen) rem
            else
              ors,(p::ps,act)::no
          else (* p # q, go on with append/insert *)
            attempt (cl::seen) rem
        end else (* q is not a or-pat, go on with append/insert *)
          attempt (cl::seen) rem
    | _  -> (* [] in fact *)
        (p::ps,act)::ors,no in (* success in appending *)
  attempt [] ors

(* Reconstruct default information from half_compiled  pm list *)

let rec rebuild_matrix pmh = match pmh with
  | Pm pm -> as_matrix pm.cases
  | PmOr {or_matrix=m} -> m
  | PmVar x -> add_omega_column  (rebuild_matrix x.inside)

let rec rebuild_default nexts def = match nexts with
| [] -> def
| (e, pmh)::rem ->
    (add_omega_column (rebuild_matrix pmh), e)::
    rebuild_default rem def

let rebuild_nexts arg nexts k =
  List.fold_right
    (fun (e, pm) k -> (e, PmVar {inside=pm ; var_arg=arg})::k)
    nexts k


(*
  Split a matching.
    Splitting is first directed by or-patterns, then by
    tests (e.g. constructors)/variable transitions.

    The approach is greedy, every split function attempt to
    raise rows as much as possible in the top matrix,
    then splitting applies again to the remaining rows.

    Some precompilation of or-patterns and
    variable pattern occurs. Mostly this means that bindings
    are performed now,  being replaced by let-bindings
    in actions (cf. simplify_cases).

    Additionally, if the match argument is a variable, matchings whose
    first column is made of variables only are splitted further
    (cf. precompile_var).

*)


let rec split_or argo cls args def =

  let cls = simplify_cases args cls in

  let rec do_split before ors no = function
    | [] ->
        cons_next
          (List.rev before) (List.rev ors) (List.rev no)
    | ((p::ps,act) as cl)::rem ->
        if up_ok cl no then
          if is_or p then
            let ors, no = insert_or_append p ps act ors no in
            do_split before ors no rem
          else begin
            if up_ok cl ors then
              do_split (cl::before) ors no rem
            else if or_ok p ps ors then
              do_split before (cl::ors) no rem
            else
              do_split before ors (cl::no) rem
          end
        else
          do_split before ors (cl::no) rem
    | _ -> assert false

  and cons_next yes yesor = function
    | [] ->
        precompile_or argo yes yesor args def []
    | rem ->
        let {me=next ; matrix=matrix ; top_default=def},nexts =
          do_split [] [] [] rem in
        let idef = next_raise_count () in
        precompile_or
          argo yes yesor args
          (cons_default matrix idef def)
          ((idef,next)::nexts) in

  do_split [] [] [] cls

(* Ultra-naive spliting, close to semantics, used for extension,
   as potential rebind prevents any kind of optimisation *)

and split_naive cls args def k =

  let rec split_exc cstr0 yes = function
    | [] ->
        let yes = List.rev yes in
        { me = Pm {cases=yes; args=args; default=def;} ;
          matrix = as_matrix_omega yes ;
          top_default=def},
        k
    | (p::_,_ as cl)::rem ->
        if group_constructor p then
          let cstr = pat_as_constr p in
          if cstr = cstr0 then split_exc cstr0 (cl::yes) rem
          else
            let yes = List.rev yes in
            let {me=next ; matrix=matrix ; top_default=def}, nexts =
              split_exc cstr [cl] rem in
            let idef = next_raise_count () in
            let def = cons_default matrix idef def in
            { me = Pm {cases=yes; args=args; default=def} ;
              matrix = as_matrix_omega yes ;
              top_default = def; },
            (idef,next)::nexts
        else
          let yes = List.rev yes in
          let {me=next ; matrix=matrix ; top_default=def}, nexts =
              split_noexc [cl] rem in
            let idef = next_raise_count () in
            let def = cons_default matrix idef def in
            { me = Pm {cases=yes; args=args; default=def} ;
              matrix = as_matrix_omega yes ;
              top_default = def; },
            (idef,next)::nexts
    | _ -> assert false

  and split_noexc yes = function
    | [] -> precompile_var args (List.rev yes) def k
    | (p::_,_ as cl)::rem ->
        if group_constructor p then
          let yes= List.rev yes in
          let {me=next; matrix=matrix; top_default=def;},nexts =
            split_exc (pat_as_constr p) [cl] rem in
          let idef = next_raise_count () in
          precompile_var
            args yes
            (cons_default matrix idef def)
            ((idef,next)::nexts)
        else split_noexc (cl::yes) rem
    | _ -> assert false in

  match cls with
  | [] -> assert false
  | (p::_,_ as cl)::rem ->
      if group_constructor p then
        split_exc (pat_as_constr p) [cl] rem
      else
        split_noexc [cl] rem
  | _ -> assert false

and split_constr cls args def k =
  let ex_pat = what_is_cases cls in
  match ex_pat.pat_desc with
  | Tpat_any -> precompile_var args cls def k
  | Tpat_construct (_,{cstr_tag=Cstr_extension _},_) ->
      split_naive cls args def k
  | _ ->

      let group = get_group ex_pat in

      let rec split_ex yes no = function
        | [] ->
            let yes = List.rev yes and no = List.rev no in
            begin match no with
            | [] ->
                {me = Pm {cases=yes ; args=args ; default=def} ;
                  matrix = as_matrix yes ;
                  top_default = def},
                k
            | cl::rem ->
                begin match yes with
                | [] ->
                    (* Could not success in raising up a constr matching up *)
                    split_noex [cl] [] rem
                | _ ->
                    let {me=next ; matrix=matrix ; top_default=def}, nexts =
                      split_noex [cl] [] rem in
                    let idef = next_raise_count () in
                    let def = cons_default matrix idef def in
                    {me = Pm {cases=yes ; args=args ; default=def} ;
                      matrix = as_matrix yes ;
                      top_default = def },
                    (idef, next)::nexts
                end
            end
        | (p::_,_) as cl::rem ->
            if group p && up_ok cl no then
              split_ex (cl::yes) no rem
            else
              split_ex yes (cl::no) rem
        | _ -> assert false

      and split_noex yes no = function
        | [] ->
            let yes = List.rev yes and no = List.rev no in
            begin match no with
            | [] -> precompile_var args yes def k
            | cl::rem ->
                let {me=next ; matrix=matrix ; top_default=def}, nexts =
                  split_ex [cl] [] rem in
                let idef = next_raise_count () in
                precompile_var
                  args yes
                  (cons_default matrix idef def)
                  ((idef,next)::nexts)
            end
        | [ps,_ as cl]
            when List.for_all group_var ps && yes <> [] ->
       (* This enables an extra division in some frequent case :
          last row is made of variables only *)
              split_noex yes (cl::no) []
        | (p::_,_) as cl::rem ->
            if not (group p) && up_ok cl no then
              split_noex (cl::yes) no rem
            else
              split_noex yes (cl::no) rem
        | _ -> assert false in

      match cls with
      | ((p::_,_) as cl)::rem ->
          if group p then split_ex [cl] [] rem
          else split_noex [cl] [] rem
      | _ ->  assert false

and precompile_var  args cls def k = match args with
| []  -> assert false
| _::((Lvar v as av,_) as arg)::rargs ->
    begin match cls with
    | [ps,_] -> (* as splitted as it can *)
        dont_precompile_var args cls def k
    | _ ->
(* Precompile *)
        let var_cls =
          List.map
            (fun (ps,act) -> match ps with
            | _::ps -> ps,act | _     -> assert false)
            cls
        and var_def = make_default (fun _ rem -> rem) def in
        let {me=first ; matrix=matrix}, nexts =
          split_or (Some v) var_cls (arg::rargs) var_def in

(* Compute top information *)
        match nexts with
        | [] -> (* If you need *)
            dont_precompile_var args cls def k
        | _  ->
            let rfirst =
              {me = PmVar {inside=first ; var_arg = av} ;
                matrix = add_omega_column matrix ;
                top_default = rebuild_default nexts def ; }
            and rnexts = rebuild_nexts av nexts k in
            rfirst, rnexts
    end
|  _ ->
    dont_precompile_var args cls def k

and dont_precompile_var args cls def k =
  {me =  Pm {cases = cls ; args = args ; default = def } ;
    matrix=as_matrix cls ;
    top_default=def},k

and is_exc p = match p.pat_desc with
| Tpat_or (p1,p2,_) -> is_exc p1 || is_exc p2
| Tpat_alias (p,v,_) -> is_exc p
| Tpat_construct (_,{cstr_tag=Cstr_extension _},_) -> true
| _ -> false

and precompile_or argo cls ors args def k = match ors with
| [] -> split_constr cls args def k
| _  ->
    let rec do_cases = function
      | ({pat_desc=Tpat_or _} as orp::patl, action)::rem ->
          let do_opt = not (is_exc orp) in
          let others,rem =
            if do_opt then get_equiv orp rem
            else [],rem in
          let orpm =
            {cases =
              (patl, action)::
              List.map
                (function
                  | (_::ps,action) -> ps,action
                  | _ -> assert false)
                others ;
              args = (match args with _::r -> r | _ -> assert false) ;
              default = default_compat (if do_opt then orp else omega) def} in
          let vars =
            IdentSet.elements
              (IdentSet.inter
                 (extract_vars IdentSet.empty orp)
                 (pm_free_variables orpm)) in
          let or_num = next_raise_count () in
          let new_patl = Parmatch.omega_list patl in

          let mk_new_action vs =
            Lstaticraise
              (or_num, List.map (fun v -> Lvar v) vs) in

          let do_optrec,body,handlers = do_cases rem in
          do_opt && do_optrec,
          explode_or_pat
            argo new_patl mk_new_action body vars [] orp,
          let mat = if do_opt then [[orp]] else [[omega]] in
          ((mat, or_num, vars , orpm):: handlers)
      | cl::rem ->
          let b,new_ord,new_to_catch = do_cases rem in
          b,cl::new_ord,new_to_catch
      | [] -> true,[],[] in

    let do_opt,end_body, handlers = do_cases ors in
    let matrix = (if do_opt then as_matrix else as_matrix_omega) (cls@ors)
    and body = {cases=cls@end_body ; args=args ; default=def} in
    {me = PmOr {body=body ; handlers=handlers ; or_matrix=matrix} ;
      matrix=matrix ;
      top_default=def},
    k

let split_precompile argo pm =
  let {me=next}, nexts = split_or argo pm.cases pm.args pm.default  in
  if dbg && (nexts <> [] || (match next with PmOr _ -> true | _ -> false))
  then begin
    prerr_endline "** SPLIT **" ;
    pretty_pm pm ;
    pretty_precompiled_res  next nexts
  end ;
  next, nexts


(* General divide functions *)

let add_line patl_action pm = pm.cases <- patl_action :: pm.cases; pm

type cell =
  {pm : pattern_matching ;
  ctx : ctx list ;
  pat : pattern}

let add make_matching_fun division eq_key key patl_action args =
  try
    let (_,cell) = List.find (fun (k,_) -> eq_key key k) division in
    cell.pm.cases <- patl_action :: cell.pm.cases;
    division
  with Not_found ->
    let cell = make_matching_fun args in
    cell.pm.cases <- [patl_action] ;
    (key, cell) :: division


let divide make eq_key get_key get_args ctx pm =

  let rec divide_rec = function
    | (p::patl,action) :: rem ->
        let this_match = divide_rec rem in
        add
          (make p pm.default ctx)
          this_match eq_key (get_key p) (get_args p patl,action) pm.args
    | _ -> [] in

  divide_rec pm.cases


let divide_line make_ctx make get_args pat ctx pm =
  let rec divide_rec = function
    | (p::patl,action) :: rem ->
        let this_match = divide_rec rem in
        add_line (get_args p patl, action) this_match
    | _ -> make pm.default pm.args in

  {pm = divide_rec pm.cases ;
  ctx=make_ctx ctx ;
  pat=pat}



(* Then come various functions,
   There is one set of functions per matching style
   (constants, constructors etc.)

   - matcher function are arguments to make_default (for defaukt handlers)
   They may raise NoMatch or OrPat and perform the full
   matching (selection + arguments).


   - get_args and get_key are for the compiled matrices, note that
   selection and geting arguments are separed.

   - make_ _matching combines the previous functions for produicing
   new  ``pattern_matching'' records.
*)



let rec matcher_const cst p rem = match p.pat_desc with
| Tpat_or (p1,p2,_) ->
    begin try
      matcher_const cst p1 rem with
    | NoMatch -> matcher_const cst p2 rem
    end
| Tpat_constant c1 when const_compare c1 cst = 0 -> rem
| Tpat_any    -> rem
| _ -> raise NoMatch

let get_key_constant caller = function
  | {pat_desc= Tpat_constant cst} -> cst
  | p ->
      prerr_endline ("BAD: "^caller) ;
      pretty_pat p ;
      assert false

let get_args_constant _ rem = rem

let make_constant_matching p def ctx = function
    [] -> fatal_error "Matching.make_constant_matching"
  | (_ :: argl) ->
      let def =
        make_default
          (matcher_const (get_key_constant "make" p)) def
      and ctx =
        filter_ctx p  ctx in
      {pm = {cases = []; args = argl ; default = def} ;
        ctx = ctx ;
        pat = normalize_pat p}




let divide_constant ctx m =
  divide
    make_constant_matching
    (fun c d -> const_compare c d = 0) (get_key_constant "divide")
    get_args_constant
    ctx m

(* Matching against a constructor *)


let make_field_args loc binding_kind arg first_pos last_pos argl =
  let rec make_args pos =
    if pos > last_pos
    then argl
    else (Lprim(Pfield (pos, Fld_na (* TODO*) ), [arg],loc), binding_kind) :: make_args (pos + 1)
  in make_args first_pos

let get_key_constr = function
  | {pat_desc=Tpat_construct (_, cstr,_)} -> cstr.cstr_tag
  | _ -> assert false

let get_args_constr p rem = match p with
| {pat_desc=Tpat_construct (_, _, args)} -> args @ rem
| _ -> assert false

let matcher_constr cstr = match cstr.cstr_arity with
| 0 ->
    let rec matcher_rec q rem = match q.pat_desc with
    | Tpat_or (p1,p2,_) ->
        begin
          try
            matcher_rec p1 rem
          with
          | NoMatch -> matcher_rec p2 rem
        end
    | Tpat_construct (_, cstr1, []) when cstr.cstr_tag = cstr1.cstr_tag ->
        rem
    | Tpat_any -> rem
    | _ -> raise NoMatch in
    matcher_rec
| 1 ->
    let rec matcher_rec q rem = match q.pat_desc with
    | Tpat_or (p1,p2,_) ->
        let r1 = try Some (matcher_rec p1 rem) with NoMatch -> None
        and r2 = try Some (matcher_rec p2 rem) with NoMatch -> None in
        begin match r1,r2 with
        | None, None -> raise NoMatch
        | Some r1, None -> r1
        | None, Some r2 -> r2
        | Some (a1::rem1), Some (a2::_) ->
            {a1 with
             pat_loc = Location.none ;
             pat_desc = Tpat_or (a1, a2, None)}::
            rem
        | _, _ -> assert false
        end
    | Tpat_construct (_, cstr1, [arg])
      when cstr.cstr_tag = cstr1.cstr_tag -> arg::rem
    | Tpat_any -> omega::rem
    | _ -> raise NoMatch in
    matcher_rec
| _ ->
    fun q rem -> match q.pat_desc with
    | Tpat_or (_,_,_) -> raise OrPat
    | Tpat_construct (_, cstr1, args)
      when cstr.cstr_tag = cstr1.cstr_tag -> args @ rem
    | Tpat_any -> Parmatch.omegas cstr.cstr_arity @ rem
    | _        -> raise NoMatch

let make_constr_matching p def ctx = function
    [] -> fatal_error "Matching.make_constr_matching"
  | ((arg, mut) :: argl) ->
      let cstr = pat_as_constr p in
      let newargs =
        match cstr.cstr_tag with
          Cstr_constant _ | Cstr_block _ ->
            make_field_args p.pat_loc Alias arg 0 (cstr.cstr_arity - 1) argl
        | Cstr_extension _ ->
            make_field_args p.pat_loc Alias arg 1 cstr.cstr_arity argl in
      {pm=
        {cases = []; args = newargs;
          default = make_default (matcher_constr cstr) def} ;
        ctx =  filter_ctx p ctx ;
        pat=normalize_pat p}


let divide_constructor ctx pm =
  divide
    make_constr_matching
    (=) get_key_constr get_args_constr
    ctx pm

(* Matching against a variant *)

let rec matcher_variant_const lab p rem = match p.pat_desc with
| Tpat_or (p1, p2, _) ->
    begin
      try
        matcher_variant_const lab p1 rem
      with
      | NoMatch -> matcher_variant_const lab p2 rem
    end
| Tpat_variant (lab1,_,_) when lab1=lab -> rem
| Tpat_any -> rem
| _   -> raise NoMatch


let make_variant_matching_constant p lab def ctx = function
    [] -> fatal_error "Matching.make_variant_matching_constant"
  | ((arg, mut) :: argl) ->
      let def = make_default (matcher_variant_const lab) def
      and ctx = filter_ctx p ctx in
      {pm={ cases = []; args = argl ; default=def} ;
        ctx=ctx ;
        pat = normalize_pat p}

let matcher_variant_nonconst lab p rem = match p.pat_desc with
| Tpat_or (_,_,_) -> raise OrPat
| Tpat_variant (lab1,Some arg,_) when lab1=lab -> arg::rem
| Tpat_any -> omega::rem
| _   -> raise NoMatch


let make_variant_matching_nonconst p lab def ctx = function
    [] -> fatal_error "Matching.make_variant_matching_nonconst"
  | ((arg, mut) :: argl) ->
      let def = make_default (matcher_variant_nonconst lab) def
      and ctx = filter_ctx p ctx in
      {pm=
        {cases = []; args = (Lprim(Pfield (1, Fld_na (* TODO*)), [arg], p.pat_loc), Alias) :: argl;
          default=def} ;
        ctx=ctx ;
        pat = normalize_pat p}

let get_key_variant p = match p.pat_desc with
| Tpat_variant(lab, Some _ , _) ->  Cstr_block (Btype.hash_variant lab)
| Tpat_variant(lab, None , _) -> Cstr_constant (Btype.hash_variant lab)
|  _ -> assert false

let divide_variant row ctx {cases = cl; args = al; default=def} =
  let row = Btype.row_repr row in
  let rec divide = function
      ({pat_desc = Tpat_variant(lab, pato, _)} as p:: patl, action) :: rem ->
        let variants = divide rem in
        if try Btype.row_field_repr (List.assoc lab row.row_fields) = Rabsent
        with Not_found -> true
        then
          variants
        else begin
          let tag = Btype.hash_variant lab in
          match pato with
            None ->
              add (make_variant_matching_constant p lab def ctx) variants
                (=) (Cstr_constant tag) (patl, action) al
          | Some pat ->
              add (make_variant_matching_nonconst p lab def ctx) variants
                (=) (Cstr_block tag) (pat :: patl, action) al
        end
    | cl -> []
  in
  divide cl

(*
  Three ``no-test'' cases
  *)

(* Matching against a variable *)

let get_args_var _ rem = rem


let make_var_matching def = function
  | [] ->  fatal_error "Matching.make_var_matching"
  | _::argl ->
      {cases=[] ;
        args = argl ;
        default= make_default get_args_var def}

let divide_var ctx pm =
  divide_line ctx_lshift make_var_matching get_args_var omega ctx pm

(* Matching and forcing a lazy value *)

let get_arg_lazy p rem = match p with
| {pat_desc = Tpat_any} -> omega :: rem
| {pat_desc = Tpat_lazy arg} -> arg :: rem
| _ ->  assert false

let matcher_lazy p rem = match p.pat_desc with
| Tpat_or (_,_,_)     -> raise OrPat
| Tpat_var _          -> get_arg_lazy omega rem
| _                   -> get_arg_lazy p rem

(* Inlining the tag tests before calling the primitive that works on
   lazy blocks. This is alse used in translcore.ml.
   No call other than Obj.tag when the value has been forced before.
*)

let prim_obj_tag =
  {prim_name = "caml_obj_tag";
   prim_arity = 1; prim_alloc = false;
   prim_native_name = "";
   prim_native_float = false}

let get_mod_field modname field =
  lazy (
    try
      let mod_ident = Ident.create_persistent modname in
      let env = Env.open_pers_signature modname Env.initial_safe_string in
      let p = try
        match Env.lookup_value (Longident.Lident field) env with
        | (Path.Pdot(_,_,i), _) -> i
        | _ -> fatal_error ("Primitive "^modname^"."^field^" not found.")
      with Not_found ->
        fatal_error ("Primitive "^modname^"."^field^" not found.")
      in
      Lprim(Pfield (p, Fld_na (* TODO - then we dont need query any more*)), 
            [Lprim(Pgetglobal mod_ident, [], Location.none)], Location.none)
    with Not_found -> fatal_error ("Module "^modname^" unavailable.")
  )

let code_force_lazy_block =
  get_mod_field "CamlinternalLazy" "force_lazy_block"
;;

(* inline_lazy_force inlines the beginning of the code of Lazy.force. When
   the value argument is tagged as:
   - forward, take field 0
   - lazy, call the primitive that forces (without testing again the tag)
   - anything else, return it

   Using Lswitch below relies on the fact that the GC does not shortcut
   Forward(val_out_of_heap).
*)

let inline_lazy_force_cond arg loc =
  let idarg = Ident.create "lzarg" in
  let varg = Lvar idarg in
  let tag = Ident.create "tag" in
  let force_fun = Lazy.force code_force_lazy_block in
  Llet(Strict, idarg, arg,
       Llet(Alias, tag, Lprim(Pccall prim_obj_tag, [varg], loc),
            Lifthenelse(
              (* if (tag == Obj.forward_tag) then varg.(0) else ... *)
              Lprim(Pintcomp Ceq,
                    [Lvar tag; Lconst(Const_base(Const_int Obj.forward_tag))],
                   loc),
              Lprim(Pfield (0, Fld_na (* TODO: lazy *)), [varg],
                   loc),
              Lifthenelse(
                (* ... if (tag == Obj.lazy_tag) then Lazy.force varg else ... *)
                Lprim(Pintcomp Ceq,
                      [Lvar tag; Lconst(Const_base(Const_int Obj.lazy_tag))],
                     loc),
                Lapply(force_fun, [varg], loc),
                (* ... arg *)
                  varg))))

let inline_lazy_force_switch arg loc =
  let idarg = Ident.create "lzarg" in
  let varg = Lvar idarg in
  let force_fun = Lazy.force code_force_lazy_block in
  Llet(Strict, idarg, arg,
       Lifthenelse(
         Lprim(Pisint, [varg],loc), varg,
         (Lswitch
            (varg,
             { sw_numconsts = 0; sw_consts = [];
               sw_numblocks = 256;  (* PR#6033 - tag ranges from 0 to 255 *)
               sw_blocks =
                 [ (Obj.forward_tag, Lprim(Pfield (0, Fld_na (* TODO: lazy *)), [varg],loc));
                   (Obj.lazy_tag,
                    Lapply(force_fun, [varg], loc)) ];
               sw_failaction = Some varg } ))))

let inline_lazy_force arg loc =
  if !Clflags.native_code then
    (* Lswitch generates compact and efficient native code *)
    inline_lazy_force_switch arg loc
  else
    (* generating bytecode: Lswitch would generate too many rather big
       tables (~ 250 elts); conditionals are better *)
    inline_lazy_force_cond arg loc

let make_lazy_matching def = function
    [] -> fatal_error "Matching.make_lazy_matching"
  | (arg,mut) :: argl ->
      { cases = [];
        args =
          (inline_lazy_force arg Location.none, Strict) :: argl;
        default = make_default matcher_lazy def }

let divide_lazy p ctx pm =
  divide_line
    (filter_ctx p)
    make_lazy_matching
    get_arg_lazy
    p ctx pm

(* Matching against a tuple pattern *)


let get_args_tuple arity p rem = match p with
| {pat_desc = Tpat_any} -> omegas arity @ rem
| {pat_desc = Tpat_tuple args} ->
    args @ rem
| _ ->  assert false

let matcher_tuple arity p rem = match p.pat_desc with
| Tpat_or (_,_,_)     -> raise OrPat
| Tpat_var _          -> get_args_tuple arity omega rem
| _                   ->  get_args_tuple arity p rem

let make_tuple_matching loc arity def = function
    [] -> fatal_error "Matching.make_tuple_matching"
  | (arg, mut) :: argl ->
      let rec make_args pos =
        if pos >= arity
        then argl
        else (Lprim(Pfield (pos, Fld_na (* TODO: tuple*)) , [arg], loc), Alias) :: make_args (pos + 1) in
      {cases = []; args = make_args 0 ;
        default=make_default (matcher_tuple arity) def}


let divide_tuple arity p ctx pm =
  divide_line
    (filter_ctx p)
    (make_tuple_matching p.pat_loc arity)
    (get_args_tuple  arity) p ctx pm

(* Matching against a record pattern *)


let record_matching_line num_fields lbl_pat_list =
  let patv = Array.make num_fields omega in
  List.iter (fun (_, lbl, pat) -> patv.(lbl.lbl_pos) <- pat) lbl_pat_list;
  Array.to_list patv

let get_args_record num_fields p rem = match p with
| {pat_desc=Tpat_any} ->
    record_matching_line num_fields [] @ rem
| {pat_desc=Tpat_record (lbl_pat_list,_)} ->
    record_matching_line num_fields lbl_pat_list @ rem
| _ -> assert false

let matcher_record num_fields p rem = match p.pat_desc with
| Tpat_or (_,_,_) -> raise OrPat
| Tpat_var _      -> get_args_record num_fields omega rem
| _               -> get_args_record num_fields p rem

let make_record_matching loc all_labels def = function
    [] -> fatal_error "Matching.make_record_matching"
  | ((arg, mut) :: argl) ->
      let rec make_args pos =
        if pos >= Array.length all_labels then argl else begin
          let lbl = all_labels.(pos) in
          let access =
            match lbl.lbl_repres with
              Record_regular -> Pfield (lbl.lbl_pos, Fld_record lbl.lbl_name)
            | Record_float -> Pfloatfield (lbl.lbl_pos, Fld_record lbl.lbl_name) in
          let str =
            match lbl.lbl_mut with
              Immutable -> Alias
            | Mutable -> StrictOpt in
          (Lprim(access, [arg], loc), str) :: make_args(pos + 1)
        end in
      let nfields = Array.length all_labels in
      let def= make_default (matcher_record nfields) def in
      {cases = []; args = make_args 0 ; default = def}


let divide_record all_labels p ctx pm =
  let get_args = get_args_record (Array.length all_labels) in
  divide_line
    (filter_ctx p)
    (make_record_matching p.pat_loc all_labels)
    get_args
    p ctx pm

(* Matching against an array pattern *)

let get_key_array = function
  | {pat_desc=Tpat_array patl} -> List.length patl
  | _ -> assert false

let get_args_array p rem = match p with
| {pat_desc=Tpat_array patl} -> patl@rem
| _ -> assert false

let matcher_array len p rem = match p.pat_desc with
| Tpat_or (_,_,_) -> raise OrPat
| Tpat_array args when List.length args=len -> args @ rem
| Tpat_any -> Parmatch.omegas len @ rem
| _ -> raise NoMatch

let make_array_matching kind p def ctx = function
  | [] -> fatal_error "Matching.make_array_matching"
  | ((arg, mut) :: argl) ->
      let len = get_key_array p in
      let rec make_args pos =
        if pos >= len
        then argl
        else (Lprim(Parrayrefu kind, [arg; Lconst(Const_base(Const_int pos))],p.pat_loc),
              StrictOpt) :: make_args (pos + 1) in
      let def = make_default (matcher_array len) def
      and ctx = filter_ctx p ctx in
      {pm={cases = []; args = make_args 0 ; default = def} ;
        ctx=ctx ;
        pat = normalize_pat p}

let divide_array kind ctx pm =
  divide
    (make_array_matching kind)
    (=) get_key_array get_args_array ctx pm


(*
   Specific string test sequence
   Will be called by the bytecode compiler, from bytegen.ml.
   The strategy is first dichotomic search (we perform 3-way tests
   with compare_string), then sequence of equality tests
   when there are less then T=strings_test_threshold static strings to match.

  Increasing T entails (slightly) less code, decreasing T
  (slightly) favors runtime speed.
  T=8 looks a decent tradeoff.
*)

(* Utilities *)

let strings_test_threshold = 8

let prim_string_notequal =
  Pccall{prim_name = "caml_string_notequal";
         prim_arity = 2; prim_alloc = false;
         prim_native_name = ""; prim_native_float = false}

let prim_string_compare =
  Pccall{prim_name = "caml_string_compare";
         prim_arity = 2; prim_alloc = false;
         prim_native_name = ""; prim_native_float = false}

let bind_sw arg k = match arg with
| Lvar _ -> k arg
| _ ->
    let id = Ident.create "switch" in
    Llet (Strict,id,arg,k (Lvar id))


(* Sequential equality tests *)

let make_string_test_sequence loc arg sw d =
  let d,sw = match d with
  | None ->
      begin match sw with
      | (_,d)::sw -> d,sw
      | [] -> assert false
      end
  | Some d -> d,sw in
  bind_sw arg
    (fun arg ->
      List.fold_right
        (fun (s,lam) k ->
          Lifthenelse
            (Lprim
               (prim_string_notequal,
                [arg; Lconst (Const_immstring s)], loc),
             k,lam))
        sw d)

let rec split k xs = match xs with
| [] -> assert false
| x0::xs ->
    if k <= 1 then [],x0,xs
    else
      let xs,y0,ys = split (k-2) xs in
      x0::xs,y0,ys

let zero_lam  = Lconst (Const_base (Const_int 0))

let tree_way_test loc arg lt eq gt =
  Lifthenelse
    (Lprim (Pintcomp Clt,[arg;zero_lam], loc),lt,
     Lifthenelse(Lprim (Pintcomp Clt,[zero_lam;arg], loc),gt,eq))

(* Dichotomic tree *)


let rec do_make_string_test_tree loc arg sw delta d =
  let len = List.length sw in
  if len <= strings_test_threshold+delta then
    make_string_test_sequence loc arg sw d
  else
    let lt,(s,act),gt = split len sw in
    bind_sw
      (Lprim
         (prim_string_compare,
          [arg; Lconst (Const_immstring s)], loc;))
      (fun r ->
        tree_way_test loc r
          (do_make_string_test_tree  loc arg lt delta d)
          act
          (do_make_string_test_tree loc arg gt delta d))

(* Entry point *)
let expand_stringswitch loc arg sw d = match d with
| None ->
    bind_sw arg
      (fun arg -> do_make_string_test_tree loc  arg sw 0 None)
| Some e ->
    bind_sw arg
      (fun arg ->
        make_catch e
          (fun d -> do_make_string_test_tree loc arg sw 1 (Some d)))

(**********************)
(* Generic test trees *)
(**********************)

(* Sharing *)

(* Add handler, if shared *)
let handle_shared () =
  let hs = ref (fun x -> x) in
  let handle_shared act = match act with
  | Switch.Single act -> act
  | Switch.Shared act ->
      let i,h = make_catch_delayed act in
      let ohs = !hs in
      hs := (fun act -> h (ohs act)) ;
      make_exit i in
  hs,handle_shared


let share_actions_tree sw d =
  let store = StoreExp.mk_store () in
(* Default action is always shared *)
  let d =
    match d with
    | None -> None
    | Some d -> Some (store.Switch.act_store_shared d) in
(* Store all other actions *)
  let sw =
    List.map  (fun (cst,act) -> cst,store.Switch.act_store act) sw in

(* Retrieve all actions, includint potentiel default *)
  let acts = store.Switch.act_get_shared () in

(* Array of actual actions *)
  let hs,handle_shared = handle_shared () in
  let acts = Array.map handle_shared acts in

(* Recontruct default and switch list *)
  let d = match d with
  | None -> None
  | Some d -> Some (acts.(d)) in
  let sw = List.map (fun (cst,j) -> cst,acts.(j)) sw in
  !hs,sw,d

(* Note: dichotomic search requires sorted input with no duplicates *)
let rec uniq_lambda_list sw = match sw with
  | []|[_] -> sw
  | (c1,_ as p1)::((c2,_)::sw2 as sw1) ->
      if const_compare c1 c2 = 0 then uniq_lambda_list (p1::sw2)
      else p1::uniq_lambda_list sw1

let sort_lambda_list l =
  let l =
    List.stable_sort (fun (x,_) (y,_) -> const_compare x y) l in
  uniq_lambda_list l

let rec cut n l =
  if n = 0 then [],l
  else match l with
    [] -> raise (Invalid_argument "cut")
  | a::l -> let l1,l2 = cut (n-1) l in a::l1, l2

let rec do_tests_fail loc fail tst arg = function
  | [] -> fail
  | (c, act)::rem ->
      Lifthenelse
        (Lprim (tst, [arg ; Lconst (Const_base c)], loc),
         do_tests_fail loc fail tst arg rem,
         act)

let rec do_tests_nofail loc tst arg = function
  | [] -> fatal_error "Matching.do_tests_nofail"
  | [_,act] -> act
  | (c,act)::rem ->
      Lifthenelse
        (Lprim (tst, [arg ; Lconst (Const_base c)], loc),
         do_tests_nofail loc tst arg rem,
         act)

let make_test_sequence loc fail tst lt_tst arg const_lambda_list =
  let const_lambda_list = sort_lambda_list const_lambda_list in
  let hs,const_lambda_list,fail =
    share_actions_tree const_lambda_list fail in

  let rec make_test_sequence const_lambda_list =
    if List.length const_lambda_list >= 4 && lt_tst <> Pignore then
      split_sequence const_lambda_list
    else match fail with
    | None -> do_tests_nofail loc tst arg const_lambda_list
    | Some fail -> do_tests_fail loc fail tst arg const_lambda_list

  and split_sequence const_lambda_list =
    let list1, list2 =
      cut (List.length const_lambda_list / 2) const_lambda_list in
    Lifthenelse(Lprim(lt_tst,[arg; Lconst(Const_base (fst(List.hd list2)))], loc),
                make_test_sequence list1, make_test_sequence list2)
  in
  hs (make_test_sequence const_lambda_list)


let rec explode_inter offset i j act k =
  if i <= j then
    explode_inter offset i (j-1) act ((j-offset,act)::k)
  else
    k

let max_vals cases acts =
  let vals = Array.make (Array.length acts) 0 in
  for i=Array.length cases-1 downto 0 do
    let l,h,act = cases.(i) in
    vals.(act) <- h - l + 1 + vals.(act)
  done ;
  let max = ref 0 in
  for i = Array.length vals-1 downto 0 do
    if vals.(i) >= vals.(!max) then
      max := i
  done ;
  if vals.(!max) > 1 then
    !max
  else
    -1

let as_int_list cases acts =
  let default = max_vals cases acts in
  let min_key,_,_ = cases.(0)
  and _,max_key,_ = cases.(Array.length cases-1) in

  let rec do_rec i k =
    if i >= 0 then
      let low, high, act =  cases.(i) in
      if act = default then
        do_rec (i-1) k
      else
        do_rec (i-1) (explode_inter min_key low high acts.(act) k)
    else
      k in
  min_key, max_key,do_rec (Array.length cases-1) [],
  (if default >= 0 then Some acts.(default) else None)


module SArg = struct
  type primitive = Lambda.primitive

  let eqint = Pintcomp Ceq
  let neint = Pintcomp Cneq
  let leint = Pintcomp Cle
  let ltint = Pintcomp Clt
  let geint = Pintcomp Cge
  let gtint = Pintcomp Cgt

  type act = Lambda.lambda

  let make_prim p args = Lprim (p,args, Location.none)
  let make_offset arg n = match n with
  | 0 -> arg
  | _ -> Lprim (Poffsetint n,[arg], Location.none)

  let bind arg body =
    let newvar,newarg = match arg with
    | Lvar v -> v,arg
    | _      ->
        let newvar = Ident.create "switcher" in
        newvar,Lvar newvar in
    bind Alias newvar arg (body newarg)
  let make_const i = Lconst (Const_base (Const_int i))
  let make_isout h arg = Lprim (Pisout, [h ; arg], Location.none)
  let make_isin h arg = Lprim (Pnot,[make_isout h arg], Location.none)
  let make_if cond ifso ifnot = Lifthenelse (cond, ifso, ifnot)
  let make_switch arg cases acts =
    let l = ref [] in
    for i = Array.length cases-1 downto 0 do
      l := (i,acts.(cases.(i))) ::  !l
    done ;
    Lswitch(arg,
            {sw_numconsts = Array.length cases ; sw_consts = !l ;
             sw_numblocks = 0 ; sw_blocks =  []  ;
             sw_failaction = None})
  let make_catch  = make_catch_delayed
  let make_exit = make_exit

end

(* Action sharing for Lswitch argument *)
let share_actions_sw sw =
(* Attempt sharing on all actions *)
  let store = StoreExp.mk_store () in
  let fail = match sw.sw_failaction with
  | None -> None
  | Some fail ->
      (* Fail is translated to exit, whatever happens *)
      Some (store.Switch.act_store_shared fail) in
  let consts =
    List.map
      (fun (i,e) -> i,store.Switch.act_store e)
      sw.sw_consts
  and blocks =
    List.map
      (fun (i,e) -> i,store.Switch.act_store e)
      sw.sw_blocks in
  let acts = store.Switch.act_get_shared () in
  let hs,handle_shared = handle_shared () in
  let acts = Array.map handle_shared acts in
  let fail = match fail with
  | None -> None
  | Some fail -> Some (acts.(fail)) in
  !hs,
  { sw with
    sw_consts = List.map (fun (i,j) -> i,acts.(j)) consts ;
    sw_blocks = List.map (fun (i,j) -> i,acts.(j)) blocks ;
    sw_failaction = fail; }

(* Reintroduce fail action in switch argument,
   for the sake of avoiding carrying over huge switches *)

let reintroduce_fail sw = match sw.sw_failaction with
| None ->
    let t = Hashtbl.create 17 in
    let seen (_,l) = match as_simple_exit l with
    | Some i ->
        let old = try Hashtbl.find t i with Not_found -> 0 in
        Hashtbl.replace t i (old+1)
    | None -> () in
    List.iter seen sw.sw_consts ;
    List.iter seen sw.sw_blocks ;
    let i_max = ref (-1)
    and max = ref (-1) in
    Hashtbl.iter
      (fun i c ->
        if c > !max then begin
          i_max := i ;
          max := c
        end) t ;
    if !max >= 3 then
      let default = !i_max in
      let remove =
        List.filter
          (fun (_,lam) -> match as_simple_exit lam with
          | Some j -> j <> default
          | None -> true) in
      {sw with
       sw_consts = remove sw.sw_consts ;
       sw_blocks = remove sw.sw_blocks ;
       sw_failaction = Some (make_exit default)}
    else sw
| Some _ -> sw


module Switcher = Switch.Make(SArg)
open Switch

let lambda_of_int i =  Lconst (Const_base (Const_int i))

let rec last def = function
  | [] -> def
  | [x,_] -> x
  | _::rem -> last def rem

let get_edges low high l = match l with
| [] -> low, high
| (x,_)::_ -> x, last high l


let as_interval_canfail fail low high l =
  let store = StoreExp.mk_store () in

  let do_store tag act =
    let i =  store.act_store act in
(*
    Printlambda.lambda Format.str_formatter act ;
    eprintf "STORE [%s] %i %s\n" tag i (Format.flush_str_formatter ()) ;
*)
    i in

  let rec nofail_rec cur_low cur_high cur_act = function
    | [] ->
        if cur_high = high then
          [cur_low,cur_high,cur_act]
        else
          [(cur_low,cur_high,cur_act) ; (cur_high+1,high, 0)]
    | ((i,act_i)::rem) as all ->
        let act_index = do_store "NO" act_i in
        if cur_high+1= i then
          if act_index=cur_act then
            nofail_rec cur_low i cur_act rem
          else if act_index=0 then
            (cur_low,i-1, cur_act)::fail_rec i i rem
          else
            (cur_low, i-1, cur_act)::nofail_rec i i act_index rem
        else if act_index = 0 then
          (cur_low, cur_high, cur_act)::
          fail_rec (cur_high+1) (cur_high+1) all
        else
          (cur_low, cur_high, cur_act)::
          (cur_high+1,i-1,0)::
          nofail_rec i i act_index rem

  and fail_rec cur_low cur_high = function
    | [] -> [(cur_low, cur_high, 0)]
    | (i,act_i)::rem ->
        let index = do_store "YES" act_i in
        if index=0 then fail_rec cur_low i rem
        else
          (cur_low,i-1,0)::
          nofail_rec i i index rem in

  let init_rec = function
    | [] -> []
    | (i,act_i)::rem ->
        let index = do_store "INIT" act_i in
        if index=0 then
          fail_rec low i rem
        else
          if low < i then
            (low,i-1,0)::nofail_rec i i index rem
          else
            nofail_rec i i index rem in

  assert (do_store "FAIL" fail = 0) ; (* fail has action index 0 *)
  let r = init_rec l in
  Array.of_list r,  store

let as_interval_nofail l =
  let store = StoreExp.mk_store () in

  let rec i_rec cur_low cur_high cur_act = function
    | [] ->
        [cur_low, cur_high, cur_act]
    | (i,act)::rem ->
        let act_index = store.act_store act in
        if act_index = cur_act then
          i_rec cur_low i cur_act rem
        else
          (cur_low, cur_high, cur_act)::
          i_rec i i act_index rem in
  let inters = match l with
  | (i,act)::rem ->
      let act_index = store.act_store act in
      i_rec i i act_index rem
  | _ -> assert false in

  Array.of_list inters, store


let sort_int_lambda_list l =
  List.sort
    (fun (i1,_) (i2,_) ->
      if i1 < i2 then -1
      else if i2 < i1 then 1
      else 0)
    l

let as_interval fail low high l =
  let l = sort_int_lambda_list l in
  get_edges low high l,
  (match fail with
  | None -> as_interval_nofail l
  | Some act -> as_interval_canfail act low high l)

let call_switcher fail arg low high int_lambda_list =
  let edges, (cases, actions) =
    as_interval fail low high int_lambda_list in
  Switcher.zyva edges arg cases actions


let exists_ctx ok ctx =
  List.exists
    (function
      | {right=p::_} -> ok p
      | _ -> assert false)
    ctx

let rec list_as_pat = function
  | [] -> fatal_error "Matching.list_as_pat"
  | [pat] -> pat
  | pat::rem ->
      {pat with pat_desc = Tpat_or (pat,list_as_pat rem,None)}


let rec pat_as_list k = function
  | {pat_desc=Tpat_or (p1,p2,_)} ->
      pat_as_list (pat_as_list k p2) p1
  | p -> p::k

(* Extracting interesting patterns *)
exception All

let rec extract_pat seen k p = match p.pat_desc with
| Tpat_or (p1,p2,_) ->
    let k1,seen1 = extract_pat seen k p1 in
    extract_pat seen1 k1 p2
| Tpat_alias (p,_,_) ->
    extract_pat  seen k p
| Tpat_var _|Tpat_any ->
    raise All
| _ ->
    let q = normalize_pat p in
    if  List.exists (compat q) seen then
      k, seen
    else
      q::k, q::seen

let extract_mat seen pss =
  let r,_ =
    List.fold_left
      (fun (k,seen) ps -> match ps with
      | p::_ -> extract_pat seen k p
      | _ -> assert false)
      ([],seen)
      pss in
  r



let complete_pats_constrs = function
  | p::_ as pats ->
      List.map
        (pat_of_constr p)
        (complete_constrs p (List.map get_key_constr pats))
  | _ -> assert false


let mk_res get_key env last_choice idef cant_fail ctx =

  let env,fail,jumps_fail = match last_choice with
  | [] ->
      env, None, jumps_empty
  | [p] when group_var p ->
      env,
      Some (Lstaticraise (idef,[])),
      jumps_singleton idef ctx
  | _ ->
      (idef,cant_fail,last_choice)::env,
      None, jumps_empty in
  let klist,jumps =
    List.fold_right
      (fun (i,cant_fail,pats) (klist,jumps) ->
        let act = Lstaticraise (i,[])
        and pat = list_as_pat pats in
        let klist =
          List.fold_right
            (fun pat klist -> (get_key pat,act)::klist)
            pats klist
        and ctx = if cant_fail then ctx else ctx_lub pat ctx in
        klist,jumps_add i ctx jumps)
      env ([],jumps_fail) in
  fail, klist, jumps


(*
     Following two ``failaction'' function compute n, the trap handler
    to jump to in case of failure of elementary tests
*)

let mk_failaction_neg partial ctx def = match partial with
| Partial ->
    begin match def with
    | (_,idef)::_ ->
        Some (Lstaticraise (idef,[])),[],jumps_singleton idef ctx
    | _ ->
       (* Act as Total, this means
          If no appropriate default matrix exists,
          then this switch cannot fail *)
        None, [], jumps_empty
    end
| Total ->
    None, [], jumps_empty



(* Conforme a l'article et plus simple qu'avant *)
and mk_failaction_pos partial seen ctx defs  =
  if dbg then begin
    prerr_endline "**POS**" ;
    pretty_def defs ;
    ()
  end ;
  let rec scan_def env to_test defs = match to_test,defs with
  | ([],_)|(_,[]) ->
      List.fold_left
        (fun  (klist,jumps) (pats,i)->
          let action = Lstaticraise (i,[]) in
          let klist =
            List.fold_right
              (fun pat r -> (get_key_constr pat,action)::r)
              pats klist
          and jumps =
            jumps_add i (ctx_lub (list_as_pat pats) ctx) jumps in
          klist,jumps)
        ([],jumps_empty) env
  | _,(pss,idef)::rem ->
      let now, later =
        List.partition
          (fun (p,p_ctx) -> ctx_match p_ctx pss) to_test in
      match now with
      | [] -> scan_def env to_test rem
      | _  -> scan_def ((List.map fst now,idef)::env) later rem in

  scan_def
    []
    (List.map
       (fun pat -> pat, ctx_lub pat ctx)
       (complete_pats_constrs seen))
    defs


let combine_constant loc arg cst partial ctx def
    (const_lambda_list, total, pats) =
  let fail, to_add, local_jumps =
    mk_failaction_neg partial ctx def in
  let const_lambda_list = to_add@const_lambda_list in
  let lambda1 =
    match cst with
    | Const_int _ ->
        let int_lambda_list =
          List.map (function Const_int n, l -> n,l | _ -> assert false)
            const_lambda_list in
        call_switcher fail arg min_int max_int int_lambda_list
    | Const_char _ ->
        let int_lambda_list =
          List.map (function Const_char c, l -> (Char.code c, l)
            | _ -> assert false)
            const_lambda_list in
        call_switcher fail arg 0 255 int_lambda_list
    | Const_string _ ->
(* Note as the bytecode compiler may resort to dichotmic search,
   the clauses of strinswitch  are sorted with duplicate removed.
   This partly applies to the native code compiler, which requires
   no duplicates *)
        let const_lambda_list = sort_lambda_list const_lambda_list in
        let sw =
          List.map
            (fun (c,act) -> match c with
            | Const_string (s,_) -> s,act
            | _ -> assert false)
            const_lambda_list in
        let hs,sw,fail = share_actions_tree sw fail in
        hs (Lstringswitch (arg,sw,fail,loc))
    | Const_float _ ->
        make_test_sequence loc 
          fail
          (Pfloatcomp Cneq) (Pfloatcomp Clt)
          arg const_lambda_list
    | Const_int32 _ ->
        make_test_sequence loc
          fail
          (Pbintcomp(Pint32, Cneq)) (Pbintcomp(Pint32, Clt))
          arg const_lambda_list
    | Const_int64 _ ->
        make_test_sequence loc
          fail
          (Pbintcomp(Pint64, Cneq)) (Pbintcomp(Pint64, Clt))
          arg const_lambda_list
    | Const_nativeint _ ->
        make_test_sequence loc
          fail
          (Pbintcomp(Pnativeint, Cneq)) (Pbintcomp(Pnativeint, Clt))
          arg const_lambda_list
  in lambda1,jumps_union local_jumps total



let split_cases tag_lambda_list =
  let rec split_rec = function
      [] -> ([], [])
    | (cstr, act) :: rem ->
        let (consts, nonconsts) = split_rec rem in
        match cstr with
          Cstr_constant n -> ((n, act) :: consts, nonconsts)
        | Cstr_block n    -> (consts, (n, act) :: nonconsts)
        | _ -> assert false in
  let const, nonconst = split_rec tag_lambda_list in
  sort_int_lambda_list const,
  sort_int_lambda_list nonconst

let split_extension_cases tag_lambda_list =
  let rec split_rec = function
      [] -> ([], [])
    | (cstr, act) :: rem ->
        let (consts, nonconsts) = split_rec rem in
        match cstr with
          Cstr_extension(path, true) -> ((path, act) :: consts, nonconsts)
        | Cstr_extension(path, false) -> (consts, (path, act) :: nonconsts)
        | _ -> assert false in
  split_rec tag_lambda_list


let combine_constructor loc arg ex_pat cstr partial ctx def
    (tag_lambda_list, total1, pats) =
  if cstr.cstr_consts < 0 then begin
    (* Special cases for extensions *)
    let fail, to_add, local_jumps =
      mk_failaction_neg partial ctx def in
    let tag_lambda_list = to_add@tag_lambda_list in
    let lambda1 =
      let consts, nonconsts = split_extension_cases tag_lambda_list in
      let default, consts, nonconsts =
        match fail with
        | None ->
            begin match consts, nonconsts with
            | _, (_, act)::rem -> act, consts, rem
            | (_, act)::rem, _ -> act, rem, nonconsts
            | _ -> assert false
            end
        | Some fail -> fail, consts, nonconsts in
      let nonconst_lambda =
        match nonconsts with
          [] -> default
        | _ ->
            let tag = Ident.create "tag" in
            let tests =
              List.fold_right
                (fun (path, act) rem ->
                   Lifthenelse(Lprim(Pintcomp Ceq,
                                     [Lvar tag;
                                      transl_path ex_pat.pat_env path], loc),
                               act, rem))
                nonconsts
                default
            in
              Llet(Alias, tag, Lprim(Pfield (0, Fld_na), [arg], loc), tests)
      in
        List.fold_right
          (fun (path, act) rem ->
             Lifthenelse(Lprim(Pintcomp Ceq,
                               [arg; transl_path ex_pat.pat_env path], loc),
                         act, rem))
          consts
          nonconst_lambda
    in
    lambda1, jumps_union local_jumps total1
  end else begin
    (* Regular concrete type *)
    let ncases = List.length tag_lambda_list
    and nconstrs =  cstr.cstr_consts + cstr.cstr_nonconsts in
    let sig_complete = ncases = nconstrs in
    let fails,local_jumps =
      if sig_complete then [],jumps_empty
      else
        mk_failaction_pos partial pats ctx def in

    let tag_lambda_list = fails @ tag_lambda_list in
    let (consts, nonconsts) = split_cases tag_lambda_list in
    let lambda1 =
      match same_actions tag_lambda_list with
      | Some act -> act
      | _ ->
          match
            (cstr.cstr_consts, cstr.cstr_nonconsts, consts, nonconsts)
          with
          | (1, 1, [0, act1], [0, act2]) ->
              Lifthenelse(arg, act2, act1)
          | (n,_,_,[])  ->
              call_switcher None arg 0 (n-1) consts
          | (n, _, _, _) ->
              match same_actions nonconsts with
              | None ->
(* Emit a switch, as bytecode implements this sophisticated instruction *)
                  let sw =
                    {sw_numconsts = cstr.cstr_consts; sw_consts = consts;
                     sw_numblocks = cstr.cstr_nonconsts; sw_blocks = nonconsts;
                     sw_failaction = None} in
                  let hs,sw = share_actions_sw sw in
                  let sw = reintroduce_fail sw in
                  hs (Lswitch (arg,sw))
              | Some act ->
                  Lifthenelse
                    (Lprim (Pisint, [arg], loc),
                     call_switcher
                       None arg
                       0 (n-1) consts,
                     act) in
    lambda1, jumps_union local_jumps total1
  end

let make_test_sequence_variant_constant fail arg int_lambda_list =
  let _, (cases, actions) =
    as_interval fail min_int max_int int_lambda_list in
  Switcher.test_sequence arg cases actions

let call_switcher_variant_constant fail arg int_lambda_list =
  call_switcher fail arg min_int max_int int_lambda_list


let call_switcher_variant_constr loc fail arg int_lambda_list =
  let v = Ident.create "variant" in
  Llet(Alias, v, Lprim(Pfield (0, Fld_na), [arg], loc),
       call_switcher
         fail (Lvar v) min_int max_int int_lambda_list)

let combine_variant loc row arg partial ctx def (tag_lambda_list, total1, pats) =
  let row = Btype.row_repr row in
  let num_constr = ref 0 in
  if row.row_closed then
    List.iter
      (fun (_, f) ->
        match Btype.row_field_repr f with
          Rabsent | Reither(true, _::_, _, _) -> ()
        | _ -> incr num_constr)
      row.row_fields
  else
    num_constr := max_int;
  let test_int_or_block arg if_int if_block =
    Lifthenelse(Lprim (Pisint, [arg], loc), if_int, if_block) in
  let sig_complete =  List.length tag_lambda_list = !num_constr
  and one_action = same_actions tag_lambda_list in
  let fail, to_add, local_jumps =
    if
      sig_complete  || (match partial with Total -> true | _ -> false)
    then
      None, [], jumps_empty
    else
      mk_failaction_neg partial ctx def in
  let tag_lambda_list = to_add@tag_lambda_list in
  let (consts, nonconsts) = split_cases tag_lambda_list in
  let lambda1 = match fail, one_action with
  | None, Some act -> act
  | _,_ ->
      match (consts, nonconsts) with
      | ([n, act1], [m, act2]) when fail=None ->
          test_int_or_block arg act1 act2
      | (_, []) -> (* One can compare integers and pointers *)
          make_test_sequence_variant_constant fail arg consts
      | ([], _) ->
          let lam = call_switcher_variant_constr loc
              fail arg nonconsts in
          (* One must not dereference integers *)
          begin match fail with
          | None -> lam
          | Some fail -> test_int_or_block arg fail lam
          end
      | (_, _) ->
          let lam_const =
            call_switcher_variant_constant
              fail arg consts
          and lam_nonconst =
            call_switcher_variant_constr loc
              fail arg nonconsts in
          test_int_or_block arg lam_const lam_nonconst
  in
  lambda1, jumps_union local_jumps total1


let combine_array loc arg kind partial ctx def
    (len_lambda_list, total1, pats)  =
  let fail, to_add, local_jumps = mk_failaction_neg partial  ctx def in
  let len_lambda_list = to_add @ len_lambda_list in
  let lambda1 =
    let newvar = Ident.create "len" in
    let switch =
      call_switcher
        fail (Lvar newvar)
        0 max_int len_lambda_list in
    bind
      Alias newvar (Lprim(Parraylength kind, [arg], loc)) switch in
  lambda1, jumps_union local_jumps total1

(* Insertion of debugging events *)

let rec event_branch repr lam =
  begin match lam, repr with
    (_, None) ->
      lam
  | (Levent(lam', ev), Some r) ->
      incr r;
      Levent(lam', {lev_loc = ev.lev_loc;
                    lev_kind = ev.lev_kind;
                    lev_repr = repr;
                    lev_env = ev.lev_env})
  | (Llet(str, id, lam, body), _) ->
      Llet(str, id, lam, event_branch repr body)
  | Lstaticraise _,_ -> lam
  | (_, Some r) ->
      Printlambda.lambda Format.str_formatter lam ;
      fatal_error
        ("Matching.event_branch: "^Format.flush_str_formatter ())
  end


(*
   This exception is raised when the compiler cannot produce code
   because control cannot reach the compiled clause,

   Unused is raised initialy in compile_test.

   compile_list (for compiling switch results) catch Unused

   comp_match_handlers (for compililing splitted matches)
   may reraise Unused


*)

exception Unused

let compile_list compile_fun division =

  let rec c_rec totals = function
  | [] -> [], jumps_unions totals, []
  | (key, cell) :: rem ->
      begin match cell.ctx with
      | [] -> c_rec totals rem
      | _  ->
          try
            let (lambda1, total1) = compile_fun cell.ctx cell.pm in
            let c_rem, total, new_pats =
              c_rec
                (jumps_map ctx_combine total1::totals) rem in
            ((key,lambda1)::c_rem), total, (cell.pat::new_pats)
          with
          | Unused -> c_rec totals rem
      end in
  c_rec [] division


let compile_orhandlers compile_fun lambda1 total1 ctx to_catch =
  let rec do_rec r total_r = function
    | [] -> r,total_r
    | (mat,i,vars,pm)::rem ->
        begin try
          let ctx = select_columns mat ctx in
          let handler_i, total_i = compile_fun ctx pm in
          match raw_action r with
          | Lstaticraise (j,args) ->
              if i=j then
                List.fold_right2 (bind Alias) vars args handler_i,
                jumps_map (ctx_rshift_num (ncols mat)) total_i
              else
                do_rec r total_r rem
          | _ ->
              do_rec
                (Lstaticcatch (r,(i,vars), handler_i))
                (jumps_union
                   (jumps_remove i total_r)
                   (jumps_map (ctx_rshift_num (ncols mat)) total_i))
              rem
        with
        | Unused ->
            do_rec (Lstaticcatch (r, (i,vars), lambda_unit)) total_r rem
        end in
  do_rec lambda1 total1 to_catch


let compile_test compile_fun partial divide combine ctx to_match =
  let division = divide ctx to_match in
  let c_div = compile_list compile_fun division in
  match c_div with
  | [],_,_ ->
     begin match mk_failaction_neg partial ctx to_match.default with
     | None,_,_ -> raise Unused
     | Some l,_,total -> l,total
     end
  | _ ->
      combine ctx to_match.default c_div

(* Attempt to avoid some useless bindings by lowering them *)

(* Approximation of v present in lam *)
let rec approx_present v = function
  | Lconst _ -> false
  | Lstaticraise (_,args) ->
      List.exists (fun lam -> approx_present v lam) args
  | Lprim (_,args,_) ->
      List.exists (fun lam -> approx_present v lam) args
  | Llet (Alias, _, l1, l2) ->
      approx_present v l1 || approx_present v l2
  | Lvar vv -> Ident.same v vv
  | _ -> true

let rec lower_bind v arg lam = match lam with
| Lifthenelse (cond, ifso, ifnot) ->
    let pcond = approx_present v cond
    and pso = approx_present v ifso
    and pnot = approx_present v ifnot in
    begin match pcond, pso, pnot with
    | false, false, false -> lam
    | false, true, false ->
        Lifthenelse (cond, lower_bind v arg ifso, ifnot)
    | false, false, true ->
        Lifthenelse (cond, ifso, lower_bind v arg ifnot)
    | _,_,_ -> bind Alias v arg lam
    end
| Lswitch (ls,({sw_consts=[i,act] ; sw_blocks = []} as sw))
    when not (approx_present v ls) ->
      Lswitch (ls, {sw with sw_consts = [i,lower_bind v arg act]})
| Lswitch (ls,({sw_consts=[] ; sw_blocks = [i,act]} as sw))
    when not (approx_present v ls) ->
      Lswitch (ls, {sw with sw_blocks = [i,lower_bind v arg act]})
| Llet (Alias, vv, lv, l) ->
    if approx_present v lv then
      bind Alias v arg lam
    else
      Llet (Alias, vv, lv, lower_bind v arg l)
| _ ->
    bind Alias v arg lam

let bind_check str v arg lam = match str,arg with
| _, Lvar _ ->bind str v arg lam
| Alias,_ -> lower_bind v arg lam
| _,_     -> bind str v arg lam

let comp_exit ctx m = match m.default with
| (_,i)::_ -> Lstaticraise (i,[]), jumps_singleton i ctx
| _        -> fatal_error "Matching.comp_exit"



let rec comp_match_handlers comp_fun partial ctx arg first_match next_matchs =
  match next_matchs with
  | [] -> comp_fun partial ctx arg first_match
  | rem ->
      let rec c_rec body total_body = function
        | [] -> body, total_body
        (* Hum, -1 meant never taken
        | (-1,pm)::rem -> c_rec body total_body rem *)
        | (i,pm)::rem ->
            let ctx_i,total_rem = jumps_extract i total_body in
            begin match ctx_i with
            | [] -> c_rec body total_body rem
            | _ ->
                try
                  let li,total_i =
                    comp_fun
                      (match rem with [] -> partial | _ -> Partial)
                      ctx_i arg pm in
                  c_rec
                    (Lstaticcatch (body,(i,[]),li))
                    (jumps_union total_i total_rem)
                    rem
                with
                | Unused ->
                    c_rec (Lstaticcatch (body,(i,[]),lambda_unit))
                      total_rem  rem
            end in
   try
      let first_lam,total = comp_fun Partial ctx arg first_match in
      c_rec first_lam total rem
   with Unused -> match next_matchs with
   | [] -> raise Unused
   | (_,x)::xs ->  comp_match_handlers comp_fun partial ctx arg x xs

(* To find reasonable names for variables *)

let rec name_pattern default = function
    (pat :: patl, action) :: rem ->
      begin match pat.pat_desc with
        Tpat_var (id, _) -> id
      | Tpat_alias(p, id, _) -> id
      | _ -> name_pattern default rem
      end
  | _ -> Ident.create default

let arg_to_var arg cls = match arg with
| Lvar v -> v,arg
| _ ->
    let v = name_pattern "match" cls in
    v,Lvar v


(*
  The main compilation function.
   Input:
      repr=used for inserting debug events
      partial=exhaustiveness information from Parmatch
      ctx=a context
      m=a pattern matching

   Output: a lambda term, a jump summary {..., exit number -> context, .. }
*)

let rec compile_match repr partial ctx m = match m with
| { cases = [] } -> comp_exit ctx m
| { cases = ([], action) :: rem } ->
    if is_guarded action then begin
      let (lambda, total) =
        compile_match None partial ctx { m with cases = rem } in
      event_branch repr (patch_guarded lambda action), total
    end else
      (event_branch repr action, jumps_empty)
| { args = (arg, str)::argl } ->
    let v,newarg = arg_to_var arg m.cases in
    let first_match,rem =
      split_precompile (Some v)
        { m with args = (newarg, Alias) :: argl } in
    let (lam, total) =
      comp_match_handlers
        ((if dbg then do_compile_matching_pr else do_compile_matching) repr)
        partial ctx newarg first_match rem in
    bind_check str v arg lam, total
| _ -> assert false


(* verbose version of do_compile_matching, for debug *)

and do_compile_matching_pr repr partial ctx arg x =
  prerr_string "COMPILE: " ;
  prerr_endline (match partial with Partial -> "Partial" | Total -> "Total") ;
  prerr_endline "MATCH" ;
  pretty_precompiled x ;
  prerr_endline "CTX" ;
  pretty_ctx ctx ;
  let (_, jumps) as r =  do_compile_matching repr partial ctx arg x in
  prerr_endline "JUMPS" ;
  pretty_jumps jumps ;
  r

and do_compile_matching repr partial ctx arg pmh = match pmh with
| Pm pm ->
  let pat = what_is_cases pm.cases in
  begin match pat.pat_desc with
  | Tpat_any ->
      compile_no_test
        divide_var ctx_rshift repr partial ctx pm
  | Tpat_tuple patl ->
      compile_no_test
        (divide_tuple (List.length patl) (normalize_pat pat)) ctx_combine
        repr partial ctx pm
  | Tpat_record ((_, lbl,_)::_,_) ->
      compile_no_test
        (divide_record lbl.lbl_all (normalize_pat pat))
        ctx_combine repr partial ctx pm
  | Tpat_constant cst ->
      compile_test
        (compile_match repr partial) partial
        divide_constant
        (combine_constant pat.pat_loc arg cst partial)
        ctx pm
  | Tpat_construct (_, cstr, _) ->
      compile_test
        (compile_match repr partial) partial
        divide_constructor (combine_constructor pat.pat_loc arg pat cstr partial)
        ctx pm
  | Tpat_array _ ->
      let kind = Typeopt.array_pattern_kind pat in
      compile_test (compile_match repr partial) partial
        (divide_array kind) (combine_array pat.pat_loc arg kind partial)
        ctx pm
  | Tpat_lazy _ ->
      compile_no_test
        (divide_lazy (normalize_pat pat))
        ctx_combine repr partial ctx pm
  | Tpat_variant(lab, _, row) ->
      compile_test (compile_match repr partial) partial
        (divide_variant !row)
        (combine_variant pat.pat_loc !row arg partial)
        ctx pm
  | _ -> assert false
  end
| PmVar {inside=pmh ; var_arg=arg} ->
    let lam, total =
      do_compile_matching repr partial (ctx_lshift ctx) arg pmh in
    lam, jumps_map ctx_rshift total
| PmOr {body=body ; handlers=handlers} ->
    let lam, total = compile_match repr partial ctx body in
    compile_orhandlers (compile_match repr partial) lam total ctx handlers

and compile_no_test divide up_ctx repr partial ctx to_match =
  let {pm=this_match ; ctx=this_ctx } = divide ctx to_match in
  let lambda,total = compile_match repr partial this_ctx this_match in
  lambda, jumps_map up_ctx total




(* The entry points *)

(*
   If there is a guard in a matching or a lazy pattern,
   then set exhaustiveness info to Partial.
   (because of side effects, assume the worst).

   Notice that exhaustiveness information is trusted by the compiler,
   that is, a match flagged as Total should not fail at runtime.
   More specifically, for instance if match y with x::_ -> x uis flagged
   total (as it happens during JoCaml compilation) then y cannot be []
   at runtime. As a consequence, the static Total exhaustiveness information
   have to to be downgraded to Partial, in the dubious cases where guards
   or lazy pattern execute arbitrary code that may perform side effects
   and change the subject values.
LM:
   Lazy pattern was PR #5992, initial patch by lwp25.
   I have  generalized teh patch, so as to also find mutable fields.
*)

let find_in_pat pred =
  let rec find_rec p =
    pred p.pat_desc ||
    begin match p.pat_desc with
    | Tpat_alias (p,_,_) | Tpat_variant (_,Some p,_) | Tpat_lazy p ->
        find_rec p
    | Tpat_tuple ps|Tpat_construct (_,_,ps) | Tpat_array ps ->
        List.exists find_rec ps
    | Tpat_record (lpats,_) ->
        List.exists
          (fun (_, _, p) -> find_rec p)
          lpats
    | Tpat_or (p,q,_) ->
        find_rec p || find_rec q
    | Tpat_constant _ | Tpat_var _
    | Tpat_any | Tpat_variant (_,None,_) -> false
  end in
  find_rec

let is_lazy_pat = function
  | Tpat_lazy _ -> true
  | Tpat_alias _ | Tpat_variant _ | Tpat_record _
  | Tpat_tuple _|Tpat_construct _ | Tpat_array _
  | Tpat_or _ | Tpat_constant _ | Tpat_var _ | Tpat_any
      -> false

let is_lazy p = find_in_pat is_lazy_pat p

let have_mutable_field p = match p with
| Tpat_record (lps,_) ->
    List.exists
      (fun (_,lbl,_) ->
        match lbl.Types.lbl_mut with
        | Mutable -> true
        | Immutable -> false)
      lps
| Tpat_alias _ | Tpat_variant _ | Tpat_lazy _
| Tpat_tuple _|Tpat_construct _ | Tpat_array _
| Tpat_or _
| Tpat_constant _ | Tpat_var _ | Tpat_any
  -> false

let is_mutable p = find_in_pat have_mutable_field p

(* Downgrade Total when
   1. Matching accesses some mutable fields;
   2. And there are  guards or lazy patterns.
*)

let check_partial is_mutable is_lazy pat_act_list = function
  | Partial -> Partial
  | Total ->
      if
        List.exists
          (fun (pats, lam) ->
            is_mutable pats && (is_guarded lam || is_lazy pats))
          pat_act_list
      then Partial
      else Total

let check_partial_list =
  check_partial (List.exists is_mutable) (List.exists is_lazy)
let check_partial = check_partial is_mutable is_lazy

(* have toplevel handler when appropriate *)

let start_ctx n = [{left=[] ; right = omegas n}]

let check_total total lambda i handler_fun =
  if jumps_is_empty total then
    lambda
  else begin
    Lstaticcatch(lambda, (i,[]), handler_fun())
  end

let compile_matching loc repr handler_fun arg pat_act_list partial =
  let partial = check_partial pat_act_list partial in
  match partial with
  | Partial ->
      let raise_num = next_raise_count () in
      let pm =
        { cases = List.map (fun (pat, act) -> ([pat], act)) pat_act_list;
          args = [arg, Strict] ;
          default = [[[omega]],raise_num]} in
      begin try
        let (lambda, total) = compile_match repr partial (start_ctx 1) pm in
        check_total total lambda raise_num handler_fun
      with
      | Unused -> assert false (* ; handler_fun() *)
      end
  | Total ->
      let pm =
        { cases = List.map (fun (pat, act) -> ([pat], act)) pat_act_list;
          args = [arg, Strict] ;
          default = []} in
      let (lambda, total) = compile_match repr partial (start_ctx 1) pm in
      assert (jumps_is_empty total) ;
      lambda


let partial_function loc () =
  (* [Location.get_pos_info] is too expensive *)
  let (fname, line, char) = Location.get_pos_info loc.Location.loc_start in
  Lprim(Praise Raise_regular, [Lprim(Pmakeblock(0, Lambda.default_tag_info, Immutable),
          [transl_normal_path Predef.path_match_failure;
           Lconst(Const_block(0, Lambda.default_tag_info,
              [Const_base(Const_string (fname, None));
               Const_base(Const_int line);
               Const_base(Const_int char)]))], loc)], loc)

let for_function loc repr param pat_act_list partial =
  compile_matching loc repr (partial_function loc) param pat_act_list partial

(* In the following two cases, exhaustiveness info is not available! *)
let for_trywith param pat_act_list =
  compile_matching Location.none None
    (fun () -> Lprim(Praise Raise_reraise, [param], Location.none))
    param pat_act_list Partial

let for_let loc param pat body =
  compile_matching loc None (partial_function loc) param [pat, body] Partial

(* Handling of tupled functions and matchings *)

(* Easy case since variables are available *)
let for_tupled_function loc paraml pats_act_list partial =
  let partial = check_partial_list pats_act_list partial in
  let raise_num = next_raise_count () in
  let omegas = [List.map (fun _ -> omega) paraml] in
  let pm =
    { cases = pats_act_list;
      args = List.map (fun id -> (Lvar id, Strict)) paraml ;
      default = [omegas,raise_num]
    } in
  try
    let (lambda, total) = compile_match None partial
        (start_ctx (List.length paraml)) pm in
    check_total total lambda raise_num (partial_function loc)
  with
  | Unused -> partial_function loc ()



let flatten_pattern size p = match p.pat_desc with
| Tpat_tuple args -> args
| Tpat_any -> omegas size
| _ -> raise Cannot_flatten

let rec flatten_pat_line size p k = match p.pat_desc with
| Tpat_any ->  omegas size::k
| Tpat_tuple args -> args::k
| Tpat_or (p1,p2,_) ->  flatten_pat_line size p1 (flatten_pat_line size p2 k)
| Tpat_alias (p,_,_) -> (* Note: if this 'as' pat is here, then this is a
                           useless binding, solves PR #3780 *)
    flatten_pat_line size p k
| _ -> fatal_error "Matching.flatten_pat_line"

let flatten_cases size cases =
  List.map
    (fun (ps,action) -> match ps with
    | [p] -> flatten_pattern size p,action
    | _ -> fatal_error "Matching.flatten_case")
    cases

let flatten_matrix size pss =
  List.fold_right
    (fun ps r -> match ps with
    | [p] -> flatten_pat_line size p r
    | _   -> fatal_error "Matching.flatten_matrix")
    pss []

let flatten_def size def =
  List.map
    (fun (pss,i) -> flatten_matrix size pss,i)
    def

let flatten_pm size args pm =
    {args = args ; cases = flatten_cases size pm.cases ;
     default = flatten_def size pm.default}


let flatten_precompiled size args  pmh = match pmh with
| Pm pm -> Pm (flatten_pm size args pm)
| PmOr {body=b ; handlers=hs ; or_matrix=m} ->
    PmOr
      {body=flatten_pm size args b ;
       handlers=
         List.map
          (fun (mat,i,vars,pm) -> flatten_matrix size mat,i,vars,pm)
          hs ;
       or_matrix=flatten_matrix size m ;}
| PmVar _ -> assert false

(*
   compiled_flattened is a ``comp_fun'' argument to comp_match_handlers.
   Hence it needs a fourth argument, which it ignores
*)

let compile_flattened repr partial ctx _ pmh = match pmh with
| Pm pm -> compile_match repr partial ctx pm
| PmOr {body=b ; handlers=hs} ->
    let lam, total = compile_match repr partial ctx b in
    compile_orhandlers (compile_match repr partial) lam total ctx hs
| PmVar _ -> assert false

let do_for_multiple_match loc paraml pat_act_list partial =
  let repr = None in
  let partial = check_partial pat_act_list partial in
  let raise_num,pm1 =
    match partial with
    | Partial ->
        let raise_num = next_raise_count () in
        raise_num,
        { cases = List.map (fun (pat, act) -> ([pat], act)) pat_act_list;
          args = [Lprim(Pmakeblock(0, Lambda.default_tag_info, Immutable), paraml, loc), Strict] ;
          default = [[[omega]],raise_num] }
    | _ ->
        -1,
        { cases = List.map (fun (pat, act) -> ([pat], act)) pat_act_list;
          args = [Lprim(Pmakeblock(0, Lambda.default_tag_info, Immutable), paraml, loc), Strict] ;
          default = [] } in

  try
    try
(* Once for checking that compilation is possible *)
      let next, nexts = split_precompile None pm1 in

      let size = List.length paraml
      and idl = List.map (fun _ -> Ident.create "match") paraml in
      let args =  List.map (fun id -> Lvar id, Alias) idl in

      let flat_next = flatten_precompiled size args next
      and flat_nexts =
        List.map
          (fun (e,pm) ->  e,flatten_precompiled size args pm)
          nexts in

      let lam, total =
        comp_match_handlers
          (compile_flattened repr)
          partial (start_ctx size) () flat_next flat_nexts in
      List.fold_right2 (bind Strict) idl paraml
        (match partial with
        | Partial ->
            check_total total lam raise_num (partial_function loc)
        | Total ->
            assert (jumps_is_empty total) ;
            lam)
    with Cannot_flatten ->
      let (lambda, total) = compile_match None partial (start_ctx 1) pm1 in
      begin match partial with
      | Partial ->
          check_total total lambda raise_num (partial_function loc)
      | Total ->
          assert (jumps_is_empty total) ;
          lambda
      end
  with Unused ->
    assert false (* ; partial_function loc () *)

(* #PR4828: Believe it or not, the 'paraml' argument below
   may not be side effect free. *)

let arg_to_var arg cls = match arg with
| Lvar v -> v,arg
| _ ->
    let v = name_pattern "match" cls in
    v,Lvar v


let param_to_var param = match param with
| Lvar v -> v,None
| _ -> Ident.create "match",Some param

let bind_opt (v,eo) k = match eo with
| None -> k
| Some e ->  Lambda.bind Strict v e k

let for_multiple_match loc paraml pat_act_list partial =
  let v_paraml = List.map param_to_var paraml in
  let paraml = List.map (fun (v,_) -> Lvar v) v_paraml in
  List.fold_right bind_opt v_paraml
    (do_for_multiple_match loc paraml pat_act_list partial)

end
module Translobj : sig 
#1 "translobj.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*         Jerome Vouillon, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Lambda

val oo_prim: string -> lambda

val share: structured_constant -> lambda
val meth: lambda -> string -> lambda * lambda list

val reset_labels: unit -> unit
val transl_label_init: lambda -> lambda
val transl_store_label_init:
    Ident.t -> int -> ('a -> lambda) -> 'a -> int * lambda

val method_ids: IdentSet.t ref (* reset when starting a new wrapper *)

val oo_wrap: Env.t -> bool -> ('a -> lambda) -> 'a -> lambda
val oo_add_class: Ident.t -> Env.t * bool

val reset: unit -> unit

end = struct
#1 "translobj.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*         Jerome Vouillon, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Misc
open Primitive
open Asttypes
open Longident
open Lambda

(* Get oo primitives identifiers *)

let oo_prim name =
  try
    transl_normal_path
      (fst (Env.lookup_value (Ldot (Lident "CamlinternalOO", name)) Env.empty))
  with Not_found ->
    fatal_error ("Primitive " ^ name ^ " not found.")

(* Share blocks *)

let consts : (structured_constant, Ident.t) Hashtbl.t = Hashtbl.create 17

let share c =
  match c with
    Const_block (n, _,  l) when l <> [] ->
      begin try
        Lvar (Hashtbl.find consts c)
      with Not_found ->
        let id = Ident.create "shared" in
        Hashtbl.add consts c id;
        Lvar id
      end
  | _ -> Lconst c

(* Collect labels *)

let cache_required = ref false
let method_cache = ref lambda_unit
let method_count = ref 0
let method_table = ref []

let meth_tag s = Lconst(Const_base(Const_int(Btype.hash_variant s)))

let next_cache tag =
  let n = !method_count in
  incr method_count;
  (tag, [!method_cache; Lconst(Const_base(Const_int n))])

let rec is_path = function
    Lvar _ | Lprim (Pgetglobal _, [], _) | Lconst _ -> true
  | Lprim (Pfield _, [lam], _) -> is_path lam
  | Lprim ((Parrayrefu _ | Parrayrefs _), [lam1; lam2], _) ->
      is_path lam1 && is_path lam2
  | _ -> false

let meth obj lab =
  let tag = meth_tag lab in
  if not (!cache_required && !Clflags.native_code) then (tag, []) else
  if not (is_path obj) then next_cache tag else
  try
    let r = List.assoc obj !method_table in
    try
      (tag, List.assoc tag !r)
    with Not_found ->
      let p = next_cache tag in
      r := p :: !r;
      p
  with Not_found ->
    let p = next_cache tag in
    method_table := (obj, ref [p]) :: !method_table;
    p

let reset_labels () =
  Hashtbl.clear consts;
  method_count := 0;
  method_table := []

(* Insert labels *)

let string s = Lconst (Const_base (Const_string (s, None)))
let int n = Lconst (Const_base (Const_int n))

let prim_makearray =
  { prim_name = "caml_make_vect"; prim_arity = 2; prim_alloc = true;
    prim_native_name = ""; prim_native_float = false}

(* Also use it for required globals *)
let transl_label_init expr =
  let expr =
    Hashtbl.fold
      (fun c id expr -> Llet(Alias, id, Lconst c, expr))
      consts expr
  in
  let expr =
    List.fold_right
      (fun id expr -> Lsequence(Lprim(Pgetglobal id, [], Location.none), expr))
      (Env.get_required_globals ()) expr
  in
  Env.reset_required_globals ();
  reset_labels ();
  expr

let transl_store_label_init glob size f arg =
  method_cache := Lprim(Pfield (size, Fld_na), [Lprim(Pgetglobal glob, [], Location.none)], Location.none);
  let expr = f arg in
  let (size, expr) =
    if !method_count = 0 then (size, expr) else
    (size+1,
     Lsequence(
     Lprim(Psetfield(size, false, Fld_set_na),
           [Lprim(Pgetglobal glob, [], Location.none);
            Lprim (Pccall prim_makearray, [int !method_count; int 0], Location.none)], Location.none),
     expr))
  in
  (size, transl_label_init expr)

(* Share classes *)

let wrapping = ref false
let top_env = ref Env.empty
let classes = ref []
let method_ids = ref IdentSet.empty

let oo_add_class id =
  classes := id :: !classes;
  (!top_env, !cache_required)

let oo_wrap env req f x =
  if !wrapping then
    if !cache_required then f x else
    try cache_required := true; let lam = f x in cache_required := false; lam
    with exn -> cache_required := false; raise exn
  else try
    wrapping := true;
    cache_required := req;
    top_env := env;
    classes := [];
    method_ids := IdentSet.empty;
    let lambda = f x in
    let lambda =
      List.fold_left
        (fun lambda id ->
          Llet(StrictOpt, id,
               Lprim(Pmakeblock(0, Lambda.default_tag_info, Mutable),
                     [lambda_unit; lambda_unit; lambda_unit], Location.none),
               lambda))
        lambda !classes
    in
    wrapping := false;
    top_env := Env.empty;
    lambda
  with exn ->
    wrapping := false;
    top_env := Env.empty;
    raise exn

let reset () =
  Hashtbl.clear consts;
  cache_required := false;
  method_cache := lambda_unit;
  method_count := 0;
  method_table := [];
  wrapping := false;
  top_env := Env.empty;
  classes := [];
  method_ids := IdentSet.empty

end
module Translcore : sig 
#1 "translcore.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Translation from typed abstract syntax to lambda terms,
   for the core language *)

open Asttypes
open Typedtree
open Lambda

val transl_exp: expression -> lambda
val transl_apply: lambda -> (label * expression option * optional) list
                  -> Location.t -> lambda
val transl_let: rec_flag -> value_binding list -> lambda -> lambda
val transl_primitive: Location.t -> Primitive.description -> lambda

val check_recursive_lambda: Ident.t list -> lambda -> bool

type error =
    Illegal_letrec_pat
  | Illegal_letrec_expr
  | Free_super_var
  | Unknown_builtin_primitive of string

exception Error of Location.t * error

open Format

val report_error: formatter -> error -> unit

(* Forward declaration -- to be filled in by Translmod.transl_module *)
val transl_module :
      (module_coercion -> Path.t option -> module_expr -> lambda) ref
val transl_object :
      (Ident.t -> string list -> class_expr -> lambda) ref

end = struct
#1 "translcore.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Translation from typed abstract syntax to lambda terms,
   for the core language *)

open Misc
open Asttypes
open Primitive
open Types
open Typedtree
open Typeopt
open Lambda

type error =
    Illegal_letrec_pat
  | Illegal_letrec_expr
  | Free_super_var
  | Unknown_builtin_primitive of string

exception Error of Location.t * error

(* Forward declaration -- to be filled in by Translmod.transl_module *)
let transl_module =
  ref((fun cc rootpath modl -> assert false) :
      module_coercion -> Path.t option -> module_expr -> lambda)

let transl_object =
  ref (fun id s cl -> assert false :
       Ident.t -> string list -> class_expr -> lambda)

(* Translation of primitives *)

let comparisons_table = create_hashtable 11 [
  "%equal",
      (Pccall{prim_name = "caml_equal"; prim_arity = 2; prim_alloc = true;
              prim_native_name = ""; prim_native_float = false},
       Pintcomp Ceq,
       Pfloatcomp Ceq,
       Pccall{prim_name = "caml_string_equal"; prim_arity = 2;
              prim_alloc = false;
              prim_native_name = ""; prim_native_float = false},
       Pbintcomp(Pnativeint, Ceq),
       Pbintcomp(Pint32, Ceq),
       Pbintcomp(Pint64, Ceq),
       true);
  "%notequal",
      (Pccall{prim_name = "caml_notequal"; prim_arity = 2; prim_alloc = true;
              prim_native_name = ""; prim_native_float = false},
       Pintcomp Cneq,
       Pfloatcomp Cneq,
       Pccall{prim_name = "caml_string_notequal"; prim_arity = 2;
              prim_alloc = false; prim_native_name = "";
              prim_native_float = false},
       Pbintcomp(Pnativeint, Cneq),
       Pbintcomp(Pint32, Cneq),
       Pbintcomp(Pint64, Cneq),
       true);
  "%lessthan",
      (Pccall{prim_name = "caml_lessthan"; prim_arity = 2; prim_alloc = true;
              prim_native_name = ""; prim_native_float = false},
       Pintcomp Clt,
       Pfloatcomp Clt,
       Pccall{prim_name = "caml_string_lessthan"; prim_arity = 2;
              prim_alloc = false; prim_native_name = "";
              prim_native_float = false},
       Pbintcomp(Pnativeint, Clt),
       Pbintcomp(Pint32, Clt),
       Pbintcomp(Pint64, Clt),
       false);
  "%greaterthan",
      (Pccall{prim_name = "caml_greaterthan"; prim_arity = 2; prim_alloc = true;
              prim_native_name = ""; prim_native_float = false},
       Pintcomp Cgt,
       Pfloatcomp Cgt,
       Pccall{prim_name = "caml_string_greaterthan"; prim_arity = 2;
              prim_alloc = false; prim_native_name = "";
              prim_native_float = false},
       Pbintcomp(Pnativeint, Cgt),
       Pbintcomp(Pint32, Cgt),
       Pbintcomp(Pint64, Cgt),
       false);
  "%lessequal",
      (Pccall{prim_name = "caml_lessequal"; prim_arity = 2; prim_alloc = true;
              prim_native_name = ""; prim_native_float = false},
       Pintcomp Cle,
       Pfloatcomp Cle,
       Pccall{prim_name = "caml_string_lessequal"; prim_arity = 2;
              prim_alloc = false; prim_native_name = "";
              prim_native_float = false},
       Pbintcomp(Pnativeint, Cle),
       Pbintcomp(Pint32, Cle),
       Pbintcomp(Pint64, Cle),
       false);
  "%greaterequal",
      (Pccall{prim_name = "caml_greaterequal"; prim_arity = 2;
              prim_alloc = true;
              prim_native_name = ""; prim_native_float = false},
       Pintcomp Cge,
       Pfloatcomp Cge,
       Pccall{prim_name = "caml_string_greaterequal"; prim_arity = 2;
              prim_alloc = false; prim_native_name = "";
              prim_native_float = false},
       Pbintcomp(Pnativeint, Cge),
       Pbintcomp(Pint32, Cge),
       Pbintcomp(Pint64, Cge),
       false);
  "%compare",
      (Pccall{prim_name = "caml_compare"; prim_arity = 2; prim_alloc = true;
              prim_native_name = ""; prim_native_float = false},
       Pccall{prim_name = "caml_int_compare"; prim_arity = 2;
              prim_alloc = false; prim_native_name = "";
              prim_native_float = false},
       Pccall{prim_name = "caml_float_compare"; prim_arity = 2;
              prim_alloc = false; prim_native_name = "";
              prim_native_float = false},
       Pccall{prim_name = "caml_string_compare"; prim_arity = 2;
              prim_alloc = false; prim_native_name = "";
              prim_native_float = false},
       Pccall{prim_name = "caml_nativeint_compare"; prim_arity = 2;
              prim_alloc = false; prim_native_name = "";
              prim_native_float = false},
       Pccall{prim_name = "caml_int32_compare"; prim_arity = 2;
              prim_alloc = false; prim_native_name = "";
              prim_native_float = false},
       Pccall{prim_name = "caml_int64_compare"; prim_arity = 2;
              prim_alloc = false; prim_native_name = "";
              prim_native_float = false},
       false)
]

let primitives_table = create_hashtable 57 [
  "%bytes_to_string", Pbytes_to_string;
  "%bytes_of_string", Pbytes_of_string;
  "%identity", Pidentity;
  "%ignore", Pignore;
  "%field0", Pfield (0, Fld_na);
  "%field1", Pfield (1, Fld_na);
  "%setfield0", Psetfield(0, true, Fld_set_na);
  "%makeblock", Pmakeblock(0, Lambda.default_tag_info, Immutable);
  "%makemutable", Pmakeblock(0,Lambda.default_tag_info,  Mutable);
  "%raise", Praise Raise_regular;
  "%reraise", Praise Raise_reraise;
  "%raise_notrace", Praise Raise_notrace;
  "%sequand", Psequand;
  "%sequor", Psequor;
  "%boolnot", Pnot;
  "%big_endian", Pctconst Big_endian;
  "%word_size", Pctconst Word_size;
  "%ostype_unix", Pctconst Ostype_unix;
  "%ostype_win32", Pctconst Ostype_win32;
  "%ostype_cygwin", Pctconst Ostype_cygwin;
  "%negint", Pnegint;
  "%succint", Poffsetint 1;
  "%predint", Poffsetint(-1);
  "%addint", Paddint;
  "%subint", Psubint;
  "%mulint", Pmulint;
  "%divint", Pdivint;
  "%modint", Pmodint;
  "%andint", Pandint;
  "%orint", Porint;
  "%xorint", Pxorint;
  "%lslint", Plslint;
  "%lsrint", Plsrint;
  "%asrint", Pasrint;
  "%eq", Pintcomp Ceq;
  "%noteq", Pintcomp Cneq;
  "%ltint", Pintcomp Clt;
  "%leint", Pintcomp Cle;
  "%gtint", Pintcomp Cgt;
  "%geint", Pintcomp Cge;
  "%incr", Poffsetref(1);
  "%decr", Poffsetref(-1);
  "%intoffloat", Pintoffloat;
  "%floatofint", Pfloatofint;
  "%negfloat", Pnegfloat;
  "%absfloat", Pabsfloat;
  "%addfloat", Paddfloat;
  "%subfloat", Psubfloat;
  "%mulfloat", Pmulfloat;
  "%divfloat", Pdivfloat;
  "%eqfloat", Pfloatcomp Ceq;
  "%noteqfloat", Pfloatcomp Cneq;
  "%ltfloat", Pfloatcomp Clt;
  "%lefloat", Pfloatcomp Cle;
  "%gtfloat", Pfloatcomp Cgt;
  "%gefloat", Pfloatcomp Cge;
  "%string_length", Pstringlength;
  "%string_safe_get", Pstringrefs;
  "%string_safe_set", Pstringsets;
  "%string_unsafe_get", Pstringrefu;
  "%string_unsafe_set", Pstringsetu;

  "%bytes_length", Pbyteslength;
  "%bytes_safe_get", Pbytesrefs;
  "%bytes_safe_set", Pbytessets;
  "%bytes_unsafe_get", Pbytesrefu;
  "%bytes_unsafe_set", Pbytessetu;

  "%array_length", Parraylength Pgenarray;
  "%array_safe_get", Parrayrefs Pgenarray;
  "%array_safe_set", Parraysets Pgenarray;
  "%array_unsafe_get", Parrayrefu Pgenarray;
  "%array_unsafe_set", Parraysetu Pgenarray;
  "%obj_size", Parraylength Pgenarray;
  "%obj_field", Parrayrefu Pgenarray;
  "%obj_set_field", Parraysetu Pgenarray;
  "%obj_is_int", Pisint;
  "%lazy_force", Plazyforce;
  "%nativeint_of_int", Pbintofint Pnativeint;
  "%nativeint_to_int", Pintofbint Pnativeint;
  "%nativeint_neg", Pnegbint Pnativeint;
  "%nativeint_add", Paddbint Pnativeint;
  "%nativeint_sub", Psubbint Pnativeint;
  "%nativeint_mul", Pmulbint Pnativeint;
  "%nativeint_div", Pdivbint Pnativeint;
  "%nativeint_mod", Pmodbint Pnativeint;
  "%nativeint_and", Pandbint Pnativeint;
  "%nativeint_or",  Porbint Pnativeint;
  "%nativeint_xor", Pxorbint Pnativeint;
  "%nativeint_lsl", Plslbint Pnativeint;
  "%nativeint_lsr", Plsrbint Pnativeint;
  "%nativeint_asr", Pasrbint Pnativeint;
  "%int32_of_int", Pbintofint Pint32;
  "%int32_to_int", Pintofbint Pint32;
  "%int32_neg", Pnegbint Pint32;
  "%int32_add", Paddbint Pint32;
  "%int32_sub", Psubbint Pint32;
  "%int32_mul", Pmulbint Pint32;
  "%int32_div", Pdivbint Pint32;
  "%int32_mod", Pmodbint Pint32;
  "%int32_and", Pandbint Pint32;
  "%int32_or",  Porbint Pint32;
  "%int32_xor", Pxorbint Pint32;
  "%int32_lsl", Plslbint Pint32;
  "%int32_lsr", Plsrbint Pint32;
  "%int32_asr", Pasrbint Pint32;
  "%int64_of_int", Pbintofint Pint64;
  "%int64_to_int", Pintofbint Pint64;
  "%int64_neg", Pnegbint Pint64;
  "%int64_add", Paddbint Pint64;
  "%int64_sub", Psubbint Pint64;
  "%int64_mul", Pmulbint Pint64;
  "%int64_div", Pdivbint Pint64;
  "%int64_mod", Pmodbint Pint64;
  "%int64_and", Pandbint Pint64;
  "%int64_or",  Porbint Pint64;
  "%int64_xor", Pxorbint Pint64;
  "%int64_lsl", Plslbint Pint64;
  "%int64_lsr", Plsrbint Pint64;
  "%int64_asr", Pasrbint Pint64;
  "%nativeint_of_int32", Pcvtbint(Pint32, Pnativeint);
  "%nativeint_to_int32", Pcvtbint(Pnativeint, Pint32);
  "%int64_of_int32", Pcvtbint(Pint32, Pint64);
  "%int64_to_int32", Pcvtbint(Pint64, Pint32);
  "%int64_of_nativeint", Pcvtbint(Pnativeint, Pint64);
  "%int64_to_nativeint", Pcvtbint(Pint64, Pnativeint);
  "%caml_ba_ref_1",
    Pbigarrayref(false, 1, Pbigarray_unknown, Pbigarray_unknown_layout);
  "%caml_ba_ref_2",
    Pbigarrayref(false, 2, Pbigarray_unknown, Pbigarray_unknown_layout);
  "%caml_ba_ref_3",
    Pbigarrayref(false, 3, Pbigarray_unknown, Pbigarray_unknown_layout);
  "%caml_ba_set_1",
    Pbigarrayset(false, 1, Pbigarray_unknown, Pbigarray_unknown_layout);
  "%caml_ba_set_2",
    Pbigarrayset(false, 2, Pbigarray_unknown, Pbigarray_unknown_layout);
  "%caml_ba_set_3",
    Pbigarrayset(false, 3, Pbigarray_unknown, Pbigarray_unknown_layout);
  "%caml_ba_unsafe_ref_1",
    Pbigarrayref(true, 1, Pbigarray_unknown, Pbigarray_unknown_layout);
  "%caml_ba_unsafe_ref_2",
    Pbigarrayref(true, 2, Pbigarray_unknown, Pbigarray_unknown_layout);
  "%caml_ba_unsafe_ref_3",
    Pbigarrayref(true, 3, Pbigarray_unknown, Pbigarray_unknown_layout);
  "%caml_ba_unsafe_set_1",
    Pbigarrayset(true, 1, Pbigarray_unknown, Pbigarray_unknown_layout);
  "%caml_ba_unsafe_set_2",
    Pbigarrayset(true, 2, Pbigarray_unknown, Pbigarray_unknown_layout);
  "%caml_ba_unsafe_set_3",
    Pbigarrayset(true, 3, Pbigarray_unknown, Pbigarray_unknown_layout);
  "%caml_ba_dim_1", Pbigarraydim(1);
  "%caml_ba_dim_2", Pbigarraydim(2);
  "%caml_ba_dim_3", Pbigarraydim(3);
  "%caml_string_get16", Pstring_load_16(false);
  "%caml_string_get16u", Pstring_load_16(true);
  "%caml_string_get32", Pstring_load_32(false);
  "%caml_string_get32u", Pstring_load_32(true);
  "%caml_string_get64", Pstring_load_64(false);
  "%caml_string_get64u", Pstring_load_64(true);
  "%caml_string_set16", Pstring_set_16(false);
  "%caml_string_set16u", Pstring_set_16(true);
  "%caml_string_set32", Pstring_set_32(false);
  "%caml_string_set32u", Pstring_set_32(true);
  "%caml_string_set64", Pstring_set_64(false);
  "%caml_string_set64u", Pstring_set_64(true);
  "%caml_bigstring_get16", Pbigstring_load_16(false);
  "%caml_bigstring_get16u", Pbigstring_load_16(true);
  "%caml_bigstring_get32", Pbigstring_load_32(false);
  "%caml_bigstring_get32u", Pbigstring_load_32(true);
  "%caml_bigstring_get64", Pbigstring_load_64(false);
  "%caml_bigstring_get64u", Pbigstring_load_64(true);
  "%caml_bigstring_set16", Pbigstring_set_16(false);
  "%caml_bigstring_set16u", Pbigstring_set_16(true);
  "%caml_bigstring_set32", Pbigstring_set_32(false);
  "%caml_bigstring_set32u", Pbigstring_set_32(true);
  "%caml_bigstring_set64", Pbigstring_set_64(false);
  "%caml_bigstring_set64u", Pbigstring_set_64(true);
  "%bswap16", Pbswap16;
  "%bswap_int32", Pbbswap(Pint32);
  "%bswap_int64", Pbbswap(Pint64);
  "%bswap_native", Pbbswap(Pnativeint);
  "%int_as_pointer", Pint_as_pointer;
]

let prim_makearray =
  { prim_name = "caml_make_vect"; prim_arity = 2; prim_alloc = true;
    prim_native_name = ""; prim_native_float = false }

let prim_obj_dup =
  { prim_name = "caml_obj_dup"; prim_arity = 1; prim_alloc = true;
    prim_native_name = ""; prim_native_float = false }

let find_primitive loc prim_name =
  match prim_name with
      "%revapply" -> Prevapply 
    | "%apply" -> Pdirapply 
    | "%loc_LOC" -> Ploc Loc_LOC
    | "%loc_FILE" -> Ploc Loc_FILE
    | "%loc_LINE" -> Ploc Loc_LINE
    | "%loc_POS" -> Ploc Loc_POS
    | "%loc_MODULE" -> Ploc Loc_MODULE
    | name -> Hashtbl.find primitives_table name

let transl_prim loc prim args =
  let prim_name = prim.prim_name in
  try
    let (gencomp, intcomp, floatcomp, stringcomp,
         nativeintcomp, int32comp, int64comp,
         simplify_constant_constructor) =
      Hashtbl.find comparisons_table prim_name in
    begin match args with
      [arg1; {exp_desc = Texp_construct(_, {cstr_tag = Cstr_constant _}, _)}]
      when simplify_constant_constructor ->
        intcomp
    | [{exp_desc = Texp_construct(_, {cstr_tag = Cstr_constant _}, _)}; arg2]
      when simplify_constant_constructor ->
        intcomp
    | [arg1; {exp_desc = Texp_variant(_, None)}]
      when simplify_constant_constructor ->
        intcomp
    | [{exp_desc = Texp_variant(_, None)}; exp2]
      when simplify_constant_constructor ->
        intcomp
    | [arg1; arg2] when has_base_type arg1 Predef.path_int
                     || has_base_type arg1 Predef.path_char ->
        intcomp
    | [arg1; arg2] when has_base_type arg1 Predef.path_float ->
        floatcomp
    | [arg1; arg2] when has_base_type arg1 Predef.path_string ->
        stringcomp
    | [arg1; arg2] when has_base_type arg1 Predef.path_nativeint ->
        nativeintcomp
    | [arg1; arg2] when has_base_type arg1 Predef.path_int32 ->
        int32comp
    | [arg1; arg2] when has_base_type arg1 Predef.path_int64 ->
        int64comp
    | _ ->
        gencomp
    end
  with Not_found ->
  try
    let p = find_primitive loc prim_name in
    (* Try strength reduction based on the type of the argument *)
    begin match (p, args) with
        (Psetfield(n, _, dbg_info), [arg1; arg2]) -> Psetfield(n, maybe_pointer arg2, dbg_info)
      | (Parraylength Pgenarray, [arg])   -> Parraylength(array_kind arg)
      | (Parrayrefu Pgenarray, arg1 :: _) -> Parrayrefu(array_kind arg1)
      | (Parraysetu Pgenarray, arg1 :: _) -> Parraysetu(array_kind arg1)
      | (Parrayrefs Pgenarray, arg1 :: _) -> Parrayrefs(array_kind arg1)
      | (Parraysets Pgenarray, arg1 :: _) -> Parraysets(array_kind arg1)
      | (Pbigarrayref(unsafe, n, Pbigarray_unknown, Pbigarray_unknown_layout),
                      arg1 :: _) ->
            let (k, l) = bigarray_kind_and_layout arg1 in
            Pbigarrayref(unsafe, n, k, l)
      | (Pbigarrayset(unsafe, n, Pbigarray_unknown, Pbigarray_unknown_layout),
                      arg1 :: _) ->
            let (k, l) = bigarray_kind_and_layout arg1 in
            Pbigarrayset(unsafe, n, k, l)
      | _ -> p
    end
  with Not_found ->
    if String.length prim_name > 0 && prim_name.[0] = '%' then
      raise(Error(loc, Unknown_builtin_primitive prim_name));
    Pccall prim


(* Eta-expand a primitive without knowing the types of its arguments *)

let transl_primitive loc p =
  let prim =
    try
      let (gencomp, _, _, _, _, _, _, _) =
        Hashtbl.find comparisons_table p.prim_name in
      gencomp
    with Not_found ->
    try
      find_primitive loc p.prim_name
    with Not_found ->
      Pccall p in
  match prim with
  | Plazyforce ->
      let parm = Ident.create "prim" in
      Lfunction(Curried, [parm],
                Matching.inline_lazy_force (Lvar parm) Location.none)
  | Ploc kind ->
    let lam = lam_of_loc kind loc in
    begin match p.prim_arity with
      | 0 -> lam
      | 1 -> (* TODO: we should issue a warning ? *)
        let param = Ident.create "prim" in
        Lfunction(Curried, [param],
          Lprim(Pmakeblock(0, Lambda.default_tag_info, Immutable), [lam; Lvar param], loc))
      | _ -> assert false
    end
  | _ ->
      let rec make_params n =
        if n <= 0 then [] else Ident.create "prim" :: make_params (n-1) in
      let params = make_params p.prim_arity in
      if params = [] then  Lprim(prim,[], loc) (* arity = 0 in Buckle? TODO: unneeded *)
      else Lfunction(Curried, params,
                Lprim(prim, List.map (fun id -> Lvar id) params, loc))

(* To check the well-formedness of r.h.s. of "let rec" definitions *)

let check_recursive_lambda idlist lam =
  let rec check_top idlist = function
    | Lvar v -> not (List.mem v idlist)
    | Llet (_, _, _, _) as lam when check_recursive_recordwith idlist lam ->
        true
    | Llet(str, id, arg, body) ->
        check idlist arg && check_top (add_let id arg idlist) body
    | Lletrec(bindings, body) ->
        let idlist' = add_letrec bindings idlist in
        List.for_all (fun (id, arg) -> check idlist' arg) bindings &&
        check_top idlist' body
    | Lprim (Pmakearray (Pgenarray), args, _) -> false
    | Lsequence (lam1, lam2) -> check idlist lam1 && check_top idlist lam2
    | Levent (lam, _) -> check_top idlist lam
    | lam -> check idlist lam

  and check idlist = function
    | Lvar _ -> true
    | Lfunction(kind, params, body) -> true
    | Llet (_, _, _, _) as lam when check_recursive_recordwith idlist lam ->
        true
    | Llet(str, id, arg, body) ->
        check idlist arg && check (add_let id arg idlist) body
    | Lletrec(bindings, body) ->
        let idlist' = add_letrec bindings idlist in
        List.for_all (fun (id, arg) -> check idlist' arg) bindings &&
        check idlist' body
    | Lprim(Pmakeblock(tag, _,  mut), args, _) ->
        List.for_all (check idlist) args
    | Lprim(Pmakearray(_), args, _) ->
        List.for_all (check idlist) args
    | Lsequence (lam1, lam2) -> check idlist lam1 && check idlist lam2
    | Levent (lam, _) -> check idlist lam
    | lam ->
        let fv = free_variables lam in
        not (List.exists (fun id -> IdentSet.mem id fv) idlist)

  and add_let id arg idlist =
    let fv = free_variables arg in
    if List.exists (fun id -> IdentSet.mem id fv) idlist
    then id :: idlist
    else idlist

  and add_letrec bindings idlist =
    List.fold_right (fun (id, arg) idl -> add_let id arg idl)
                    bindings idlist

  (* reverse-engineering the code generated by transl_record case 2 *)
  (* If you change this, you probably need to change Bytegen.size_of_lambda. *)
  and check_recursive_recordwith idlist = function
    | Llet (Strict, id1, Lprim (Pduprecord _, [e1], _), body) ->
       check_top idlist e1
       && check_recordwith_updates idlist id1 body
    | _ -> false

  and check_recordwith_updates idlist id1 = function
    | Lsequence (Lprim ((Psetfield _ | Psetfloatfield _), [Lvar id2; e1], _), cont)
        -> id2 = id1 && check idlist e1
           && check_recordwith_updates idlist id1 cont
    | Lvar id2 -> id2 = id1
    | _ -> false

  in check_top idlist lam

(* To propagate structured constants *)

exception Not_constant

let extract_constant = function
    Lconst sc -> sc
  | _ -> raise Not_constant

let extract_float = function
    Const_base(Const_float f) -> f
  | _ -> fatal_error "Translcore.extract_float"

(* To find reasonable names for let-bound and lambda-bound idents *)

let rec name_pattern default = function
    [] -> Ident.create default
  | {c_lhs=p; _} :: rem ->
      match p.pat_desc with
        Tpat_var (id, _) -> id
      | Tpat_alias(p, id, _) -> id
      | _ -> name_pattern default rem

(* Push the default values under the functional abstractions *)

let rec push_defaults loc bindings cases partial =
  match cases with
    [{c_lhs=pat; c_guard=None;
      c_rhs={exp_desc = Texp_function(l, pl,partial)} as exp}] ->
      let pl = push_defaults exp.exp_loc bindings pl partial in
      [{c_lhs=pat; c_guard=None;
        c_rhs={exp with exp_desc = Texp_function(l, pl, partial)}}]
  | [{c_lhs=pat; c_guard=None;
      c_rhs={exp_attributes=[{txt="#default"},_];
             exp_desc = Texp_let
               (Nonrecursive, binds, ({exp_desc = Texp_function _} as e2))}}] ->
      push_defaults loc (binds :: bindings) [{c_lhs=pat;c_guard=None;c_rhs=e2}]
                    partial
  | [case] ->
      let exp =
        List.fold_left
          (fun exp binds ->
            {exp with exp_desc = Texp_let(Nonrecursive, binds, exp)})
          case.c_rhs bindings
      in
      [{case with c_rhs=exp}]
  | {c_lhs=pat; c_rhs=exp; c_guard=_} :: _ when bindings <> [] ->
      let param = name_pattern "param" cases in
      let name = Ident.name param in
      let exp =
        { exp with exp_loc = loc; exp_desc =
          Texp_match
            ({exp with exp_type = pat.pat_type; exp_desc =
              Texp_ident (Path.Pident param, mknoloc (Longident.Lident name),
                          {val_type = pat.pat_type; val_kind = Val_reg;
                           val_attributes = [];
                           Types.val_loc = Location.none;
                          })},
             cases, [], partial) }
      in
      push_defaults loc bindings
        [{c_lhs={pat with pat_desc = Tpat_var (param, mknoloc name)};
          c_guard=None; c_rhs=exp}]
        Total
  | _ ->
      cases

(* Insertion of debugging events *)

let event_before exp lam = match lam with
| Lstaticraise (_,_) -> lam
| _ ->
  if !Clflags.record_event_when_debug && !Clflags.debug
  then Levent(lam, {lev_loc = exp.exp_loc;
                    lev_kind = Lev_before;
                    lev_repr = None;
                    lev_env = Env.summary exp.exp_env})
  else lam

let event_after exp lam =
  if !Clflags.record_event_when_debug && !Clflags.debug
  then Levent(lam, {lev_loc = exp.exp_loc;
                    lev_kind = Lev_after exp.exp_type;
                    lev_repr = None;
                    lev_env = Env.summary exp.exp_env})
  else lam

let event_function exp lam =
  if !Clflags.record_event_when_debug && !Clflags.debug then
    let repr = Some (ref 0) in
    let (info, body) = lam repr in
    (info,
     Levent(body, {lev_loc = exp.exp_loc;
                   lev_kind = Lev_function;
                   lev_repr = repr;
                   lev_env = Env.summary exp.exp_env}))
  else
    lam None

let primitive_is_ccall = function
  (* Determine if a primitive is a Pccall or will be turned later into
     a C function call that may raise an exception *)
  | Pccall _ | Pstringrefs | Pstringsets | Parrayrefs _ | Parraysets _ |
    Pbigarrayref _ | Pbigarrayset _ | Pduprecord _ -> true
  | _ -> false

(* Assertions *)

let assert_failed exp =
  let (fname, line, char) =
    Location.get_pos_info exp.exp_loc.Location.loc_start in
     
  let fname = 
    if  not !Location.absname then Filename.basename fname else fname 
  in   
  
  Lprim(Praise Raise_regular, [event_after exp
    (Lprim(Pmakeblock(0, Lambda.default_tag_info, Immutable),
          [transl_normal_path Predef.path_assert_failure;
           Lconst(Const_block(0, Lambda.default_tag_info,
              [Const_base(Const_string (fname, None));
               Const_base(Const_int line);
               Const_base(Const_int char)]))], exp.exp_loc))], exp.exp_loc)
;;

let rec cut n l =
  if n = 0 then ([],l) else
  match l with [] -> failwith "Translcore.cut"
  | a::l -> let (l1,l2) = cut (n-1) l in (a::l1,l2)

(* Translation of expressions *)

let try_ids = Hashtbl.create 8

let rec transl_exp e =
  let eval_once =
    (* Whether classes for immediate objects must be cached *)
    match e.exp_desc with
      Texp_function _ | Texp_for _ | Texp_while _ -> false
    | _ -> true
  in
  if eval_once then transl_exp0 e else
  Translobj.oo_wrap e.exp_env true transl_exp0 e

and transl_exp0 e =
  match e.exp_desc with
    Texp_ident(path, _, {val_kind = Val_prim p}) ->
      let public_send = p.prim_name = "%send" in
      if public_send || p.prim_name = "%sendself" then
        let kind = if public_send then Public None else Self in
        let obj = Ident.create "obj" and meth = Ident.create "meth" in
        Lfunction(Curried, [obj; meth], Lsend(kind, Lvar meth, Lvar obj, [],
                                              e.exp_loc))
      else if p.prim_name = "%sendcache" then
        let obj = Ident.create "obj" and meth = Ident.create "meth" in
        let cache = Ident.create "cache" and pos = Ident.create "pos" in
        Lfunction(Curried, [obj; meth; cache; pos],
                  Lsend(Cached, Lvar meth, Lvar obj, [Lvar cache; Lvar pos],
                        e.exp_loc))
      else
        transl_primitive e.exp_loc p
  | Texp_ident(path, _, {val_kind = Val_anc _}) ->
      raise(Error(e.exp_loc, Free_super_var))
  | Texp_ident(path, _, {val_kind = Val_reg | Val_self _}) ->
      transl_path ~loc:e.exp_loc e.exp_env path
  | Texp_ident _ -> fatal_error "Translcore.transl_exp: bad Texp_ident"
  | Texp_constant cst ->
      Lconst(Const_base cst)
  | Texp_let(rec_flag, pat_expr_list, body) ->
      transl_let rec_flag pat_expr_list (event_before body (transl_exp body))
  | Texp_function (_, pat_expr_list, partial) ->
      let ((kind, params), body) =
        event_function e
          (function repr ->
            let pl = push_defaults e.exp_loc [] pat_expr_list partial in
            transl_function e.exp_loc !Clflags.native_code repr partial pl)
      in
      Lfunction(kind, params, body)
  | Texp_apply({exp_desc = Texp_ident(path, _, {val_kind = Val_prim p})},
               oargs)
    when List.length oargs >= p.prim_arity
    && List.for_all (fun (_, arg,_) -> arg <> None) oargs ->
      let args, args' = cut p.prim_arity oargs in
      let wrap f =
        if args' = []
        then event_after e f
        else event_after e (transl_apply f args' e.exp_loc)
      in
      let wrap0 f =
        if args' = [] then f else wrap f in
      let args =
         List.map (function _, Some x, _ -> x | _ -> assert false) args in
      let argl = transl_list args in
      let public_send = p.prim_name = "%send"
        || not !Clflags.native_code && p.prim_name = "%sendcache"in
      if public_send || p.prim_name = "%sendself" then
        let kind = if public_send then Public None else Self in
        let obj = List.hd argl in
        wrap (Lsend (kind, List.nth argl 1, obj, [], e.exp_loc))
      else if p.prim_name = "%sendcache" then
        match argl with [obj; meth; cache; pos] ->
          wrap (Lsend(Cached, meth, obj, [cache; pos], e.exp_loc))
        | _ -> assert false
      else begin
        let prim = transl_prim e.exp_loc p args in
        match (prim, args) with
          (Praise k, [arg1]) ->
            let targ = List.hd argl in
            let k =
              match k, targ with
              | Raise_regular, Lvar id
                when Hashtbl.mem try_ids id ->
                  Raise_reraise
              | _ ->
                  k
            in
            wrap0 (Lprim(Praise k, [event_after arg1 targ], e.exp_loc))
        | (Ploc kind, []) ->
          lam_of_loc kind e.exp_loc
        | (Ploc kind, [arg1]) ->
          let lam = lam_of_loc kind arg1.exp_loc in
          Lprim(Pmakeblock(0, Lambda.default_tag_info, Immutable), lam :: argl, e.exp_loc)
        | (Ploc _, _) -> assert false
        | (_, _) ->
            begin match (prim, argl) with
            | (Plazyforce, [a]) ->
                wrap (Matching.inline_lazy_force a e.exp_loc)
            | (Plazyforce, _) -> assert false
            |_ -> let p = Lprim(prim, argl, e.exp_loc) in
               if primitive_is_ccall prim then wrap p else wrap0 p
            end
      end
  | Texp_apply(funct, oargs) ->
      event_after e (transl_apply (transl_exp funct) oargs e.exp_loc)
  | Texp_match(arg, pat_expr_list, exn_pat_expr_list, partial) ->
    transl_match e arg pat_expr_list exn_pat_expr_list partial
  | Texp_try(body, pat_expr_list) ->
      let id = name_pattern "exn" pat_expr_list in
      Ltrywith(transl_exp body, id,
               Matching.for_trywith (Lvar id) (transl_cases_try pat_expr_list))
  | Texp_tuple el ->
      let ll = transl_list el in
      let tag_info = Lambda.Blk_tuple in 
      begin try
        Lconst(Const_block(0, tag_info, List.map extract_constant ll))
      with Not_constant ->
        Lprim(Pmakeblock(0,  tag_info, Immutable), ll, e.exp_loc)
      end
  | Texp_construct(_, cstr, args) ->
      let ll = transl_list args in
      begin match cstr.cstr_tag with
        Cstr_constant n ->
          Lconst(Const_pointer (n, Lambda.Pt_constructor cstr.cstr_name))
      | Cstr_block n ->
          let tag_info = (Lambda.Blk_constructor (cstr.cstr_name, cstr.cstr_nonconsts)) in
          begin try
            Lconst(Const_block(n,tag_info, List.map extract_constant ll))
          with Not_constant ->
            Lprim(Pmakeblock(n, tag_info, Immutable), ll, e.exp_loc)
          end
      | Cstr_extension(path, is_const) ->
          if is_const then
            transl_path e.exp_env path
          else
            Lprim(Pmakeblock(0, Lambda.default_tag_info, Immutable),
                  transl_path e.exp_env path :: ll, e.exp_loc)
      end
  | Texp_variant(l, arg) ->
      let tag = Btype.hash_variant l in
      begin match arg with
        None -> Lconst(Const_pointer (tag, Lambda.Pt_variant l))
      | Some arg ->
          let lam = transl_exp arg in
          let tag_info = Lambda.Blk_variant l in
          try
            Lconst(Const_block(0, tag_info, [Const_base(Const_int tag);
                                   extract_constant lam]))
          with Not_constant ->
            Lprim(Pmakeblock(0, tag_info, Immutable),
                  [Lconst(Const_base(Const_int tag)); lam], e.exp_loc)
      end
  | Texp_record ((_, lbl1, _) :: _ as lbl_expr_list, opt_init_expr) ->
      transl_record e.exp_loc lbl1.lbl_all lbl1.lbl_repres lbl_expr_list opt_init_expr
  | Texp_record ([], _) ->
      fatal_error "Translcore.transl_exp: bad Texp_record"
  | Texp_field(arg, _, lbl) ->
      let access =
        match lbl.lbl_repres with
          Record_regular -> Pfield (lbl.lbl_pos, Fld_record lbl.lbl_name)
        | Record_float -> Pfloatfield (lbl.lbl_pos, Fld_record lbl.lbl_name) in
      Lprim(access, [transl_exp arg], e.exp_loc)
  | Texp_setfield(arg, _, lbl, newval) ->
      let access =
        match lbl.lbl_repres with
          Record_regular -> Psetfield(lbl.lbl_pos, maybe_pointer newval, Fld_record_set lbl.lbl_name)
        | Record_float -> Psetfloatfield (lbl.lbl_pos, Fld_record_set lbl.lbl_name) in
      Lprim(access, [transl_exp arg; transl_exp newval], e.exp_loc)
  | Texp_array expr_list ->
      let kind = array_kind e in
      let ll = transl_list expr_list in
      begin try
        (* Deactivate constant optimization if array is small enough *)
        if List.length ll <= 4 then raise Not_constant;
        let cl = List.map extract_constant ll in
        let master =
          match kind with
          | Paddrarray | Pintarray ->
              Lconst(Const_block(0, Lambda.Blk_array, cl)) (* ATTENTION: ? [|1;2;3;4|]*)
          | Pfloatarray ->
              Lconst(Const_float_array(List.map extract_float cl))
          | Pgenarray ->
              raise Not_constant in             (* can this really happen? *)
        Lprim(Pccall prim_obj_dup, [master], e.exp_loc)
      with Not_constant ->
        Lprim(Pmakearray kind, ll, e.exp_loc)
      end
  | Texp_ifthenelse(cond, ifso, Some ifnot) ->
      Lifthenelse(transl_exp cond,
                  event_before ifso (transl_exp ifso),
                  event_before ifnot (transl_exp ifnot))
  | Texp_ifthenelse(cond, ifso, None) ->
      Lifthenelse(transl_exp cond,
                  event_before ifso (transl_exp ifso),
                  lambda_unit)
  | Texp_sequence(expr1, expr2) ->
      Lsequence(transl_exp expr1, event_before expr2 (transl_exp expr2))
  | Texp_while(cond, body) ->
      Lwhile(transl_exp cond, event_before body (transl_exp body))
  | Texp_for(param, _, low, high, dir, body) ->
      Lfor(param, transl_exp low, transl_exp high, dir,
           event_before body (transl_exp body))
  | Texp_send(_, _, Some exp) -> transl_exp exp
  | Texp_send(expr, met, None) ->
      let obj = transl_exp expr in
      let lam =
        match met with
          Tmeth_val id -> Lsend (Self, Lvar id, obj, [], e.exp_loc)
        | Tmeth_name nm ->
            let (tag, cache) = Translobj.meth obj nm in
            let kind = if cache = [] then Public (Some nm) else Cached in
            Lsend (kind, tag, obj, cache, e.exp_loc)
      in
      event_after e lam
  | Texp_new (cl, {Location.loc=loc}, _) ->
      Lapply(Lprim(Pfield (0, Fld_na), [transl_path ~loc e.exp_env cl], loc),
             [lambda_unit], Location.none)
  | Texp_instvar(path_self, path, _) ->
      Lprim(Parrayrefu Paddrarray,
            [transl_normal_path path_self; transl_normal_path path], e.exp_loc)
  | Texp_setinstvar(path_self, path, _, expr) ->
      transl_setinstvar e.exp_loc (transl_normal_path path_self) path expr
  | Texp_override(path_self, modifs) ->
      let cpy = Ident.create "copy" in
      Llet(Strict, cpy,
           Lapply(Translobj.oo_prim "copy", [transl_normal_path path_self],
                  Location.none),
           List.fold_right
             (fun (path, _, expr) rem ->
                Lsequence(transl_setinstvar Location.none (Lvar cpy) path expr, rem))
             modifs
             (Lvar cpy))
  | Texp_letmodule(id, _, modl, body) ->
      Llet(Strict, id, !transl_module Tcoerce_none None modl, transl_exp body)
  | Texp_pack modl ->
      !transl_module Tcoerce_none None modl
  | Texp_assert {exp_desc=Texp_construct(_, {cstr_name="false"}, _)} ->
      assert_failed e
  | Texp_assert (cond) ->
      if !Clflags.noassert
      then lambda_unit
      else Lifthenelse (transl_exp cond, lambda_unit, assert_failed e)
  | Texp_lazy e ->
      (* when e needs no computation (constants, identifiers, ...), we
         optimize the translation just as Lazy.lazy_from_val would
         do *)
      begin match e.exp_desc with
        (* a constant expr of type <> float gets compiled as itself *)
      | Texp_constant
          ( Const_int _ | Const_char _ | Const_string _
          | Const_int32 _ | Const_int64 _ | Const_nativeint _ )
      | Texp_function(_, _, _)
      | Texp_construct (_, {cstr_arity = 0}, _)
        -> transl_exp e
      | Texp_constant(Const_float _) ->
          Lprim(Pmakeblock(Obj.forward_tag, Lambda.default_tag_info, Immutable), [transl_exp e], e.exp_loc)
      | Texp_ident(_, _, _) -> (* according to the type *)
          begin match e.exp_type.desc with
          (* the following may represent a float/forward/lazy: need a
             forward_tag *)
          | Tvar _ | Tlink _ | Tsubst _ | Tunivar _
          | Tpoly(_,_) | Tfield(_,_,_,_) ->
              Lprim(Pmakeblock(Obj.forward_tag, Lambda.default_tag_info, Immutable), [transl_exp e], e.exp_loc)
          (* the following cannot be represented as float/forward/lazy:
             optimize *)
          | Tarrow(_,_,_,_) | Ttuple _ | Tpackage _ | Tobject(_,_) | Tnil
          | Tvariant _
              -> transl_exp e
          (* optimize predefined types (excepted float) *)
          | Tconstr(_,_,_) ->
              if has_base_type e Predef.path_int
                || has_base_type e Predef.path_char
                || has_base_type e Predef.path_string
                || has_base_type e Predef.path_bool
                || has_base_type e Predef.path_unit
                || has_base_type e Predef.path_exn
                || has_base_type e Predef.path_array
                || has_base_type e Predef.path_list
                || has_base_type e Predef.path_option
                || has_base_type e Predef.path_nativeint
                || has_base_type e Predef.path_int32
                || has_base_type e Predef.path_int64
              then transl_exp e
              else
                Lprim(Pmakeblock(Obj.forward_tag, Lambda.default_tag_info, Immutable), [transl_exp e], e.exp_loc)
          end
      (* other cases compile to a lazy block holding a function *)
      | _ ->
          let fn = Lfunction (Curried, [Ident.create "param"], transl_exp e) in
          Lprim(Pmakeblock(Config.lazy_tag, Lambda.default_tag_info, Mutable), [fn], e.exp_loc)
      end
  | Texp_object (cs, meths) ->
      let cty = cs.cstr_type in
      let cl = Ident.create "class" in
      !transl_object cl meths
        { cl_desc = Tcl_structure cs;
          cl_loc = e.exp_loc;
          cl_type = Cty_signature cty;
          cl_env = e.exp_env;
          cl_attributes = [];
         }

and transl_list expr_list =
  List.map transl_exp expr_list

and transl_guard guard rhs =
  let expr = event_before rhs (transl_exp rhs) in
  match guard with
  | None -> expr
  | Some cond ->
      event_before cond (Lifthenelse(transl_exp cond, expr, staticfail))

and transl_case {c_lhs; c_guard; c_rhs} =
  c_lhs, transl_guard c_guard c_rhs

and transl_cases cases =
  List.map transl_case cases

and transl_case_try {c_lhs; c_guard; c_rhs} =
  match c_lhs.pat_desc with
  | Tpat_var (id, _)
  | Tpat_alias (_, id, _) ->
      Hashtbl.replace try_ids id ();
      Misc.try_finally
        (fun () -> c_lhs, transl_guard c_guard c_rhs)
        (fun () -> Hashtbl.remove try_ids id)
  | _ ->
      c_lhs, transl_guard c_guard c_rhs

and transl_cases_try cases =
  List.map transl_case_try cases

and transl_tupled_cases patl_expr_list =
  List.map (fun (patl, guard, expr) -> (patl, transl_guard guard expr))
    patl_expr_list

and transl_apply lam sargs loc =
  let lapply funct args =
    match funct with
      Lsend(k, lmet, lobj, largs, loc) ->
        Lsend(k, lmet, lobj, largs @ args, loc)
    | Levent(Lsend(k, lmet, lobj, largs, loc), _) ->
        Lsend(k, lmet, lobj, largs @ args, loc)
    | Lapply(lexp, largs, _) ->
        Lapply(lexp, largs @ args, loc)
    | lexp ->
        Lapply(lexp, args, loc)
  in
  let rec build_apply lam args = function
      (None, optional) :: l ->
        let defs = ref [] in
        let protect name lam =
          match lam with
            Lvar _ | Lconst _ -> lam
          | _ ->
              let id = Ident.create name in
              defs := (id, lam) :: !defs;
              Lvar id
        in
        let args, args' =
          if List.for_all (fun (_,opt) -> opt = Optional) args then [], args
          else args, [] in
        let lam =
          if args = [] then lam else lapply lam (List.rev_map fst args) in
        let handle = protect "func" lam
        and l = List.map (fun (arg, opt) -> may_map (protect "arg") arg, opt) l
        and id_arg = Ident.create "param" in
        let body =
          match build_apply handle ((Lvar id_arg, optional)::args') l with
            Lfunction(Curried, ids, lam) ->
              Lfunction(Curried, id_arg::ids, lam)
          | Levent(Lfunction(Curried, ids, lam), _) ->
              Lfunction(Curried, id_arg::ids, lam)
          | lam ->
              Lfunction(Curried, [id_arg], lam)
        in
        List.fold_left
          (fun body (id, lam) -> Llet(Strict, id, lam, body))
          body !defs
    | (Some arg, optional) :: l ->
        build_apply lam ((arg, optional) :: args) l
    | [] ->
        lapply lam (List.rev_map fst args)
  in
  build_apply lam [] (List.map (fun (l, x,o) -> may_map transl_exp x, o) sargs)

and transl_function loc untuplify_fn repr partial cases =
  match cases with
    [{c_lhs=pat; c_guard=None;
      c_rhs={exp_desc = Texp_function(_, pl,partial')} as exp}]
    when Parmatch.fluid pat ->
      let param = name_pattern "param" cases in
      let ((_, params), body) =
        transl_function exp.exp_loc false repr partial' pl in
      ((Curried, param :: params),
       Matching.for_function loc None (Lvar param) [pat, body] partial)
  | {c_lhs={pat_desc = Tpat_tuple pl}} :: _ when untuplify_fn ->
      begin try
        let size = List.length pl in
        let pats_expr_list =
          List.map
            (fun {c_lhs; c_guard; c_rhs} ->
              (Matching.flatten_pattern size c_lhs, c_guard, c_rhs))
            cases in
        let params = List.map (fun p -> Ident.create "param") pl in
        ((Tupled, params),
         Matching.for_tupled_function loc params
           (transl_tupled_cases pats_expr_list) partial)
      with Matching.Cannot_flatten ->
        let param = name_pattern "param" cases in
        ((Curried, [param]),
         Matching.for_function loc repr (Lvar param)
           (transl_cases cases) partial)
      end
  | _ ->
      let param = name_pattern "param" cases in
      ((Curried, [param]),
       Matching.for_function loc repr (Lvar param)
         (transl_cases cases) partial)

and transl_let rec_flag pat_expr_list body =
  match rec_flag with
    Nonrecursive ->
      let rec transl = function
        [] ->
          body
      | {vb_pat=pat; vb_expr=expr} :: rem ->
          Matching.for_let pat.pat_loc (transl_exp expr) pat (transl rem)
      in transl pat_expr_list
  | Recursive ->
      let idlist =
        List.map
          (fun {vb_pat=pat} -> match pat.pat_desc with
              Tpat_var (id,_) -> id
            | Tpat_alias ({pat_desc=Tpat_any}, id,_) -> id
            | _ -> raise(Error(pat.pat_loc, Illegal_letrec_pat)))
        pat_expr_list in
      let transl_case {vb_pat=pat; vb_expr=expr} id =
        let lam = transl_exp expr in
        if not (check_recursive_lambda idlist lam) then
          raise(Error(expr.exp_loc, Illegal_letrec_expr));
        (id, lam) in
      Lletrec(List.map2 transl_case pat_expr_list idlist, body)

and transl_setinstvar loc self var expr =
  Lprim(Parraysetu (if maybe_pointer expr then Paddrarray else Pintarray),
                    [self; transl_normal_path var; transl_exp expr], loc)

and transl_record loc all_labels repres lbl_expr_list opt_init_expr =
  let size = Array.length all_labels in
  (* Determine if there are "enough" new fields *)
  if 3 + 2 * List.length lbl_expr_list >= size
  then begin
    (* Allocate new record with given fields (and remaining fields
       taken from init_expr if any *)
    let lv = Array.make (Array.length all_labels) staticfail in
    let init_id = Ident.create "init" in
    begin match opt_init_expr with
      None -> ()
    | Some init_expr ->
        for i = 0 to Array.length all_labels - 1 do
          let access =
            let lbl = all_labels.(i) in
            match lbl.lbl_repres with
              Record_regular -> Pfield (i, Fld_record lbl.lbl_name)
            | Record_float -> Pfloatfield (i, Fld_record lbl.lbl_name)  in
          lv.(i) <- Lprim(access, [Lvar init_id], loc)
        done
    end;
    List.iter
      (fun (_, lbl, expr) -> lv.(lbl.lbl_pos) <- transl_exp expr)
      lbl_expr_list;
    let ll = Array.to_list lv in
    let mut =
      if List.exists (fun (_, lbl, expr) -> lbl.lbl_mut = Mutable) lbl_expr_list
      then Mutable
      else Immutable in
    let all_labels_info = all_labels |> Array.map (fun x -> x.Types.lbl_name) in
    let lam =
      try
        if mut = Mutable then raise Not_constant;
        let cl = List.map extract_constant ll in
        match repres with
          Record_regular -> Lconst(Const_block(0, Lambda.Blk_record all_labels_info, cl))
        | Record_float ->
            Lconst(Const_float_array(List.map extract_float cl))
      with Not_constant ->
        match repres with
          Record_regular -> Lprim(Pmakeblock(0, Lambda.Blk_record all_labels_info, mut), ll,loc)
        | Record_float -> Lprim(Pmakearray Pfloatarray, ll, loc) in
    begin match opt_init_expr with
      None -> lam
    | Some init_expr -> Llet(Strict, init_id, transl_exp init_expr, lam)
    end
  end else begin
    (* Take a shallow copy of the init record, then mutate the fields
       of the copy *)
    (* If you change anything here, you will likely have to change
       [check_recursive_recordwith] in this file. *)
    let copy_id = Ident.create "newrecord" in
    let update_field (_, lbl, expr) cont =
      let upd =
        match lbl.lbl_repres with
          Record_regular -> Psetfield(lbl.lbl_pos, maybe_pointer expr, Fld_record_set lbl.lbl_name)
        | Record_float -> Psetfloatfield (lbl.lbl_pos, Fld_record_set lbl.lbl_name) in
      Lsequence(Lprim(upd, [Lvar copy_id; transl_exp expr], loc), cont) in
    begin match opt_init_expr with
      None -> assert false
    | Some init_expr ->
        Llet(Strict, copy_id,
             Lprim(Pduprecord (repres, size), [transl_exp init_expr], loc),
             List.fold_right update_field lbl_expr_list (Lvar copy_id))
    end
  end

and transl_match e arg pat_expr_list exn_pat_expr_list partial =
  let id = name_pattern "exn" exn_pat_expr_list
  and cases = transl_cases pat_expr_list
  and exn_cases = transl_cases exn_pat_expr_list in
  let static_catch body val_ids handler =
    let static_exception_id = next_negative_raise_count () in
    Lstaticcatch
      (Ltrywith (Lstaticraise (static_exception_id, body), id,
                 Matching.for_trywith (Lvar id) exn_cases),
       (static_exception_id, val_ids),
       handler)
  in
  match arg, exn_cases with
  | {exp_desc = Texp_tuple argl}, [] ->
    Matching.for_multiple_match e.exp_loc (transl_list argl) cases partial
  | {exp_desc = Texp_tuple argl}, _ :: _ ->
    let val_ids = List.map (fun _ -> name_pattern "val" []) argl in
    let lvars = List.map (fun id -> Lvar id) val_ids in
    static_catch (transl_list argl) val_ids
      (Matching.for_multiple_match e.exp_loc lvars cases partial)
  | arg, [] ->
    Matching.for_function e.exp_loc None (transl_exp arg) cases partial
  | arg, _ :: _ ->
    let val_id = name_pattern "val" pat_expr_list in
    static_catch [transl_exp arg] [val_id]
      (Matching.for_function e.exp_loc None (Lvar val_id) cases partial)


(* Wrapper for class compilation *)

(*
let transl_exp = transl_exp_wrap

let transl_let rec_flag pat_expr_list body =
  match pat_expr_list with
    [] -> body
  | (_, expr) :: _ ->
      Translobj.oo_wrap expr.exp_env false
        (transl_let rec_flag pat_expr_list) body
*)

(* Error report *)

open Format

let report_error ppf = function
  | Illegal_letrec_pat ->
      fprintf ppf
        "Only variables are allowed as left-hand side of `let rec'"
  | Illegal_letrec_expr ->
      fprintf ppf
        "This kind of expression is not allowed as right-hand side of `let rec'"
  | Free_super_var ->
      fprintf ppf
        "Ancestor names can only be used to select inherited methods"
  | Unknown_builtin_primitive prim_name ->
    fprintf ppf  "Unknown builtin primitive \"%s\"" prim_name

let () =
  Location.register_error_of_exn
    (function
      | Error (loc, err) ->
          Some (Location.error_of_printer loc report_error err)
      | _ ->
        None
    )

end
module Translclass : sig 
#1 "translclass.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*         Jerome Vouillon, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Typedtree
open Lambda

val transl_class :
  Ident.t list -> Ident.t ->
  string list -> class_expr -> Asttypes.virtual_flag -> lambda;;

type error = Illegal_class_expr | Tags of string * string

exception Error of Location.t * error

open Format

val report_error: formatter -> error -> unit

end = struct
#1 "translclass.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*         Jerome Vouillon, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Asttypes
open Types
open Typedtree
open Lambda
open Translobj
open Translcore

(* XXX Rajouter des evenements... *)

type error = Illegal_class_expr | Tags of label * label

exception Error of Location.t * error

let lfunction params body =
  if params = [] then body else
  match body with
    Lfunction (Curried, params', body') ->
      Lfunction (Curried, params @ params', body')
  |  _ ->
      Lfunction (Curried, params, body)

let lapply func args loc =
  match func with
    Lapply(func', args', _) ->
      Lapply(func', args' @ args, loc)
  | _ ->
      Lapply(func, args, loc)

let mkappl (func, args) = Lapply (func, args, Location.none);;

let lsequence l1 l2 =
  if l2 = lambda_unit then l1 else Lsequence(l1, l2)

let lfield v i = Lprim(Pfield (i, Fld_na), [Lvar v], Location.none)

let transl_label l = share (Const_immstring l)

let transl_meth_list lst =
  if lst = [] then Lconst (Const_pointer (0, Lambda.Pt_na)) else
  share (Const_block
            (0, Lambda.Blk_na, List.map (fun lab -> Const_immstring lab) lst))

let set_inst_var obj id expr =
  let kind = if Typeopt.maybe_pointer expr then Paddrarray else Pintarray in
  Lprim(Parraysetu kind, [Lvar obj; Lvar id; transl_exp expr],Location.none)

let copy_inst_var obj id expr templ offset =
  let kind = if Typeopt.maybe_pointer expr then Paddrarray else Pintarray in
  let id' = Ident.create (Ident.name id) in
  Llet(Strict, id', Lprim (Pidentity, [Lvar id], Location.none),
  Lprim(Parraysetu kind,
        [Lvar obj; Lvar id';
         Lprim(Parrayrefu kind, [Lvar templ; Lprim(Paddint,
                                                   [Lvar id';
                                                    Lvar offset], Location.none)], Location.none)], Location.none))

let transl_val tbl create name =
  mkappl (oo_prim (if create then "new_variable" else "get_variable"),
          [Lvar tbl; transl_label name])

let transl_vals tbl create strict vals rem =
  List.fold_right
    (fun (name, id) rem ->
      Llet(strict, id, transl_val tbl create name, rem))
    vals rem

let meths_super tbl meths inh_meths =
  List.fold_right
    (fun (nm, id) rem ->
       try
         (nm, id,
          mkappl(oo_prim "get_method", [Lvar tbl; Lvar (Meths.find nm meths)]))
         :: rem
       with Not_found -> rem)
    inh_meths []

let bind_super tbl (vals, meths) cl_init =
  transl_vals tbl false StrictOpt vals
    (List.fold_right (fun (nm, id, def) rem -> Llet(StrictOpt, id, def, rem))
       meths cl_init)

let create_object cl obj init =
  let obj' = Ident.create "self" in
  let (inh_init, obj_init, has_init) = init obj' in
  if obj_init = lambda_unit then
    (inh_init,
     mkappl (oo_prim (if has_init then "create_object_and_run_initializers"
                      else"create_object_opt"),
             [obj; Lvar cl]))
  else begin
   (inh_init,
    Llet(Strict, obj',
            mkappl (oo_prim "create_object_opt", [obj; Lvar cl]),
         Lsequence(obj_init,
                   if not has_init then Lvar obj' else
                   mkappl (oo_prim "run_initializers_opt",
                           [obj; Lvar obj'; Lvar cl]))))
  end

let name_pattern default p =
  match p.pat_desc with
  | Tpat_var (id, _) -> id
  | Tpat_alias(p, id, _) -> id
  | _ -> Ident.create default

let normalize_cl_path cl path =
  Env.normalize_path (Some cl.cl_loc) cl.cl_env path

let rec build_object_init cl_table obj params inh_init obj_init cl =
  match cl.cl_desc with
    Tcl_ident ( path, _, _) ->
      let obj_init = Ident.create "obj_init" in
      let envs, inh_init = inh_init in
      let env =
        match envs with None -> []
        | Some envs -> [Lprim(Pfield (List.length inh_init + 1, Fld_na), [Lvar envs], Location.none)]
      in
      ((envs, (obj_init, normalize_cl_path cl path)
        ::inh_init),
       mkappl(Lvar obj_init, env @ [obj]))
  | Tcl_structure str ->
      create_object cl_table obj (fun obj ->
        let (inh_init, obj_init, has_init) =
          List.fold_right
            (fun field (inh_init, obj_init, has_init) ->
               match field.cf_desc with
                 Tcf_inherit (_, cl, _, _, _) ->
                   let (inh_init, obj_init') =
                     build_object_init cl_table (Lvar obj) [] inh_init
                       (fun _ -> lambda_unit) cl
                   in
                   (inh_init, lsequence obj_init' obj_init, true)
               | Tcf_val (_, _, id, Tcfk_concrete (_, exp), _) ->
                   (inh_init, lsequence (set_inst_var obj id exp) obj_init,
                    has_init)
               | Tcf_method _ | Tcf_val _ | Tcf_constraint _ | Tcf_attribute _->
                   (inh_init, obj_init, has_init)
               | Tcf_initializer _ ->
                   (inh_init, obj_init, true)
            )
            str.cstr_fields
            (inh_init, obj_init obj, false)
        in
        (inh_init,
         List.fold_right
           (fun (id, expr) rem ->
              lsequence (Lifused (id, set_inst_var obj id expr)) rem)
           params obj_init,
         has_init))
  | Tcl_fun (_, pat, vals, cl, partial) ->
      let vals = List.map (fun (id, _, e) -> id,e) vals in
      let (inh_init, obj_init) =
        build_object_init cl_table obj (vals @ params) inh_init obj_init cl
      in
      (inh_init,
       let build params rem =
         let param = name_pattern "param" pat in
         Lfunction (Curried, param::params,
                    Matching.for_function
                      pat.pat_loc None (Lvar param) [pat, rem] partial)
       in
       begin match obj_init with
         Lfunction (Curried, params, rem) -> build params rem
       | rem                              -> build [] rem
       end)
  | Tcl_apply (cl, oexprs) ->
      let (inh_init, obj_init) =
        build_object_init cl_table obj params inh_init obj_init cl
      in
      (inh_init, transl_apply obj_init oexprs Location.none)
  | Tcl_let (rec_flag, defs, vals, cl) ->
      let vals = List.map (fun (id, _, e) -> id,e) vals in
      let (inh_init, obj_init) =
        build_object_init cl_table obj (vals @ params) inh_init obj_init cl
      in
      (inh_init, Translcore.transl_let rec_flag defs obj_init)
  | Tcl_constraint (cl, _, vals, pub_meths, concr_meths) ->
      build_object_init cl_table obj params inh_init obj_init cl

let rec build_object_init_0 cl_table params cl copy_env subst_env top ids =
  match cl.cl_desc with
    Tcl_let (rec_flag, defs, vals, cl) ->
      let vals = List.map (fun (id, _, e) -> id,e) vals in
      build_object_init_0 cl_table (vals@params) cl copy_env subst_env top ids
  | _ ->
      let self = Ident.create "self" in
      let env = Ident.create "env" in
      let obj = if ids = [] then lambda_unit else Lvar self in
      let envs = if top then None else Some env in
      let ((_,inh_init), obj_init) =
        build_object_init cl_table obj params (envs,[]) (copy_env env) cl in
      let obj_init =
        if ids = [] then obj_init else lfunction [self] obj_init in
      (inh_init, lfunction [env] (subst_env env inh_init obj_init))


let bind_method tbl lab id cl_init =
  Llet(Strict, id, mkappl (oo_prim "get_method_label",
                           [Lvar tbl; transl_label lab]),
       cl_init)

let bind_methods tbl meths vals cl_init =
  let methl = Meths.fold (fun lab id tl -> (lab,id) :: tl) meths [] in
  let len = List.length methl and nvals = List.length vals in
  if len < 2 && nvals = 0 then Meths.fold (bind_method tbl) meths cl_init else
  if len = 0 && nvals < 2 then transl_vals tbl true Strict vals cl_init else
  let ids = Ident.create "ids" in
  let i = ref (len + nvals) in
  let getter, names =
    if nvals = 0 then "get_method_labels", [] else
    "new_methods_variables", [transl_meth_list (List.map fst vals)]
  in
  Llet(Strict, ids,
       mkappl (oo_prim getter,
               [Lvar tbl; transl_meth_list (List.map fst methl)] @ names),
       List.fold_right
         (fun (lab,id) lam -> decr i; Llet(StrictOpt, id, lfield ids !i, lam))
         (methl @ vals) cl_init)

let output_methods tbl methods lam =
  match methods with
    [] -> lam
  | [lab; code] ->
      lsequence (mkappl(oo_prim "set_method", [Lvar tbl; lab; code])) lam
  | _ ->
      lsequence (mkappl(oo_prim "set_methods",
                        [Lvar tbl; Lprim(Pmakeblock(0, Lambda.Blk_array, Immutable), methods, Location.none)]))
        lam

let rec ignore_cstrs cl =
  match cl.cl_desc with
    Tcl_constraint (cl, _, _, _, _) -> ignore_cstrs cl
  | Tcl_apply (cl, _) -> ignore_cstrs cl
  | _ -> cl

let rec index a = function
    [] -> raise Not_found
  | b :: l ->
      if b = a then 0 else 1 + index a l

let bind_id_as_val (id, _, _) = ("", id)

let rec build_class_init cla cstr super inh_init cl_init msubst top cl =
  match cl.cl_desc with
    Tcl_ident ( path, _, _) ->
      begin match inh_init with
        (obj_init, path')::inh_init ->
          let lpath = transl_path ~loc:cl.cl_loc cl.cl_env path in
          (inh_init,
           Llet (Strict, obj_init,
                 mkappl(Lprim(Pfield (1, Fld_na), [lpath], Location.none), Lvar cla ::
                        if top then [Lprim(Pfield (3, Fld_na), [lpath], Location.none)] else []),
                 bind_super cla super cl_init))
      | _ ->
          assert false
      end
  | Tcl_structure str ->
      let cl_init = bind_super cla super cl_init in
      let (inh_init, cl_init, methods, values) =
        List.fold_right
          (fun field (inh_init, cl_init, methods, values) ->
            match field.cf_desc with
              Tcf_inherit (_, cl, _, vals, meths) ->
                let cl_init = output_methods cla methods cl_init in
                let inh_init, cl_init =
                  build_class_init cla false
                    (vals, meths_super cla str.cstr_meths meths)
                    inh_init cl_init msubst top cl in
                (inh_init, cl_init, [], values)
            | Tcf_val (name, _, id, _, over) ->
                let values =
                  if over then values else (name.txt, id) :: values
                in
                (inh_init, cl_init, methods, values)
            | Tcf_method (_, _, Tcfk_virtual _)
            | Tcf_constraint _
              ->
                (inh_init, cl_init, methods, values)
            | Tcf_method (name, _, Tcfk_concrete (_, exp)) ->
                let met_code = msubst true (transl_exp exp) in
                let met_code =
                  if !Clflags.native_code && List.length met_code = 1 then
                    (* Force correct naming of method for profiles *)
                    let met = Ident.create ("method_" ^ name.txt) in
                    [Llet(Strict, met, List.hd met_code, Lvar met)]
                  else met_code
                in
                (inh_init, cl_init,
                 Lvar(Meths.find name.txt str.cstr_meths) :: met_code @ methods,
                 values)
            | Tcf_initializer exp ->
                (inh_init,
                 Lsequence(mkappl (oo_prim "add_initializer",
                                   Lvar cla :: msubst false (transl_exp exp)),
                           cl_init),
                 methods, values)
            | Tcf_attribute _ ->
                (inh_init, cl_init, methods, values))
          str.cstr_fields
          (inh_init, cl_init, [], [])
      in
      let cl_init = output_methods cla methods cl_init in
      (inh_init, bind_methods cla str.cstr_meths values cl_init)
  | Tcl_fun (_, pat, vals, cl, _) ->
      let (inh_init, cl_init) =
        build_class_init cla cstr super inh_init cl_init msubst top cl
      in
      let vals = List.map bind_id_as_val vals in
      (inh_init, transl_vals cla true StrictOpt vals cl_init)
  | Tcl_apply (cl, exprs) ->
      build_class_init cla cstr super inh_init cl_init msubst top cl
  | Tcl_let (rec_flag, defs, vals, cl) ->
      let (inh_init, cl_init) =
        build_class_init cla cstr super inh_init cl_init msubst top cl
      in
      let vals = List.map bind_id_as_val vals in
      (inh_init, transl_vals cla true StrictOpt vals cl_init)
  | Tcl_constraint (cl, _, vals, meths, concr_meths) ->
      let virt_meths =
        List.filter (fun lab -> not (Concr.mem lab concr_meths)) meths in
      let concr_meths = Concr.elements concr_meths in
      let narrow_args =
        [Lvar cla;
         transl_meth_list vals;
         transl_meth_list virt_meths;
         transl_meth_list concr_meths] in
      let cl = ignore_cstrs cl in
      begin match cl.cl_desc, inh_init with
        Tcl_ident (path, _, _), (obj_init, path')::inh_init ->
          assert (Path.same (normalize_cl_path cl path) path');
          let lpath = transl_normal_path path' in
          let inh = Ident.create "inh"
          and ofs = List.length vals + 1
          and valids, methids = super in
          let cl_init =
            List.fold_left
              (fun init (nm, id, _) ->
                Llet(StrictOpt, id, lfield inh (index nm concr_meths + ofs),
                     init))
              cl_init methids in
          let cl_init =
            List.fold_left
              (fun init (nm, id) ->
                Llet(StrictOpt, id, lfield inh (index nm vals + 1), init))
              cl_init valids in
          (inh_init,
           Llet (Strict, inh,
                 mkappl(oo_prim "inherits", narrow_args @
                        [lpath; Lconst(Const_pointer ((if top then 1 else 0), Lambda.Pt_na))]),
                 Llet(StrictOpt, obj_init, lfield inh 0, cl_init)))
      | _ ->
          let core cl_init =
            build_class_init cla true super inh_init cl_init msubst top cl
          in
          if cstr then core cl_init else
          let (inh_init, cl_init) =
            core (Lsequence (mkappl (oo_prim "widen", [Lvar cla]), cl_init))
          in
          (inh_init,
           Lsequence(mkappl (oo_prim "narrow", narrow_args),
                     cl_init))
      end

let rec build_class_lets cl ids =
  match cl.cl_desc with
    Tcl_let (rec_flag, defs, vals, cl') ->
      let env, wrap = build_class_lets cl' [] in
      (env, fun x ->
        let lam = Translcore.transl_let rec_flag defs (wrap x) in
        (* Check recursion in toplevel let-definitions *)
        if ids = [] || Translcore.check_recursive_lambda ids lam then lam
        else raise(Error(cl.cl_loc, Illegal_class_expr)))
  | _ ->
      (cl.cl_env, fun x -> x)

let rec get_class_meths cl =
  match cl.cl_desc with
    Tcl_structure cl ->
      Meths.fold (fun _ -> IdentSet.add) cl.cstr_meths IdentSet.empty
  | Tcl_ident _ -> IdentSet.empty
  | Tcl_fun (_, _, _, cl, _)
  | Tcl_let (_, _, _, cl)
  | Tcl_apply (cl, _)
  | Tcl_constraint (cl, _, _, _, _) -> get_class_meths cl

(*
   XXX Il devrait etre peu couteux d'ecrire des classes :
     class c x y = d e f
*)
let rec transl_class_rebind obj_init cl vf =
  match cl.cl_desc with
    Tcl_ident (path, _, _) ->
      if vf = Concrete then begin
        try if (Env.find_class path cl.cl_env).cty_new = None then raise Exit
        with Not_found -> raise Exit
      end;
      (normalize_cl_path cl path, obj_init)
  | Tcl_fun (_, pat, _, cl, partial) ->
      let path, obj_init = transl_class_rebind obj_init cl vf in
      let build params rem =
        let param = name_pattern "param" pat in
        Lfunction (Curried, param::params,
                   Matching.for_function
                     pat.pat_loc None (Lvar param) [pat, rem] partial)
      in
      (path,
       match obj_init with
         Lfunction (Curried, params, rem) -> build params rem
       | rem                              -> build [] rem)
  | Tcl_apply (cl, oexprs) ->
      let path, obj_init = transl_class_rebind obj_init cl vf in
      (path, transl_apply obj_init oexprs Location.none)
  | Tcl_let (rec_flag, defs, vals, cl) ->
      let path, obj_init = transl_class_rebind obj_init cl vf in
      (path, Translcore.transl_let rec_flag defs obj_init)
  | Tcl_structure _ -> raise Exit
  | Tcl_constraint (cl', _, _, _, _) ->
      let path, obj_init = transl_class_rebind obj_init cl' vf in
      let rec check_constraint = function
          Cty_constr(path', _, _) when Path.same path path' -> ()
        | Cty_arrow (_, _, cty) -> check_constraint cty
        | _ -> raise Exit
      in
      check_constraint cl.cl_type;
      (path, obj_init)

let rec transl_class_rebind_0 self obj_init cl vf =
  match cl.cl_desc with
    Tcl_let (rec_flag, defs, vals, cl) ->
      let path, obj_init = transl_class_rebind_0 self obj_init cl vf in
      (path, Translcore.transl_let rec_flag defs obj_init)
  | _ ->
      let path, obj_init = transl_class_rebind obj_init cl vf in
      (path, lfunction [self] obj_init)

let transl_class_rebind ids cl vf =
  try
    let obj_init = Ident.create "obj_init"
    and self = Ident.create "self" in
    let obj_init0 = lapply (Lvar obj_init) [Lvar self] Location.none in
    let path, obj_init' = transl_class_rebind_0 self obj_init0 cl vf in
    if not (Translcore.check_recursive_lambda ids obj_init') then
      raise(Error(cl.cl_loc, Illegal_class_expr));
    let id = (obj_init' = lfunction [self] obj_init0) in
    if id then transl_normal_path path else

    let cla = Ident.create "class"
    and new_init = Ident.create "new_init"
    and env_init = Ident.create "env_init"
    and table = Ident.create "table"
    and envs = Ident.create "envs" in
    Llet(
    Strict, new_init, lfunction [obj_init] obj_init',
    Llet(
    Alias, cla, transl_normal_path path,
    Lprim(Pmakeblock(0, Lambda.default_tag_info, Immutable),
          [mkappl(Lvar new_init, [lfield cla 0]);
           lfunction [table]
             (Llet(Strict, env_init,
                   mkappl(lfield cla 1, [Lvar table]),
                   lfunction [envs]
                     (mkappl(Lvar new_init,
                             [mkappl(Lvar env_init, [Lvar envs])]))));
           lfield cla 2;
           lfield cla 3], Location.none)))
  with Exit ->
    lambda_unit

(* Rewrite a closure using builtins. Improves native code size. *)

let rec module_path = function
    Lvar id ->
      let s = Ident.name id in s <> "" && s.[0] >= 'A' && s.[0] <= 'Z'
  | Lprim(Pfield _, [p], _)    -> module_path p
  | Lprim(Pgetglobal _, [], _) -> true
  | _                       -> false

let const_path local = function
    Lvar id -> not (List.mem id local)
  | Lconst _ -> true
  | Lfunction (Curried, _, body) ->
      let fv = free_variables body in
      List.for_all (fun x -> not (IdentSet.mem x fv)) local
  | p -> module_path p

let rec builtin_meths self env env2 body =
  let const_path = const_path (env::self) in
  let conv = function
    (* Lvar s when List.mem s self ->  "_self", [] *)
    | p when const_path p -> "const", [p]
    | Lprim(Parrayrefu _, [Lvar s; Lvar n], _) when List.mem s self ->
        "var", [Lvar n]
    | Lprim(Pfield (n,_), [Lvar e], _) when Ident.same e env ->
        "env", [Lvar env2; Lconst(Const_pointer (n, Lambda.Pt_na))]
    | Lsend(Self, met, Lvar s, [], _) when List.mem s self ->
        "meth", [met]
    | _ -> raise Not_found
  in
  match body with
  | Llet(_, s', Lvar s, body) when List.mem s self ->
      builtin_meths (s'::self) env env2 body
  | Lapply(f, [arg], _) when const_path f ->
      let s, args = conv arg in ("app_"^s, f :: args)
  | Lapply(f, [arg; p], _) when const_path f && const_path p ->
      let s, args = conv arg in
      ("app_"^s^"_const", f :: args @ [p])
  | Lapply(f, [p; arg], _) when const_path f && const_path p ->
      let s, args = conv arg in
      ("app_const_"^s, f :: p :: args)
  | Lsend(Self, Lvar n, Lvar s, [arg], _) when List.mem s self ->
      let s, args = conv arg in
      ("meth_app_"^s, Lvar n :: args)
  | Lsend(Self, met, Lvar s, [], _) when List.mem s self ->
      ("get_meth", [met])
  | Lsend(Public _, met, arg, [], _) ->
      let s, args = conv arg in
      ("send_"^s, met :: args)
  | Lsend(Cached, met, arg, [_;_], _) ->
      let s, args = conv arg in
      ("send_"^s, met :: args)
  | Lfunction (Curried, [x], body) ->
      let rec enter self = function
        | Lprim(Parraysetu _, [Lvar s; Lvar n; Lvar x'], _)
          when Ident.same x x' && List.mem s self ->
            ("set_var", [Lvar n])
        | Llet(_, s', Lvar s, body) when List.mem s self ->
            enter (s'::self) body
        | _ -> raise Not_found
      in enter self body
  | Lfunction _ -> raise Not_found
  | _ ->
      let s, args = conv body in ("get_"^s, args)

module M = struct
  open CamlinternalOO
  let builtin_meths self env env2 body =
    let builtin, args = builtin_meths self env env2 body in
    (* if not arr then [mkappl(oo_prim builtin, args)] else *)
    let tag = match builtin with
      "get_const" -> GetConst
    | "get_var"   -> GetVar
    | "get_env"   -> GetEnv
    | "get_meth"  -> GetMeth
    | "set_var"   -> SetVar
    | "app_const" -> AppConst
    | "app_var"   -> AppVar
    | "app_env"   -> AppEnv
    | "app_meth"  -> AppMeth
    | "app_const_const" -> AppConstConst
    | "app_const_var"   -> AppConstVar
    | "app_const_env"   -> AppConstEnv
    | "app_const_meth"  -> AppConstMeth
    | "app_var_const"   -> AppVarConst
    | "app_env_const"   -> AppEnvConst
    | "app_meth_const"  -> AppMethConst
    | "meth_app_const"  -> MethAppConst
    | "meth_app_var"    -> MethAppVar
    | "meth_app_env"    -> MethAppEnv
    | "meth_app_meth"   -> MethAppMeth
    | "send_const" -> SendConst
    | "send_var"   -> SendVar
    | "send_env"   -> SendEnv
    | "send_meth"  -> SendMeth
    | _ -> assert false
    in Lconst(Const_pointer(Obj.magic tag, Lambda.Pt_na)) :: args
end
open M


(*
   Traduction d'une classe.
   Plusieurs cas:
    * reapplication d'une classe connue -> transl_class_rebind
    * classe sans dependances locales -> traduction directe
    * avec dependances locale -> creation d'un arbre de stubs,
      avec un noeud pour chaque classe locale heritee
   Une classe est un 4-uplet:
    (obj_init, class_init, env_init, env)
    obj_init: fonction de creation d'objet (unit -> obj)
    class_init: fonction d'heritage (table -> env_init)
      (une seule par code source)
    env_init: parametrage par l'environnement local (env -> params -> obj_init)
      (une par combinaison de class_init herites)
    env: environnement local
   Si ids=0 (objet immediat), alors on ne conserve que env_init.
*)

let prerr_ids msg ids =
  let names = List.map Ident.unique_toplevel_name ids in
  prerr_endline (String.concat " " (msg :: names))

let transl_class ids cl_id pub_meths cl vflag =
  (* First check if it is not only a rebind *)
  let rebind = transl_class_rebind ids cl vflag in
  if rebind <> lambda_unit then rebind else

  (* Prepare for heavy environment handling *)
  let tables = Ident.create (Ident.name cl_id ^ "_tables") in
  let (top_env, req) = oo_add_class tables in
  let top = not req in
  let cl_env, llets = build_class_lets cl ids in
  let new_ids = if top then [] else Env.diff top_env cl_env in
  let env2 = Ident.create "env" in
  let meth_ids = get_class_meths cl in
  let subst env lam i0 new_ids' =
    let fv = free_variables lam in
    (* prerr_ids "cl_id =" [cl_id]; prerr_ids "fv =" (IdentSet.elements fv); *)
    let fv = List.fold_right IdentSet.remove !new_ids' fv in
    (* We need to handle method ids specially, as they do not appear
       in the typing environment (PR#3576, PR#4560) *)
    (* very hacky: we add and remove free method ids on the fly,
       depending on the visit order... *)
    method_ids :=
      IdentSet.diff (IdentSet.union (free_methods lam) !method_ids) meth_ids;
    (* prerr_ids "meth_ids =" (IdentSet.elements meth_ids);
       prerr_ids "method_ids =" (IdentSet.elements !method_ids); *)
    let new_ids = List.fold_right IdentSet.add new_ids !method_ids in
    let fv = IdentSet.inter fv new_ids in
    new_ids' := !new_ids' @ IdentSet.elements fv;
    (* prerr_ids "new_ids' =" !new_ids'; *)
    let i = ref (i0-1) in
    List.fold_left
      (fun subst id ->
        incr i; Ident.add id (lfield env !i)  subst)
      Ident.empty !new_ids'
  in
  let new_ids_meths = ref [] in
  let msubst arr = function
      Lfunction (Curried, self :: args, body) ->
        let env = Ident.create "env" in
        let body' =
          if new_ids = [] then body else
          subst_lambda (subst env body 0 new_ids_meths) body in
        begin try
          (* Doesn't seem to improve size for bytecode *)
          (* if not !Clflags.native_code then raise Not_found; *)
          if not arr || !Clflags.debug then raise Not_found;
          builtin_meths [self] env env2 (lfunction args body')
        with Not_found ->
          [lfunction (self :: args)
             (if not (IdentSet.mem env (free_variables body')) then body' else
              Llet(Alias, env,
                   Lprim(Parrayrefu Paddrarray,
                         [Lvar self; Lvar env2], Location.none), body'))]
        end
      | _ -> assert false
  in
  let new_ids_init = ref [] in
  let env1 = Ident.create "env" and env1' = Ident.create "env'" in
  let copy_env envs self =
    if top then lambda_unit else
    Lifused(env2, Lprim(Parraysetu Paddrarray,
                        [Lvar self; Lvar env2; Lvar env1'], Location.none))
  and subst_env envs l lam =
    if top then lam else
    (* must be called only once! *)
    let lam = subst_lambda (subst env1 lam 1 new_ids_init) lam in
    Llet(Alias, env1, (if l = [] then Lvar envs else lfield envs 0),
    Llet(Alias, env1',
         (if !new_ids_init = [] then Lvar env1 else lfield env1 0),
         lam))
  in

  (* Now we start compiling the class *)
  let cla = Ident.create "class" in
  let (inh_init, obj_init) =
    build_object_init_0 cla [] cl copy_env subst_env top ids in
  let inh_init' = List.rev inh_init in
  let (inh_init', cl_init) =
    build_class_init cla true ([],[]) inh_init' obj_init msubst top cl
  in
  assert (inh_init' = []);
  let table = Ident.create "table"
  and class_init = Ident.create (Ident.name cl_id ^ "_init")
  and env_init = Ident.create "env_init"
  and obj_init = Ident.create "obj_init" in
  let pub_meths =
    List.sort
      (fun s s' -> compare (Btype.hash_variant s) (Btype.hash_variant s'))
      pub_meths in
  let tags = List.map Btype.hash_variant pub_meths in
  let rev_map = List.combine tags pub_meths in
  List.iter2
    (fun tag name ->
      let name' = List.assoc tag rev_map in
      if name' <> name then raise(Error(cl.cl_loc, Tags(name, name'))))
    tags pub_meths;
  let ltable table lam =
    Llet(Strict, table,
         mkappl (oo_prim "create_table", [transl_meth_list pub_meths]), lam)
  and ldirect obj_init =
    Llet(Strict, obj_init, cl_init,
         Lsequence(mkappl (oo_prim "init_class", [Lvar cla]),
                   mkappl (Lvar obj_init, [lambda_unit])))
  in
  (* Simplest case: an object defined at toplevel (ids=[]) *)
  if top && ids = [] then llets (ltable cla (ldirect obj_init)) else

  let concrete = (vflag = Concrete)
  and lclass lam =
    let cl_init = llets (Lfunction(Curried, [cla], cl_init)) in
    Llet(Strict, class_init, cl_init, lam (free_variables cl_init))
  and lbody fv =
    if List.for_all (fun id -> not (IdentSet.mem id fv)) ids then
      mkappl (oo_prim "make_class",[transl_meth_list pub_meths;
                                    Lvar class_init])
    else
      ltable table (
      Llet(
      Strict, env_init, mkappl (Lvar class_init, [Lvar table]),
      Lsequence(
      mkappl (oo_prim "init_class", [Lvar table]),
      Lprim(Pmakeblock(0, Lambda.default_tag_info, Immutable),
            [mkappl (Lvar env_init, [lambda_unit]);
             Lvar class_init; Lvar env_init; lambda_unit], Location.none))))
  and lbody_virt lenvs =
    Lprim(Pmakeblock(0, Lambda.default_tag_info, Immutable),
          [lambda_unit; Lfunction(Curried,[cla], cl_init); lambda_unit; lenvs], Location.none)
  in
  (* Still easy: a class defined at toplevel *)
  if top && concrete then lclass lbody else
  if top then llets (lbody_virt lambda_unit) else

  (* Now for the hard stuff: prepare for table cacheing *)
  let envs = Ident.create "envs"
  and cached = Ident.create "cached" in
  let lenvs =
    if !new_ids_meths = [] && !new_ids_init = [] && inh_init = []
    then lambda_unit
    else Lvar envs in
  let lenv =
    let menv =
      if !new_ids_meths = [] then lambda_unit else
      Lprim(Pmakeblock(0, Lambda.default_tag_info, Immutable),
            List.map (fun id -> Lvar id) !new_ids_meths, Location.none) in
    if !new_ids_init = [] then menv else
    Lprim(Pmakeblock(0, Lambda.default_tag_info, Immutable),
          menv :: List.map (fun id -> Lvar id) !new_ids_init, Location.none)
  and linh_envs =
    List.map (fun (_, p) -> Lprim(Pfield (3, Fld_na), [transl_normal_path p], Location.none))
      (List.rev inh_init)
  in
  let make_envs lam =
    Llet(StrictOpt, envs,
         (if linh_envs = [] then lenv else
         Lprim(Pmakeblock(0, Lambda.default_tag_info, Immutable), lenv :: linh_envs, Location.none)),
         lam)
  and def_ids cla lam =
    Llet(StrictOpt, env2,
         mkappl (oo_prim "new_variable", [Lvar cla; transl_label ""]),
         lam)
  in
  let inh_paths =
    List.filter
      (fun (_,path) -> List.mem (Path.head path) new_ids) inh_init in
  let inh_keys =
    List.map (fun (_,p) -> Lprim(Pfield (1, Fld_na), [transl_normal_path p], Location.none)) inh_paths in
  let lclass lam =
    Llet(Strict, class_init,
         Lfunction(Curried, [cla], def_ids cla cl_init), lam)
  and lcache lam =
    if inh_keys = [] then Llet(Alias, cached, Lvar tables, lam) else
    Llet(Strict, cached,
         mkappl (oo_prim "lookup_tables",
                [Lvar tables; Lprim(Pmakeblock(0, Lambda.default_tag_info, Immutable), inh_keys, Location.none)]),
         lam)
  and lset cached i lam =
    Lprim(Psetfield(i, true, Fld_set_na), [Lvar cached; lam], Location.none)
  in
  let ldirect () =
    ltable cla
      (Llet(Strict, env_init, def_ids cla cl_init,
            Lsequence(mkappl (oo_prim "init_class", [Lvar cla]),
                      lset cached 0 (Lvar env_init))))
  and lclass_virt () =
    lset cached 0 (Lfunction(Curried, [cla], def_ids cla cl_init))
  in
  llets (
  lcache (
  Lsequence(
  Lifthenelse(lfield cached 0, lambda_unit,
              if ids = [] then ldirect () else
              if not concrete then lclass_virt () else
              lclass (
              mkappl (oo_prim "make_class_store",
                      [transl_meth_list pub_meths;
                       Lvar class_init; Lvar cached]))),
  make_envs (
  if ids = [] then mkappl (lfield cached 0, [lenvs]) else
  Lprim(Pmakeblock(0, Lambda.default_tag_info, Immutable),
        (if concrete then
          [mkappl (lfield cached 0, [lenvs]);
           lfield cached 1;
           lfield cached 0;
           lenvs]
        else [lambda_unit; lfield cached 0; lambda_unit; lenvs])
       , Location.none)))))

(* Wrapper for class compilation *)
(*
    let cl_id = ci.ci_id_class in
(* TODO: cl_id is used somewhere else as typesharp ? *)
  let _arity = List.length ci.ci_params in
  let pub_meths = m in
  let cl = ci.ci_expr in
  let vflag = vf in
*)

let transl_class ids id pub_meths cl vf =
  oo_wrap cl.cl_env false (transl_class ids id pub_meths cl) vf

let () =
  transl_object := (fun id meths cl -> transl_class [] id meths cl Concrete)

(* Error report *)

open Format

let report_error ppf = function
  | Illegal_class_expr ->
      fprintf ppf "This kind of recursive class expression is not allowed"
  | Tags (lab1, lab2) ->
      fprintf ppf "Method labels `%s' and `%s' are incompatible.@ %s"
        lab1 lab2 "Change one of them."

let () =
  Location.register_error_of_exn
    (function
      | Error (loc, err) ->
        Some (Location.error_of_printer loc report_error err)
      | _ ->
        None
    )

end
module Translmod : sig 
#1 "translmod.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Translation from typed abstract syntax to lambda terms,
   for the module language *)

open Typedtree
open Lambda

val transl_implementation: string -> structure * module_coercion -> lambda
val transl_store_phrases: string -> structure -> int * lambda
val transl_store_implementation:
      string -> structure * module_coercion -> int * lambda
val transl_toplevel_definition: structure -> lambda
val transl_package:
      Ident.t option list -> Ident.t -> module_coercion -> lambda
val transl_store_package:
      Ident.t option list -> Ident.t -> module_coercion -> int * lambda

val toplevel_name: Ident.t -> string
val nat_toplevel_name: Ident.t -> Ident.t * int

val primitive_declarations: Primitive.description list ref

type error =
  Circular_dependency of Ident.t

exception Error of Location.t * error

val report_error: Format.formatter -> error -> unit

val reset: unit -> unit


(** make it an array for better performance*)
val get_export_identifiers : unit -> Ident.t list 

end = struct
#1 "translmod.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Translation from typed abstract syntax to lambda terms,
   for the module language *)

open Misc
open Asttypes
open Longident
open Path
open Types
open Typedtree
open Lambda
open Translobj
open Translcore
open Translclass

type error =
  Circular_dependency of Ident.t


exception Error of Location.t * error

(* Keep track of the root path (from the root of the namespace to the
   currently compiled module expression).  Useful for naming extensions. *)

let global_path glob = Some(Pident glob)
let is_top rootpath = 
  match rootpath with 
  | Some (Pident _ ) -> true
  | _ -> false 

let functor_path path param =
  match path with
    None -> None
  | Some p -> Some(Papply(p, Pident param))
let field_path path field =
  match path with
    None -> None
  | Some p -> Some(Pdot(p, Ident.name field, Path.nopos))

(* Compile type extensions *)

let prim_set_oo_id =
  Pccall {Primitive.prim_name = "caml_set_oo_id"; prim_arity = 1;
          prim_alloc = false; prim_native_name = "";
          prim_native_float = false}

let transl_extension_constructor env path ext =
  let name =
    match path with
      None -> Ident.name ext.ext_id
    | Some p -> Path.name p
  in
  let loc = ext.ext_loc in
  match ext.ext_kind with
    Text_decl(args, ret) ->
      let tag_info =
        if Path.same ext.ext_type.ext_type_path Predef.path_exn then
          Blk_exception
        else Blk_extension in 
      Lprim(prim_set_oo_id,
            [Lprim(Pmakeblock(Obj.object_tag, tag_info, Mutable),
                   [Lconst(Const_base(Const_string (name,None)));
                    Lconst(Const_base(Const_int 0))], loc)], loc)
  | Text_rebind(path, lid) ->
      transl_path ~loc env path

let transl_type_extension env rootpath tyext body =
  List.fold_right
    (fun ext body ->
      let lam =
        transl_extension_constructor env (field_path rootpath ext.ext_id) ext
      in
      Llet(Strict, ext.ext_id, lam, body))
    tyext.tyext_constructors
    body

(* Compile a coercion *)

let rec apply_coercion loc strict restr arg =
  match restr with
    Tcoerce_none ->
      arg
  | Tcoerce_structure(pos_cc_list, id_pos_list) ->
      name_lambda strict arg (fun id ->
        let get_field pos = Lprim(Pfield (pos, Fld_na (*TODO*)),[Lvar id], loc) in
        let lam =
          Lprim(Pmakeblock(0, Lambda.default_tag_info, Immutable),
                List.map (apply_coercion_field loc get_field) pos_cc_list, loc)
        in
        wrap_id_pos_list loc id_pos_list get_field lam)
  | Tcoerce_functor(cc_arg, cc_res) ->
      let param = Ident.create "funarg" in
      name_lambda strict arg (fun id ->
        Lfunction(Curried, [param],
          apply_coercion loc Strict cc_res
            (Lapply(Lvar id, [apply_coercion loc Alias cc_arg (Lvar param)],
                   Location.none))))
  | Tcoerce_primitive (_,p) ->
      transl_primitive Location.none p
  | Tcoerce_alias (path, cc) ->
      name_lambda strict arg
        (fun id -> apply_coercion loc Alias cc (transl_normal_path path))

and apply_coercion_field loc get_field (pos, cc) =
  apply_coercion loc Alias cc (get_field pos)

and wrap_id_pos_list loc id_pos_list get_field lam =
  let fv = free_variables lam in
  (*Format.eprintf "%a@." Printlambda.lambda lam;
  IdentSet.iter (fun id -> Format.eprintf "%a " Ident.print id) fv;
  Format.eprintf "@.";*)
  let (lam,s) =
    List.fold_left (fun (lam,s) (id',pos,c) ->
      if IdentSet.mem id' fv then
        let id'' = Ident.create (Ident.name id') in
        (Llet(Alias,id'',
              apply_coercion loc Alias c (get_field pos),lam),
         Ident.add id' (Lvar id'') s)
      else (lam,s))
      (lam, Ident.empty) id_pos_list
  in
  if s == Ident.empty then lam else subst_lambda s lam


(* Compose two coercions
   apply_coercion c1 (apply_coercion c2 e) behaves like
   apply_coercion (compose_coercions c1 c2) e. *)

let rec compose_coercions c1 c2 =
  match (c1, c2) with
    (Tcoerce_none, c2) -> c2
  | (c1, Tcoerce_none) -> c1
  | (Tcoerce_structure (pc1, ids1), Tcoerce_structure (pc2, ids2)) ->
      let v2 = Array.of_list pc2 in
      let ids1 =
        List.map (fun (id,pos1,c1) ->
          let (pos2,c2) = v2.(pos1) in (id, pos2, compose_coercions c1 c2))
          ids1
      in
      Tcoerce_structure
        (List.map
          (function (p1, Tcoerce_primitive _) as x ->
                      x (* (p1, Tcoerce_primitive p) *)
                  | (p1, c1) ->
                      let (p2, c2) = v2.(p1) in (p2, compose_coercions c1 c2))
             pc1,
         ids1 @ ids2)
  | (Tcoerce_functor(arg1, res1), Tcoerce_functor(arg2, res2)) ->
      Tcoerce_functor(compose_coercions arg2 arg1,
                      compose_coercions res1 res2)
  | (c1, Tcoerce_alias (path, c2)) ->
      Tcoerce_alias (path, compose_coercions c1 c2)
  | (_, _) ->
      fatal_error "Translmod.compose_coercions"

(*
let apply_coercion a b c =
  Format.eprintf "@[<2>apply_coercion@ %a@]@." Includemod.print_coercion b;
  apply_coercion a b c

let compose_coercions c1 c2 =
  let c3 = compose_coercions c1 c2 in
  let open Includemod in
  Format.eprintf "@[<2>compose_coercions@ (%a)@ (%a) =@ %a@]@."
    print_coercion c1 print_coercion c2 print_coercion c3;
  c3
*)

(* Record the primitive declarations occuring in the module compiled *)

let primitive_declarations = ref ([] :  Primitive.description list)
let record_primitive = function
  | {val_kind=Val_prim p} ->
      primitive_declarations := p :: !primitive_declarations
  | _ -> ()

(* Utilities for compiling "module rec" definitions *)

let mod_prim name =
  try
    transl_normal_path
      (fst (Env.lookup_value (Ldot (Lident "CamlinternalMod", name))
                             Env.empty))
  with Not_found ->
    fatal_error ("Primitive " ^ name ^ " not found.")

let undefined_location loc =
  let (fname, line, char) = Location.get_pos_info loc.Location.loc_start in
  Lconst(Const_block(0, Lambda.default_tag_info,
                     [Const_base(Const_string (fname, None));
                      Const_base(Const_int line);
                      Const_base(Const_int char)]))

let init_shape modl =
  let rec init_shape_mod env mty =
    match Mtype.scrape env mty with
      Mty_ident _ ->
        raise Not_found
    | Mty_alias _ ->
        Const_block (1, Lambda.default_tag_info, [Const_pointer (0, Lambda.Pt_module_alias)])
    | Mty_signature sg ->
        Const_block(0,  Lambda.default_tag_info, [Const_block(0, Lambda.default_tag_info, init_shape_struct env sg)])
    | Mty_functor(id, arg, res) ->
        raise Not_found (* can we do better? *)
  and init_shape_struct env sg =
    match sg with
      [] -> []
    | Sig_value(id, vdesc) :: rem ->
        let init_v =
          match Ctype.expand_head env vdesc.val_type with
            {desc = Tarrow(_,_,_,_)} ->
              Const_pointer (0,Lambda.default_pointer_info) (* camlinternalMod.Function *)
          | {desc = Tconstr(p, _, _)} when Path.same p Predef.path_lazy_t ->
              Const_pointer (1, Lambda.default_pointer_info) (* camlinternalMod.Lazy *)
          | _ -> raise Not_found in
        init_v :: init_shape_struct env rem
    | Sig_type(id, tdecl, _) :: rem ->
        init_shape_struct (Env.add_type ~check:false id tdecl env) rem
    | Sig_typext(id, ext, _) :: rem ->
        raise Not_found
    | Sig_module(id, md, _) :: rem ->
        init_shape_mod env md.md_type ::
        init_shape_struct (Env.add_module_declaration id md env) rem
    | Sig_modtype(id, minfo) :: rem ->
        init_shape_struct (Env.add_modtype id minfo env) rem
    | Sig_class(id, cdecl, _) :: rem ->
        Const_pointer (2, Lambda.default_pointer_info) (* camlinternalMod.Class *)
        :: init_shape_struct env rem
    | Sig_class_type(id, ctyp, _) :: rem ->
        init_shape_struct env rem
  in
  try
    Some(undefined_location modl.mod_loc,
         Lconst(init_shape_mod modl.mod_env modl.mod_type))
  with Not_found ->
    None

(* Reorder bindings to honor dependencies.  *)

type binding_status = Undefined | Inprogress | Defined

let reorder_rec_bindings bindings =
  let id = Array.of_list (List.map (fun (id,_,_,_) -> id) bindings)
  and loc = Array.of_list (List.map (fun (_,loc,_,_) -> loc) bindings)
  and init = Array.of_list (List.map (fun (_,_,init,_) -> init) bindings)
  and rhs = Array.of_list (List.map (fun (_,_,_,rhs) -> rhs) bindings) in
  let fv = Array.map Lambda.free_variables rhs in
  let num_bindings = Array.length id in
  let status = Array.make num_bindings Undefined in
  let res = ref [] in
  let rec emit_binding i =
    match status.(i) with
      Defined -> ()
    | Inprogress -> raise(Error(loc.(i), Circular_dependency id.(i)))
    | Undefined ->
        if init.(i) = None then begin
          status.(i) <- Inprogress;
          for j = 0 to num_bindings - 1 do
            if IdentSet.mem id.(j) fv.(i) then emit_binding j
          done
        end;
        res := (id.(i), init.(i), rhs.(i)) :: !res;
        status.(i) <- Defined in
  for i = 0 to num_bindings - 1 do
    match status.(i) with
      Undefined -> emit_binding i
    | Inprogress -> assert false
    | Defined -> ()
  done;
  List.rev !res

(* Generate lambda-code for a reordered list of bindings *)

let eval_rec_bindings bindings cont =
  let rec bind_inits = function
    [] ->
      bind_strict bindings
  | (id, None, rhs) :: rem ->
      bind_inits rem
  | (id, Some(loc, shape), rhs) :: rem ->
      Llet(Strict, id, Lapply(mod_prim "init_mod", [loc; shape], Location.none),
           bind_inits rem)
  and bind_strict = function
    [] ->
      patch_forwards bindings
  | (id, None, rhs) :: rem ->
      Llet(Strict, id, rhs, bind_strict rem)
  | (id, Some(loc, shape), rhs) :: rem ->
      bind_strict rem
  and patch_forwards = function
    [] ->
      cont
  | (id, None, rhs) :: rem ->
      patch_forwards rem
  | (id, Some(loc, shape), rhs) :: rem ->
      Lsequence(Lapply(mod_prim "update_mod", [shape; Lvar id; rhs],
                       Location.none),
                patch_forwards rem)
  in
    bind_inits bindings

let compile_recmodule compile_rhs bindings cont =
  eval_rec_bindings
    (reorder_rec_bindings
       (List.map
          (fun {mb_id=id; mb_expr=modl; _} ->
            (id, modl.mod_loc, init_shape modl, compile_rhs id modl))
          bindings))
    cont

(* Extract the list of "value" identifiers bound by a signature.
   "Value" identifiers are identifiers for signature components that
   correspond to a run-time value: values, extensions, modules, classes.
   Note: manifest primitives do not correspond to a run-time value! *)

let rec bound_value_identifiers = function
    [] -> []
  | Sig_value(id, {val_kind = Val_reg}) :: rem ->
      id :: bound_value_identifiers rem
  | Sig_typext(id, ext, _) :: rem -> id :: bound_value_identifiers rem
  | Sig_module(id, mty, _) :: rem -> id :: bound_value_identifiers rem
  | Sig_class(id, decl, _) :: rem -> id :: bound_value_identifiers rem
  | _ :: rem -> bound_value_identifiers rem

(* Compile a module expression *)
 
let export_identifiers  : Ident.t list ref = ref []
let get_export_identifiers () = 
  !export_identifiers

let rec transl_module cc rootpath mexp =
  let loc = mexp.mod_loc in
  match mexp.mod_type with
    Mty_alias _ -> apply_coercion loc Alias cc lambda_unit
  | _ ->
  match mexp.mod_desc with
    Tmod_ident (path,_) ->
      apply_coercion loc Strict cc
        (transl_path ~loc mexp.mod_env path)
  | Tmod_structure str ->
      transl_struct loc [] cc rootpath str
  | Tmod_functor( param, _, mty, body) ->
      let bodypath = functor_path rootpath param in
      oo_wrap mexp.mod_env true
        (function
        | Tcoerce_none ->
            Lfunction(Curried, [param],
                      transl_module Tcoerce_none bodypath body)
        | Tcoerce_functor(ccarg, ccres) ->
            let param' = Ident.create "funarg" in
            Lfunction(Curried, [param'],
                      Llet(Alias, param,
                           apply_coercion loc Alias ccarg (Lvar param'),
                           transl_module ccres bodypath body))
        | _ ->
            fatal_error "Translmod.transl_module")
        cc
  | Tmod_apply(funct, arg, ccarg) ->
      oo_wrap mexp.mod_env true
        (apply_coercion loc Strict cc)
        (Lapply(transl_module Tcoerce_none None funct,
                [transl_module ccarg None arg], loc))
  | Tmod_constraint(arg, mty, _, ccarg) ->
      transl_module (compose_coercions cc ccarg) rootpath arg
  | Tmod_unpack(arg, _) ->
      apply_coercion loc  Strict cc (Translcore.transl_exp arg)

and transl_struct loc fields cc rootpath str =
  transl_structure loc fields cc rootpath str.str_items

and transl_structure loc fields cc rootpath = function
    [] ->
      begin match cc with
        Tcoerce_none ->
          let fields =  List.rev fields in
          let field_names = List.map (fun id -> id.Ident.name) fields in
          Lprim(Pmakeblock(0, Lambda.Blk_module (Some field_names) , Immutable),
                List.fold_right (fun id acc -> begin
                      (if is_top rootpath then 
                         export_identifiers :=  id :: !export_identifiers);
                      (Lvar id :: acc) end) fields [] , loc
                 )
      | Tcoerce_structure(pos_cc_list, id_pos_list) ->
              (* Do not ignore id_pos_list ! *)
          (*Format.eprintf "%a@.@[" Includemod.print_coercion cc;
          List.iter (fun l -> Format.eprintf "%a@ " Ident.print l)
            fields;
          Format.eprintf "@]@.";*)
          let v = Array.of_list (List.rev fields) in
          let get_field pos = Lvar v.(pos)
          and ids = List.fold_right IdentSet.add fields IdentSet.empty in
          let (result, names) = List.fold_right
              (fun  (pos, cc) (code, name) ->
                 begin match cc with
                 | Tcoerce_primitive (id,p) -> 
                     (if is_top rootpath then 
                        export_identifiers := id:: !export_identifiers);
                     (transl_primitive Location.none p :: code, p.Primitive.prim_name ::name)
                 | _ -> 
                     (if is_top rootpath then 
                        export_identifiers :=  v.(pos) :: !export_identifiers);
                     (apply_coercion loc Strict cc (get_field pos) :: code, v.(pos).Ident.name :: name)
                 end)
              pos_cc_list ([], [])in 
          let lam =
            (Lprim(Pmakeblock(0, Blk_module (Some names), Immutable),
                   result, loc))
          and id_pos_list =
            List.filter (fun (id,_,_) -> not (IdentSet.mem id ids)) id_pos_list
          in
          wrap_id_pos_list loc id_pos_list get_field lam
      | _ ->
          fatal_error "Translmod.transl_structure"
      end
  | item :: rem ->
      match item.str_desc with
      | Tstr_eval (expr, _) ->
      Lsequence(transl_exp expr, transl_structure loc fields cc rootpath rem)
  | Tstr_value(rec_flag, pat_expr_list) ->
      let ext_fields = rev_let_bound_idents pat_expr_list @ fields in
      transl_let rec_flag pat_expr_list
                 (transl_structure loc ext_fields cc rootpath rem)
  | Tstr_primitive descr ->
      record_primitive descr.val_val;
      transl_structure loc fields cc rootpath rem
  | Tstr_type decls ->
      transl_structure loc  fields cc rootpath rem
  | Tstr_typext(tyext) ->
      let ids = List.map (fun ext -> ext.ext_id) tyext.tyext_constructors in
      transl_type_extension item.str_env rootpath tyext
        (transl_structure loc (List.rev_append ids fields) cc rootpath rem)
  | Tstr_exception ext ->
      let id = ext.ext_id in
      let path = field_path rootpath id in
      Llet(Strict, id, transl_extension_constructor item.str_env path ext,
           transl_structure loc (id :: fields) cc rootpath rem)
  | Tstr_module mb ->
      let id = mb.mb_id in
      Llet(pure_module mb.mb_expr, id,
           transl_module Tcoerce_none (field_path rootpath id) mb.mb_expr,
           transl_structure loc (id :: fields) cc rootpath rem)
  | Tstr_recmodule bindings ->
      let ext_fields =
        List.rev_append (List.map (fun mb -> mb.mb_id) bindings) fields
      in
      compile_recmodule
        (fun id modl ->
          transl_module Tcoerce_none (field_path rootpath id) modl)
        bindings
        (transl_structure loc ext_fields cc rootpath rem)
  | Tstr_class cl_list ->
      let ids = List.map (fun (ci,_,_) -> ci.ci_id_class) cl_list in
      Lletrec(List.map
              (fun (ci, meths, vf) ->
                let id = ci.ci_id_class in
                let cl = ci.ci_expr in
                  (id, transl_class ids id meths cl vf ))
                cl_list,
              transl_structure loc (List.rev_append ids fields) cc rootpath rem)
  | Tstr_include incl ->
      let ids = bound_value_identifiers incl.incl_type in
      let modl = incl.incl_mod in
      let mid = Ident.create "include" in
      let rec rebind_idents pos newfields = function
        [] ->
          transl_structure loc newfields cc rootpath rem
      | id :: ids ->
          Llet(Alias, id, Lprim(Pfield (pos, Fld_na), [Lvar mid], incl.incl_loc),
               rebind_idents (pos + 1) (id :: newfields) ids) in
      Llet(pure_module modl, mid, transl_module Tcoerce_none None modl,
           rebind_idents 0 fields ids)

  | Tstr_modtype _
  | Tstr_open _
  | Tstr_class_type _
  | Tstr_attribute _ ->
      transl_structure loc fields cc rootpath rem

and pure_module m =
  match m.mod_desc with
    Tmod_ident _ -> Alias
  | Tmod_constraint (m,_,_,_) -> pure_module m
  | _ -> Strict

(* Update forward declaration in Translcore *)
let _ =
  Translcore.transl_module := transl_module

(* Compile an implementation *)

let transl_implementation module_name (str, cc) =
  reset_labels ();
  primitive_declarations := [];
  let module_id = Ident.create_persistent module_name in
  Lprim(Psetglobal module_id,
        [transl_label_init
            (transl_struct Location.none [] cc (global_path module_id) str)], Location.none)


(* Build the list of value identifiers defined by a toplevel structure
   (excluding primitive declarations). *)

let rec defined_idents = function
    [] -> []
  | item :: rem ->
    match item.str_desc with
    | Tstr_eval (expr, _) -> defined_idents rem
    | Tstr_value(rec_flag, pat_expr_list) ->
      let_bound_idents pat_expr_list @ defined_idents rem
    | Tstr_primitive desc -> defined_idents rem
    | Tstr_type decls -> defined_idents rem
    | Tstr_typext tyext ->
      List.map (fun ext -> ext.ext_id) tyext.tyext_constructors
      @ defined_idents rem
    | Tstr_exception ext -> ext.ext_id :: defined_idents rem
    | Tstr_module mb -> mb.mb_id :: defined_idents rem
    | Tstr_recmodule decls ->
      List.map (fun mb -> mb.mb_id) decls @ defined_idents rem
    | Tstr_modtype _ -> defined_idents rem
    | Tstr_open _ -> defined_idents rem
    | Tstr_class cl_list ->
      List.map (fun (ci, _, _) -> ci.ci_id_class) cl_list @ defined_idents rem
    | Tstr_class_type cl_list -> defined_idents rem
    | Tstr_include incl ->
      bound_value_identifiers incl.incl_type @ defined_idents rem
    | Tstr_attribute _ -> defined_idents rem

(* second level idents (module M = struct ... let id = ... end),
   and all sub-levels idents *)
let rec more_idents = function
    [] -> []
  | item :: rem ->
    match item.str_desc with
    | Tstr_eval (expr, _attrs) -> more_idents rem
    | Tstr_value(rec_flag, pat_expr_list) -> more_idents rem
    | Tstr_primitive _ -> more_idents rem
    | Tstr_type decls -> more_idents rem
    | Tstr_typext tyext -> more_idents rem
    | Tstr_exception _ -> more_idents rem
    | Tstr_recmodule decls -> more_idents rem
    | Tstr_modtype _ -> more_idents rem
    | Tstr_open _ -> more_idents rem
    | Tstr_class cl_list -> more_idents rem
    | Tstr_class_type cl_list -> more_idents rem
    | Tstr_include _ -> more_idents rem
    | Tstr_module {mb_expr={mod_desc = Tmod_structure str}} ->
        all_idents str.str_items @ more_idents rem
    | Tstr_module _ -> more_idents rem
    | Tstr_attribute _ -> more_idents rem

and all_idents = function
    [] -> []
  | item :: rem ->
    match item.str_desc with
    | Tstr_eval (expr, _attrs) -> all_idents rem
    | Tstr_value(rec_flag, pat_expr_list) ->
      let_bound_idents pat_expr_list @ all_idents rem
    | Tstr_primitive _ -> all_idents rem
    | Tstr_type decls -> all_idents rem
    | Tstr_typext tyext ->
      List.map (fun ext -> ext.ext_id) tyext.tyext_constructors
      @ all_idents rem
    | Tstr_exception ext -> ext.ext_id :: all_idents rem
    | Tstr_recmodule decls ->
      List.map (fun mb -> mb.mb_id) decls @ all_idents rem
    | Tstr_modtype _ -> all_idents rem
    | Tstr_open _ -> all_idents rem
    | Tstr_class cl_list ->
      List.map (fun (ci, _, _) -> ci.ci_id_class) cl_list @ all_idents rem
    | Tstr_class_type cl_list -> all_idents rem
    | Tstr_include incl ->
      bound_value_identifiers incl.incl_type @ all_idents rem
    | Tstr_module {mb_id;mb_expr={mod_desc = Tmod_structure str}} ->
        mb_id :: all_idents str.str_items @ all_idents rem
    | Tstr_module mb -> mb.mb_id :: all_idents rem
    | Tstr_attribute _ -> all_idents rem


(* A variant of transl_structure used to compile toplevel structure definitions
   for the native-code compiler. Store the defined values in the fields
   of the global as soon as they are defined, in order to reduce register
   pressure.  Also rewrites the defining expressions so that they
   refer to earlier fields of the structure through the fields of
   the global, not by their names.
   "map" is a table from defined idents to (pos in global block, coercion).
   "prim" is a list of (pos in global block, primitive declaration). *)

let transl_store_subst = ref Ident.empty
  (** In the native toplevel, this reference is threaded through successive
      calls of transl_store_structure *)

let nat_toplevel_name id =
  try match Ident.find_same id !transl_store_subst with
    | Lprim(Pfield (pos, _), [Lprim(Pgetglobal glob, [], _)] ,_) -> (glob,pos)
    | _ -> raise Not_found
  with Not_found ->
    fatal_error("Translmod.nat_toplevel_name: " ^ Ident.unique_name id)

let transl_store_structure glob map prims str =
  let rec transl_store rootpath subst = function
    [] ->
      transl_store_subst := subst;
        lambda_unit
    | item :: rem ->
        match item.str_desc with
  | Tstr_eval (expr, _attrs) ->
      Lsequence(subst_lambda subst (transl_exp expr),
                transl_store rootpath subst rem)
  | Tstr_value(rec_flag, pat_expr_list) ->
      let ids = let_bound_idents pat_expr_list in
      let lam = transl_let rec_flag pat_expr_list (store_idents Location.none ids) in
      Lsequence(subst_lambda subst lam,
                transl_store rootpath (add_idents false ids subst) rem)
  | Tstr_primitive descr ->
      record_primitive descr.val_val;
      transl_store rootpath subst rem
  | Tstr_type decls ->
      transl_store rootpath subst rem
  | Tstr_typext(tyext) ->
      let ids = List.map (fun ext -> ext.ext_id) tyext.tyext_constructors in
      let lam =
        transl_type_extension item.str_env rootpath tyext (store_idents Location.none ids)
      in
        Lsequence(subst_lambda subst lam,
                  transl_store rootpath (add_idents false ids subst) rem)
  | Tstr_exception ext ->
      let id = ext.ext_id in
      let path = field_path rootpath id in
      let lam = transl_extension_constructor item.str_env path ext in
      Lsequence(Llet(Strict, id, subst_lambda subst lam, store_ident ext.ext_loc id),
                transl_store rootpath (add_ident false id subst) rem)
  | Tstr_module{mb_id=id; mb_expr={mod_desc = Tmod_structure str}; mb_loc = loc} ->
    let lam = transl_store (field_path rootpath id) subst str.str_items in
      (* Careful: see next case *)
    let subst = !transl_store_subst in
    Lsequence(lam,
              Llet(Strict, id,
                   subst_lambda subst
                   (Lprim(Pmakeblock(0, Lambda.default_tag_info, Immutable),
                          List.map (fun id -> Lvar id)
                                   (defined_idents str.str_items),loc)),
                   Lsequence(store_ident loc id,
                             transl_store rootpath (add_ident true id subst)
                                          rem)))
  | Tstr_module{mb_id=id; mb_expr=modl; mb_loc = loc} ->
      let lam = transl_module Tcoerce_none (field_path rootpath id) modl in
      (* Careful: the module value stored in the global may be different
         from the local module value, in case a coercion is applied.
         If so, keep using the local module value (id) in the remainder of
         the compilation unit (add_ident true returns subst unchanged).
         If not, we can use the value from the global
         (add_ident true adds id -> Pgetglobal... to subst). *)
      Llet(Strict, id, subst_lambda subst lam,
        Lsequence(store_ident loc id,
                  transl_store rootpath (add_ident true id subst) rem))
  | Tstr_recmodule bindings ->
      let ids = List.map (fun mb -> mb.mb_id) bindings in
      compile_recmodule
        (fun id modl ->
          subst_lambda subst
            (transl_module Tcoerce_none
                           (field_path rootpath id) modl))
        bindings
        (Lsequence(store_idents Location.none ids,
                   transl_store rootpath (add_idents true ids subst) rem))
  | Tstr_class cl_list ->
      let ids = List.map (fun (ci, _, _) -> ci.ci_id_class) cl_list in
      let lam =
        Lletrec(List.map
              (fun (ci, meths, vf) ->
                let id = ci.ci_id_class in
                let cl = ci.ci_expr in
                     (id, transl_class ids id meths cl vf))
                  cl_list,
                store_idents Location.none ids) in
      Lsequence(subst_lambda subst lam,
                transl_store rootpath (add_idents false ids subst) rem)
  | Tstr_include incl ->
      let ids = bound_value_identifiers incl.incl_type in
      let modl = incl.incl_mod in
      let mid = Ident.create "include" in
      let loc = incl.incl_loc in
      let rec store_idents pos = function
        [] -> transl_store rootpath (add_idents true ids subst) rem
      | id :: idl ->
          Llet(Alias, id, Lprim(Pfield (pos, Fld_na), [Lvar mid],loc),
               Lsequence(store_ident loc id, store_idents (pos + 1) idl)) in
      Llet(Strict, mid,
           subst_lambda subst (transl_module Tcoerce_none None modl),
           store_idents 0 ids)
  | Tstr_modtype _
  | Tstr_open _
  | Tstr_class_type _
  | Tstr_attribute _ ->
      transl_store rootpath subst rem

  and store_ident loc id =
    try
      let (pos, cc) = Ident.find_same id map in
      let init_val = apply_coercion loc Alias cc (Lvar id) in
      Lprim(Psetfield(pos, false, Fld_set_na), [Lprim(Pgetglobal glob, [], loc); init_val], loc)
    with Not_found ->
      fatal_error("Translmod.store_ident: " ^ Ident.unique_name id)

  and store_idents loc idlist =
    make_sequence (store_ident loc) idlist

  and add_ident may_coerce id subst =
    try
      let (pos, cc) = Ident.find_same id map in
      match cc with
        Tcoerce_none ->
          Ident.add id (Lprim(Pfield (pos, Fld_na), [Lprim(Pgetglobal glob, [], Location.none)], Location.none)) subst
      | _ ->
          if may_coerce then subst else assert false
    with Not_found ->
      assert false

  and add_idents may_coerce idlist subst =
    List.fold_right (add_ident may_coerce) idlist subst

  and store_primitive (pos, prim) cont =
    Lsequence(Lprim(Psetfield(pos, false, Fld_set_na),
                    [Lprim(Pgetglobal glob, [], Location.none);
                     transl_primitive Location.none prim], Location.none),
              cont)

  in List.fold_right store_primitive prims
                     (transl_store (global_path glob) !transl_store_subst str)

(* Transform a coercion and the list of value identifiers defined by
   a toplevel structure into a table [id -> (pos, coercion)],
   with [pos] being the position in the global block where the value of
   [id] must be stored, and [coercion] the coercion to be applied to it.
   A given identifier may appear several times
   in the coercion (if it occurs several times in the signature); remember
   to assign it the position of its last occurrence.
   Identifiers that are not exported are assigned positions at the
   end of the block (beyond the positions of all exported idents).
   Also compute the total size of the global block,
   and the list of all primitives exported as values. *)

let build_ident_map restr idlist more_ids =
  let rec natural_map pos map prims = function
    [] ->
      (map, prims, pos)
  | id :: rem ->
      natural_map (pos+1) (Ident.add id (pos, Tcoerce_none) map) prims rem in
  let (map, prims, pos) =
    match restr with
        Tcoerce_none ->
          natural_map 0 Ident.empty [] idlist
      | Tcoerce_structure (pos_cc_list, _id_pos_list) ->
              (* ignore _id_pos_list as the ids are already bound *)
        let idarray = Array.of_list idlist in
        let rec export_map pos map prims undef = function
        [] ->
          natural_map pos map prims undef
          | (source_pos, Tcoerce_primitive (_,p)) :: rem ->
            export_map (pos + 1) map ((pos, p) :: prims) undef rem
          | (source_pos, cc) :: rem ->
            let id = idarray.(source_pos) in
            export_map (pos + 1) (Ident.add id (pos, cc) map)
              prims (list_remove id undef) rem
        in export_map 0 Ident.empty [] idlist pos_cc_list
      | _ ->
        fatal_error "Translmod.build_ident_map"
  in
  natural_map pos map prims more_ids

(* Compile an implementation using transl_store_structure
   (for the native-code compiler). *)

let transl_store_gen module_name ({ str_items = str }, restr) topl =
  reset_labels ();
  primitive_declarations := [];
  let module_id = Ident.create_persistent module_name in
  let (map, prims, size) =
    build_ident_map restr (defined_idents str) (more_idents str) in
  let f = function
    | [ { str_desc = Tstr_eval (expr, _attrs) } ] when topl ->
        assert (size = 0);
        subst_lambda !transl_store_subst (transl_exp expr)
    | str -> transl_store_structure module_id map prims str in
  transl_store_label_init module_id size f str
  (*size, transl_label_init (transl_store_structure module_id map prims str)*)

let transl_store_phrases module_name str =
  transl_store_gen module_name (str,Tcoerce_none) true

let transl_store_implementation module_name (str, restr) =
  let s = !transl_store_subst in
  transl_store_subst := Ident.empty;
  let r = transl_store_gen module_name (str, restr) false in
  transl_store_subst := s;
  r

(* Compile a toplevel phrase *)

let toploop_ident = Ident.create_persistent "Toploop"
let toploop_getvalue_pos = 0 (* position of getvalue in module Toploop *)
let toploop_setvalue_pos = 1 (* position of setvalue in module Toploop *)

let aliased_idents = ref Ident.empty

let set_toplevel_unique_name id =
  aliased_idents :=
    Ident.add id (Ident.unique_toplevel_name id) !aliased_idents

let toplevel_name id =
  try Ident.find_same id !aliased_idents
  with Not_found -> Ident.name id

let toploop_getvalue id =
  Lapply(Lprim(Pfield (toploop_getvalue_pos, Fld_na),
                 [Lprim(Pgetglobal toploop_ident, [], Location.none)], Location.none),
         [Lconst(Const_base(Const_string (toplevel_name id, None)))],
         Location.none)

let toploop_setvalue id lam =
  Lapply(Lprim(Pfield (toploop_setvalue_pos, Fld_na),
                 [Lprim(Pgetglobal toploop_ident, [], Location.none)], Location.none),
         [Lconst(Const_base(Const_string (toplevel_name id, None))); lam],
         Location.none)

let toploop_setvalue_id id = toploop_setvalue id (Lvar id)

let close_toplevel_term lam =
  IdentSet.fold (fun id l -> Llet(Strict, id, toploop_getvalue id, l))
                (free_variables lam) lam

let transl_toplevel_item item =
  match item.str_desc with
    Tstr_eval (expr, _attrs) ->
      transl_exp expr
  | Tstr_value(rec_flag, pat_expr_list) ->
      let idents = let_bound_idents pat_expr_list in
      transl_let rec_flag pat_expr_list
                 (make_sequence toploop_setvalue_id idents)
  | Tstr_typext(tyext) ->
      let idents =
        List.map (fun ext -> ext.ext_id) tyext.tyext_constructors
      in
        transl_type_extension item.str_env None tyext
          (make_sequence toploop_setvalue_id idents)
  | Tstr_exception ext ->
      toploop_setvalue ext.ext_id
        (transl_extension_constructor item.str_env None ext)
  | Tstr_module {mb_id=id; mb_expr=modl} ->
      (* we need to use the unique name for the module because of issues
         with "open" (PR#1672) *)
      set_toplevel_unique_name id;
      let lam = transl_module Tcoerce_none (Some(Pident id)) modl in
      toploop_setvalue id lam
  | Tstr_recmodule bindings ->
      let idents = List.map (fun mb -> mb.mb_id) bindings in
      compile_recmodule
        (fun id modl -> transl_module Tcoerce_none (Some(Pident id)) modl)
        bindings
        (make_sequence toploop_setvalue_id idents)
  | Tstr_class cl_list ->
      (* we need to use unique names for the classes because there might
         be a value named identically *)
      let ids = List.map (fun (ci, _, _) -> ci.ci_id_class) cl_list in
      List.iter set_toplevel_unique_name ids;
      Lletrec(List.map
          (fun (ci, meths, vf) ->
            let id = ci.ci_id_class in
            let cl = ci.ci_expr in
                   (id, transl_class ids id meths cl vf))
                cl_list,
              make_sequence
                (fun (ci, _, _) -> toploop_setvalue_id ci.ci_id_class)
                cl_list)
  | Tstr_include incl ->
      let ids = bound_value_identifiers incl.incl_type in
      let modl = incl.incl_mod in
      let mid = Ident.create "include" in
      let rec set_idents pos = function
        [] ->
          lambda_unit
      | id :: ids ->
          Lsequence(toploop_setvalue id (Lprim(Pfield (pos, Fld_na), [Lvar mid], Location.none)),
                    set_idents (pos + 1) ids) in
      Llet(Strict, mid, transl_module Tcoerce_none None modl, set_idents 0 ids)
  | Tstr_modtype _
  | Tstr_open _
  | Tstr_primitive _
  | Tstr_type _
  | Tstr_class_type _
  | Tstr_attribute _ ->
      lambda_unit

let transl_toplevel_item_and_close itm =
  close_toplevel_term (transl_label_init (transl_toplevel_item itm))

let transl_toplevel_definition str =
  reset_labels ();
  make_sequence transl_toplevel_item_and_close str.str_items

(* Compile the initialization code for a packed library *)

let get_component = function
    None -> Lconst const_unit
  | Some id -> Lprim(Pgetglobal id, [], Location.none)

let transl_package component_names target_name coercion =
  let components =
    Lprim(Pmakeblock(0, Lambda.default_tag_info, Immutable), List.map get_component component_names, Location.none) in
  Lprim(Psetglobal target_name, [apply_coercion Location.none Strict coercion components], Location.none)
  (*
  let components =
    match coercion with
      Tcoerce_none ->
        List.map get_component component_names
    | Tcoerce_structure (pos_cc_list, id_pos_list) ->
              (* ignore id_pos_list as the ids are already bound *)
        let g = Array.of_list component_names in
        List.map
          (fun (pos, cc) -> apply_coercion Strict cc (get_component g.(pos)))
          pos_cc_list
    | _ ->
        assert false in
  Lprim(Psetglobal target_name, [Lprim(Pmakeblock(0, Immutable), components)])
   *)

let transl_store_package component_names target_name coercion =
  let rec make_sequence fn pos arg =
    match arg with
      [] -> lambda_unit
    | hd :: tl -> Lsequence(fn pos hd, make_sequence fn (pos + 1) tl) in
  match coercion with
    Tcoerce_none ->
      (List.length component_names,
       make_sequence
         (fun pos id ->
           Lprim(Psetfield(pos, false, Fld_set_na),
                 [Lprim(Pgetglobal target_name, [], Location.none);
                  get_component id], Location.none))
         0 component_names)
  | Tcoerce_structure (pos_cc_list, id_pos_list) ->
      let components =
        Lprim(Pmakeblock(0, Lambda.default_tag_info, Immutable), List.map get_component component_names, Location.none)
      in
      let blk = Ident.create "block" in
      (List.length pos_cc_list,
       Llet (Strict, blk, apply_coercion Location.none Strict coercion components,
             make_sequence
               (fun pos id ->
                 Lprim(Psetfield(pos, false, Fld_set_na),
                       [Lprim(Pgetglobal target_name, [], Location.none);
                        Lprim(Pfield (pos, Fld_na), [Lvar blk], Location.none)], Location.none))
               0 pos_cc_list))
  (*
              (* ignore id_pos_list as the ids are already bound *)
      let id = Array.of_list component_names in
      (List.length pos_cc_list,
       make_sequence
         (fun dst (src, cc) ->
           Lprim(Psetfield(dst, false),
                 [Lprim(Pgetglobal target_name, []);
                  apply_coercion Strict cc (get_component id.(src))]))
         0 pos_cc_list)
  *)
  | _ -> assert false

(* Error report *)

open Format

let report_error ppf = function
    Circular_dependency id ->
      fprintf ppf
        "@[Cannot safely evaluate the definition@ \
         of the recursively-defined module %a@]"
        Printtyp.ident id

let () =
  Location.register_error_of_exn
    (function
      | Error (loc, err) ->
        Some (Location.error_of_printer loc report_error err)
      | _ ->
        None
    )

let reset () =
  export_identifiers := [];
  primitive_declarations := [];
  transl_store_subst := Ident.empty;
  toploop_ident.Ident.flags <- 0;
  aliased_idents := Ident.empty

end
module Type_int_to_string
= struct
#1 "type_int_to_string.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

let name_of_signature_item (x : Types.signature_item )=
  match x with 
  | Sig_value (i,_) 
  | Sig_module (i,_,_) -> i 
  | Sig_typext (i,_,_) -> i 
  | Sig_modtype(i,_) -> i 
  | Sig_class (i,_,_) -> i 
  | Sig_class_type(i,_,_) -> i 
  | Sig_type(i,_,_) -> i  


(** It should be safe to replace Pervasives[], 
    we should test cases  like module Pervasives = List *)
let serializable_signature =
  (fun x ->
     match (x : Types.signature_item) with 
     | Sig_value(_, {val_kind = Val_prim _}) -> false
     | Sig_typext _ 
     | Sig_module _
     | Sig_class _ 
     | Sig_value _ -> true
     | _ -> false)
  
let filter_serializable_signatures (signature : Types.signature)
  : Types.signature = 
  List.filter serializable_signature signature

end
module Type_util : sig 
#1 "type_util.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Utilities for quering typing inforaation from {!Env.t}, this part relies
    on compiler API
*)


val get_name : Types.signature -> int -> string


(* Input path is a global module 
    TODO: it should be fine for local module*)
val find_serializable_signatures_by_path :
  Ident.t -> Env.t -> Types.signature option


(* val find_name : *)
(*   Ident.t -> int -> Env.t -> string option *)




end = struct
#1 "type_util.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)



(* Input path is a global module 
    TODO: it should be fine for local module
*)
let find_serializable_signatures_by_path v (env : Env.t) 
  : Types.signature option = 
  match Env.find_module (Pident v) env with 
  | exception Not_found -> None 
  | {md_type = Mty_signature signature; _} -> 
    Some (Type_int_to_string.filter_serializable_signatures signature)
  (** TODO: refine *)
  | _ -> Ext_log.err __LOC__  "@[impossible path %s@]@."
           (Ident.name v) ; assert false 

let rec dump_summary fmt (x : Env.summary) = 
  match x with 
  | Env_empty -> ()
  | Env_value(s,id,value_description) -> 
    dump_summary fmt s ;
    Printtyp.value_description id fmt value_description
  | _ -> ()

(** Used in [ Lglobal_module] *)
let get_name  (serializable_sigs : Types.signature) (pos : int) = 
  Ident.name @@ Type_int_to_string.name_of_signature_item @@ List.nth  serializable_sigs  pos

(* let find_name id pos env = *)
(*   match find_serializable_signatures_by_path id env with *)
(*   | Some signatures -> *)
(*     Some (get_name signatures pos) *)
(*   | None -> None       *)



    


end
module Lam_compile_env : sig 
#1 "lam_compile_env.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Helper for global Ocaml module index into meaningful names  *) 

type primitive_description =  Primitive.description

type key = 
  Ident.t * Env.t * bool 
  (** the boolean is expand or not
      when it's passed as module, it should be expanded, 
      otherwise for alias, [include Array], it's okay to return an identifier
      TODO: be more clear about its concept
  *)
  (** we need register which global variable is an dependency *)

type path = string 
type ident_info = {
  id : Ident.t;
  name : string;
  signatures : Types.signature;
  arity : Js_cmj_format.arity;
  closed_lambda : Lam.t option 
}

type module_info = {
  signature :  Types.signature ;
  pure : bool 
}

type _ t = 
  | No_env :  (path * Js_cmj_format.t) t 
  | Has_env : Env.t  -> module_info t 

val find_and_add_if_not_exist : 
  Ident.t * int -> 
  Env.t -> 
  not_found:(Ident.t -> 'a) -> 
  found:(ident_info -> 'a) -> 'a

val query_and_add_if_not_exist : 
  Lam_module_ident.t ->
  'a t -> not_found:(unit -> 'b) ->
  found:('a -> 'b) -> 'b

val add_js_module : ?hint_name:string -> string  -> Ident.t 
(** add third party dependency *)

(* The other dependencies are captured by querying 
   either when [access] or when expansion, 
   however such dependency can be removed after inlining etc.

   When we register such compile time dependency we classified 
   it as 
   Visit (ml), Builtin(built in js), External()

   For external, we never remove, we only consider 
   remove dependency for Runtime and Visit, so 
   when compile OCaml to Javascript, we only need 
   pay attention to for those modules are actually used or not
*)

val reset : unit -> unit 

val is_pure_module : Lam_module_ident.t -> bool


val get_package_path_from_cmj : 
  Lam_module_ident.t -> 
  (string * Js_packages_info.t * bool) option



(* The second argument is mostly from [runtime] modules 
    will change the input [hard_dependencies]
    [get_required_modules extra hard_dependencies]
    [extra] maybe removed if it is pure and not in [hard_dependencies]
*)
val get_required_modules : 
  Lam_module_ident.Hash_set.t  ->
  Lam_module_ident.Hash_set.t -> 
  Lam_module_ident.t list

end = struct
#1 "lam_compile_env.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








module E = Js_exp_make  
module S = Js_stmt_make

type module_id = Lam_module_ident.t

type path = string 

type ml_module_info = { 
  signatures : Types.signature ;
  cmj_table : Js_cmj_format.t ;
  cmj_path : path;
}

type env_value = 
  | Visit of ml_module_info
  | Runtime  of bool * path * Js_cmj_format.t
  (** A built in module probably from our runtime primitives, 
      so it does not have any [signature]
  *)
  | External  
  (** Also a js file, but this belong to third party 
  *)

type module_info = {
  signature :  Types.signature ;
  pure : bool 
}

type primitive_description =  Primitive.description

type key = 
  Ident.t * Env.t  * bool (** we need register which global variable is an dependency *)


type ident_info = {
  id : Ident.t;
  name : string;
  signatures : Types.signature;
  arity : Js_cmj_format.arity; 
  closed_lambda : Lam.t option 
}

(*
   refer: [Env.find_pers_struct]
   [ find_in_path_uncap !load_path (name ^ ".cmi")]
*)



let cached_tbl  = Lam_module_ident.Hash.create 31

(* For each compilation we need reset to make it re-entrant *)
let reset () = 
  Translmod.reset ();
  Lam_module_ident.Hash.clear cached_tbl 




(* This is for a js exeternal module, we can change it when printing
   for example
   {[
     var React$1 = require('react');
     React$1.render(..)
   ]}

   Given a name, if duplicated, they should  have the same id
*)

let create_js_module (hint_name : string) : Ident.t = 
  let hint_name = 
    String.concat "" @@ Ext_list.map (Ext_string.capitalize_ascii ) @@ 
    Ext_string.split hint_name '-' in
  Ident.create hint_name

(** 
   Any [id] as long as put in the [cached_tbl] should be always valid,

   Since it is already used in the code gen, the older will have higher precedence
   So for freshly created id, we will test if it is already there not not 
   (using key *only* involves external module name), 

   If it is already there, we discard the freshly made one, 
   Otherwise, we add it into cache table, and use it 

*)
let add_js_module ?hint_name module_name : Ident.t 
  = 
  let id = 
    match hint_name with
    | Some (* _ *)  hint_name
      -> create_js_module hint_name
    | None -> create_js_module module_name 
  in
  let lam_module_ident = 
    Lam_module_ident.of_external id module_name in  
  match Lam_module_ident.Hash.find_key_opt cached_tbl lam_module_ident with   
  | None ->
    (* Ext_log.dwarn __LOC__ "HASH MISS %a@." Ext_pervasives.pp_any (lam_module_ident); *)
    Lam_module_ident.Hash.add 
      cached_tbl 
      lam_module_ident
      External;
    id
  | Some old_key ->
    (* Ext_log.dwarn __LOC__ *)
    (*   "HASH HIT %a@." Ext_pervasives.pp_any (old_key,lam_module_ident); *)
    old_key.id 




let add_cached_tbl = Lam_module_ident.Hash.add cached_tbl

let find_and_add_if_not_exist (id, pos) env ~not_found ~found =
  let oid  = Lam_module_ident.of_ml id in
  begin match Lam_module_ident.Hash.find_opt cached_tbl oid with 
    | None -> 
      let cmj_path, cmj_table = Js_cmj_load.find_cmj (id.name ^ Literals.suffix_cmj) in
      begin match
          Type_util.find_serializable_signatures_by_path
            ( id) env with 
      | None -> not_found id 
      | Some signature -> 
        add_cached_tbl oid (Visit {signatures = signature; 
                                   cmj_table ; cmj_path  } ) ;
        let name =  (Type_util.get_name signature pos ) in
        let arity, closed_lambda =        
          begin match String_map.find_opt name cmj_table.values with
            | Some {arity ; closed_lambda} -> arity, closed_lambda
            | None -> Js_cmj_format.single_na, None 
          end in
        found {id; 
               name ;
               signatures = signature ;
               arity ;
               closed_lambda = 
                 if Js_config.get_cross_module_inline () then
                   closed_lambda
                 else None
              }
      end
    | Some (Visit { signatures = serializable_sigs ; cmj_table = { values ; _} } ) -> 
      let name = (Type_util.get_name serializable_sigs pos ) in
      let arity , closed_lambda =  (
        match  String_map.find_opt name values with
        | Some {arity; closed_lambda;_} -> 
          arity, closed_lambda 
        | None -> Js_cmj_format.single_na, None
      ) in
      found { id;
              name; 
              signatures = serializable_sigs;
              arity;
              closed_lambda = 
                if Js_config.get_cross_module_inline () then
                  closed_lambda
                else None
                (* TODO shall we cache the arity ?*) 
            } 
    | Some (Runtime _) -> assert false
    | Some External  -> assert false
  end



(* TODO: it does not make sense to cache
   [Runtime] 
   and [externals]*)
type _ t = 
  | No_env :  (path * Js_cmj_format.t) t 
  | Has_env : Env.t  -> module_info t 


let query_and_add_if_not_exist (type u)
    (oid : Lam_module_ident.t) 
    (env : u t) ~not_found ~found:(found : u -> _) =
  match Lam_module_ident.Hash.find_opt cached_tbl oid with 
  | None -> 
    begin match oid.kind with
      | Runtime  -> 
        let (cmj_path, cmj_table) as cmj_info = 
          Js_cmj_load.find_cmj (Lam_module_ident.name oid ^ Literals.suffix_cmj) in           
        add_cached_tbl oid (Runtime (true,cmj_path,cmj_table)) ; 
        begin match env with 
          | Has_env _ -> 
            found {signature = []; pure = true}
          | No_env -> 
            found cmj_info
        end
      | Ml 
        -> 
        let (cmj_path, cmj_table) as cmj_info = 
          Js_cmj_load.find_cmj (Lam_module_ident.name oid ^ Literals.suffix_cmj) in           
        begin match env with 
          | Has_env env -> 
            begin match 
                Type_util.find_serializable_signatures_by_path ( oid.id) env with 
            | None -> not_found () (* actually when [not_found] in the call site, we throw... *)
            | Some signature -> 
              add_cached_tbl oid (Visit {signatures = signature; cmj_table;cmj_path }) ;
              found  { signature ; pure = cmj_table.effect = None} 
            end
          | No_env -> 
            found cmj_info
        end

      | External _  -> 
        add_cached_tbl oid External;
        (** This might be wrong, if we happen to expand  an js module
            we should assert false (but this in general should not happen)
        *)
        begin match env with 
          | Has_env _ 
            -> 
            found {signature = []; pure = false}
          | No_env -> 
            found (Ext_string.empty, Js_cmj_format.no_pure_dummy)
            (* FIXME: #154, it come from External, should be okay *)
        end

    end
  | Some (Visit {signatures  ; cmj_table =  cmj_table; cmj_path}) -> 
    begin match env with 
      | Has_env _ -> 
        found   { signature =  signatures  ; pure = (cmj_table.effect = None)} 
      | No_env  -> found (cmj_path,cmj_table)
    end

  | Some (Runtime (pure, cmj_path,cmj_table)) -> 
    begin match env with 
      | Has_env _ -> 
        found {signature = []  ; pure }
      | No_env -> 
        found (cmj_path, cmj_table) 
    end
  | Some External -> 
    begin match env with 
      | Has_env _ -> 
        found {signature = []  ; pure  = false}
      | No_env -> 
        found (Ext_string.empty, Js_cmj_format.no_pure_dummy) (* External is okay *)
    end

(* Conservative interface *)
let is_pure_module id  = 
  query_and_add_if_not_exist id No_env
    ~not_found:(fun _ -> false) 
    ~found:(fun (_,x) -> x.effect = None)



let get_package_path_from_cmj 
    ( id : Lam_module_ident.t) 
  : _ option = 
  query_and_add_if_not_exist id No_env
    ~not_found:(fun _ ->
      None
        (*
          So after querying, it should return 
           [Js_packages_info.Package_not_found]
        *)
        ) 
    ~found:(fun (cmj_path,x) -> 
        Some (cmj_path, 
        x.npm_package_path, x.case )
        )

    
let add = Lam_module_ident.Hash_set.add





let get_required_modules 
    extras 
    (hard_dependencies 
     : Lam_module_ident.Hash_set.t) : module_id list =  
  Lam_module_ident.Hash.iter (fun (id : module_id)  _  ->
      if not @@ is_pure_module id 
      then add  hard_dependencies id) cached_tbl ;
  Lam_module_ident.Hash_set.iter (fun (id  : module_id)  -> 
      (if not @@ is_pure_module  id 
       then add hard_dependencies id : unit)
    ) extras;
  Lam_module_ident.Hash_set.elements hard_dependencies

end
module Ext_char : sig 
#1 "ext_char.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






(** Extension to Standard char module, avoid locale sensitivity *)

val escaped : char -> string


val valid_hex : char -> bool

val is_lower_case : char -> bool
end = struct
#1 "ext_char.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)







external string_unsafe_set : string -> int -> char -> unit
                           = "%string_unsafe_set"

external string_create: int -> string = "caml_create_string"

external unsafe_chr: int -> char = "%identity"

(** {!Char.escaped} is locale sensitive in 4.02.3, fixed in the trunk,
    backport it here
 *)
let escaped = function
  | '\'' -> "\\'"
  | '\\' -> "\\\\"
  | '\n' -> "\\n"
  | '\t' -> "\\t"
  | '\r' -> "\\r"
  | '\b' -> "\\b"
  | ' ' .. '~' as c ->
      let s = string_create 1 in
      string_unsafe_set s 0 c;
      s
  | c ->
      let n = Char.code c in
      let s = string_create 4 in
      string_unsafe_set s 0 '\\';
      string_unsafe_set s 1 (unsafe_chr (48 + n / 100));
      string_unsafe_set s 2 (unsafe_chr (48 + (n / 10) mod 10));
      string_unsafe_set s 3 (unsafe_chr (48 + n mod 10));
      s


let valid_hex x = 
    match x with 
    | '0' .. '9'
    | 'a' .. 'f'
    | 'A' .. 'F' -> true
    | _ -> false 



let is_lower_case c =
  (c >= 'a' && c <= 'z')
  || (c >= '\224' && c <= '\246')
  || (c >= '\248' && c <= '\254')    
end
module Ext_pp : sig 
#1 "ext_pp.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** A simple pretty printer
    
    Advantage compared with [Format], 
    [P.newline] does not screw the layout, have better control when do a newline (sicne JS has ASI)
    Easy to tweak

    {ul 
    {- be a little smarter}
    {- buffer the last line, so that  we can do a smart newline, when it's really safe to do so}
    }
*)
type t

val indent_length : int 

val string : t -> string -> unit

val space :  t -> unit

val nspace : t -> int ->  unit

val group : t -> int -> (unit -> 'a) -> 'a
(** [group] will record current indentation 
    and indent futher
 *)

val vgroup : t -> int -> (unit -> 'a) -> 'a

val paren : t -> (unit -> 'a) -> 'a

val brace : t -> (unit -> 'a) -> 'a

val paren_group : t -> int -> (unit -> 'a) -> 'a

val paren_vgroup : t -> int -> (unit -> 'a) -> 'a

val brace_group : t -> int -> (unit -> 'a) -> 'a

val brace_vgroup : t -> int -> (unit -> 'a) -> 'a

val bracket_group : t -> int -> (unit -> 'a) -> 'a

val bracket_vgroup : t -> int -> (unit -> 'a) -> 'a

val newline : t -> unit

val force_newline : t -> unit
(** [force_newline] Always print a newline *)

val from_channel : out_channel -> t

val from_buffer : Buffer.t -> t

val flush : t -> unit -> unit

end = struct
#1 "ext_pp.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








module L = struct 
  let space = " "
  let indent_str = "  "
end

let indent_length = String.length L.indent_str 

type t = {
  output_string : string -> unit;
  output_char : char -> unit; 
  flush : unit -> unit;
  mutable indent_level : int;
  mutable last_new_line : bool; 
  (* only when we print newline, we print the indent *)
}

let from_channel chan = { 
  output_string = (fun  s -> output_string chan s); 
  output_char = (fun c -> output_char chan c);
  flush = (fun _ -> flush chan);
  indent_level = 0 ;
  last_new_line = false;
}


let from_buffer buf = {
  output_string = (fun s -> Buffer.add_string buf s);
  output_char = (fun  c -> Buffer.add_char buf c);
  flush = (fun _ -> ());
  indent_level = 0;
  last_new_line = false;
}

(* If we have [newline] in [s], 
   all indentations will be broken 
   in the future, we can detect this in [s]
*)
let string t s = 
  t.output_string  s ;
  t.last_new_line <- false

let newline t = 
  if not t.last_new_line then 
    begin
      t.output_char  '\n';
      for i = 0 to t.indent_level - 1 do 
        t.output_string  L.indent_str;
      done;
      t.last_new_line <- true
    end

let force_newline t = 
  t.output_char  '\n';
  for i = 0 to t.indent_level - 1 do 
    t.output_string  L.indent_str;
  done

let space t  = 
  string t L.space

let nspace  t n  = 
  string  t (String.make n ' ')

let group t i action = 
  if i = 0 then action ()
  else 
    let old = t.indent_level in
    t.indent_level <- t.indent_level + i;
    Ext_pervasives.finally () (fun _ -> t.indent_level <- old) action 

let vgroup = group

let paren t action = 
  string t "(";
  let v = action () in
  string t ")";
  v 

let brace fmt u = 
  string fmt "{";
  (* break1 fmt ; *)
  let v = u () in
  string fmt "}";
  v 

let bracket fmt u = 
  string fmt "[";
  let v = u () in
  string fmt "]";
  v 

let brace_vgroup st n action = 
  string st "{";
  let v = vgroup st n (fun _ -> 
      newline st; 
      let v =  action () in
      v
    ) in
  force_newline st;
  string st "}";
  v

let bracket_vgroup st n action = 
  string st "[";
  let v = vgroup st n (fun _ -> 
      newline st; 
      let v =  action () in
      v
    ) in
  force_newline st;
  string st "]";
  v

let bracket_group st n action = 
  group st n (fun _ -> bracket st action)

let paren_vgroup st n action = 
  string st "(";
  let v = group st n (fun _ -> 
      newline st; 
      let v = action () in
      v
    ) in
  newline st;
  string st ")";
  v 
let paren_group st n action = group st n (fun _ -> paren st action)

let brace_group st n action = 
  group st n (fun _ -> brace st action )

let indent t n = 
  t.indent_level <- t.indent_level + n 

let flush t () = t.flush ()

end
module Int_map : sig 
#1 "int_map.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








include Map_gen.S with type key = int

end = struct
#1 "int_map.ml"

# 2 "ext/map.cppo.ml"
(* we don't create [map_poly], since some operations require raise an exception which carries [key] *)


  
# 13
  type key = int
  let compare_key = Ext_int.compare

# 22
type 'a t = (key,'a) Map_gen.t
exception Duplicate_key of key 

let empty = Map_gen.empty 
let is_empty = Map_gen.is_empty
let iter = Map_gen.iter
let fold = Map_gen.fold
let for_all = Map_gen.for_all 
let exists = Map_gen.exists 
let singleton = Map_gen.singleton 
let cardinal = Map_gen.cardinal
let bindings = Map_gen.bindings
let keys = Map_gen.keys
let choose = Map_gen.choose 
let partition = Map_gen.partition 
let filter = Map_gen.filter 
let map = Map_gen.map 
let mapi = Map_gen.mapi
let bal = Map_gen.bal 
let height = Map_gen.height 
let max_binding_exn = Map_gen.max_binding_exn
let min_binding_exn = Map_gen.min_binding_exn


let rec add x data (tree : _ Map_gen.t as 'a) : 'a = match tree with 
  | Empty ->
    Node(Empty, x, data, Empty, 1)
  | Node(l, v, d, r, h) ->
    let c = compare_key x v in
    if c = 0 then
      Node(l, x, data, r, h)
    else if c < 0 then
      bal (add x data l) v d r
    else
      bal l v d (add x data r)


let rec adjust x data replace (tree : _ Map_gen.t as 'a) : 'a = 
  match tree with 
  | Empty ->
    Node(Empty, x, data (), Empty, 1)
  | Node(l, v, d, r, h) ->
    let c = compare_key x v in
    if c = 0 then
      Node(l, x, replace  d , r, h)
    else if c < 0 then
      bal (adjust x data replace l) v d r
    else
      bal l v d (adjust x data replace r)


let rec find_exn x (tree : _ Map_gen.t )  = match tree with 
  | Empty ->
    raise Not_found
  | Node(l, v, d, r, _) ->
    let c = compare_key x v in
    if c = 0 then d
    else find_exn x (if c < 0 then l else r)

let rec find_opt x (tree : _ Map_gen.t )  = match tree with 
  | Empty -> None 
  | Node(l, v, d, r, _) ->
    let c = compare_key x v in
    if c = 0 then Some d
    else find_opt x (if c < 0 then l else r)

let rec find_default x (tree : _ Map_gen.t ) default     = match tree with 
  | Empty -> default  
  | Node(l, v, d, r, _) ->
    let c = compare_key x v in
    if c = 0 then  d
    else find_default x   (if c < 0 then l else r) default

let rec mem x (tree : _ Map_gen.t )   = match tree with 
  | Empty ->
    false
  | Node(l, v, d, r, _) ->
    let c = compare_key x v in
    c = 0 || mem x (if c < 0 then l else r)

let rec remove x (tree : _ Map_gen.t as 'a) : 'a = match tree with 
  | Empty ->
    Empty
  | Node(l, v, d, r, h) ->
    let c = compare_key x v in
    if c = 0 then
      Map_gen.merge l r
    else if c < 0 then
      bal (remove x l) v d r
    else
      bal l v d (remove x r)


let rec split x (tree : _ Map_gen.t as 'a) : 'a * _ option * 'a  = match tree with 
  | Empty ->
    (Empty, None, Empty)
  | Node(l, v, d, r, _) ->
    let c = compare_key x v in
    if c = 0 then (l, Some d, r)
    else if c < 0 then
      let (ll, pres, rl) = split x l in (ll, pres, Map_gen.join rl v d r)
    else
      let (lr, pres, rr) = split x r in (Map_gen.join l v d lr, pres, rr)

let rec merge f (s1 : _ Map_gen.t) (s2  : _ Map_gen.t) : _ Map_gen.t =
  match (s1, s2) with
  | (Empty, Empty) -> Empty
  | (Node (l1, v1, d1, r1, h1), _) when h1 >= height s2 ->
    let (l2, d2, r2) = split v1 s2 in
    Map_gen.concat_or_join (merge f l1 l2) v1 (f v1 (Some d1) d2) (merge f r1 r2)
  | (_, Node (l2, v2, d2, r2, h2)) ->
    let (l1, d1, r1) = split v2 s1 in
    Map_gen.concat_or_join (merge f l1 l2) v2 (f v2 d1 (Some d2)) (merge f r1 r2)
  | _ ->
    assert false

let rec disjoint_merge  (s1 : _ Map_gen.t) (s2  : _ Map_gen.t) : _ Map_gen.t =
  match (s1, s2) with
  | (Empty, Empty) -> Empty
  | (Node (l1, v1, d1, r1, h1), _) when h1 >= height s2 ->
    begin match split v1 s2 with 
    | l2, None, r2 -> 
      Map_gen.join (disjoint_merge  l1 l2) v1 d1 (disjoint_merge r1 r2)
    | _, Some _, _ ->
      raise (Duplicate_key  v1)
    end        
  | (_, Node (l2, v2, d2, r2, h2)) ->
    begin match  split v2 s1 with 
    | (l1, None, r1) -> 
      Map_gen.join (disjoint_merge  l1 l2) v2 d2 (disjoint_merge  r1 r2)
    | (_, Some _, _) -> 
      raise (Duplicate_key v2)
    end
  | _ ->
    assert false



let compare cmp m1 m2 = Map_gen.compare compare_key cmp m1 m2

let equal cmp m1 m2 = Map_gen.equal compare_key cmp m1 m2 

let add_list (xs : _ list ) init = 
  List.fold_left (fun acc (k,v) -> add k v acc) init xs 

let of_list xs = add_list xs empty

let of_array xs = 
  Array.fold_left (fun acc (k,v) -> add k v acc) empty xs

end
module Ext_pp_scope : sig 
#1 "ext_pp_scope.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Scope type to improve identifier name printing
    Defines scope type [t], so that the pretty printer would 
    print more beautiful code:     
    print [identifer] instead of [identifier$1234] 
    when it can
 *)

type t 

val empty : t 

val print : Format.formatter -> t -> unit

val sub_scope : t -> Ident_set.t -> t

val merge : Ident_set.t -> t -> t



val str_of_ident : t -> Ident.t -> string * t 

val ident : t -> Ext_pp.t -> Ident.t -> t 
end = struct
#1 "ext_pp_scope.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








type t =  
  int  Int_map.t String_map.t
(**
   -- "name" --> int map -- stamp --> index suffix
*)
let empty = 
  String_map.empty 

let rec print fmt v = 
  Format.fprintf fmt "@[<v>{"  ;
  String_map.iter (fun k m -> 
      Format.fprintf fmt "%s: @[%a@],@ " k print_int_map m       
    )  v;
  Format.fprintf fmt "}@]"  
and print_int_map fmt m = 
  Int_map.iter (fun k v -> 
      Format.fprintf fmt "%d - %d" k v       
    ) m    

let add_ident ~mangled:name stamp (cxt : t) : int * t = 
  match String_map.find_opt name cxt with 
  | None -> 
    (0, String_map.add name (Int_map.add stamp 0  Int_map.empty) cxt )
  | Some imap -> (
      match Int_map.find_opt stamp imap with
      | None -> 
        let v = Int_map.cardinal imap in
        v, String_map.add name (Int_map.add stamp v imap) cxt
      | Some i -> i, cxt
    )





(**
   same as {!Js_dump.ident} except it generates a string instead of doing the printing
   For fast/debug mode, we can generate the name as 
       [Printf.sprintf "%s$%d" name id.stamp] which is 
       not relevant to the context       

   Attention: 
   - $$Array.length, due to the fact that global module is 
       always printed in the begining(via imports), so you get a gurantee, 
       (global modules will not be printed as [List$1]) 

       However, this means we loose the ability of dynamic loading, is it a big 
       deal? we can fix this by a scanning first, since we already know which 
       modules are global

       check [test/test_global_print.ml] for regression
   - collision
      It is obvious that for the same identifier that they 
      print the same name.
      
      It also needs to be hold that for two different identifiers,  
      they print different names:
      - This happens when they escape to the same name and 
        share the  same stamp
      So the key has to be mangled name  + stamp
      otherwise, if two identifier happens to have same mangled name,
      if we use the original name as key, they can have same id (like 0).
      then it caused a collision
      
      Here we can guarantee that if mangled name and stamp are not all the same
      they can not have a collision

*)
let str_of_ident (cxt : t) (id : Ident.t)  : string * t  =
  if Ext_ident.is_js id then 
    (* reserved by compiler *)
    id.name , cxt
  else 
    let id_name = id.name in
    let name = Ext_ident.convert id_name in
    let i,new_cxt = add_ident  ~mangled:name id.stamp cxt in
    (if i == 0 then 
       name 
     else
       Printf.sprintf "%s$%d" name i), new_cxt 

let ident (cxt : t) f (id : Ident.t) : t  =
  let str, cxt = str_of_ident cxt id in
  Ext_pp.string f str; 
  cxt   


let merge set cxt  = 
  Ident_set.fold (fun ident acc -> 
      snd (add_ident ~mangled:(Ext_ident.convert ident.name) ident.stamp acc)) set  cxt 

(* Assume that all idents are already in [scope]
   so both [param/0] and [param/1] are in idents, we don't need 
   update twice,  once is enough
*)
let sub_scope (scope : t) (idents : Ident_set.t) : t =
  Ident_set.fold (fun ({name } : Ident.t) (acc : t) -> 
      let mangled = Ext_ident.convert name in 
      match String_map.find_exn mangled scope with 
      | exception Not_found -> assert false 
      | imap -> 
          if String_map.mem mangled acc then acc 
          else String_map.add mangled imap acc
    ) idents empty


end
module Js_dump_lit
= struct
#1 "js_dump_lit.ml"
(* Copyright (C) 2017 Authors of BuckleScript
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

let function_ = "function"
let var = "var" (* should be able to switch to [let] easily*)
let return = "return"
let eq = "="
let require = "require"
let import = "import"
let from = "from"
let as_ = "as"
let export = "export"
let star = "*"
let lparen = "("
let rparen = ")"
let exports = "exports"
let dot = "."
let comma = ","
let colon = Ext_string.single_colon
let throw = "throw"
let default = "default"
let length = "length"
let char_code_at = "charCodeAt"
let new_ = "new"
let array = "Array"
let question = "?"      
let plusplus = "++"
let minusminus = "--"
let semi = ";"
let else_ = "else"
let if_ = "if"
let this = "this"
let while_ = "while"
let empty_block = "empty_block"
let start_block = "start_block"
let end_block = "end_block"
let json = "JSON"
let stringify = "stringify"
let console = "console"
let define = "define"
let break = "break"
let continue = "continue"
let switch = "switch"
let strict_directive = "'use strict';"
let true_ = "true"
let false_ = "false"
let app = Literals.app (* curry arbitrary args *)
let app_array = Literals.app_array
let debugger = "debugger"
let tag = "tag"
let bind = "bind"
let math = "Math"
let apply = "apply"
let null = "null"
let string_cap = "String"
let fromCharcode = "fromCharCode"
let eq = "="
let le = "<="
let ge = ">="
let plus_plus = "++" 
(*  FIXME: use (i = i + 1 | 0) instead  *)
let minus_minus = "--"
let caml_block = "Block"
let caml_block_create = "__"
let case = "case" 
end
module Js_dump_string : sig 
#1 "js_dump_string.mli"
(* Copyright (C) 2017 Authors of BuckleScript
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


 val pp_string : 
  Ext_pp.t -> 
  string -> 
  unit
end = struct
#1 "js_dump_string.ml"
(* Copyright (C) 2017 Authors of BuckleScript
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

module P = Ext_pp

(** Avoid to allocate single char string too many times*)
let array_str1 =
  Array.init 256 (fun i -> String.make 1 (Char.chr i)) 

(** For conveting 

*)
let array_conv =
  [|"0"; "1"; "2"; "3"; "4"; "5"; "6"; "7"; "8"; "9"; "a"; "b"; "c"; "d";
    "e"; "f"|]

 (* https://mathiasbynens.be/notes/javascript-escapes *)

 let pp_string f  (* ?(utf=false)*) s =
  let pp_raw_string f (* ?(utf=false)*) s = 
    let l = String.length s in
    for i = 0 to l - 1 do
      let c = String.unsafe_get s i in
      match c with
      | '\b' -> P.string f "\\b"
      | '\012' -> P.string f "\\f"
      | '\n' -> P.string f "\\n"
      | '\r' -> P.string f "\\r"
      | '\t' -> P.string f "\\t"
      (* This escape sequence is not supported by IE < 9
               | '\011' -> "\\v"
         IE < 9 treats '\v' as 'v' instead of a vertical tab ('\x0B'). 
         If cross-browser compatibility is a concern, use \x0B instead of \v.

         Another thing to note is that the \v and \0 escapes are not allowed in JSON strings.
      *)
      | '\000' when i = l - 1 || (let next = String.unsafe_get s (i + 1) in (next < '0' || next > '9'))
        -> P.string f "\\0"

      | '\\' (* when not utf*) -> P.string f "\\\\"


      | '\000' .. '\031'  | '\127'->
        let c = Char.code c in
        P.string f "\\x";
        P.string f (Array.unsafe_get array_conv (c lsr 4));
        P.string f (Array.unsafe_get array_conv (c land 0xf))
      | '\128' .. '\255' (* when not utf*) ->
        let c = Char.code c in
        P.string f "\\x";
        P.string f (Array.unsafe_get array_conv (c lsr 4));
        P.string f (Array.unsafe_get array_conv (c land 0xf))
      | '\"' -> P.string f "\\\"" (* quote*)
      | _ ->
        P.string f (Array.unsafe_get array_str1 (Char.code c))
    done
  in
  P.string f "\"";
  pp_raw_string f (*~utf*) s ;
  P.string f "\""
;;


(* let _best_string_quote s =
  let simple = ref 0 in
  let double = ref 0 in
  for i = 0 to String.length s - 1 do
    match s.[i] with
    | '\'' -> incr simple
    | '"' -> incr double
    | _ -> ()
  done;
  if !simple < !double
  then '\''
  else '"' *)

end
module Js_dump_import_export : sig 
#1 "js_dump_import_export.mli"
(* Copyright (C) 2017 Authors of BuckleScript
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)



val exports : 
  Ext_pp_scope.t -> Ext_pp.t -> Ident.t list -> Ext_pp_scope.t

val es6_export :   
  Ext_pp_scope.t -> Ext_pp.t -> Ident.t list -> Ext_pp_scope.t

val requires :  
  string -> Ext_pp_scope.t ->
  Ext_pp.t -> (Ident.t * string) list -> 
  Ext_pp_scope.t 

val imports : 
  Ext_pp_scope.t -> 
  Ext_pp.t -> 
  (Ident.t * string) list -> 
  Ext_pp_scope.t
end = struct
#1 "js_dump_import_export.ml"
(* Copyright (C) 2017 Authors of BuckleScript
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

module P = Ext_pp
module L = Js_dump_lit
let default_export = "default"
let esModule  = "__esModule", "true"
(** Exports printer *)
(** Print exports in Google module format, CommonJS format *)
let exports cxt f (idents : Ident.t list) = 
  let outer_cxt, reversed_list, margin = 
    List.fold_left (fun (cxt, acc, len ) (id : Ident.t) -> 
        let id_name = id.name in 
        let s = Ext_ident.convert id_name in        
        let str,cxt  = Ext_pp_scope.str_of_ident cxt id in         
        cxt, ( 
          if id_name = default_export then 
            (* TODO check how it will affect AMDJS*)
            esModule :: (default_export, str) :: (s,str)::acc 
          else (s,str) :: acc ) , max len (String.length s)   )
      (cxt, [], 0)  idents in    
  P.newline f ;
  Ext_list.rev_iter (fun (s,export) -> 
      P.group f 0 @@ (fun _ ->  
          P.string f L.exports;
          P.string f L.dot;
          P.string f s; 
          P.nspace f (margin - String.length s +  1) ;
          P.string f L.eq;
          P.space f;
          P.string f export;          
          P.string f L.semi;);
      P.newline f;
    ) reversed_list;
  outer_cxt  


(** Print module in ES6 format, it is ES6, trailing comma is valid ES6 code *)
let es6_export cxt f (idents : Ident.t list) = 
  let outer_cxt, reversed_list, margin = 
    List.fold_left (fun (cxt, acc, len ) (id : Ident.t) -> 
        let id_name = id.name in 
        let s = Ext_ident.convert id_name in        
        let str,cxt  = Ext_pp_scope.str_of_ident cxt id in         
        cxt, ( 
          if id_name = default_export then 
            (default_export,str)::(s,str)::acc
          else 
            (s,str) :: acc ) , max len (String.length s)   )
      (cxt, [], 0)  idents in    
  P.newline f ;
  P.string f L.export ; 
  P.space f ; 
  P.brace_vgroup f 1 begin fun _ -> 
    Ext_list.rev_iter (fun (s,export) -> 
        P.group f 0 @@ (fun _ ->  
            P.string f export;          
            P.nspace f (margin - String.length s +  1) ;
            if not @@ Ext_string.equal export s then begin 
              P.string f L.as_ ;
              P.space f;
              P.string f s
            end ;             
            P.string f L.comma ;);
        P.newline f;
      ) reversed_list;
  end;
  outer_cxt  
  

(** Node or Google module style imports *)
let requires require_lit cxt f (modules : (Ident.t * string) list ) =
  P.newline f ; 
  (* the context used to print the following program *)  
  let outer_cxt, reversed_list, margin  =
    List.fold_left
      (fun (cxt, acc, len) (id,s) ->
         let str, cxt = Ext_pp_scope.str_of_ident cxt id  in
         cxt, ((str,s) :: acc), (max len (String.length str))
      )
      (cxt, [], 0)  modules in
  P.force_newline f ;    
  Ext_list.rev_iter (fun (s,file) ->
      P.string f L.var;
      P.space f ;
      P.string f s ;
      P.nspace f (margin - String.length s + 1) ;
      P.string f L.eq;
      P.space f;
      P.string f require_lit;
      P.paren_group f 0 @@ (fun _ ->
          Js_dump_string.pp_string f file  );
      P.string f L.semi;
      P.newline f ;
    ) reversed_list;
  outer_cxt  

(** ES6 module style imports *)
let imports  cxt f (modules : (Ident.t * string) list ) =
  P.newline f ; 
  (* the context used to print the following program *)  
  let outer_cxt, reversed_list, margin  =
    List.fold_left
      (fun (cxt, acc, len) (id,s) ->
         let str, cxt = Ext_pp_scope.str_of_ident cxt id  in
         cxt, ((str,s) :: acc), (max len (String.length str))
      )
      (cxt, [], 0)  modules in
  P.force_newline f ;    
  Ext_list.rev_iter (fun (s,file) ->

      P.string f L.import;
      P.space f ;
      P.string f L.star ;
      P.space f ; (* import * as xx \t from 'xx*) 
      P.string f L.as_ ; 
      P.space f ; 
      P.string f s ; 
      P.nspace f (margin - String.length s + 1) ;      
      P.string f L.from;
      P.space f;
      Js_dump_string.pp_string f file ;
      P.string f L.semi ;
      P.newline f ;
    ) reversed_list;
  outer_cxt

  
end
module Js_dump_property : sig 
#1 "js_dump_property.mli"
(* Copyright (C) 2017 Authors of BuckleScript
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


val property_access : 
  Ext_pp.t ->
  string -> 
  unit 


val property_key : 
  Ext_pp.t -> 
  string -> 
  unit 
end = struct
#1 "js_dump_property.ml"
(* Copyright (C) 2017 Authors of BuckleScript
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


module P = Ext_pp
module L = Js_dump_lit 

(**
   https://stackoverflow.com/questions/9367572/rules-for-unquoted-javascript-object-literal-keys
   https://mathiasbynens.be/notes/javascript-properties
   https://mathiasbynens.be/notes/javascript-identifiers

   Let's not do smart things
   {[
     { 003 : 1} 
   ]}
   becomes 
   {[
     { 3 : 1}
   ]}
*)

let obj_property_no_need_quot s = 
  let len = String.length s in 
  if len > 0 then 
    match String.unsafe_get s 0 with 
    | '$' | '_'
    | 'a'..'z'| 'A' .. 'Z' ->
      Ext_string.for_all_range
        ~start:1 ~finish:(len - 1) s
        (function 
          | 'a'..'z'|'A'..'Z'
          | '$' | '_' 
          | '0' .. '9' -> true
          | _ -> false)

    | _ -> false
  else 
    false 
(** used in printing keys 
    {[
      {"x" : x};;
      {x : x }
        {"50x" : 2 } GPR #1943
]}
    Note we can not treat it in the same way when printing
    [x.id] vs [{id : xx}]
    for example, id can be number in object literal
*)

(** used in property access 
    {[
      f.x ;;
      f["x"];;
    ]}
*)
let property_access f s = 
  if obj_property_no_need_quot s then 
    begin 
      P.string f L.dot;
      P.string f s; 
    end
  else
    begin 
      P.bracket_group f 1 @@ fun _ ->
      Js_dump_string.pp_string f s
    end

let property_key f s =     
  if obj_property_no_need_quot s then 
    P.string f s 
  else Js_dump_string.pp_string f s  
end
module Js_number : sig 
#1 "js_number.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)







type t  = float 


val to_string : t -> string


val caml_float_literal_to_js_string : string -> string

end = struct
#1 "js_number.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






type t = float 


(* http://www.ecma-international.org/ecma-262/5.1/#sec-7.8.3 
   http://caml.inria.fr/pub/docs/manual-ocaml/lex.html
   {[
     float-literal ::= [-](0...9){0...9|_}[.{0...9|_}][(e|E)][(e|E)[+|-](0...9){0...9|_}]     
   ]}   
   In ocaml, the interpretation of floating-point literals that
   fall outside the range of representable floating-point values is undefined.
   Also, (_) are accepted   

   see https://github.com/ocaml/ocaml/pull/268 that ocaml will have HEXADECIMAL notation 
   support in 4.3

   The Hex part is quite different   
 *)



let to_string v =
  if v = infinity
  then "Infinity"
  else if v = neg_infinity
  then "-Infinity"
  else if v <> v
  then "NaN"
  else
    let vint = (int_of_float v)
    (* TODO: check if 32-bits will loose some precision *)               
    in
    if float_of_int  vint = v
    then
      string_of_int vint
    else
      let s1 = Printf.sprintf "%.12g" v in
      if v = float_of_string s1
      then s1
      else
        let s2 = Printf.sprintf "%.15g" v in
        if v = float_of_string s2
        then s2
        else  Printf.sprintf "%.18g" v



let caml_float_literal_to_js_string v = 
  let len = String.length v in
  if len >= 2 && 
    v.[0] = '0' &&
    (v.[1] = 'x' || v.[1] = 'X') then  
    assert false 
   (* TODO: catchup when upgraded to 4.3 
      it does not make sense too much since js dos not 
      support it natively
    *)    
  else    

    let rec aux buf i = 
      if i >= len then buf
      else 
        let x = v.[i] in
        if x = '_' then
          aux buf (i + 1)
        else if   x  = '.' && i = len - 1  then
          buf
        else 
          begin
            Buffer.add_char buf x ;
            aux buf ( i + 1) 
          end in
    Buffer.contents (aux  (Buffer.create len) 0)


end
module Js_dump : sig 
#1 "js_dump.mli"
(* BuckleScript compiler
 * Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * http://www.ocsigen.org/js_of_ocaml/
 * Copyright (C) 2010 Jrme Vouillon
 * Laboratoire PPS - CNRS Universit Paris Diderot
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, with linking exception;
 * either version 2.1 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
*)
(* Authors: Jrme Vouillon, Hongbo Zhang  *)



(** Print JS IR to vanilla Javascript code *)


val statement_list : 
  bool ->
  Ext_pp_scope.t -> 
  Ext_pp.t -> 
  J.block -> 
  Ext_pp_scope.t


(** 2 functions Only used for debugging *)
val string_of_block : J.block -> string

val string_of_expression : J.expression -> string

end = struct
#1 "js_dump.ml"
(* BuckleScript compiler
 * Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * http://www.ocsigen.org/js_of_ocaml/
 * Copyright (C) 2010 Jrme Vouillon
 * Laboratoire PPS - CNRS Universit Paris Diderot
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, with linking exception;
 * either version 2.1 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
*)
(* Authors: Jrme Vouillon, Hongbo Zhang  *)

(*
  http://stackoverflow.com/questions/2846283/what-are-the-rules-for-javascripts-automatic-semicolon-insertion-asi
  ASI catch up
   {[
     a=b
       ++c
       ---
       a=b ++c
     ====================
     a ++
     ---
     a 
     ++
     ====================
     a --
     ---
     a 
     --
     ====================
     (continue/break/return/throw) a
     ---
     (continue/break/return/throw)
       a
     ====================
   ]}

*)


module P = Ext_pp
module E = Js_exp_make 
module S = Js_stmt_make 

module L = Js_dump_lit
let return_indent = (String.length L.return / Ext_pp.indent_length) 

let throw_indent = (String.length L.throw / Ext_pp.indent_length) 


let semi f = P.string f L.semi

let op_prec, op_str  =
  Js_op_util.(op_prec, op_str)


let rec comma_idents  cxt f (ls : Ident.t list)  =
  match ls with
  | [] -> cxt
  | [x] -> Ext_pp_scope.ident cxt f x
  | y :: ys ->
    let cxt = Ext_pp_scope.ident cxt f y in
    P.string f L.comma;
    comma_idents cxt f ys  
let ipp_ident cxt f id un_used = 
  if un_used then 
    Ext_pp_scope.ident cxt f (Ext_ident.make_unused ())
  else 
    Ext_pp_scope.ident cxt f id  
let rec formal_parameter_list cxt (f : P.t) method_ l env =
  let offset = if method_ then 1 else 0 in   
  let rec aux i cxt l = 
    match l with
    | []     -> cxt
    | [id]    -> ipp_ident cxt f id (Js_fun_env.get_unused env i)
    | id :: r -> 
      let cxt = ipp_ident cxt f id (Js_fun_env.get_unused env i) in
      P.string f L.comma; P.space f;
      aux (i + 1) cxt  r
  in
  match l with 
  | [] -> cxt 
  | [i] -> 
    (** necessary, since some js libraries like [mocha]...*)
    if Js_fun_env.get_unused env offset then cxt 
    else
      Ext_pp_scope.ident cxt f i 
  | _ -> 
    aux offset cxt l  


(* IdentMap *)
(*
f/122 --> 
  f/122 is in the map 
  if in, use the old mapping
  else 
    check  f,
     if in last bumped id
     else 
        use "f", register it 

  check "f"       
         if not , use "f", register stamp -> 0 
         else 
           check stamp 
             if in  use it 
             else check last bumped id, increase it and register
*)
type name =
  | No_name
  | Name_top  of Ident.t
  | Name_non_top of Ident.t


(**
   Turn [function f (x,y) { return a (x,y)} ] into [Curry.__2(a)],
   The idea is that [Curry.__2] will guess the arity of [a], if it does 
   hit, then there is no cost when passed
*)


(* TODO: refactoring 
   Note that {!pp_function} could print both statement and expression when [No_name] is given 
*)
let rec

  try_optimize_curry cxt f len function_id = 
  begin           
    P.string f Js_runtime_modules.curry;
    P.string f L.dot;
    P.string f "__";
    P.string f (Printf.sprintf "%d" len);
    P.paren_group f 1 (fun _ -> expression 1 cxt f function_id  )             
  end              

and  pp_function method_
    cxt (f : P.t) ?(name=No_name)  return 
    (l : Ident.t list) (b : J.block) (env : Js_fun_env.t ) =  
  match b, (name,  return)  with 
  | [ {statement_desc =
         Return {return_value = 
                   {expression_desc = 
                      Call(({expression_desc = Var v ; _} as function_id), 
                           ls , 
                           {arity = ( Full | NA as arity(* see #234*)); 
                            (* TODO: need a case to justify it*)
                            call_info = 
                              (Call_builtin_runtime | Call_ml )})}}}],
    ((_, false) | (No_name, true))  
    when 
      (* match such case: 
         {[ function(x,y){ return u(x,y) } ]}
         it can be optimized in to either [u] or [Curry.__n(u)]
      *)
      not method_ && 
      Ext_list.for_all2_no_exn (fun a (b : J.expression) -> 
          match b.expression_desc with 
          | Var (Id i) -> Ident.same a i 
          | _ -> false) l ls ->
    let optimize  len p cxt f v =
      if p then try_optimize_curry cxt f len function_id      
      else
        vident cxt f v
    in
    let len = List.length l in (* length *)           
    begin match name with 
      | Name_top i | Name_non_top i  -> 
        P.string f L.var; 
        P.space f ; 
        let cxt = Ext_pp_scope.ident cxt f i in
        P.space f ;
        P.string f L.eq;
        P.space f ;
        let cxt = optimize len (arity = NA && len <= 8) cxt f v in 
        semi f ;
        cxt
      | No_name ->
        if return then 
          begin 
            P.string f L.return ;
            P.space f
          end;
        optimize len (arity = NA && len <=8) cxt f v 

    end
  | _, _  -> 

    let set_env : Ident_set.t = (** identifiers will be printed following*)
      match name with 
      | No_name ->
        Js_fun_env.get_unbounded env 
      | Name_top id | Name_non_top id -> Ident_set.add id (Js_fun_env.get_unbounded env )
    in
    (* the context will be continued after this function *)
    let outer_cxt = Ext_pp_scope.merge set_env cxt in  

    (* the context used to be printed inside this function

       when printing a function, 
       only the enclosed variables and function name matters, 
       if the function does not capture any variable, then the context is empty     
    *)
    let inner_cxt = Ext_pp_scope.sub_scope outer_cxt set_env in


    (* (if not @@ Js_fun_env.is_empty env then *)
    (* pp_comment  f (Some (Js_fun_env.to_string env))) ; *)
    let param_body () = 
      if method_ then begin
        let cxt = P.paren_group f 1 (fun _ -> 
            formal_parameter_list inner_cxt  f method_ (List.tl l) env )
        in
        P.space f ;
        ignore @@ P.brace_vgroup f 1 (fun _ ->
            let cxt =
              if not (Js_fun_env.get_unused env 0) then
                begin               
                  P.string f L.var ; 
                  P.space f; 
                  let cxt = Ext_pp_scope.ident cxt f (List.hd l) in 
                  P.space f ; 
                  P.string f L.eq ; 
                  P.space f ;
                  P.string f L.this;
                  P.space f ; 
                  semi f ;
                  P.newline f ;
                  cxt ;                
                end
              else
                cxt
            in
            statement_list false cxt f b 
          );

      end
      else begin  
        let cxt = P.paren_group f 1 (fun _ -> 
            formal_parameter_list inner_cxt  f method_ l env )
        in
        P.space f ;
        ignore @@ P.brace_vgroup f 1 (fun _ -> statement_list false cxt f b );
      end
    in
    let lexical : Ident_set.t = Js_fun_env.get_lexical_scope env in
    let enclose  lexical  return = 
      let handle lexical = 
        if  Ident_set.is_empty lexical  
        then
          begin 
            if return then 
              begin 
                P.string f L.return ;
                P.space f
              end ;

            begin match name with 
              | No_name -> 
                (* see # 1692, add a paren for annoymous function for safety  *)
                P.paren_group f 1 begin fun _ -> 
                  P.string f L.function_;
                  P.space f ;
                  param_body ()
                end
              | Name_non_top x  -> 
                P.string f L.var ;
                P.space f ; 
                ignore @@ Ext_pp_scope.ident inner_cxt f x ; 
                P.space f ;
                P.string f L.eq ;
                P.space f ; 
                P.string f L.function_;
                P.space f ;
                param_body ();
                semi f ;
              | Name_top x  -> 
                P.string f L.function_;
                P.space f ;
                ignore (Ext_pp_scope.ident inner_cxt f x);
                param_body ();
            end;
          end
        else
          (* print as 
             {[(function(x,y){...} (x,y))]}           
          *)
          let lexical = Ident_set.elements lexical in
          (if return then
             begin 
               P.string f L.return ; 
               P.space f
             end
           else 
             begin match name with
               | No_name -> ()
               | Name_non_top name | Name_top name->
                 P.string f L.var;
                 P.space f;
                 ignore @@ Ext_pp_scope.ident inner_cxt f name ;
                 P.space f ;
                 P.string f L.eq;
                 P.space f ;
             end
          )   
          ;
          P.string f L.lparen;
          P.string f L.function_; 
          P.string f L.lparen;
          ignore @@ comma_idents inner_cxt f lexical;
          P.string f L.rparen;
          P.brace_vgroup f 0  (fun _ -> 
              begin 
                P.string f L.return ;
                P.space f;
                P.string f L.function_;
                P.space f ;
                (match name with 
                 | No_name  -> () 
                 | Name_non_top x | Name_top x -> ignore (Ext_pp_scope.ident inner_cxt f x));
                param_body ()
              end);
          P.string f L.lparen;
          ignore @@ comma_idents inner_cxt f lexical;
          P.string f L.rparen;
          P.string f L.rparen;
          begin match name with 
            | No_name -> () (* expression *)
            | _ -> semi f (* has binding, a statement *)
          end
      in 
      begin match name with 
        | Name_top name | Name_non_top name  when Ident_set.mem name lexical ->
          (*TODO: when calculating lexical we should not include itself *)
          let lexical =  (Ident_set.remove name lexical) in
          handle lexical
        | _ -> handle lexical 
      end
    in
    enclose lexical return 
    ;
    outer_cxt


(* Assume the cond would not change the context, 
    since it can be either [int] or [string]
*)
and output_one : 'a . 
  _ -> P.t -> (P.t -> 'a -> unit) -> 'a J.case_clause -> _
  = fun cxt f  pp_cond
    ({case = e; body = (sl,break)} : _ J.case_clause) -> 
    let cxt = 
      P.group f 1 @@ fun _ -> 
      P.group f 1 @@ (fun _ -> 
          P.string f L.case;
          P.space f ;
          pp_cond  f e; (* could be integer or string*)
          P.space f ;
          P.string f L.colon  );

      P.space f;
      P.group f 1 @@ fun _ ->
      let cxt =
        match sl with 
        | [] -> cxt 
        | _ ->
          P.newline f ;
          statement_list false cxt  f sl
      in
      (if break then 
         begin
           P.newline f ;
           P.string f L.break;
           semi f;
         end) ;
      cxt
    in
    P.newline f;
    cxt 

and loop  :  'a . Ext_pp_scope.t ->
  P.t -> (P.t -> 'a -> unit) -> 'a J.case_clause list -> Ext_pp_scope.t
  = fun  cxt  f pp_cond cases ->
    match cases with 
    | [] -> cxt 
    | [x] -> output_one cxt f pp_cond x
    | x::xs ->
      let cxt = output_one cxt f pp_cond x 
      in loop  cxt f pp_cond  xs 

and vident cxt f  (v : J.vident) =
  begin match v with 
    | Id v | Qualified(v, _, None) ->  
      Ext_pp_scope.ident cxt f v
    | Qualified (id, (Ml | Runtime),  Some name) ->
      let cxt = Ext_pp_scope.ident cxt f id in
      P.string f L.dot;
      P.string f (Ext_ident.convert  name);
      cxt
    | Qualified (id, External _, Some name) ->
      let cxt = Ext_pp_scope.ident cxt f id in
      Js_dump_property.property_access f name ;
      cxt

  end

and expression l cxt  f (exp : J.expression) : Ext_pp_scope.t = 
  pp_comment_option f exp.comment ;
  expression_desc cxt l f exp.expression_desc

and
  expression_desc cxt (l:int) f x : Ext_pp_scope.t  =
  match x with
  | Var v ->
    vident cxt f v 
  | Bool b -> 
    (if  b then P.string f L.true_ else P.string f L.false_ ) ; cxt 
  | Seq (e1, e2) ->
    let action () = 
      let cxt = expression 0 cxt f e1 in
      P.string f L.comma ;
      P.space f ;
      expression 0 cxt f e2  in
    if l > 0 then 
      P.paren_group f 1 action
    else action ()

  | Fun (method_, l, b, env) ->  (* TODO: dump for comments *)
    pp_function method_ cxt f false  l b env
  (* TODO: 
     when [e] is [Js_raw_code] with arity
     print it in a more precise way
     It seems the optimizer already did work to make sure
     {[
       Call (Raw_js_code (s, Exp i), el, {Full})
       when Ext_list.length_equal el i
     ]}
  *)

  | Call (e, el, info) ->
    let action () = 
      P.group f 1 (fun _ -> 
          match info, el  with
          | {arity  = Full }, _ 
          | _, [] -> 
            let cxt = expression 15 cxt f e in 
            P.paren_group f 1 (fun _ -> arguments cxt  f el )  

          | _ , _ -> 
            (* ipp_comment f (Some "!") *)
            P.string f  Js_runtime_modules.curry; 
            P.string f L.dot;
            let len = List.length el in
            if 1 <= len && len <= 8 then  
              begin
                P.string f L.app;
                P.string f (Printf.sprintf "%d" len);
                P.paren_group f 1 (fun _ -> arguments cxt f (e::el))
              end
            else 
              begin 
                P.string f  L.app_array;                
                P.paren_group f 1 (fun _ -> arguments cxt f [ e ; E.arr Mutable el])
              end)
    in
    if l > 15 then P.paren_group f 1 action   
    else action ()
  | Bind (a,b) -> 
    (* a.bind(b)
       {[ fun b -> a.bind(b) ==? a.bind ]}
    *)
    begin
      expression_desc cxt l f  
        (Call ({expression_desc = Dot(a,L.bind, true); comment = None }, [b], 
               {arity = Full; call_info = Call_na}))
    end    

  | FlatCall(e,el) -> 
    P.group f 1 (fun _ -> 
        let cxt = expression 15 cxt f e in
        P.string f L.dot; 
        P.string f L.apply;
        P.paren_group f 1 (fun _ ->
            P.string f L.null;
            P.string f L.comma;
            P.space f ; 
            expression 1 cxt f el
          )
      )
  | String_of_small_int_array ({expression_desc = desc } as e) -> 
    let action () = 
      P.group f 1 (fun _ -> 
          P.string f L.string_cap; 
          P.string f L.dot ;
          P.string f L.fromCharcode;
          begin match desc with 
            | Array (el, _mutable)
              ->
              P.paren_group f 1 (fun _ -> arguments cxt f el)
            | _ -> 
              P.string f L.dot ;
              P.string f L.apply; 
              P.paren_group f 1 (fun _ -> 
                  P.string f L.null;
                  P.string f L.comma;
                  expression 1 cxt  f e  )
          end ) 
    in
    if l > 15 then P.paren_group f 1 action   
    else action ()


  | Array_append (e, el) -> 
    P.group f 1 (fun _ -> 
        let cxt = expression 15 cxt f e in
        P.string f ".concat";
        P.paren_group f 1 (fun _ -> arguments cxt f [el]))

  | Array_copy e -> 
    P.group f 1 (fun _ -> 
        let cxt = expression 15 cxt f e in
        P.string f ".slice";
        P.string f "()" ;
        cxt 
      )

  | Dump (level, el) -> 
    let obj = 
      match level with 
      | Log -> "log"
      | Info -> "info"
      | Warn -> "warn"
      | Error -> "error" in
    P.group f 1 (fun _ -> 
        P.string f L.console;
        P.string f L.dot;
        P.string f obj ;
        P.paren_group f 1 (fun _ -> arguments cxt f el))
  | Json_stringify e 
    -> 
    P.group f 1 (fun _ -> 
        P.string f L.json ;
        P.string f L.dot;
        P.string f L.stringify; 
        P.paren_group f 1 (fun _ -> expression 0 cxt f e )        
      )    
  | Char_to_int e -> 
    begin match e.expression_desc with 
      | String_access (a,b) -> 
        P.group f 1 (fun _ -> 
            let cxt = expression 15 cxt f a in
            P.string f L.dot;
            P.string f L.char_code_at;
            P.paren_group f 1 (fun _ -> expression 0 cxt f b);
          )
      | _ -> 
        P.group f 1 (fun _ -> 
            let cxt = expression 15 cxt f e in
            P.string f L.dot;
            P.string f L.char_code_at;
            P.string f "(0)";
            cxt)
    end

  | Char_of_int e -> 
    P.group f 1 (fun _ -> 
        P.string f L.string_cap;
        P.string f L.dot;
        P.string f L.fromCharcode;
        P.paren_group f 1 (fun _ -> arguments cxt f [e])
      )


  | Math (name, el) -> 
    P.group f 1 (fun _ ->
        P.string f L.math;
        P.string f L.dot;
        P.string f name;
        P.paren_group f 1 (fun _ -> arguments cxt f el)
      )
  | Unicode s -> 
    P.string f "\"";
    P.string f s ; 
    P.string f "\"";
    cxt 
  | Str (_, s) ->
    (*TODO --
       when utf8-> it will not escape '\\' which is definitely not we want
    *)
    Js_dump_string.pp_string f  s;
    cxt 

  | Raw_js_code (s,info) -> 
    begin match info with 
      | Exp -> 
        P.string f "("; 
        P.string f s ; 
        P.string f ")";
        cxt 
      | Stmt -> 
        P.newline f  ;
        P.string f s ;
        P.newline f ;
        cxt 
    end
  | Number v ->
    let s = 
      match v with 
      | Float {f = v} -> 
        Js_number.caml_float_literal_to_js_string v 
      (* attach string here for float constant folding?*)
      | Int { i = v; _} 
        -> Int32.to_string v (* check , js convention with ocaml lexical convention *)
      | Uint i
        -> Format.asprintf "%lu" i              
      | Nint i -> Nativeint.to_string i 
    in
    let need_paren =
      if s.[0] = '-'
      then l > 13  (* Negative numbers may need to be parenthesized. *)
      else l = 15  (* Parenthesize as well when followed by a dot. *)
           && s.[0] <> 'I' (* Infinity *)
           && s.[0] <> 'N' (* NaN *)
    in
    let action = fun _ -> P.string f s  in
    (
      if need_paren 
      then P.paren f  action
      else action ()
    ); 
    cxt 
  | J.Anything_to_number e 
  | Int_of_boolean e -> 
    let action () = 
      P.group f 0 @@ fun _ -> 
      P.string f "+" ;
      expression 13 cxt f e 
    in
    (* need to tweak precedence carefully 
       here [++x --> +(+x)]
    *)
    if l > 12 
    then P.paren_group f 1 action 
    else action ()
  | Is_null_undefined_to_boolean e ->
    let action = (fun _ -> 
        let cxt = expression 1 cxt f e in 
        P.space f ;
        P.string f "==";
        P.space f ;
        P.string f L.null;
        cxt)  in 
    if l > 0 then      
      P.paren_group f 1 action
    else action ()  

  | Caml_not e ->
    expression_desc cxt l f (Bin (Minus, E.one_int_literal, e))

  | Js_not e ->
    let action () = 
      P.string f "!" ;
      expression 13 cxt f e 
    in
    if l > 13 
    then P.paren_group f 1 action 
    else action ()
  | Typeof e 
    -> 
    P.string f "typeof"; 
    P.space f;
    expression 13 cxt f e     
  | Caml_block_set_tag(a,b) -> 
    expression_desc cxt l f 
      (Bin(Eq, 
           {expression_desc = Caml_block_tag a; comment = None},
           b
          ))
  | Caml_block_set_length(a,b) -> 
    expression_desc cxt l f 
      (Bin(Eq, 
           {expression_desc = Length (a,Caml_block); comment = None},
           b
          ))
  | Bin (Eq, {expression_desc = Var i },
         {expression_desc = 
            (
              Bin(
                (Plus as op), {expression_desc = Var j}, delta)
            | Bin(
                (Plus as op), delta, {expression_desc = Var j})
            | Bin(
                (Minus as op), {expression_desc = Var j}, delta)
            )
         })
    when Js_op_util.same_vident i j -> 
    (* TODO: parenthesize when necessary *)
    begin match delta, op with 
      | {expression_desc = Number (Int { i =  1l; _})}, Plus
      (* TODO: float 1. instead, 
           since in JS, ++ is a float operation           
      *)        
      | {expression_desc = Number (Int { i =  -1l; _})}, Minus
        ->
        P.string f L.plusplus;
        P.space f ; 
        vident cxt f i

      | {expression_desc = Number (Int { i =  -1l; _})}, Plus
      | {expression_desc = Number (Int { i =  1l; _})}, Minus
        -> 
        P.string f L.minusminus; 
        P.space f ; 
        vident cxt f i;
      | _, _ -> 
        let cxt = vident cxt f i in
        P.space f ;
        if op = Plus then P.string f "+=" 
        else P.string f "-=";
        P.space f ; 
        expression 13 cxt  f delta
    end
  | Bin (Eq, {expression_desc = Access({expression_desc = Var i; _},
                                       {expression_desc = Number (Int {i = k0 })}
                                      ) },
         {expression_desc = 
            (Bin((Plus as op), 
                 {expression_desc = Access(
                      {expression_desc = Var j; _},
                      {expression_desc = Number (Int {i = k1; })}
                    ); _}, delta)
            | Bin((Plus as op), delta,
                  {expression_desc = Access(
                       {expression_desc = Var j; _},
                       {expression_desc = Number (Int {i = k1; })}
                     ); _})
            | Bin((Minus as op), 
                  {expression_desc = Access(
                       {expression_desc = Var j; _},
                       {expression_desc = Number (Int {i = k1; })}
                     ); _}, delta)

            )})
    when  k0 = k1 && Js_op_util.same_vident i j 
    (* Note that 
       {[x = x + 1]}
       is exactly the same  (side effect, and return value)
       as {[ ++ x]}
       same to 
       {[ x = x + a]}
       {[ x += a ]}
       they both return the modified value too
    *)
    (* TODO:
       handle parens..
    *)
    ->
    let aux cxt f vid i = 
      let cxt = vident cxt f vid in
      P.string f "[";
      P.string f (Int32.to_string  i);
      P.string f"]"; 
      cxt in
    (** TODO: parenthesize when necessary *)

    begin match delta, op with 
      | {expression_desc = Number (Int { i =  1l; _})}, Plus
      | {expression_desc = Number (Int { i =  -1l; _})}, Minus
        ->
        P.string f L.plusplus;
        P.space f ; 
        aux cxt f i k0
      | {expression_desc = Number (Int { i =  -1l; _})}, Plus
      | {expression_desc = Number (Int { i =  1l; _})}, Minus
        -> 
        P.string f L.minusminus; 
        P.space f ; 
        aux cxt f  i k0
      | _, _ -> 
        let cxt = aux cxt f i k0 in
        P.space f ;
        if op = Plus then P.string f "+=" 
        else P.string f "-=";
        P.space f ; 
        expression 13 cxt  f delta
    end
  | Anything_to_string e -> 
    (* Note that we should not apply any smart construtor here, 
       it's purely  a convenice for pretty-printing
    *)    
    expression_desc cxt l f (Bin (Plus, E.empty_string_literal , e))    

  | Bin (Minus, {expression_desc = Number (Int {i=0l;_} | Float {f = "0."})}, e) 
    (* TODO:
       Handle multiple cases like
       {[ 0. - x ]}
       {[ 0.00 - x ]}
       {[ 0.000 - x ]}
    *)
    ->
    let action () = 
      P.string f "-" ;
      expression 13 cxt f e 
    in
    if l > 13 then P.paren_group f 1 action 
    else action ()

  | Bin (op, e1, e2) ->
    let (out, lft, rght) = op_prec op in
    let need_paren =
      l > out || (match op with Lsl | Lsr | Asr -> true | _ -> false) in

    let action () = 
      (* We are more conservative here, to make the generated code more readable
          to the user
      *)

      let cxt = expression lft cxt  f e1 in
      P.space f; 
      P.string f (op_str op);
      P.space f;
      expression rght cxt   f e2 
    in
    if need_paren 
    then P.paren_group f 1 action 
    else action ()

  | String_append (e1, e2) -> 
    let op : Js_op.binop = Plus in
    let (out, lft, rght) = op_prec op in
    let need_paren =
      l > out || (match op with Lsl | Lsr | Asr -> true | _ -> false) in

    let action () = 
      let cxt = expression  lft cxt f e1 in
      P.space f ;
      P.string f "+";
      P.space f;
      expression rght  cxt   f e2 
    in
    if need_paren then P.paren_group f 1 action else action ()

  | Array (el,_) ->
    (** TODO: simplify for singleton list *)
    begin match el with 
      | []| [ _ ] -> P.bracket_group f 1 @@ fun _ -> array_element_list  cxt f el 
      | _ -> P.bracket_vgroup f 1 @@ fun _ -> array_element_list  cxt f el 
    end
  | Caml_uninitialized_obj (tag, size) 
    ->  (* FIXME *)
    expression_desc cxt l f (Object [Length, size ; Tag, tag])    
  | Caml_block( el, mutable_flag, tag, tag_info) 
    -> 
    (* Note that, if we ignore more than tag [0] we loose some information 
       with regard tag  *)
    begin match tag.expression_desc, tag_info with 

      | Number (Int { i = 0l ; _})  , 
        (Blk_tuple | Blk_array | Blk_variant _ | Blk_record _ | Blk_na | Blk_module _
        |  Blk_constructor (_, 1) (* Sync up with {!Js_dump}*)
        ) 
        -> expression_desc cxt l f  (Array (el, mutable_flag))
      (* TODO: for numbers like 248, 255 we can reverse engineer to make it 
         [Obj.xx_flag], but we can not do this in runtime libraries
      *)

      | _, _
        -> 
        P.string f L.caml_block; 
        P.string f L.dot ;
        P.string f L.caml_block_create;
        P.paren_group f 1 (fun _ -> arguments cxt f [tag; E.arr mutable_flag el])
    end
  | Caml_block_tag e ->
    P.group f 1 (fun _ ->  
        let cxt = expression 15 cxt f  e in
        P.string f L.dot ;
        P.string f L.tag ;
        cxt)
  | Access (e, e') 

  | String_access (e,e')
    ->
    let action () = 
      P.group f 1 @@ fun _ -> 
      let cxt = expression 15 cxt f e in
      P.bracket_group f 1 @@ fun _ -> 
      expression 0 cxt f e' 
    in
    if l > 15 then P.paren_group f 1 action else action ()

  | Length (e, _) -> 
    let action () =  (** Todo: check parens *)
      let cxt = expression 15 cxt f e in
      P.string f L.dot;
      P.string f L.length;
      cxt  in
    if l > 15 then P.paren_group f 1 action else action ()

  | Dot (e, s,normal) ->
    let action () = 
      let cxt = expression 15 cxt f e in
      Js_dump_property.property_access f s ;
      (* See [ .obj_of_exports] 
         maybe in the ast level we should have 
         refer and export
      *)
      cxt in
    if l > 15 then P.paren_group f 1 action else action ()

  | New (e,  el) ->
    let action () = 
      P.group f 1 @@ fun _ -> 
      P.string f L.new_;
      P.space f;
      let cxt = expression 16 cxt f e in
      P.paren_group f 1 @@ fun _ -> 
      match el with 
      | Some el  -> arguments cxt f el  
      | None -> cxt
    in
    if l > 15 then P.paren_group f 1 action else action ()

  | Array_of_size e ->
    let action () = 
      P.group f 1 @@ fun _ -> 
      P.string f L.new_;
      P.space f;
      P.string f L.array;
      P.paren_group f 1 @@ fun _ -> expression 0 cxt f e
    in
    if l > 15 then P.paren_group f 1 action else action ()

  | Cond (e, e1, e2) ->
    let action () = 
      (* P.group f 1 @@ fun _ ->  *)
      let cxt =  expression 3 cxt f e in
      P.space f;
      P.string f L.question; 
      P.space f;
      (* 
            [level 1] is correct, however
            to make nice indentation , force nested conditional to be parenthesized
          *)
      let cxt = (P.group f 1 @@ fun _ -> expression 3 cxt f e1) in
      (* let cxt = (P.group f 1 @@ fun _ -> expression 1 cxt f e1) in *)
      P.space f;
      P.string f L.colon;
      P.space f ; 

      (* idem *)
      P.group f 1 @@ fun _ -> expression 3 cxt f e2
      (* P.group f 1 @@ fun _ -> expression 1 cxt f e2 *)
    in
    if l > 2 then P.paren_vgroup f 1 action else action ()

  | Object lst ->
    begin
      match lst with 
      | [] -> P.string f "{ }" ; cxt 
      | _ -> 
        let action () = 
          P.brace_vgroup f 1 @@ fun _ -> 
          property_name_and_value_list cxt f lst in 
        if l > 1 then  
          (* #1946 object literal is easy to be 
            interpreted as block statement
            here we avoid parens in such case
            {[
              var f = { x : 2 , y : 2}
            ]}
          *)
          P.paren_group f 1 action
        else action ()

    end

and property_name cxt f (s : J.property_name) : unit =
  match s with
  | Tag -> P.string f L.tag
  | Length -> P.string f L.length
  | Key s -> Js_dump_property.property_key f s 
  | Int_key i -> P.string f (string_of_int i)

and property_name_and_value_list cxt f l : Ext_pp_scope.t =
  match l with
  | [] -> cxt
  | [(pn, e)] ->
    property_name cxt  f pn ;
    P.string f L.colon;
    P.space f;
    expression 1 cxt f e 
  | (pn, e) :: r ->
    property_name cxt f pn ; 
    P.string f L.colon;
    P.space f;
    let cxt = expression 1 cxt f e in
    P.string f L.comma;
    P.newline f;
    property_name_and_value_list cxt f r

and array_element_list cxt f el : Ext_pp_scope.t =
  match el with
  | []     -> cxt 
  | [e]    ->  expression 1 cxt f e
  | e :: r ->
    let cxt =  expression 1 cxt f e 
    in
    P.string f L.comma; P.newline f; array_element_list cxt f r

and arguments cxt f l : Ext_pp_scope.t =
  match l with
  | []     -> cxt 
  | [e]    ->   expression 1 cxt f e
  | e :: r -> 
    let cxt =   expression 1 cxt f e in
    P.string f L.comma; P.space f; arguments cxt f r

and variable_declaration top cxt f 
    (variable : J.variable_declaration) : Ext_pp_scope.t = 
  (* TODO: print [const/var] for different backends  *)
  match variable with
  | {ident = i; value =  None; ident_info ; _} -> 
    if ident_info.used_stats = Dead_pure 
    then cxt
    else 
      begin
        P.string f L.var;
        P.space f;
        let cxt = Ext_pp_scope.ident cxt  f i in
        semi f ; 
        cxt
      end 
  | { ident = name; value =  Some e; ident_info = {used_stats; _}} ->
    begin match used_stats with
      | Dead_pure -> 
        cxt 
      | Dead_non_pure -> 
        (* Make sure parens are added correctly *)
        statement_desc top cxt f (J.Exp e)
      | _ -> 
        begin match e, top  with 
          | {expression_desc = Fun (method_, params, b, env ); comment = _}, _ -> 
            pp_function method_ cxt f 
              ~name:(if top then Name_top name else Name_non_top name) 
              false params b env 
          | _, _ -> 
            P.string f L.var;
            P.space f;
            let cxt = Ext_pp_scope.ident cxt f name in
            P.space f ;
            P.string f L.eq;
            P.space f ;
            let cxt = expression 1 cxt f e in
            semi f;
            cxt 
        end
    end
and ipp_comment : 'a . P.t -> 'a  -> unit = fun   f comment -> 
  ()


(** don't print a new line -- ASI 
    FIXME: this still does not work in some cases...
    {[
      return /* ... */
      [... ]
    ]}
*)

and pp_comment f comment = 
  if String.length comment > 0 then
    begin 
      P.string f "/* "; P.string f comment ; P.string f " */"
    end

and pp_comment_option f comment  = 
  match comment with 
  | None -> ()
  | Some x -> pp_comment f x
and statement top cxt f 
    ({statement_desc = s;  comment ; _} : J.statement)  : Ext_pp_scope.t =

  pp_comment_option f comment ;
  statement_desc top cxt f s 

and statement_desc top cxt f (s : J.statement_desc) : Ext_pp_scope.t = 
  match s with
  | Block [] -> 
    ipp_comment f  L.empty_block; (* debugging*)
    cxt
  | Exp {expression_desc = Var _;}
    -> (* Does it make sense to optimize here? *)
    semi f; cxt 
  | Exp e ->
    (* Parentheses are required when the expression
       starts syntactically with "{" or "function" 
       TODO:  be more conservative, since Google Closure will handle
       the precedence correctly, we also need people read the code..
       Here we force parens for some alien operators

       If we move assign into a statement, will be less?
       TODO: construct a test case that do need parenthesisze for expression
       IIE does not apply (will be inlined?)
    *)

    let rec need_paren  (e : J.expression) =
      match e.expression_desc with
      | Call ({expression_desc = Fun _; },_,_) -> true
      | Caml_uninitialized_obj _ 
      | Raw_js_code (_, Exp) 
      | Fun _ | Object _ -> true
      | Raw_js_code (_,Stmt)
      | Caml_block_set_tag _ 
      | Length _ 
      | Caml_block_set_length _ 
      | Anything_to_string _ 
      | String_of_small_int_array _
      | Call _ 
      | Array_append _ 
      | Array_copy _ 
      | Caml_block_tag _ 
      | Seq _
      | Dot _
      | Cond _
      | Bin _ 
      | Is_null_undefined_to_boolean _
      | String_access _ 
      | Access _
      | Array_of_size _ 
      | String_append _ 
      | Char_of_int _ 
      | Char_to_int _
      | Dump _
      | Json_stringify _ 
      | Math _
      | Var _ 
      | Str _ 
      | Unicode _
      | Array _ 
      | Caml_block  _ 
      | FlatCall _ 
      | Typeof _
      | Bind _ 
      | Number _
      | Caml_not _ (* FIXME*)
      | Js_not _ 
      | Bool _
      | New _ 
      | J.Anything_to_number _ 
      | Int_of_boolean _ -> false
      (* e = function(x){...}(x);  is good
      *)
    in
    let cxt = 
      (
        if need_paren  e 
        then (P.paren_group f 1)
        else (P.group f 0)
      ) (fun _ -> expression 0 cxt f e ) in
    semi f;
    cxt 

  | Block b -> (* No braces needed here *)
    ipp_comment f L.start_block;
    let cxt = statement_list top cxt  f b in
    ipp_comment f  L.end_block;
    cxt
  | Variable l ->
    variable_declaration top cxt  f l

  | If (e, s1,  s2) -> (* TODO: always brace those statements *)
    P.string f L.if_;
    P.space f;
    let cxt = P.paren_group f 1 @@ fun _ -> expression 0 cxt f e in
    P.space f;
    let cxt =
      block cxt f s1
    in
    begin match s2 with 
      | None | (Some []) 
      | Some [{statement_desc = (Block [] | Exp {expression_desc = Var _;} ); }]
        -> P.newline f; cxt
      | Some [{statement_desc = If _} as nest]
      | Some [{statement_desc = Block [ {statement_desc = If _ ; _} as nest] ; _}]
        ->
        P.space f;
        P.string f L.else_;
        P.space f;
        statement false cxt f nest 
      | Some s2 -> 
        P.space f;
        P.string f L.else_;
        P.space f ;
        block  cxt f s2 
    end

  | While (label, e, s, _env) ->  (*  FIXME: print scope as well *)
    begin 
      (match label with 
       | Some i ->
         P.string f i ; 
         P.string f L.colon;
         P.newline f ;
       | None -> ());
      let cxt = 
        match e.expression_desc with
        | Number (Int {i = 1l}) ->
          P.string f L.while_;
          P.string f "(";
          P.string f L.true_;
          P.string f ")"; 
          P.space f ;
          cxt 
        | _ -> 
          P.string f L.while_;
          let cxt = P.paren_group f 1 @@ fun _ ->  expression 0 cxt f e in
          P.space f ; 
          cxt 
      in
      let cxt = block cxt f s in
      semi f;
      cxt
    end
  | ForRange (for_ident_expression, finish, id, direction, s, env) -> 
    let action cxt  = 
      P.vgroup f 0 @@ fun _ -> 
      let cxt = P.group f 0 @@ fun _ -> 
        (* The only place that [semi] may have semantics here *)
        P.string f "for";
        P.paren_group f 1 @@ fun _ -> 
        let cxt, new_id = 
          (match for_ident_expression, finish.expression_desc with 
           | Some ident_expression , (Number _ | Var _ ) -> 
             P.string f L.var;
             P.space f;
             let cxt  =  Ext_pp_scope.ident cxt f id in
             P.space f; 
             P.string f L.eq;
             P.space f;
             expression 0 cxt f ident_expression, None
           | Some ident_expression, _ -> 
             P.string f L.var;
             P.space f;
             let cxt  =  Ext_pp_scope.ident cxt f id in
             P.space f;
             P.string f L.eq;
             P.space f; 
             let cxt = expression 1 cxt f ident_expression in
             P.space f ; 
             P.string f L.comma;
             let id = Ext_ident.create (Ident.name id ^ "_finish") in
             let cxt = Ext_pp_scope.ident cxt f id in
             P.space f ; 
             P.string f L.eq;
             P.space f;
             expression 1 cxt f finish, Some id
           | None, (Number _ | Var _) -> 
             cxt, None 
           | None , _ -> 
             P.string f L.var;
             P.space f ;
             let id = Ext_ident.create (Ident.name id ^ "_finish") in
             let cxt = Ext_pp_scope.ident cxt f id in
             P.space f ; 
             P.string f L.eq ; 
             P.space f ; 
             expression 15 cxt f finish, Some id
          ) in

        semi f ; 
        P.space f;
        let cxt = Ext_pp_scope.ident cxt f id in
        P.space f;
        let right_prec  = 

          match direction with 
          | Upto -> 
            let (_,_,right) = op_prec Le  in
            P.string f L.le;
            right
          | Downto -> 
            let (_,_,right) = op_prec Ge in
            P.string f L.ge ;
            right
        in
        P.space f ; 
        let cxt  = 
          match new_id with 
          | Some i -> expression   right_prec cxt  f (E.var i)
          | None -> expression  right_prec cxt  f finish
        in
        semi f; 
        P.space f;
        let ()  = 
          match direction with 
          | Upto -> P.string f L.plus_plus
          | Downto -> P.string f L.minus_minus in
        Ext_pp_scope.ident cxt f id
      in
      block  cxt f s  in
    let lexical = Js_closure.get_lexical_scope env in
    if Ident_set.is_empty lexical 
    then action cxt
    else 
      (* unlike function, 
         [print for loop] has side effect, 
         we should take it out
      *)
      let inner_cxt = Ext_pp_scope.merge lexical cxt in
      let lexical = Ident_set.elements lexical in
      let _enclose action inner_cxt lexical   = 
        let rec aux  cxt f ls  =
          match ls with
          | [] -> cxt
          | [x] -> Ext_pp_scope.ident cxt f x
          | y :: ys ->
            let cxt = Ext_pp_scope.ident cxt f y in
            P.string f L.comma;
            aux cxt f ys  in
        P.vgroup f 0
          (fun _ ->
             (
               P.string f "(function(";
               ignore @@ aux inner_cxt f lexical;
               P.string f ")";
               let cxt = P.brace_vgroup f 0  (fun _ -> action inner_cxt) in
               P.string f "(";
               ignore @@ aux inner_cxt f lexical;
               P.string f ")";
               P.string f ")";
               semi f;
               cxt
             )) 
      in
      _enclose action inner_cxt lexical

  | Continue s ->
    P.string f L.continue;
    P.space f ;
    P.string f s;
    semi f;
    P.newline f;
    cxt
  | Debugger
    -> 
    P.newline f ;
    P.string f L.debugger;
    semi f ;
    P.newline f;
    cxt 
  | Break
    ->
    P.string f L.break;
    P.space f ;
    semi f;
    P.newline f; 
    cxt

  | Return {return_value = e} ->
    begin match e with
      | {expression_desc = Fun (method_,  l, b, env); _} ->
        let cxt =
          pp_function method_ cxt f true l b env in
        semi f ; cxt 
      | e ->
        P.string f L.return ;
        P.space f ;

        (* P.string f "return ";(\* ASI -- when there is a comment*\) *)
        P.group f return_indent @@ fun _ -> 
        let cxt =  expression 0 cxt f e in
        semi f;
        cxt 
        (* There MUST be a space between the return and its
           argument. A line return will not work *)
    end
  | Int_switch (e, cc, def) ->
    P.string f L.switch;  
    P.space f;
    let cxt = P.paren_group f 1 @@ fun _ ->  expression 0 cxt f e 
    in
    P.space f;
    P.brace_vgroup f 1 @@ fun _ -> 
    let cxt = loop cxt f (fun f i -> P.string f (string_of_int i) ) cc in
    (match def with
     | None -> cxt
     | Some def ->
       P.group f 1 @@ fun _ -> 
       P.string f L.default;
       P.string f L.colon;
       P.newline f;
       statement_list  false cxt  f def 
    )

  | String_switch (e, cc, def) ->
    P.string f L.switch;
    P.space f;
    let cxt = P.paren_group f 1 @@ fun _ ->  expression 0 cxt f e 
    in
    P.space f;
    P.brace_vgroup f 1 @@ fun _ -> 
    let cxt = loop cxt f (fun f i -> Js_dump_string.pp_string f i ) cc in
    (match def with
     | None -> cxt
     | Some def ->
       P.group f 1 @@ fun _ -> 
       P.string f L.default;
       P.string f L.colon;
       P.newline f;
       statement_list  false cxt  f def )

  | Throw e ->
    P.string f L.throw;
    P.space f ;
    P.group f throw_indent @@ fun _ -> 

    let cxt = expression 0 cxt f e in
    semi f ; cxt 

  (* There must be a space between the return and its
     argument. A line return would not work *)
  | Try (b, ctch, fin) ->
    P.vgroup f 0 @@ fun _-> 
    P.string f "try";
    P.space f ; 
    let cxt = block cxt f b in
    let cxt = 
      match ctch with
      | None ->
        cxt
      | Some (i, b) ->
        P.newline f;
        P.string f "catch (";
        let cxt = Ext_pp_scope.ident cxt f i in
        P.string f ")";
        block cxt f b
    in 
    begin match fin with
      | None -> cxt
      | Some b ->
        P.group f 1 @@ fun _ -> 
        P.string f "finally";
        P.space f;
        block cxt f b 
    end
(* similar to [block] but no braces *)
and statement_list top cxt f  b =
  match b with
  | []     -> cxt
  | [s]    -> statement top  cxt f  s
  | s :: r -> 
    let cxt = statement top cxt f s in
    P.newline f;
    (if top then P.force_newline f);
    statement_list top cxt f  r

and block cxt f b =
  (* This one is for '{' *)
  P.brace_vgroup f 1 (fun _ -> statement_list false cxt   f b )




let program f cxt   ( x : J.program ) = 
  let () = P.force_newline f in
  let cxt =  statement_list true cxt f x.block  in
  let () = P.force_newline f in
  Js_dump_import_export.exports cxt f x.exports

let dump_program (x : J.program) oc = 
  ignore (program (P.from_channel oc)  Ext_pp_scope.empty  x )

let string_of_block  block  
  = 
  let buffer  = Buffer.create 50 in
  begin
    let f = P.from_buffer buffer in
    let _scope =  statement_list true Ext_pp_scope.empty  f block in
    P.flush  f ();
    Buffer.contents buffer     
  end


let string_of_expression e =
  let buffer  = Buffer.create 50 in
  begin
    let f = P.from_buffer buffer in
    let _scope =  expression 0  Ext_pp_scope.empty  f e in
    P.flush  f ();
    Buffer.contents buffer     
  end  

end
module Js_packages_state : sig 
#1 "js_packages_state.mli"
(* Copyright (C) 2017 Authors of BuckleScript
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)



val set_package_name : string -> unit 

val set_package_map : string -> unit 

val get_packages_info : 
  unit -> Js_packages_info.t 

val update_npm_package_path : 
  string -> unit   
end = struct
#1 "js_packages_state.ml"
(* Copyright (C) 2017 Authors of BuckleScript
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


let packages_info  = ref Js_packages_info.empty



let set_package_name name =
  if Js_packages_info.is_empty !packages_info then 
      packages_info := Js_packages_info.from_name name
  else
    Ext_pervasives.bad_argf "duplicated flag for -bs-package-name"

let set_package_map name = 
    set_package_name name ; 
    Clflags.open_modules := 
      Ext_namespace.namespace_of_package_name name ::
      !Clflags.open_modules
      
let update_npm_package_path s  = 
  packages_info := Js_packages_info.add_npm_package_path s !packages_info

let get_packages_info () = !packages_info  
end
module Js_name_of_module_id : sig 
#1 "js_name_of_module_id.mli"
(* Copyright (C) 2017 Authors of BuckleScript
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


val string_of_module_id : 
  output_dir:string ->
  Js_packages_info.module_system -> 
  Lam_module_ident.t ->
  string
end = struct
#1 "js_name_of_module_id.ml"
(* Copyright (C) 2017 Authors of BuckleScript
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)





  let string_of_module_id 
      ~output_dir
      module_system
      id
    = 
    Js_packages_info.string_of_module_id
      ~output_dir
      module_system
      (Js_packages_state.get_packages_info ())
      Lam_compile_env.get_package_path_from_cmj
      id    


end
module Js_dump_program : sig 
#1 "js_dump_program.mli"
(* Copyright (C) 2017 Authors of BuckleScript
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)



val dump_program : J.program -> out_channel -> unit


val pp_deps_program :
  output_prefix:string ->
  Js_packages_info.module_system -> J.deps_program -> Ext_pp.t -> unit


val dump_deps_program :
  output_prefix:string ->
  Js_packages_info.module_system  -> J.deps_program -> out_channel -> unit
  
end = struct
#1 "js_dump_program.ml"
(* Copyright (C) 2017 Authors of BuckleScript
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

module P = Ext_pp
module L = Js_dump_lit 




let empty_explanation = 
  "/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */"

let program_is_empty (x : J.program) = 
  match x with 
  | {
    block = [];
    exports = [];
    name = _ ;
    export_set = _
  }  -> true 
  | _  -> false  

let deps_program_is_empty (x : J.deps_program) = 
  match x with 
  | { modules = [];
      program ;
      side_effect = None
    } -> program_is_empty program
  | _ -> false 

let program f cxt   ( x : J.program ) = 
  P.force_newline f;
  let cxt =  Js_dump.statement_list true cxt f x.block  in
  P.force_newline f;
  Js_dump_import_export.exports cxt f x.exports

let dump_program (x : J.program) oc = 
  ignore (program (P.from_channel oc)  Ext_pp_scope.empty  x )


let node_program ~output_dir f ( x : J.deps_program) = 
  let cxt = 
    Js_dump_import_export.requires 
      L.require
      Ext_pp_scope.empty
      f
      (Ext_list.map 
         (fun x -> 
            Lam_module_ident.id x,
            Js_name_of_module_id.string_of_module_id ~output_dir
              NodeJS 
              x)
         x.modules)
  in
  program f cxt x.program  


let amd_program ~output_dir kind f (  x : J.deps_program) = 
  let cxt = Ext_pp_scope.empty in
  P.vgroup f 1 @@ fun _ -> 
  P.string f L.define;
  P.string f "([";
  P.string f (Printf.sprintf "%S" L.exports);

  List.iter (fun x ->
      let s : string = 
        Js_name_of_module_id.string_of_module_id ~output_dir
          kind 
          x in
      P.string f L.comma ;
      P.space f; 
      Js_dump_string.pp_string f  s;
    ) x.modules ;
  P.string f "]";
  P.string f L.comma;
  P.newline f;
  P.string f L.function_;
  P.string f "(";
  P.string f L.exports;

  let cxt = 
    List.fold_left (fun cxt x ->         
        let id = Lam_module_ident.id x in
        P.string f L.comma;
        P.space f ; 
        Ext_pp_scope.ident cxt f id
      ) cxt x.modules     
  in
  P.string f ")";
  let v = P.brace_vgroup f 1 @@ (fun _ -> 
      let () = P.string f L.strict_directive in 
      program f cxt x.program
    ) in
  P.string f ")";
  v


let es6_program  ~output_dir fmt f (  x : J.deps_program) = 
  let cxt = 
    Js_dump_import_export.imports
      Ext_pp_scope.empty
      f
      (Ext_list.map 
         (fun x -> 
            Lam_module_ident.id x,
            Js_name_of_module_id.string_of_module_id ~output_dir
              fmt 
              x)
         x.modules)
  in
  let () = P.force_newline f in 
  let cxt = Js_dump.statement_list true cxt f x.program.block in 
  let () = P.force_newline f in 
  Js_dump_import_export.es6_export cxt f x.program.exports



(** Make sure github linguist happy
    {[
      require('Linguist')
        Linguist::FileBlob.new('jscomp/test/test_u.js').generated?
    ]}
*)

let pp_deps_program
    ~output_prefix
    (kind : Js_packages_info.module_system )
    (program  : J.deps_program) (f : Ext_pp.t) = 
  if not !Js_config.no_version_header then 
    begin 
      P.string f Bs_version.header;
      P.newline f
    end ; 
  if deps_program_is_empty program then 
    P.string f empty_explanation 
    (* This is empty module, it won't be referred anywhere *)
  else 
    let output_dir = Filename.dirname output_prefix in 
    P.string f L.strict_directive; 
    P.newline f ;    
    begin 
      ignore (match kind with 
          | Es6 | Es6_global -> 
            es6_program ~output_dir kind f program
          | AmdJS | AmdJS_global -> 
            amd_program ~output_dir kind f program
          | NodeJS -> 
            node_program ~output_dir f program
        ) ;
      P.newline f ;
      P.string f (
        match program.side_effect with
        | None -> "/* No side effect */"
        | Some v -> Printf.sprintf "/* %s Not a pure module */" v );
      P.newline f;
      P.flush f ()
    end



let dump_deps_program
    ~output_prefix
    kind
    x 
    (oc : out_channel) = 
  pp_deps_program ~output_prefix  kind x (P.from_channel oc)

end
module Js_fold_basic : sig 
#1 "js_fold_basic.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** A module to calculate hard dependency based on JS IR in module [J] *)

val depends_j : J.expression -> Ident_set.t -> Ident_set.t

(** TODO: {!Ordered_hash_set} for better ordering *)
val calculate_hard_dependencies : J.block -> Lam_module_ident.Hash_set.t

end = struct
#1 "js_fold_basic.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)









class count_deps (add : Ident.t -> unit )  = 
  object(self)
    inherit  Js_fold.fold as super
    method! expression lam = 
      match lam.expression_desc with 
      | Fun (_, _, block, _) -> self#block block
      (** Call 
          actually depends on parameter, 
          since closure 
          {[
            n = n - 1
                    acc = () => n 
          ]}
          should be 

          {[
            acc = (function (n) {() => n} (n))
              n = n - 1
          ]}
      *)
      | _ -> super#expression lam
    method! ident x = add x ; self
  end

let add_lam_module_ident = Lam_module_ident.Hash_set.add
let create = Lam_module_ident.Hash_set.create
class count_hard_dependencies = 
  object(self)
    inherit  Js_fold.fold as super
    val hard_dependencies =  create 17
    method! vident vid = 
      match vid with 
      | Qualified (id,kind,_) ->
          add_lam_module_ident  hard_dependencies (Lam_module_ident.mk kind id); self
      | Id id -> self
    method! expression x = 
      match  x with
      | {expression_desc = Call (_,_, {arity = NA}); _}
        (* see [Js_exp_make.runtime_var_dot] *)
        -> 
        add_lam_module_ident hard_dependencies 
          (Lam_module_ident.of_runtime (Ext_ident.create_js Js_runtime_modules.curry));
        super#expression x             
      | {expression_desc = Caml_block(_,_, tag, tag_info); _}
        -> 
        begin match tag.expression_desc, tag_info with 
          | Number (Int { i = 0l ; _})  , 
            (Blk_tuple | Blk_array | Blk_variant _ | Blk_record _ | Blk_na | Blk_module _
            |  Blk_constructor (_, 1)
            )  (*Sync up with {!Js_dump}*)
            -> ()
          | _, _
            -> 
            add_lam_module_ident hard_dependencies 
              (Lam_module_ident.of_runtime (Ext_ident.create_js Js_runtime_modules.block));
        end;
        super#expression x 
      | _ -> super#expression x
    method get_hard_dependencies = hard_dependencies
  end

let calculate_hard_dependencies block = 
  ((new count_hard_dependencies)#block block) # get_hard_dependencies

(*
   Given a set of [variables], count which variables  [lam] will depend on
   Invariant:
   [variables] are parameters which means immutable so that [Call] 
   will not depend [variables]

*)
let depends_j (lam : J.expression) (variables : Ident_set.t) = 
  let v = ref Ident_set.empty in
  let add id = 
    if Ident_set.mem id variables then 
      v := Ident_set.add id !v 
  in
  ignore @@ (new count_deps add ) # expression lam ;
  !v


end
module Lam_compile_defs : sig 
#1 "lam_compile_defs.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Type defintion to keep track of compilation state 
  *)

(** Some types are defined in this module to help avoiding generating unnecessary symbols 
    (generating too many symbols will make the output code unreadable)
*)

type jbl_label = int 



type value = {
    exit_id : Ident.t ; 
    args : Ident.t list ;
    order_id : int
  }

type let_kind = Lam.let_kind

type st = 
  | EffectCall
  | Declare of let_kind * J.ident (* bound value *)
  | NeedValue 
  | Assign of J.ident 
  (** when use [Assign], var is not needed, since it's already declared 
      make sure all [Assign] are declared first, otherwise you are creating global variables
   *)

type return_label = {
  id : Ident.t;
  label : J.label;
  params : Ident.t list;
  immutable_mask : bool array;
  mutable new_params : Ident.t Ident_map.t ;
  mutable triggered : bool
}

type return_type = 
  | ReturnFalse 
  | ReturnTrue of return_label option (* anonoymous function does not have identifier *)

(* delegate to the callee to generate expression 
      Invariant: [output] should return a trailing expression
  *)

module HandlerMap : Map.S with type key = jbl_label

type cxt = {
  st : st ;
  should_return : return_type;
  jmp_table : value  HandlerMap.t ;
  meta : Lam_stats.t ;
}

val empty_handler_map : value HandlerMap.t 

val add_jmps :
    Ident.t * (HandlerMap.key * 'a * Ident.t list) list ->
    value HandlerMap.t -> value HandlerMap.t * (int * 'a) list


end = struct
#1 "lam_compile_defs.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








type jbl_label = int 

module HandlerMap = Map.Make(struct 
  type t = jbl_label
  let compare x y= compare (x:t) y 
end )

type value = {
    exit_id : Ident.t ;
    args : Ident.t list ;
    order_id : int
  }

(* delegate to the callee to generate expression 
      Invariant: [output] should return a trailing expression
 *)
type return_label = {
  id : Ident.t;
  label : J.label;
  params : Ident.t list;
  immutable_mask : bool array; 
  mutable new_params : Ident.t Ident_map.t;  
  mutable triggered : bool
}

type return_type = 
  | ReturnFalse 
  | ReturnTrue of return_label option 
    (* Note [return] does indicate it is a tail position in most cases
      however, in an exception handler, return may not be in tail position
      to fix #1701 we play a trick that (ReturnTrue None) 
      would never trigger tailcall, however, it preserves [return] 
      semantics
    *)
   (* have a mutable field to notifiy it's actually triggered *)
   (* anonoymous function does not have identifier *)

type let_kind = Lam.let_kind

type st = 
  | EffectCall
  | Declare of let_kind * J.ident (* bound value *)
  | NeedValue 
  | Assign of J.ident (* when use [Assign], var is not needed, since it's already declared  *)

type cxt = {
  st : st ;
  should_return : return_type;
  jmp_table : value  HandlerMap.t ;
  meta : Lam_stats.t ;
  (* include_alias :  *)
  (*   (\** It's correct to add more, we can do this in lambda optimization pass *)
  (*    *\) *)
  (*   (Ident.t , Ident.t) Hashtbl.t *)
  (* Used when compiling [Lstaticraise]  *)
}

let empty_handler_map = HandlerMap.empty


let add_jmps (exit_id, code_table)   
    (m : value HandlerMap.t) = 
  (* always keep key id positive, specifically no [0] generated
   *)
  let map, _, handlers = 
    List.fold_left 
           (fun (acc,prev_order_id, handlers) 
               (l,lam, args)   -> 
                 let order_id = prev_order_id + 1 in
                 (HandlerMap.add l {exit_id ; args; order_id } acc, 
                  order_id ,
                  (order_id, lam) :: handlers))
      (m,
       HandlerMap.cardinal m,
       []
      )
      code_table in
  map, List.rev handlers

end
module Js_output : sig 
#1 "js_output.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** The intemediate output when compiling lambda into JS IR *)

(* Hongbo Should we rename this module js_of_lambda since it looks like it's 
   containing that step
 *)

type st = Lam_compile_defs.st 

type finished = 
  | True 
  | False 
  | Dummy (* Have no idea, so that when [++] is applied, always use the other *)

type t  =  { 
  block : J.block ;
  value : J.expression option;
  finished : finished
}

val make : ?value: J.expression -> ?finished:finished -> J.block -> t

val of_stmt : ?value: J.expression -> ?finished:finished -> J.statement -> t

val of_block : ?value:J.expression -> ?finished:finished -> J.block -> t

val to_block : t -> J.block

val to_break_block : t -> J.block * bool 

module Ops : sig 
  val (++) : t -> t -> t 
end

val dummy : t 


val handle_name_tail :
    Lam_compile_defs.st ->
    Lam_compile_defs.return_type ->
    Lam.t ->  J.expression -> t

val handle_block_return : 
    Lam_compile_defs.st ->
    Lam_compile_defs.return_type ->
    Lam.t ->
    J.block -> J.expression -> t

val concat : t list -> t

val to_string : t -> string

end = struct
#1 "js_output.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








module E = Js_exp_make 
module S = Js_stmt_make 

type finished = 
  | True 
  | False 
  | Dummy (* Have no idea, so that when [++] is applied, always use the other *)

type t  =  { 
  block : J.block ;
  value : J.expression option;
  finished : finished ; 
    (** When [finished] is true the block is already terminated, value does not make sense
        default is false, false is  an conservative approach 
     *)
}

type st = Lam_compile_defs.st 

let make ?value ?(finished=False) block = {block ; value ; finished }

let of_stmt ?value ?(finished = False) stmt = {block = [stmt] ; value ; finished }

let of_block ?value ?(finished = False) block = 
  {block  ; value ; finished }

let dummy = {value = None; block = []; finished = Dummy }

let handle_name_tail 
    (name : st)
    (should_return : Lam_compile_defs.return_type)
    lam (exp : J.expression) : t =
  begin match name, should_return with 
  | EffectCall, ReturnFalse -> 
      if Lam_analysis.no_side_effects lam 
      then dummy
      else {block = []; value  = Some exp ; finished = False}
  | EffectCall, ReturnTrue _ ->
      make [S.return  exp] ~finished:True
  | Declare (kind, n), ReturnFalse -> 
      make [ S.define ~kind n  exp]
  | Assign n ,ReturnFalse -> 
      make [S.assign n exp ]
  | (Declare _ | Assign _ ), ReturnTrue _ -> 
      make [S.unknown_lambda lam] ~finished:True
  | NeedValue, _ -> {block = []; value = Some exp; finished = False }
  end

let handle_block_return 
    (st : st) 
    (should_return : Lam_compile_defs.return_type)
    (lam : Lam.t) (block : J.block) exp : t = 
  match st, should_return with 
  | Declare (kind,n), ReturnFalse -> 
    make (block @ [ S.define ~kind  n exp])
  | Assign n, ReturnFalse -> make (block @ [S.assign n exp])
  | (Declare _ | Assign _), ReturnTrue _ -> make [S.unknown_lambda lam] ~finished:True
  | EffectCall, ReturnFalse -> make block ~value:exp
  | EffectCall, ReturnTrue _ -> make (block @ [S.return exp]) ~finished:True
  | NeedValue, _ ->  make block ~value:exp

let statement_of_opt_expr (x : J.expression option) : J.statement =
  match x with 
  | None -> S.empty ()
  | Some x when Js_analyzer.no_side_effect_expression x -> S.empty ()
        (* TODO, pure analysis in lambda instead *)
  | Some x -> S.exp x 

let rec unroll_block (block : J.block) = 
  match block with 
  | [{statement_desc = Block block}] -> unroll_block block 
  |  _ -> block 

let to_block ( x : t)  : J.block = 
  match x with 
  | {block; value = opt; finished} ->
      let block = unroll_block block in
      if finished = True  then block
      else 
        begin match opt with 
        | None -> block (* TODO, pure analysis in lambda instead *)
        | Some x when Js_analyzer.no_side_effect_expression x -> block
        | Some x -> block @ [S.exp x ]
        end

let to_break_block (x : t) : J.block * bool = 
    match x with 
    | {finished = True; block ; _ } -> 
        unroll_block block, false 
       (* value does not matter when [finished] is true
           TODO: check if it has side efects
        *)
    | {block; value =  None; finished } -> 
        let block = unroll_block block in 
        block, (match finished with | True -> false | (False | Dummy)  -> true  )

    | {block; value = opt; _} -> 
        let block = unroll_block block in
        block @ [statement_of_opt_expr opt], true

let rec append  (x : t ) (y : t ) : t =  
    match x , y with (* ATTTENTION: should not optimize [opt_e2], it has to conform to [NeedValue]*)
    | {finished = True; _ }, _ -> x  
    | _, {block = []; value= None; finished = Dummy } -> x 
          (* finished = true --> value = E.undefined otherwise would throw*)
    | {block = []; value= None; _ }, y  -> y 
    | {block = []; value= Some _; _}, {block = []; value= None; _ } -> x 
    | {block = []; value =  Some e1; _}, ({block = []; value = Some e2; finished } as z) -> 
        if Js_analyzer.no_side_effect_expression e1 
        then z
            (* It would optimize cases like [module aliases]
                Bigarray, List 
             *)
        else
          {block = []; value = Some (E.seq e1 e2); finished}
          (* {block = [S.exp e1]; value =  Some e2(\* (E.seq e1 e2) *\); finished} *)

       (** TODO: make everything expression make inlining hard, and code not readable?

           1. readability pends on how we print the expression 
           2. inlining needs generate symbols, which are statements, type mismatch
              we need capture [Exp e]

           can we call them all [statement]? statement has no value 
        *)
    (* | {block = [{statement_desc = Exp e }]; value = None ; _}, _ *)
    (*   -> *)
    (*     append { x with block = []; value = Some e} y *)
    (* |  _ , {block = [{statement_desc = Exp e }]; value = None ; _} *)
    (*   -> *)
    (*     append x { y with block = []; value = Some e} *)

    | {block = block1; value = opt_e1; _},  {block = block2; value = opt_e2; finished} -> 
        let block1 = unroll_block block1 in
        make (block1 @ (statement_of_opt_expr opt_e1  :: unroll_block block2))
          ?value:opt_e2 ~finished


module Ops = struct 
  let (++)  (x : t ) (y : t ) : t =  append x y 
end

(* Fold right is more efficient *)
let concat (xs : t list) : t = 
  List.fold_right (fun x acc -> append x  acc) xs dummy

let to_string x   = 
  Js_dump.string_of_block (to_block x)

end
module Js_pass_debug : sig 
#1 "js_pass_debug.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






val dump : string  -> J.program -> J.program 

end = struct
#1 "js_pass_debug.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






let log_counter = ref 0 

let dump name (prog : J.program) =

    prog

 

end
module Js_map
= struct
#1 "js_map.ml"
(* BuckleScript compiler
 * Copyright (C) 2015-2016 Bloomberg Finance L.P.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, with linking exception;
 * either version 2.1 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 *)
(* Author: Hongbo Zhang  *)
(** GENERATED CODE, map visitor for JS IR  *)
open J
  
class virtual map =
  object ((o : 'self_type))
    method string : string -> string = o#unknown
    method option :
      'a 'a_out. ('self_type -> 'a -> 'a_out) -> 'a option -> 'a_out option =
      fun _f_a ->
        function | None -> None | Some _x -> let _x = _f_a o _x in Some _x
    method list :
      'a 'a_out. ('self_type -> 'a -> 'a_out) -> 'a list -> 'a_out list =
      fun _f_a ->
        function
        | [] -> []
        | _x :: _x_i1 ->
            let _x = _f_a o _x in
            let _x_i1 = o#list _f_a _x_i1 in _x :: _x_i1
    method int : int -> int = o#unknown
    method bool : bool -> bool = function | false -> false | true -> true
    method vident : vident -> vident =
      function
      | Id _x -> let _x = o#ident _x in Id _x
      | Qualified (_x, _x_i1, _x_i2) ->
          let _x = o#ident _x in
          let _x_i1 = o#kind _x_i1 in
          let _x_i2 = o#option (fun o -> o#string) _x_i2
          in Qualified (_x, _x_i1, _x_i2)
    method variable_declaration :
      variable_declaration -> variable_declaration =
      fun { ident = _x; value = _x_i1; property = _x_i2; ident_info = _x_i3 }
        ->
        let _x = o#ident _x in
        let _x_i1 = o#option (fun o -> o#expression) _x_i1 in
        let _x_i2 = o#property _x_i2 in
        let _x_i3 = o#ident_info _x_i3
        in
          { ident = _x; value = _x_i1; property = _x_i2; ident_info = _x_i3;
          }
    method tag_info : tag_info -> tag_info = o#unknown
    method statement_desc : statement_desc -> statement_desc =
      function
      | Block _x -> let _x = o#block _x in Block _x
      | Variable _x -> let _x = o#variable_declaration _x in Variable _x
      | Exp _x -> let _x = o#expression _x in Exp _x
      | If (_x, _x_i1, _x_i2) ->
          let _x = o#expression _x in
          let _x_i1 = o#block _x_i1 in
          let _x_i2 = o#option (fun o -> o#block) _x_i2
          in If (_x, _x_i1, _x_i2)
      | While (_x, _x_i1, _x_i2, _x_i3) ->
          let _x = o#option (fun o -> o#label) _x in
          let _x_i1 = o#expression _x_i1 in
          let _x_i2 = o#block _x_i2 in
          let _x_i3 = o#unknown _x_i3 in While (_x, _x_i1, _x_i2, _x_i3)
      | ForRange (_x, _x_i1, _x_i2, _x_i3, _x_i4, _x_i5) ->
          let _x = o#option (fun o -> o#for_ident_expression) _x in
          let _x_i1 = o#finish_ident_expression _x_i1 in
          let _x_i2 = o#for_ident _x_i2 in
          let _x_i3 = o#for_direction _x_i3 in
          let _x_i4 = o#block _x_i4 in
          let _x_i5 = o#unknown _x_i5
          in ForRange (_x, _x_i1, _x_i2, _x_i3, _x_i4, _x_i5)
      | Continue _x -> let _x = o#label _x in Continue _x
      | Break -> Break
      | Return _x -> let _x = o#return_expression _x in Return _x
      | Int_switch (_x, _x_i1, _x_i2) ->
          let _x = o#expression _x in
          let _x_i1 =
            o#list
              (fun o ->
                 (* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)
                 (** Javascript IR
  
    It's a subset of Javascript AST specialized for OCaml lambda backend

    Note it's not exactly the same as Javascript, the AST itself follows lexical
    convention and [Block] is just a sequence of statements, which means it does 
    not introduce new scope
*)
                 (** object literal, if key is ident, in this case, it might be renamed by 
    Google Closure  optimizer,
    currently we always use quote
 *)
                 (* Since camldot is only available for toplevel module accessors,
       we don't need print  `A.length$2`
       just print `A.length` - it's guarateed to be unique
       
       when the third one is None, it means the whole module 

       TODO: 
       invariant, when [kind] is [Runtime], then we can ignore [ident], 
       since all [runtime] functions are unique, when do the 
       pattern match we can ignore the first one for simplicity
       for example       
       {[
         Qualified (_, Runtime, Some "caml_int_compare")         
       ]}       
     *)
                 (** where we use a trick [== null ] *)
                 (* used in [#create_array] primitive, note having
       uninitilized array is not as bad as in ocaml, 
       since GC does not rely on it
     *)
                 (* shallow copy, like [x.slice] *)
                 (* For [caml_array_append]*)
                 (* | Tag_ml_obj of expression *) (* js true/false*)
                 (* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence 
     [typeof] is an operator     
  *)
                 (* 1 - v *) (* !v *)
                 (* String.fromCharCode.apply(null, args) *)
                 (* Convert JS boolean into OCaml boolean 
       like [+true], note this ast talks using js
       terminnology unless explicity stated                       
     *)
                 (* TODO: in the future, it might make sense to group primitivie by type,
     which makes optimizations easier
     {[ JSON.stringify(value, replacer[, space]) ]}
  *)
                 (* for debugging utitlites, 
     TODO:  [Dump] is not necessary with this primitive 
     Note that the semantics is slightly different from [JSON.stringify]     
     {[
       JSON.stringify("x")       
     ]}
     {[
       ""x""       
     ]}     
     {[
       JSON.stringify(undefined)       
     ]}     
     {[
       undefined       
     ]}
     {[ '' + undefined
     ]}     
     {[ 'undefined'
     ]}     
  *)
                 (* TODO: 
     add 
     {[ Assert of bool * expression ]}     
  *)
                 (* to support 
       val log1 : 'a -> unit
       val log2 : 'a -> 'b -> unit 
       val log3 : 'a -> 'b -> 'c -> unit 
     *)
                 (* TODO: Add some primitives so that [js inliner] can do a better job *)
                 (* [int_op] will guarantee return [int32] bits 
     https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators  *)
                 (* | Int32_bin of int_op * expression * expression *)
                 (* f.apply(null,args) -- Fully applied guaranteed 
       TODO: once we know args's shape --
       if it's know at compile time, we can turn it into
       f(args[0], args[1], ... )
     *)
                 (* {[ Bind (a,b) ]}
     is literally
     {[ a.bind(b) ]}
  *)
                 (* Analysze over J expression is hard since, 
        some primitive  call is translated 
        into a plain call, it's better to keep them
    *)
                 (* Invariant: 
       The second argument has to be type of [int],
       This can be constructed either in a static way [E.index] or a dynamic way 
       [E.access]
     *)
                 (* The third argument bool indicates whether we should 
       print it as 
       a["idd"] -- false
       or 
       a.idd  -- true
       There are several kinds of properties
       1. OCaml module dot (need to be escaped or not)
          All exported declarations have to be OCaml identifiers
       2. Javascript dot (need to be preserved/or using quote)
     *)
                 (* TODO: option remove *)
                 (* The first parameter by default is false, 
     it will be true when it's a method
  *)
                 (* A string is UTF-8 encoded, the string may contain
       escape sequences.
       The first argument is used to mark it is non-pure, please
       don't optimize it, since it does have side effec, 
       examples like "use asm;" and our compiler may generate "error;..." 
       which is better to leave it alone
       The last argument is passed from as `j` from `{j||j}`
     *)
                 (* It is escaped string, print delimited by '"'*)
                 (* literally raw JS code 
  *)
                 (* The third argument is [tag] , forth is [tag_info] *)
                 (* [tag] and [size] tailed  for [Obj.new_block] *)
                 (* For setter, it still return the value of expression, 
     we can not use 
     {[
       type 'a access = Get | Set of 'a
     ]}
     in another module, since it will break our code generator
     [Caml_block_tag] can return [undefined], 
     you have to use [E.tag] in a safe way     
  *)
                 (* It will just fetch tag, to make it safe, when creating it, 
     we need apply "|0", we don't do it in the 
     last step since "|0" can potentially be optimized
  *)
                 (* pure*) (* pure *)
                 (* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block
   block can be nested, specified in ES3 
 *)
                 (* Delay some units like [primitive] into JS layer ,
   benefit: better cross module inlining, and smaller IR size?
 *)
                 (* 
  [closure] captured loop mutable values in the outer loop

  check if it contains loop mutable values, happens in nested loop
  when closured, it's no longer loop mutable value. 
  which means the outer loop mutable value can not peek into the inner loop
  {[
  var i = f ();
  for(var finish = 32; i < finish; ++i){
  }
  ]}
  when [for_ident_expression] is [None], [var i] has to 
  be initialized outside, so 

  {[
  var i = f ()
  (function (xxx){
  for(var finish = 32; i < finish; ++i)
  }(..i))
  ]}
  This happens rare it's okay

  this is because [i] has to be initialized outside, if [j] 
  contains a block side effect
  TODO: create such example
*)
                 (* Since in OCaml, 
   
  [for i = 0 to k end do done ]
  k is only evaluated once , to encode this invariant in JS IR,
  make sure [ident] is defined in the first b

  TODO: currently we guarantee that [bound] was only 
  excecuted once, should encode this in AST level
*)
                 (* Can be simplified to keep the semantics of OCaml
   For (var i, e, ...){
     let  j = ... 
   }

   if [i] or [j] is captured inside closure

   for (var i , e, ...){
     (function (){
     })(i)
   }
*)
                 (* Single return is good for ininling..
   However, when you do tail-call optmization
   you loose the expression oriented semantics
   Block is useful for implementing goto
   {[
   xx:{
   break xx;
   }
   ]}
*)
                 (* Function declaration and Variable declaration  *)
                 (* check if it contains loop mutable values, happens in nested loop *)
                 (* only used when inline a fucntion *)
                 (* Here we need track back a bit ?, move Return to Function ...
                              Then we can only have one Return, which is not good *)
                 o#case_clause (fun o -> o#int))
              _x_i1 in
          let _x_i2 = o#option (fun o -> o#block) _x_i2
          in Int_switch (_x, _x_i1, _x_i2)
      | String_switch (_x, _x_i1, _x_i2) ->
          let _x = o#expression _x in
          let _x_i1 =
            o#list (fun o -> o#case_clause (fun o -> o#string)) _x_i1 in
          let _x_i2 = o#option (fun o -> o#block) _x_i2
          in String_switch (_x, _x_i1, _x_i2)
      | Throw _x -> let _x = o#expression _x in Throw _x
      | Try (_x, _x_i1, _x_i2) ->
          let _x = o#block _x in
          let _x_i1 =
            o#option
              (fun o (_x, _x_i1) ->
                 let _x = o#exception_ident _x in
                 let _x_i1 = o#block _x_i1 in (_x, _x_i1))
              _x_i1 in
          let _x_i2 = o#option (fun o -> o#block) _x_i2
          in Try (_x, _x_i1, _x_i2)
      | Debugger -> Debugger
    method statement : statement -> statement =
      fun { statement_desc = _x; comment = _x_i1 } ->
        let _x = o#statement_desc _x in
        let _x_i1 = o#option (fun o -> o#string) _x_i1
        in { statement_desc = _x; comment = _x_i1; }
    method return_expression : return_expression -> return_expression =
      fun { return_value = _x } ->
        let _x = o#expression _x in { return_value = _x; }
    method required_modules : required_modules -> required_modules =
      o#unknown
    method property_name : property_name -> property_name = o#unknown
    method property_map : property_map -> property_map =
      o#list
        (fun o (_x, _x_i1) ->
           let _x = o#property_name _x in
           let _x_i1 = o#expression _x_i1 in (_x, _x_i1))
    method property : property -> property = o#unknown
    method program : program -> program =
      fun { name = _x; block = _x_i1; exports = _x_i2; export_set = _x_i3 }
        ->
        let _x = o#string _x in
        let _x_i1 = o#block _x_i1 in
        let _x_i2 = o#exports _x_i2 in
        let _x_i3 = o#unknown _x_i3
        in { name = _x; block = _x_i1; exports = _x_i2; export_set = _x_i3; }
    method number : number -> number = o#unknown
    method mutable_flag : mutable_flag -> mutable_flag = o#unknown
    method length_object : length_object -> length_object = o#unknown
    method label : label -> label = o#string
    method kind : kind -> kind = o#unknown
    method jsint : jsint -> jsint = o#unknown
    method int_op : int_op -> int_op = o#unknown
    method ident_info : ident_info -> ident_info = o#unknown
    method ident : ident -> ident = o#unknown
    method for_ident_expression :
      for_ident_expression -> for_ident_expression = o#expression
    method for_ident : for_ident -> for_ident = o#ident
    method for_direction : for_direction -> for_direction = o#unknown
    method finish_ident_expression :
      finish_ident_expression -> finish_ident_expression = o#expression
    method expression_desc : expression_desc -> expression_desc =
      function
      | Math (_x, _x_i1) ->
          let _x = o#string _x in
          let _x_i1 = o#list (fun o -> o#expression) _x_i1
          in Math (_x, _x_i1)
      | Length (_x, _x_i1) ->
          let _x = o#expression _x in
          let _x_i1 = o#length_object _x_i1 in Length (_x, _x_i1)
      | Char_of_int _x -> let _x = o#expression _x in Char_of_int _x
      | Char_to_int _x -> let _x = o#expression _x in Char_to_int _x
      | Is_null_undefined_to_boolean _x ->
          let _x = o#expression _x in Is_null_undefined_to_boolean _x
      | Array_of_size _x -> let _x = o#expression _x in Array_of_size _x
      | Array_copy _x -> let _x = o#expression _x in Array_copy _x
      | Array_append (_x, _x_i1) ->
          let _x = o#expression _x in
          let _x_i1 = o#expression _x_i1 in Array_append (_x, _x_i1)
      | String_append (_x, _x_i1) ->
          let _x = o#expression _x in
          let _x_i1 = o#expression _x_i1 in String_append (_x, _x_i1)
      | Int_of_boolean _x -> let _x = o#expression _x in Int_of_boolean _x
      | Anything_to_number _x ->
          let _x = o#expression _x in Anything_to_number _x
      | Bool _x -> let _x = o#bool _x in Bool _x
      | Typeof _x -> let _x = o#expression _x in Typeof _x
      | Caml_not _x -> let _x = o#expression _x in Caml_not _x
      | Js_not _x -> let _x = o#expression _x in Js_not _x
      | String_of_small_int_array _x ->
          let _x = o#expression _x in String_of_small_int_array _x
      | Json_stringify _x -> let _x = o#expression _x in Json_stringify _x
      | Anything_to_string _x ->
          let _x = o#expression _x in Anything_to_string _x
      | Dump (_x, _x_i1) ->
          let _x = o#unknown _x in
          let _x_i1 = o#list (fun o -> o#expression) _x_i1
          in Dump (_x, _x_i1)
      | Seq (_x, _x_i1) ->
          let _x = o#expression _x in
          let _x_i1 = o#expression _x_i1 in Seq (_x, _x_i1)
      | Cond (_x, _x_i1, _x_i2) ->
          let _x = o#expression _x in
          let _x_i1 = o#expression _x_i1 in
          let _x_i2 = o#expression _x_i2 in Cond (_x, _x_i1, _x_i2)
      | Bin (_x, _x_i1, _x_i2) ->
          let _x = o#binop _x in
          let _x_i1 = o#expression _x_i1 in
          let _x_i2 = o#expression _x_i2 in Bin (_x, _x_i1, _x_i2)
      | FlatCall (_x, _x_i1) ->
          let _x = o#expression _x in
          let _x_i1 = o#expression _x_i1 in FlatCall (_x, _x_i1)
      | Bind (_x, _x_i1) ->
          let _x = o#expression _x in
          let _x_i1 = o#expression _x_i1 in Bind (_x, _x_i1)
      | Call (_x, _x_i1, _x_i2) ->
          let _x = o#expression _x in
          let _x_i1 = o#list (fun o -> o#expression) _x_i1 in
          let _x_i2 = o#unknown _x_i2 in Call (_x, _x_i1, _x_i2)
      | String_access (_x, _x_i1) ->
          let _x = o#expression _x in
          let _x_i1 = o#expression _x_i1 in String_access (_x, _x_i1)
      | Access (_x, _x_i1) ->
          let _x = o#expression _x in
          let _x_i1 = o#expression _x_i1 in Access (_x, _x_i1)
      | Dot (_x, _x_i1, _x_i2) ->
          let _x = o#expression _x in
          let _x_i1 = o#string _x_i1 in
          let _x_i2 = o#bool _x_i2 in Dot (_x, _x_i1, _x_i2)
      | New (_x, _x_i1) ->
          let _x = o#expression _x in
          let _x_i1 =
            o#option (fun o -> o#list (fun o -> o#expression)) _x_i1
          in New (_x, _x_i1)
      | Var _x -> let _x = o#vident _x in Var _x
      | Fun (_x, _x_i1, _x_i2, _x_i3) ->
          let _x = o#bool _x in
          let _x_i1 = o#list (fun o -> o#ident) _x_i1 in
          let _x_i2 = o#block _x_i2 in
          let _x_i3 = o#unknown _x_i3 in Fun (_x, _x_i1, _x_i2, _x_i3)
      | Str (_x, _x_i1) ->
          let _x = o#bool _x in let _x_i1 = o#string _x_i1 in Str (_x, _x_i1)
      | Unicode _x -> let _x = o#string _x in Unicode _x
      | Raw_js_code (_x, _x_i1) ->
          let _x = o#string _x in
          let _x_i1 = o#code_info _x_i1 in Raw_js_code (_x, _x_i1)
      | Array (_x, _x_i1) ->
          let _x = o#list (fun o -> o#expression) _x in
          let _x_i1 = o#mutable_flag _x_i1 in Array (_x, _x_i1)
      | Caml_block (_x, _x_i1, _x_i2, _x_i3) ->
          let _x = o#list (fun o -> o#expression) _x in
          let _x_i1 = o#mutable_flag _x_i1 in
          let _x_i2 = o#expression _x_i2 in
          let _x_i3 = o#tag_info _x_i3
          in Caml_block (_x, _x_i1, _x_i2, _x_i3)
      | Caml_uninitialized_obj (_x, _x_i1) ->
          let _x = o#expression _x in
          let _x_i1 = o#expression _x_i1
          in Caml_uninitialized_obj (_x, _x_i1)
      | Caml_block_tag _x -> let _x = o#expression _x in Caml_block_tag _x
      | Caml_block_set_tag (_x, _x_i1) ->
          let _x = o#expression _x in
          let _x_i1 = o#expression _x_i1 in Caml_block_set_tag (_x, _x_i1)
      | Caml_block_set_length (_x, _x_i1) ->
          let _x = o#expression _x in
          let _x_i1 = o#expression _x_i1 in Caml_block_set_length (_x, _x_i1)
      | Number _x -> let _x = o#number _x in Number _x
      | Object _x -> let _x = o#property_map _x in Object _x
    method expression : expression -> expression =
      fun { expression_desc = _x; comment = _x_i1 } ->
        let _x = o#expression_desc _x in
        let _x_i1 = o#option (fun o -> o#string) _x_i1
        in { expression_desc = _x; comment = _x_i1; }
    method exports : exports -> exports = o#unknown
    method exception_ident : exception_ident -> exception_ident = o#ident
    method deps_program : deps_program -> deps_program =
      fun { program = _x; modules = _x_i1; side_effect = _x_i2 } ->
        let _x = o#program _x in
        let _x_i1 = o#required_modules _x_i1 in
        let _x_i2 = o#option (fun o -> o#string) _x_i2
        in { program = _x; modules = _x_i1; side_effect = _x_i2; }
    method code_info : code_info -> code_info = o#unknown
    method case_clause :
      (* since in ocaml, it's expression oriented langauge, [return] in
    general has no jumps, it only happens when we do 
    tailcall conversion, in that case there is a jump.
    However, currently  a single [break] is good to cover
    our compilation strategy 

    Attention: we should not insert [break] arbitrarily, otherwise 
    it would break the semantics
    A more robust signature would be 
    {[ goto : label option ; ]}
  *)
        'a 'a_out.
        ('self_type -> 'a -> 'a_out) -> 'a case_clause -> 'a_out case_clause =
      fun _f_a { case = _x; body = _x_i1 } ->
        let _x = _f_a o _x in
        let _x_i1 =
          (fun (_x, _x_i1) ->
             let _x = o#block _x in let _x_i1 = o#bool _x_i1 in (_x, _x_i1))
            _x_i1
        in { case = _x; body = _x_i1; }
    method block : block -> block = (* true means break *)
      (* TODO: For efficency: block should not be a list, it should be able to 
   be concatenated in both ways 
 *)
      o#list (fun o -> o#statement)
    method binop : binop -> binop = o#unknown
    method unknown : 'a. 'a -> 'a = fun x -> x
  end
  


end
module Js_pass_flatten : sig 
#1 "js_pass_flatten.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** A pass converting nested js statement into a flatten visual appearance 

    Note this module is used to convert some nested expressions to flat statements, 
    in general, it's more human readable, and since it generate flat statements, we can spot
    some inline opportunities for the produced statemetns, 
    (inline) expressions inside a nested expression would generate ugly code.

    Since we are aiming to flatten expressions, we should avoid some smart constructors in {!Js_helper}, 
    it  tries to spit out expression istead of statements if it can
*)

val program : J.program -> J.program

end = struct
#1 "js_pass_flatten.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








module E = Js_exp_make
module S = Js_stmt_make 

let flatten_map = 
  object(self)
    inherit Js_map.map as super
    method! statement x = 
      match x.statement_desc with 
      |  Exp ({expression_desc = Seq _; _} as v) ->
          (S.block ( List.rev_map (self#statement) (Js_analyzer.rev_flatten_seq v )))
      |  Exp ({expression_desc = Cond(a,b,c); comment} ) -> 
          (* Note that we need apply [self#statement] recursively *)
          { statement_desc = If (a, [ self#statement (S.exp b)],  
                                 Some [ self#statement (S.exp c)]); comment}
          (* CHECK? Trick semantics difference *)
          (* super#statement (S.if_ a ([ (\* self#statement *\) (S.exp b) ]) *)
          (*     ~else_:([self#statement (S.exp c)]) *)
          (*                 ) *)

      |  Exp ({expression_desc = Bin(Eq, a, ({expression_desc = Seq _; _ } as v)); _} )
        ->
          let block = Js_analyzer.rev_flatten_seq v in
          begin match block with
          | {statement_desc = Exp last_one ; _} :: rest_rev
            ->  
              S.block (Ext_list.rev_map_append (self#statement) rest_rev 
                [self#statement @@ S.exp (E.assign a  last_one)])
                (* TODO: here we introduce a block, should avoid it *)
              (* super#statement *)
              (*   (S.block (List.rev_append rest_rev [S.exp (E.assign a  last_one)])) *)
          | _ ->
              assert false
          end
      | Return ( {return_value = {expression_desc = Cond (a,b,c);  comment}}) 
        -> 
          { statement_desc = If (a, [self#statement (S.return b)],  
                                 Some [ self#statement (S.return c)]); comment}

      | Return ({return_value = {expression_desc = Seq _; _} as v}) ->
          let block = Js_analyzer.rev_flatten_seq v  in
          begin match block with
          | {statement_desc = Exp last_one ; _} :: rest_rev
            ->  
              super#statement 
                (S.block (Ext_list.rev_map_append (self#statement) rest_rev [S.return last_one]))
          | _ -> assert false
          end
      | Block [x]
          -> 
            self#statement x 
      | _ -> super#statement x 

    method! block b =
      match b with
      | {statement_desc = Block bs } :: rest ->
          self#block ( bs @  rest)
      | x::rest  
        -> 
          self#statement x :: self#block rest
      | [] -> []
  end

let program ( x : J.program) = flatten_map # program x 

end
module Js_pass_flatten_and_mark_dead : sig 
#1 "js_pass_flatten_and_mark_dead.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** A pass to mark some declarations in JS IR as dead code *)

val program :  J.program -> J.program

end = struct
#1 "js_pass_flatten_and_mark_dead.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








module E = Js_exp_make
module S = Js_stmt_make

class count  var = object (self : 'self)
  val mutable appears = 0
  inherit Js_fold.fold as super
  method! ident  x =
    (if Ident.same x var then
      appears <- appears + 1); 
    self
  method get_appears = appears 
end

(* rewrite return for current block, but don't go into
   inner function, mostly for inlinning
 *)
class rewrite_return ?return_value ()=
  let mk_return  = 
    match return_value with 
    | None -> fun e -> S.exp e 
    | Some ident -> fun e -> S.define ~kind:Variable ident e in
  object (self : 'self)
    inherit Js_map.map as super
    method! statement x =
      match x.statement_desc with 
      | Return {return_value = e} -> 
          mk_return e 
      | _ -> super#statement x 
    method! expression x = x (* don't go inside *)
  end  

(* 
    HERE we are using an object , so make sure to clean it up, 
    remove stale cache
 *)
let mark_dead = object (self)
  inherit Js_fold.fold as super

  val mutable name = ""

  val mutable ident_use_stats : [`Info of J.ident_info | `Recursive] Ident_hashtbl.t
      = Ident_hashtbl.create 17
  
  val mutable export_set : Ident_set.t = Ident_set.empty    

  method mark_not_dead ident =
    match Ident_hashtbl.find_opt ident_use_stats ident with
    | None -> (* First time *)
        Ident_hashtbl.add ident_use_stats ident `Recursive 
        (* recursive identifiers *)
    | Some `Recursive
      -> ()
    | Some (`Info x) ->  Js_op_util.update_used_stats x Used 

  method scan b ident (ident_info : J.ident_info) = 
    let is_export = Ident_set.mem ident export_set in
    let () = 
      if is_export (* && false *) then 
        Js_op_util.update_used_stats ident_info Exported 
    in
    match Ident_hashtbl.find_opt ident_use_stats ident with
    | Some (`Recursive) -> 
        Js_op_util.update_used_stats ident_info Used; 
        Ident_hashtbl.replace ident_use_stats ident (`Info ident_info)
    | Some (`Info _) ->  
        (** check [camlinternlFormat,box_type] inlined twice 
            FIXME: seems we have redeclared identifiers
         *)
      if Js_config.get_diagnose () then 
        Ext_log.warn __LOC__ "@[%s$%d in %s@]" ident.name ident.stamp name
        (* assert false *)
    | None ->  (* First time *)
        Ident_hashtbl.add ident_use_stats ident (`Info ident_info);
        Js_op_util.update_used_stats ident_info 
          (if b then Scanning_pure else Scanning_non_pure)
  method promote_dead = 
    Ident_hashtbl.iter (fun _id (info : [`Info of J.ident_info  | `Recursive]) ->
      match info  with 
      | `Info ({used_stats = Scanning_pure} as info) -> 
          Js_op_util.update_used_stats info Dead_pure
      | `Info ({used_stats = Scanning_non_pure} as info) -> 
          Js_op_util.update_used_stats info Dead_non_pure
      | _ -> ())
      ident_use_stats;
    Ident_hashtbl.clear ident_use_stats (* clear to make it re-entrant *)

  method! program x = 
    export_set <- x.export_set ; 
    name <- x.name;
    super#program x 

  method! ident x = 
    self#mark_not_dead x ; self 

  method! variable_declaration vd =  
    match vd with 
    | { ident_info = {used_stats = Dead_pure } ; _}
      -> self
    | { ident_info = {used_stats = Dead_non_pure } ; value } -> 
      begin match value with
      | None -> self
      | Some x -> self#expression x 
      end
    | {ident; ident_info ; value ; _} -> 
      let pure = 
        match value with 
        | None  -> false 
        | Some x -> ignore (self#expression x); Js_analyzer.no_side_effect_expression x in
      self#scan pure ident ident_info; self
end

let mark_dead_code js = 
  let _ =  (mark_dead#program js) in 
  mark_dead#promote_dead;
  js
        
(*
   when we do optmizations, we might need track it will break invariant 
   of other optimizations, especially for [mutable] meta data, 
   for example, this pass will break [closure] information, 
   it should be done before closure pass (even it does not use closure information)

   Take away, it is really hard to change the code while collecting some information..
   we should always collect info in a single pass

   Note that, we should avoid reuse object, i.e,
   {[
     let v = 
       object 
       end      
   ]}   
   Since user may use `bsc.exe -c xx.ml xy.ml xz.ml` and we need clean up state
 *)
let subst_map name = object (self)
  inherit Js_map.map as super

  val mutable substitution :  J.expression Ident_hashtbl.t= Ident_hashtbl.create 17 

  method get_substitution = substitution

  method add_substitue (ident : Ident.t) (e:J.expression) = 
    Ident_hashtbl.replace  substitution ident e

  method! statement v = 
    match v.statement_desc with 
    | Variable ({ident; ident_info = {used_stats = Dead_pure } ; _}) -> 
      {v with statement_desc = Block []}
    | Variable ({ident; ident_info = {used_stats = Dead_non_pure } ; value = None}) -> 
      {v with statement_desc = Block []}
    | Variable ({ident; ident_info = {used_stats = Dead_non_pure } ; value = Some x}) -> 
      {v with statement_desc =  (Exp x)}

    | Variable ({ ident ; 
                  property = (Strict | StrictOpt | Alias);
                  value = Some (
                      {expression_desc = (Caml_block ( _:: _ :: _ as ls, Immutable, tag, tag_info) 
                                         )} as block)
                } as variable) -> 
      (** If we do this, we should prevent incorrect inlning to inline it into an array :) 
          do it only when block size is larger than one
      *)

      let (_, e, bindings) = 
        List.fold_left 
          (fun  (i,e,  acc) (x : J.expression) -> 
             match x.expression_desc with 
             | J.Var _ | Number _ | Str _ 
               -> 
               (i + 1, x :: e, acc)
             | _ ->                
               (* tradeoff, 
                   when the block is small, it does not make 
                   sense too much -- 
                   bottomline, when the block size is one, no need to do 
                   this
               *)
               let v' = self#expression x in 
               let match_id =
                 Ext_ident.create
                   (Printf.sprintf "%s_%03d"
                      ident.name i) in
               (i + 1, E.var match_id :: e, (match_id, v') :: acc)               
          ) (0, [], []) ls  in
      let e = 
        {block with 
         expression_desc = 
           Caml_block(List.rev e, Immutable, tag, tag_info)
        } in
      let () = self#add_substitue ident e in
      (* let bindings =  !bindings in *)
      let original_statement = 
        { v with 
          statement_desc = Variable {variable with value =  Some   e }
        } in
      begin match bindings with 
        | [] -> 
          original_statement
        | _ ->  
          (* self#add_substitue ident e ; *)
          S.block @@
          (Ext_list.rev_map_acc [original_statement] (fun (id,v) -> 
               S.define ~kind:Strict id v)  bindings  )
      end
    | _ -> super#statement v 

  method! expression x =
    match x.expression_desc with 
    | Access ({expression_desc = Var (Id (id))}, 
              {expression_desc = Number (Int {i; _})}) -> 
      begin match Ident_hashtbl.find_opt self#get_substitution id with 
        | Some {expression_desc = Caml_block (ls, Immutable, _, _) } 
          -> 
          (* user program can be wrong, we should not 
             turn a runtime crash into compile time crash : )
          *)          
          begin match List.nth ls (Int32.to_int i) with 
            | {expression_desc = J.Var _ | Number _ | Str _ } as x 
              -> x 
            | exception _ ->
              begin
                Ext_log.err __LOC__ "suspcious code %s when compiling %s@."
                  (Printf.sprintf "%s/%d" id.name id.stamp)
                  name  ;
                super#expression x ;
              end
            | _ -> 
              (** we can do here, however, we should 
                  be careful that it can only be done 
                  when it's accessed once and the array is not escaped,
                  otherwise, we redo the computation,
                  or even better, we re-order

                  {[
                    var match = [/* tuple */0,Pervasives.string_of_int(f(1,2,3)),f3(2),arr];

                        var a = match[1];

                          var b = match[2];

                  ]}

                  --->

                  {[
                    var match$1 = Pervasives.string_of_int(f(1,2,3));
                        var match$2 = f3(2);
                            var match = [/* tuple */0,match$1,match$2,arr];
                                var a = match$1;
                                  var b = match$2;
                                    var arr = arr; 
                  ]}

                  --> 
                  since match$1 (after match is eliminated) is only called once 
                  {[
                    var a = Pervasives.string_of_int(f(1,2,3));
                    var b = f3(2);
                    var arr = arr; 
                  ]}

              *)
              super#expression x 
          end
        | (Some _ | None) -> super#expression x 
      end
    | _ -> super#expression x
end 

(* Top down or bottom up ?*)
(* A pass to support nullary argument in JS 
    Nullary information can be done in one pass, 
    there is no need to add another pass
 *)

let program  (js : J.program) = 
  js 
  |> (subst_map js.name )#program
  |> mark_dead_code
  (* |> mark_dead_code *)
  (* mark dead code twice does have effect in some cases, however, we disabled it 
    since the benefit is not obvious
   *)

end
module Js_pass_scope : sig 
#1 "js_pass_scope.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** A module to do scope analysis over JS IR *)

val program : J.program ->  Ident_set.t

end = struct
#1 "js_pass_scope.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








let _l idents = 
  Ext_log.err __LOC__ "hey .. %s@." 
    (String.concat "," @@ Ext_list.map (fun  i -> i.Ident.name ) idents) 

(* 

    Base line 
    {[
     for i = 1 to n do (function (i){...}(i))
     done
       (* This is okay, since all ocaml follow the lexical scope, 
          for generrated code too (* TODO: check *)
        *)
    ]}

  For nested loops 
  {[
   for i = 0 to n do 
     for j = 0 to n do 
       arrr.(j)<- ()=>{ i}
     done
   done
 ]}
    Three kind of variables  (defined in the loop scope)
    1. loop mutable variables 
       As long as variables change per iteration, defined in a loop (in the same loop)
        and captured by a closure
       the loop, iff  be lexically scoped 
       Tailcall parameters are considered defined inside the loop
    - unless it's defined 
       outside all the loops - note that for nested loops, if it's defined 
       in the outerloop and captured by the inner loop, 
       it still has to be lexically scoped. 

       How do we detect whether it is loop invariant or not 
       - depend on loop variant 
       - depend on mutuable valuse
       - non pure (function call)

       so we need collect mutable variables 
       1. from lambda + loop (for/i) + tailcall params
       2. defined in the loop and can not determine it is invariant  
          in such cases we can determine it's immutable
          1. const 
          2. only depend on immutable values and no function call?

    ## The following would take advantage of nested loops 
    2. loop invariant observable varaibles 
        {[ 
         var x = (console.log(3), 32)
        ]}
    3. loop invariant non-observable variables 

    Invariant: 
    loop invariant (observable or not) variables can not depend on 
    loop mutable values so that once we detect loop Invariant variables 
    all its dependency are loop invariant as well, so we can do loop 
    Invariant code motion.
    
    TODO:
    loop invariant can be layered, it will be loop invariant 
    in the inner layer while loop variant in the outer layer.
    {[
    for i = 0 to 10 do 
      for j  = 10 do 
        let  k0 = param * 100 in (* loop invariant *)
        let  k1 = i * i in (* inner loop invariant, loop variant *)
        let  k2 = j * i in (* variant *)
        ..
      done 
    done 
    ]}
*)

let scope_pass  = 
  object(self)
    inherit Js_fold.fold as super

    val  defined_idents = Ident_set.empty 
        
    (** [used_idents] 
        does not contain locally defined idents *)
    val  used_idents = Ident_set.empty 
    (** we need collect mutable values and loop defined varaibles *)    
    val loop_mutable_values = Ident_set.empty 

    val mutable_values = Ident_set.empty      

    val closured_idents = Ident_set.empty 

    (** check if in loop or not *)    
    val in_loop = false 

    method get_in_loop = in_loop

    method get_defined_idents = defined_idents

    method get_used_idents = used_idents

    method get_loop_mutable_values = loop_mutable_values 

    method get_mutable_values = mutable_values 

    method get_closured_idents = closured_idents 

    method with_in_loop b = 
      if b = self#get_in_loop then self
      else {< in_loop = b >}
     (* Since it's loop mutable variable, for sure
         it is mutable variable
         *)       
    method with_loop_mutable_values b = 
      {< loop_mutable_values =  b >}

    method add_loop_mutable_variable id = 
      {< loop_mutable_values = Ident_set.add id loop_mutable_values;
         mutable_values = Ident_set.add id mutable_values
         >}

    method add_mutable_variable id = 
      {< mutable_values = Ident_set.add id mutable_values >}

    method add_defined_ident ident = 
      {< defined_idents = Ident_set.add ident defined_idents >} 

    method! expression x = 
      match x.expression_desc with 
      | Fun (_method_, params, block , env) -> 
        (* Function is the only place to introduce a new scope in 
            ES5
            TODO: check 
            {[ try .. catch(exn) {.. }]}
            what's the scope of exn
        *)
        (* Note that [used_idents] is not complete
            it ignores some locally defined idents *)
        let param_set = Ident_set.of_list params in
        let obj =  {<defined_idents = Ident_set.empty;
                     (** pass [empty]
                         so that we can check which parameter was actually used *)
                     used_idents = Ident_set.empty ;
                     in_loop = false;
                     loop_mutable_values = Ident_set.empty;
                     mutable_values = Ident_set.of_list (Js_fun_env.get_mutable_params params env) ; 
                     closured_idents = Ident_set.empty; (* think about nested function*)
                   >} # block block in
        let defined_idents', used_idents' = 
          obj#get_defined_idents, obj#get_used_idents  in
        (* mark which param is used *)
        params |> List.iteri 
          (fun i v -> 
             if not (Ident_set.mem v used_idents') then 
               Js_fun_env.mark_unused env i) ;
        let closured_idents' =  (* pass param_set down *)
          Ident_set.(diff used_idents' (union defined_idents' param_set )) in

        (* Noe that we don't know which variables are exactly mutable yet ..
           due to the recursive thing
         *)
        Js_fun_env.set_unbounded env closured_idents'   ; 
        let lexical_scopes = Ident_set.(inter closured_idents' self#get_loop_mutable_values) in
        Js_fun_env.set_lexical_scope env lexical_scopes;
        (* tailcall , note that these varibles are used in another pass *)
        {< used_idents = 
             Ident_set.union used_idents closured_idents' ;
           (* There is a bug in ocaml -dsource*)           
           closured_idents = Ident_set.union closured_idents closured_idents'
        >}
      | _ -> super#expression x 
            (* TODO: most variables are immutable *)

    method! variable_declaration x = 
      match x with
      | { ident ; value; property  }  -> 
        let obj = 
          (match self#get_in_loop, property with 
           | true, Variable 
             -> 
             self#add_loop_mutable_variable ident 
           | true, (Strict | StrictOpt | Alias)
           (* Not real true immutable in javascript 
               since it's in the loop 

               TODO: we should also 
           *)
             -> 
             begin match value with 
               | None -> self#add_loop_mutable_variable ident
               (* TODO: Check why assertion failure *)
               (* self#add_loop_mutable_variable ident *) (* assert false *)
               | Some x
                 ->
                 (** 
                     when x is an immediate immutable value, 
                     (like integer .. )
                     not a reference, it should be Immutable
                     or string, 
                     type system might help here
                     TODO:
                 *)
                 match x.expression_desc with
                 | Fun _  | Number _ | Str _ 
                   -> self 
                 | _ -> 
                   (* if Ident_set.(is_empty @@ *)
                   (*   inter self#get_mutable_values  *)
                   (*     ( ({<  *)
                   (*         defined_idents = Ident_set.empty;  *)
                   (*         used_idents = Ident_set.empty; *)
                   (*         >} # expression x) # get_used_idents)) then *)
                   (*   (\* FIXME: still need to check expression is pure or not*\) *)
                   (*   self *)
                   (* else  *)
                   self#add_loop_mutable_variable ident
             end
           | false, Variable
             -> 
             self#add_mutable_variable ident      
           | false, (Strict | StrictOpt | Alias)
             -> self
          )#add_defined_ident ident
        in
        begin match value with 
          | None -> obj 
          | Some x -> obj # expression x  
        end 

        
    method! statement x = 
      match x.statement_desc with 
      | ForRange  (_,_, loop_id, _,_,a_env) as y -> (* TODO: simplify definition of For *)
          let obj = 
            {< in_loop = true ;
               loop_mutable_values = Ident_set.singleton loop_id ;
               used_idents = Ident_set.empty; (* TODO: if unused, can we generate better code? *)
               defined_idents = Ident_set.singleton loop_id ;
               closured_idents = Ident_set.empty (* Think about nested for blocks *)
                 (* Invariant: Finish id is never used *)
                 >}
              # statement_desc y in

          let defined_idents', used_idents', closured_idents' = 
            obj#get_defined_idents, obj#get_used_idents, obj#get_closured_idents in


          let lexical_scope =  Ident_set.(inter (diff closured_idents' defined_idents') self#get_loop_mutable_values) in
          let () = Js_closure.set_lexical_scope a_env lexical_scope in
          (* set scope *)
          {< used_idents = Ident_set.union used_idents used_idents';
             (* walk around ocaml -dsource bug 
                {[ 
                  Ident_set.(union used_idents used_idents)                  
                ]}                
             *)             
             defined_idents = Ident_set.union defined_idents defined_idents';
             (* TODO: if we our generated code also follow lexical scope,
                this is not necessary ;
                [varaibles] are mutable or not is known at definition
              *)
             closured_idents = Ident_set.union closured_idents lexical_scope
             >}

      | While (_label,pred,body, _env) ->  
          (((self#expression pred)#with_in_loop true) # block  body )
            #with_in_loop (self#get_in_loop)
      | _ -> 
          super#statement x 

    method! exception_ident x = 
      (* we can not simply skip it, since it can be used 
          TODO: check loop exception
          (loop {
          excption(i){
          () => {i}
          } 
          })
       *)
      {< used_idents = Ident_set.add x used_idents;
         defined_idents = Ident_set.add x defined_idents
         >}
    method! for_ident x = {< loop_mutable_values = Ident_set.add x loop_mutable_values >}

    method! ident x = 
      if Ident_set.mem x defined_idents then 
        self
      else {< used_idents = Ident_set.add x used_idents >}
  end

let program js = 
  (scope_pass # program js ) # get_loop_mutable_values

end
module Js_pass_tailcall_inline : sig 
#1 "js_pass_tailcall_inline.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** This pass detect functions used once and if it is used in used
    in the tail position, it will get inlined, this will help 
    remove some common use cases like This
    {[
      let length x = 
        let rec aux n x = 
          match x with 
          | [] -> n 
          | _ :: rest -> aux (n + 1) rest in
        aux 0 x         
    ]} 
*)

val tailcall_inline : J.program -> J.program 

end = struct
#1 "js_pass_tailcall_inline.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






(* When we inline a function call, if we don't do a beta-reduction immediately, there is 
   a chance that it is ignored, (we can not assume that each pass is robust enough)

   After we do inlining, it makes sense to do another constant folding and propogation 
 *)

(* Check: shall we inline functions with while loop? if it is used only once, 
   it makes sense to inline it
*)

module S = Js_stmt_make
module E = Js_exp_make


(** Update ident info use cases, it is a non pure function, 
    it will annotate [program] with some meta data
    TODO: Ident Hashtbl could be improved, 
    since in this case it can not be global?  

 *)
let count_collects () = 
  object (self)
    inherit Js_fold.fold as super
    (* collect used status*)
    val stats : int ref Ident_hashtbl.t = Ident_hashtbl.create 83
    (* collect all def sites *)
    val defined_idents : J.variable_declaration Ident_hashtbl.t = Ident_hashtbl.create 83

    val mutable export_set  : Ident_set.t = Ident_set.empty
    val mutable name : string = ""

    method add_use id = 
      match Ident_hashtbl.find_opt stats id with
      | None -> Ident_hashtbl.add stats id (ref 1)
      | Some v -> incr v 
    method! program x = 
      export_set <- x.export_set ; 
      name <- x.name;
      super#program x
    method! variable_declaration 
        ({ident; value ; property  ; ident_info }  as v)
      =  
        Ident_hashtbl.add defined_idents ident v; 
        match value with 
        | None
          -> 
          self
        | Some x
          -> self#expression x 
    method! ident id = self#add_use id; self
    method get_stats = 
      Ident_hashtbl.iter (fun ident (v : J.variable_declaration) -> 
          if Ident_set.mem ident export_set then 
            Js_op_util.update_used_stats v.ident_info Exported
          else 
            let pure = 
              match v.value  with 
              | None -> false  (* can not happen *)
              | Some x -> Js_analyzer.no_side_effect_expression x  
            in
            match Ident_hashtbl.find_opt stats ident with 
              | None -> 
                Js_op_util.update_used_stats v.ident_info 
                  (if pure then Dead_pure else Dead_non_pure)
              | Some num -> 
                if !num = 1 then 
                  Js_op_util.update_used_stats v.ident_info 
                    (if pure then Once_pure else Used) 
        ) defined_idents; defined_idents
  end


let get_stats program
  =  ((count_collects ()) #program program) #get_stats


(* 1. recursive value ? let rec x = 1 :: x
    non-terminating
    2. duplicative identifiers ..
    remove it at the same time is a bit unsafe,
    since we have to guarantee that the one use
    case is substituted
    we already have this? in [defined_idents]
*)

(** There is a side effect when traversing dead code, since 
   we assume that substitue a node would mark a node as dead node,
  
    so if we traverse a dead node, this would get a wrong result.
   it does happen in such scenario
   {[
     let generic_basename is_dir_sep current_dir_name name =
       let rec find_end n =
         if n < 0 then String.sub name 0 1
         else if is_dir_sep name n then find_end (n - 1)
         else find_beg n (n + 1)
       and find_beg n p =
         if n < 0 then String.sub name 0 p
         else if is_dir_sep name n then String.sub name (n + 1) (p - n - 1)
         else find_beg (n - 1) p
       in
       if name = ""
       then current_dir_name
       else find_end (String.length name - 1)
   ]}
   [find_beg] can potentially be expanded in [find_end] and in [find_end]'s expansion, 
   if the order is not correct, or even worse, only the wrong one [find_beg] in [find_end] get expanded 
   (when we forget to recursive apply), then some code non-dead [find_beg] will be marked as dead, 
   while it is still called 
*)
let subst name export_set stats  = 
  object (self)
    inherit Js_map.map as super
    method! statement st = 
      match st with 
      | {statement_desc =
           Variable 
             {value = _ ;
              ident_info = {used_stats = Dead_pure}
             } 
        ; comment = _}
        ->
        S.block []
      | {statement_desc = 
           Variable { ident_info = {used_stats = Dead_non_pure} ;
                      value = Some v  ; _ } 
        ; _}
        -> S.exp v
      | _ -> super#statement st 
    method! variable_declaration 
        ({ident; value ; property  ; ident_info }  as v)
      =  
      (* TODO: replacement is a bit shaky, the problem is the lambda we stored is
         not consistent after we did some subsititution, and the dead code removal
         does rely on this (otherwise, when you do beta-reduction you have to regenerate names)
      *)
      let v = super # variable_declaration v in
      Ident_hashtbl.add stats ident v; (* see #278 before changes *)
      v
    method! block bs = 
      match bs with
      | ({statement_desc = 
            Variable ({value =
                         Some ({expression_desc = Fun _; _ } as v )
                      } as vd) ; comment = _} as st) :: rest  -> 
        let is_export = Ident_set.mem vd.ident export_set in
        if is_export then 
          self#statement st :: self#block rest 
        else 
          begin 
            match Ident_hashtbl.find_opt stats vd.ident with 
            (* TODO: could be improved as [mem] *)
            | None -> 
              if Js_analyzer.no_side_effect_expression v 
              then S.exp v  :: self#block rest 
              else self#block rest 

            | Some _ -> self#statement st  :: self#block rest 
          end

      | {statement_desc = 
           Return {return_value = 
                     {expression_desc = 
                        Call({expression_desc = Var (Id id)},args,_info)}} }
        as st 
           :: rest 
        -> 
        begin match Ident_hashtbl.find_opt stats id with 

          | Some ({ value = 
                Some {expression_desc = Fun (false, params, block, _env) ; comment = _}; 
              (*TODO: don't inline method tail call yet, 
                [this] semantics are weird 
              *)              
              property = (Alias | StrictOpt | Strict);
              ident_info = {used_stats = Once_pure };
              ident = _
            } as v)
            when Ext_list.same_length params args 
            -> 
            (* Ext_log.dwarn  __LOC__ "%s is dead \n %s " id.name  *)
            (*   (Js_dump.string_of_block [st]); *)
            Js_op_util.update_used_stats v.ident_info Dead_pure;
            let block  = 
              List.fold_right2 (fun param arg acc ->  S.define ~kind:Variable param arg :: acc)
                params args  ( self#block block) (* see #278 before changes*)
                                
            in
            (* Mark a function as dead means it will never be scanned, 
               here we inline the function
            *)
            Ext_list.append block @@ self#block rest
          | (None | Some _) ->
            self#statement st :: self#block rest
        end
      | x :: xs 
        ->
        self#statement x :: self#block xs
      | [] 
        -> 
        []

  end


let tailcall_inline (program : J.program) = 
  let _stats = get_stats program in
  let _export_set = program.export_set in
  program
  |> (subst program.name _export_set _stats )# program
  (* |> pass_beta #program *)
    

end
module Js_shake : sig 
#1 "js_shake.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** A module to shake JS IR
   
    Tree shaking is not going to change the closure 
 *)

val shake_program : J.program -> J.program

end = struct
#1 "js_shake.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** we also need make it complete 
 *)
let get_initial_exports 
    count_non_variable_declaration_statement 
    (export_set : Ident_set.t) (block : J.block ) = 
  let result = List.fold_left 
    (fun acc (st : J.statement) -> 
      match st.statement_desc with
      | Variable {ident ; value; _} ->
          if Ident_set.mem ident acc then 
            begin match value with
            | None -> acc  
            | Some x -> 
              (* If not a function, we have to calcuate again and again 
                  TODO: add hashtbl for a cache
               *)
                Ident_set.(
                union (Js_analyzer.free_variables_of_expression empty empty x) acc)
            end
          else 
            begin match value with
            | None -> acc 
            | Some x -> 
                if Js_analyzer.no_side_effect_expression x then acc 
                else 
                  Ident_set.(
                  union (Js_analyzer.free_variables_of_expression empty empty x) 
                    (add ident acc))
            end
      | _ -> 
          (* recalcuate again and again ... *)
          if Js_analyzer.no_side_effect_statement st || (not count_non_variable_declaration_statement)
          then acc
          else Ident_set.(union (Js_analyzer.free_variables_of_statement empty empty st) acc)
    ) export_set block  in result, Ident_set.(diff result export_set)

let shake_program (program : J.program) = 
  let debug_file = "pervasives.ml" in

  let _d () = 
    if Ext_string.ends_with program.name  debug_file then 
      Ext_log.err __LOC__ "@[%s@]@." program.name 
  in
  let shake_block block export_set = 
    let block = List.rev @@ Js_analyzer.rev_toplevel_flatten block in 
    let  loop block export_set : Ident_set.t = 
      let rec aux acc block = 
        let result, diff = get_initial_exports false acc block   in
        (* let _d ()  =  *)
        (*   if Ext_string.ends_with program.name  debug_file then  *)
        (*     begin *)
        (*       Ext_log.err "@[%a@]@." Ident_set.print result  ; *)
        (*     end *)
        (* in *)
        if Ident_set.is_empty diff then 
          result
        else 
          aux result block in
      let first_iteration, delta  = get_initial_exports true export_set block  in
      (* let _d ()  =  *)
      (*   if Ext_string.ends_with program.name  debug_file then  *)
      (*   begin   *)
      (*     Ext_log.err "@[<v>%a@ %a@]@." *)
      (*       Ident_set.print first_iteration   *)
      (*       Ident_set.print delta (\* TODO: optimization, don't add persistent variables *\) *)
      (*       ; *)
      (*     Ext_log.err "init ---- @." *)
      (*   end *)
      (* in *)

      if not @@ Ident_set.is_empty delta then
        aux first_iteration block 
      else first_iteration in

    let really_set = loop block export_set in 
    List.fold_right
      (fun  (st : J.statement) acc -> 
        match st.statement_desc with
        | Variable {ident; value ; _} -> 
            if Ident_set.mem ident really_set  then st:: acc 
            else 
              begin match value with 
              | None -> acc 
              | Some x -> 
                  if Js_analyzer.no_side_effect_expression x then acc
                  else st::acc
              end
        | _ -> if Js_analyzer.no_side_effect_statement st then acc else st::acc
      ) block []
  in

  {program with block = shake_block program.block program.export_set}

end
module Lam_group : sig 
#1 "lam_group.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






type t = 
  | Single of Lam.let_kind  * Ident.t * Lam.t
  | Recursive of (Ident.t * Lam.t) list
  | Nop of Lam.t 





(** Tricky to be complete *)

val pp_group : Env.t -> Format.formatter -> t -> unit

end = struct
#1 "lam_group.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)





(** This is not a recursive type definition *)
type t = 
  | Single of Lam.let_kind  * Ident.t * Lam.t
  | Recursive of (Ident.t * Lam.t) list
  | Nop of Lam.t 


let pp = Format.fprintf 

let str_of_kind (kind : Lam.let_kind) = 
  match kind with 
  | Alias -> "a"
  | Strict -> ""
  | StrictOpt -> "o"
  | Variable -> "v" 

let pp_group env fmt ( x : t) =
  match x with
  | Single (kind, id, lam) ->
    Format.fprintf fmt "@[let@ %a@ =%s@ @[<hv>%a@]@ @]" Ident.print id (str_of_kind kind) 
      (Lam_print.env_lambda env) lam
  | Recursive lst -> 
    List.iter (fun (id,lam) -> 
        Format.fprintf fmt
          "@[let %a@ =r@ %a@ @]" Ident.print id (Lam_print.env_lambda env) lam
      ) lst
  | Nop lam -> Lam_print.env_lambda env fmt lam




end
module Lam_dce : sig 
#1 "lam_dce.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)









(** Dead code eliminatiion on the lambda layer 
*)

val remove : Ident.t list -> Lam_group.t list -> Lam_group.t list

end = struct
#1 "lam_dce.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)











let transitive_closure 
    (initial_idents : Ident.t list) 
    (ident_freevars : Ident_set.t Ident_hashtbl.t) 
  =
  let visited  = Ident_hash_set.create 31 in 
  let rec dfs (id : Ident.t) =
    if Ident_hash_set.mem visited id || Ext_ident.is_js_or_global id  
    then ()
    else 
      begin 
        Ident_hash_set.add visited id;
        match Ident_hashtbl.find_opt ident_freevars id with 
        | None -> 
          Ext_pervasives.failwithf ~loc:__LOC__ "%s/%d not found"  (Ident.name id) (id.Ident.stamp)  
        | Some e -> Ident_set.iter (fun id -> dfs id) e
      end  in 
  List.iter dfs initial_idents;
  visited

let remove export_idents (rest : Lam_group.t list) : Lam_group.t list  = 
  let ident_free_vars :  _ Ident_hashtbl.t = Ident_hashtbl.create 17 in
  (* calculate initial required idents, 
     at the same time, populate dependency set [ident_free_vars]
  *)
  let initial_idents =
    List.fold_left (fun acc (x : Lam_group.t) -> 
        match x with
        | Single(kind, id,lam) ->                   
          begin
            Ident_hashtbl.add ident_free_vars id 
              (Lam.free_variables  lam);
            match kind with
            | Alias | StrictOpt -> acc
            | Strict | Variable -> id :: acc 
          end
        | Recursive bindings -> 
          List.fold_left (fun acc (id,lam) -> 
              Ident_hashtbl.add ident_free_vars id (Lam.free_variables lam);
              match (lam : Lam.t) with
              | Lfunction _ -> acc 
              | _ -> id :: acc
            ) acc bindings 
        | Nop lam ->
          if Lam_analysis.no_side_effects lam then acc
          else 
            (** its free varaibles here will be defined above *)
            Ident_set.fold (fun x acc -> x :: acc )  ( Lam.free_variables lam) acc                
      )  export_idents rest in 
  let visited = transitive_closure initial_idents ident_free_vars in 
  List.fold_left (fun (acc : _ list) (x : Lam_group.t) ->
      match x with 
      | Single(_,id,_) -> 
        if Ident_hash_set.mem visited id  then 
          x :: acc 
        else acc 
      | Nop _ -> x :: acc  
      | Recursive bindings ->
        let b = 
          List.fold_right (fun ((id,_) as v) acc ->
              if Ident_hash_set.mem visited id then 
                v :: acc 
              else
                acc  
            ) bindings [] in            
        match b with 
        | [] -> acc  
        | _ -> (Recursive b) :: acc
    ) [] rest |> List.rev   

  

end
module Lam_stats_util : sig 
#1 "lam_stats_util.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Utilities for lambda analysis *)


val arity_of_var : 
  Lam_stats.t -> 
  Ident.t -> 
  Lam_arity.t

val get_arity :
  Lam_stats.t -> 
  Lam.t ->
  Lam_arity.t






end = struct
#1 "lam_stats_util.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

      
let merge 
    ((n : int ), params as y)
    (x : Lam_arity.t) : Lam_arity.t = 
  match x with 
  | NA -> Determin(false, [y], false)
  | Determin (b,xs,tail) -> Determin (b, y :: xs, tail)


let arity_of_var (meta : Lam_stats.t) (v : Ident.t)  =
    (** for functional parameter, if it is a high order function,
        if it's not from function parameter, we should warn
    *)
    begin 
      match Ident_hashtbl.find_opt meta.ident_tbl v with 
      | Some (FunctionId {arity;_}) -> arity
      | Some _
      | None ->
        (* Format.fprintf Format.err_formatter *)
        (*   "@[%s %a is not function/functor@]@." meta.filename Ident.print v ; *)
        (NA : Lam_arity.t)

    end

(* we need record all aliases -- since not all aliases are eliminated, 
   mostly are toplevel bindings
   We will keep iterating such environment
   If not found, we will return [NA]
*)
let rec get_arity 
    (meta : Lam_stats.t) 
    (lam : Lam.t) : 
  Lam_arity.t = 
  match lam with 
  | Lconst _ -> Determin (true,[], false)
  | Lvar v -> arity_of_var meta v 
  | Llet(_,_,_, l ) -> get_arity meta l 

  (*   begin match Parsetree_util.has_arity prim_attributes with *)
  (*     | Some arity ->  *)
  (*       (\* Ext_log.dwarn __LOC__ "arity %d" arity; *\) *)
  (*       Determin(false, [arity, None], false) *)
  (*     | None -> NA *)
  (*   end *)
  | Lprim {primitive = Pfield (n,_); 
           args =  [ Lglobal_module id  ]; _} ->
    Lam_compile_env.find_and_add_if_not_exist (id, n) meta.env
      ~not_found:(fun _ -> assert false)
      ~found:(fun x -> match x.arity with Single x -> x | Submodule _ -> NA )
  | Lprim {primitive = Pfield (m,_); 
           args =  [ Lprim{primitive = Pfield(n,_); 
            args = [ Lglobal_module id]}  ]
           ; _} ->
    Lam_compile_env.find_and_add_if_not_exist (id, n) meta.env
      ~not_found:(fun _ -> assert false)
      ~found:(fun x -> match x.arity with 
      | Submodule subs -> subs.(m)
      | Single _ -> NA
       )

      
  | Lprim {primitive = Pfield _; _} -> NA (** TODO *)
  | Lprim {primitive = Praise ;  _} -> Determin(true,[], true)
  | Lprim {primitive = Pccall _; _} -> Determin(false, [], false)
  | Lglobal_module _ (* TODO: fix me never going to happen assert false  *)
  | Lprim _  -> Determin(true,[] ,false)
  (* shall we handle primitive in a direct way, 
      since we know all the information
      Invariant: all primitive application is fully applied, 
      since this information  is already available

      -- Check external c functions ?
      -- it's not true for primitives 
      like caml_set_oo_id  or  Lprim (Pmakeblock , [])

      it seems true that primitive is always fully applied, however,
      it can return a function
  *)
  | Lletrec(_, body) ->
    get_arity meta body
  (* | Lapply(Lprim( p, _), _args, _info) -> *)
  (*     Determin(true, [], false) (\** Invariant : primtive application is always complete.. *\) *)

  | Lapply{fn = app;  args; _ } -> (* detect functor application *)
    let fn = get_arity meta app in 
    begin match fn with 
      | NA -> NA 
      | Determin (b, xs, tail ) -> 
        let rec take (xs : _ list) arg_length = 
          match xs with 
          | (x,y) :: xs ->
            if arg_length = x then Lam_arity.Determin (b, xs, tail) 
            else if arg_length > x then
              take xs (arg_length - x)
            else Determin (b, 
                           ((x -  arg_length ), 
                            (match y with
                            | Some y -> Some (Ext_list.drop arg_length y) 
                            | None -> None)) :: xs ,
                           tail)
          | [] -> 
            if tail then Determin(b, [], tail)
            else if not b then 
              NA
            else NA
            (* Actually, you can not have truly deministic arities
               for example [fun x -> x ]
            *)
              (* Ext_pervasives.failwithf ~loc:__LOC__ "%s %s" *)
              (*   (Format.asprintf "%a" pp_arities fn)  *)
              (*   (Lam_util.string_of_lambda lam) *)
        in
        take xs (List.length args) 
    end
  | Lfunction {arity; function_kind; params; body = l} -> 
    merge (arity, Some params)  (get_arity meta l)
  | Lswitch(l, {sw_failaction; 
                sw_consts; 
                sw_blocks;
                sw_numblocks = _;
                sw_numconsts = _;
               }) -> 
    all_lambdas meta (
      let rest = 
        Ext_list.append (sw_consts |> Ext_list.map snd)  (sw_blocks |> Ext_list.map snd ) in
      match sw_failaction with None -> rest | Some x -> x::rest )
  | Lstringswitch(l, sw, d) -> 
    begin match d with 
      | None -> all_lambdas meta (Ext_list.map snd  sw )
      | Some v -> all_lambdas meta (v:: Ext_list.map snd  sw)
    end
  | Lstaticraise _ -> NA (* since it will not be in tail position *)
  | Lstaticcatch(_, _, handler) -> get_arity meta handler
  | Ltrywith(l1, _, l2) -> 
    all_lambdas meta [l1;l2]
  | Lifthenelse(l1, l2, l3) ->
    all_lambdas meta [l2;l3]
  | Lsequence(_, l2) -> get_arity meta l2 
  | Lsend(u, m, o, ll, v) -> NA
  | Lifused(v, l) -> NA 
  | Lwhile _ 
  | Lfor _  
  | Lassign _ -> Determin(true,[], false)

and all_lambdas meta (xs : Lam.t list) = 
  match xs with 
  | y :: ys -> 
    let arity =  get_arity meta y in 
    List.fold_left (fun exist (v : Lam.t) -> 
        match (exist : Lam_arity.t) with 
        | NA -> NA 
        | Determin (b, xs, tail) -> 
          begin 
            match get_arity meta v with 
            | NA -> NA 
            | Determin (u,ys,tail2) -> 
              let rec aux (b,acc) xs ys = 
                match xs,ys with
                | [], [] -> (b, List.rev acc, tail && tail2) 
                | [], y::ys when tail  -> 
                  aux (b,y::acc) [] ys 
                | x::xs, [] when tail2 -> 
                  aux (b,x::acc) [] xs
                | x::xs, y::ys when x = y -> aux (b, (y :: acc)) xs ys 
                | _, _  -> (false, List.rev acc, false) in 
              let (b,acc, tail3)  = aux ( u &&b, []) xs ys in 
              Determin (b,acc, tail3)
          end
      ) arity ys 
  | _ -> assert false 

(*
let dump_exports_arities (meta : Lam_stats.t ) = 
  let fmt = 
    if meta.filename != "" then 
      let cmj_file = Ext_path.chop_extension meta.filename ^ Literals.suffix_cmj in
      let out = open_out cmj_file in   
      Format.formatter_of_out_channel out
    else 
      Format.err_formatter in 
  begin 
    List.iter (fun (i : Ident.t) ->  
      pp fmt "@[%s: %s -> %a@]@." meta.filename i.name 
        pp_arities  (get_arity meta (Lvar i))
              ) meta.exports
  end
*)


end
module Lam_coercion : sig 
#1 "lam_coercion.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


type t = {
  export_list : Ident.t list ;
  export_set : Ident_set.t;
  export_map : Lam.t Ident_map.t ; 
  groups : Lam_group.t list ; 
}   


val coerce_and_group_big_lambda : 
    Lam_stats.t ->
    Lam.t -> 
    t * Lam_stats.t
end = struct
#1 "lam_coercion.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)





(*
  Invariant: The last one is always [exports]
  Compile definitions
  Compile exports
  Assume Pmakeblock(_,_),
  lambda_exports are pure
  compile each binding with a return value

  Such invariant  might be wrong in toplevel (since it is all bindings)

  We should add this check as early as possible
*)

(*           
- {[ Ident.same id eid]} is more  correct, 
        however, it will introduce a coercion, which is not necessary, 
        as long as its name is the same, we want to avoid 
        another coercion                
        In most common cases, it will be 
   {[
     let export/100 =a fun ..
         export/100    
   ]}
        This comes from we have lambda as below 
   {[
     (* let export/100 =a export/99  *)
     (* above is probably the cause but does not have to be  *)
     (export/99)                
   ]}
        [export/100] was not eliminated due to that it is export id, 
        if we rename export/99 to be export id, then we don't need 
        the  coercion any more, and export/100 will be dced later
   - avoid rebound
   check [map.ml] here coercion, we introduced 
                    rebound which is not corrrect 
   {[
     let Make/identifier = function (funarg){
         var $$let = Make/identifier(funarg);
                 return [0, ..... ]
       }
   ]}
                    Possible fix ? 
                    change export identifier, we should do this in the very 
                    beginning since lots of optimizations depend on this
                    however
*)

type t = {
  export_list : Ident.t list ;
  export_set : Ident_set.t;
  export_map : Lam.t Ident_map.t ;
  (** not used in code generation, mostly used 
      for store some information in cmj files *)   
  groups : Lam_group.t list ; 
  (* all code to be compiled later = original code + rebound coercions *)
}               


let handle_exports (meta : Lam_stats.t)
    (lambda_exports : Lam.t list)  (reverse_input : Lam_group.t list) =
   
  let (original_exports : Ident.t list) = meta.exports in 
  let (original_export_set : Ident_set.t) = meta.export_idents in   
  let len = List.length original_exports in   
  let tbl = String_hash_set.create len in 
  let ({export_list ; export_set  ;  groups = coercion_groups } as result)  = 
    List.fold_right2 
      (fun  (original_export_id : Ident.t) (lam : Lam.t) (acc : t)  ->
         let original_name = original_export_id.name in 
         if not @@ String_hash_set.check_add tbl original_name then 
           Bs_exception.error (Bs_duplicate_exports original_name);
         (match lam  with 
          | Lvar id ->
            if 
             Ident.name id = original_name then
            { acc with 
              export_list = id :: acc.export_list ; 
              export_set = 
                if id.stamp = original_export_id.stamp then acc.export_set 
                else (Ident_set.add id (Ident_set.remove original_export_id acc.export_set))
            }
            else
             let newid = Ident.rename original_export_id in 
             let kind : Lam.let_kind = Alias in 
             Lam_util.alias_ident_or_global meta newid id NA kind;
              { acc with 
              export_list = newid :: acc.export_list;
              export_map = Ident_map.add newid lam acc.export_map;              
              groups = Single(kind, newid, lam) :: acc.groups
              }
          | _ -> 
            (*
              Example:
              {[
              let N = [a0,a1,a2,a3]
              in [[ N[0], N[2]]]
              
              ]}
              After optimization
              {[
                [ [ a0, a2] ] 
              ]}
              Here [N] is elminated while N is still exported identifier
              Invariant: [eid] can not be bound before 
              FIX: this invariant is not guaranteed. 
              Bug manifested: when querying arity info about N, it returns an array 
              of size 4 instead of 2
              *)
             let newid = Ident.rename original_export_id in    
             (match Lam_stats_util.get_arity meta lam with 
             | NA
             | Determin(_,[],_) ->
              ()  
             | Determin _ as v  ->
              Ident_hashtbl.add meta.ident_tbl newid 
                (FunctionId{
                 arity = v; lambda = lam;
                   rec_flag = Non_rec }))
            ;
            { acc with 
              export_list = newid :: acc.export_list;
              export_map = Ident_map.add newid lam acc.export_map;              
              groups = Single(Strict, newid, lam) :: acc.groups
            })
      )
      original_exports 
      lambda_exports 
      {export_list = []; export_set = original_export_set; export_map = Ident_map.empty; groups = []}

  in

  let (export_map, coerced_input) = 
    List.fold_left 
      (fun (export_map, acc) x ->
         (match (x : Lam_group.t)  with 
          | Single (_,id,lam) when Ident_set.mem id export_set 
            -> Ident_map.add id lam export_map
              (** relies on the Invariant that [eoid] can not be bound before
                  FIX: such invariant may not hold
              *)
          | _ -> export_map), x :: acc ) (result.export_map, result.groups) reverse_input in
  { result with export_map ; groups = Lam_dce.remove export_list coerced_input }

(** TODO: more flattening, 
    - also for function compilation, flattening should be done first
    - [compile_group] and [compile] become mutually recursive function
*)
;;
let rec flatten 
    (acc :  Lam_group.t list ) 
    (lam : Lam.t) :  Lam.t *  Lam_group.t list = 
  match lam with 
  | Llet (str,id,arg,body) -> 
    let (res,l) = flatten acc arg  in
    flatten (Single(str, id, res ) :: l) body
  | Lletrec (bind_args, body) -> 
    flatten
      (
        Recursive bind_args :: acc
      )
      body
  | Lsequence (l,r) -> 
    let (res, l)  = flatten acc l in
    flatten (Nop res :: l)  r
  | x ->  
    x, acc

(** Invarinat to hold:
    [export_map] is sound, for every rebinded export id, its key is indeed in 
    [export_map] since we know its old bindings are no longer valid, i.e 
    Lam_stats.t is not valid
*)    
let coerce_and_group_big_lambda 
    (meta : Lam_stats.t) 
    lam = 
  match flatten [] lam with 
  | Lprim {primitive = Pmakeblock _;  args = lambda_exports }, reverse_input 
    -> 
    let coerced_input = 
      handle_exports
      meta lambda_exports reverse_input  in 
    coerced_input, 
      {meta with export_idents = coerced_input.export_set ; 
        exports = coerced_input.export_list}
  | _ -> assert false


end
module Js_arr : sig 
#1 "js_arr.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)







val set_array : J.expression -> J.expression -> J.expression -> J.expression

val ref_array : J.expression -> J.expression -> J.expression

end = struct
#1 "js_arr.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






module E = Js_exp_make
 
let set_array  e e0 e1 = 
  E.assign (E.access e e0)  e1

let ref_array  e e0 = 
  E.access  e  e0

end
module Js_ast_util : sig 
#1 "js_ast_util.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






val named_expression : 
  J.expression -> (J.statement * Ident.t) option

end = struct
#1 "js_ast_util.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






module E = Js_exp_make 

module S = Js_stmt_make  


let rec named_expression (e : J.expression)
  :  (J.statement  * Ident.t) option = 
  if Js_analyzer.is_simple_no_side_effect_expression e then 
    None 
  else 
    let obj = Ext_ident.create_tmp () in 
    let obj_code = 
      S.define
        ~kind:Strict obj e in 
    Some (obj_code, obj)

end
module Js_of_lam_array : sig 
#1 "js_of_lam_array.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Utilities for creating Array of JS IR *)

val make_array : J.mutable_flag -> Lambda.array_kind -> J.expression list -> J.expression
(** create an array *)

val set_array : J.expression -> J.expression -> J.expression -> J.expression
(** Here we don't care about [array_kind],  
    In the future, we might used TypedArray for FloatArray
 *)

val ref_array :  J.expression -> J.expression -> J.expression
end = struct
#1 "js_of_lam_array.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(*
   construct array,
   set array,
   ref array,

   Also make sure, don't call any primitive array method, i.e [E.index] 

   We also need check primitive [caml_make_vect], i.e, 
   [Caml_primitive['caml_make_vect']] see if it's correct 

   [caml_make_vect]
   [caml_array_sub]
   [caml_array_append]
   [caml_array_concat]
   [caml_make_float_vect]
   [caml_array_blit]

   research: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays


 *)

module E  = Js_exp_make


(* Parrayref(u|s) *)
let make_array mt (kind : Lambda.array_kind) args = 
  match kind with 
  | Pgenarray
  | Paddrarray -> E.arr ~comment:"array" mt args 
  | Pintarray  -> E.arr ~comment:"int array" mt args 
  | Pfloatarray -> E.arr ~comment:"float array" mt args

let set_array  e e0 e1 = 
  E.assign (E.access e e0)  e1

let ref_array  e e0 = 
  E.access  e  e0
end
module Js_of_lam_record : sig 
#1 "js_of_lam_record.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






(** Utilities for compiling lambda record into JS IR *)

(* val make : J.mutable_flag -> (string * J.expression) list -> J.expression *)


val field : Lambda.field_dbg_info -> J.expression -> J.jsint ->J.expression

val copy : Js_exp_make.unary_op

end = struct
#1 "js_of_lam_record.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








module E = Js_exp_make 

let empty_record_info = Lambda.Blk_record [||] (* careful to share*)


(* TODO: add label to the comment *)
(* let make  mutable_flag (args : (string * J.expression) list) = *)
(*   E.make_block ~comment:"record"  *)
(*     E.zero_int_literal empty_record_info (Ext_list.map snd args) mutable_flag *)



let field field_info  e i =
  match field_info with 
  | Lambda.Fld_na -> 
    E.index e i 
  | Lambda.Fld_record s 
  | Lambda.Fld_module s 
    -> E.index ~comment:s e i

(**
   used in [Pduprecord]
   this is due to we encode record as an array, it is going to change
   if we have another encoding       
*)    
let copy  = E.array_copy


end
module Lam_beta_reduce_util : sig 
#1 "lam_beta_reduce_util.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)







val simple_beta_reduce : 
  Ident.t list -> Lam.t -> Lam.t list -> Lam.t option

end = struct
#1 "lam_beta_reduce_util.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






(* 
   Principle: since in ocaml, the apply order is not specified 
   rules:
   1. each argument it is only used once, (avoid eval duplication)
   2. it's actually used, if not (Lsequence)
   3. no nested  compuation, 
      other wise the evaluation order is tricky (make sure eval order is correct)
*)

type value = 
  { mutable used : bool ; 
    lambda  : Lam.t
  }
let param_hash :  _ Ident_hashtbl.t = Ident_hashtbl.create 20
let simple_beta_reduce params body args = 
  let module E = struct exception Not_simple_apply end in
  let rec find_param v  opt = 
    match Ident_hashtbl.find_opt param_hash v with 
    | Some exp ->  
      if exp.used then raise E.Not_simple_apply
      else exp.used <- true; exp.lambda
    | None -> opt
  in  
  let rec aux acc (us : Lam.t list) = 
    match us with 
    | [] -> List.rev acc
    | (Lvar x as a ) :: rest 
      -> 
      aux  (find_param x a  :: acc) rest 
    | (Lconst  _  as u) :: rest 
      -> aux (u :: acc) rest 
    | _ :: _ -> raise E.Not_simple_apply 
  in 
  match (body : Lam.t) with 
  | Lprim { primitive ; args =  args' ; loc}  (* There is no lambda in primitive *)
    -> (* catch a special case of primitives *)
    (* Note in a very special case we can avoid any allocation
       {[
         when Ext_list.for_all2_no_exn
             (fun p a ->
                match (a : Lam.t) with
                | Lvar a -> Ident.same p a
                | _ -> false ) params args'
       ]}*)
    let () = 
      List.iter2 (fun p a -> Ident_hashtbl.add param_hash p {lambda = a; used = false }) params args  
    in 
    begin match aux [] args' with 
    | args -> 
      let result = 
        Ident_hashtbl.fold (fun _param {lambda; used} code -> 
            if not used then
              Lam.seq lambda code
            else code) param_hash (Lam.prim ~primitive ~args loc) in 
      Ident_hashtbl.clear param_hash;
      Some result 
    | exception _ -> 
      Ident_hashtbl.clear param_hash ;
      None
    end
  | Lapply { fn = Lvar fn_name as f ; args =  args';  loc; status}
    ->  
    let () = 
      List.iter2 (fun p a -> Ident_hashtbl.add param_hash p {lambda = a; used = false }) params args  
    in 
    (*since we adde each param only once, 
      iff it is removed once, no exception, 
      if it is removed twice there will be exception.
      if it is never removed, we have it as rest keys 
    *)
    begin match aux [] args' with 
      | us -> 
        let f = find_param fn_name  f in
        let result = 
          Ident_hashtbl.fold 
            (fun _param {lambda; used} code -> 
               if not used then 
                 Lam.seq lambda code
               else code )
            param_hash (Lam.apply  f us  loc status) in
        Ident_hashtbl.clear param_hash;
        Some result 
      | exception _ -> 
        Ident_hashtbl.clear param_hash; 
        None
    end
  | _ -> None

end
module Lam_bounded_vars : sig 
#1 "lam_bounded_vars.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


(** [rewrite tbl lam] 
    Given a [tbl] to rewrite all bounded variables in [lam] 
*)
val rewrite : Lam.t Ident_hashtbl.t -> Lam.t -> Lam.t

(** refresh lambda to replace all bounded vars for new ones *)
val refresh : 
  Lam.t -> 
  Lam.t 

end = struct
#1 "lam_bounded_vars.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)



(*
   Given an [map], rewrite all let bound variables into new variables, 
   note that the [map] is changed
   example    
   {[
     let a/112 = 3 in a/112      
   ]}
   would be converted into 
   {[
     let a/113 = 3 in a/113     
   ]}   

   ATTENTION: [let] bound idents have to be renamed, 
   Note we rely on an invariant that parameter could not be rebound 
 *)

(* 
  Small function inline heuristics:
  Even if a function is small, it does not mean it is good for inlining,
  for example, in list.ml
   {[
     let rec length_aux len = function
         [] -> len
       | a::l -> length_aux (len + 1) l

     let length l = length_aux 0 l
   ]}   
   if we inline [length], it will expose [length_aux] to the user, first, it make 
   the code not very friendly, also since [length_aux] is used everywhere now, it 
   may affect that we will not do the inlining of [length_aux] in [length]

   Criteior for sure to inline   
   1. small size, does not introduce extra symbols, non-exported and non-recursive   
      non-recursive is required if we re-apply the strategy

   Other Factors:   
   2. number of invoked times
   3. arguments are const or not   
*)
let rewrite (map :   _ Ident_hashtbl.t) 
    (lam : Lam.t) : Lam.t = 

  let rebind i = 
    let i' = Ident.rename i in 
    Ident_hashtbl.add map i (Lam.var i');
    i' in
  (* order matters, especially for let bindings *)
  let rec 
    option_map op = 
    match op with 
    | None -> None 
    | Some x -> Some (aux x)
  and aux (lam : Lam.t) : Lam.t = 
    match lam with 
    | Lvar v ->
      Ident_hashtbl.find_default map v lam 
    | Llet(str, v, l1, l2) ->
      let v = rebind v in
      let l1 = aux l1 in      
      let l2 = aux l2 in
      Lam.let_ str v  l1  l2 
    | Lletrec(bindings, body) ->
      (*order matters see GPR #405*)
      let vars = Ext_list.map (fun (k, _) -> rebind k) bindings in 
      let bindings = List.map2 (fun var (_,l) -> var, aux l) vars bindings in 
      let body = aux body in       
      Lam.letrec bindings body
    | Lfunction{arity; function_kind; params; body} -> 
      let params =  Ext_list.map rebind params in
      let body = aux body in      
      Lam.function_ ~arity ~function_kind ~params ~body
    | Lstaticcatch(l1, (i,xs), l2) -> 
      let l1 = aux l1 in
      let xs = Ext_list.map rebind xs in
      let l2 = aux l2 in
      Lam.staticcatch l1 (i,xs) l2
    | Lfor(ident, l1, l2, dir, l3) ->
      let ident = rebind ident in 
      let l1 = aux l1 in
      let l2 = aux l2 in
      let l3 = aux l3 in
      Lam.for_ ident (aux  l1)  l2 dir  l3
    | Lconst _ -> lam
    | Lprim {primitive; args ; loc} ->
      (* here it makes sure that global vars are not rebound *)      
      Lam.prim ~primitive ~args:(Ext_list.map aux  args) loc
    | Lglobal_module _ -> lam 
    | Lapply {fn;  args; loc;  status } ->
      let fn = aux fn in       
      let args = Ext_list.map aux  args in 
      Lam.apply fn  args loc status
    | Lswitch(l, {sw_failaction; 
                  sw_consts; 
                  sw_blocks;
                  sw_numblocks;
                  sw_numconsts;
                 }) ->
      let l = aux l in
      Lam.switch l
              {sw_consts = 
                 Ext_list.map (fun (v, l) -> v, aux  l) sw_consts;
               sw_blocks = Ext_list.map (fun (v, l) -> v, aux  l) sw_blocks;
               sw_numconsts = sw_numconsts;
               sw_numblocks = sw_numblocks;
               sw_failaction =  option_map sw_failaction
              }
    | Lstringswitch(l, sw, d) ->
      let l = aux  l in
      Lam.stringswitch l 
                     (Ext_list.map (fun (i, l) -> i,aux  l) sw)
                     (option_map d)
    | Lstaticraise (i,ls) 
      -> Lam.staticraise i (Ext_list.map aux  ls)
    | Ltrywith(l1, v, l2) -> 
      let l1 = aux l1 in
      let v = rebind v in
      let l2 = aux l2 in
      Lam.try_ l1 v l2
    | Lifthenelse(l1, l2, l3) -> 
      let l1 = aux l1 in
      let l2 = aux l2 in
      let l3 = aux l3 in
      Lam.if_ l1  l2   l3
    | Lsequence(l1, l2) -> 
      let l1 = aux l1 in
      let l2 = aux l2 in
      Lam.seq l1 l2
    | Lwhile(l1, l2) -> 
      let l1 = aux l1 in
      let l2 = aux l2 in
      Lam.while_  l1  l2
    | Lassign(v, l) 
      -> Lam.assign v (aux  l)
    | Lsend(u, m, o, ll, v) ->
      let m = aux m in 
      let o = aux o in 
      let ll = Ext_list.map aux ll in
      Lam.send u  m  o  ll v
    | Lifused(v, l) -> 
      let l = aux l in 
      Lam.ifused v  l
  in 
  aux lam


let refresh lam = rewrite (Ident_hashtbl.create 17 : Lam.t Ident_hashtbl.t ) lam

end
module Lam_closure : sig 
#1 "lam_closure.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

(** [is_closed_by map lam]
    return [true] if all unbound variables
    belongs to the given [map] *)
val is_closed_by : Ident_set.t -> Lam.t -> bool

val is_closed : Lam.t -> bool





type stats = 
  { 
    top : bool ; 
    (* all appearances are in the top,  substitution is fine 
       whether it is pure or not
       {[
         (fun x y          
           ->  x + y + (f x )) (32) (console.log('hi'), 33)
       ]}       
       since in ocaml, the application order is intentionally undefined, 
       note if [times] is not one, this field does not make sense       
    *)    
    times : int ; 
  }

val is_closed_with_map : 
  Ident_set.t ->
  Ident.t list -> Lam.t -> bool * stats Ident_map.t

(* val param_map_of_list : Ident.t list -> stats Ident_map.t *)

val free_variables : Ident_set.t -> stats Ident_map.t -> Lam.t -> stats Ident_map.t


end = struct
#1 "lam_closure.ml"
(* Copyright (C) 2017 Authors of BuckleScript
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)





type stats = 
  { 
    top : bool ; 
    (* all appearances are in the top,  substitution is fine 
       whether it is pure or not
       {[
         (fun x y          
           ->  x + y + (f x )) (32) (console.log('hi'), 33)
       ]}       
       since in ocaml, the application order is intentionally undefined, 
       note if [times] is not one, this field does not make sense       
    *)    
    times : int ; 
  }
type env = 
  { top  : bool ; 
    loop : bool 
  }

let no_substitute = { top = false; loop = true }
let fresh_env = {top = true; loop = false }
let fresh_stats  : stats = { top = true; times = 0 }

let param_map_of_list lst : stats Ident_map.t = 
  List.fold_left  (fun acc l -> Ident_map.add l fresh_stats acc) Ident_map.empty  lst 

(** Sanity check, remove all varaibles in [local_set] in the last pass *)  

let loop_use = 100 (** Used in loop, huge punishment *)

(**
   [param_stats = free_variables exports param_stats lam] 
   This function tries to do more than detect free variable of [lam],  
   given [param_stats] it tries to return a new stats with updated usage of 
   recorded params and unbound parameters
*)
let free_variables (export_idents : Ident_set.t ) (params : stats Ident_map.t ) lam = 
  let fv = ref params in
  let local_set = ref export_idents in

  let local_add k =
    local_set := Ident_set.add k !local_set in
  let local_add_list ks = 
    local_set :=  
      List.fold_left (fun acc k -> Ident_set.add k acc) !local_set ks 
  in    
  (* base don the envrionmet, recoring the use cases of arguments *)
  let map_use {top; loop} v = 
    (* relies on [identifier] uniquely bound *)    
    if not (Ident_set.mem v !local_set) then 
      fv := Ident_map.adjust 
          v
          (fun _ -> {top; times = if loop then loop_use else 1})
          (fun v -> {times = if loop then loop_use else v.times + 1 ; top = v.top && top})
          !fv 
  in
  let new_env lam (env : env) : env = 
    if env.top then 
      if Lam_analysis.no_side_effects lam 
      then env 
      (* no side effect, if argument has no side effect and used only once we can simply do the replacement *)
      else { env with top = false}
    else env      
  in    
  let rec iter (top : env) (lam : Lam.t) =
    match lam with 
    | Lvar v -> map_use top v 
    | Lconst _ -> ()
    | Lapply {fn; args; _} ->
      iter top  fn; 
      let top = new_env fn top in
      List.iter (fun lam -> iter top lam ) args  
    | Lprim {args ; _} -> 
      (* Check: can top be propoaged for all primitives *)
      List.iter (iter top) args
    | Lam.Lglobal_module _ -> ()
    | Lfunction{ params; body} ->
      local_add_list params;
      iter no_substitute body 
    | Llet(_let_kind, id, arg, body) ->
      local_add id ;  
      iter top  arg; iter no_substitute body
    | Lletrec(decl, body) ->
      local_set := List.fold_left (fun acc (id, _) -> 
          Ident_set.add id acc) !local_set decl;        
      List.iter (fun (_, exp) -> iter no_substitute exp) decl;
      iter no_substitute body
    | Lswitch(arg, 
              ({sw_consts; 
                sw_blocks; 
                sw_failaction;
                sw_numconsts;
                sw_numblocks
               })) ->
      iter top arg; 
      let top = new_env arg top  in       
      List.iter (fun (_, case) -> iter top case) sw_consts;
      List.iter (fun (_, case) -> iter top  case) sw_blocks;

      begin match sw_failaction with 
        | None -> ()
        | Some x ->
          if  
            Ext_list.length_ge sw_consts sw_numconsts
            ||
            Ext_list.length_ge sw_blocks sw_numblocks
          then
            iter top x 
          else
            iter no_substitute x
      end

    | Lstringswitch (arg,cases,default) ->
      iter top arg ;
      let top = new_env arg top  in       
      List.iter (fun (_,act) -> iter top  act) cases ;
      begin match default with 
        | None -> ()
        | Some x -> iter top x 
      end
    | Lstaticraise (_,args) ->
      List.iter (iter no_substitute ) args
    | Lstaticcatch(e1, (_,vars), e2) ->
      iter no_substitute  e1; 
      local_add_list vars;       
      iter no_substitute e2
    | Ltrywith(e1, exn, e2) ->
      iter top  e1; iter no_substitute  e2
    | Lifthenelse(e1, e2, e3) ->
      iter top e1; 
      let top = new_env e1 top  in
      iter top e2; iter top e3
    | Lsequence(e1, e2) ->
      iter top e1; iter no_substitute e2
    | Lwhile(e1, e2) ->
      iter no_substitute e1; iter no_substitute e2 (* in the loop, no substitution any way *)
    | Lfor(v, e1, e2, dir, e3) ->
      local_add v ; 
      iter no_substitute e1; iter no_substitute e2; iter no_substitute e3
    | Lassign(id, e) ->
      map_use top  id ; 
      iter top e
    | Lsend (_k, met, obj, args, _) ->
      iter no_substitute met ; 
      iter no_substitute obj;
      List.iter (iter no_substitute) args
    | Lifused (v, e) ->
      iter no_substitute e in
  iter fresh_env  lam ; !fv 


let is_closed_by set lam = 
  Ident_map.is_empty (free_variables set (Ident_map.empty ) lam   )


(** A bit consverative , it should be empty *)
let is_closed  lam = 
  Ident_map.for_all (fun k _ -> Ident.global k)
    (free_variables Ident_set.empty Ident_map.empty lam)  


let is_closed_with_map exports params body = 
  let param_map = free_variables exports (param_map_of_list params) body in
  let old_count = List.length params in
  let new_count = Ident_map.cardinal param_map in
  (old_count  = new_count, param_map)




end
module Js_of_lam_module : sig 
#1 "js_of_lam_module.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






val make :
  ?comment:string ->
  J.expression list -> J.expression


end = struct
#1 "js_of_lam_module.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






module E = Js_exp_make 

let make ?comment (args : J.expression list) =
  E.make_block
    ?comment E.zero_int_literal
    (Blk_module None) args Immutable


end
module Lam_compile_global : sig 
#1 "lam_compile_global.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Compile ocaml external module call , e.g [List.length] to  JS IR *)

val expand_global_module :  Ident.t -> Env.t   -> J.expression



val query_lambda : Ident.t -> Env.t -> Lam.t

end = struct
#1 "lam_compile_global.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








module E = Js_exp_make  
module S = Js_stmt_make

open Js_output.Ops

(* TODO: used in functor inlining, so that it can not be an exception
   Make(S), S can not be an exception
*)



let query_lambda id env = 
  Lam_compile_env.query_and_add_if_not_exist (Lam_module_ident.of_ml id) 
    (Has_env env)
    ~not_found:(fun id -> assert false)
    ~found:(fun {signature = sigs; _} 
             -> 
               Lam.prim
                 ~primitive:(Pmakeblock(0, Blk_module None, Immutable))  
                 ~args:(
                   List.mapi (fun i _ -> 
                       Lam.prim
                         ~primitive:(Pfield (i, Lambda.Fld_na)) 
                         ~args:[ Lam.global_module id  ] Location.none)
                     sigs) Location.none (* FIXME*))


(* Given an module name,  find its expanded structure  *)  
let expand_global_module  id env  : J.expression = 
  Lam_compile_env.query_and_add_if_not_exist 
    (Lam_module_ident.of_ml id) 
    (Has_env env)
    ~not_found:(fun _ -> assert false)
    ~found:(fun   {signature = sigs; _} -> 
          let len = List.length sigs in (** TODO: could be optimized *) 
          Js_of_lam_module.make ~comment:id.name 
            (Ext_list.init len (fun i -> 
                 E.ml_var_dot id
                   (Type_util.get_name sigs i ))))




end
module Lam_beta_reduce : sig 
#1 "lam_beta_reduce.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Beta reduction of lambda IR *)


val beta_reduce : Ident.t list -> Lam.t -> Lam.t list -> Lam.t
(* Compile-time beta-reduction of functions immediately applied:
      Lapply(Lfunction(Curried, params, body), args, loc) ->
        let paramN = argN in ... let param1 = arg1 in body
      Lapply(Lfunction(Tupled, params, body), [Lprim(Pmakeblock(args))], loc) ->
        let paramN = argN in ... let param1 = arg1 in body
   Assumes |args| = |params|.
*)

(*
   Refresh all the identifiers, 
   otherwise the identifier property can not be preserved, 
   the obvious example is parameter
 *)

val propogate_beta_reduce : 
  Lam_stats.t -> 
  Ident.t list -> 
  Lam.t -> 
  Lam.t list -> 
  Lam.t



(** 
   {[ Lam_beta_reduce.propogate_beta_reduce_with_map 
       meta param_map
       params body args]}

   [param_map] collect the usage of parameters, it's readonly
   it can be  produced by 

   {[!Lam_analysis.free_variables meta.export_idents 
       (Lam_analysis.param_map_of_list params) body]}

   TODO:
   replace [propogate_beta_reduce] with such implementation 
   {[
     let propogate_beta_reduce meta params body args = 
       let (_, param_map) = 
         Lam_analysis.is_closed_with_map Ident_set.empty params body in 
       propogate_beta_reduce_with_map meta param_map params body args  
   ]}
*)
val propogate_beta_reduce_with_map : 
  Lam_stats.t ->
  Lam_closure.stats Ident_map.t ->
  Ident.t list ->
  Lam.t -> Lam.t list -> Lam.t

end = struct
#1 "lam_beta_reduce.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)










(* 
    A naive beta reduce would break the invariants of the optmization.


    The sane but slowest  way:
      when we do a beta reduction, we need rename all variables inlcuding 
      let-bound ones

    A conservative one:
      - for internal one 
        rename params and let bound variables
      - for external one (seriaized)
        if it's enclosed environment should be good enough
        so far, we only inline enclosed lambdas
    TODO: rename 

   Optimizations:   
   {[
     (fun x y -> ...     ) 100 3 
   ]}   
   we can bound [x] to [100] in a single step     
 *)
let propogate_beta_reduce 
    (meta : Lam_stats.t) params body args =
  match Lam_beta_reduce_util.simple_beta_reduce params body  args with 
  | Some x -> x 
  | None -> 
  let rest_bindings, rev_new_params  = 
    List.fold_left2 
      (fun (rest_bindings, acc) old_param (arg : Lam.t) -> 
         match arg with          
         | Lconst _
         | Lvar _  -> rest_bindings , arg :: acc 
         | _ -> 
           let p = Ident.rename old_param in 
           (p,arg) :: rest_bindings , (Lam.var p) :: acc 
      )  ([],[]) params args in
  let new_body = Lam_bounded_vars.rewrite (Ident_hashtbl.of_list2 (List.rev params) (rev_new_params)) body in
  List.fold_right
    (fun (param, (arg : Lam.t)) l -> 
       let arg = 
         match arg with 
         | Lvar v -> 
           begin 
             match Ident_hashtbl.find_opt meta.ident_tbl v with 
             | None -> ()
             | Some ident_info -> 
               Ident_hashtbl.add meta.ident_tbl param ident_info 
           end;
           arg 
         | Lglobal_module ident   
         -> 
           (* It's not completeness, its to make it sound.. 
              Pass global module as an argument
           *)
           Lam_compile_global.query_lambda ident meta.env 
         (* alias meta param ident (Module (Global ident)) Strict *)
         | Lprim {primitive = Pmakeblock (_, _, Immutable) ;args ; _} -> 
           Ident_hashtbl.replace meta.ident_tbl param 
             (Lam_util.kind_of_lambda_block Normal args ); (** *)
           arg
         | _ -> arg in
       Lam_util.refine_let ~kind:Strict param arg l) 
     rest_bindings new_body

let propogate_beta_reduce_with_map  
    (meta : Lam_stats.t) (map : Lam_closure.stats Ident_map.t ) params body args =
  match Lam_beta_reduce_util.simple_beta_reduce params body args with
  | Some x -> x
  | None ->
  let rest_bindings, rev_new_params  = 
    List.fold_left2 
      (fun (rest_bindings, acc) old_param (arg : Lam.t) -> 
         match arg with          
         | Lconst _
         | Lvar _  -> rest_bindings , arg :: acc 
         | Lglobal_module ident 
            (* We can pass Global, but you also need keep track of it*)
           ->
           let p = Ident.rename old_param in 
           (p,arg) :: rest_bindings , (Lam.var p) :: acc 

         | _ -> 
           if  Lam_analysis.no_side_effects arg then
             begin match Ident_map.find_exn old_param map with 
               | exception Not_found -> assert false 
               | {top = true ; times = 0 }
               | {top = true ; times = 1 } 
                 -> 
                 rest_bindings, arg :: acc                
               | _  ->  
                 let p = Ident.rename old_param in 
                 (p,arg) :: rest_bindings , (Lam.var p) :: acc 
             end
           else
             let p = Ident.rename old_param in 
             (p,arg) :: rest_bindings , (Lam.var p) :: acc 
      )  ([],[]) params args in
  let new_body = Lam_bounded_vars.rewrite (Ident_hashtbl.of_list2 (List.rev params) (rev_new_params)) body in
  List.fold_right
    (fun (param, (arg : Lam.t)) l -> 
       let arg = 
         match arg with 
         | Lvar v -> 
           begin 
             match Ident_hashtbl.find_opt meta.ident_tbl v with 
             | None -> ()
             | Some ident_info -> 
               Ident_hashtbl.add meta.ident_tbl param ident_info 
           end;
           arg 
          | Lglobal_module ident 
          -> 
           (* It's not completeness, its to make it sound.. *)
           Lam_compile_global.query_lambda ident meta.env 
         (* alias meta param ident (Module (Global ident)) Strict *)
         | Lprim {primitive = Pmakeblock (_, _, Immutable ) ; args} -> 
           Ident_hashtbl.replace meta.ident_tbl param 
             (Lam_util.kind_of_lambda_block Normal args ); (** *)
           arg
         | _ -> arg in
       Lam_util.refine_let ~kind:Strict param arg l) 
     rest_bindings new_body



let beta_reduce params body args =
  match Lam_beta_reduce_util.simple_beta_reduce params body args with 
  | Some x -> x 
  | None -> 
    List.fold_left2 
      (fun l param arg ->
         Lam_util.refine_let ~kind:Strict param arg l)
      body params args

end
module Js_long : sig 
#1 "js_long.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






type int64_call = J.expression list -> J.expression  

val make_const : lo:Int32.t -> hi:Int32.t -> J.expression

val of_const : int64 -> J.expression

val to_int32 : int64_call

val of_int32 : int64_call
val comp : Lambda.comparison -> int64_call
val neg : int64_call
val add : int64_call
val sub : int64_call
val mul : int64_call
val div : int64_call
val xor : int64_call
val mod_ : int64_call
val lsl_ : int64_call
val lsr_ : int64_call
val asr_ : int64_call
val and_ : int64_call
val or_ : int64_call
val swap : int64_call
val discard_sign : int64_call
val div_mod : int64_call
val to_hex : int64_call  
val to_float : int64_call
val of_float : int64_call
val compare : int64_call
val of_string : int64_call
val float_of_bits : int64_call
val bits_of_float : int64_call  
val get64 : int64_call

end = struct
#1 "js_long.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






module E = Js_exp_make
type int64_call = J.expression list -> J.expression  

let int64_call (fn : string) args  = 
  E.runtime_call Js_runtime_modules.int64 fn args 


(* TODO: make layout easier to change later *)
let record_info = Lambda.Blk_record [| "hi"; "lo"|]
let make_const ~lo ~hi = 
  E.make_block 
    ~comment:"int64" (E.zero_int_literal) 
    record_info
    [E.int hi; E.to_uint32 @@ E.int lo ; ]
    (* If we use unsigned int for lo field, 
       then we can not use [E.int] which is 
       assumed to to be signed int.
       Or we can use [Int64] to encode 
       in the ast node?
    *)
    Immutable
let make ~lo ~hi = 
  E.make_block 
    ~comment:"int64" (E.zero_int_literal) 
    record_info [   hi; E.to_uint32 lo ]
    Immutable
let get_lo x = E.index x 1l
let get_hi x = E.index x 0l


(* below should  not depend on layout *)


let of_const (v : Int64.t) = 
  make_const
    ~lo:(Int64.to_int32 v )
    ~hi:(Int64.to_int32 (Int64.shift_right v 32))

let to_int32 args = 
  begin match args with
    | [v] ->  E.to_int32 @@ get_lo v
    | _ -> assert false
  end

let of_int32 (args : J.expression list) = 
  match args with 
  | [{expression_desc = Number (Int {i}) ; _}] 
    -> 
    if i < 0l then make_const ~lo:i ~hi:(-1l)
    else make_const ~lo:i ~hi:0l
  | _ -> int64_call  "of_int32" args

let comp (cmp : Lambda.comparison) args = 
  E.runtime_call  Js_runtime_modules.int64
    (match cmp with 
     | Ceq -> "eq"
     | Cneq -> "neq"
     | Clt -> "lt"
     | Cgt -> "gt"
     | Cle -> "le"
     | Cge -> "ge") args 

let neg args = 
  int64_call "neg" args

let add args = 
  int64_call "add" args 

let sub args = 
  int64_call "sub" args

let mul args =  
  int64_call "mul" args

let div args =
  int64_call "div" args


(** Note if operands are not pure, we need hold shared value, 
    which is  a statement [var x = ... ; x ], it does not fit 
    current pipe-line fall back to a function call
*)
let bit_op  op runtime_call args = 
  match args  with 
  | [l;r] -> 
    (* Int64 is a block in ocaml, a little more conservative in inlining *)
    if Js_analyzer.is_simple_no_side_effect_expression l  &&
       Js_analyzer.is_simple_no_side_effect_expression r then 
      make ~lo:(op (get_lo l) (get_lo r))
        ~hi:(op (get_hi l) (get_hi r))
    else int64_call runtime_call args 
  | _ -> assert false

let xor  = bit_op E.int32_bxor "xor"
let or_ = bit_op E.int32_bor "or_"
let and_ = bit_op E.int32_band "and_"


let lsl_ args = 
  int64_call "lsl_" args

let lsr_ args = 
  int64_call "lsr_" args

let asr_ args = 
  int64_call "asr_" args

let mod_ args = 
  int64_call "mod_" args


let swap args = 
  int64_call "swap" args

(* Safe constant propgation 
   {[
     Number.MAX_SAFE_INTEGER:
       Math.pow(2,53) - 1
   ]}
   {[
     Number.MIN_SAFE_INTEGER:
       - (Math.pow(2,53) -1)
   ]}
   Note that [Number._SAFE_INTEGER] is in ES6, 
   we can hard code this number without bringing browser issue.
*)
let of_float (args : J.expression list ) = 
  int64_call "of_float" args

let compare (args : J.expression list) = 
  int64_call "compare" args 

let of_string (args : J.expression list) = 
  int64_call "of_string" args 
let discard_sign (args : J.expression list) =
  int64_call "discard_sign" args
let div_mod (args : J.expression list) =
  int64_call "div_mod" args
let to_hex (args : J.expression list) =
  int64_call "to_hex"  args
let get64 = int64_call "get64"
let float_of_bits  =  int64_call "float_of_bits" 
let bits_of_float = int64_call "bits_of_float"
let to_float (args : J.expression list ) = 
  match args with
  (* | [ {expression_desc  *)
  (*      = Caml_block (  *)
  (*          [lo =  *)
  (*           {expression_desc = Number (Int {i = lo; _}) }; *)
  (*           hi =  *)
  (*           {expression_desc = Number (Int {i = hi; _}) }; *)
  (*          ], _, _, _); _ }]  *)
  (*   ->  *)

  | [ _ ] -> 
    int64_call "to_float" args
  | _ -> 
    assert false    

end
module Js_of_lam_block : sig 
#1 "js_of_lam_block.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Utilities for creating block of lambda expression in JS IR *)

val make_block : 
  Js_op.mutable_flag -> Lambda.tag_info ->
  J.expression -> J.expression list -> J.expression

val field : Lambda.field_dbg_info -> J.expression -> J.jsint -> J.expression

val set_field : 
  Lambda.set_field_dbg_info -> 
  J.expression -> J.jsint -> J.expression -> J.expression


end = struct
#1 "js_of_lam_block.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








module E = Js_exp_make

(* TODO: it would be even better, if the [tag_info] contains more information
   about immutablility
 *)
let make_block mutable_flag (tag_info : Lambda.tag_info) tag args  = 

  match mutable_flag, tag_info with
  | _, Blk_array -> Js_of_lam_array.make_array mutable_flag  Pgenarray args
  | _ , _ -> E.make_block tag tag_info args mutable_flag
  (* | _, (  Tuple | Variant _ ) -> (\** TODO: check with inline record *\) *)
  (*     E.arr Immutable *)
  (*       (E.small_int  ?comment:(Lam_compile_util.comment_of_tag_info tag_info) tag   *)
  (*        :: args) *)
  (* | _, _  ->  *)
  (*     E.arr mutable_flag *)
  (*       (E.int  ?comment:(Lam_compile_util.comment_of_tag_info tag_info) tag   *)
  (*        :: args) *)

let field field_info e i =
  match field_info with 
  | Lambda.Fld_na -> 
    E.index e i 
  | Lambda.Fld_record s 
  | Lambda.Fld_module s 
    -> E.index ~comment:s e i



let set_field field_info e i e0 =
  let comment = 
    match field_info with 
    | Lambda.Fld_set_na 
      -> None
    | Fld_record_set s -> Some (s)
  in (* see GPR#631*)
  E.index_addr ?comment e i  ~no:e0 ~yes:(fun v -> E.assign v e0)






end
module Js_of_lam_string : sig 
#1 "js_of_lam_string.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Utilities to wrap [string] and [bytes] compilation, 

   this is isolated, so that we can swap different representation in the future.
   [string] is Immutable, so there is not [set_string] method
*)

val ref_string : J.expression -> J.expression -> J.expression

val ref_byte : J.expression -> J.expression -> J.expression

val set_byte : J.expression -> J.expression -> J.expression -> J.expression 

val caml_char_of_int : ?comment:string -> J.expression -> J.expression

val caml_char_to_int : ?comment:string -> J.expression -> J.expression

val const_char : char -> J.expression

val bytes_to_string : J.expression -> J.expression

val bytes_of_string : J.expression -> J.expression

end = struct
#1 "js_of_lam_string.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)









module E = Js_exp_make

module A = struct 

  let const_char (i : char) = 
    E.str (String.make 1 i)

  let caml_char_of_int ?comment (v : J.expression)  =  
    E.char_of_int ?comment v

  let caml_char_to_int ?comment v =  
    E.char_to_int ?comment v

  (* string [s[i]] expects to return a [ocaml_char] *)
  let ref_string e e1 = 
    E.string_access e e1

  (* [s[i]] excepts to return a [ocaml_char]
     We use normal array for [bytes]
     TODO: we can use [Buffer] in the future 
   *)
  let ref_byte e e0  =
    E.char_of_int (E.access  e  e0)

  (* {Bytes.set : bytes -> int -> char -> unit }*)
  let set_byte  e e0 e1 = 
    E.assign (E.access e e0)  (E.char_to_int e1)

(*
   Note that [String.fromCharCode] also works, but it only 
   work for small arrays, however, for {bytes_to_string} it is likely the bytes 
   will become big
   {[
   String.fromCharCode.apply(null,[87,97])
   "Wa"
   String.fromCharCode(87,97)
   "Wa" 
   ]}
   This does not work for large arrays
   {[
   String.fromCharCode.apply(null, prim = Array[1048576]) 
   Maxiume call stack size exceeded
   ]}
 *)

  let bytes_to_string e = 
    E.runtime_call Js_runtime_modules.string "bytes_to_string" [e]

  let bytes_of_string s =
    E.runtime_call Js_runtime_modules.string "bytes_of_string" [s]
end

(* We use module B for string compilation, once the upstream can make changes to the 
    patten match of range patterns, we can use module [A] which means [char] is [string] in js, 
    currently, it follows the same patten of ocaml, [char] is [int]
 *)

module B = struct 

  let const_char (i : char) = 
    E.int  ~comment:("\"" ^ Ext_string.escaped (String.make 1 i) ^ "\"") 
      ~c:i (Int32.of_int @@ Char.code i)

  let caml_char_of_int ?comment (v : J.expression)  =  v

  let caml_char_to_int ?comment v =  v

  (* string [s[i]] expects to return a [ocaml_char] *)
  let ref_string e e1 = 
    E.char_to_int (E.string_access e e1)

  (* [s[i]] excepts to return a [ocaml_char]
     We use normal array for [bytes]
     TODO: we can use [Buffer] in the future 
   *)
  let ref_byte e e0  = E.access  e  e0

  (* {Bytes.set : bytes -> int -> char -> unit }*)
  let set_byte  e e0 e1 = 
    E.assign (E.access e e0)  e1

(**
   Note that [String.fromCharCode] also works, but it only 
   work for small arrays, however, for {bytes_to_string} it is likely the bytes 
   will become big
   {[
   String.fromCharCode.apply(null,[87,97])
   "Wa"
   String.fromCharCode(87,97)
   "Wa" 
   ]}
   This does not work for large arrays
   {[
   String.fromCharCode.apply(null, prim = Array[1048576]) 
   Maxiume call stack size exceeded
   ]}
 *)

  let bytes_to_string e = 
    E.runtime_call Js_runtime_modules.string "bytes_to_string" [e]

  let bytes_of_string s =
    E.runtime_call Js_runtime_modules.string "bytes_of_string" [s]
end

(* include A *)
include B

end
module Lam_compile_const : sig 
#1 "lam_compile_const.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Compile lambda constant to JS *)

val translate : Lam.constant -> J.expression


val translate_arg_cst : Ast_arg.cst -> J.expression

end = struct
#1 "lam_compile_const.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








module E = Js_exp_make

let rec translate (x : Lam.constant ) : J.expression = 
  match x with 
  | Const_int i -> E.int (Int32.of_int i)
  | Const_char i ->
    Js_of_lam_string.const_char i
  | Const_int32 i -> E.int i 
  (* E.float (Int32.to_string i) *)
  | Const_int64 i -> 
          (*
            TODO:
       {[
         Int64.to_string 0x7FFFFFFFFFFFFFFFL;;
         - : string = "9223372036854775807"
       ]}
       {[
         Int64.(to_float max_int);;
         - : float = 9.22337203685477581e+18
       ]}
       Note we should compile it to Int64 as JS's 
       speical representation -- 
       it is not representatble in JS number
    *)
    (* E.float (Int64.to_string i) *)
    Js_long.of_const i
  (* https://github.com/google/closure-library/blob/master/closure%2Fgoog%2Fmath%2Flong.js *)
  | Const_nativeint i -> E.nint i 
  | Const_float f -> E.float f (* TODO: preserve float *)
  | Const_string i (*TODO: here inline js*) -> 
    E.str  i 
  | Const_unicode i -> 
    E.unicode i 
    (* E.str i ~delimiter:Literals.escaped_j_delimiter *)   

  | Const_pointer (c,pointer_info) -> 
    E.int ?comment:(Lam_compile_util.comment_of_pointer_info pointer_info)
      (Int32.of_int c )

  | Const_block(tag, tag_info, xs ) -> 
    Js_of_lam_block.make_block NA tag_info 
      (E.small_int  tag) (Ext_list.map translate xs)

  | Const_float_array ars -> 
    (* according to the compiler 
        const_float_array is immutable 
       {[ Lprim(Pccall prim_obj_dup, [master]) ]},
        however, we can not translate 
       {[ prim_obj_dup(x) =>  x' ]}
        since x' is now mutable, prim_obj_dup does a copy,

        the compiler does this  is mainly to extract common data into data section, 
        we  deoptimized this in js backend? so it is actually mutable 
    *)
    (* TODO-- *)
    Js_of_lam_array.make_array Mutable Pfloatarray 
      (Ext_list.map (fun x ->  E.float  x ) ars)
  (* E.arr Mutable ~comment:"float array" *)
  (*   (Ext_list.map (fun x ->  E.float  x ) ars) *)

  | Const_immstring s ->  (*TODO *)
    E.str s  (* TODO: check *)


let translate_arg_cst (cst : Ast_arg.cst) = 
  match cst with 
   | Arg_int_lit i -> 
     E.int (Int32.of_int i)
   | Arg_string_lit i -> 
     E.str i
   | Arg_js_null  -> E.raw_js_code Exp "null"
   | Arg_js_json s 
     -> E.raw_js_code Exp s

   | Arg_js_true  -> E.js_bool true
   | Arg_js_false -> E.js_bool false 

end
module Js_of_lam_option : sig 
#1 "js_of_lam_option.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






type option_unwrap_time =
  | Static_unwrapped
  | Runtime_maybe_unwrapped

val get_default_undefined : ?map:(option_unwrap_time -> J.expression -> J.expression) -> J.expression -> J.expression

val none : J.expression

val some : J.expression -> J.expression

end = struct
#1 "js_of_lam_option.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






module E = Js_exp_make 

type option_unwrap_time =
  | Static_unwrapped
  | Runtime_maybe_unwrapped

(**
  Invrariant: 
  - optional encoding
  -  None encoding

  when no argumet is supplied, [undefined] 
  if we detect that all rest arguments are [null], 
  we can remove them


  - avoid duplicate evlauation of [arg] when it
   is not a variable
  {!Js_ast_util.named_expression} does not help 
   since we need an expression here, it might be a statement
*)
let get_default_undefined
    ?(map=((fun _ x -> x) : option_unwrap_time -> J.expression -> J.expression))
    (arg : J.expression)
    : J.expression =
  match arg.expression_desc with
  | Number _ -> E.undefined
  | Array ([x],_)
  | Caml_block([x],_,_,_) -> (map Static_unwrapped x) (* invariant: option encoding *)
  | _ ->
    if Js_analyzer.is_simple_no_side_effect_expression arg then
      E.econd arg (map Static_unwrapped (E.index arg 0l)) E.undefined
    else
      map Runtime_maybe_unwrapped (E.runtime_call Js_runtime_modules.js_primitive "option_get" [arg])

(** Another way: 
    {[
      | Var _  ->
        can only bd detected at runtime thing
          (E.triple_equal (E.typeof arg)
             (E.str "number"))
    ]}
*)
let none : J.expression = 
  {expression_desc = Number (Int {i = 0l; c  = None}); comment = Some "None" }

let some x : J.expression = 
  {expression_desc = Caml_block ( [x], Immutable, E.zero_int_literal , Blk_constructor ("Some",1) );
   comment = None}








end
module Js_of_lam_variant : sig 
#1 "js_of_lam_variant.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

val eval : J.expression -> (int * string) list -> J.expression
val eval_as_event : J.expression -> (int * string) list -> J.expression list 
val eval_as_int : J.expression -> (int * int) list -> J.expression
val eval_as_unwrap : J.expression -> J.expression

end = struct
#1 "js_of_lam_variant.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

module E = Js_exp_make
module S = Js_stmt_make

(* we need destruct [undefined] when input is optional *)
let eval (arg : J.expression) (dispatches : (int * string) list ) : E.t = 
  if arg == E.undefined then E.undefined else
  match arg.expression_desc with
  | Number (Int {i} | Uint i) -> 
    E.str (Ext_list.assoc_by_int None (Int32.to_int i) dispatches) 
  | _ ->  
    E.of_block
      [(S.int_switch arg
      (Ext_list.map (fun (i,r) -> 
              {J.case = i ; 
               body = [S.return (E.str r)],
                      false (* FIXME: if true, still print break*)
              }) dispatches))]

(** invariant: optional is not allowed in this case *)
let eval_as_event (arg : J.expression) (dispatches : (int * string) list ) : E.t list  = 
  match arg.expression_desc with
  | Array ([{expression_desc = Number (Int {i} | Uint i)}; cb], _)
  | Caml_block([{expression_desc = Number (Int {i} | Uint i)}; cb], _, _, _)
    -> 
    let v = Ext_list.assoc_by_int None (Int32.to_int i) dispatches in [E.str v ; cb ]   
  | _ ->  
    let event = Ext_ident.create "action" in
    [
      E.ocaml_fun [event]
      [(S.int_switch arg
      (Ext_list.map (fun (i,r) -> 
              {J.case = i ; 
               body = [S.return (E.index (E.var event) 0l)],
                      false (* FIXME: if true, still print break*)
              }) dispatches))]
      ; (* TODO: improve, one dispatch later, 
           the problem is that we can not create bindings 
           due to the 
        *)
      E.ocaml_fun [event]
      [(S.int_switch arg
      (Ext_list.map (fun (i,r) -> 
              {J.case = i ; 
               body = [S.return (E.index (E.var event) 1l)],
                      false (* FIXME: if true, still print break*)
              }) dispatches))]
    ]

(* we need destruct [undefined] when input is optional *)
let eval_as_int (arg : J.expression) (dispatches : (int * int) list ) : E.t  = 
  if arg == E.undefined then E.undefined else 
  match arg.expression_desc with
  | Number (Int {i} | Uint i) ->
    E.int (Int32.of_int (Ext_list.assoc_by_int None (Int32.to_int i) dispatches))    
  | _ ->  
    E.of_block
      [(S.int_switch arg
      (Ext_list.map (fun (i,r) -> 
              {J.case = i ; 
               body = [S.return (E.int (Int32.of_int  r))],
                      false (* FIXME: if true, still print break*)
              }) dispatches))]

let eval_as_unwrap (arg : J.expression) : E.t =
  match arg.expression_desc with
  | Caml_block ([{expression_desc = Number _}; cb], _, _, _) ->
    cb
  | _ ->
    E.index (arg) 1l

end
module Lam_compile_external_call : sig 
#1 "lam_compile_external_call.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Compile ocaml external function call to JS IR. *) 
val ocaml_to_js_eff : 
  Ast_arg.kind -> 
  J.expression -> 
  J.expression list * J.expression list  

val translate_ffi :
  Location.t -> 
  Ast_ffi_types.ffi -> 
  (* string -> *) (* Not used.. *)
  Lam_compile_defs.cxt -> 
  Ast_arg.kind list -> 
  (*bool -> *)
  J.expression list -> 
  J.expression 
  
(** TODO: document supported attributes
    Attributes starting with `js` are reserved
    examples: "bs.splice"
 *)

end = struct
#1 "lam_compile_external_call.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)



[@@@warning "+9"]

module E = Js_exp_make


(** 
   [bind_name] is a hint to the compiler to generate 
   better names for external module 
*)
let handle_external 
    ({bundle ; bind_name} : Ast_ffi_types.external_module_name)
  : Ident.t * string 
  =
  match bind_name with 
  | None -> 
    Lam_compile_env.add_js_module bundle , bundle
  | Some bind_name -> 
    Lam_compile_env.add_js_module 
      ~hint_name:bind_name
      bundle,
    bundle

let handle_external_opt 
    (module_name : Ast_ffi_types.external_module_name option) 
  : (Ident.t * string) option = 
  match module_name with 
  | Some module_name -> Some (handle_external module_name) 
  | None -> None 



(** The first return value is value, the second argument is side effect expressions 
    Only the [unit] with no label will be ignored
    When  we are passing a boxed value to external(optional), we need
    unbox it in the first place.

    Note when optional value is not passed, the unboxed value would be 
    [undefined], with the combination of `[@bs.int]` it would be still be 
    [undefined], this by default is still correct..  
    {[
      (function () {
           switch (undefined) {
             case 97 : 
               return "a";
             case 98 : 
               return "b";

           }
         }()) === undefined
    ]} 

     This would not work with [NonNullString]
*)
let ocaml_to_js_eff 
    ({ Ast_arg.arg_label;  arg_type })
    (raw_arg : J.expression)
  : E.t list * E.t list  =
  let arg =
    match arg_label with
    | Optional label -> Js_of_lam_option.get_default_undefined raw_arg
    | Label (_, None) | Empty None -> raw_arg
    | Label (_, Some _) 
    | Empty ( Some _)
      -> assert false in 
  match arg_type with
  | Arg_cst _ -> assert false 
  | Fn_uncurry_arity _ -> assert false  
  (* has to be preprocessed by {!Lam} module first *)
  | Extern_unit ->  
    (if arg_label = Ast_arg.empty_label then [] else [E.unit]), 
    (if Js_analyzer.no_side_effect_expression arg then 
       []
     else 
       [arg]) (* leave up later to decide *)
  | Ignore -> 
    [], 
    (if Js_analyzer.no_side_effect_expression arg then 
       []
     else 
       [arg])
  | NullString dispatches -> 
    [Js_of_lam_variant.eval arg dispatches],[]
  | NonNullString dispatches -> 
    Js_of_lam_variant.eval_as_event arg dispatches,[]
  | Int dispatches -> 
    [Js_of_lam_variant.eval_as_int arg dispatches],[]
  | Unwrap ->
    let single_arg =
      match arg_label with
      | Optional label ->
        (**
           If this is an optional arg (like `?arg`), we have to potentially do
           2 levels of unwrapping:
           - if ocaml arg is `None`, let js arg be `undefined` (no unwrapping)
           - if ocaml arg is `Some x`, unwrap the arg to get the `x`, then
             unwrap the `x` itself
        *)
        Js_of_lam_option.get_default_undefined
          ~map:(fun opt_unwrapping exp ->
              match opt_unwrapping with
              | Static_unwrapped ->
                (* If we can unwrap the option statically, do `arg[1]` *)
                E.index exp 1l
              | Runtime_maybe_unwrapped ->
                (* If we can't, do Js_primitive.option_get_unwrap(arg) *)
                E.runtime_call Js_runtime_modules.js_primitive "option_get_unwrap" [raw_arg]
            )
          raw_arg
      | _ ->
        Js_of_lam_variant.eval_as_unwrap raw_arg
    in
    [single_arg],[]
  | Nothing  | Array ->  [arg], []



let empty_pair = [],[]       

let add_eff eff e =
  match eff with
  | None -> e 
  | Some v -> E.seq v e 



(* TODO: fix splice, 
   we need a static guarantee that it is static array construct
   otherwise, we should provide a good error message here, 
   no compiler failure here 
   Invariant : Array encoding
   @return arguments and effect
*)
let assemble_args call_loc ffi  js_splice arg_types args : E.t list * E.t option = 
  let rec aux (labels : Ast_arg.kind list) args = 
    match labels, args with 
    | [] , [] -> empty_pair
    | { arg_label =  Empty (Some cst) ; _} :: labels  , args 
    | { arg_label =  Label (_, Some cst); _} :: labels  , args -> 
      let accs, eff = aux labels args in
      Lam_compile_const.translate_arg_cst cst :: accs, eff 
    | ({arg_label = Empty None | Label (_,None) | Optional _ ;_ } as arg_kind) ::labels, arg :: args
      ->  
      if js_splice && args = [] then 
        let accs, eff = aux labels [] in 
        begin match arg_kind.arg_type with 
          | Array -> 
            begin match (arg : E.t) with 
              | {expression_desc = Array (ls,_mutable_flag) ;_ } -> 
                Ext_list.append ls accs, eff 
              | _ -> 
                Location.raise_errorf ~loc:call_loc
                  {|@{<error>Error:@} function call with %s  is a primitive with [@@bs.splice], it expects its `bs.splice` argument to be a syntactic array in the call site and  all arguments to be supplied|}
                  (Ast_ffi_types.name_of_ffi ffi)
            end
          | _ -> assert false 
        end
      else 
        let accs, eff = aux labels args in 
        let acc, new_eff = ocaml_to_js_eff arg_kind arg in 
        Ext_list.append acc  accs, Ext_list.append new_eff  eff
    | { arg_label = Empty None | Label (_,None) | Optional _  ; _ } :: _ , [] -> assert false 
    | [],  _ :: _  -> assert false      

  in 
  let args, eff = aux arg_types args  in 
  args,
  begin  match eff with
    | [] -> None 
    | x::xs ->  
      Some (E.fuse_to_seq x xs) 
  end

let translate_scoped_module_val module_name fn  scopes = 
  match handle_external_opt module_name with 
  | Some (id,external_name) ->
    begin match scopes with 
      | [] -> 
        E.external_var_dot ~external_name ~dot:fn id 
        (* E.dot (E.var id) fn *)
      | x :: rest -> 
        (* let start = E.dot (E.var id )  x in  *)
        let start = E.external_var_dot ~external_name ~dot:x id in 
        List.fold_left (fun acc x -> E.dot  acc x) start (Ext_list.append rest  [fn])
    end
  | None ->  
    (*  no [@@bs.module], assume it's global *)
    begin match scopes with 
      | [] -> 
        (* E.external_var_dot ~external_name ~dot:fn id  *)
        E.js_var fn
      | x::rest -> 
        let start = E.js_var x  in 
        List.fold_left (fun acc x -> E.dot acc x) start (Ext_list.append rest  [fn])
    end



let translate_scoped_access scopes obj =
  match scopes with 
  | [] ->  obj
  | x::xs -> 
    List.fold_left (fun acc x -> E.dot acc x) (E.dot obj x) xs 
  
let translate_ffi 
    call_loc (ffi : Ast_ffi_types.ffi ) 
    (* prim_name *)
    (cxt  : Lam_compile_defs.cxt)
    arg_types 
    (args : J.expression list) = 
  match ffi with 

  | Js_call{ external_module_name = module_name; 
             name = fn; splice = js_splice ; 
             scopes

           } -> 
    let fn =  translate_scoped_module_val module_name fn scopes in 
    let args, eff  = assemble_args   call_loc ffi js_splice arg_types args in 
    add_eff eff @@              
    E.call ~info:{arity=Full; call_info = Call_na} fn args

  | Js_module_as_var module_name -> 
    let (id, name) =  handle_external  module_name  in
    E.external_var_dot id ~external_name:name 

  | Js_module_as_fn {external_module_name = module_name; splice} ->
    let fn =
      let (id, name) = handle_external  module_name  in
      E.external_var_dot id ~external_name:name 
    in           
    let args, eff = assemble_args   call_loc ffi splice arg_types args in 
    (* TODO: fix in rest calling convention *)          
    add_eff eff @@
    E.call ~info:{arity=Full; call_info = Call_na} fn args

  | Js_module_as_class module_name ->
    let fn =
      let (id,name) = handle_external  module_name in
      E.external_var_dot id ~external_name:name  in           
    let args,eff = assemble_args call_loc  ffi false  arg_types args in 
    (* TODO: fix in rest calling convention *)   
    add_eff eff        
      begin 
        (match cxt.st with 
         | Declare (_, id) | Assign id  ->
           (* Format.fprintf Format.err_formatter "%a@."Ident.print  id; *)
           Ext_ident.make_js_object id 
         | EffectCall | NeedValue -> ())
        ;
        E.new_ fn args
      end            

  | Js_new { external_module_name = module_name; 
             name = fn;
             splice ;
             scopes
           } -> 
    (* This has some side effect, it will 
       mark its identifier (If it has) as an object,
       ATTENTION: 
       order also matters here, since we mark its jsobject property, 
       it  will affect the code gen later
       TODO: we should propagate this property 
       as much as we can(in alias table)
    *)
    let args, eff = assemble_args  call_loc  ffi splice arg_types args in
    let fn =  translate_scoped_module_val module_name fn scopes in 
    add_eff eff 
      begin 
        (match cxt.st with 
         | Declare (_, id) | Assign id  ->
           (* Format.fprintf Format.err_formatter "%a@."Ident.print  id; *)
           Ext_ident.make_js_object id 
         | EffectCall | NeedValue -> ())
        ;
        E.new_ fn args
      end            



  | Js_global {name; external_module_name; scopes} -> 

    (* TODO #11
       1. check args -- error checking 
       2. support [@@bs.scope "window"]
       we need know whether we should call [add_js_module] or not 
    *)
    begin match name, handle_external_opt external_module_name , scopes with 
      | "true", None, []  -> E.js_bool true
      | "false", None, [] -> E.js_bool false
      | "null", None, [] -> E.nil 
      | "undefined", None, [] -> E.undefined
      | _, _, _ -> 
        translate_scoped_module_val external_module_name name scopes
    end
  | Js_send {splice  = js_splice ; name ; pipe = false; js_send_scopes = scopes } -> 
    begin match args  with
      | self :: args -> 
        let [@warning"-8"] ( self_type::arg_types )
          = arg_types in
        let args, eff = assemble_args  call_loc ffi  js_splice arg_types args in
        add_eff eff @@ 
          let self = translate_scoped_access scopes self in 
          E.call ~info:{arity=Full; call_info = Call_na}  (E.dot self name) args
      | _ -> 
        assert false 
    end
  | Js_send { name ; pipe = true ; splice = js_splice; js_send_scopes = scopes  }
    -> (* splice should not happen *)
    (* assert (js_splice = false) ;  *)
    let self, args = Ext_list.exclude_tail args in
    let self_type, arg_types = Ext_list.exclude_tail arg_types in
    let args, eff = assemble_args call_loc ffi  js_splice arg_types args in
    add_eff eff @@
    let self = translate_scoped_access scopes self in 
    E.call ~info:{arity=Full; call_info = Call_na}  (E.dot self name) args

  | Js_get {js_get_name = name; js_get_scopes = scopes } -> 
    let args,cur_eff = assemble_args call_loc ffi false arg_types args in 
    add_eff cur_eff @@ 
    begin match args with 
      | [obj] ->
        let obj = translate_scoped_access scopes obj in 
        E.dot obj name        
      | _ -> assert false  (* Note these assertion happens in call site *)
    end  
  | Js_set {js_set_name = name; js_set_scopes = scopes  } -> 
    (* assert (js_splice = false) ;  *)
    let args,cur_eff = assemble_args call_loc ffi false arg_types args in 
    add_eff cur_eff @@
    begin match args, arg_types with 
      | [obj; v], _ -> 
        let obj = translate_scoped_access scopes obj in
        E.assign (E.dot obj name) v         
      | _ -> 
        assert false 
    end
  | Js_get_index { js_get_index_scopes = scopes }
    -> 
    let args,cur_eff = assemble_args call_loc ffi false arg_types args in 
    add_eff cur_eff @@ 
    begin match args with
      | [obj; v ] -> 
        Js_arr.ref_array (translate_scoped_access scopes obj) v 
      | _ -> assert false 
    end
  | Js_set_index { js_set_index_scopes = scopes }
    -> 
    let args,cur_eff = assemble_args call_loc ffi false arg_types args in 
    add_eff cur_eff @@ 
    begin match args with 
      | [obj; v ; value] -> 
          Js_arr.set_array (translate_scoped_access scopes obj) v value
      | _ -> assert false
    end


end
module Lam_compile_external_obj : sig 
#1 "lam_compile_external_obj.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Compile ocaml external function call to JS IR. *) 

(** 
    This module define how the FFI (via `external`) works with attributes. 
    Note it will route to {!Lam_compile_global} 
    for compiling normal functions without attributes.
 *)

val assemble_args_obj :
  Ast_arg.kind list -> 
  J.expression list -> 
  J.block * J.expression 
(* It returns a block in cases we need set the property dynamically: we need
  create a place holder assignment first and then set it accordingly
*)



end = struct
#1 "lam_compile_external_obj.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)




module E = Js_exp_make
module S = Js_stmt_make

(* Note: can potentially be inconsistent, sometimes 
   {[
     { x : 3 , y : undefined}
   ]}
   and 
   {[
     {x : 3 }
   ]}
   But the default to be undefined  seems reasonable 
*)

(* TODO: check stackoverflow *)
let assemble_args_obj (labels : Ast_arg.kind list)  (args : J.expression list) 
  : J.block * J.expression = 
   let rec aux (labels : Ast_arg.kind list) args 
    : (Js_op.property_name * E.t ) list  * J.expression list * _ = 
    match labels, args with 
    | [] , []  ->  [], [], []
    | {arg_label = Label (label, Some cst )} :: labels  , args -> 
      let accs, eff, assign = aux labels args in 
      (Key label, Lam_compile_const.translate_arg_cst cst )::accs, eff, assign 
    | {arg_label = Empty (Some _) } :: rest  , args -> assert false 
    | {arg_label = Empty None }::labels, arg::args 
      ->  (* unit type*)
      let (accs, eff, assign) as r  = aux labels args in 
      if Js_analyzer.no_side_effect_expression arg then r 
      else (accs, arg::eff, assign)
    | ({arg_label = Label (label,None)  } as arg_kind)::labels, arg::args 
      -> 
      let accs, eff, assign = aux labels args in 
      let acc, new_eff = Lam_compile_external_call.ocaml_to_js_eff arg_kind arg in 
      begin match acc with 
        | [ ] -> assert false
        | x::xs -> 
          (Key label, E.fuse_to_seq x xs ) :: accs , Ext_list.append new_eff  eff , assign
      end (* evaluation order is undefined *)

    | ({arg_label = Optional label; arg_type } as arg_kind)::labels, arg::args 
      -> 
      let (accs, eff, assign) as r = aux labels args  in 
      begin match arg.expression_desc with 
        | Number _ -> (*Invariant: None encoding*)
          r
        | Array ([x],_)
        | Caml_block ([x],_,_,_) ->
          let acc, new_eff = Lam_compile_external_call.ocaml_to_js_eff 
            ({Ast_arg.arg_label = Ast_arg.label label None; arg_type}) x in 
          begin match acc with 
          | [] -> assert false 
          | x::xs -> 
            (Key label, E.fuse_to_seq x xs ) :: accs , Ext_list.append new_eff  eff , assign
          end   
        | _ ->                 
          accs, eff , (arg_kind,arg)::assign 
      end
    | {arg_label = Empty None | Label (_,None) | Optional _  } :: _ , [] -> assert false 
    | [],  _ :: _  -> assert false 
  in 
  let map, eff, assignment = aux labels args in 
  match assignment with 
  | [] -> 
    [],  begin  match eff with
      | [] -> 
        E.obj map 
      | x::xs -> E.seq (E.fuse_to_seq x xs) (E.obj map)
    end
  | _ ->     
    let v  = Ext_ident.create_tmp () in 
    let var_v = E.var v in 
    S.define ~kind:Variable v 
    (begin match eff with
      | [] -> 
        E.obj map 
      | x::xs -> E.seq (E.fuse_to_seq x xs) (E.obj map)     
    end) :: 
      (Ext_list.flat_map (fun 
        ((label : Ast_arg.kind), (arg  : J.expression )) -> 
      match label with 
      | {arg_label = Optional label } -> 
        (* Need make sure whether assignment is effectful or not
          to avoid code duplication
        *)
        begin match Js_ast_util.named_expression arg with 
        | None ->
          [S.if_ arg [S.exp (E.assign (E.dot var_v label) 
            (E.index arg 0l) ) ] ] 
        | Some (st,id) ->
          let var_id = E.var id in         
          st ::  
            [S.if_ var_id [S.exp (E.assign (E.dot var_v label) 
              (E.index var_id 0l)) ]]
        end 
      |  _ -> assert false    
      )
      assignment)
    , var_v                    

end
module Js_of_lam_exception : sig 
#1 "js_of_lam_exception.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






  
val get_builtin_by_name : string -> J.expression


val caml_set_oo_id : J.expression list -> J.expression
val make : J.expression  -> J.expression
(* val make_extension : J.expression  -> J.expression *)

end = struct
#1 "js_of_lam_exception.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






(** An pattern match on {!caml_set_oo_id args}
    Note that in the trunk, it is immutable by default now 
 *)
module E = Js_exp_make 


(* Sync up with [caml_set_oo_id] 
   Note if we inline {!Caml_exceptions.create}, 
   it seems can be useful for optimizations in theory, 
   in practice, it never happen, since the pattern match 
   never dig into it internally, so maybe {!Obj.set_tag} 
   is not necessary at all
*)
let make exception_str  : J.expression = 
  E.runtime_call Js_runtime_modules.exceptions Literals.create [exception_str]

(* let make_extension exception_str  : J.expression =  *)
(*   E.runtime_call Js_config.exceptions "makeExtension" [exception_str] *)


let get_builtin_by_name name = 
  E.runtime_ref Js_runtime_modules.builtin_exceptions (String.lowercase name)


(* let match_exception_def (args : J.expression list) =  *)
(*   match args with    *)
(*   | [{ expression_desc  =  *)
(*                Caml_block ( *)
(*                  [ exception_str;  *)
(*                    {expression_desc = J.Number (Int { i = 0l; _}); _} *)
(*                  ], *)
(*                  mutable_flag,  *)
(*                  {expression_desc = J.Number (Int {i = object_tag; _}); _}, _ ); *)
(*               _} ] ->  *)
(*     if object_tag = 248l (\* Obj.object_tag *\) then *)
(*       Some ( exception_str, mutable_flag)     *)
(*     else *)
(*       None *)
(*   | _ -> None *)

let caml_set_oo_id args = 
      (**
         If we can guarantee this code path is never hit, we can do 
         a better job for encoding of exception and extension?
      *)
      E.runtime_call Js_runtime_modules.exceptions "caml_set_oo_id" args 
    (* begin match match_exception_def args with  *)
    (* | Some ( exception_str, mutable_flag) *)
    (*   ->  *)
    (*   make_exception exception_str  *)
    (* | _ -> *)

    (* end *)

end
module Js_of_lam_float_record : sig 
#1 "js_of_lam_float_record.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






(** Compile a special representation in OCaml when all fields are of type [float] 
    check the invariant in {!Js_of_lam_array.make_array}
*)

val set_double_field : 
  Lambda.set_field_dbg_info -> 
  J.expression -> J.jsint -> 
  J.expression -> J.expression

val get_double_feild : 
  Lambda.field_dbg_info -> 
  J.expression -> J.jsint -> J.expression

end = struct
#1 "js_of_lam_float_record.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






module E = Js_exp_make 

let get_double_feild field_info e i = 
  match field_info with 
  | Lambda.Fld_na -> 
    E.index e i 
  | Lambda.Fld_record s 
  | Lambda.Fld_module s 
    -> E.index ~comment:s e i


let set_double_field field_info e  i e0 = 
  let v = 
    match field_info with 
    | Lambda.Fld_set_na 
      -> 
      E.index e i 
    | Fld_record_set s -> 
      E.index ~comment:s e i in 
  E.assign v  e0


end
module Js_of_lam_tuple : sig 
#1 "js_of_lam_tuple.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Utilities for compiling lambda tuple into JS IR *)

val make : J.expression list -> J.expression

end = struct
#1 "js_of_lam_tuple.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








module E = Js_exp_make

let make (args : J.expression list) =
  E.make_block E.zero_int_literal Blk_tuple args Immutable


end
module Lam_dispatch_primitive : sig 
#1 "lam_dispatch_primitive.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)









(** Compile lambda primitives (note this is different external c calls) *)


(** 
    @return None when the primitives are not handled in  pre-processing
 *)
val translate : 
  string ->
  J.expression list -> J.expression 

end = struct
#1 "lam_dispatch_primitive.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)









module E = Js_exp_make  
module S = Js_stmt_make


(** 
There are two things we need consider:
1.  For some primitives we can replace caml-primitive with js primitives directly
2.  For some standard library functions, we prefer to replace with javascript primitives
    For example [Pervasives["^"] -> ^]
    We can collect all mli files in OCaml and replace it with an efficient javascript runtime

TODO: return type to be expression is ugly, 
   we should allow return block    
*)
let translate (prim_name : string) 
    (args : J.expression list) : J.expression  =
  let call m = 
    E.runtime_call m prim_name args in 
  begin match prim_name with 
  | "caml_gc_stat" 
  | "caml_gc_quick_stat"  
  | "caml_gc_counters"
  | "caml_gc_get"
  | "caml_gc_set"
  | "caml_gc_minor"
  | "caml_gc_major_slice"
  | "caml_gc_major"
  | "caml_gc_full_major"
  | "caml_gc_compaction"
  | "caml_final_register"
  | "caml_final_release"
    ->  call Js_runtime_modules.gc
  | "caml_abs_float" -> 
    E.math "abs" args 
  | "caml_acos_float" -> 
    E.math "acos" args 
  |  "caml_add_float" -> 
    begin match args with 
    | [e0;e1] -> E.float_add e0 e1 (** TODO float plus*)
    | _ -> assert false
    end
  |"caml_div_float" -> 
    begin match args with 
    | [e0;e1] -> E.float_div e0 e1
    | _ -> assert false 
    end
  |"caml_sub_float" -> 
    begin match args with 
    | [e0;e1] -> E.float_minus e0 e1 
    | _ -> assert false 
    end
  | "caml_eq_float" -> 
    begin match args with 
    | [e0;e1] -> E.float_equal e0 e1 
    | _ -> assert false 
    end
  | "caml_ge_float"  ->
    begin match args with 
    | [e0;e1] -> E.float_comp Cge e0 e1
    | _ -> assert false 
    end
  |"caml_gt_float"  ->
    begin match args with 
    | [e0;e1] -> E.float_comp Cgt  e0 e1
    | _ -> assert false 
    end
  | "caml_tan_float"  ->
    E.math "tan" args 
  | "caml_tanh_float"  ->
    E.math "tanh" args 
  | "caml_asin_float"  -> 
    E.math "asin" args 
  | "caml_atan2_float" -> 
    E.math "atan2" args
  | "caml_atan_float" -> 
    E.math "atan" args 
  | "caml_ceil_float" -> 
    E.math "ceil" args 
  | "caml_cos_float" -> 
    E.math "cos" args 
  | "caml_cosh_float" -> 
    E.math "cosh" args
  | "caml_exp_float" -> 
    E.math "exp" args
  | "caml_sin_float" -> 
    E.math "sin" args
  | "caml_sinh_float"-> 
    E.math "sinh" args
  | "caml_sqrt_float" -> 
    E.math "sqrt" args


  | "caml_float_of_int" -> 
    begin match args with 
    | [e] -> e 
    | _ -> assert false 
    end
  | "caml_floor_float" ->
    E.math "floor" args 
  | "caml_log_float" -> 
    E.math "log" args 
  | "caml_log10_float" -> 
    E.math "log10" args 
  | "caml_log1p_float" -> 
    E.math "log1p" args 
  | "caml_power_float"  -> 
    E.math "pow" args
  |  "caml_make_float_vect" -> 
    E.new_ (E.js_global "Array") args 


  | "caml_array_append" -> 
    begin match args with 
    | [e0;e1] -> E.array_append e0 e1
    | _ ->  assert false 
    end

  | "caml_array_get" -> 
    call Js_runtime_modules.array
  | "caml_array_get_addr"
  | "caml_array_get_float"
  | "caml_array_unsafe_get"
  | "caml_array_unsafe_get_float" -> 
    begin match args with 
    | [e0;e1] -> Js_of_lam_array.ref_array e0 e1
    | _ -> assert false
    end
  | "caml_array_set" ->
    call Js_runtime_modules.array
  | "caml_array_set_addr"
  | "caml_array_set_float"
  | "caml_array_unsafe_set"
  | "caml_array_unsafe_set_addr"
  | "caml_array_unsafe_set_float" -> 
    begin match args with 
    | [e0;e1;e2] -> 
      Js_of_lam_array.set_array e0 e1 e2
    | _ -> assert false
    end

  | "caml_int32_add"
    -> 
    begin match args with 
    | [e0;e1] -> E.int32_add e0 e1 
    | _ -> assert false 
    end

  | "caml_nativeint_add" 
    -> 
    begin match args with 
    | [e0;e1] -> E.unchecked_int32_add e0 e1 
    | _ -> assert false 
    end
  | "caml_int32_div" 
    -> 
    begin match args with 
      | [e0;e1] -> 
        E.int32_div  ~checked:(!Js_config.check_div_by_zero) e0 e1
      | _ -> assert false 
    end

  | "caml_nativeint_div" 
    -> (* nativeint behaves exactly the same as js numbers except division *)
    begin match args with 
    | [e0;e1] -> E.int32_div  ~checked:false e0 e1
    | _ -> assert false 
    end

  | "caml_int32_mul"
    -> 
    begin match args with 
    | [e0;e1] -> E.int32_mul e0 e1 
    | _ -> assert false 
    end
  | "caml_nativeint_mul"  -> 
    begin match args with 
    | [e0;e1] -> E.unchecked_int32_mul e0 e1 
    | _ -> assert false 
    end
  | "caml_int32_of_int"
  | "caml_nativeint_of_int" 
  | "caml_nativeint_of_int32" -> 
    begin match args with 
    | [e] -> e 
    | _ -> assert false 
    end
  | "caml_int32_of_float"
  | "caml_int_of_float"
  | "caml_nativeint_of_float" -> 
    begin match args with 
    | [e] -> E.to_int32 e 
    | _ -> assert false 
    end
  | "caml_int32_to_float"
  | "caml_int32_to_int"
  | "caml_nativeint_to_int" 
  | "caml_nativeint_to_float"
  | "caml_nativeint_to_int32" -> 
    begin match args with 
    | [e] -> e (* TODO: do more checking when [to_int32]*)
    | _ -> assert false 
    end
  | "caml_int32_sub" -> 
    begin match args with 
    | [e0;e1] -> E.int32_minus e0 e1 
    | _ -> assert false 
    end

  | "caml_nativeint_sub" ->
    begin match args with 
    | [e0;e1] -> E.unchecked_int32_minus e0 e1 
    | _ -> assert false 
    end
  | "caml_int32_xor" 
  | "caml_nativeint_xor" -> 
    begin match args with 
    | [e0; e1] -> E.int32_bxor e0 e1 
    | _ -> assert false 
    end

  | "caml_int32_and"
  | "caml_nativeint_and" -> 
    begin match args with 
    | [e0;e1] -> E.int32_band e0 e1 
    | _ -> assert false 
    end
  | "caml_int32_or"
  | "caml_nativeint_or" ->
    begin match args with
    | [e0;e1] -> E.int32_bor e0 e1 
    | _ -> assert false  
    end
  | "caml_le_float" ->
    begin match args with 
    | [e0;e1] -> E.float_comp Cle e0 e1 
    | _ -> assert false 
    end
  | "caml_lt_float" ->
    begin match args with 
    | [e0;e1] -> E.float_comp Clt e0 e1 
    | _ -> assert false 
    end
  |  "caml_neg_float" -> 
    begin match args with 
    | [e] -> 
      (** TODO: use float.. *)
      E.int32_minus E.zero_int_literal e 
    | _ -> assert false
    end
  | "caml_neq_float" -> 
    begin match args with 
    | [e0;e1] -> E.float_notequal e0 e1
    | _ -> assert false 
    end
  | "caml_mul_float" -> 
    begin match args with 
    | [e0; e1] -> E.float_mul e0 e1 
    | _ -> assert false  
    end
  | "caml_int64_to_float"
    -> Js_long.to_float args
  | "caml_int64_of_float"
    -> Js_long.of_float args
  | "caml_int64_compare"
    -> Js_long.compare args 
  | "js_int64_discard_sign"
    -> Js_long.discard_sign args
  | "js_int64_div_mod"
    -> Js_long.div_mod args
  | "js_int64_to_hex"
    -> Js_long.to_hex args    
  | "caml_int64_bits_of_float"
    -> Js_long.bits_of_float args     
  | "caml_int64_float_of_bits"
    -> Js_long.float_of_bits args 
  | "caml_int64_bswap"
    -> Js_long.swap args    
  | "caml_int32_float_of_bits"
  | "caml_int32_bits_of_float"
  | "caml_classify_float"
  | "caml_modf_float"
  | "caml_ldexp_float"
  | "caml_frexp_float"
  | "caml_float_compare"
  | "caml_copysign_float"
  | "caml_expm1_float"
  | "caml_hypot_float"

    ->
    call Js_runtime_modules.float
  | "caml_fmod_float" 
    (* float module like js number module *)      
    ->      
    begin match args with 
    | [e0;e1] -> E.float_mod e0 e1
    | _ -> assert false 
    end

  | "caml_string_equal" 
    -> 
    begin match args with 
    | [e0; e1] -> E.string_equal e0 e1 
    | _ -> assert false 
    end
  | "caml_string_notequal"
    -> 
    begin match args with 
    | [e0; e1] -> E.string_comp NotEqEq e0 e1
    (** TODO: convert to ocaml ones*)
    | _ -> assert false 
    end
  | "caml_string_lessequal"
    -> 
    begin 
      match args with 
      | [e0; e1] 
        -> 
        E.string_comp Le e0 e1
      | _ -> assert false 
    end
  | "caml_string_lessthan"
    -> 
    begin match args with 
    | [e0; e1] 
      -> 
      E.string_comp Lt e0 e1
    | _ -> assert false 
    end
  | "caml_string_greaterequal"
    -> 
    begin match args with 
    | [e0; e1] 
      -> 
      E.string_comp Ge  e0 e1
    | _ -> assert false 
    end
  | "caml_string_greaterthan"
    -> 
    begin match args with 
    | [e0; e1] 
      -> 
      E.string_comp Gt  e0 e1
    | _ -> assert false 
    end
  | "caml_create_string" -> 
    (* Note that for invalid range, JS raise an Exception RangeError, 
       here in OCaml it's [Invalid_argument], we have to preserve this semantics.
        Also, it's creating a [bytes] which is a js array actually.
    *)
    begin match args with
    | [{expression_desc = Number (Int {i; _}); _} as v] 
      when i >= 0l -> 
      E.uninitialized_array v 
    (* TODO: inline and spits out a warning when i is negative *)
    | _ -> 
      call Js_runtime_modules.string 
    end

  | "caml_string_get"
  | "caml_string_compare"
  | "string_of_bytes"
  | "bytes_of_string"

  | "caml_is_printable"
  | "caml_string_of_char_array"
  | "caml_fill_string"
  | "caml_blit_string" 
  | "caml_blit_bytes"
    -> 
    call Js_runtime_modules.string

  | "caml_register_named_value" -> 
    (**
       callback.ml
       {[ external register_named_value : string -> Obj.t -> unit
         = "caml_register_named_value" ]}

       See the manual chap19, Interfacing C with OCaml

       {[
         let f x = print_string "f is applied to "; print_int x; print_newline()
         let _ = Callback.register "test function" f
       ]}

       On the C side 
       {[
         let f x = print_string "f is applied to "; print_int x; print_newline()
         let _ = Callback.register "test function" f
       ]}

       [caml_named_value] is a c primitive but not belong to OCaml/runtimedef.ml,
       so we don't needs
       handle it 
    *)
    E.unit

  | "caml_backtrace_status"


  | "caml_get_exception_backtrace"
  | "caml_get_exception_raw_backtrace"
  | "caml_record_backtrace"
  | "caml_convert_raw_backtrace" 
  | "caml_get_current_callstack"
    -> E.unit
  (* unit -> unit 
     _ -> unit  
     major_slice : int -> int 
  *)
  (** Note we captured [exception/extension] creation in the early pass, this primitive is 
      like normal one to set the identifier *)
  
  | "caml_set_oo_id" 
    ->
    Js_of_lam_exception.caml_set_oo_id args 

  | "caml_sys_const_big_endian" -> 
    (** return false *)
    E.bool Sys.big_endian
  | "caml_sys_const_word_size" -> 
    E.small_int  Sys.word_size
  (** TODO: How it will affect program behavior *)
  | "caml_sys_const_ostype_cygwin" -> E.caml_false 
  | "caml_sys_const_ostype_win32" -> E.caml_false 
  | "caml_sys_const_ostype_unix" -> E.caml_true
  | "caml_is_js" -> E.caml_true
  | "caml_sys_get_config" ->
    (** No cross compilation *)
    Js_of_lam_tuple.make [E.str Sys.os_type; E.small_int  Sys.word_size; 
                          E.bool Sys.big_endian ]
  | "caml_sys_get_argv" 
    (** TODO: refine
        Inlined here is helpful for DCE
        {[ external get_argv: unit -> string * string array = "caml_sys_get_argv" ]}
    *)
    (* Js_of_lam_tuple.make [E.str "cmd";  *)
    (*                       Js_of_lam_array.make_array NA Pgenarray [] *)
    (*                      ] *)
  | "caml_sys_time"
  | "caml_sys_random_seed"
  | "caml_sys_getenv"
  | "caml_sys_system_command" 
  | "caml_sys_getcwd" (* check browser or nodejs *)
  | "caml_sys_is_directory"
  | "caml_sys_exit"
  (* | "caml_sys_file_exists" *)
    -> 
    call Js_runtime_modules.sys
  | "caml_lex_engine"
  | "caml_new_lex_engine"
    -> 
    call Js_runtime_modules.lexer 
  | "caml_parse_engine"
  | "caml_set_parser_trace" 
    -> 
    call Js_runtime_modules.parser 

  | "caml_array_sub"
  | "caml_array_concat"
  (*external concat: 'a array list -> 'a array 
     Not good for inline *)

  | "caml_array_blit"
  | "caml_make_vect" -> 
    call Js_runtime_modules.array
  | "caml_ml_flush"
  | "caml_ml_out_channels_list"
  | "caml_ml_open_descriptor_in" 
  | "caml_ml_open_descriptor_out"
  | "caml_ml_output_char"
  | "caml_ml_output" 
  | "caml_ml_input_char"
    -> 
    call Js_runtime_modules.io
  | "caml_update_dummy"
  | "caml_obj_dup" -> 
    (** Note currently is an Array copy function, this is tightly coupled with 
        how record, tuple encoded in JS.
        Here we only inline constant cases, since this semantics should be preserved 
        no matter how we represent objects, we don't inline it just for future
    *)
    begin 
      match args with 
      | [ a ] when Js_analyzer.is_constant a ->  a 
      | _ -> 
        call Js_runtime_modules.obj_runtime 
    end
  | "caml_obj_block" -> 
    (** TODO: Optimize  for [CamlinternalOO] input 
        external new_block : tag:int -> size:int  -> t = "caml_obj_block"
        Note that we don't need initialize its content anyway
        TODO: more optimizations later
        ATTENTION: This optmization is coupled with memory layout
    *)
    begin match args with 
    | [ tag; 
        {expression_desc = Number (Int { i ;_}); _} ] ->
      E.make_block tag Blk_na 
        (Ext_list.init (Int32.to_int i) 
           (fun _ -> E.zero_int_literal)) NA

    | [ tag; size] -> 
      E.uninitialized_object tag size
    | _ -> assert false


    end
  | "caml_format_float"

  | "caml_nativeint_format"
  | "caml_int32_format"
  | "caml_float_of_string"
  | "caml_int_of_string" (* what is the semantics?*)
  | "caml_int32_of_string"
  | "caml_nativeint_of_string" 
  | "caml_int64_format"
  | "caml_int64_of_string"
    -> 
    call Js_runtime_modules.format 
  | "caml_format_int" -> 
    begin match args with 
    | [ {expression_desc = Str (_, "%d"); _}; v] 
      ->
      E.int_to_string v 
    | _ -> 
      call Js_runtime_modules.format
    end
    (*   "caml_alloc_dummy"; *)
    (* TODO:   "caml_alloc_dummy_float"; *)


  | "caml_obj_is_block"
    -> 
    begin match args with 
    | [e] -> E.is_caml_block e 
    | _ -> assert false
    end
  | "caml_obj_truncate"
  | "caml_lazy_make_forward"
  | "caml_compare"
  | "caml_int_compare"
  | "caml_int32_compare"
  | "caml_nativeint_compare"
  | "caml_equal"
  | "caml_notequal"
  | "caml_greaterequal"
  | "caml_greaterthan"
  | "caml_lessequal"
  | "caml_lessthan"

    -> 
    call Js_runtime_modules.obj_runtime
  | "caml_obj_set_tag" 
    -> begin match args with 
      | [a;b]  -> E.set_tag a b 
      | _ -> assert false end
  | "caml_obj_tag" -> 
    (* Note that in ocaml, [int] has tag [1000] and [string] has tag [252]
       also now we need do nullary check 
    *)      
    begin match args with 
    | [e] -> E.tag e 
    | _ -> assert false end

  (* Unix support *)
  | "unix_tcdrain"
  | "unix_tcflush"
  | "unix_setsid"
  | "unix_tcflow"
  | "unix_tcgetattr"
  | "unix_tcsetattr"
  | "unix_tcsendbreak"
  | "unix_getprotobynumber"
  | "unix_getprotobyname"
  | "unix_getservbyport"
  | "unix_getservbyname"
  | "unix_getservbyaddr"
  | "unix_gethostbyname"
  | "unix_gethostname"
  | "unix_getpeername"
  | "unix_accept"
  | "unix_bind"
  | "unix_connect"
  | "unix_listen"
  | "unix_shutdown"
  | "unix_getsockname"
  | "unix_gethostbyaddr"
  | "unix_getgrnam"
  | "unix_getpwuid"
  | "unix_getgrgid"
  | "unix_inet_addr_of_string"
  | "unix_string_of_inet_addr"
  | "unix_socket"
  | "unix_socketpair"
  | "unix_error_message"
  | "unix_read"
  | "unix_write"
  | "unix_single_write"
  | "unix_set_close_on_exec"
  | "unix_sigprocmask"
  | "unix_sigsuspend"
  | "unix_recv"
  | "unix_recvfrom"
  | "unix_send"
  | "unix_sendto"
  | "unix_getsockopt"
  | "unix_setsockopt"
  | "unix_getaddrinfo"
  | "unix_getnameinfo"
  | "unix_waitpid"
  | "unix_wait"
  | "unix_fork"
  | "unix_execv"
  | "unix_dup"
  | "unix_close"
  | "unix_dup2"
  | "unix_execvp"
  | "unix_execvpe"
  | "unix_pipe"
  | "unix_execve"
  | "caml_channel_descriptor"
  | "unix_putenv"
  | "unix_environment"
  | "unix_lseek"
  | "unix_getppid"
  | "unix_getpid"
  | "unix_nice"
  | "unix_open"
  | "unix_truncate"
  | "unix_ftruncate"
  | "unix_stat"
  | "unix_lstat"
  | "unix_fstat"
  | "unix_isatty"
  | "unix_lseek_64"
  | "unix_truncate_64"
  | "unix_ftruncate_64"
  | "unix_stat_64"
  | "unix_lstat_64"
  | "unix_fstat_64"
  | "unix_unlink"
  | "unix_rename"
  | "unix_link"
  | "unix_chmod"
  | "unix_fchmod"
  | "unix_chown"
  | "unix_fchown"
  | "unix_umask"
  | "unix_access"
  | "unix_set_nonblock"
  | "unix_clear_nonblock"
  | "unix_clear_close_on_exec"
  | "unix_mkdir"
  | "unix_rmdir"
  | "unix_chdir"
  | "unix_getcwd"
  | "unix_chroot"
  | "unix_opendir"
  | "unix_readdir"
  | "unix_rewinddir"
  | "unix_closedir"
  | "unix_mkfifo"
  | "unix_symlink"
  | "unix_readlink"
  | "unix_select"
  | "unix_lockf"
  | "unix_kill"
  | "unix_sigpending"
  | "unix_time"
  | "unix_gettimeofday"
  | "unix_gmtime"
  | "unix_localtime"
  | "unix_mktime"
  | "unix_alarm"
  | "unix_sleep"
  | "unix_times"
  | "unix_utimes"
  | "unix_getitimer"
  | "unix_setitimer"
  | "unix_getuid"
  | "unix_geteuid"
  | "unix_setuid"
  | "unix_getgid"
  | "unix_getegid"
  | "unix_setgid"
  | "unix_getgroups"
  | "unix_setgroups"
  | "unix_initgroups"
  | "unix_getlogin"
  | "unix_getpwnam"
    ->  E.not_implemented prim_name
  (* End of Unix support *)
  (* bigarrary support *)
  | "caml_ba_init"
    -> 
    begin match args with 
      | [e] -> E.seq e E.unit 
      | _ -> assert false
    end
  | "caml_ba_create"
  | "caml_ba_get_generic"
  | "caml_ba_set_generic"
  | "caml_ba_num_dims"
  | "caml_ba_dim"
  | "caml_ba_kind"
  | "caml_ba_layout"
  | "caml_ba_sub"
  | "caml_ba_slice"
  | "caml_ba_blit"
  | "caml_ba_fill"
  | "caml_ba_reshape"
  | "caml_ba_map_file_bytecode"

    (* caml_ba_get_1,  (\* %caml_ba_ref_1 *\) *)
    (* caml_ba_get_2, *)
    (* caml_ba_get_3, *)

    (* caml_ba_set_1,  // %caml_ba_set_1 *)
    (* caml_ba_set_2, *)
    (* caml_ba_set_3, *)

    (* caml_ba_dim_1, // %caml_ba_dim_1 *)
    (* caml_ba_dim_2,  *)
    (* caml_ba_dim_3,  *)

    -> 
    E.not_implemented prim_name
    (* call  Js_config.bigarray *)
  (* End of bigarray support *)
  | "caml_convert_raw_backtrace_slot"
    -> call  Js_runtime_modules.backtrace

  | "caml_bswap16"
  | "caml_int32_bswap"
  | "caml_nativeint_bswap" 
    -> call Js_runtime_modules.int32
  | "caml_get_public_method"
    ->
    call Js_runtime_modules.oo
  (** TODO: Primitives not implemented yet ...*)
  | "caml_install_signal_handler"
    -> 
    begin match args with
    | [num; behavior] 
      -> E.seq num behavior (*TODO:*)
    | _ -> assert false
    end
  | "caml_md5_string"
    -> call Js_runtime_modules.md5
  | "caml_hash"
    -> call Js_runtime_modules.hash 
  | "caml_weak_set"
  | "caml_weak_create"
  | "caml_weak_get"
  | "caml_weak_check"
  | "caml_weak_blit"
  | "caml_weak_get_copy"
    -> call Js_runtime_modules.weak

  | "caml_output_value_to_buffer"
  | "caml_marshal_data_size"
  | "caml_input_value_from_string"
  | "caml_output_value"
  | "caml_input_value"
  | "caml_output_value_to_string"
  | "caml_md5_chan"
  | "caml_hash_univ_param"
  | "caml_sys_close"
  | "caml_sys_open"
  | "caml_ml_input"
  | "caml_ml_input_scan_line"
  | "caml_ml_input_int"
  | "caml_ml_close_channel"
  | "caml_ml_output_int"

  | "caml_ml_channel_size_64"
  | "caml_ml_channel_size"
  | "caml_ml_pos_in_64"
  | "caml_ml_pos_in"
  | "caml_ml_seek_in"
  | "caml_ml_seek_in_64"
  | "caml_ml_pos_out"
  | "caml_ml_pos_out_64"
  | "caml_ml_seek_out"
  | "caml_ml_seek_out_64"
  | "caml_ml_set_binary_mode"
    ->  E.not_implemented prim_name
  | _ -> 
      let comment = "Missing primitive" in       
      Ext_log.warn __LOC__  "%s: %s when compiling %s\n" comment prim_name 
        (Js_config.get_current_file ()) ;
      E.not_implemented prim_name
      (*we dont use [throw] here, since [throw] is an statement 
        so we wrap in IIFE
        TODO: we might provoide a hook for user to provide polyfill.
        For example `Bs_global.xxx`
      *)        

  end 



;;

end
module Lam_compile_primitive : sig 
#1 "lam_compile_primitive.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Primitive compilation  *) 

(* The entry point of compile primitives
   Note it will call {!Lam_compile_external_call.translate} for c stubs compilation
 *)

val translate : 
  Location.t -> 
  Lam_compile_defs.cxt  -> Lam.primitive -> J.expression list -> J.expression

end = struct
#1 "lam_compile_primitive.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








module E = Js_exp_make 

(* If it is the return value, since it is a side-effect call,
   we return unit, otherwise just return it
*)
let decorate_side_effect ({st; should_return;_} : Lam_compile_defs.cxt) e : E.t = 
  match st, should_return with 
  | _, ReturnTrue _ 
  | (Assign _ | Declare _ | NeedValue), _  -> E.seq e E.unit
  | EffectCall, ReturnFalse -> e 
(* NeedValue should return a meaningful expression*)

let translate  loc
    ({ meta = { env; _}; _} as cxt : Lam_compile_defs.cxt) 
    (prim : Lam.primitive)
    (args : J.expression list) : J.expression = 
  match prim with
  (* | Pcreate_exception s  *)
  (*   ->  *)
  (*   Js_of_lam_exception.make_exception (E.str s) *)
  | Pcreate_extension s 
    -> 
    Js_of_lam_exception.make (E.str s)
  | Pwrap_exn -> 
    E.runtime_call Js_runtime_modules.exn "internalToOCamlException" args 
  | Lam.Praw_js_code_exp s -> 
    E.raw_js_code Exp s  
  | Lam.Praw_js_code_stmt s -> 
    E.raw_js_code Stmt s 
  | Lam.Pjs_runtime_apply -> 
    begin match args with 
      | [f ;  args] -> 
        E.flat_call f args
      | _ -> assert false 
    end
  | Pjs_apply -> 
    begin match args with 
      | fn :: rest -> 
        E.call ~info:{arity=Full; call_info =  Call_na} fn rest 
      | _ -> assert false
    end

  | Lam.Pnull_to_opt -> 
    begin match args with 
      | [e] -> 
        begin match e.expression_desc with 
          | Var _ -> 
            E.econd (E.is_nil e) Js_of_lam_option.none (Js_of_lam_option.some e)
          | _ ->
            E.runtime_call Js_runtime_modules.js_primitive
              "null_to_opt" args 
              (* GPR #974
                 let id = Ext_ident.create "v" in
                 let tmp = E.var id in
                 E.(seq (assign tmp e ) 
                    (econd (is_nil tmp) Js_of_lam_option.none (Js_of_lam_option.some tmp)) )
              *)
        end
      | _ -> assert false 
    end
  | Lam.Pundefined_to_opt ->
    begin match args with 
      | [e] -> 
        begin match e.expression_desc with 
          | Var _ -> 
            E.econd (E.is_undef e) Js_of_lam_option.none (Js_of_lam_option.some e)
          | _ -> 
            E.runtime_call Js_runtime_modules.js_primitive  
              "undefined_to_opt" args 
              (* # GPR 974
                 let id = Ext_ident.create "v" in
                 let tmp = E.var id in
                 E.(seq (assign tmp e ) 
                     (econd (is_undef tmp) Js_of_lam_option.none (Js_of_lam_option.some tmp)) )
              *)
        end
      | _ -> assert false 
    end    
  | Lam.Pnull_undefined_to_opt -> 
    begin match args with 
      | [e] -> 
        begin match e.expression_desc with 
          | Var _ -> 
            E.econd (E.is_null_undefined e) 
              Js_of_lam_option.none 
              (Js_of_lam_option.some e)
          | _ ->
            E.runtime_call 
              Js_runtime_modules.js_primitive        
              "null_undefined_to_opt" args 
        end
      | _ -> assert false  
    end   
  | Pjs_function_length -> 
    begin match args with 
      | [f] -> E.function_length f
      | _ -> assert false 
    end
  | Lam.Pcaml_obj_length -> 
    begin match args with 
      | [e] -> E.obj_length e 
      | _ -> assert false 
    end
  | Lam.Pcaml_obj_set_length -> 
    begin match args with 
      | [a;b] -> E.set_length a b 
      | _ -> assert false 
    end
  | Lam.Pjs_string_of_small_array -> 
    begin match args with 
      | [e] -> E.string_of_small_int_array e 
      | _ -> assert false 
    end 
  | Lam.Pjs_is_instance_array -> 
    begin match args with 
      | [e] -> E.is_instance_array e 
      | _ -> assert false 
    end 


  | Pis_null -> 
    begin match args with 
      | [e] -> E.is_nil e 
      | _ -> assert false 
    end   
  | Pis_undefined -> 
    begin match args with 
      | [e] -> E.is_undef e 
      | _ -> assert false 
    end
  | Pis_null_undefined -> 
    begin match args with 
      | [ arg] -> 
        E.is_null_undefined arg
      | _ -> assert false 
    end
  
  | Pjs_boolean_to_bool -> 
    begin match args with 
      | [e] -> E.bool_of_boolean e 
      | _ -> assert false 
    end
  | Pjs_typeof -> 
    begin match args with 
      | [e] -> E.typeof e 
      | _ -> assert false 
    end
  | Pjs_unsafe_downgrade _
  | Pdebugger 
  | Pjs_fn_run _ 
  | Pjs_fn_make _

  | Pjs_fn_runmethod _ 
    -> assert false (* already handled by {!Lam_compile} *)
  | Pjs_fn_method _ -> assert false
  | Pglobal_exception id ->
    Js_of_lam_exception.get_builtin_by_name id.name    
  | Pstringadd ->
    begin match args with      
      | [a;b] ->
        E.string_append a b
      | _ -> assert false          
    end          
  | Pinit_mod -> 
    E.runtime_call Js_runtime_modules.module_ "init_mod" args
  | Pupdate_mod ->
    E.runtime_call Js_runtime_modules.module_ "update_mod" args
  | Pmakeblock(tag, tag_info, mutable_flag ) ->  (* RUNTIME *)
    Js_of_lam_block.make_block 
      (Js_op_util.of_lam_mutable_flag mutable_flag) 
      tag_info (E.small_int tag) args 
  | Pfield (i, fld_info) -> 
    begin match args with 
      | [ e ]  -> 
        Js_of_lam_block.field fld_info e (Int32.of_int i)
      (* Invariant depends on runtime *)
      | _ -> assert false
    end

  (** Negate boxed int *)
  | Pnegbint Pint32
    ->
    begin match args with
      | [ e ] -> E.int32_minus (E.zero_int_literal)  e 
      | _ -> assert false
    end
  | Pnegint
    -> 
    begin match args with (* #977 *)
      | [ e ] -> E.int32_minus (E.zero_int_literal)  e 
      | _ -> assert false
    end

  | Pnegbint Pnativeint
    -> 
    begin match args with
      | [ e ] -> E.unchecked_int32_minus (E.zero_int_literal)  e 
      | _ -> assert false
    end
  | Pnegbint Pint64
    -> 
    Js_long.neg args 


  | Pnegfloat 
    -> 
    begin match args with 
      | [ e ] -> E.float_minus (E.zero_float_lit) e 
      | _ -> assert false
    end
  (** Negate boxed int end*)
  (* Int addition and subtraction *)
  | Paddint 
  | Paddbint  Pint32
    ->
    begin match args with
      | [e1;e2] ->
        E.int32_add  e1  e2
      | _ -> assert false
    end
  | Paddbint Pnativeint 
    -> 
    begin match args with
      | [e1;e2] ->
        E.unchecked_int32_add  e1  e2
      | _ -> assert false
    end

  | Paddbint Pint64
    ->  
    Js_long.add args 


  | Paddfloat
    -> 
    begin match args with
      | [e1;e2] ->
        E.float_add  e1  e2
      | _ -> assert false
    end
  | Psubint 
    -> 
    begin match args with 
      | [e1; e2] ->     
        E.int32_minus e1 e2 
      | _ -> assert false
    end
  | Psubbint Pint32
    -> 
    begin match args with
      | [e1;e2] ->
        E.int32_minus   e1  e2
      | _ -> assert false 
    end
  | Psubbint Pnativeint
    -> 
    begin match args with
      | [e1;e2] ->
        E.unchecked_int32_minus   e1  e2
      | _ -> assert false 
    end
  | Psubbint Pint64
    -> 
    Js_long.sub args 
  | Psubfloat
    ->
    begin match args with
      | [e1;e2] ->
        E.float_minus   e1  e2
      | _ -> assert false 
    end
  | Pmulbint Lambda.Pnativeint
    -> 
    begin match args with
      | [e1; e2]  ->
        E.unchecked_int32_mul  e1  e2
      | _ -> assert false 
    end

  | Pmulint 
  | Pmulbint Lambda.Pint32
    ->
    begin match args with
      | [e1; e2]  ->
        E.int32_mul  e1  e2
      | _ -> assert false 
    end
  | Pmulbint Pint64 
    -> 
    Js_long.mul args 
  | Pmulfloat 
    -> 
    begin match args with
      | [e1; e2]  ->
        E.float_mul  e1  e2
      | _ -> assert false 
    end
  | Pdivfloat -> 
    begin match args with  
      | [e1;e2] -> E.float_div  e1  e2
      | _ -> assert false 
    end
  | Pdivbint Pnativeint
    -> 
    begin match args with 
      | [e1;e2] ->
        E.int32_div ~checked:false e1 e2
      | _ -> assert false
    end
  | Pdivint 
  | Pdivbint Pint32
    -> 
    begin match args with 
      | [e1;e2] ->
        E.int32_div ~checked:(!Js_config.check_div_by_zero) e1 e2
      | _ -> assert false
    end

  | Pdivbint Pint64 
    -> Js_long.div args 
  | Pmodint 
  | Pmodbint Pnativeint
  | Pmodbint Pint32
    ->
    begin match args with
      | [e1; e2] ->
        E.int32_mod   ~checked:(!Js_config.check_div_by_zero) e1  e2
      | _ -> assert false 
    end
  | Pmodbint Lambda.Pint64 
    -> Js_long.mod_ args  
  | Plslint 
  | Plslbint Lambda.Pnativeint
  | Plslbint Lambda.Pint32
    ->
    begin match args with
      | [e1;e2] ->
        E.int32_lsl e1  e2
      | _ -> assert false 
    end
  | Plslbint Lambda.Pint64 
    -> Js_long.lsl_ args
  | Plsrbint Lambda.Pnativeint
    -> 
    begin match args with
      | [e1; e2] ->
        E.int32_lsr   e1  e2
      | _ -> assert false
    end
  | Plsrint 
  | Plsrbint Lambda.Pint32
    ->
    begin match args with
      | [e1; {J.expression_desc = Number (Int {i=0l; _}|Uint 0l | Nint 0n); _}]
        -> 
        e1
      | [e1; e2] ->
        E.to_int32 @@ E.int32_lsr   e1  e2
      | _ -> assert false
    end
  | Plsrbint Lambda.Pint64
    -> Js_long.lsr_ args
  | Pasrint 
  | Pasrbint Lambda.Pnativeint
  | Pasrbint Lambda.Pint32
    ->
    begin match args with
      | [e1;e2] ->
        E.int32_asr  e1  e2
      | _ -> assert false
    end
  | Pasrbint Lambda.Pint64 
    -> Js_long.asr_ args      
  | Pandint 
  | Pandbint Lambda.Pnativeint
  | Pandbint Lambda.Pint32
    ->
    begin match args with
      | [e1;e2] ->
        E.int32_band  e1  e2
      | _ -> assert false
    end
  | Pandbint Lambda.Pint64
    -> Js_long.and_ args
  | Porint 
  | Porbint Lambda.Pnativeint
  | Porbint Lambda.Pint32
    ->
    begin match args with
      | [e1;e2] ->
        E.int32_bor  e1  e2
      | _ -> assert false
    end
  | Porbint Lambda.Pint64 
    -> Js_long.or_ args
  | Pxorint 
  | Pxorbint Lambda.Pnativeint
  | Pxorbint Lambda.Pint32 
    -> 
    begin match args with
      | [e1;e2] ->
        E.int32_bxor  e1  e2
      | _ -> assert false
    end
  | Pxorbint Lambda.Pint64 
    ->
    Js_long.xor args    
  | Pjscomp cmp ->
    begin match args with
      | [l;r] -> E.js_comp cmp l r 
      | _ -> assert false 
    end
  | Pbintcomp (Pnativeint ,cmp)
  | Pfloatcomp cmp
  | Pintcomp cmp
  | Pbintcomp (Pint32 ,cmp)
    ->
    begin 
      (* Global Builtin Exception is an int, like 
         [Not_found] or [Invalid_argument] ?
      *)
      match args with 
      | [e1;e2] -> E.int_comp cmp e1 e2
      | _ -> assert false 
    end
  (* List --> stamp = 0 
     Assert_false --> stamp = 26 
  *)
  | Pbintcomp (Pint64 ,cmp)
    -> Js_long.comp cmp args

  | Pcvtbint ((Pint32 | Pnativeint ), Pint64) 
    -> Js_long.of_int32 args
  | Pcvtbint (Pint64, Pint64)
  | Pcvtbint ((Pnativeint|Pint32), (Pnativeint|Pint32))
    ->   
    begin match args with 
      | [e0] -> e0 
      | _ -> assert false
    end
  | Pcvtbint (Pint64, (Pnativeint|Pint32)) 
    ->  
    Js_long.to_int32 args 
  | Pintoffloat -> 
    begin
      match args with 
      | [e] -> E.to_int32 e 
      | _ -> assert false 
    end
  | Pbintofint Pint64
    -> Js_long.of_int32 args 
  | Pbintofint (Pnativeint 
               | Pint32 )
  | Pintofbint Pnativeint
  | Pintofbint Pint32
  | Pfloatofint 
    -> 
    begin match args with 
      | [e] -> e 
      | _ -> assert false 
    end
  | Pintofbint Pint64
    -> Js_long.to_int32 args
  | Pabsfloat -> 
    begin match args with 
      | [e] ->
        E.math "abs" [e]
      (* GCC treat built-ins like Math in a dirfferent way*)
      | _ -> assert false
    end
  | Pnot ->
    begin match args with
      | [e] ->  E.not  e 
      | _ -> assert false
    end
  | Poffsetint n ->
    begin match args with
      | [e] ->  E.int32_add  e (E.small_int  n)
      | _ -> assert false
    end
  | Poffsetref n ->
    begin match args with
      | [e] -> 
        let v = (Js_of_lam_block.field Fld_na e 0l) in
        E.seq (E.assign  v (E.int32_add v (E.small_int  n))) E.unit
      | _ -> assert false
    end

  | Psequand -> (* TODO: rhs is possibly a tail call *)
    begin match args with
      | [e1;e2] ->
        E.and_   e1  e2
      | _ -> assert false
    end
  | Psequor -> (* TODO: rhs is possibly a tail call *)
    begin match args with
      | [e1;e2] ->
        E.or_  e1  e2
      | _ -> assert false
    end
  | Pisout -> 
    begin match args with 
      (* predicate: [x > range  or x < 0 ]
         can be simplified if x is positive , x > range
         if x is negative, fine, its uint is for sure larger than range,
         the output is not readable, we might change it back.

         Note that if range is small like [1], then the negative of 
         it can be more precise (given integer)
         a normal case of the compiler is  that it will do a shift 
         in the first step [ (x - 1) > 1 or ( x - 1 ) < 0 ]
      *)
      | [range; e] -> E.is_out e range
      | _ -> assert false
    end
  | Pbytes_of_string -> 
    begin 
      (* TODO: write a js primitive  - or is it necessary ?
         if we have byte_get/string_get
         still necessary, since you can set it now.
      *)
      match args with 
      |[e] -> Js_of_lam_string.bytes_of_string e
      | _ -> assert false
    end
  | Pbytes_to_string  -> 
    begin 
      match args with 
      |[e] -> Js_of_lam_string.bytes_to_string e 
      | _ -> assert false
    end
  | Pstringlength ->
    begin match args with
      | [e] -> E.string_length e 
      | _ -> assert false 
    end
  | Pbyteslength  -> 
    begin match args with
      | [e] -> E.bytes_length e 
      | _ -> assert false 
    end
  (* This should only be Pbyteset(u|s), which in js, is an int array 
     Bytes is an int array in javascript
  *)
  | Pbytessetu
  | Pbytessets -> 
    begin match args with
      | [e;e0;e1] -> decorate_side_effect cxt 
                       (Js_of_lam_string.set_byte e e0 e1)

      | _ -> assert false
    end
  | Pbytesrefu ->
    begin match args with
      | [e;e1] -> Js_of_lam_string.ref_byte e e1
      | _ -> assert false
    end

  | Pbytesrefs ->
    begin match args with
      | [e ; e1] ->
        if !Clflags.fast then
          Js_of_lam_string.ref_byte e e1
        else E.runtime_call Js_runtime_modules.bytes "get" args            
      | _ -> assert false         
    end
  (* For bytes and string, they both return [int] in ocaml 
      we need tell Pbyteref from Pstringref
      1. Pbyteref -> a[i]
      2. Pstringref -> a.charCodeAt (a[i] is wrong)
  *)
  | Pstringrefu  ->
    begin match args with
      | [e;e1] -> Js_of_lam_string.ref_string e e1 
      | _ -> assert false
    end

  | Pstringrefs ->
    begin match args with
      | [e;e1] ->
        if !Clflags.fast then
          Js_of_lam_string.ref_string e e1             
        else       
          E.runtime_call Js_runtime_modules.string "get" args          
      | _ -> assert false
    end
  (** only when Lapply -> expand = true*)
  | Praise  -> assert false (* handled before here *)

  (* Runtime encoding relevant *)
  | Parraylength Pgenarray
  | Parraylength Paddrarray
  | Parraylength Pintarray
  | Parraylength Pfloatarray  -> 
    begin match args with 
      | [e] -> E.array_length e 
      | _ -> assert false
    end
  | Psetfield (i, _, field_info) -> 
    begin match args with 
      | [e0;e1] ->  (** RUNTIME *)
        decorate_side_effect cxt 
          (Js_of_lam_block.set_field field_info e0 (Int32.of_int i) e1)
      (*TODO: get rid of [E.unit ()]*)
      | _ -> assert false
    end
  | Psetfloatfield (i,field_info)
    -> (** RUNTIME --  RETURN VALUE SHOULD BE UNIT *)
    begin 
      match args with 
      | [e;e0] -> 
        decorate_side_effect cxt 
          (Js_of_lam_float_record.set_double_field field_info e (Int32.of_int i) e0 ) 
      | _ -> assert false
    end


  | Pfloatfield (i, field_info) -> (** RUNTIME *)
    begin 
      match args with 
      | [e] ->
        Js_of_lam_float_record.get_double_feild field_info e
          (Int32.of_int i) 
      | _ -> assert false 
    end
  | Parrayrefu _kind ->  
    begin match args with
      | [e;e1] -> Js_of_lam_array.ref_array e e1 (* Todo: Constant Folding *)
      | _ -> assert false
    end
  | Parrayrefs _kind ->
    Lam_dispatch_primitive.translate "caml_array_get" args
  | Pmakearray kind -> 
    Js_of_lam_array.make_array Mutable kind args 
  | Parraysetu _kind -> 
    begin match args with (* wrong*)
      | [e;e0;e1] -> decorate_side_effect cxt @@ Js_of_lam_array.set_array  e e0 e1
      | _ -> assert false
    end

  | Parraysets _kind -> 
    Lam_dispatch_primitive.translate "caml_array_set" args
  | Pccall prim -> 
    Lam_dispatch_primitive.translate prim.prim_name  args
  (* Lam_compile_external_call.translate loc cxt prim args *)
  (* Test if the argument is a block or an immediate integer *)
  | Pjs_object_create labels
    -> 
    assert false 
  (*Lam_compile_external_obj.assemble_args_obj labels args *)
  | Pjs_call (_, arg_types, ffi) -> 
    Lam_compile_external_call.translate_ffi 
      loc ffi cxt arg_types args 
  (** FIXME, this can be removed later *)
  | Pisint -> 
    begin 
      match args with 
      | [e] ->  E.is_type_number e 

      | _ ->   assert false
    end
  | Pctconst ct -> 
    begin
      match ct with 
      | Big_endian -> 
        if Sys.big_endian then  E.caml_true
        else E.caml_false
      | Word_size -> 
        E.small_int  Sys.word_size
      | Ostype_unix -> 
        if Sys.unix then E.caml_true else E.caml_false
      | Ostype_win32 -> 
        if Sys.win32 then E.caml_true else E.caml_false
      | Ostype_cygwin -> 
        if Sys.cygwin then E.caml_true else E.caml_false
    end
  (* | Psetglobal _  ->  *)
  (*   assert false (\* already handled *\) *)
  (* assert false *)
  | Pduprecord ((Record_regular 
                | Record_float ),0)
  | Pduprecord ((Record_regular 
                | Record_float ),_) -> 
    begin match args with 
      | [e] -> Js_of_lam_record.copy e
      | _ -> assert false       
    end
  | Pbigarrayref (unsafe, dimension, kind, layout)
    -> 
    (* can be refined to 
       [caml_bigarray_float32_c_get_1]
       note that kind can be [generic]
       and layout can be [unknown],
       dimension is always available
    *)
    begin match dimension, kind, layout, unsafe with 
      | 1,  ( Pbigarray_float32 | Pbigarray_float64
            | Pbigarray_sint8 | Pbigarray_uint8
            | Pbigarray_sint16 | Pbigarray_uint16
            | Pbigarray_int32 | Pbigarray_int64
            | Pbigarray_caml_int | Pbigarray_native_int
            | Pbigarray_complex32 | Pbigarray_complex64), Pbigarray_c_layout, _
        -> 
        begin match args with
          | [x;indx] -> Js_of_lam_array.ref_array x indx
          | _ -> assert false
        end
      | _, _, _ ,_ -> 
        E.not_implemented ("caml_ba_get_" ^ string_of_int dimension )
        (* E.runtime_call Js_config.bigarray  *)
        (*   ("caml_ba_get_" ^ string_of_int dimension ) args  *)
    end
  | Pbigarrayset (unsafe, dimension, kind, layout)
    -> 
    begin match dimension, kind, layout, unsafe with 
      | 1,  ( Pbigarray_float32 | Pbigarray_float64
            | Pbigarray_sint8 | Pbigarray_uint8
            | Pbigarray_sint16 | Pbigarray_uint16
            | Pbigarray_int32 | Pbigarray_int64
            | Pbigarray_caml_int | Pbigarray_native_int
            | Pbigarray_complex32 | Pbigarray_complex64), Pbigarray_c_layout, _
        -> 
        begin match args with 
          | [x; index; value] -> 
            Js_of_lam_array.set_array x index value          
          | _ -> assert false
        end

      | _ , _, _,_ 
        -> 
        E.not_implemented
          ("caml_ba_set_" ^ string_of_int dimension )
          (* E.runtime_call Js_config.bigarray  *)
          (*   ("caml_ba_set_" ^ string_of_int dimension ) args  *)
    end

  | Pbigarraydim i
    -> 
    E.not_implemented ("caml_ba_dim_" ^ string_of_int i)
  (* E.runtime_call Js_config.bigarray *)
  (*   ("caml_ba_dim_" ^ string_of_int i) args        *)
  | Pbswap16 
    -> 
    E.runtime_call Js_runtime_modules.int32 "caml_bswap16" args
  | Pbbswap Lambda.Pnativeint
  | Pbbswap Lambda.Pint32
    -> 
    E.runtime_call Js_runtime_modules.int32 "caml_int32_bswap" args
  | Pbbswap Lambda.Pint64
    -> Js_long.swap args 
  | Pstring_load_16 unsafe
    -> E.runtime_call Js_runtime_modules.string "caml_string_get16" args
  | Pstring_load_32 unsafe
    -> E.runtime_call Js_runtime_modules.string "caml_string_get32" args
  | Pstring_load_64 unsafe
    -> Js_long.get64 args

  | Plazyforce
  (* | Plazyforce -> *)
  (*     let parm = Ident.create "prim" in *)
  (*     Lfunction(Curried, [parm], *)
  (*               Matching.inline_lazy_force (Lvar parm) Location.none) *)
  (* It is inlined, this should not appear here *)    
  | Pbittest 

  | Pstring_set_16 _
  | Pstring_set_32 _
  | Pstring_set_64 _
  | Pbigstring_load_16 _
  | Pbigstring_load_32 _
  | Pbigstring_load_64 _
  | Pbigstring_set_16 _
  | Pbigstring_set_32 _
  | Pbigstring_set_64 _
    -> 
    let comment = "Missing primitive" in       
    let s = Lam_util.string_of_primitive prim in
    let warn = Printf.sprintf  "%s: %s\n" comment s in
    Ext_log.warn __LOC__ "%s"  warn;
    (*we dont use [throw] here, since [throw] is an statement  *)        
    E.dump  Error [ E.str warn]



end
module Lam_eta_conversion : sig 
#1 "lam_eta_conversion.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


(** 
  [transform n loc status fn args]
  n is the number of missing arguments required for [fn].
  Return a function of airty [n]
*) 

val transform_under_supply : 
  int ->
  Location.t -> Lam.apply_status -> Lam.t -> Lam.t list -> Lam.t


val unsafe_adjust_to_arity :
  Location.t -> 
  to_:int -> 
  ?from:int -> 
  Lam.t -> 
  Lam.t 
end = struct
#1 "lam_eta_conversion.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


(*
  let f x y =  x + y 
  Invariant: there is no currying 
  here since f's arity is 2, no side effect 
  f 3 --> function(y) -> f 3 y 
*)

(** 
   [transform n loc status fn args]
   n is the number of missing arguments required for [fn].
   Return a function of airty [n]
*) 
let transform_under_supply n loc status fn args = 
  let extra_args = Ext_list.init n
      (fun _ ->   (Ident.create Literals.param)) in
  let extra_lambdas = Ext_list.map (fun x -> Lam.var x) extra_args in
  begin match List.fold_right (fun (lam : Lam.t) (acc, bind) ->
      match lam with
      | Lvar _
      | Lconst (Const_int _  
        | Const_char _ | Const_string _ 
        | Const_float _ | Const_int32 _ 
        | Const_int64 _ | Const_nativeint _ 
        | Const_pointer _ | Const_immstring _ ) 
      | Lprim {primitive = Pfield _;
               args =  [ Lglobal_module _ ]; _ }
      | Lfunction _ 
        ->
        (lam :: acc, bind)
      | _ ->
        let v = Ident.create Literals.partial_arg in
        (Lam.var v :: acc),  ((v, lam) :: bind)
    ) (fn::args) ([],[])   with 
  | fn :: args, [] -> 
    (* More than no side effect in the [args], 
       we try to avoid computation, so even if 
       [x + y] is side effect free, we need eval it only once 
    *)
    (* TODO: Note we could adjust [fn] if [fn] is already a function
       But it is dangerous to change the arity 
       of an existing function which may cause inconsistency
    *)
    Lam.function_ ~arity:n ~function_kind:Curried ~params:extra_args
      ~body:(Lam.apply fn (Ext_list.append args  extra_lambdas) 
               loc 
               status
            ) 
  | fn::args , bindings ->

    let rest : Lam.t = 
      Lam.function_ ~arity:n ~function_kind:Curried ~params:extra_args
        ~body:(Lam.apply fn (Ext_list.append args  extra_lambdas) 
                 loc 
                 status
              ) in
    List.fold_left (fun lam (id,x) ->
        Lam.let_ Strict id x lam
      ) rest bindings
  | _, _ -> assert false
  end



(* Invariant: mk0 : (unit -> 'a0) -> 'a0 t 
                TODO: this case should be optimized, 
                we need check where we handle [arity=0] 
                as a special case -- 
                if we do an optimization before compiling
                into lambda

   {[Fn.mk0]} is not intended for use by normal users

   so we assume [Fn.mk0] is only used in such cases
   {[
     Fn.mk0 (fun _ -> .. )
   ]}
   when it is passed as a function directly
*)
(*TODO: can be optimized ?
  {[\ x y -> (\u -> body x) x y]}
  {[\u x -> body x]}        
    rewrite rules 
  {[
    \x -> body 
          --
          \y (\x -> body ) y 
  ]}
  {[\ x y -> (\a b c -> g a b c) x y]}
  {[ \a b -> \c -> g a b c ]}
*)
(** if arity = 0 then 
            begin match fn with 
              | Lfunction {params =  [_]; body}
                ->
                compile_lambda cxt 
                  (Lam.function_ 
                     ~arity:0 
                     ~kind:Curried
                     ~params:[]
                     ~body)
              | _ -> 
                let wrapper, new_fn = 
                  match fn with 
                  | Lvar _ 
                  | Lprim {primitive = Pfield _ ; args = [Lglobal_module _]; _} -> 
                    None, fn 
                  | _ ->  
                    let partial_arg = Ext_ident.create Literals.partial_arg in 
                    Some partial_arg, Lam.var partial_arg
                in 
                let cont =   
                  (Lam.function_ ~arity:0 
                     ~kind:Curried ~params:[] 
                     ~body:(
                       Lam.apply new_fn
                         [Lam.unit]
                         Location.none App_na
                     )) in 
                begin match wrapper with 
                  | None ->      
                    compile_lambda cxt  cont
                  | Some partial_arg
                    -> 
                    compile_lambda cxt (Lam.let_ Strict partial_arg fn cont )  
                end
            end
          else 
            begin match fn with
              | Lam.Lfunction{arity = len; kind; params = args; body}
                ->
                if len = arity then
                  compile_lambda cxt fn 
                else if len > arity then 
                  let params, rest  = Ext_list.take arity args  in 
                  compile_lambda cxt 
                    (Lam.function_ 
                       ~arity
                       ~kind ~params
                       ~body:(Lam.function_ ~arity:(len - arity)
                                ~kind ~params:rest ~body)
                    )
                else (* len < arity *)
                  compile_lambda cxt 
                    (Lam_eta_conversion.transform_under_supply arity 
                       Location.none App_na
                       fn  [] )
              (* let extra_args = Ext_list.init (arity - len) (fun _ ->   (Ident.create Literals.param)) in *)
              (* let extra_lambdas = Ext_list.map (fun x -> Lambda.Lvar x) extra_args in *)
              (* Lambda.Lfunction (kind, Ext_list.append extra_args  args , body ) *)

                                | _ -> 
                                compile_lambda cxt 
                                (Lam_eta_conversion.transform_under_supply arity
                                Location.none App_na  fn  [] )
                                end *)


(** Unsafe function, we are changing arity here, it should be applied 
    cautiously, since 
    [let u = f] and we are chaning the arity of [f] it will affect 
    the collection of [u]
*)
let unsafe_adjust_to_arity loc ~to_:(to_:int) ?from
    (fn : Lam.t) = 
  begin match from, fn  with 
    | Some from, _ 
    | None, Lfunction{arity=from} ->
      if from = to_ then 
        fn 
      else if to_ = 0 then  
        match fn with 
        | Lfunction{params = [param]; body} -> 
          Lam.function_ ~arity:0 ~function_kind:Curried 
            ~params:[]
            ~body:(
              Lam.let_ Alias param Lam.unit body  
            ) (* could be only introduced by 
                 {[ Pjs_fn_make 0 ]} <- 
                 {[ fun [@bs] () -> .. ]}
              *)
        | _ -> 
          let wrapper, new_fn  = 
            match fn with 
            | Lvar _ 
            | Lprim{primitive = Pfield _ ; args = [Lglobal_module _]; _ }
              -> 
              None, fn 
            | _ -> 
              let partial_arg = Ext_ident.create Literals.partial_arg in 
              Some partial_arg, Lam.var partial_arg in 

          let cont = Lam.function_ 
              ~arity:0
              ~function_kind:Curried 
              ~params:[]
              ~body:(
                Lam.apply new_fn [Lam.unit ; Lam.unit ] loc App_na
              ) in 

          match wrapper with 
          | None -> cont 
          | Some partial_arg 
            -> Lam.let_ Strict partial_arg fn cont 

      else if to_ > from then 
        match fn with 
        | Lfunction{params;body; function_kind} -> 
          (* {[fun x -> f]} -> 
             {[ fun x y -> f y ]}
          *)
          let extra_args = Ext_list.init (to_ - from) (fun _ -> Ident.create Literals.param) in 
          Lam.function_
            ~arity:to_ 
            ~function_kind:Curried
            ~params:(Ext_list.append params  extra_args )
            ~body:(Lam.apply body (Ext_list.map Lam.var extra_args) loc App_na)
        | _ -> 
          let arity = to_ in 
          let extra_args = Ext_list.init to_  (fun _ -> Ident.create Literals.param ) in 
          let wrapper, new_fn = 
            match fn with 
            | Lvar _ 
            | Lprim {primitive = Pfield _ ; args = [ Lglobal_module _] ; _}  -> 
              None, fn
            | _ -> 
              let partial_arg = Ext_ident.create Literals.partial_arg in 
              Some partial_arg, Lam.var partial_arg
          in   
          let cont = 
            Lam.function_ 
              ~arity
              ~function_kind:Curried
              ~params:extra_args 
              ~body:(
                let first_args, rest_args = Ext_list.take from extra_args in 
                Lam.apply (Lam.apply new_fn (Ext_list.map Lam.var first_args) loc App_ml_full) (Ext_list.map Lam.var rest_args) loc App_na ) in 
          begin match wrapper with 
            | None -> cont 
            | Some partial_arg -> 
              Lam.let_ Strict partial_arg fn cont 
          end    
      else 
        (* add3  --adjust to arity 1 ->
           fun x -> (fun y z -> add3 x y z )

           [fun x y z -> f x y z ]
           [fun x -> [fun y z -> f x y z ]]
           This is okay if the function is not held by other..
        *)
        begin match fn with 

          | Lfunction 
              {params; body; function_kind } (* TODO check arity = List.length params in debug mode *)
            -> 
            let arity = to_ in 
            let extra_outer_args, extra_inner_args = Ext_list.take arity params in 
            Lam.function_ 
              ~arity 
              ~function_kind:Curried
              ~params:extra_outer_args 
              ~body:(
                Lam.function_ ~arity:(from - to_)
                  ~function_kind:Curried ~params:extra_inner_args ~body:body)
          | _
            -> 
            let extra_outer_args = 
              Ext_list.init to_
                (fun _ ->   Ident.create Literals.param) in
            let wrapper, new_fn = 
              match fn with 
              | Lvar _ 
              | Lprim {primitive = Pfield _ ; args = [ Lglobal_module _] ; _}  -> 
                None, fn
              | _ -> 
                let partial_arg = Ext_ident.create Literals.partial_arg in 
                Some partial_arg, Lam.var partial_arg
            in   
            let cont = 
              Lam.function_ ~arity:to_ ~function_kind:Curried ~params:extra_outer_args 
                ~body:(
                  let arity = from - to_ in 
                  let extra_inner_args =
                    Ext_list.init arity (fun _ -> Ident.create Literals.param ) in 
                  Lam.function_ ~arity ~function_kind:Curried ~params:extra_inner_args 
                    ~body:(Lam.apply new_fn 
                             (Ext_list.map_acc (Ext_list.map Lam.var extra_inner_args) Lam.var extra_outer_args )      
                             loc App_ml_full)
                )  in 
            begin match wrapper with 
              | None -> cont 
              | Some partial_arg -> Lam.let_ Strict partial_arg fn  cont    
            end
        end 
    | None, _ ->      
      (** In this case [fn] is not [Lfunction], otherwise we would get [arity] *)
      if to_ = 0 then 
        let wrapper, new_fn  = 
          match fn with 
          | Lvar _ 
          | Lprim{primitive = Pfield _ ; args = [Lglobal_module _]; _ }
            -> 
            None, fn 
          | _ -> 
            let partial_arg = Ext_ident.create Literals.partial_arg in 
            Some partial_arg, Lam.var partial_arg in 

        let cont = Lam.function_ 
            ~arity:0
            ~function_kind:Curried 
            ~params:[]
            ~body:(
              Lam.apply new_fn [Lam.unit] loc App_na
            ) in 

        match wrapper with 
        | None -> cont 
        | Some partial_arg 
          -> Lam.let_ Strict partial_arg fn cont 
      else   
        transform_under_supply to_ loc App_na fn []
  end 


(* | _ -> 
   let partial_arg = Ext_ident.create Literals.partial_arg in 
   Lam.let_ Strict partial_arg fn 
    (let arity = to_ in 
     let extra_args = Ext_list.init arity (fun _ -> Ident.create Literals.param) in 
     Lam.function_ ~arity ~kind:Curried ~params:extra_args 
       ~body:(Lam.apply fn (Ext_list.map Lam.var extra_args ) loc Lam.App_na )
    ) *)

end
module Lam_exit_code : sig 
#1 "lam_exit_code.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)







val has_exit_code : (int -> bool ) -> Lam.t -> bool 

end = struct
#1 "lam_exit_code.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






let rec has_exit_code exits  (lam : Lam.t)  : bool = 
  match lam with
  | Lvar _
  | Lconst _ 
  | Lfunction _ (* static exit can not across function boundary *)
    -> false
  | Lapply {fn = l; args; _ } 
    -> has_exit_code exits l || List.exists (fun x -> has_exit_code exits x ) args 

  | Llet (_kind,_id,v,body) 
    -> has_exit_code exits v || has_exit_code exits body
  | Lletrec (binding,body) ->
    List.exists (fun (_, l) -> has_exit_code exits l ) binding ||
    has_exit_code exits body    
  | Lam.Lglobal_module _ -> false
  | Lprim {args; _} 
    -> List.exists (fun x -> has_exit_code exits x) args
  | Lswitch (l,lam_switch) 
    -> has_exit_code exits l || has_exit_code_lam_switch exits lam_switch

  | Lstringswitch (l,ls,opt) -> 
    has_exit_code exits l ||
    List.exists (fun (_,l) -> has_exit_code exits l) ls ||
    (match opt with 
    | None -> false
    | Some x -> has_exit_code exits l )
  | Lstaticraise (v,ls) ->
      exits v ||    
    List.exists (has_exit_code exits) ls
  | Lstaticcatch (l,_,handler) 
    ->
    has_exit_code exits l || has_exit_code exits handler
  | Ltrywith (l,_, handler) 
    ->
    has_exit_code exits l || has_exit_code exits handler
  | Lifthenelse (a,b,c) 
    -> 
    has_exit_code exits a || has_exit_code exits b || has_exit_code exits c
  | Lsequence (a,b) 
    ->
    has_exit_code exits a || has_exit_code exits b
  | Lwhile (a,b) 
    ->
    has_exit_code exits a || has_exit_code exits b
  | Lfor (_,a,b,_dir,body) -> 
    has_exit_code exits a 
    || has_exit_code exits b
    || has_exit_code exits body
    
  | Lassign (_,a) 
    -> 
    has_exit_code exits a
  | Lsend (_,obj,l,ls,_loc) 
    -> 
    has_exit_code exits obj ||
    has_exit_code exits l ||
    List.exists (has_exit_code exits) ls
  | Lifused (_,b) 
    -> has_exit_code exits b

and has_exit_code_lam_switch exits (lam_switch : Lam.switch) = 
  match lam_switch with
   | { sw_numconsts = _; sw_consts; sw_numblocks = _ ; sw_blocks; sw_failaction } ->
     List.exists (fun (_,l) -> has_exit_code exits l) sw_consts ||
     List.exists (fun (_,l) -> has_exit_code exits l)  sw_blocks ||
     (match sw_failaction with 
     | None -> false 
     | Some x -> has_exit_code exits x)

end
module Lam_methname : sig 
#1 "lam_methname.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)



val translate : ?loc:Location.t -> string -> string

end = struct
#1 "lam_methname.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


(**
  {[
    _open -> open 
    _in -> in 
    _MAX_LENGTH -> MAX_LENGTH
    _Capital -> Capital 
    
    _open__ ->  _open
    open__ -> open 
    
    _'x -> 'x 

    _Capital__ -> _Capital 
    _MAX__ -> _MAX
    __ -> __ 
    __x -> __x 
    ___ -> _     
    ____ -> __
    _ -> _  (* error *)   
    

  ]}
  First we scan '__' from end to start, 
  If found, discard it.
  Otherwise, check if it is [_ + keyword] or followed by capital letter,
  If so, discard [_].

  Limitations: user can not have [_Capital__, _Capital__other] to 
  make it all compile to [Capital].
  Keyword is fine [open__, open__other].
  So we loose polymorphism over capital letter. 
  It is okay, otherwise, if [_Captial__] is interpreted as [Capital], then
  there is no way to express [_Capital]
*)

(* Copied from [ocaml/parsing/lexer.mll] *)
let key_words = String_hash_set.of_array [|
    "and";
    "as";
    "assert";
    "begin";
    "class";
    "constraint";
    "do";
    "done";
    "downto";
    "else";
    "end";
    "exception";
    "external";
    "false";
    "for";
    "fun";
    "function";
    "functor";
    "if";
    "in";
    "include";
    "inherit";
    "initializer";
    "lazy";
    "let";
    "match";
    "method";
    "module";
    "mutable";
    "new";
    "nonrec";
    "object";
    "of";
    "open";
    "or";
(*  "parser", PARSER; *)
    "private";
    "rec";
    "sig";
    "struct";
    "then";
    "to";
    "true";
    "try";
    "type";
    "val";
    "virtual";
    "when";
    "while";
    "with";

    "mod";
    "land";
    "lor";
    "lxor";
    "lsl";
    "lsr";
    "asr";
|]
let double_underscore = "__"

(*https://caml.inria.fr/pub/docs/manual-ocaml/lex.html
{[

  label-name	::=	 lowercase-ident 
]}
*)
let valid_start_char x =
  match x with 
  | '_' | 'a' .. 'z' -> true 
  | _ -> false 
let translate ?loc name = 
  assert (not @@ Ext_string.is_empty name);
  let i = Ext_string.rfind ~sub:double_underscore name in 
  if i < 0 then 
    let name_len = String.length name in 
    if name.[0] = '_' then  begin 
      let try_key_word = (String.sub name 1 (name_len - 1)) in 
      if name_len > 1 && 
        (not (valid_start_char try_key_word.[0])
        || String_hash_set.mem key_words try_key_word)  then 
        try_key_word
      else 
        name 
    end
    else name 
  else if i = 0 then name 
  else  String.sub name 0 i 


end
module Lam_compile : sig 
#1 "lam_compile.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Compile single lambda IR to JS IR  *)

val compile_let : 
  Lam.let_kind ->
  Lam_compile_defs.cxt -> 
  J.ident -> 
  Lam.t -> 
  Js_output.t

val compile_recursive_lets : Lam_compile_defs.cxt -> (Ident.t * Lam.t) list -> Js_output.t

val compile_lambda : Lam_compile_defs.cxt -> Lam.t -> Js_output.t

end = struct
#1 "lam_compile.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








open Js_output.Ops 

module E = Js_exp_make 

module S = Js_stmt_make  

let method_cache_id = ref 1 (*TODO: move to js runtime for re-entrant *)


(* assume outer is [Lstaticcatch] *)
let rec flat_catches acc (x : Lam.t)
  : (int * Lam.t * Ident.t  list ) list * Lam.t = 
  match x with 
  | Lstaticcatch(l, (code, bindings), handler) 
    when 
      acc = [] ||
      (not @@ Lam_exit_code.has_exit_code 
         (fun exit -> List.exists (fun (c,_,_) -> c = exit) acc) handler)
    -> (* #1698 should not crush exit code here without checking *)
    flat_catches ((code,handler,bindings)::acc) l
  | _ -> acc, x

let flatten_caches  x = flat_catches [] x 



(* TODO:
    for expression generation, 
    name, should_return  is not needed,
    only jmp_table and env needed
*)


type default_case = 
  | Default of Lam.t
  | Complete
  | NonComplete

(* let lam_of_pos ( (id : Ident.t), pos ) env = 
   Lam_compile_env.find_and_add_if_not_exist (id,pos) env
   ~not_found:(fun _ -> assert false)
   ~found:(fun x ->
    match x with 
    | {id = {name = "Sys"; }; name = "os_type"} -> 
      Lam.const (Const_string (Sys.os_type))
    | {closed_lambda = Some lam} when Lam_util.not_function lam 
      -> lam
    | { id ; name } ->   

   ) *)

(* f (E.str ~pure:false (Printf.sprintf "Err %s %d %d" id.name id.flags pos)) *)
(* E.index m (pos + 1) *) (** shift by one *)
(** This can not happen since this id should be already consulted by type checker *)
(** We drop the ability of cross-compiling
        the compiler has to be the same running 
*)      
(* since it's only for alias, there is no arguments, 
   we should not inline function definition here, even though
   it is very small             
   TODO: add comment here, we should try to add comment for 
   cross module inlining             

   if we do too agressive inlining here: 

   if we inline {!List.length} which will call {!A_list.length}, 
   then we if we try inline {!A_list.length}, this means if {!A_list} 
   is rebuilt, this module should also be rebuilt,

   But if the build system is content-based, suppose {!A_list} 
   is changed, cmj files in {!List} is unchnaged, however, 
   {!List.length} call {!A_list.length} which is changed, since
   [ocamldep] only detect that we depend on {!List}, it will not 
   get re-built, then we are screwed.                   

   This is okay for stamp based build system.

   Another solution is that we add dependencies in the compiler

   -: we should not do functor application inlining in a 
      non-toplevel, it will explode code very quickly              
*)    
let rec  
  compile_external_field 
    (cxt : Lam_compile_defs.cxt) 
    lam 
    (id : Ident.t)
    (pos : int)
    env : Js_output.t = 
  let f =   Js_output.handle_name_tail cxt.st cxt.should_return lam in    
  Lam_compile_env.find_and_add_if_not_exist (id,pos) env 
    ~not_found:(fun id -> 
        assert false
      )
    ~found:(fun {id; name; closed_lambda } ->
        match id, name, closed_lambda with 
        | {name = "Sys"; _}, "os_type" , _

          ->  f (E.str Sys.os_type) 
        | _, _, Some lam 
          when Lam_util.not_function lam

          ->  
          compile_lambda cxt lam
        | _ -> 
          f (E.ml_var_dot id name)
      ) 
(* TODO: how nested module call would behave,
   In the future, we should keep in track  of if 
   it is fully applied from [Lapply]
   Seems that the module dependency is tricky..
   should we depend on [Pervasives] or not?

   we can not do this correctly for the return value, 
   however we can inline the definition in Pervasives
   TODO:
   [Pervasives.print_endline]
   [Pervasives.prerr_endline]
   @param id external module id 
   @param number the index of the external function 
   @param env typing environment
   @param args arguments 
*)
(** This can not happen since this id should be already consulted by type checker 
          Worst case 
    {[
      E.index m pos 
    ]}
*)
(* when module is passed as an argument - unpack to an array
    for the function, generative module or functor can be a function,
    however it can not be global -- global can only module
*)

and compile_external_field_apply 
    (cxt : Lam_compile_defs.cxt) 
    lam 
    args_lambda
    (id : Ident.t)
    (pos : int) env : Js_output.t = 
  Lam_compile_env.find_and_add_if_not_exist 
    (id,pos) env ~not_found:(fun _ -> assert false)
    ~found:(fun {id; name;arity; closed_lambda ; _} -> 
        let args_code, args = 
          List.fold_right 
            (fun (x : Lam.t) (args_code, args)  ->
               match compile_lambda {cxt with st = NeedValue; should_return = ReturnFalse} x with
               | {block = a; value = Some b} -> 
                 (Ext_list.append a args_code), (b :: args )
               | _ -> assert false
            ) args_lambda ([], []) in

        match closed_lambda with 
        | Some (Lfunction{ params; body; _}) 
          when Ext_list.same_length params args_lambda -> 
          (* TODO: serialize it when exporting to save compile time *)
          let (_, param_map)  = 
            Lam_closure.is_closed_with_map Ident_set.empty params body in
          compile_lambda cxt 
            (Lam_beta_reduce.propogate_beta_reduce_with_map cxt.meta param_map
               params body args_lambda)
        | _ ->  
          Js_output.handle_block_return cxt.st cxt.should_return lam args_code @@ 
          (match id, name,  args with 
           | {name = "Pervasives"; _}, "print_endline", ([ _ ] as args) ->  
             E.seq (E.dump Log args) E.unit
           | {name = "Pervasives"; _}, "prerr_endline", ([ _ ] as args) ->  
             E.seq (E.dump Error args) E.unit
           | _ -> 
             let rec aux (acc : J.expression)
                 (arity : Lam_arity.t) args (len : int)  =
               match arity, len with
               | _, 0 -> 
                 acc (** All arguments consumed so far *)
               | Determin (a, (x,_) :: rest, b), len   ->
                 let x = 
                   if x = 0 
                   then 1 
                   else x in (* Relax when x = 0 *)
                 if  len >= x 
                 then
                   let first_part, continue =  Ext_list.take x args in
                   aux
                     (E.call ~info:{arity=Full; call_info = Call_ml} acc first_part)
                     (Determin (a, rest, b))
                     continue (len - x)
                 else (* GPR #1423 *)
                 if List.for_all Js_analyzer.is_simple_no_side_effect_expression args then 
                   let params = Ext_list.init (x - len)
                       (fun _ -> Ext_ident.create "param") in
                   E.ocaml_fun params 
                     [S.return (E.call ~info:{arity=Full; call_info=Call_ml}
                       acc (Ext_list.append args @@ Ext_list.map E.var params))]
                 else E.call ~info:Js_call_info.dummy acc args
               (* alpha conversion now? --
                  Since we did an alpha conversion before so it is not here
               *)
               | Determin (a, [], b ), _ ->
                 (* can not happen, unless it's an exception ? *)
                 E.call ~info:Js_call_info.dummy acc args
               | NA, _ ->
                 E.call ~info:Js_call_info.dummy acc args
             in
             aux (E.ml_var_dot id name) 
               (match arity with Single x -> x | Submodule _ -> NA)
               args (List.length args ))
      )

and  compile_let let_kind (cxt : Lam_compile_defs.cxt) id (arg : Lam.t) : Js_output.t =
  compile_lambda {cxt with st = Declare (let_kind, id); should_return = ReturnFalse } arg 
(** 
    The second return values are values which need to be wrapped using 
   [caml_update_dummy] 

   Invariant:  jmp_table can not across function boundary,
       here we share env 

*)
and compile_recursive_let ~all_bindings
    (cxt : Lam_compile_defs.cxt)
    (id : Ident.t)
    (arg : Lam.t)   : Js_output.t * Ident.t list = 
  match arg with 
  |  Lfunction { function_kind; params; body; _}  -> 

    let continue_label = Lam_util.generate_label ~name:id.name () in
    (* TODO: Think about recursive value 
       {[
         let rec v = ref (fun _ ... 
                         )
       ]}
        [Alias] may not be exact 
    *)
    Js_output.handle_name_tail (Declare (Alias, id)) ReturnFalse arg
      (
        let ret : Lam_compile_defs.return_label = 
          {id; 
           label = continue_label; 
           params;
           immutable_mask = Array.make (List.length params) true;
           new_params = Ident_map.empty;
           triggered = false} in
        let output = 
          compile_lambda
            { cxt with 
              st = EffectCall;  
              should_return = ReturnTrue (Some ret );
              jmp_table = Lam_compile_defs.empty_handler_map}  body in
        if ret.triggered then 
          let body_block = Js_output.to_block output in
          E.ocaml_fun
            (* TODO:  save computation of length several times 
               Here we always create [ocaml_fun], 
               it will be renamed into [method] 
               when it is detected by a primitive
            *)
            ~immutable_mask:ret.immutable_mask
            (Ext_list.map (fun x -> 
                 Ident_map.find_default x ret.new_params x )
                params)
            [
              S.while_ (* ~label:continue_label *)
                E.caml_true   
                (
                  Ident_map.fold
                    (fun old new_param  acc ->
                       S.define ~kind:Alias old (E.var new_param) :: acc) 
                    ret.new_params body_block
                )
            ]

        else            (* TODO:  save computation of length several times *)
          E.ocaml_fun params (Js_output.to_block output )
      ), [] 
  | Lprim {primitive = Pmakeblock (0, _, _) ; args =  ls}
    when List.for_all (fun (x : Lam.t) -> 
        match x with 
        | Lvar pid -> 
          Ident.same pid id  || 
          (not @@ List.exists (fun (other,_) -> Ident.same other pid ) all_bindings)
        | _ -> false) ls 
    ->
    (* capture cases like for {!Queue}
       {[let rec cell = { content = x; next = cell} ]}
       #1716: be careful not to optimize such cases:
       {[ let rec a = { b} and b = { a} ]} they are indeed captured 
       and need to be declared first 
    *)
    Js_output.of_block (
      S.define ~kind:Variable id (E.arr Mutable []) :: 
      (List.mapi (fun i (x : Lam.t) -> 
           match x with  
           | Lvar lid
             -> S.exp 
                  (Js_arr.set_array (E.var id) (E.int (Int32.of_int i)) (E.var lid))
           | _ -> assert false
         ) ls)
    ), []

  | Lprim{primitive = Pmakeblock _ ; _}   ->
    (* FIXME: also should fill tag *)
    (* Lconst should not appear here if we do [scc]
       optimization, since it's faked recursive value,
       however it would affect scope issues, we have to declare it first 
    *)
    (* Ext_log.err "@[recursive value %s/%d@]@." id.name id.stamp; *)
    begin
      match compile_lambda {cxt with st = NeedValue; should_return = ReturnFalse } arg with
      | { block = b; value = Some v} -> 
        (* TODO: check recursive value .. 
            could be improved for simple cases
        *)
        Js_output.of_block  
          (Ext_list.append
            b   
            [S.exp
               (E.runtime_call Js_runtime_modules.obj_runtime "caml_update_dummy" 
                  [ E.var id;  v])]),
        [id]
      (* S.define ~kind:Variable id (E.arr Mutable [])::  *)
      | _ -> assert false 
    end
  | Lvar _   ->
    compile_lambda {cxt with st = Declare (Alias ,id); should_return = ReturnFalse } arg, []
  | _ -> 
    (* pathological case:
        fail to capture taill call?
       {[ let rec a = 
            if  g > 30 then .. fun () -> a ()
       ]}

        Neither  below is not allowed in ocaml:
       {[
         let rec v = 
           if sum 0 10 > 20 then 
             1::v 
           else 2:: v
       ]}
       {[
         let rec v = 
           if sum 0 10 > 20 then 
             fun _ -> print_endline "hi"; v ()
           else 
             fun _-> print_endline "hey"; v ()
       ]}
    *)
    compile_lambda {cxt with st = Declare (Alias ,id); should_return = ReturnFalse } arg, []

and compile_recursive_lets_aux cxt id_args : Js_output.t = 
  (* #1716 *)
  let output_code, ids  = List.fold_right
      (fun (ident,arg) (acc, ids) -> 
         let code, declare_ids  = compile_recursive_let ~all_bindings:id_args cxt ident arg in
         (code ++ acc, Ext_list.append declare_ids  ids )
      )  id_args (Js_output.dummy, [])
  in
  match ids with 
  | [] -> output_code
  | _ ->  
    (Js_output.of_block  @@
     Ext_list.map (fun id -> S.define ~kind:Variable id (E.dummy_obj ())) ids ) 
    ++  output_code
and compile_recursive_lets cxt id_args : Js_output.t  = 

  match id_args with 
  | [ ] -> Js_output.dummy
  | _ -> 
    let id_args_group = Lam.scc_bindings id_args in 
    begin match id_args_group with 
      | [ ] -> assert false 
      | first::rest  ->
        let acc = compile_recursive_lets_aux cxt first in 
        List.fold_left (fun acc x -> acc ++ compile_recursive_lets_aux cxt x ) acc rest 
    end  
and compile_general_cases : 
  'a . 
  ('a -> J.expression) ->
  (J.expression -> J.expression -> J.expression) -> 
  Lam_compile_defs.cxt -> 
  (?default:J.block ->
   ?declaration:Lam.let_kind * Ident.t  -> 
   _ -> 'a J.case_clause list ->  J.statement) -> 
  _ -> 
  ('a * Lam.t) list -> default_case -> J.block 
  = fun f eq cxt switch v table default -> 
    let wrap (cxt : Lam_compile_defs.cxt) k =
      let cxt, define =
        match cxt.st with 
        | Declare (kind, did)
          -> 
          {cxt with st = Assign did}, Some (kind,did)
        | _ -> cxt, None
      in
      k cxt  define 
    in
    match table, default with 
    | [], Default lam ->  
      Js_output.to_block  (compile_lambda cxt lam)
    | [], (Complete | NonComplete) ->  []
    | [(id,lam)],Complete -> 
      (* To take advantage of such optimizations, 
          when we generate code using switch, 
          we should always have a default,
          otherwise the compiler engine would think that 
          it's also complete
      *)
      Js_output.to_block @@ compile_lambda cxt lam 
    | [(id,lam)], NonComplete 
      ->
      wrap cxt @@ fun cxt define  ->
      [S.if_ ?declaration:define (eq v (f id) )
         (Js_output.to_block @@ compile_lambda cxt lam )]

    | ([(id,lam)], Default x) | ([(id,lam); (_,x)], Complete)
      ->
      wrap cxt  @@ fun cxt define -> 
      let else_block = Js_output.to_block (compile_lambda cxt x) in
      let then_block = Js_output.to_block (compile_lambda cxt lam)  in
      [ S.if_ ?declaration:define (eq v (f id) )
          then_block
          ~else_:else_block
      ]
    | _ , _ -> 
      (* TODO: this is not relevant to switch case
          however, in a subset of switch-case if we can analysis 
          its branch are the same, we can propogate which 
          might encourage better inlining strategey
          ---
          TODO: grouping can be delayed untile JS IR
      *)
      (*TOOD: disabled temporarily since it's not perfect yet *)
      wrap cxt @@ fun cxt declaration  ->
      let default =
        match default with
        | Complete -> None
        | NonComplete -> None
        | Default lam -> Some (Js_output.to_block  (compile_lambda cxt lam))
      in
      let body = 
        table 
        |> Ext_list.stable_group (fun (_,lam) (_,lam1) -> Lam_analysis.eq_lambda lam lam1)
        |> Ext_list.flat_map 
          (fun group -> 
             group 
             |> Ext_list.map_last 
               (fun last (x,lam) -> 
                  if last 
                  then {J.case =  x; body = Js_output.to_break_block (compile_lambda cxt lam) }
                  else { case = x; body = [],false }))
          (* TODO: we should also group default *)
          (* The last clause does not need [break]
              common break through, *)

      in
      [switch ?default ?declaration v body] 

and compile_cases cxt = compile_general_cases (fun x -> E.small_int  x) E.int_equal cxt 
    (fun  ?default ?declaration e clauses    -> S.int_switch ?default  ?declaration e clauses)

and compile_string_cases cxt = compile_general_cases E.str E.string_equal cxt 
    (fun  ?default ?declaration e clauses    -> S.string_switch ?default  ?declaration e clauses)
(* TODO: optional arguments are not good 
    for high order currying *)
and
  compile_lambda
    ({st ; should_return; jmp_table; meta = {env ; _} } as cxt : Lam_compile_defs.cxt)
    (lam : Lam.t)  : Js_output.t  =
  begin
    match lam with 
    | Lfunction{ function_kind; params; body} ->
      Js_output.handle_name_tail st should_return lam 
        (E.ocaml_fun
           params
           (* Invariant:  jmp_table can not across function boundary,
              here we share env
           *)
           (Js_output.to_block 
              ( compile_lambda
                  { cxt with st = EffectCall;  
                             should_return = ReturnTrue None; (* Refine*)
                             jmp_table = Lam_compile_defs.empty_handler_map}  body)))


    | Lapply{
        fn = Lapply{ fn = an; args =  args'; status = App_na ; };
        args;  
        status = App_na; loc }
      ->    
      (* After inlining we can generate such code, 
         see {!Ari_regress_test}         
      *)      
      compile_lambda  cxt  
        (Lam.apply an (Ext_list.append args'  args)  loc  App_na )
    (* External function calll *)
    | Lapply{ fn = 
                Lprim{primitive = Pfield (n,_); 
                      args = [  Lglobal_module id];_};
              args = args_lambda;
              status = App_na | App_ml_full} ->
      (* Note we skip [App_js_full] since [get_exp_with_args] dont carry 
         this information, we should fix [get_exp_with_args]
      *)
      compile_external_field_apply cxt lam  args_lambda id n  env


    | Lapply{ fn; args = args_lambda;   status} -> 
      (* TODO: --- 
         1. check arity, can be simplified for pure expression
         2. no need create names
      *)
      begin 
        let [@warning "-8" (* non-exhaustive pattern*)] (args_code, fn_code:: args) = 
          List.fold_right (fun (x : Lam.t) (args_code, fn_code )-> 
              match compile_lambda 
                      {cxt with st = NeedValue ; should_return =  ReturnFalse} x with
              | {block = a; value =  Some b} -> Ext_list.append a  args_code , b:: fn_code 
              | _ -> assert false
            ) (fn::args_lambda) ([],[]) in


        begin
          match fn, should_return with
          | (Lvar id',
             ReturnTrue (Some ({id;label; params; _} as ret))) when Ident.same id id' ->


            (* Ext_log.err "@[ %s : %a tailcall @]@."  cxt.meta.filename Ident.print id; *)
            ret.triggered <- true;
            (* Here we mark [finished] true, since the continuation 
                does not make sense any more (due to that we have [continue])
                TODO: [finished] is not a meaningful name, we should use [truncate] 
                to mean the following statement should be truncated
            *)
            (* 
                actually, there is no easy way to determin 
                if the argument depends on an expresion, since 
                it can be a function, then it may depend on anything
                http://caml.inria.fr/pub/ml-archives/caml-list/2005/02/5727b4ecaaef6a7a350c9d98f5f68432.en.html
                http://caml.inria.fr/pub/ml-archives/caml-list/2005/02/fe9bc4e23e6dc8c932c8ab34240ff195.en.html

            *)
            (* TODO: use [fold]*)            
            let block =  args_code @
                         (
                           let (_,assigned_params,new_params) = 
                             List.fold_left2 (fun (i,assigns,new_params) param (arg : J.expression) ->
                                 match arg with
                                 | {expression_desc = Var (Id x); _} when Ident.same x param ->
                                   (i + 1, assigns, new_params)
                                 | _ ->
                                   let new_param, m  = 
                                     match Ident_map.find_opt  param ret.new_params with 
                                     | None -> 
                                       ret.immutable_mask.(i)<- false;
                                       let v = Ext_ident.create ("_"^param.Ident.name) in
                                       v, (Ident_map.add param v new_params) 
                                     | Some v -> v, new_params  in
                                   (i+1, (new_param, arg) :: assigns, m)
                               ) (0, [], Ident_map.empty) params args  in 
                           let () = ret.new_params <- Ident_map.disjoint_merge new_params ret.new_params in
                           assigned_params |> Ext_list.map (fun (param, arg) -> S.assign param arg))
                         @
                         [S.continue ()(* label *)]
                         (* Note true and continue needed to be handled together*)
            in
            begin
              (* Ext_log.dwarn __LOC__ "size : %d" (List.length block); *)
              Js_output.of_block  ~finished:True block 
            end
          | _ -> 

            Js_output.handle_block_return st should_return lam args_code 
              (E.call ~info:(match fn, status with 
                   | _,  App_ml_full -> 
                     {arity = Full ; call_info = Call_ml}
                   | _,  App_js_full -> 
                     {arity = Full ; call_info = Call_na}
                   | _,   App_na -> 
                     {arity = NA; call_info = Call_ml }
                 ) fn_code args) 
        end;
      end


    | Llet (let_kind,id,arg, body) ->
      (* Order matters..  see comment below in [Lletrec] *)
      let args_code =
        compile_let  let_kind cxt id arg  in 
      args_code ++
      compile_lambda  cxt  body

    | Lletrec (id_args, body) -> 
      (* There is a bug in our current design, 
         it requires compile args first (register that some objects are jsidentifiers)
         and compile body wiht such effect.
         So here we should compile [id_args] first, then [body] later.
         Note it has some side effect over cache number as well, mostly the value of
         [Caml_primitive["caml_get_public_method"](x,hash_tab, number)]

         To fix this, 
         1. scan the lambda layer first, register js identifier before proceeding
         2. delay the method call into javascript ast
      *)
      let v =  compile_recursive_lets cxt  id_args in v ++ compile_lambda cxt  body

    | Lvar id -> Js_output.handle_name_tail st  should_return lam (E.var id )
    | Lconst c -> 
      Js_output.handle_name_tail st should_return lam (Lam_compile_const.translate c)

    | Lprim {primitive = Pfield (n,_); 
             args = [ Lglobal_module id ]; _} 
      -> (* should be before Lglobal_global *)
      compile_external_field cxt lam  id n env

    | Lprim {primitive = Praise ; args =  [ e ]; _} -> 
      begin
        match compile_lambda {
            cxt with should_return = ReturnFalse; st = NeedValue} e with 
        | {block = b; value =  Some v} -> 

          Js_output.make (Ext_list.append b  [S.throw v])
            ~value:E.undefined ~finished:True
        (* FIXME -- breaks invariant when NeedValue, reason is that js [throw] is statement 
           while ocaml it's an expression, we should remove such things in lambda optimizations
        *)
        | {value =  None; _} -> assert false 
      end
    | Lprim{primitive = Psequand ; args =  [l;r] ; _}
      ->
      begin match cxt with 
        | {should_return = ReturnTrue _ } 
          (* Invariant: if [should_return], then [st] will not be [NeedValue] *)
          ->
          compile_lambda cxt (Lam.sequand  l r )
        | _ -> 
          let l_block,l_expr = 
            match compile_lambda {cxt with st = NeedValue; should_return = ReturnFalse} l with 
            | {block = a; value = Some b} -> a, b
            | _ -> assert false 
          in
          let r_block, r_expr = 
            match compile_lambda {cxt with st = NeedValue; should_return = ReturnFalse} r with
            | {block = a; value = Some b} -> a, b
            | _ -> assert false 
          in
          let args_code =  Ext_list.append l_block  r_block  in
          let exp =  E.and_ l_expr r_expr  in
          Js_output.handle_block_return st should_return lam args_code exp           
      end

    | Lprim {primitive = Psequor; args =  [l;r]}
      ->
      begin match cxt with
        | {should_return = ReturnTrue _ }
          (* Invariant: if [should_return], then [st] will not be [NeedValue] *)
          ->
          compile_lambda cxt @@ Lam.sequor l r
        | _ ->
          let l_block,l_expr =
            match compile_lambda {cxt with st = NeedValue; should_return = ReturnFalse} l with
            | {block = a; value = Some b} -> a, b
            | _ -> assert false
          in
          let r_block, r_expr =
            match compile_lambda {cxt with st = NeedValue; should_return = ReturnFalse} r with
            | {block = a; value = Some b} -> a, b
            | _ -> assert false
          in
          let args_code =  Ext_list.append l_block r_block  in
          let exp =  E.or_ l_expr r_expr  in
          Js_output.handle_block_return st should_return lam args_code exp
      end
    | Lprim {primitive = Pdebugger ; _}
      -> 
      (* [%bs.debugger] guarantees that the expression does not matter 
         TODO: make it even safer      *)
      Js_output.handle_block_return st should_return lam [S.debugger] E.unit



    (* TODO: 
       check the arity of fn before wrapping it 
       we need mark something that such eta-conversion can not be simplified in some cases 
    *)

    | Lprim {primitive = Pjs_unsafe_downgrade (name,loc); 
             args = [obj]}
      when not (Ext_string.ends_with name Literals.setter_suffix) 
      -> 
      (**
         either a getter {[ x #. height ]} or {[ x ## method_call ]}
      *)
      let property =  Lam_methname.translate ~loc name  in
      begin 
        match compile_lambda {cxt with st = NeedValue; should_return = ReturnFalse} obj
        with 
        | {block; value = Some b } -> 
          let blocks, ret  = 
            if block = [] then [],  E.dot b property
            else 
              (match Js_ast_util.named_expression b  with 
               | None -> block,  E.dot b property
               | Some (x, b) ->  
                 (Ext_list.append block  [x]),  E.dot (E.var b) property
              )
          in 
          Js_output.handle_block_return st should_return lam 
            blocks ret 
        | _ -> assert false 
      end
    | Lprim {primitive = Pjs_fn_run arity;  args = args_lambda}
      ->
      (* 1. prevent eta-conversion
         by using [App_js_full]
         2. invariant: `external` declaration will guarantee
         the function application is saturated
         3. we need a location for Pccall in the call site
      *)

      begin match args_lambda with  
        | [Lprim{
            primitive = 
              Pjs_unsafe_downgrade(method_name,loc);
            args = [obj]} as fn;
           arg]
          -> 
          begin 
            let obj_block = 
              compile_lambda {cxt with st = NeedValue; should_return = ReturnFalse} obj
            in 
            let value_block = 
              compile_lambda {cxt with st = NeedValue; should_return = ReturnFalse} arg
            in 
            let cont block0 block1 obj_code = 
              Js_output.handle_block_return st should_return lam 
                (
                  match obj_code with
                  | None -> Ext_list.append block0  block1
                  | Some obj_code -> Ext_list.append block0 @@ obj_code :: block1
                )
            in 
            match obj_block, value_block with 
            | {block = block0; value = Some obj }, 
              {block = block1; value = Some value}
              ->
              if  Ext_string.ends_with method_name Literals.setter_suffix then 
                let property =
                  Lam_methname.translate ~loc @@ 
                  String.sub method_name 0 
                    (String.length method_name - Literals.setter_suffix_len) in 
                match Js_ast_util.named_expression  obj with
                | None ->
                  cont block0 block1 None (E.assign (E.dot obj property) value)
                | Some (obj_code, obj)
                  ->
                  cont block0 block1 (Some obj_code)
                    (E.assign (E.dot (E.var obj) property) value)
              else 
                compile_lambda cxt
                  (Lam.apply fn [arg]  
                     Location.none (* TODO *) App_js_full)
            | _ -> 
              assert false 
          end

        | fn :: rest -> 
          compile_lambda cxt 
            (Lam.apply fn rest 
               Location.none (*TODO*)
               App_js_full)
        | _ -> assert false 
      end
    | Lprim {primitive = Pjs_fn_runmethod arity ; args }
      -> 
      begin match args with 
        | (Lprim{primitive = Pjs_unsafe_downgrade (name,loc);
                 args = [ _ ]} as fn) 
          :: _obj
          :: rest -> 
          (* assert (Ident.same id2 id) ;  *)
          (* we ignore the computation of [_obj], 
             since our ast writer 
             {[ obj#.f (x,y)
             ]}
             -->
             {[ runmethod2 f obj#.f x y]}           
          *)
          compile_lambda cxt (Lam.apply fn rest loc App_js_full)
        | _ -> assert false               
      end
    | Lprim {primitive = Pjs_fn_method arity;  args = args_lambda} -> 
      begin match args_lambda with 
        | [Lfunction{arity = len; function_kind; params; body} ] 
          when len = arity -> 
          Js_output.handle_block_return 
            st
            should_return             
            lam 
            []
            (E.method_
               params
               (* Invariant:  jmp_table can not across function boundary,
                  here we share env
               *)
               (Js_output.to_block 
                  ( compile_lambda
                      { cxt with st = EffectCall;  
                                 should_return = ReturnTrue None; 
                                 jmp_table = Lam_compile_defs.empty_handler_map} 
                      body)))
        | _ -> assert false 
      end


    | Lprim {primitive = Pjs_fn_make arity;  args = [fn]; loc } -> 
      compile_lambda cxt (Lam_eta_conversion.unsafe_adjust_to_arity loc ~to_:arity ?from:None fn)

    | Lprim {primitive = Pjs_fn_make arity;  
             args = [] | _::_::_ } -> 
      assert false 
    | Lglobal_module i -> 
      (* introduced by 
         1. {[ include Array --> let include  = Array  ]}
         2. inline functor application
      *)
      let exp = Lam_compile_global.expand_global_module i env  in 
      Js_output.handle_block_return st should_return lam [] exp 
    | Lprim{ primitive = Pjs_object_create labels ; args ; loc}
      ->   
      let args_block, args_expr =
        Ext_list.split_map (fun (x : Lam.t) ->
            match compile_lambda {cxt with st = NeedValue; should_return = ReturnFalse} x 
            with 
            | {block = a; value = Some b} -> a,b
            | _ -> assert false ) args
      in
      let args_code  = List.concat args_block in
      let block, exp  =  
        Lam_compile_external_obj.assemble_args_obj labels args_expr
      in
      Js_output.handle_block_return st should_return lam 
      (Ext_list.append args_code block) exp  

    | Lprim{primitive = prim; args =  args_lambda; loc} -> 
      let args_block, args_expr =
        Ext_list.split_map (fun (x : Lam.t) ->
            match compile_lambda {cxt with st = NeedValue; should_return = ReturnFalse} x 
            with 
            | {block = a; value = Some b} -> a,b
            | _ -> assert false ) args_lambda 

      in
      let args_code  : J.block = List.concat args_block in
      let exp  =  (* TODO: all can be done in [compile_primitive] *)
        Lam_compile_primitive.translate loc cxt  prim args_expr in
      Js_output.handle_block_return st should_return lam args_code exp  


    | Lsequence (l1,l2) ->
      let output_l1 = 
        compile_lambda {cxt with st = EffectCall; should_return =  ReturnFalse} l1 in
      let output_l2 = 
        compile_lambda cxt l2  in
      output_l1 ++ output_l2


    | Lifthenelse(p,t_br,f_br) ->

      (*
         This should be optimized in lambda layer 
         (let (match/1038 = (apply g/1027 x/1028))
         (catch
         (stringswitch match/1038
         case "aabb": 0
         case "bbc": 1
         default: (exit 1))
         with (1) 2))
      *)

      begin 
        match compile_lambda {cxt with st = NeedValue ; should_return = ReturnFalse } p with 
        | {block = b; value =  Some e} ->
          begin match st with 
            | NeedValue  -> 
              begin match
                  compile_lambda cxt  t_br, 
                  compile_lambda cxt  f_br with 
              | {block = []; value =  Some out1}, 
                {block = []; value =  Some out2} -> (* speical optimization *)
                Js_output.make b ~value:(E.econd e out1 out2)
              | _, _ -> 
                (* we can not reuse -- here we need they have the same name, 
                       TODO: could be optimized by inspecting assigment statement *)
                let id = Ext_ident.create_tmp () in
                (match
                   compile_lambda  {cxt with st = Assign id} t_br,
                   compile_lambda {cxt with st = Assign id} f_br
                 with
                 | out1 , out2 -> 
                   Js_output.make 
                     (Ext_list.append 
                      (S.declare_variable ~kind:Variable id :: b)  [
                         S.if_ e 
                           (Js_output.to_block out1) 
                           ~else_:(Js_output.to_block out2 )
                       ])
                     ~value:(E.var id)
                )
              end
            | Declare (kind,id) ->
              begin match
                  compile_lambda {cxt with st = NeedValue}  t_br, 
                  compile_lambda {cxt with st = NeedValue}  f_br with 
              | {block = []; value =  Some out1},
                {block = []; value =  Some out2} ->  
                (* Invariant: should_return is false*)
                Js_output.make @@ 
                Ext_list.append b  [
                    S.define ~kind id (E.econd e out1 out2) ]
              | _, _ -> 
                Js_output.make 
                  ( Ext_list.append b [
                        S.if_ ~declaration:(kind,id) e 
                          (Js_output.to_block @@ 
                           compile_lambda {cxt with st = Assign id}  t_br)
                          ~else_:(Js_output.to_block @@  
                                  (compile_lambda {cxt with st = Assign id} f_br))
                      ])
              end
            | Assign id -> 
              (* 
#if BS_DEBUG then 
            let () = Ext_log.dwarn __LOC__ "\n@[[TIME:]Lifthenelse: %f@]@."  (Sys.time () *. 1000.) in      
#end 
*)              
              (* match
                                compile_lambda {cxt with st = NeedValue}  t_br, 
                                compile_lambda {cxt with st = NeedValue}  f_br with 
                            | {block = []; value =  Some out1}, 
                              {block = []; value =  Some out2} ->  
                              (* Invariant:  should_return is false *)
                              Js_output.make [S.assign id (E.econd e out1 out2)]
                            | _, _ -> *)
              let then_output = 
                Js_output.to_block @@ 
                (compile_lambda cxt  t_br) in
              let else_output = 
                Js_output.to_block @@ 
                (compile_lambda cxt f_br) in
              Js_output.make (Ext_list.append b  [
                  S.if_ e 
                    then_output
                    ~else_:else_output
                ])
            | EffectCall ->
              begin match should_return,
                          compile_lambda {cxt with st = NeedValue}  t_br, 
                          compile_lambda {cxt with st = NeedValue}  f_br with  

              (* see PR#83 *)
              |  ReturnFalse , {block = []; value =  Some out1}, 
                 {block = []; value =  Some out2} ->
                begin
                  match Js_exp_make.extract_non_pure out1 ,
                        Js_exp_make.extract_non_pure out2 with
                  | None, None -> Js_output.make (Ext_list.append b  [ S.exp e]) 
                  (* FIX #1762 *)
                  | Some out1, Some out2 -> 
                    Js_output.make b  ~value:(E.econd e  out1 out2)
                  | Some out1, None -> 
                    Js_output.make (Ext_list.append b  [S.if_ e  [S.exp out1]])
                  | None, Some out2 -> 
                    Js_output.make @@
                    (Ext_list.append b  [S.if_ (E.not e)
                           [S.exp out2]
                        ])
                end
              |  ReturnFalse , {block = []; value = Some out1}, _ -> 
                (* assert branch 
                    TODO: here we re-compile two branches since
                    its context is different -- could be improved
                *)
                if Js_analyzer.no_side_effect_expression out1 then 
                  Js_output.make
                    (Ext_list.append b [ S.if_ (E.not e)
                            (Js_output.to_block @@
                             (compile_lambda cxt f_br))])
                else 
                  Js_output.make 
                    (Ext_list.append b [S.if_ e 
                           (Js_output.to_block 
                            @@ compile_lambda cxt t_br)
                           ~else_:(Js_output.to_block @@  
                                   (compile_lambda cxt f_br))]
                    )

              | ReturnFalse , _, {block = []; value = Some out2} -> 
                let else_ = 
                  if  Js_analyzer.no_side_effect_expression out2 then  
                    None 
                  else 
                    Some (
                      Js_output.to_block @@
                      compile_lambda cxt f_br) in 
                Js_output.make 
                  (Ext_list.append b [S.if_ e 
                         (Js_output.to_block @@
                          compile_lambda cxt t_br)
                         ?else_])

              | ReturnTrue _, {block = []; value =  Some out1}, 
                {block = []; value =  Some out2} ->
                (*                
#if BS_DEBUG then 
            let () = Ext_log.dwarn __LOC__ "\n@[[TIME:]Lifthenelse: %f@]@."  (Sys.time () *. 1000.) in      
#end                 
*)
                Js_output.make 
                (Ext_list.append b  [S.return  (E.econd e  out1 out2)]) ~finished:True                         
              |   _, _, _  ->
                (*              
#if BS_DEBUG then 
            let () = Ext_log.dwarn __LOC__ "\n@[[TIME:]Lifthenelse: %f@]@."  (Sys.time () *. 1000.) in      
#end 
*)
                let then_output = 
                  Js_output.to_block @@ 
                  (compile_lambda cxt  t_br) in
                let else_output = 
                  Js_output.to_block @@ 
                  (compile_lambda cxt f_br) in
                Js_output.make (Ext_list.append b  [
                    S.if_ e 
                      then_output
                      ~else_:else_output
                  ])
              end
          end
        | {value = None } -> assert false 
      end
    | Lstringswitch(l, cases, default) -> 

      (* TODO might better optimization according to the number of cases  
          Be careful: we should avoid multiple evaluation of l,
          The [gen] can be elimiated when number of [cases] is less than 3
      *)
      begin
        match compile_lambda {cxt with should_return = ReturnFalse ; st = NeedValue} l 
        with
        | {block ; value =  Some e}  -> 
          (* when should_return is true -- it's passed down 
             otherwise it's ok *)
          let default = 
            match default with 
            | Some x -> Default x 
            | None -> Complete in
          begin
            match st with 
            (* TODO: can be avoided when cases are less than 3 *)
            | NeedValue -> 
              let v = Ext_ident.create_tmp () in 
              Js_output.make (Ext_list.append block @@
                              compile_string_cases 
                                {cxt with st = Declare (Variable, v)}
                                e cases default) ~value:(E.var v)
            | _ -> 
              Js_output.make 
                (Ext_list.append block @@ compile_string_cases  cxt e cases default)  end

        | _ -> assert false 
      end
    | Lswitch(lam,
              {sw_numconsts; 
               sw_consts;
               sw_numblocks;
               sw_blocks;
               sw_failaction = default }) 
      -> 
      (* TODO: if default is None, we can do some optimizations
          Use switch vs if/then/else

          TODO: switch based optimiztion - hash, group, or using array,
                also if last statement is throw -- should we drop remaining
                statement?
      *)
      let  sw_num_default  =      
        match default with 
        | None -> Complete 
        | Some x -> 
          if Ext_list.length_ge sw_consts sw_numconsts 
          then Complete
          else Default x in 
      let sw_blocks_default = 
        match default  with      
        | None -> Complete 
        | Some x -> 
          if Ext_list.length_ge sw_blocks sw_numblocks
          then Complete
          else Default x in 
      let compile_whole  ({st; _} as cxt  : Lam_compile_defs.cxt ) =
        match sw_numconsts, sw_numblocks, 
              compile_lambda {cxt with should_return = ReturnFalse; st = NeedValue}
                lam with 
        | 0 , _ , {block; value =  Some e}  ->
          compile_cases cxt (E.tag e )  sw_blocks sw_blocks_default
        | _, 0, {block; value =  Some e} ->  
          compile_cases cxt e  sw_consts sw_num_default
        | _, _,  { block; value =  Some e} -> (* [e] will be used twice  *)
          let dispatch e = 
            [
              S.if_ 
                (E.is_type_number e )
                (compile_cases cxt e sw_consts sw_num_default
                )
                (* default still needed, could simplified*)
                ~else_:
                  (compile_cases  cxt (E.tag e ) sw_blocks 
                     sw_blocks_default)
            ] in 
          begin
            match e.expression_desc with 
            | J.Var _  -> dispatch e  
            | _ -> 
              let v = Ext_ident.create_tmp () in  
              (* Necessary avoid duplicated computation*)
              (S.define ~kind:Variable v e ) ::  dispatch (E.var v)
          end
        | _, _, {value =  None; _}  -> assert false 
      in
      begin
        match st with  (* Needs declare first *)
        | NeedValue -> 
          (* Necessary since switch is a statement, we need they return 
             the same value for different branches -- can be optmized 
             when branches are minimial (less than 2)
          *)
          let v = Ext_ident.create_tmp () in
          Js_output.make (S.declare_variable ~kind:Variable v   :: compile_whole {cxt with st = Assign v})
            ~value:(E.var  v)

        | Declare (kind,id) -> 
          Js_output.make (S.declare_variable ~kind id
                          :: compile_whole {cxt with st = Assign id} )
        | EffectCall | Assign _  -> Js_output.make (compile_whole cxt)
      end

    | Lstaticraise(i, largs) ->  (* TODO handlding *largs*)
      (* [i] is the jump table, [largs] is the arguments passed to [Lstaticcatch]*)
      begin
        match Lam_compile_defs.HandlerMap.find i cxt.jmp_table  with 
        | {exit_id; args ; order_id} -> 
          let args_code  =
            (Js_output.concat @@ List.map2 (
                fun (x : Lam.t) (arg : Ident.t) ->
                  match x with
                  | Lvar id -> 
                    Js_output.make [S.assign arg (E.var id)]

                  | _ -> (* TODO: should be Assign -- Assign is an optimization *)
                    compile_lambda {cxt with st = Assign arg ; should_return =  ReturnFalse} x 
              ) largs (args : Ident.t list)) 
          in
          args_code ++ (* Declared in [Lstaticraise ]*)
          Js_output.make [S.assign exit_id (E.small_int  order_id)]
            ~value:E.undefined
        | exception Not_found ->
          Js_output.make [S.unknown_lambda ~comment:"error" lam]
          (* staticraise is always enclosed by catch  *)
      end
    (* Invariant: code can not be reused 
        (catch l with (32)
        (handler))
        32 should not be used in another catch
        Assumption: 
        This is true in current ocaml compiler
        currently exit only appears in should_return position relative to staticcatch
        if not we should use ``javascript break`` or ``continue``
    *)
    | Lstaticcatch _  -> 
      let code_table, body =  flatten_caches lam in

      let exit_id =   Ext_ident.create_tmp ~name:"exit" () in
      let exit_expr = E.var exit_id in
      let bindings = Ext_list.flat_map (fun (_,_,bindings) -> bindings) code_table in

      (* compile_list name l false (\*\) *)
      (* if exit_code_id == code 
         handler -- ids are not useful, since 
         when compiling `largs` we will do the binding there
         - when exit_code is undefined internally, 
           it should PRESERVE  ``tail`` property
         - if it uses `staticraise` only once 
           or handler is minimal, we can inline
         - always inline also seems to be ok, but it might bloat the code
         - another common scenario is that we have nested catch
           (catch (catch (catch ..))
      *)
      (*
        checkout example {!Digest.file}, you can not inline handler there, 
        we can spot such patten and use finally there?
         {[
           let file filename =
             let ic = open_in_bin filename in
             match channel ic (-1) with
             | d -> close_in ic; d
             | exception e -> close_in ic; raise e

         ]}
      *)
      (* TODO: handle NeedValue *)
      let jmp_table, handlers =  Lam_compile_defs.add_jmps (exit_id, code_table) jmp_table in

      (* Declaration First, body and handler have the same value *)
      (* There is a bug in google closure compiler:
            https://github.com/google/closure-compiler/issues/1234#issuecomment-151976340 
            TODO: wait for a bug fix
      *)
      let declares = 
        S.define ~kind:Variable exit_id
          E.zero_int_literal :: 
        (* we should always make it zero here, since [zero] is reserved in our mapping*)
        Ext_list.map (fun x -> S.declare_variable ~kind:Variable x ) bindings in

      begin match  st with 
        (* could be optimized when cases are less than 3 *)
        | NeedValue -> 
          let v = Ext_ident.create_tmp  () in 
          let lbody = compile_lambda {cxt with 
                                      jmp_table = jmp_table;
                                      st = Assign v
                                     } body in
          Js_output.make  (S.declare_variable ~kind:Variable v  :: declares) ++ 
          lbody ++ Js_output.make (
            compile_cases 
              {cxt with st = Assign v;
                        jmp_table = jmp_table} 
              exit_expr handlers  NonComplete)  ~value:(E.var v )
        | Declare (kind, id)
          (* declare first this we will do branching*) ->
          let declares = 
            S.declare_variable ~kind id  :: declares in   
          let lbody = compile_lambda {cxt with jmp_table = jmp_table; st = Assign id } body in
          Js_output.make  declares ++ 
          lbody ++ 
          Js_output.make (compile_cases 
                            {cxt with jmp_table = jmp_table; st = Assign id} 
                            exit_expr 
                            handlers
                            NonComplete
                            (* place holder -- tell the compiler that 
                               we don't know if it's complete
                            *)
                         )
        | EffectCall | Assign _  -> 
          let lbody = compile_lambda {cxt with jmp_table = jmp_table } body in
          Js_output.make declares ++
          lbody ++
          Js_output.make (compile_cases
                            {cxt with jmp_table = jmp_table}
                            exit_expr
                            handlers
                            NonComplete)
      end
    | Lwhile(p,body) ->  
      (* Note that ``J.While(expression * statement )``
            idealy if ocaml expression does not need fresh variables, we can generate
            while expression, here we generate for statement, leave optimization later. 
            (Sine OCaml expression can be really complex..)
      *)
      (match compile_lambda {cxt with st = NeedValue; should_return = ReturnFalse } p 
       with 
       | {block; value =  Some e} -> 
         (* st = NeedValue -- this should be optimized and never happen *)
         let e = 
           match block with
           | [] -> e 
           | _ -> E.of_block block ~e  in
         let block = 
           [
             S.while_
               e
               (Js_output.to_block @@ 
                compile_lambda 
                  {cxt with st = EffectCall; should_return = ReturnFalse}
                  body)
           ] in

         begin
           match st, should_return  with 
           | Declare (_kind, x), _  ->  (* FIXME _kind not used *)
             Js_output.make (Ext_list.append block  [S.declare_unit x ])
           | Assign x, _  ->
             Js_output.make (Ext_list.append block  [S.assign_unit x ])
           | EffectCall, ReturnTrue _  -> 
             Js_output.make (Ext_list.append block  [S.return_unit ()]) ~finished:True
           | EffectCall, _ -> Js_output.make block
           | NeedValue, _ -> Js_output.make block ~value:E.unit end
       | _ -> assert false )

    | Lfor (id,start,finish,direction,body) -> 
      (* all non-tail *)
      (* TODO: check semantics should start, finish be executed each time in both 
           ocaml and js?, also check evaluation order..
           in ocaml id is not in the scope of finish, so it should be safe here

           for i  = 0 to (print_int 3; 10) do print_int i done;;
           3012345678910- : unit = ()

         for(var i =  0 ; i < (console.log(i),10); ++i){console.log('hi')}
         print i each time, so they are different semantics...
      *)

      let block =
        begin
          match compile_lambda {cxt with st = NeedValue; should_return = ReturnFalse} start,
                compile_lambda {cxt with st = NeedValue; should_return = ReturnFalse} finish with 
          | {block = b1; value =  Some e1}, {block = b2; value =  Some e2} -> 

            (* order b1 -- (e1 -- b2 -- e2) 
                in most cases we can shift it into such scenarios
                b1, b2, [e1, e2]
                - b2 is Empty
                - e1 is pure
                we can guarantee e1 is pure, if it literally contains a side effect call,
                put it in the beginning


            *)
            begin 
              match b1,b2 with
              | _,[] -> 
                Ext_list.append b1 [S.for_ (Some e1) e2  id direction 
                         (Js_output.to_block @@ 
                          compile_lambda {cxt with should_return = ReturnFalse ; st = EffectCall}
                            body) ]
              | _, _ when Js_analyzer.no_side_effect_expression e1 
                (* 
                     e1 > b2 > e2
                     re-order 
                     b2 > e1 > e2
                   *)
                -> 
                Ext_list.append b1 
                  (Ext_list.append b2  [S.for_ (Some e1) e2  id direction 
                             (Js_output.to_block @@ 
                              compile_lambda {cxt with should_return = ReturnFalse ; st = EffectCall}
                                body) ])
              | _ , _
                -> 
                Ext_list.append b1 (S.define ~kind:Variable id e1 :: (Ext_list.append b2   [
                    S.for_ None e2 id direction 
                      (Js_output.to_block @@ 
                       compile_lambda {cxt with should_return = ReturnFalse ; st = EffectCall}
                         body) 
                  ]))

            end


          | _ -> assert false end in
      begin
        match st, should_return with 
        | EffectCall, ReturnFalse  -> Js_output.make block
        | EffectCall, ReturnTrue _  -> 
          Js_output.make (Ext_list.append block  [S.return_unit()]) ~finished:True
        (* unit -> 0, order does not matter *)
        | (Declare _ | Assign _), ReturnTrue _ -> Js_output.make [S.unknown_lambda lam]
        | Declare (_kind, x), ReturnFalse  ->   
          (* FIXME _kind unused *)
          Js_output.make (Ext_list.append block    [S.declare_unit x ])
        | Assign x, ReturnFalse  -> 
          Js_output.make (Ext_list.append block  [S.assign_unit x ])
        | NeedValue, _ 
          ->  
          Js_output.make block ~value:E.unit
          (* TODO: fixme, here it's ok*)
      end
    | Lassign(id,lambda) -> 
      let block = 
        match lambda with
        | Lprim {primitive = Poffsetint  v; args =  [Lvar id']}
          when Ident.same id id' ->
          [ S.exp (E.assign (E.var id) 
                     (E.int32_add (E.var id) (E.small_int  v)))
          ]
        | _ ->
          begin 
            match compile_lambda {cxt with st = NeedValue; should_return = ReturnFalse} lambda with 
            | {block = b; value =  Some v}  -> 
              (Ext_list.append b  [S.assign id v ])
            | _ -> assert false  
          end
      in
      begin
        match st, should_return with 
        | EffectCall, ReturnFalse -> Js_output.make block
        | EffectCall, ReturnTrue _ -> 
          Js_output.make (Ext_list.append block  [S.return_unit ()]) ~finished:True
        | (Declare _ | Assign _ ) , ReturnTrue _ -> 
          Js_output.make [S.unknown_lambda lam]
        (* bound by a name, while in a tail position, this can not happen  *)
        | Declare (_kind, x) , ReturnFalse ->
          (* FIXME: unused *)
          Js_output.make (Ext_list.append block  [ S.declare_unit x ])
        | Assign x, ReturnFalse  -> Js_output.make (Ext_list.append block  [S.assign_unit x ])
        | NeedValue, _ -> 
          Js_output.make block ~value:E.unit
      end
    | (Ltrywith(
        (Lprim {primitive = Pccall {prim_name = "caml_sys_getenv"; _};
                args = [Lconst _]} as body),
        id, 
        Lifthenelse
          (Lprim{primitive = Pintcomp(Ceq);
                 args = [Lvar id2 ; 
                         Lprim{primitive = Pglobal_exception {name = "Not_found"}; _}]},
           cont, _reraise )
      )
      | Ltrywith(
          (Lprim {primitive = Pccall {prim_name = "caml_sys_getenv"; _};
                  args = [Lconst _]} as body),
          id, 
          Lifthenelse(Lprim{primitive = Pintcomp(Ceq);
                            args = [ 
                              Lprim { primitive = Pglobal_exception {name = "Not_found"; _}; _}; Lvar id2 ]},
                      cont, _reraise )
        )) when Ident.same id id2 
      -> 
      compile_lambda cxt (Lam.try_ body id cont)
    | Ltrywith(lam,id, catch) ->  (* generate documentation *)
      (* 
         tail --> should be renamed to `shouldReturn`  
          in most cases ``shouldReturn`` == ``tail``, however, here is not, 
          should return, but it is not a tail call in js
          (* could be optimized using javascript style exceptions *)
         {[
           {try
              {var $js=g(x);}
                catch(exn){if(exn=Not_found){var $js=0;}else{throw exn;}}
           return h($js);
         }
         ]}
      *)
      let aux st = 
        (* should_return is passed down *)
        (* #1701 *)
        [ S.try_ 
            (Js_output.to_block (compile_lambda 
                                   (match should_return with 
                                    | ReturnTrue (Some _ ) -> {cxt with st = st; should_return = ReturnTrue None}
                                    | ReturnTrue None | ReturnFalse -> {cxt with st = st}) lam))
            ~with_:(id, 
                    Js_output.to_block @@ 
                    compile_lambda {cxt with st = st} catch )

        ] in 

      begin
        match st with 
        | NeedValue -> 
          let v = Ext_ident.create_tmp () in
          Js_output.make (S.declare_variable ~kind:Variable v :: aux (Assign v))  ~value:(E.var v )
        | Declare (kind,  id) -> 
          Js_output.make (S.declare_variable ~kind
                            id :: aux (Assign id))
        | Assign _ | EffectCall -> Js_output.make (aux st)
      end


    | Lsend(meth_kind,met, obj, args,loc) -> 
      (* Note that in [Texp_apply] for [%sendcache] the cache might not be used 
         see {!CamlinternalOO.send_meth} and {!Translcore.transl_exp0} the branch
         [Texp_apply] when [public_send ], args are simply dropped

         reference 
         [js_of_ocaml] 
         1. GETPUBMET
         2. GETDYNMET
         3. GETMETHOD
         [ocaml]
         Lsend (bytegen.ml)
         For the object layout refer to [camlinternalOO/create_object]
         {[
           let create_object table =
             (* XXX Appel de [obj_block] *)
             let obj = mark_ocaml_object @@ Obj.new_block Obj.object_tag table.size in
             (* XXX Appel de [caml_modify] *)
             Obj.set_field obj 0 (Obj.repr table.methods);
             Obj.obj (set_id obj)

           let create_object_opt obj_0 table =
             if (Obj.magic obj_0 : bool) then obj_0 else begin
               (* XXX Appel de [obj_block] *)
               let obj = mark_ocaml_object @@ Obj.new_block Obj.object_tag table.size in
               (* XXX Appel de [caml_modify] *)
               Obj.set_field obj 0 (Obj.repr table.methods);
               Obj.obj (set_id obj)
             end
         ]}
         it's a block with tag [248], the first field is [table.methods] which is an array 
         {[
           type table =
             { mutable size: int;
               mutable methods: closure array;
               mutable methods_by_name: meths;
               mutable methods_by_label: labs;
               mutable previous_states:
                 (meths * labs * (label * item) list * vars *
                  label list * string list) list;
               mutable hidden_meths: (label * item) list;
               mutable vars: vars;
               mutable initializers: (obj -> unit) list }
         ]}
      *)


      begin match 
          (met :: obj :: args) 
          |> Ext_list.split_map (fun (x : Lam.t) -> 
              match x with 
              | Lprim {primitive = Pccall {prim_name ; _}; args =  []}
                (* nullary external call*)
                -> 
                [], E.var (Ext_ident.create_js prim_name)
              | _ -> 
                begin
                  match compile_lambda
                          {cxt with st = NeedValue; should_return = ReturnFalse}
                          x with
                  | {block = a; value = Some b} -> a, b 
                  | _ -> assert false
                end
            ) with  
      | _, ([] | [_]) -> assert false
      | (args_code, label::obj'::args) 
        -> 
        let cont3 obj' k = 
          match Js_ast_util.named_expression obj' with 
          | None -> 
            let cont =
              Js_output.handle_block_return 
                st should_return lam (List.concat args_code)
            in
            cont (k obj')
          | Some (obj_code, v) -> 
            let cont2 obj_code v = 
              Js_output.handle_block_return 
                st should_return lam 
                (obj_code :: List.concat args_code) v in 
            let obj' = E.var v in 
            cont2 obj_code (k obj') 
        in
        begin
          match meth_kind with 
          | Self -> 
            (* TODO: horrible hack -- fixed later *)
            cont3 obj' (fun obj' -> E.call ~info:Js_call_info.dummy 
                           (Js_of_lam_array.ref_array 
                              (Js_of_lam_record.field Fld_na obj' 0l) label )
                           (obj' :: args))
          (* [E.small_int 1] is because we use array, 
              when we change the runtime represenation, it needs to be adapted 
          *)

          | Cached | Public None
            (* TODO: check -- 1. js object propagate 2. js object create  *)
            -> 
            let get = E.runtime_ref  Js_runtime_modules.oo "caml_get_public_method" in
            let cache = !method_cache_id in
            let () = incr method_cache_id  in
            cont3 obj' (fun obj' -> 
                E.call ~info:Js_call_info.dummy 
                  (E.call ~info:Js_call_info.dummy get 
                     [obj'; label; E.small_int cache]) (obj'::args)
              ) (* avoid duplicated compuattion *)


          | Public (Some name) -> 
            let cache = !method_cache_id in
            incr method_cache_id ;
            cont3 obj' 
              (fun obj' -> E.public_method_call name obj' label 
                  (Int32.of_int cache) args )

        end
      end

    (* [J.Empty,J.N] *)  (* TODO debugging, sourcemap, ignore lambda_event currently *)
    (* 
        seems to be an optimization trick for [translclass]
        | Lifused(v, l) ->
        if count_var v > 0 then simplif l else lambda_unit
    *)
    | Lifused(_,lam) -> compile_lambda cxt lam
  end

end
module Lam_pass_alpha_conversion : sig 
#1 "lam_pass_alpha_conversion.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** alpha conversion based on arity *)

val alpha_conversion : Lam_stats.t -> Lam.t  -> Lam.t

end = struct
#1 "lam_pass_alpha_conversion.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








let alpha_conversion (meta : Lam_stats.t) (lam : Lam.t) : Lam.t = 
  let rec simpl  (lam : Lam.t) = 
    match lam with 
    | Lconst _ -> lam
    | Lvar _ -> lam 
    | Lapply {fn = l1; args =  ll;  loc ; status} 
      -> (* detect functor application *)
      begin 
        match Lam_stats_util.get_arity meta l1 with 
        | NA -> 
          Lam.apply (simpl  l1) (Ext_list.map simpl  ll) loc status
        | Determin (b, args, tail) -> 
          let len = List.length ll in 
          let rec take args = 
            match args with 
            | (x,_) :: xs -> 
              if x = len 
              then 
                Lam.apply (simpl l1)
                  (Ext_list.map simpl ll) loc App_ml_full
              else if x > len  
              then 
                let fn = simpl l1 in
                let args = Ext_list.map simpl ll in
                Lam_eta_conversion.transform_under_supply (x - len) loc App_ml_full
                  fn args 
              else 
                let first,rest = Ext_list.take x ll in 
                Lam.apply (
                  Lam.apply (simpl l1) 
                         (Ext_list.map simpl first) 
                         loc App_ml_full
                )
                  (Ext_list.map simpl rest) loc status (* TODO refien *)
            | _ -> Lam.apply (simpl l1) (Ext_list.map simpl ll)  loc status
          in take args
      end

    | Llet (str, v, l1, l2) ->
      Lam.let_ str v (simpl l1) (simpl l2 )
    | Lletrec (bindings, body) ->
      let bindings = Ext_list.map (fun (k,l) -> (k, simpl l)) bindings in 
      Lam.letrec bindings (simpl body) 
    | Lglobal_module _ -> lam 
    | Lprim {primitive = (Lam.Pjs_fn_make len) as primitive ; args = [arg] 
      ; loc } -> 
      
      begin match Lam_stats_util.get_arity meta arg with       
      | Determin (b, (x,_)::_, tail)
        -> 
        let arg = simpl arg in
          Lam_eta_conversion.unsafe_adjust_to_arity loc 
            ~to_:len 
            ~from:x
            arg 
      | _  -> Lam.prim ~primitive ~args:[simpl arg] loc
      end
    | Lprim {primitive; args ; loc} -> 
      Lam.prim ~primitive ~args:(Ext_list.map simpl  args) loc
    | Lfunction {arity; function_kind; params; body = l} ->
      (* Lam_mk.lfunction kind params (simpl l) *)
      Lam.function_ ~arity ~function_kind ~params  ~body:(simpl  l)
    | Lswitch (l, {sw_failaction; 
                  sw_consts; 
                  sw_blocks;
                  sw_numblocks;
                  sw_numconsts;
                 }) ->
      Lam.switch (simpl  l)
              {sw_consts = 
                 Ext_list.map (fun (v, l) -> v, simpl  l) sw_consts;
               sw_blocks = Ext_list.map (fun (v, l) -> v, simpl  l) sw_blocks;
               sw_numconsts = sw_numconsts;
               sw_numblocks = sw_numblocks;
               sw_failaction = 
                 begin 
                   match sw_failaction with 
                   | None -> None
                   | Some x -> Some (simpl x)
                 end}
    | Lstringswitch (l, sw, d) ->
      Lam.stringswitch (simpl  l)
                    (Ext_list.map (fun (i, l) -> i,simpl  l) sw)
                    (match d with
                      | Some d -> Some (simpl d )
                      | None -> None)
                    
    | Lstaticraise (i,ls) ->
      Lam.staticraise i (Ext_list.map simpl  ls)
    | Lstaticcatch (l1, ids, l2) 
      -> 
      Lam.staticcatch (simpl  l1) ids (simpl  l2)
    | Ltrywith (l1, v, l2) 
      -> 
      Lam.try_ (simpl  l1) v (simpl  l2)
    | Lifthenelse (l1, l2, l3) -> 
      Lam.if_ (simpl  l1) (simpl  l2) (simpl  l3)
    | Lsequence (l1, l2) 
      -> Lam.seq (simpl  l1) (simpl  l2)
    | Lwhile (l1, l2)
      -> Lam.while_ (simpl  l1) (simpl l2)
    | Lfor (flag, l1, l2, dir, l3)
      -> Lam.for_ flag (simpl  l1) (simpl  l2) dir (simpl  l3)
    | Lassign (v, l) ->
      (* Lalias-bound variables are never assigned, so don't increase
         v's refsimpl *)
      Lam.assign v (simpl  l)
    | Lsend (u, m, o, ll, v) -> 
      Lam.send u (simpl m) (simpl o) (Ext_list.map simpl ll) v
    | Lifused (v, l) -> Lam.ifused v (simpl  l)
  in 

  simpl lam

end
module Lam_pass_collect : sig 
#1 "lam_pass_collect.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)









(** This pass is used to collect meta data information.

    It includes:
    alias table, arity for identifiers and might more information,
    
    ATTENTION:
    For later pass to keep its information complete and up to date,
    we  need update its table accordingly

    - Alias inference is not for substitution, it is for analyze which module is 
      actually a global module or an exception, so it can be relaxed a bit
      (without relying on strict analysis)

    - Js object (local) analysis 

    Design choice:

    Side effectful operations:
       - Lassign 
       - Psetfield

    1. What information should be collected:

    2. What's the key
       If it's identifier, 
       
    Information that is always sound, not subject to change 

    - shall we collect that if an identifier is passed as a parameter, (useful for escape analysis), 
    however, since it's going to change after inlning (for local function)

    - function arity, subject to change when you make it a mutable ref and change it later
    
    - Immutable blocks of identifiers
     
      if identifier itself is function/non block then the access can be inlined 
      if identifier itself is immutable block can be inlined
      if identifier is mutable block can be inlined (without Lassign) since

    - When collect some information, shall we propogate this information to 
      all alias table immeidately

      - annotation identifiers (at first time)
      -
 *)

(** Modify existing [meta] *)
val collect_helper : Lam_stats.t -> Lam.t -> unit

(** return a new [meta] *)
 val count_alias_globals : 
    Env.t -> string -> Ident.t list -> Ident_set.t -> Lam.t -> Lam_stats.t 



end = struct
#1 "lam_pass_collect.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)









let annotate (meta : Lam_stats.t)
    rec_flag    
    (k:Ident.t) (v : Lam_arity.t) lambda = 
  (* Ext_log.dwarn  __LOC__ "%s/%d" k.name k.stamp;     *)
  match Ident_hashtbl.find_opt  meta.ident_tbl k  with 
  | None -> (** FIXME: need do a sanity check of arity is NA or Determin(_,[],_) *)
      Ident_hashtbl.add meta.ident_tbl k 
        (FunctionId {
            arity = v; lambda; rec_flag})
  |  Some (FunctionId old)  ->  
      (** Check, it is shared across ident_tbl, 
          Only [Lassign] will break such invariant,
          how about guarantee that [Lassign] only check the local ref 
          and we track which ids are [Lassign]ed
       *)
      (**
         might not be the same due to refinement
         assert (old.arity = v) 
       *)
        old.arity <- v  (* due to we keep refining arity analysis after each round*)
      

  | _ -> assert false (* TODO -- avoid exception *)


(** it only make senses recording arities for 
    function definition,
    alias propgation - and toplevel identifiers, this needs to be exported
 *)
let collect_helper  (meta : Lam_stats.t) (lam : Lam.t)  = 
  let rec collect_bind rec_flag
      (kind : Lam.let_kind) 
      (ident : Ident.t)
      (lam : Lam.t) = 
    match lam with 
    | Lconst v 
      -> 
      Ident_hashtbl.replace meta.ident_tbl ident (Constant v); (** *)
    | Lprim {primitive = Pmakeblock (_, _, Immutable ) ; args=  ls}
      -> 
      Ident_hashtbl.replace meta.ident_tbl ident 
        (Lam_util.kind_of_lambda_block Normal ls);
      List.iter collect ls     
    | Lprim {primitive = Pnull_to_opt; 
             args = ([ Lvar _] as ls) ; _}
      ->
      Ident_hashtbl.replace meta.ident_tbl ident 
        (Lam_util.kind_of_lambda_block Null ls )    
    | Lprim {primitive = Pundefined_to_opt; 
             args = ([ Lvar _] as ls); _}
      ->
      Ident_hashtbl.replace meta.ident_tbl ident 
        (Lam_util.kind_of_lambda_block Undefined ls )
    | Lprim {primitive = Pnull_undefined_to_opt;
             args = ([ Lvar _] as ls);}
      ->
      Ident_hashtbl.replace meta.ident_tbl ident 
        (Lam_util.kind_of_lambda_block Null_undefined ls )
    | Lglobal_module v  
      -> 
        Lam_util.alias_ident_or_global meta  ident v (Module  v) kind; 
    | Lvar v 
      -> 
        (
         (* if Ident.global v then  *)
         Lam_util.alias_ident_or_global meta  ident v NA kind
           (* enven for not subsitution, it still propogate some properties *)
           (* else () *)
        )
    | Lfunction{ params; body = l}
        (** TODO record parameters ident ?, but it will be broken after inlining *)  
      -> 
        (** TODO could be optimized in one pass? 
            -- since collect would iter everywhere,
            so -- it would still iterate internally
         *)

      List.iter (fun p -> Ident_hashtbl.add meta.ident_tbl p Parameter ) params;
      let arity = Lam_stats_util.get_arity meta lam in       
      annotate meta rec_flag ident  arity lam; 
      collect l
    | x -> 
        collect x ;
        if Ident_set.mem ident meta.export_idents then 
          annotate meta rec_flag ident (Lam_stats_util.get_arity meta x ) lam


  and collect  (lam : Lam.t)  =
    match lam with 

        (** TODO: 
            how about module aliases..
            record dependency
            --- tricky -- if we inlining, 
            is it safe to remove it? probably not...
         *)
    | Lconst _ -> ()
    | Lvar _ -> ()
    | Lapply{fn = l1; args =  ll; _} ->
        collect  l1; List.iter collect  ll
    | Lfunction { params; body =  l} -> (* functor ? *)
        List.iter (fun p -> Ident_hashtbl.add meta.ident_tbl p Parameter ) params;
        collect  l
    | Llet (kind,ident,arg,body) -> 
        collect_bind Non_rec kind ident arg ; collect body
    | Lletrec (bindings, body) -> 
        List.iter (fun (ident,arg) -> collect_bind Rec  Strict ident arg ) bindings;
        collect body
    | Lglobal_module _ -> ()
    | Lprim {args; _} -> List.iter collect  args
    | Lswitch(l, {sw_failaction; sw_consts; sw_blocks}) ->
        collect  l;
        List.iter (fun (_, l) -> collect  l) sw_consts;
        List.iter (fun (_, l) -> collect  l) sw_blocks;
        begin match sw_failaction with 
        | None -> ()
        | Some x -> collect x
        end
    | Lstringswitch(l, sw, d) ->
        collect  l ;
        List.iter (fun (_, l) -> collect  l) sw ;
        begin match d with
        | Some d -> collect d 
        | None -> ()
        end
    | Lstaticraise (code,ls) -> 
          List.iter collect  ls
    | Lstaticcatch(l1, (_,_), l2) -> collect  l1; collect  l2
    | Ltrywith(l1, _, l2) -> collect  l1; collect  l2
    | Lifthenelse(l1, l2, l3) -> collect  l1; collect  l2; collect  l3
    | Lsequence(l1, l2) -> collect  l1; collect  l2
    | Lwhile(l1, l2) -> collect  l1; collect l2
    | Lfor(_, l1, l2, dir, l3) -> collect  l1; collect  l2; collect  l3
    | Lassign(v, l) ->
        (* Lalias-bound variables are never assigned, so don't increase
           v's refcollect *)
        collect  l
    | Lsend(_, m, o, ll, _) -> List.iter collect  (m::o::ll)
    | Lifused(_, l) -> collect  l in collect lam 



let count_alias_globals 
    env 
    filename
    export_idents
    export_sets 
    (lam : Lam.t) : Lam_stats.t =
  let meta : Lam_stats.t = 
    {alias_tbl = Ident_hashtbl.create 31 ; 
     ident_tbl = Ident_hashtbl.create 31;
     
     exports =  export_idents;
     filename;
     env;
     export_idents = export_sets;
   } in 
  collect_helper  meta lam ; 
  meta

end
module Lam_pass_deep_flatten : sig 
#1 "lam_pass_deep_flatten.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


val deep_flatten : Lam.t -> Lam.t

end = struct
#1 "lam_pass_deep_flatten.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

(* [groups] are in reverse order *)

      (** be careful to flatten letrec 
          like below : 
          {[
            let rec even = 
              let odd n =  if n ==1 then true else even (n - 1) in
              fun n -> if n ==0  then true else odd (n - 1)
          ]}
          odd and even are recursive values, since all definitions inside 
          e.g, [odd] can see [even] now, however, it should be fine
          in our case? since ocaml's recursive value does not allow immediate 
          access its value direclty?, seems no
          {[
            let rec even2 = 
              let odd = even2 in
              fun n -> if n ==0  then true else odd (n - 1)
          ]}
      *)
      (* FIXME:
          here we try to move inner definitions of [recurisve value] upwards
          for example:
         {[
           let rec x = 
             let y = 32 in
             y :: x
           and z = ..
             ---
             le ty = 32 in
           let rec x = y::x
           and z = ..
         ]}
          however, the inner definitions can see [z] and [x], so we
          can not blindly move it in the beginning, however, for 
          recursive value, ocaml does not allow immediate access to 
          recursive value, so what's the best strategy?
          ---
          the motivation is to capture real tail call
      *)
      (*            | Single ((Alias | Strict | StrictOpt), id, ( Lfunction _ )) -> 
              (** FIXME: 
                   It should be alias and alias will be optimized away
                   in later optmizations, however, 
                   this means if we don't optimize 
                  {[ let u/a = v in ..]}
                   the output would be wrong, we should *optimize 
                   this away right now* instead of delaying it to the 
                   later passes
              *)
              (acc, set, g :: wrap, stop)
      *)
       (* could also be from nested [let rec] 
                 like 
                 {[
                   let rec x = 
                     let rec y = 1 :: y in
                     2:: List.hd y:: x 
                 ]}
                 TODO: seems like we should update depenency graph, 

              *)
      (** TODO: more flattening, 
          - also for function compilation, flattening should be done first
          - [compile_group] and [compile] become mutually recursive function
      *)
      (* Printlambda.lambda Format.err_formatter lam ; assert false  *)              
let lambda_of_groups ~rev_bindings result  = 
  List.fold_left (fun acc x -> 
      match (x : Lam_group.t) with 
      | Nop l -> Lam.seq l acc
      | Single(kind,ident,lam) -> Lam_util.refine_let ~kind ident lam acc
      | Recursive bindings -> Lam.letrec bindings acc) 
    result rev_bindings


(* TODO: 
    refine effectful [ket_kind] to be pure or not
    Be careful of how [Lifused(v,l)] work 
    since its semantics depend on whether v is used or not
    return value are in reverse order, but handled by [lambda_of_groups]
*)
let deep_flatten
    (lam : Lam.t) :  Lam.t  = 
  let rec
    flatten 
      (acc :  Lam_group.t list ) 
      (lam : Lam.t) :  Lam.t *  Lam_group.t list = 
    match lam with 
    | Llet (str, id, 
            (Lprim {primitive = (
                          Pnull_to_opt
                         | Pundefined_to_opt
                         | Pnull_undefined_to_opt)
                   ; args  =  [Lvar _]} as arg), body)
      -> 
      flatten (Single(str, id, (aux arg) ) :: acc) body
    | Llet (str, id, 
            Lprim {primitive = ( 
                          Pnull_to_opt | Pundefined_to_opt | Pnull_undefined_to_opt as primitive );
                   args = [arg]}, body)
      -> 
      let id' = Ident.rename id in 
      flatten acc 
        (Lam.let_ str id' arg 
               (Lam.let_ Alias id 
                  (Lam.prim 
                     ~primitive
                     ~args: [Lam.var id'] Location.none (* FIXME*))
                  body)
              )
    | Llet (str,id,arg,body) -> 
      let (res,l) = flatten acc arg  in
      flatten (Single(str, id, res ) :: l) body
    | Lletrec (bind_args, body) -> 

      flatten
        (
          Recursive
            (Ext_list.map (fun (id, arg ) -> (id, aux arg)) bind_args)
          :: acc
        )
        body
    | Lsequence (l,r) -> 
      let (res, l)  = flatten acc l in
      flatten (Nop res :: l)  r
    | x ->  
      aux x, acc      

  and aux  (lam : Lam.t) : Lam.t= 
    match lam with 
    | Llet _ -> 
      let res, groups = flatten [] lam  
      in lambda_of_groups res ~rev_bindings:groups
    | Lletrec (bind_args, body) ->  
      (* Attention: don't mess up with internal {let rec} *)
      let rec iter bind_args groups set  =
        match bind_args with
        | [] ->   (List.rev groups, set)
        | (id,arg) :: rest ->
          iter rest ((id, aux arg) :: groups) (Ident_set.add id set)
      in
      let groups, collections = iter bind_args [] Ident_set.empty in
      (* Try to extract some value definitions from recursive values as [wrap],
         it will stop whenever it find it could not move forward
        {[
           let rec x = 
              let y = 1 in
              let z = 2 in 
              ...  
        ]}
      *)
      let (rev_bindings, rev_wrap, _) = 
        List.fold_left (fun  (inner_recursive_bindings,  wrap,stop)  ((id,lam) )  ->           
          if stop || Lam.hit_any_variables collections lam  then 
              (id, lam) :: inner_recursive_bindings, wrap, true
          else 
              (inner_recursive_bindings,  (Lam_group.Single (Strict, id, lam)) :: wrap, false)
          ) ([],  [], false ) groups in
      lambda_of_groups 
      ~rev_bindings:rev_wrap (* These bindings are extracted from [letrec] *)
        (Lam.letrec  (List.rev rev_bindings)  (aux body)) 
    | Lsequence (l,r) -> Lam.seq (aux l) (aux r)
    | Lconst _ -> lam
    | Lvar _ -> lam 
    (* | Lapply(Lfunction(Curried, params, body), args, _) *)
    (*   when  List.length params = List.length args -> *)
    (*     aux (beta_reduce  params body args) *)
    (* | Lapply(Lfunction(Tupled, params, body), [Lprim(Pmakeblock _, args)], _) *)
    (*     (\** TODO: keep track of this parameter in ocaml trunk, *)
    (*           can we switch to the tupled backend? *\) *)
    (*   when  List.length params = List.length args -> *)
    (*       aux (beta_reduce params body args) *)

    | Lapply{fn = l1; args  = ll; loc; status} -> 
      Lam.apply (aux l1) (Ext_list.map aux ll) loc status

    (* This kind of simple optimizations should be done each time
       and as early as possible *) 

    | Lprim {primitive = Pccall{prim_name = "caml_int64_float_of_bits"; _};
            args = [ Lconst (  (Const_int64 i))]; _} 
      ->  
      Lam.const 
        (  (Const_float (Js_number.to_string (Int64.float_of_bits i) )))
    | Lprim {primitive = Pccall{prim_name = "caml_int64_to_float"; _}; 
             args = [ Lconst (  (Const_int64 i))]; _} 
      -> 
      (* TODO: note when int is too big, [caml_int64_to_float] is unsafe *)
      Lam.const 
        (  (Const_float (Js_number.to_string (Int64.to_float i) )))
    | Lglobal_module _ -> lam 
    | Lprim {primitive ; args; loc }
      -> 
      let args = Ext_list.map aux args in
      Lam.prim ~primitive ~args loc

    | Lfunction{arity; function_kind; params;  body = l} -> 
      Lam.function_ ~arity ~function_kind ~params  ~body:(aux  l)
    | Lswitch(l, {sw_failaction; 
                  sw_consts; 
                  sw_blocks;
                  sw_numblocks;
                  sw_numconsts;
                 }) ->
      Lam.switch (aux  l)
              {sw_consts = 
                 Ext_list.map (fun (v, l) -> v, aux  l) sw_consts;
               sw_blocks = Ext_list.map (fun (v, l) -> v, aux  l) sw_blocks;
               sw_numconsts = sw_numconsts;
               sw_numblocks = sw_numblocks;
               sw_failaction = 
                 begin 
                   match sw_failaction with 
                   | None -> None
                   | Some x -> Some (aux x)
                 end}
    | Lstringswitch(l, sw, d) ->
      Lam.stringswitch (aux  l) 
                    (Ext_list.map (fun (i, l) -> i,aux  l) sw)
                    (match d with
                     | Some d -> Some (aux d )
                     | None -> None)

    | Lstaticraise (i,ls) 
      -> Lam.staticraise i (Ext_list.map aux  ls)
    | Lstaticcatch(l1, ids, l2) 
      -> 
      Lam.staticcatch (aux  l1) ids (aux  l2)
    | Ltrywith(l1, v, l2) ->
      Lam.try_ (aux  l1) v (aux  l2)
    | Lifthenelse(l1, l2, l3) 
      -> 
      Lam.if_ (aux  l1) (aux l2) (aux l3)
    | Lwhile(l1, l2) 
      -> 
      Lam.while_ (aux  l1) (aux l2)
    | Lfor(flag, l1, l2, dir, l3) 
      -> 
      Lam.for_ flag (aux  l1) (aux  l2) dir (aux  l3)
    | Lassign(v, l) ->
      (* Lalias-bound variables are never assigned, so don't increase
         v's refaux *)
      Lam.assign v (aux  l)
    | Lsend(u, m, o, ll, v) -> 
      Lam.send u (aux m) (aux o) (Ext_list.map aux ll) v

    | Lifused(v, l) -> Lam.ifused v (aux  l)
  in aux lam

end
module Lam_pass_exits : sig 
#1 "lam_pass_exits.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)
(* Adapted for Javascript backend: Hongbo Zhang,                       *)


(** A pass used to optimize the exit code compilation, adaped from the compiler's
    [simplif] module
 *)



val simplify_exits : Lam.t -> Lam.t

end = struct
#1 "lam_pass_exits.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)
(* Adapted for Javascript backend: Hongbo Zhang                        *)

(*
   TODO: 
   we should have a pass called, always inlinable
   as long as its length is smaller than [exit=exit_id], for example

   {[
     switch(box_name)
       {case "":exit=178;break;
        case "b":exit=178;break;
        case "h":box_type=/* Pp_hbox */0;break;
        case "hov":box_type=/* Pp_hovbox */3;break;
        case "hv":box_type=/* Pp_hvbox */2;break;
        case "v":box_type=/* Pp_vbox */1;break;
        default:box_type=invalid_box(/* () */0);}

       switch(exit){case 178:box_type=/* Pp_box */4;break}
   ]}
*)

(** Don't modify it .. *)
let default_zero = ref 0

(* Count occurrences of (exit n ...) statements *)
let count_exit exits i =
  !(Int_hashtbl.find_default exits i default_zero)

let incr_exit exits i =
  Int_hashtbl.modify_or_init exits i incr (fun _ -> ref 1)


(** 
  This funcition counts how each [exit] is used, it will affect how the following optimizations performed.
  
  Some smart cases (this requires the following optimizations follow it): 
  
  {[
    Lstaticcatch(l1, (i,_), l2) 
  ]}
  If [l1] does not contain [(exit i)],
  [l2] will be removed, so don't count it.
  
  About Switch default branch handling, it maybe backend-specific
  See https://github.com/ocaml/ocaml/commit/fcf3571123e2c914768e34f1bd17e4cbaaa7d212#diff-704f66c0fa0fc9339230b39ce7d90919 
  For Lstringswitch ^
  
  For Lswitch, if it is not exhuastive pattern match, default will be counted twice.
  Since for pattern match,  we will  test whether it is  an integer or block, both have default cases predicate: [sw_numconsts] vs nconsts
*)
let count_helper  (lam : Lam.t) : int ref Int_hashtbl.t  = 
  let exits  = Int_hashtbl.create 17 in
  let rec count (lam : Lam.t) = 
    match lam with 
    | Lstaticraise (i,ls) -> incr_exit exits i ; List.iter count ls
    | Lstaticcatch(l1, (i,_), l2) ->
      count l1;
      if count_exit exits i > 0 
      then
        count l2
    | Lstringswitch(l, sw, d) ->
      count l;
      List.iter (fun (_, l) -> count l) sw;
      begin 
        match  d with
        | None -> ()
        | Some d ->  count d
      end
    | Lvar _| Lconst _ -> ()
    | Lapply{fn = l1; args =  ll; _} -> count l1; List.iter count ll
    | Lfunction {body = l} -> count l
    | Llet(_, _, l1, l2) ->
      count l2; count l1
    | Lletrec(bindings, body) ->
      List.iter (fun (_, l) -> count l) bindings;
      count body
    | Lglobal_module _ -> ()
    | Lprim {args;  _} -> List.iter count args
    | Lswitch(l, sw) ->
      count_default sw ;
      count l;
      List.iter (fun (_, l) -> count l) sw.sw_consts;
      List.iter (fun (_, l) -> count l) sw.sw_blocks
    | Ltrywith(l1, v, l2) -> count l1; count l2
    | Lifthenelse(l1, l2, l3) -> count l1; count l2; count l3
    | Lsequence(l1, l2) -> count l1; count l2
    | Lwhile(l1, l2) -> count l1; count l2
    | Lfor(_, l1, l2, dir, l3) -> count l1; count l2; count l3
    | Lassign(_, l) -> count l
    | Lsend(_, m, o, ll, _) -> count m; count o; List.iter count ll
    | Lifused(_, l) -> count l 

  and count_default sw =
    match sw.sw_failaction with
    | None -> ()
    | Some al ->
      let nconsts = List.length sw.sw_consts in 
      let nblocks = List.length sw.sw_blocks in
      if nconsts < sw.sw_numconsts && nblocks < sw.sw_numblocks
      then begin 
          count al ; count al
      end 
      else 
        begin (* default action will occur once *)
          assert (nconsts < sw.sw_numconsts || nblocks < sw.sw_numblocks) ;
          count al
        end in 
  count lam ; 
  exits
;;

(** The third argument is its occurrence,
  when do the substitution, if its occurence is > 1,
  we should refresh
 *)
type lam_subst = 
  | Id of Lam.t 
  | Refresh of Lam.t

type subst_tbl = (Ident.t list * lam_subst ) Int_hashtbl.t

let to_lam x = 
  match x with 
  | Id x -> x 
  | Refresh x -> Lam_bounded_vars.refresh x 

(**
   Simplify  ``catch body with (i ...) handler''
      - if (exit i ...) does not occur in body, suppress catch
      - if (exit i ...) occurs exactly once in body,
        substitute it with handler
      - If handler is a single variable, replace (exit i ..) with it


  Note:
    In ``catch body with (i x1 .. xn) handler''
     Substituted expression is
      let y1 = x1 and ... yn = xn in
      handler[x1 <- y1 ; ... ; xn <- yn]
     For the sake of preserving the uniqueness  of bound variables.
   ASKS: This documentation seems outdated
     (No alpha conversion of ``handler'' is presently needed, since
     substitution of several ``(exit i ...)''
     occurs only when ``handler'' is a variable.)
  Note that 
           for [query] result = 2, 
           the non-inline cost is 
           {[
             var exit ;

             exit = 11;
             exit = 11;

             switch(exit){
               case exit = 11 : body ; break
             }

           ]}
           the inline cost is 

           {[
             body;
             body;
           ]}

           when [i] is negative, we can not inline in general, 
           since the outer is a traditional [try .. catch] body, 
           if it is guaranteed to be non throw, then we can inline
        *)

let subst_helper (subst : subst_tbl) (query : int -> int) lam = 
  let rec simplif (lam : Lam.t) = 
    match lam with 
    | Lstaticraise (i,[])  ->
      begin match Int_hashtbl.find_opt subst i with
        | Some (_,handler) -> to_lam handler
        | None -> lam
      end
    | Lstaticraise (i,ls) ->
      let ls = Ext_list.map simplif ls in
      begin 
        match Int_hashtbl.find_opt subst i with
        | Some (xs, handler) -> 
          let handler = to_lam handler in 
          let ys = Ext_list.map Ident.rename xs in
          let env =
            List.fold_right2
              (fun x y t -> Ident_map.add x (Lam.var y) t)
              xs ys Ident_map.empty in
          List.fold_right2
            (fun y l r -> Lam.let_ Alias y l r)
            ys ls 
            (Lam_util.subst_lambda  env  handler)
        | None -> Lam.staticraise i ls
      end
    | Lstaticcatch (l1,(i,xs),l2) ->
      begin 
        let i_occur = query i in 
        match i_occur , l2 with
        | 0,_ -> simplif l1

        | ( _ , Lvar _
          | _, Lconst _) ->  
          Int_hashtbl.add subst i (xs, Id (simplif l2)) ;
          simplif l1 (** l1 will inline *)
        | 1,_ when i >= 0 -> (** Ask: Note that we have predicate i >=0 *)
          Int_hashtbl.add subst i (xs, Id (simplif l2)) ;
          simplif l1 (** l1 will inline *)
        |  _ ->

          (** TODO: better heuristics, also if we can group same exit code [j] 
              in a very early stage -- maybe we can define our enhanced [Lambda] 
              representation and counter can be more precise, for example [apply] 
              does not need patch from the compiler

              FIXME:   when inlining, need refresh local bound identifiers
              #1438 when the action containes bounded variable 
                to keep the invariant, everytime, we do an inlining,
                we need refresh, just refreshing once is not enough
            *)
          let l2 = simplif l2 in 
          (** We need to decide whether inline or not based on post-simplification
            code, since when we do the substitution 
            we use the post-simplified expression, it is more consistent
          *)
          let ok_to_inline = 
            i >=0 && 
            (Lam.no_bounded_variables l2) &&
            (let lam_size = Lam_analysis.size l2 in
             (i_occur <= 2 && lam_size < Lam_analysis.exit_inline_size   )
             || lam_size < 5)
            (*TODO: when we do the case merging on the js side, 
              the j is not very indicative                
            *)             
          in 
          if ok_to_inline (* && false *)

          then 
            begin  
              (* we only inline when [l2] does not contain bound variables
                no need to refresh
               *)
              Int_hashtbl.add subst i (xs,  Id l2) ;
              simplif l1 
            end
          else Lam.staticcatch (simplif l1) (i,xs) l2
      end

    | Lvar _|Lconst _  -> lam
    | Lapply {fn = l1; args =  ll;  loc; status } -> 
      Lam.apply (simplif l1) (Ext_list.map simplif ll) loc status
    | Lfunction {arity; function_kind; params; body =  l} -> 
      Lam.function_ ~arity ~function_kind ~params ~body:(simplif l)
    | Llet (kind, v, l1, l2) -> 
      Lam.let_ kind v (simplif l1) (simplif l2)
    | Lletrec (bindings, body) ->
      Lam.letrec
        ( Ext_list.map (fun (v, l) -> (v, simplif l)) bindings) 
        (simplif body)
    | Lglobal_module _ -> lam 
    | Lprim {primitive; args; loc} -> 
      let args = Ext_list.map simplif args in
      Lam.prim ~primitive ~args loc
    | Lswitch(l, sw) ->
      let new_l = simplif l
      and new_consts =  Ext_list.map (fun (n, e) -> (n, simplif e)) sw.sw_consts
      and new_blocks =  Ext_list.map (fun (n, e) -> (n, simplif e)) sw.sw_blocks
      and new_fail = 
        begin match sw.sw_failaction with 
          | None   -> None
          | Some x -> Some (simplif x) end in
      Lam.switch
        new_l
        { 
          sw with 
          sw_consts = new_consts ;
          sw_blocks = new_blocks; 
          sw_failaction = new_fail}
    | Lstringswitch(l,sw,d) ->
      Lam.stringswitch
        (simplif l) (Ext_list.map (fun (s,l) -> s,simplif l) sw)
        (begin match d with None -> None | Some d -> Some (simplif d) end)
    | Ltrywith (l1, v, l2) -> 
      Lam.try_ (simplif l1) v (simplif l2)
    | Lifthenelse (l1, l2, l3) -> 
      Lam.if_ (simplif l1) (simplif l2) (simplif l3)
    | Lsequence (l1, l2) -> Lam.seq (simplif l1) (simplif l2)
    | Lwhile (l1, l2) -> Lam.while_ (simplif l1) (simplif l2)
    | Lfor (v, l1, l2, dir, l3) ->
      Lam.for_ v (simplif l1) (simplif l2) dir (simplif l3)
    | Lassign (v, l) -> 
      Lam.assign v (simplif l)
    | Lsend (k, m, o, ll, loc) ->
      Lam.send k (simplif m) (simplif o) (Ext_list.map simplif ll) loc
    | Lifused (v, l) -> 
      Lam.ifused v (simplif l)
  in 
  simplif lam 

let simplify_exits (lam : Lam.t) =
  let exits = count_helper lam in
  subst_helper (Int_hashtbl.create 17 ) (count_exit exits) lam

(* Compile-time beta-reduction of functions immediately applied:
      Lapply(Lfunction(Curried, params, body), args, loc) ->
        let paramN = argN in ... let param1 = arg1 in body
      Lapply(Lfunction(Tupled, params, body), [Lprim(Pmakeblock(args))], loc) ->
        let paramN = argN in ... let param1 = arg1 in body
   Assumes |args| = |params|.
*)

end
module Lam_pass_count : sig 
#1 "lam_pass_count.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)
(* Adapted for Javascript backend : Hongbo Zhang,  *)

type used_info = { 
  mutable times : int ; 
  mutable captured : bool;
    (* captured in functon or loop, 
       inline in such cases should be careful
       1. can not inline mutable values
       2. avoid re-computation 
    *)
}

type occ_tbl  = used_info Ident_hashtbl.t

val dummy_info : unit -> used_info
val collect_occurs : Lam.t -> occ_tbl

val pp_occ_tbl : Format.formatter -> occ_tbl -> unit   

end = struct
#1 "lam_pass_count.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)
(* Adapted for Javascript backend : Hongbo Zhang,  *)

(*A naive dead code elimination *)
type used_info = { 
  mutable times : int ; 
  mutable captured : bool;
  (* captured in functon or loop, 
     inline in such cases should be careful
     1. can not inline mutable values
     2. avoid re-computation 
  *)
}

type occ_tbl  = used_info Ident_hashtbl.t
(* First pass: count the occurrences of all let-bound identifiers *)

type local_tbl = used_info  Ident_map.t

let dummy_info () = {times =  0 ; captured = false }
(* y is untouched *)

let absorb_info (x : used_info) (y : used_info) = 
  match x, y with
  | {times = x0} , {times = y0; captured } -> 
    x.times <- x0 + y0;
    if captured then x.captured <- true

let pp_info fmt (x : used_info) = 
  Format.fprintf fmt "(<captured:%b>:%d)"  x.captured x.times

let pp_occ_tbl fmt tbl = 
  Ident_hashtbl.iter (fun k v -> 
      Format.fprintf fmt "@[%a@ %a@]@." Ident.print k pp_info v 
    ) tbl 
(* The global table [occ] associates to each let-bound identifier
   the number of its uses (as a reference):
   - 0 if never used
   - 1 if used exactly once in and not under a lambda or within a loop
       - when under a lambda, 
       - it's probably a closure
       - within a loop
       - update reference,
       niether is good for inlining
   - > 1 if used several times or under a lambda or within a loop.
   The local table [bv] associates to each locally-let-bound variable
   its reference count, as above.  [bv] is enriched at let bindings
   but emptied when crossing lambdas and loops. *)
let collect_occurs  lam : occ_tbl =
  let occ : occ_tbl = Ident_hashtbl.create 83 in

  (* Current use count of a variable. *)
  let used v = 
    match Ident_hashtbl.find_opt occ v with 
    | None -> false 
    | Some {times ; _} -> times > 0  in

  (* Entering a [let].  Returns updated [bv]. *)
  let bind_var bv ident =
    let r = dummy_info () in
    Ident_hashtbl.add occ ident r;
    Ident_map.add ident r bv in

  (* Record a use of a variable *)
  let add_one_use bv ident  =
    match Ident_map.find_opt ident bv with 
    | Some r  -> r.times <- r.times + 1 
    | None ->
      (* ident is not locally bound, therefore this is a use under a lambda
         or within a loop.  Increase use count by 2 -- enough so
         that single-use optimizations will not apply. *)
      match Ident_hashtbl.find_opt occ ident with 
      | Some r -> absorb_info r {times = 1; captured =  true}
      | None ->
        (* Not a let-bound variable, ignore *)
        () in

  let inherit_use bv ident bid =
    let n =
      match Ident_hashtbl.find_opt occ bid with
      | None -> dummy_info ()
      | Some v -> v in
    match Ident_map.find_opt ident bv with 
    | Some r  -> absorb_info r n
    | None ->
      (* ident is not locally bound, therefore this is a use under a lambda
         or within a loop.  Increase use count by 2 -- enough so
         that single-use optimizations will not apply. *)
      match Ident_hashtbl.find_opt occ ident with 
      | Some r -> absorb_info r {n with captured = true} 
      | None ->
        (* Not a let-bound variable, ignore *)
        () in

  let rec count (bv : local_tbl) (lam : Lam.t) = 
    match lam with 
    | Lfunction{body = l} ->
      count Ident_map.empty l
    (** when entering a function local [bv] 
        is cleaned up, so that all closure variables will not be
        carried over, since the parameters are never rebound, 
        so it is fine to kep it empty
    *)
    | Lfor(_, l1, l2, dir, l3) -> 
      count bv l1;
      count bv l2; 
      count Ident_map.empty l3
    | Lwhile(l1, l2) -> count Ident_map.empty l1; count Ident_map.empty l2
    | Lvar v ->
      add_one_use bv v 
    | Llet(_, v, Lvar w, l2)  ->
      (* v will be replaced by w in l2, so each occurrence of v in l2
         increases w's refcount *)
      count (bind_var bv v) l2;
      inherit_use bv w v 
    | Llet(kind, v, l1, l2) ->
      count (bind_var bv v) l2;
      (* count [l2] first,
         If v is unused, l1 will be removed, so don't count its variables *)
      if kind = Strict || used v then count bv l1
    | Lassign(_, l) ->
      (* Lalias-bound variables are never assigned, so don't increase
         this ident's refcount *)
      count bv l
    | Lglobal_module _ -> ()
    | Lprim {args; _} -> List.iter (count bv ) args
    | Lletrec(bindings, body) ->
      List.iter (fun (v, l) -> count bv l) bindings;
      count bv body
        (** Note there is a difference here when do beta reduction for *)
    | Lapply{fn = Lfunction{function_kind= Curried; params; body};  args; _}
      when  Ext_list.same_length params args ->
      count bv (Lam_beta_reduce.beta_reduce  params body args)
    (* | Lapply{fn = Lfunction{function_kind = Tupled; params; body}; *)
    (*          args = [Lprim {primitive = Pmakeblock _;  args; _}]; _} *)
    (*   when  Ext_list.same_length params  args -> *)
    (*   count bv (Lam_beta_reduce.beta_reduce   params body args) *)
    | Lapply{fn = l1; args= ll; _} ->
      count bv l1; List.iter (count bv) ll 
    | Lconst cst -> ()
    | Lswitch(l, sw) ->
      count_default bv sw ;
      count bv l;
      List.iter (fun (_, l) -> count bv l) sw.sw_consts;
      List.iter (fun (_, l) -> count bv l) sw.sw_blocks
    | Lstringswitch(l, sw, d) ->
      count bv l ;
      List.iter (fun (_, l) -> count bv l) sw ;
      begin match d with
        | Some d -> count bv d 
        | None -> ()
      end        
    (* x2 for native backend *)
    (* begin match sw with *)
    (* | []|[_] -> count bv d *)
    (* | _ -> count bv d ; count bv d *)
    (* end *)      
    | Lstaticraise (i,ls) -> List.iter (count bv) ls
    | Lstaticcatch(l1, (i,_), l2) -> count bv l1; count bv l2
    | Ltrywith(l1, v, l2) -> count bv l1; count bv l2
    | Lifthenelse(l1, l2, l3) -> count bv l1; count bv l2; count bv l3
    | Lsequence(l1, l2) -> count bv l1; count bv l2 
    | Lsend(_, m, o, ll, _) -> 
      count bv m ;
      count bv o;
      List.iter (count bv) ll
    | Lifused(v, l) ->
      if used v then count bv l
  and count_default bv sw = 
    match sw.sw_failaction with
    | None -> ()
    | Some al ->
      let nconsts = List.length sw.sw_consts
      and nblocks = List.length sw.sw_blocks in
      if nconsts < sw.sw_numconsts && nblocks < sw.sw_numblocks
      then 
        begin (* default action will occur twice in native code *)
          count bv al ; count bv al
        end 
      else 
        begin (* default action will occur once *)
          assert (nconsts < sw.sw_numconsts || nblocks < sw.sw_numblocks) ;
          count bv al
        end
  in
  count Ident_map.empty  lam;
  occ


end
module Lam_pass_eliminate_ref : sig 
#1 "lam_pass_eliminate_ref.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


exception Real_reference 

val eliminate_ref : 
    Ident.t -> 
    Lam.t -> 
    Lam.t








end = struct
#1 "lam_pass_eliminate_ref.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)
(* Adapted for Javascript backend : Hongbo Zhang,  *)




exception Real_reference

let rec eliminate_ref id (lam : Lam.t) = 
  match lam with  (** we can do better escape analysis in Javascript backend *)
  | Lvar v ->
    if Ident.same v id then raise_notrace Real_reference else lam
  | Lprim {primitive = Pfield (0,_); args =  [Lvar v]} when Ident.same v id ->
    Lam.var id
  | Lfunction{ function_kind; params; body} as lam ->
    if Ident_set.mem id (Lam.free_variables  lam)
    then raise_notrace Real_reference
    else lam
  (* In Javascript backend, its okay, we can reify it later
     a failed case 
     {[
       for i = .. 
           let v = ref 0 
               for j = .. 
                   incr v 
                     a[j] = ()=>{!v}

     ]}
     here v is captured by a block, and it's a loop mutable value,
     we have to generate 
     {[
       for i = .. 
           let v = ref 0 
               (function (v){for j = .. 
                                   a[j] = ()=>{!v}}(v)

     ]}
     now, v is a real reference 
     TODO: we can refine analysis in later
  *)
  (* Lfunction(kind, params, eliminate_ref id body) *)
  | Lprim {primitive = Psetfield(0, _,_); 
           args =  [Lvar v; e]} when Ident.same v id ->
    Lam.assign id (eliminate_ref id e)
  | Lprim {primitive = Poffsetref delta ; 
           args =  [Lvar v]; loc } when Ident.same v id ->
    Lam.assign id (Lam.prim ~primitive:(Poffsetint delta) ~args:[Lam.var id] loc)
  | Lconst _  -> lam
  | Lapply{fn = e1; args =  el;  loc; status} ->
    Lam.apply 
      (eliminate_ref id e1)
      (Ext_list.map (eliminate_ref id) el)
      loc status
  | Llet(str, v, e1, e2) ->
    Lam.let_ str v (eliminate_ref id e1) (eliminate_ref id e2)
  | Lletrec(idel, e2) ->
    Lam.letrec
      (Ext_list.map (fun (v, e) -> (v, eliminate_ref id e)) idel)
      (eliminate_ref id e2)
  | Lam.Lglobal_module _ -> lam     
  | Lprim {primitive ; args ; loc} ->
    Lam.prim  ~primitive ~args:(Ext_list.map (eliminate_ref id) args) loc
  | Lswitch(e, sw) ->
    Lam.switch(eliminate_ref id e)
      {sw_numconsts = sw.sw_numconsts;
       sw_consts =
         Ext_list.map (fun (n, e) -> (n, eliminate_ref id e)) sw.sw_consts;
       sw_numblocks = sw.sw_numblocks;
       sw_blocks =
         Ext_list.map (fun (n, e) -> (n, eliminate_ref id e)) sw.sw_blocks;
       sw_failaction =
         match sw.sw_failaction with 
         | None -> None 
         | Some x -> Some (eliminate_ref id x)
          }
  | Lstringswitch(e, sw, default) ->
    Lam.stringswitch
      (eliminate_ref id e)
      (Ext_list.map (fun (s, e) -> (s, eliminate_ref id e)) sw)
      (match default with 
      | None -> None 
      | Some x ->  Some (eliminate_ref id x))
  | Lstaticraise (i,args) ->
    Lam.staticraise i (Ext_list.map (eliminate_ref id) args)
  | Lstaticcatch(e1, i, e2) ->
    Lam.staticcatch (eliminate_ref id e1) i (eliminate_ref id e2)
  | Ltrywith(e1, v, e2) ->
    Lam.try_ (eliminate_ref id e1) v (eliminate_ref id e2)
  | Lifthenelse(e1, e2, e3) ->
    Lam.if_ (eliminate_ref id e1) (eliminate_ref id e2) (eliminate_ref id e3)
  | Lsequence(e1, e2) ->
    Lam.seq (eliminate_ref id e1) (eliminate_ref id e2)
  | Lwhile(e1, e2) ->
    Lam.while_ (eliminate_ref id e1) (eliminate_ref id e2)
  | Lfor(v, e1, e2, dir, e3) ->
    Lam.for_ v
      (eliminate_ref id e1) 
      (eliminate_ref id e2)
      dir
      (eliminate_ref id e3)
  | Lassign(v, e) ->
    Lam.assign v (eliminate_ref id e)
  | Lsend(k, m, o, el, loc) ->
    Lam.send k 
      (eliminate_ref id m) (eliminate_ref id o)
      (Ext_list.map (eliminate_ref id) el) loc
  | Lifused(v, e) ->
    Lam.ifused v (eliminate_ref id e)



end
module Lam_pass_lets_dce : sig 
#1 "lam_pass_lets_dce.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)
(* Adapted for Javascript backend: Hongbo Zhang                        *)

(**
   This pass would do beta reduction, and dead code elimination (adapted from compiler's built-in [Simplif] module )

   1. beta reduction -> Llet (Strict )
  
   2. The global table [occ] associates to each let-bound identifier
   the number of its uses (as a reference):
     - 0 if never used
     - 1 if used exactly once in and *not under a lambda or within a loop
     - > 1 if used several times or under a lambda or within a loop.

   The local table [bv] associates to each locally-let-bound variable
   its reference count, as above.  [bv] is enriched at let bindings
   but emptied when crossing lambdas and loops. 

   For this pass, when it' used under a lambda or within a loop, we don't do anything,
   in theory, we can still do something if it's pure but we are conservative here.

   [bv] is used to help caculate [occ] it is not useful outside

 *)
val simplify_lets :  Lam.t -> Lam.t

end = struct
#1 "lam_pass_lets_dce.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)
(* Adapted for Javascript backend : Hongbo Zhang,  *)


let lets_helper (count_var : Ident.t -> Lam_pass_count.used_info) lam = 
  let subst : Lam.t Ident_hashtbl.t = Ident_hashtbl.create 32 in
  let string_table : string Ident_hashtbl.t = Ident_hashtbl.create 32 in  
  let used v = (count_var v ).times > 0 in
  let rec simplif (lam : Lam.t) = 
    match lam with 
    | Lvar v  -> Ident_hashtbl.find_default subst v lam 
    | Llet( (Strict | Alias | StrictOpt) , v, Lvar w, l2) 
      ->
      Ident_hashtbl.add subst v (simplif (Lam.var w));
      simplif l2
    | Llet(Strict as kind,
           v, (Lprim {primitive = (Pmakeblock(0, tag_info, Mutable) 
                                   as primitive); 
                      args = [linit] ; loc}), lbody)
      ->
      let slinit = simplif linit in
      let slbody = simplif lbody in
      begin 
        try (** TODO: record all references variables *)
          Lam_util.refine_let
            ~kind:Variable v slinit
             (Lam_pass_eliminate_ref.eliminate_ref v slbody)
        with Lam_pass_eliminate_ref.Real_reference ->
          Lam_util.refine_let 
            ~kind v (Lam.prim ~primitive ~args:[slinit] loc)
            slbody
      end
    | Llet(Alias, v, l1, l2) ->
      (** For alias, [l1] is pure, we can always inline,
          when captured, we should avoid recomputation
      *)
      begin 
        match count_var v, l1  with
        | {times = 0; _}, _  -> simplif l2 
        | {times = 1; captured = false }, _ 
        | {times = 1; captured = true }, (Lconst _ | Lvar _)
        |  _, (Lconst 
                 ((
                     Const_int _ | Const_char _ | Const_float _ | Const_int32 _ 
                     | Const_nativeint _ )
                 | Const_pointer _ ) (* could be poly-variant [`A] -> [65a]*)
              | Lprim {primitive = Pfield (_);
                       args = [ 
                         Lglobal_module _
                       ]}
              ) 
          (* Const_int64 is no longer primitive
             Note for some constant which is not 
             inlined, we can still record it and
             do constant folding independently              
          *)
          ->
          Ident_hashtbl.add subst v (simplif l1); simplif l2
        | _, Lconst (Const_string s ) -> 
          (** only "" added for later inlining *)
          Ident_hashtbl.add string_table v s;
          Lam.let_ Alias v l1 (simplif l2)
          (* we need move [simplif l2] later, since adding Hashtbl does have side effect *)
        | _ -> Lam.let_ Alias v (simplif l1) (simplif l2)
        (* for Alias, in most cases [l1] is already simplified *)
      end
    | Llet(StrictOpt as kind, v, l1, lbody) ->
      (** can not be inlined since [l1] depend on the store
          {[
            let v = [|1;2;3|]
          ]}
          get [StrictOpt] here,  we can not inline v, 
          since the value of [v] can be changed
          
          GPR #1476 
          Note to pass the sanitizer, we do need remove dead code (not just best effort)
          This logic is tied to {!Lam_pass_count.count}
          {[
            if kind = Strict || used v then count bv l1
          ]}
          If the code which should be removed is not removed, it will hold references 
          to other variables which is already removed.
      *)
      if not @@ used v 
      then simplif lbody (* GPR #1476 *)
      else
        begin match l1 with 
        | (Lprim {primitive = (Pmakeblock(0, tag_info, Mutable) 
                                    as primitive); 
                       args = [linit] ; loc})
          -> 
          let slinit = simplif linit in
          let slbody = simplif lbody in
          begin 
            try (** TODO: record all references variables *)
              Lam_util.refine_let
                ~kind:Variable v slinit
                (Lam_pass_eliminate_ref.eliminate_ref v slbody)
            with Lam_pass_eliminate_ref.Real_reference ->
              Lam_util.refine_let 
                ~kind v (Lam.prim ~primitive ~args:[slinit] loc)
                slbody
          end

        | _ -> 
          let l1 = simplif l1 in         
          begin match l1 with 
            | Lconst(Const_string s) -> 
              Ident_hashtbl.add string_table v s; 
              (* we need move [simplif lbody] later, since adding Hashtbl does have side effect *)
              Lam.let_ Alias v l1 (simplif lbody)
            | _ -> 
              Lam_util.refine_let ~kind v l1 (simplif lbody)
          end  
        end
    (* TODO: check if it is correct rollback to [StrictOpt]? *)

    | Llet((Strict | Variable as kind), v, l1, l2) -> 
      if not @@ used v 
      then
        let l1 = simplif l1 in
        let l2 = simplif l2 in
        if Lam_analysis.no_side_effects l1 
        then l2 
        else Lam.seq l1 l2
      else 
        let l1 = (simplif l1) in 
        
         begin match kind, l1 with 
         | Strict, Lconst((Const_string s))
           -> 
            Ident_hashtbl.add string_table v s;
            Lam.let_ Alias v l1 (simplif l2)
         | _ -> 
           Lam_util.refine_let ~kind v l1 (simplif l2)
        end
    | Lifused(v, l) ->
      if used  v then
        simplif l
      else Lam.unit
    | Lsequence(Lifused(v, l1), l2) ->
      if used v 
      then Lam.seq (simplif l1) (simplif l2)
      else simplif l2
    | Lsequence(l1, l2) -> Lam.seq (simplif l1) (simplif l2)

    | Lapply{fn = Lfunction{function_kind =  Curried; params; body};  args; _}
      when  Ext_list.same_length params args ->
      simplif (Lam_beta_reduce.beta_reduce  params body args)
    (* | Lapply{ fn = Lfunction{function_kind = Tupled; params; body}; *)
    (*           args = [Lprim {primitive = Pmakeblock _;  args; _}]; _} *)
    (*   (\** TODO: keep track of this parameter in ocaml trunk, *)
    (*       can we switch to the tupled backend? *)
    (*   *\) *)
    (*   when  Ext_list.same_length params  args -> *)
    (*   simplif (Lam_beta_reduce.beta_reduce params body args) *)

    | Lapply{fn = l1;args =  ll; loc; status} -> 
      Lam.apply (simplif l1) (Ext_list.map simplif ll) loc status
    | Lfunction{arity; function_kind; params; body = l} ->
      Lam.function_ ~arity ~function_kind ~params ~body:(simplif l)
    | Lconst _ -> lam
    | Lletrec(bindings, body) ->
      Lam.letrec 
        (Ext_list.map (fun (v, l) -> (v, simplif l)) bindings) 
        (simplif body)
    | Lprim {primitive=Pstringadd; args = [l;r]; loc } -> 
      begin
        let l' = simplif l in 
        let r' = simplif r in
        let opt_l = 
          match l' with 
          | Lconst((Const_string ls)) -> Some ls 
          | Lvar i -> Ident_hashtbl.find_opt string_table i 
          | _ -> None in 
        match opt_l with   
        | None -> Lam.prim ~primitive:Pstringadd ~args:[l';r'] loc 
        | Some l_s -> 
          let opt_r = 
            match r' with 
            | Lconst ( (Const_string rs)) -> Some rs 
            | Lvar i -> Ident_hashtbl.find_opt string_table i 
            | _ -> None in 
            begin match opt_r with 
            | None -> Lam.prim ~primitive:Pstringadd ~args:[l';r'] loc 
            | Some r_s -> 
              Lam.const (Const_string(l_s^r_s))
            end
      end

    | Lprim {primitive = (Pstringrefu|Pstringrefs) as primitive ; 
      args = [l;r] ; loc 
      } ->  (* TODO: introudce new constant *)
      let l' = simplif l in 
      let r' = simplif r in 
      let opt_l =
         match l' with 
         | Lconst (Const_string ls) -> 
            Some ls 
         | Lvar i -> Ident_hashtbl.find_opt string_table i 
         | _ -> None in 
      begin match opt_l with 
      | None -> Lam.prim ~primitive ~args:[l';r'] loc 
      | Some l_s -> 
        match r with 
        |Lconst((Const_int i)) -> 
          if i < String.length l_s && i >=0  then
            Lam.const ((Const_char l_s.[i]))
          else 
            Lam.prim ~primitive ~args:[l';r'] loc 
        | _ -> 
          Lam.prim ~primitive ~args:[l';r'] loc 
      end    
    | Lglobal_module _ -> lam    
    | Lprim {primitive; args; loc} 
      -> Lam.prim ~primitive ~args:(Ext_list.map simplif args) loc
    | Lswitch(l, sw) ->
      let new_l = simplif l
      and new_consts =  Ext_list.map (fun (n, e) -> (n, simplif e)) sw.sw_consts
      and new_blocks =  Ext_list.map (fun (n, e) -> (n, simplif e)) sw.sw_blocks
      and new_fail = 
        match sw.sw_failaction with 
        | None -> None 
        | Some x -> Some (simplif x)
      in
      Lam.switch
        new_l
        {sw with sw_consts = new_consts ; sw_blocks = new_blocks;
                 sw_failaction = new_fail}
    | Lstringswitch (l,sw,d) ->
      Lam.stringswitch
        (simplif l) (Ext_list.map (fun (s,l) -> s,simplif l) sw)
        (match d with None -> None | Some d -> Some (simplif d))
    | Lstaticraise (i,ls) ->
      Lam.staticraise i (Ext_list.map simplif ls)
    | Lstaticcatch(l1, (i,args), l2) ->
      Lam.staticcatch (simplif l1) (i,args) (simplif l2)
    | Ltrywith(l1, v, l2) -> Lam.try_ (simplif l1) v (simplif l2)
    | Lifthenelse(l1, l2, l3) -> 
      Lam.if_ (simplif l1) (simplif l2) (simplif l3)
    | Lwhile(l1, l2) 
      -> 
      Lam.while_ (simplif l1) (simplif l2)
    | Lfor(v, l1, l2, dir, l3) ->
      Lam.for_ v (simplif l1) (simplif l2) dir (simplif l3)
    | Lassign(v, l) -> Lam.assign v (simplif l)
    | Lsend(k, m, o, ll, loc) ->
      Lam.send k (simplif m) (simplif o) (Ext_list.map simplif ll) loc
  in simplif lam ;;


(* To transform let-bound references into variables *)
let apply_lets  occ lambda = 
  let count_var v =
    match
      Ident_hashtbl.find_opt occ v 
    with
    | None -> Lam_pass_count.dummy_info ()
    | Some  v -> v in
  lets_helper count_var lambda      

let simplify_lets  (lam : Lam.t) = 
  let occ =  Lam_pass_count.collect_occurs  lam in 

  apply_lets  occ   lam

end
module Lam_inline_util : sig 
#1 "lam_inline_util.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Utilities for lambda inlining *)

val maybe_functor : string -> bool

val should_be_functor : string -> Lam.t -> bool 

end = struct
#1 "lam_inline_util.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)







(* TODO: add a context, like 
    [args]
    [Lfunction(params,body)]
 *)


let maybe_functor (name : string) = 
  name.[0] >= 'A' && name.[0] <= 'Z'


let should_be_functor (name : string) (lam : Lam.t) = 
  maybe_functor name  &&
  (match lam with Lfunction _ -> true | _ -> false)



end
module Lam_pass_remove_alias : sig 
#1 "lam_pass_remove_alias.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Keep track of the global module Aliases *) 

(**
    One way:  guarantee that all global aliases *would be removed* ,
    it will not be aliased 
    
    So the only remaining place for globals is either 
    just  Pgetglobal in functor application or 
    `Lprim (Pfield( i ), [Pgetglobal])`

    This pass does not change meta  data
*)

val simplify_alias : 
  Lam_stats.t -> 
  Lam.t ->
  Lam.t



end = struct
#1 "lam_pass_remove_alias.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








let simplify_alias 
    (meta : Lam_stats.t)
    (lam : Lam.t) 
  :  Lam.t  = 

  let rec simpl  (lam : Lam.t) : Lam.t = 
    match lam with 
    | Lvar v ->
      begin match (Ident_hashtbl.find_opt meta.alias_tbl v) with
      | None -> lam
      | Some v ->
        if Ident.persistent v then 
          Lam.global_module v 
        else 
         Lam.var v 
        (* This is wrong
            currently alias table has info 
            include -> Array

            however, (field id Array/xx) 
            does not result in a reduction, so we 
            still pick the old one (field id include)
            which makes dead code elimination wrong
         *)
      end
      (* GLOBAL module needs to be propogated *)
    | Llet (kind, k, (Lglobal_module i as g), l )
           -> 
      (* This is detection of global MODULE inclusion
          we need track all global module aliases, when it's
          passed as a parameter(escaped), we need do the expansion
          since global module access is not the same as local module
          TODO: 
          since we aliased k, so it's safe to remove it?
          no, we should not shake away code just by [Ident_set.mem k meta.export_idents ]
          in that case, we should provide strong guarantee that all [k] will be substitued
      *)
      let v = simpl l in
      Lam.let_ kind k g v
        (* in this case it is preserved, but will still be simplified 
            for the inner expression
        *)
      
    | Lprim {primitive = (Pfield (i,_) as primitive); args =  [arg]; loc} -> 
      (* ATTENTION: 
         Main use case, we should detect inline all immutable block .. *)
      begin match  simpl  arg with 
      | Lglobal_module g 
      ->    
        Lam.prim 
          ~primitive:(Pfield(i,Lambda.Fld_na))
          ~args:[Lam.global_module g ]
          loc
      | Lvar v as l-> 
        Lam_util.field_flatten_get (fun _ -> Lam.prim ~primitive ~args:[l] loc )
         v  i meta.ident_tbl 
      | _ ->  
        Lam.prim ~primitive ~args:[simpl arg] loc 
      end
    | Lglobal_module _ -> lam 
    | Lprim {primitive; args; loc } 
      -> Lam.prim ~primitive ~args:(Ext_list.map simpl  args) loc
      
    | Lifthenelse(Lvar id as l1, l2, l3) 
      -> 
      begin match Ident_hashtbl.find_opt meta.ident_tbl id with 
      | Some (ImmutableBlock ( _, Normal))
      | Some (MutableBlock _  )
        -> simpl l2 
      | Some (ImmutableBlock ( [| SimpleForm l |]  , x) )
        -> 
        let l1 = 
          match x with 
          | Null 
            -> Lam.not_ (Location.none) ( Lam.prim ~primitive:Pis_null

            ~args:[l] Location.none) 
          | Undefined 
            -> 
            Lam.not_  Location.none (Lam.prim ~primitive:Pis_undefined ~args:[l] Location.none)
          | Null_undefined
            -> 
            Lam.not_ Location.none
              ( Lam.prim ~primitive:Pis_null_undefined  ~args:[l] Location.none) 
          | Normal ->  l1 
        in 
        Lam.if_ l1 (simpl l2) (simpl l3)
      | Some _
      | None -> Lam.if_ l1 (simpl l2) (simpl l3)
      end
    | Lifthenelse (l1, l2, l3) -> 
        Lam.if_ (simpl  l1) (simpl  l2) (simpl  l3)

    | Lconst _ -> lam
    | Llet(str, v, l1, l2) ->
      Lam.let_ str v (simpl l1) (simpl l2 )
    | Lletrec(bindings, body) ->
      let bindings = Ext_list.map (fun (k,l) ->  (k, simpl l) ) bindings in 
      Lam.letrec bindings (simpl body) 
 
    (* complicated 
        1. inline this function
        2. ...
        exports.Make=
        function(funarg)
      {var $$let=Make(funarg);
        return [0, $$let[5],... $$let[16]]}
    *)      
    | Lapply{fn = 
               Lprim {primitive = Pfield (index, _) ;
                      args = [ Lglobal_module ident ];
                      _} as l1;
             args; loc ; status} ->
      begin
        Lam_compile_env.find_and_add_if_not_exist (ident,index) meta.env
          ~not_found:(fun _ -> assert false)
          ~found:(fun i ->
              match i with
              | {closed_lambda=Some Lfunction{params; body; _} } 
                (** be more cautious when do cross module inlining *)
                when
                  ( Ext_list.same_length params args &&
                    List.for_all (fun (arg : Lam.t) ->
                        match arg with 
                        | Lvar p -> 
                          begin 
                            match Ident_hashtbl.find_opt meta.ident_tbl p with
                            | Some v  -> v <> Parameter
                            | None -> true 
                          end
                        |  _ -> true 
                      ) args) -> 
                simpl @@
                Lam_beta_reduce.propogate_beta_reduce
                  meta params body args
              | _ -> 
                Lam.apply (simpl l1) (Ext_list.map simpl args) loc status
            )

      end
    (* Function inlining interact with other optimizations...

        - parameter attributes
        - scope issues 
        - code bloat 
    *)      
    | Lapply{fn = (Lvar v as fn);  args; loc ; status} ->
      (* Check info for always inlining *)

      (* Ext_log.dwarn __LOC__ "%s/%d" v.name v.stamp;     *)
      let normal () = Lam.apply ( simpl fn) (Ext_list.map simpl args) loc status in
      begin 
        match Ident_hashtbl.find_opt meta.ident_tbl v with
        | Some (FunctionId {lambda = Lfunction {params; body} as _m;
                    rec_flag;                     
                    _ })
          -> 
        
          if Ext_list.same_length args params (* && false *)
          then               
            if Lam_inline_util.maybe_functor v.name  
              (* && (Ident_set.mem v meta.export_idents) && false *)
            then 
              (* TODO: check l1 if it is exported, 
                 if so, maybe not since in that case, 
                 we are going to have two copy?
              *)

              (* Check: recursive applying may result in non-termination *)
              begin
                (* Ext_log.dwarn __LOC__ "beta .. %s/%d" v.name v.stamp ; *)
                simpl (Lam_beta_reduce.propogate_beta_reduce meta params body args) 
              end
            else 
            if (* Lam_analysis.size body < Lam_analysis.small_inline_size *)
              Lam_analysis.ok_to_inline_fun_when_app ~body params args 
            then 

                (* let param_map =  *)
                (*   Lam_analysis.free_variables meta.export_idents  *)
                (*     (Lam_analysis.param_map_of_list params) body in *)
                (* let old_count = List.length params in *)
                (* let new_count = Ident_map.cardinal param_map in *)
                let param_map = 
                  Lam_closure.is_closed_with_map 
                    meta.export_idents params body in
                let is_export_id = Ident_set.mem v meta.export_idents in
                match is_export_id, param_map with 
                | false, (_, param_map)
                | true, (true, param_map) -> 
                  if rec_flag = Rec then               
                    begin
                      (* Ext_log.dwarn __LOC__ "beta rec.. %s/%d" v.name v.stamp ; *)
                      (* Lam_beta_reduce.propogate_beta_reduce meta params body args *)
                      Lam_beta_reduce.propogate_beta_reduce_with_map meta param_map params body args
                    end
                  else 
                    begin
                      (* Ext_log.dwarn __LOC__ "beta  nonrec..[%d] [%a]  %s/%d"  *)
                      (*   (List.length args)  *)
                      (*   Printlambda.lambda body                      *)
                      (*   v.name v.stamp ; *)
                      simpl (Lam_beta_reduce.propogate_beta_reduce_with_map meta param_map params body args)

                    end
                | _ -> normal ()
              else 
                normal ()
          else
            normal ()
        | Some _
        | None -> normal ()

      end

    | Lapply{ fn = Lfunction{ function_kind = Curried ; params; body}; args; _}
      when  Ext_list.same_length params args ->
      simpl (Lam_beta_reduce.propogate_beta_reduce meta params body args)
    (* | Lapply{ fn = Lfunction{function_kind =  Tupled;  params; body};  *)
    (*          args = [Lprim {primitive = Pmakeblock _; args; _}]; _} *)
    (*   (\** TODO: keep track of this parameter in ocaml trunk, *)
    (*       can we switch to the tupled backend? *)
    (*   *\) *)
    (*   when  Ext_list.same_length params args -> *)
    (*   simpl (Lam_beta_reduce.propogate_beta_reduce meta params body args) *)

    | Lapply {fn = l1; args =  ll;  loc ; status} ->
      Lam.apply (simpl  l1) (Ext_list.map simpl  ll) loc status
    | Lfunction {arity; function_kind; params; body = l}
      -> Lam.function_ ~arity ~function_kind ~params  ~body:(simpl  l)
    | Lswitch (l, {sw_failaction; 
                   sw_consts; 
                   sw_blocks;
                   sw_numblocks;
                   sw_numconsts;
                  }) ->
      Lam.switch (simpl  l)
               {sw_consts = 
                  Ext_list.map (fun (v, l) -> v, simpl  l) sw_consts;
                sw_blocks = Ext_list.map (fun (v, l) -> v, simpl  l) sw_blocks;
                sw_numconsts = sw_numconsts;
                sw_numblocks = sw_numblocks;
                sw_failaction = 
                  begin 
                    match sw_failaction with 
                    | None -> None
                    | Some x -> Some (simpl x)
                  end}
    | Lstringswitch(l, sw, d) ->
      Lam.stringswitch (simpl  l )
                    (Ext_list.map (fun (i, l) -> i,simpl  l) sw)
                    (match d with
                     | Some d -> Some (simpl d )
                     | None -> None)
    | Lstaticraise (i,ls) -> 
      Lam.staticraise i (Ext_list.map simpl  ls)
    | Lstaticcatch (l1, ids, l2) -> 
      Lam.staticcatch (simpl  l1) ids (simpl  l2)
    | Ltrywith (l1, v, l2) -> Lam.try_ (simpl  l1) v (simpl  l2)
    | Lsequence(l1, l2)
      -> Lam.seq (simpl  l1) (simpl  l2)
    | Lwhile(l1, l2)
      -> Lam.while_ (simpl  l1) (simpl l2)
    | Lfor(flag, l1, l2, dir, l3)
      -> 
      Lam.for_ flag (simpl  l1) (simpl  l2) dir (simpl  l3)
    | Lassign(v, l) ->
      (* Lalias-bound variables are never assigned, so don't increase
         v's refsimpl *)
      Lam.assign v (simpl  l)
    | Lsend (u, m, o, ll, v) 
      -> 
      Lam.send u (simpl m) (simpl o) (Ext_list.map simpl ll) v
    | Lifused (v, l) -> Lam.ifused v (simpl  l)
  in 
  simpl lam



end
module Ext_option : sig 
#1 "ext_option.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** Utilities for [option] type *)

val bind : 'a option -> ('a -> 'b) -> 'b option

end = struct
#1 "ext_option.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








let bind v f = 
  match v with 
  | None -> None
  | Some x -> Some (f x )

end
module Lam_stats_export : sig 
#1 "lam_stats_export.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






val export_to_cmj : 
  Lam_stats.t ->
  Js_cmj_format.effect ->
  Lam_module_ident.t list ->
  Lam.t Ident_map.t ->
  bool ->
  Js_cmj_format.t


end = struct
#1 "lam_stats_export.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






let pp = Format.fprintf 
(* we should exclude meaninglist names and do the convert as well *)

(* let meaningless_names  = ["*opt*"; "param";] *)

let rec dump_ident fmt (id : Ident.t) (arity : Lam_arity.t)  = 
  pp fmt  "@[<2>export var %s:@ %a@ ;@]" (Ext_ident.convert id.name ) dump_arity arity

and dump_arity fmt (arity : Lam_arity.t) = 
  match arity with 
  | NA -> pp fmt "any"
  | Determin (_, [], _) -> pp fmt "any"
  | Determin (_, (n,args)::xs, _) -> 
    let args = match args with 
      | Some args -> args 
      | None -> Ext_list.init n (fun _ -> Ident.create "param") in
    pp fmt "@[(%a)@ =>@ any@]" 
      (Format.pp_print_list  
         ~pp_sep:(fun fmt _ -> 
             Format.pp_print_string fmt ",";
             Format.pp_print_space fmt ();
           )
         (fun fmt ident -> pp fmt "@[%s@ :@ any@]" 
             (Ext_ident.convert  @@ Ident.name ident))
      ) args 

let single_na = Js_cmj_format.single_na

let values_of_export 
  (meta : Lam_stats.t) 
  (export_map  : Lam.t Ident_map.t)
  = 
  List.fold_left
    (fun   acc (x : Ident.t)  ->

       let arity : Js_cmj_format.arity =
         match Ident_hashtbl.find_opt meta.ident_tbl x with 
         | Some (FunctionId {arity ; _}) -> Single arity 
         | Some (ImmutableBlock(elems,_)) ->  
           Submodule(elems |> Array.map (fun (x : Lam_id_kind.element) -> 
               match x with 
               | NA -> Lam_arity.NA
               | SimpleForm lam -> Lam_stats_util.get_arity  meta lam)
             )
         | Some _ 
         | None ->
          begin match Ident_map.find_opt x export_map with 
          | Some (Lprim {primitive = Pmakeblock (_,_, Immutable); args }) ->
            Submodule (args |> Ext_array.of_list_map (fun lam -> 
            Lam_stats_util.get_arity meta lam
            ))
          | Some _
          | None -> single_na
          end
         
         (*Single (Lam_stats_util.arity_of_var meta x) *)
       in
       let closed_lambda = 
         match Ident_map.find_opt x export_map with 
         | Some lambda  -> 
           if Lam_analysis.safe_to_inline lambda
           (* when inlning a non function, we have to be very careful,
              only truly immutable values can be inlined
           *)
           then
             if Lam_inline_util.should_be_functor x.name lambda (* can also be submodule *)
             then
               if Lam_closure.is_closed lambda (* TODO: seriealize more*)
               then Some lambda
               else None
             else 
               let lam_size = Lam_analysis.size lambda in
               (* TODO:
                  1. global need re-assocate when do the beta reduction 
                  2. [lambda_exports] is not precise
               *)
               let free_variables =
                 Lam_closure.free_variables Ident_set.empty Ident_map.empty lambda in
               if  lam_size < Lam_analysis.small_inline_size  && 
                   Ident_map.is_empty free_variables
               then 
                 begin
                   Ext_log.dwarn __LOC__ "%s recorded for inlining @." x.name ;
                   Some lambda
                 end
               else None
           else
             None
         | None
           -> None  in 
       String_map.add x.name  Js_cmj_format.({arity ; closed_lambda }) acc          
    )
    String_map.empty
    meta.exports 

let get_effect (meta : Lam_stats.t) maybe_pure external_ids = 
  match maybe_pure with
  | None ->  
    Ext_option.bind ( Ext_list.for_all_ret 
                        (fun (id : Lam_module_ident.t) -> 
                           Lam_compile_env.query_and_add_if_not_exist id 
                             (Has_env meta.env )
                             ~not_found:(fun _ -> false ) ~found:(fun i -> 
                                 i.pure)
                        ) external_ids) (fun x -> Lam_module_ident.name x)
  | Some _ -> maybe_pure

let rec dump meta fmt ids = 
  (* TODO: also use {[Ext_pp]} module instead *)
  match ids with 
  | [] -> ()
  | x::xs -> 
    dump_ident fmt x (Lam_stats_util.get_arity meta (Lam.var x)) ; 
    Format.pp_print_space fmt ();
    dump meta fmt xs

(* Note that 
   [lambda_exports] is 
   lambda expression to be exported
   for the js backend, we compile to js 
   for the inliner, we try to seriaize it -- 
   relies on other optimizations to make this happen
   {[
     exports.Make = function () {.....}
   ]}
   TODO: check that we don't do this in browser environment
*)
let export_to_cmj 
    (meta : Lam_stats.t ) 
    maybe_pure
    external_ids 
    export_map
    case
  : Js_cmj_format.t = 
  let values =  values_of_export meta export_map in
  let () =
    if !Js_config.default_gen_tds && not ( Ext_string.is_empty meta.filename) then
      Ext_pervasives.with_file_as_pp
        (Ext_path.chop_extension ~loc:__LOC__ meta.filename ^ ".d.ts")
      @@ fun fmt ->
      pp fmt "@[<v>%a@]@." (dump meta) meta.exports in
  let effect = get_effect meta maybe_pure external_ids in
  {values; 
   effect ; 
   npm_package_path = Js_packages_state.get_packages_info ();
   case ;
    (* FIXME: make sure [-o] would not change its case 
      add test for ns/non-ns
    *)
  }


end
module Lam_compile_main : sig 
#1 "lam_compile_main.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** BuckleScript entry point in the OCaml compiler *) 

(** Compile and register the hook of function to compile  a lambda to JS IR 
 *)

(** For toplevel, [filename] is [""] which is the same as
    {!Env.get_unit_name ()}
 *)
val compile :  
  filename : string -> 
  string -> 
  Env.t -> 
  Types.signature -> 
  Lambda.lambda -> 
  J.deps_program

val lambda_as_module :  
  Env.t ->
  Types.signature -> string -> 
  string  -> Lambda.lambda -> unit

end = struct
#1 "lam_compile_main.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








module E = Js_exp_make 
module S = Js_stmt_make  

 open Js_output.Ops 

let compile_group ({filename = file_name; env;} as meta : Lam_stats.t) 
    (x : Lam_group.t) : Js_output.t  = 
  match x, file_name with 
  (* 
        We need

        2. [E.builtin_dot] for javascript builtin
        3. [E.mldot]
     *)
  (* ATTENTION: check {!Lam_compile_global} for consistency  *)      
  (** Special handling for values in [Pervasives] *)
  | Single(_, ({name="stdout"|"stderr"|"stdin";_} as id),_ ),
    "pervasives.ml" -> 
    Js_output.of_stmt @@ S.alias_variable id
      ~exp:(E.runtime_ref  Js_runtime_modules.io id.name)
  (* 
         we delegate [stdout, stderr, and stdin] into [caml_io] module, 
         the motivation is to help dead code eliminatiion, it's helpful 
         to make those parts pure (not a function call), then it can be removed 
         if unused 
      *)                     
  | Single(_, ({name="infinity";_} as id),_ ),  "pervasives.ml" 
    -> (* TODO: check relative path to compiler*)
    Js_output.of_stmt @@ S.alias_variable id ~exp:(E.js_global "Infinity")
  | Single(_, ({name="neg_infinity";_} as id),_ ), "pervasives.ml" ->
    Js_output.of_stmt @@ S.alias_variable id ~exp:(E.js_global "-Infinity")
  | Single(_, ({name="nan";_} as id),_ ),  "pervasives.ml" ->
    Js_output.of_stmt @@ S.alias_variable id ~exp:(E.js_global "NaN")

  (* TODO: 
      Make it more safe, we should rewrite the last one...
       checkout [E.mldot], it would make sense that cross module inlining done there
       In general, we would like to do such specialization on primitive specialization
        [Lam_dispatch_primitive], here it makes an exception since this function is not a primitive
  *) 
  | Single(_, ({name="^";_} as id),_ ),  "pervasives.ml" ->
    Js_output.of_stmt @@ S.alias_variable id 
      ~exp:(let a = Ext_ident.create "a" in 
            let b = Ext_ident.create "b" in
            E.ocaml_fun [a;b] [S.return (E.string_append (E.var a) (E.var b))]
           )

  (* QUICK hack to make hello world example nicer,
     Note the arity of [print_endline] is already analyzed before, 
     so it should be safe
  *)
  | Single(_, ({name="print_endline";_} as id),_ ),  "pervasives.ml" ->
    Js_output.of_stmt @@ S.alias_variable id 
      ~exp:(let param = Ext_ident.create "param" in 
            E.ocaml_fun [param] [S.return 
                                   (E.seq (E.call ~info:{arity=Full; call_info = Call_na} 
                                             (E.js_global "console.log") [E.var param]) 
                                      E.zero_int_literal )] )
  | Single(_, ({name="prerr_endline";_} as id),_ ),  "pervasives.ml" ->
    Js_output.of_stmt @@ S.alias_variable id 
      ~exp:(let param = Ext_ident.create "param" in 
            E.ocaml_fun [param] [S.return 
                                   (E.seq (E.call ~info:{arity=Full; call_info = Call_na} 
                                             (E.js_global "console.error") [E.var param]) 
                                      E.zero_int_literal )] )


  | Single(_, ({name="string_of_int";_} as id),_ ),  "pervasives.ml" ->
    Js_output.of_stmt @@ S.alias_variable id
      ~exp:( 
        let arg = Ext_ident.create "param" in
        E.ocaml_fun [arg] [S.return (E.anything_to_string (E.var arg))]
      )

  | Single(_, ({name="max_float";_} as id),_ ),  "pervasives.ml" ->

    Js_output.of_stmt @@ S.alias_variable id 
      ~exp:(E.js_global_dot "Number" "MAX_VALUE")
  | Single(_, ({name="min_float";_} as id) ,_ ), "pervasives.ml" ->
    Js_output.of_stmt @@  S.alias_variable id
      ~exp:(E.js_global_dot  "Number" "MIN_VALUE")
  | Single(_, ({name="epsilon_float";_} as id) ,_ ),  "pervasives.ml" ->
    Js_output.of_stmt @@ S.alias_variable id 
      ~exp:(E.float "2.220446049250313e-16")
  | Single(_, ({name="cat";_} as id) ,_ ),  "bytes.ml" ->
    Js_output.of_stmt @@ S.alias_variable id
      ~exp:(let a = Ext_ident.create "a" in 
            let b = Ext_ident.create "b" in
            E.ocaml_fun [a;b] [S.return (E.array_append (E.var a) (E.var b))]
           )

  (** Special handling for values in [Sys] *)
  | Single(_, ({name="max_array_length" | "max_string_length";_} as id) ,_ ),  "sys.ml" ->
    (* See [js_knowledge] Array size section, can not be expressed by OCaml int,
       note that casual handling of {!Sys.max_string_length} could result into 
       negative value which could cause wrong behavior of {!Buffer.create}
    *)
    Js_output.of_stmt @@ S.alias_variable id ~exp:(E.float "2147483647")  (*2 ^ 31 - 1*)

  | Single(_, ({name="max_int";_} as id) ,_ ),  ("sys.ml" | "nativeint.ml") ->
    (* See [js_knowledge] Max int section, (2. ** 53. -. 1.;;)
       can not be expressed by OCaml int 
       FIXME: we need handle {!Nativeint} and {!Sys} differently
    *)
    Js_output.of_stmt @@ S.alias_variable id 
      ~exp:(E.float "9007199254740991.") 

  | Single(_, ({name="min_int";_} as id) ,_ ),  ("sys.ml" | "nativeint.ml") ->
    (* See [js_knowledge] Max int section, -. (2. ** 53. -. 1.);;
       can not be expressed by OCaml int 
       FIXME: we need handle {!Nativeint} and {!Sys} differently
    *)
    Js_output.of_stmt @@ S.alias_variable id
      ~exp:(E.float ("-9007199254740991.")) 

  | Single (kind, id, lam), _ -> 
    (* let lam = Optimizer.simplify_lets [] lam in  *)
    (* can not apply again, it's wrong USE it with care*)
    (* ([Js_stmt_make.comment (Gen_of_env.query_type id  env )], None)  ++ *)
    Lam_compile.compile_let  kind { st = Declare (kind, id);
                                    should_return = ReturnFalse;
                                    jmp_table = Lam_compile_defs.empty_handler_map;
                                    meta
                                  } id  lam

  | Recursive id_lams, _   -> 
    Lam_compile.compile_recursive_lets 
      { st = EffectCall ;
        should_return = ReturnFalse; 
        jmp_table = Lam_compile_defs.empty_handler_map;
        meta
      } 
      id_lams
  | Nop lam, _ -> (* TODO: Side effect callls, log and see statistics *)
    Lam_compile.compile_lambda {st = EffectCall;
                                should_return = ReturnFalse;
                                jmp_table = Lam_compile_defs.empty_handler_map;
                                meta
                               } lam

;;

 (** Also need analyze its depenency is pure or not *)
let no_side_effects (rest : Lam_group.t list) : string option = 
    Ext_list.find_opt (fun (x : Lam_group.t) -> 
        match x with 
        | Single(kind,id,body) -> 
          begin 
            match kind with 
            | Strict | Variable -> 
              if not @@ Lam_analysis.no_side_effects body 
              then Some  (Printf.sprintf "%s" id.name)
              else None
            | _ -> None
          end
        | Recursive bindings -> 
          Ext_list.find_opt (fun (id,lam) -> 
              if not @@ Lam_analysis.no_side_effects lam 
              then Some (Printf.sprintf "%s" id.Ident.name )
              else None
            ) bindings
        | Nop lam -> 
          if not @@ Lam_analysis.no_side_effects lam 
          then 
            (*  (Lam_util.string_of_lambda lam) *)
            Some ""
          else None (* TODO :*))
      rest



(** Actually simplify_lets is kind of global optimization since it requires you to know whether 
    it's used or not 
*)
let compile  ~filename (output_prefix : string) env _sigs 
    (lam : Lambda.lambda)   = 
  let export_idents = Translmod.get_export_identifiers() in
  let export_ident_sets = Ident_set.of_list export_idents in 
  (* To make toplevel happy - reentrant for js-demo *)
  let () = 
      
    Lam_compile_env.reset () ;
  in 
  let lam, may_required_modules = Lam.convert export_ident_sets lam in 
  let _d  = fun s lam -> 
    let result = Lam_util.dump env s lam  in

    result 
  in
  let _j = Js_pass_debug.dump in
  let lam = _d "initial"  lam in
  let lam  = Lam_pass_deep_flatten.deep_flatten lam in
  let lam = _d  "flatten" lam in
  let meta = 
    Lam_pass_collect.count_alias_globals env filename
      export_idents export_ident_sets lam in
  let lam = 
    let lam =  
      lam
      |> _d "flattern"
      |>  Lam_pass_exits.simplify_exits
      |> _d "simplyf_exits"
      |> (fun lam -> Lam_pass_collect.collect_helper meta lam; lam)
      |>  Lam_pass_remove_alias.simplify_alias  meta
      |> _d "simplify_alias"
      |> Lam_pass_deep_flatten.deep_flatten
      |> _d "flatten"
    in  (* Inling happens*)

    let ()  = Lam_pass_collect.collect_helper meta lam in
    let lam = Lam_pass_remove_alias.simplify_alias meta lam  in
    let lam = Lam_pass_deep_flatten.deep_flatten lam in
    let ()  = Lam_pass_collect.collect_helper meta lam in
    let lam = 
      lam
      |> _d "alpha_before"
      |> Lam_pass_alpha_conversion.alpha_conversion meta
      |> Lam_pass_exits.simplify_exits in    
    let () = Lam_pass_collect.collect_helper meta lam in


    lam
    |> _d "simplify_alias_before"
    |>  Lam_pass_remove_alias.simplify_alias meta 
    |> _d "alpha_conversion"
    |>  Lam_pass_alpha_conversion.alpha_conversion meta
    |> _d "before-simplify_lets"
    (* we should investigate a better way to put different passes : )*)
    |> Lam_pass_lets_dce.simplify_lets 

    |> _d "before-simplify-exits"
    (* |> (fun lam -> Lam_pass_collect.collect_helper meta lam 
       ; Lam_pass_remove_alias.simplify_alias meta lam) *)
    (* |> Lam_group_pass.scc_pass
       |> _d "scc" *)
    |> Lam_pass_exits.simplify_exits
    |> _d "simplify_lets"
    
  in

  let ({Lam_coercion.groups = groups } as coerced_input , meta) = 
    Lam_coercion.coerce_and_group_big_lambda  meta lam
  in 

  
  let maybe_pure = no_side_effects groups in
  
  let body  = 
    groups
    |> Ext_list.map (fun group -> compile_group meta group)
    |> Js_output.concat
    |> Js_output.to_block
  in
    
  (* The file is not big at all compared with [cmo] *)
  (* Ext_marshal.to_file (Ext_path.chop_extension filename ^ ".mj")  js; *)
  let js : J.program = 
      { J.name = filename ; 
        exports = meta.exports ; 
        export_set = Ident_set.of_list meta.exports; 
        block = body}
  in
  js 
  |> _j "initial"
  |> Js_pass_flatten.program
  |> _j "flattern"
  |> Js_pass_tailcall_inline.tailcall_inline
  |> _j "inline_and_shake"
  |> Js_pass_flatten_and_mark_dead.program
  |> _j "flatten_and_mark_dead"
  (* |> Js_inline_and_eliminate.inline_and_shake *)
  (* |> _j "inline_and_shake" *)
  |> (fun js -> ignore @@ Js_pass_scope.program  js ; js )
  |> Js_shake.shake_program
  |> _j "shake"
  |> ( fun (program:  J.program) -> 
      let external_module_ids = 
        Lam_compile_env.get_required_modules  
          may_required_modules  
          (Js_fold_basic.calculate_hard_dependencies program.block)
        |>
        (fun x ->
           if !Js_config.sort_imports then
             Ext_list.sort_via_array
               (fun (id1 : Lam_module_ident.t) (id2 : Lam_module_ident.t) ->
                  Ext_string.compare (Lam_module_ident.name id1) (Lam_module_ident.name id2)
               ) x
           else
             x
        )
      in

      let v = 
        Lam_stats_export.export_to_cmj 
          meta  
          maybe_pure 
          external_module_ids
          coerced_input.export_map
          (Ext_char.is_lower_case (Filename.basename output_prefix).[0])
      in
      (if not @@ !Clflags.dont_write_files then
         Js_cmj_format.to_file 
           (output_prefix ^ Literals.suffix_cmj) v);
      {J.program = program ; side_effect = v.effect ; modules = external_module_ids }      
    )
;;

let (//) = Filename.concat  

let lambda_as_module 
    env 
    (sigs : Types.signature)
    (filename : string) 
    (output_prefix : string)
    (lam : Lambda.lambda) = 
  begin 
    Js_config.set_current_file filename ;  

    
    let lambda_output = compile ~filename output_prefix env sigs lam in
    let basename =  
      (* #758, output_prefix is already chopped *)
       Ext_namespace.js_name_of_basename (Filename.basename
         output_prefix (* -o *)
         (* filename *) (* see #757  *)
      ) in
      (* #913
         only generate little-case js file
      *)
 
    (* Not re-entrant *)
    let package_info = Js_packages_state.get_packages_info () in 
    if Js_packages_info.is_empty package_info  then 
    begin 

    (* script mode *)
      let output_chan chan =         
        Js_dump_program.dump_deps_program ~output_prefix NodeJS lambda_output chan in
      (if !Js_config.dump_js then output_chan stdout);
      if not @@ !Clflags.dont_write_files then 
        Ext_pervasives.with_file_as_chan 
          (Filename.dirname filename //  basename)
           output_chan
    end
    else  begin 
      package_info.module_systems 
      |> List.iter begin fun (module_system, _path) -> 
        let output_chan chan  = 
          Js_dump_program.dump_deps_program ~output_prefix
            module_system 
            lambda_output
            chan in
        (if !Js_config.dump_js then 
           output_chan  stdout);
        if not @@ !Clflags.dont_write_files then 
          Ext_pervasives.with_file_as_chan
            (Lazy.force Ext_filename.package_dir //
             _path //
              basename
             (* #913 only generate little-case js file *)
            ) output_chan

      end
    end 
  end
(* We can use {!Env.current_unit = "Pervasives"} to tell if it is some specific module, 
    We need handle some definitions in standard libraries in a special way, most are io specific, 
    includes {!Pervasives.stdin, Pervasives.stdout, Pervasives.stderr}

    However, use filename instead of {!Env.current_unit} is more honest, since node-js module system is coupled with the file name 
*)

end
module Parse : sig 
#1 "parse.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Entry points in the parser *)

val implementation : Lexing.lexbuf -> Parsetree.structure
val interface : Lexing.lexbuf -> Parsetree.signature
val toplevel_phrase : Lexing.lexbuf -> Parsetree.toplevel_phrase
val use_file : Lexing.lexbuf -> Parsetree.toplevel_phrase list
val core_type : Lexing.lexbuf -> Parsetree.core_type
val expression : Lexing.lexbuf -> Parsetree.expression
val pattern : Lexing.lexbuf -> Parsetree.pattern

end = struct
#1 "parse.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Entry points in the parser *)

(* Skip tokens to the end of the phrase *)

let rec skip_phrase lexbuf =
  try
    match Lexer.token lexbuf with
      Parser.SEMISEMI | Parser.EOF -> ()
    | _ -> skip_phrase lexbuf
  with
    | Lexer.Error (Lexer.Unterminated_comment _, _)
    | Lexer.Error (Lexer.Unterminated_string, _)
    | Lexer.Error (Lexer.Unterminated_string_in_comment _, _)
    | Lexer.Error (Lexer.Illegal_character _, _) -> skip_phrase lexbuf
;;

let maybe_skip_phrase lexbuf =
  if Parsing.is_current_lookahead Parser.SEMISEMI
  || Parsing.is_current_lookahead Parser.EOF
  then ()
  else skip_phrase lexbuf

let wrap parsing_fun lexbuf =
  try
    Docstrings.init ();
    Lexer.init ();
    let ast = parsing_fun Lexer.token lexbuf in
    Parsing.clear_parser();
    Docstrings.warn_bad_docstrings ();
    ast
  with
  | Lexer.Error(Lexer.Illegal_character _, _) as err
    when !Location.input_name = "//toplevel//"->
      skip_phrase lexbuf;
      raise err
  | Syntaxerr.Error _ as err
    when !Location.input_name = "//toplevel//" ->
      maybe_skip_phrase lexbuf;
      raise err
  | Parsing.Parse_error | Syntaxerr.Escape_error ->
      let loc = Location.curr lexbuf in
      if !Location.input_name = "//toplevel//"
      then maybe_skip_phrase lexbuf;
      raise(Syntaxerr.Error(Syntaxerr.Other loc))

let implementation = wrap Parser.implementation
and interface = wrap Parser.interface
and toplevel_phrase = wrap Parser.toplevel_phrase
and use_file = wrap Parser.use_file
and core_type = wrap Parser.parse_core_type
and expression = wrap Parser.parse_expression
and pattern = wrap Parser.parse_pattern

end
module Ccomp : sig 
#1 "ccomp.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Compiling C files and building C libraries *)

val command: string -> int
val run_command: string -> unit
val compile_file: string -> int
val create_archive: string -> string list -> int
val expand_libname: string -> string
val quote_files: string list -> string
val quote_optfile: string option -> string
(*val make_link_options: string list -> string*)

type link_mode =
  | Exe
  | Dll
  | MainDll
  | Partial

val call_linker: link_mode -> string -> string list -> string -> bool

end = struct
#1 "ccomp.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* Compiling C files and building C libraries *)

let command cmdline =
  if !Clflags.verbose then begin
    prerr_string "+ ";
    prerr_string cmdline;
    prerr_newline()
  end;
  Sys.command cmdline

let run_command cmdline = ignore(command cmdline)

(* Build @responsefile to work around Windows limitations on
   command-line length *)
let build_diversion lst =
  let (responsefile, oc) = Filename.open_temp_file "camlresp" "" in
  List.iter (fun f -> Printf.fprintf oc "%s\n" f) lst;
  close_out oc;
  at_exit (fun () -> Misc.remove_file responsefile);
  "@" ^ responsefile

let quote_files lst =
  let lst = List.filter (fun f -> f <> "") lst in
  let quoted = List.map Filename.quote lst in
  let s = String.concat " " quoted in
  if String.length s >= 4096 && Sys.os_type = "Win32"
  then build_diversion quoted
  else s

let quote_prefixed pr lst =
  let lst = List.filter (fun f -> f <> "") lst in
  let lst = List.map (fun f -> pr ^ f) lst in
  quote_files lst

let quote_optfile = function
  | None -> ""
  | Some f -> Filename.quote f

let compile_file name =
  command
    (Printf.sprintf
       "%s -c %s %s %s %s %s"
       (match !Clflags.c_compiler with
        | Some cc -> cc
        | None ->
            if !Clflags.native_code
            then Config.native_c_compiler
            else Config.bytecomp_c_compiler)
       (if !Clflags.debug then "-g" else "")
       (String.concat " " (List.rev !Clflags.all_ccopts))
       (quote_prefixed "-I" (List.rev !Clflags.include_dirs))
       (Clflags.std_include_flag "-I")
       (Filename.quote name))

let create_archive archive file_list =
  Misc.remove_file archive;
  let quoted_archive = Filename.quote archive in
  match Config.ccomp_type with
    "msvc" ->
      command(Printf.sprintf "link /lib /nologo /out:%s %s"
                             quoted_archive (quote_files file_list))
  | _ ->
      assert(String.length Config.ar > 0);
      let r1 =
        command(Printf.sprintf "%s rc %s %s"
                Config.ar quoted_archive (quote_files file_list)) in
      if r1 <> 0 || String.length Config.ranlib = 0
      then r1
      else command(Config.ranlib ^ " " ^ quoted_archive)

let expand_libname name =
  if String.length name < 2 || String.sub name 0 2 <> "-l"
  then name
  else begin
    let libname =
      "lib" ^ String.sub name 2 (String.length name - 2) ^ Config.ext_lib in
    try
      Misc.find_in_path !Config.load_path libname
    with Not_found ->
      libname
  end

type link_mode =
  | Exe
  | Dll
  | MainDll
  | Partial

let remove_Wl cclibs =
  cclibs |> List.map (fun cclib ->
    (* -Wl,-foo,bar -> -foo bar *)
    if String.length cclib >= 4 && "-Wl," = String.sub cclib 0 4 then
      String.map (function ',' -> ' ' | c -> c)
                 (String.sub cclib 4 (String.length cclib - 4))
    else cclib)

let call_linker mode output_name files extra =
  let cmd =
    if mode = Partial then
      Printf.sprintf "%s%s %s %s %s"
        Config.native_pack_linker
        (Filename.quote output_name)
        (quote_prefixed "-L" !Config.load_path)
        (quote_files (remove_Wl files))
        extra
    else
      Printf.sprintf "%s -o %s %s %s %s %s %s %s"
        (match !Clflags.c_compiler, mode with
        | Some cc, _ -> cc
        | None, Exe -> Config.mkexe
        | None, Dll -> Config.mkdll
        | None, MainDll -> Config.mkmaindll
        | None, Partial -> assert false
        )
        (Filename.quote output_name)
        (if !Clflags.gprofile then Config.cc_profile else "")
        ""  (*(Clflags.std_include_flag "-I")*)
        (quote_prefixed "-L" !Config.load_path)
        (String.concat " " (List.rev !Clflags.all_ccopts))
        (quote_files files)
        extra
  in
  command cmd = 0

end
module Pparse : sig 
#1 "pparse.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*        Daniel de Rauglaudre, projet Cristal, INRIA Rocquencourt     *)
(*                                                                     *)
(*  Copyright 2002 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Format

type error =
  | CannotRun of string
  | WrongMagic of string

exception Error of error

val preprocess : string -> string
val remove_preprocessed : string -> unit
val file : formatter -> tool_name:string -> string -> (Lexing.lexbuf -> 'a) -> string -> 'a
val apply_rewriters: ?restore:bool -> tool_name:string -> string -> 'a -> 'a
  (** If [restore = true] (the default), cookies set by external rewriters will be
      kept for later calls. *)

val apply_rewriters_str: ?restore:bool -> tool_name:string -> Parsetree.structure -> Parsetree.structure
val apply_rewriters_sig: ?restore:bool -> tool_name:string -> Parsetree.signature -> Parsetree.signature


val report_error : formatter -> error -> unit


val parse_implementation: formatter -> tool_name:string -> string -> Parsetree.structure
val parse_interface: formatter -> tool_name:string -> string -> Parsetree.signature

(* [call_external_preprocessor sourcefile pp] *)
val call_external_preprocessor : string -> string -> string
val open_and_check_magic : string -> string -> in_channel * bool
val read_ast : string -> string -> 'a

end = struct
#1 "pparse.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*        Daniel de Rauglaudre, projet Cristal, INRIA Rocquencourt     *)
(*                                                                     *)
(*  Copyright 2002 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Format

type error =
  | CannotRun of string
  | WrongMagic of string

exception Error of error

(* Optionally preprocess a source file *)

let call_external_preprocessor sourcefile pp =
      let tmpfile = Filename.temp_file "ocamlpp" "" in
      let comm = Printf.sprintf "%s %s > %s"
                                pp (Filename.quote sourcefile) tmpfile
      in
      if Ccomp.command comm <> 0 then begin
        Misc.remove_file tmpfile;
        raise (Error (CannotRun comm));
      end;
      tmpfile

let preprocess sourcefile =
  match !Clflags.preprocessor with
    None -> sourcefile
  | Some pp -> call_external_preprocessor sourcefile pp


let remove_preprocessed inputfile =
  match !Clflags.preprocessor with
    None -> ()
  | Some _ -> Misc.remove_file inputfile


(* Note: some of the functions here should go to Ast_mapper instead,
   which would encapsulate the "binary AST" protocol. *)

let write_ast magic ast =
  let fn = Filename.temp_file "camlppx" "" in
  let oc = open_out_bin fn in
  output_string oc magic;
  output_value oc !Location.input_name;
  output_value oc ast;
  close_out oc;
  fn

let apply_rewriter magic fn_in ppx =
  let fn_out = Filename.temp_file "camlppx" "" in
  let comm =
    Printf.sprintf "%s %s %s" ppx (Filename.quote fn_in) (Filename.quote fn_out)
  in
  let ok = Ccomp.command comm = 0 in
  Misc.remove_file fn_in;
  if not ok then begin
    Misc.remove_file fn_out;
    raise (Error (CannotRun comm));
  end;
  if not (Sys.file_exists fn_out) then
    raise (Error (WrongMagic comm));
  (* check magic before passing to the next ppx *)
  let ic = open_in_bin fn_out in
  let buffer =
    try really_input_string ic (String.length magic) with End_of_file -> "" in
  close_in ic;
  if buffer <> magic then begin
    Misc.remove_file fn_out;
    raise (Error (WrongMagic comm));
  end;
  fn_out

let read_ast magic fn =
  let ic = open_in_bin fn in
  try
    let buffer = really_input_string ic (String.length magic) in
    assert(buffer = magic); (* already checked by apply_rewriter *)
    Location.input_name := input_value ic;
    let ast = input_value ic in
    close_in ic;
    Misc.remove_file fn;
    ast
  with exn ->
    close_in ic;
    Misc.remove_file fn;
    raise exn

let rewrite magic ast ppxs =
  read_ast magic
    (List.fold_left (apply_rewriter magic) (write_ast magic ast)
       (List.rev ppxs))

let apply_rewriters_str ?(restore = true) ~tool_name ast =
  match !Clflags.all_ppx with
  | [] -> ast
  | ppxs ->
      let ast = Ast_mapper.add_ppx_context_str ~tool_name ast in
      let ast = rewrite Config.ast_impl_magic_number ast ppxs in
      Ast_mapper.drop_ppx_context_str ~restore ast

let apply_rewriters_sig ?(restore = true) ~tool_name ast =
  match !Clflags.all_ppx with
  | [] -> ast
  | ppxs ->
      let ast = Ast_mapper.add_ppx_context_sig ~tool_name ast in
      let ast = rewrite Config.ast_intf_magic_number ast ppxs in
      Ast_mapper.drop_ppx_context_sig ~restore ast

let apply_rewriters ?restore ~tool_name magic ast =
  if magic = Config.ast_impl_magic_number then
    Obj.magic (apply_rewriters_str ?restore ~tool_name (Obj.magic ast))
  else if magic = Config.ast_intf_magic_number then
    Obj.magic (apply_rewriters_sig ?restore ~tool_name (Obj.magic ast))
  else
    assert false

(* Parse a file or get a dumped syntax tree from it *)

exception Outdated_version

let open_and_check_magic inputfile ast_magic =
  let ic = open_in_bin inputfile in
  let is_ast_file =
    try
      let buffer = really_input_string ic (String.length ast_magic) in
      if buffer = ast_magic then true
      else if String.sub buffer 0 9 = String.sub ast_magic 0 9 then
        raise Outdated_version
      else false
    with
      Outdated_version ->
        Misc.fatal_error "OCaml and preprocessor have incompatible versions"
    | _ -> false
  in
  (ic, is_ast_file)

let file ppf ~tool_name inputfile parse_fun ast_magic =
  let (ic, is_ast_file) = open_and_check_magic inputfile ast_magic in
  let ast =
    try
      if is_ast_file then begin
        if !Clflags.fast then
          (* FIXME make this a proper warning *)
          fprintf ppf "@[Warning: %s@]@."
            "option -unsafe used with a preprocessor returning a syntax tree";
        Location.input_name := input_value ic;
        input_value ic
      end else begin
        seek_in ic 0;
        Location.input_name := inputfile;
        let lexbuf = Lexing.from_channel ic in
        Location.init lexbuf inputfile;
        parse_fun lexbuf
      end
    with x -> close_in ic; raise x
  in
  close_in ic;
  apply_rewriters ~restore:false ~tool_name ast_magic ast


let report_error ppf = function
  | CannotRun cmd ->
      fprintf ppf "Error while running external preprocessor@.\
                   Command line: %s@." cmd
  | WrongMagic cmd ->
      fprintf ppf "External preprocessor does not produce a valid file@.\
                   Command line: %s@." cmd

let () =
  Location.register_error_of_exn
    (function
      | Error err -> Some (Location.error_of_printer_file report_error err)
      | _ -> None
    )

let parse_all ~tool_name parse_fun magic ppf sourcefile =
  Location.input_name := sourcefile;
  let inputfile = preprocess sourcefile in
  let ast =
    try file ppf ~tool_name inputfile parse_fun magic
    with exn ->
      remove_preprocessed inputfile;
      raise exn
  in
  remove_preprocessed inputfile;
  ast

let parse_implementation ppf ~tool_name sourcefile =
  parse_all ~tool_name Parse.implementation
    Config.ast_impl_magic_number ppf sourcefile
let parse_interface ppf ~tool_name sourcefile =
  parse_all ~tool_name Parse.interface
    Config.ast_intf_magic_number ppf sourcefile

end
module Ext_utf8 : sig 
#1 "ext_utf8.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type byte =
  | Single of int
  | Cont of int
  | Leading of int * int
  | Invalid


val classify : char -> byte 

val follow : 
    string -> 
    int -> 
    int -> 
    int ->
    int * int 


(** 
  return [-1] if failed 
*)
val next :  string -> remaining:int -> int -> int 


exception Invalid_utf8 of string 
 
 
val decode_utf8_string : string -> int list
end = struct
#1 "ext_utf8.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type byte =
  | Single of int
  | Cont of int
  | Leading of int * int
  | Invalid

(** [classify chr] returns the {!byte} corresponding to [chr] *)
let classify chr =
  let c = int_of_char chr in
  (* Classify byte according to leftmost 0 bit *)
  if c land 0b1000_0000 = 0 then Single c else
    (* c 0b0____*)
  if c land 0b0100_0000 = 0 then Cont (c land 0b0011_1111) else
    (* c 0b10___*)
  if c land 0b0010_0000 = 0 then Leading (1, c land 0b0001_1111) else
    (* c 0b110__*)
  if c land 0b0001_0000 = 0 then Leading (2, c land 0b0000_1111) else
    (* c 0b1110_ *)
  if c land 0b0000_1000 = 0 then Leading (3, c land 0b0000_0111) else
    (* c 0b1111_0___*)
  if c land 0b0000_0100 = 0 then Leading (4, c land 0b0000_0011) else
    (* c 0b1111_10__*)
  if c land 0b0000_0010 = 0 then Leading (5, c land 0b0000_0001)
  (* c 0b1111_110__ *)
  else Invalid

exception Invalid_utf8 of string 

(* when the first char is [Leading],
  TODO: need more error checking 
  when out of bond
 *)
let rec follow s n (c : int) offset = 
  if n = 0 then (c, offset)
  else 
    begin match classify s.[offset+1] with
      | Cont cc -> follow s (n-1) ((c lsl 6) lor (cc land 0x3f)) (offset+1)
      | _ -> raise (Invalid_utf8 "Continuation byte expected")
    end


let rec next s ~remaining  offset = 
  if remaining = 0 then offset 
  else 
    begin match classify s.[offset+1] with
      | Cont cc -> next s ~remaining:(remaining-1) (offset+1)
      | _ ->  -1 
      | exception _ ->  -1 (* it can happen when out of bound *)
    end




let decode_utf8_string s =
  let lst = ref [] in
  let add elem = lst := elem :: !lst in
  let rec  decode_utf8_cont s i s_len =
    if i = s_len  then ()
    else 
      begin 
        match classify s.[i] with
        | Single c -> 
          add c; decode_utf8_cont s (i+1) s_len
        | Cont _ -> raise (Invalid_utf8 "Unexpected continuation byte")
        | Leading (n, c) ->
          let (c', i') = follow s n c i in add c';
          decode_utf8_cont s (i' + 1) s_len
        | Invalid -> raise (Invalid_utf8 "Invalid byte")
      end
  in decode_utf8_cont s 0 (String.length s); 
  List.rev !lst


(** To decode {j||j} we need verify in the ast so that we have better error 
    location, then we do the decode later
*)  

let verify s loc = 
  assert false
end
module Ext_js_regex : sig 
#1 "ext_js_regex.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

(* This is a module that checks if js regex is valid or not *)

val js_regex_checker : string -> bool
end = struct
#1 "ext_js_regex.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


let check_from_end al =
  let rec aux l seen =
    match l with
    | [] -> false
    | (e::r) ->
      if e < 0 || e > 255 then false
      else (let c = Char.chr e in
            if c = '/' then true
            else (if List.exists (fun x -> x = c) seen then false (* flag should not be repeated *)
                  else (if c = 'i' || c = 'g' || c = 'm' || c = 'y' || c ='u' then aux r (c::seen) 
                        else false)))
  in aux al []

let js_regex_checker s =
  match Ext_utf8.decode_utf8_string s with 
  | [] -> false 
  | 47 (* [Char.code '/' = 47 ]*)::tail -> 
    check_from_end (List.rev tail)       
  | _ :: _ -> false 
  | exception Ext_utf8.Invalid_utf8 _ -> false 

end
module Ast_payload : sig 
#1 "ast_payload.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)



(** A utility module used when destructuring parsetree attributes, used for 
    compiling FFI attributes and built-in ppx  *)

type t = Parsetree.payload
type lid = string Asttypes.loc
type label_expr = lid  * Parsetree.expression
type action = 
   lid * Parsetree.expression option

val is_single_string : t -> (string * string option) option
val is_single_int : t -> int option 

type rtn = Not_String_Lteral | JS_Regex_Check_Failed | Correct of Parsetree.expression
val as_string_exp : ?check_js_regex: bool -> t -> rtn
val as_core_type : Location.t -> t -> Parsetree.core_type    
val as_empty_structure :  t -> bool 
val as_ident : t -> Longident.t Asttypes.loc option
val raw_string_payload : Location.t -> string -> t 
val assert_strings :
  Location.t -> t -> string list  

(** as a record or empty 
    it will accept 

    {[ [@@@bs.config ]]}
    or 
    {[ [@@@bs.config no_export ] ]}
    or 
    {[ [@@@bs.config { property  .. } ]]}    
    Note that we only 
    {[
      { flat_property}
    ]}
    below  is not allowed 
    {[
      {M.flat_property}
    ]}
*)

val ident_or_record_as_config : 
  Location.t ->
  t -> action list 

val assert_bool_lit : Parsetree.expression -> bool

val empty : t 

val table_dispatch : 
  (Parsetree.expression option  -> 'a) String_map.t -> action -> 'a

end = struct
#1 "ast_payload.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type t = Parsetree.payload

let is_single_string (x : t ) = 
  match x with  (** TODO also need detect empty phrase case *)
  | PStr [ {
      pstr_desc =  
        Pstr_eval (
          {pexp_desc = 
             Pexp_constant 
               (Const_string (name,dec));
           _},_);
      _}] -> Some (name,dec)
  | _  -> None

let is_single_int (x : t ) = 
  match x with  (** TODO also need detect empty phrase case *)
  | PStr [ {
      pstr_desc =  
        Pstr_eval (
          {pexp_desc = 
             Pexp_constant 
               (Const_int name);
           _},_);
      _}] -> Some name
  | _  -> None

type rtn = Not_String_Lteral | JS_Regex_Check_Failed | Correct of Parsetree.expression
let as_string_exp ?(check_js_regex = false) (x : t ) = 
  match x with  (** TODO also need detect empty phrase case *)
  | PStr [ {
      pstr_desc =  
        Pstr_eval (
          {pexp_desc = 
             Pexp_constant 
               (Const_string (str,_));
           _} as e ,_);
      _}] -> if check_js_regex then (if Ext_js_regex.js_regex_checker str then Correct e else JS_Regex_Check_Failed) else Correct e
  | _  -> Not_String_Lteral

let as_core_type loc x =
  match  x with
  | Parsetree.PTyp x -> x
  | _ -> Location.raise_errorf ~loc "except a core type"

let as_ident (x : t ) =
  match x with
  | PStr [
      {pstr_desc =
         Pstr_eval (
           {
             pexp_desc =
               Pexp_ident ident 

           } , _)
      }
    ] -> Some ident
  | _ -> None
open Ast_helper

let raw_string_payload loc (s : string) : t =
  PStr [ Str.eval ~loc (Exp.constant ~loc (Const_string (s,None)  ))]

let as_empty_structure (x : t ) = 
  match x with 
  | PStr ([]) -> true
  | PTyp _ | PPat _ | PStr (_ :: _ ) -> false 

type lid = string Asttypes.loc
type label_expr = lid  * Parsetree.expression

type action = 
  lid * Parsetree.expression option 
(** None means punning is hit 
    {[ { x } ]}
    otherwise it comes with a payload 
    {[ { x = exp }]}
*)


let ident_or_record_as_config     
    loc
    (x : Parsetree.payload) 
  : ( string Location.loc * Parsetree.expression option) list 
  = 
  match  x with 
  | PStr 
      [ {pstr_desc = Pstr_eval
             ({pexp_desc = Pexp_record (label_exprs, with_obj) ; pexp_loc = loc}, _); 
         _
        }]
    -> 
    begin match with_obj with
      | None ->
        Ext_list.map
          (fun ((x,y) : (Longident.t Asttypes.loc * _) ) -> 
             match (x,y) with 
             | ({txt = Lident name; loc} ) , 
               ({Parsetree.pexp_desc = Pexp_ident{txt = Lident name2}} )
               when name2 = name -> 
               ({Asttypes.txt = name ; loc}, None)
             | ({txt = Lident name; loc} ), y 
               -> 
               ({Asttypes.txt = name ; loc}, Some y)
             | _ -> 
               Location.raise_errorf ~loc "Qualified label is not allood"
          )
          label_exprs
      | Some _ -> 
        Location.raise_errorf ~loc "with is not supported"
    end
  | PStr [
      {pstr_desc =
         Pstr_eval (
           {
             pexp_desc =
               Pexp_ident ({loc = lloc; txt = Lident txt});

           } , _)
      }
    ] -> [ {Asttypes.txt ; loc = lloc}, None] 
  | PStr [] -> []
  | _ -> 
    Location.raise_errorf ~loc "this is not a valid record config"



let assert_strings loc (x : t) : string list
  = 
  let module M = struct exception Not_str end  in 
  match x with 
  | PStr [ {pstr_desc =  
              Pstr_eval (
                {pexp_desc = 
                   Pexp_tuple strs;
                 _},_);
            pstr_loc = loc ;            
            _}] ->
    (try 
       strs |> Ext_list.map (fun e ->
           match (e : Parsetree.expression) with
           | {pexp_desc = Pexp_constant (Const_string (name,_)); _} -> 
             name
           | _ -> raise M.Not_str)
     with M.Not_str ->
       Location.raise_errorf ~loc "expect string tuple list"
    )
  | PStr [ {
      pstr_desc =  
        Pstr_eval (
          {pexp_desc = 
             Pexp_constant 
               (Const_string (name,_));
           _},_);
      _}] ->  [name] 
  | PStr [] ->  []
  | PStr _                
  | PTyp _ | PPat _ ->
    Location.raise_errorf ~loc "expect string tuple list"
let assert_bool_lit  (e : Parsetree.expression) = 
  match e.pexp_desc with
  | Pexp_construct ({txt = Lident "true" }, None)
    -> true
  | Pexp_construct ({txt = Lident "false" }, None)
    -> false 
  | _ ->
    Location.raise_errorf ~loc:e.pexp_loc "expect `true` or `false` in this field"


let empty : t = Parsetree.PStr []



let table_dispatch table (action : action)
  = 
  match action with 
  | {txt =  name; loc  }, y -> 
    begin match String_map.find_exn name table with 
      | fn -> fn y
      | exception _ -> Location.raise_errorf ~loc "%s is not supported" name
    end

end
module Ast_attributes : sig 
#1 "ast_attributes.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)
type attr =  Parsetree.attribute
type t =  attr list 

type ('a,'b) st = 
  { get : 'a option ; 
    set : 'b option }

val process_method_attributes_rev : 
  t ->
  (bool * bool , [`Get | `No_get ]) st * t 

val process_attributes_rev : 
  t -> [ `Meth_callback | `Nothing | `Uncurry | `Method ] * t 

val process_pexp_fun_attributes_rev :
  t -> [ `Nothing | `Exn ] * t 
val process_bs : 
  t -> [ `Nothing | `Has] * t 

val process_external : t -> bool 

type derive_attr = {
  explict_nonrec : bool;
  bs_deriving : [`Has_deriving of Ast_payload.action list | `Nothing ]
}
val process_bs_string_int_unwrap_uncurry :
  t -> [`Nothing | `String | `Int | `Ignore | `Unwrap | `Uncurry of int option ]  * t

val process_bs_string_as :
  t -> string option * t 
val process_bs_int_as : 
  t -> int option * t 

val process_bs_string_or_int_as : 
    t ->
    [ `Int of int 
    | `Str of string
    | `Json_str of string  ] option *
    (string Asttypes.loc * Parsetree.payload) list


val process_derive_type : 
  t -> derive_attr * t 



val bs : attr 
val bs_this : attr
val bs_method : attr


val warn_unused_attributes : t -> unit

end = struct
#1 "ast_attributes.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type attr =  Parsetree.attribute
type t =  attr list 

type ('a,'b) st = 
  { get : 'a option ; 
    set : 'b option }


let process_method_attributes_rev (attrs : t) = 
  List.fold_left (fun (st,acc) (({txt ; loc}, payload) as attr : attr) -> 

      match txt  with 
      | "bs.get" (* [@@bs.get{null; undefined}]*)
        -> 
        let result = 
          List.fold_left 
            (fun 
              (null, undefined)
              (({txt ; loc}, opt_expr) : Ast_payload.action) -> 
              match txt with 
              | "null" ->
                (match opt_expr with 
                 | None -> true
                 | Some e -> 
                   Ast_payload.assert_bool_lit e), undefined

              |  "undefined" ->
                null, 
                (match opt_expr with
                 | None ->  true
                 | Some e -> 
                   Ast_payload.assert_bool_lit e)
              | "nullable" -> 
                begin match opt_expr with 
                | None -> true, true 
                | Some e ->
                  let v = Ast_payload.assert_bool_lit e in 
                  v,v
                end
              | _ -> Bs_syntaxerr.err loc Unsupported_predicates
            ) (false, false) 
            (Ast_payload.ident_or_record_as_config loc payload)  in 

        ({st with get = Some result}, acc  )

      | "bs.set"
        -> 
        let result = 
          List.fold_left 
            (fun st (({txt ; loc}, opt_expr) : Ast_payload.action) -> 
               if txt =  "no_get" then 
                 match opt_expr with 
                 | None -> `No_get 
                 | Some e -> 
                   if Ast_payload.assert_bool_lit e then 
                     `No_get
                   else `Get
               else Bs_syntaxerr.err loc Unsupported_predicates
            ) `Get (Ast_payload.ident_or_record_as_config loc payload)  in 
        (* properties -- void 
              [@@bs.set{only}]
        *)
        {st with set = Some result }, acc
      | _ -> 
        (st, attr::acc  )
    ) ( {get = None ; set = None}, []) attrs


let process_attributes_rev (attrs : t) = 
  List.fold_left (fun (st, acc) (({txt; loc}, _) as attr : attr) -> 
      match txt, st  with 
      | "bs", (`Nothing | `Uncurry) 
        -> 
        `Uncurry, acc
      | "bs.this", (`Nothing | `Meth_callback)
        ->  `Meth_callback, acc
      | "bs.meth",  (`Nothing | `Method)
        -> `Method, acc
      | "bs", _
      | "bs.this", _
        -> Bs_syntaxerr.err loc Conflict_bs_bs_this_bs_meth
      | _ , _ -> 
        st, attr::acc 
    ) ( `Nothing, []) attrs

let process_pexp_fun_attributes_rev (attrs : t) = 
  List.fold_left (fun (st, acc) (({txt; loc}, _) as attr : attr) -> 
      match txt, st  with 
      | "bs.open", (`Nothing | `Exn) 
        -> 
        `Exn, acc

      | _ , _ -> 
        st, attr::acc 
    ) ( `Nothing, []) attrs

let process_bs attrs = 
  List.fold_left (fun (st, acc) (({txt; loc}, _) as attr : attr) -> 
      match txt, st  with 
      | "bs", _
        -> 
        `Has, acc
      | _ , _ -> 
        st, attr::acc 
    ) ( `Nothing, []) attrs

let process_external attrs = 
  List.exists (fun (({txt; }, _)  : attr) -> 
      if Ext_string.starts_with txt "bs." then true 
      else false
    ) attrs


type derive_attr = {
  explict_nonrec : bool;
  bs_deriving : [`Has_deriving of Ast_payload.action list | `Nothing ]
}

let process_derive_type attrs =
  List.fold_left 
    (fun (st, acc) 
      (({txt ; loc}, payload  as attr): attr)  ->
      match  st, txt  with
      |  {bs_deriving = `Nothing}, "bs.deriving"
        ->
        {st with
         bs_deriving = `Has_deriving 
             (Ast_payload.ident_or_record_as_config loc payload)}, acc 
      | {bs_deriving = `Has_deriving _}, "bs.deriving"
        -> 
        Bs_syntaxerr.err loc Duplicated_bs_deriving

      | _ , _ ->
        let st = 
          if txt = "nonrec" then 
            { st with explict_nonrec = true }
          else st in 
        st, attr::acc
    ) ( {explict_nonrec = false; bs_deriving = `Nothing }, []) attrs



let process_bs_string_int_unwrap_uncurry attrs =
  List.fold_left 
    (fun (st,attrs)
      (({txt ; loc}, (payload : _ ) ) as attr : attr)  ->
      match  txt, st  with
      | "bs.string", (`Nothing | `String)
        -> `String, attrs
      | "bs.int", (`Nothing | `Int)
        ->  `Int, attrs
      | "bs.ignore", (`Nothing | `Ignore)
        -> `Ignore, attrs
      | "bs.unwrap", (`Nothing | `Unwrap)
        -> `Unwrap, attrs
      | "bs.uncurry", `Nothing
        ->
        `Uncurry (Ast_payload.is_single_int payload), attrs 
      (* Don't allow duplicated [bs.uncurry] since
         it may introduce inconsistency in arity
      *)  
      | "bs.int", _
      | "bs.string", _
      | "bs.ignore", _
      | "bs.unwrap", _
        -> 
        Bs_syntaxerr.err loc Conflict_attributes
      | _ , _ -> st, (attr :: attrs )
    ) (`Nothing, []) attrs

let process_bs_string_as  attrs = 
  List.fold_left 
    (fun (st, attrs)
      (({txt ; loc}, payload ) as attr : attr)  ->
      match  txt, st  with
      | "bs.as", None
        ->
        begin match Ast_payload.is_single_string payload with 
          | None -> 
            Bs_syntaxerr.err loc Expect_string_literal
          | Some  (v,dec) ->  ( Some v, attrs)  
        end
      | "bs.as",  _ 
        -> 
        Bs_syntaxerr.err loc Duplicated_bs_as 
      | _ , _ -> (st, attr::attrs) 
    ) (None, []) attrs

let process_bs_int_as  attrs = 
  List.fold_left 
    (fun (st, attrs)
      (({txt ; loc}, payload ) as attr : attr)  ->
      match  txt, st  with
      | "bs.as", None
        ->
        begin match Ast_payload.is_single_int payload with 
          | None -> 
            Bs_syntaxerr.err loc Expect_int_literal
          | Some  _ as v->  (v, attrs)  
        end
      | "bs.as",  _ 
        -> 
        Bs_syntaxerr.err loc Duplicated_bs_as
      | _ , _ -> (st, attr::attrs) 
    ) (None, []) attrs

let process_bs_string_or_int_as attrs = 
  List.fold_left 
    (fun (st, attrs)
      (({txt ; loc}, payload ) as attr : attr)  ->
      match  txt, st  with
      | "bs.as", None
        ->
        begin match Ast_payload.is_single_int payload with 
          | None -> 
            begin match Ast_payload.is_single_string payload with 
              | Some (s,None) -> (Some (`Str (s)), attrs)
              | Some (s, Some "json") -> (Some (`Json_str s ), attrs)
              | None | Some (_, Some _) -> 
                Bs_syntaxerr.err loc Expect_int_or_string_or_json_literal

            end
          | Some   v->  (Some (`Int v), attrs)  
        end
      | "bs.as",  _ 
        -> 
        Bs_syntaxerr.err loc Duplicated_bs_as
      | _ , _ -> (st, attr::attrs) 
    ) (None, []) attrs

let bs : attr
  =  {txt = "bs" ; loc = Location.none}, Ast_payload.empty
let bs_this : attr
  =  {txt = "bs.this" ; loc = Location.none}, Ast_payload.empty

let bs_method : attr 
  =  {txt = "bs.meth"; loc = Location.none}, Ast_payload.empty


let warn_unused_attributes attrs = 
  if attrs <> [] then 
    List.iter (fun (({txt; loc}, _) : Parsetree.attribute) -> 
        Bs_warnings.warn_unused_attribute loc txt 
      ) attrs

end
module Ast_signature : sig 
#1 "ast_signature.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type item = Parsetree.signature_item
type t = item list 
val fuse : ?loc:Ast_helper.loc -> item -> t -> item

end = struct
#1 "ast_signature.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type item = Parsetree.signature_item
type t = item list 

open Ast_helper
let fuse ?(loc=Location.none) (item : item) (t : t) : item = 
  Sig.include_ ~loc (Incl.mk ~loc (Mty.signature ~loc (item::t)))

end
module Ast_structure : sig 
#1 "ast_structure.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


type item = Parsetree.structure_item

type t = item list 

val fuse : ?loc:Ast_helper.loc -> item -> t -> item

val constraint_ : ?loc:Ast_helper.loc -> t -> Ast_signature.t -> item

end = struct
#1 "ast_structure.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type item = Parsetree.structure_item

type t = item list 

open Ast_helper

let fuse ?(loc=Location.none) (item : item ) (t : t) : item = 
  Str.include_ ~loc 
    (Incl.mk ~loc (Mod.structure ~loc (item :: t) ))

let constraint_ ?(loc=Location.none) (stru : t) (sign : Ast_signature.t) = 
  Str.include_ ~loc
    (Incl.mk ~loc 
       (Mod.constraint_ ~loc (Mod.structure ~loc stru) (Mty.signature ~loc sign)))

end
module Ast_derive : sig 
#1 "ast_derive.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


type gen = {
  structure_gen : Parsetree.type_declaration list -> bool -> Ast_structure.t ;
  signature_gen : Parsetree.type_declaration list -> bool -> Ast_signature.t ; 
  expression_gen : (Parsetree.core_type -> Parsetree.expression) option ; 
}

val type_deriving_structure: 
  Parsetree.type_declaration list  ->
  Ast_payload.action list ->
  bool -> 
  Ast_structure.t
val type_deriving_signature: 
  Parsetree.type_declaration list ->
  Ast_payload.action list -> 
  bool -> 
  Ast_signature.t


val dispatch_extension : 
  string Asttypes.loc -> Parsetree.core_type -> Parsetree.expression

val update : string -> (Parsetree.expression option -> gen) -> unit

end = struct
#1 "ast_derive.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


type gen = {
  structure_gen : Parsetree.type_declaration list  -> bool -> Ast_structure.t ;
  signature_gen : Parsetree.type_declaration list -> bool -> Ast_signature.t ; 
  expression_gen : (Parsetree.core_type -> Parsetree.expression) option ; 
}

(* the first argument is [config] payload
   {[
     { x = {uu} }
   ]}
*)
type derive_table  = 
  (Parsetree.expression option -> gen) String_map.t

let derive_table : derive_table ref = ref String_map.empty

let update key value = 
  derive_table := String_map.add key value !derive_table 



let type_deriving_structure 
    tdcls 
    (actions :  Ast_payload.action list ) 
    (explict_nonrec : bool )
  : Ast_structure.t = 
  Ext_list.flat_map
    (fun action -> 
       (Ast_payload.table_dispatch !derive_table action).structure_gen 
         tdcls explict_nonrec) actions

let type_deriving_signature
    tdcls
    (actions :  Ast_payload.action list ) 
    (explict_nonrec : bool )
  : Ast_signature.t = 
  Ext_list.flat_map
    (fun action -> 
       (Ast_payload.table_dispatch !derive_table action).signature_gen
         tdcls explict_nonrec) actions

let dispatch_extension ({Asttypes.txt ; loc}) typ =
  let txt = Ext_string.tail_from txt (String.length Literals.bs_deriving_dot) in 
    match (Ast_payload.table_dispatch !derive_table 
            ({txt ; loc}, None)).expression_gen with 
    | None ->
      Bs_syntaxerr.err loc (Unregistered txt)

    | Some f -> f typ

end
module Ast_derive_util
= struct
#1 "ast_derive_util.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

open Ast_helper

let core_type_of_type_declaration (tdcl : Parsetree.type_declaration) = 
  match tdcl with 
  | {ptype_name = {txt ; loc};
     ptype_params ;
    } -> Typ.constr {txt = Lident txt ; loc} (Ext_list.map fst ptype_params)

let lift_string_list_to_array (labels : string list) = 
  Exp.array
    (Ext_list.map (fun s -> Exp.constant (Const_string (s, None)))
       labels)

let lift_int i = Exp.constant (Const_int i)
let lift_int_list_to_array (labels : int list) = 
  Exp.array (Ext_list.map lift_int labels)


let mk_fun ~loc (typ : Parsetree.core_type) 
    (value : string) body
  : Parsetree.expression = 
  Exp.fun_ 
    "" None
    (Pat.constraint_ (Pat.var {txt = value ; loc}) typ)
    body

let destruct_label_declarations ~loc
    (arg_name : string)
    (labels : Parsetree.label_declaration list) : 
  (Parsetree.core_type * Parsetree.expression) list * string list 
  =
  List.fold_right
    (fun   ({pld_name = {txt}; pld_type} : Parsetree.label_declaration) 
      (core_type_exps, labels) -> 
      ((pld_type, 
        Exp.field (Exp.ident {txt = Lident arg_name ; loc}) 
          {txt = Lident txt ; loc}) :: core_type_exps),
      txt :: labels 
    ) labels ([], [])

end
module Ast_derive_dyn : sig 
#1 "ast_derive_dyn.mli"
(* *)
val init : unit -> unit

end = struct
#1 "ast_derive_dyn.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

open Ast_helper

let not_supported loc =
  Bs_syntaxerr.err loc Not_supported_in_bs_deriving


let current_name_set : string list ref = ref []

let loc = Location.none 

let (+>) = Typ.arrow ""

type lid = Longident.t Asttypes.loc


let record_to_value = "record_to_value"
let variant_to_value = "variant_to_value"
let shape = "shape"
let js_dyn = "Bs_dyn"
let value = "value"
let record_shape = "record_shape"
let to_value = "_to_value"
let to_value_ = "_to_value_"
let shape_of_variant = "shape_of_variant"
let shape_of_record = "shape_of_record"
let option_to_value = "option_to_value"
(**
   {[Ptyp_constr of Longident.t loc * core_type list ]}
   ['u M.t]
*)


let bs_attrs = [Ast_attributes.bs]

(** template for 
    {[fun (value : t) -> 
      match value with 
        cases 
    ]}
*)
let js_dyn_value_type () =
  Typ.constr {txt = Longident.Ldot ((Lident  js_dyn), value) ; loc} []
let get_js_dyn_record_shape_type () = 
  Typ.constr {txt = Ldot (Lident js_dyn, record_shape); loc} []
let js_dyn_shape_of_variant () = 
  Exp.ident {txt = Ldot (Lident js_dyn, shape_of_variant); loc}
let js_dyn_shape_of_record () = 
  Exp.ident {txt = Ldot (Lident js_dyn, shape_of_record); loc}

let js_dyn_to_value_type ty  = 
  Typ.arrow "" ty  (js_dyn_value_type ())
let js_dyn_to_value_uncurry_type ty = 
  Typ.arrow "" ~attrs:bs_attrs ty (js_dyn_value_type ())

let js_dyn_variant_to_value () = 
  Exp.ident {txt = Ldot (Lident js_dyn, variant_to_value); loc}

let js_dyn_option_to_value () = 
  Exp.ident {txt = Ldot (Lident js_dyn, option_to_value); loc}

let js_dyn_tuple_to_value i = 
  Exp.ident {txt = Ldot (
      Lident js_dyn,
      "tuple_" ^ string_of_int i ^ "_to_value"); loc}


let bs_apply1 f v = 
  Exp.apply f ["",v] ~attrs:bs_attrs



(** [M.t]-> [M.t_to_value ] *)

let fn_of_lid  suffix (x : lid) : lid = 
  match x with
  | { txt = Lident name} 
    -> { x with  txt = Lident (name ^ suffix )}
  | { txt = Ldot (v,name)} 
    -> {x with txt = Ldot (v,  name ^ suffix )}
  | { txt = Lapply _} -> not_supported x.loc 

let rec exp_of_core_type prefix 
    ({ptyp_loc = loc} as x : Parsetree.core_type)
  : Parsetree.expression = 
  match x.ptyp_desc with 
  | Ptyp_constr (
      {txt = 
         Lident (
           "int" 
         | "int32" 
         | "int64" 
         | "nativeint"
         | "bool"
         | "float"
         | "char"
         | "string" 
           as name );
       loc }, ([] as params))
  | Ptyp_constr (
      {txt = 
         Lident (
           "option" 
         | "list" 
         | "array" 
           as name );
       loc }, ([_] as params))
    -> exp_of_core_type prefix 
         {x with 
          ptyp_desc =
            Ptyp_constr ({txt =  Ldot(Lident js_dyn,name);loc}, params)}
  | Ptyp_constr ({txt ; loc} as lid, []) -> 
    Exp.ident (fn_of_lid prefix lid)       
  | Ptyp_constr (lid, params)
    -> 
    Exp.apply (Exp.ident (fn_of_lid prefix lid))
      (Ext_list.map (fun x -> "",exp_of_core_type prefix x ) params) 
  | Ptyp_tuple lst -> 
    begin match lst with 
    | [x] -> exp_of_core_type prefix x 
    | [] -> assert false 
    | _ -> 
      let len = List.length lst in 
      if len > 6 then 
        Location.raise_errorf ~loc "tuple arity > 6 not supported yet"
      else 
        let fn = js_dyn_tuple_to_value len in 
        let args = Ext_list.map (fun x -> "", exp_of_core_type prefix x) lst in 
        Exp.apply fn args 
    end


  | _ -> assert false



(** return an expression node of array type *)
let exp_of_core_type_exprs 
    (core_type_exprs : (Parsetree.core_type * Parsetree.expression) list) 
  : Parsetree.expression  = 
    Exp.array 
      (List.fold_right (fun (core_type, exp) acc -> 
           bs_apply1
             (exp_of_core_type to_value  core_type) exp

           (* depends on [core_type] is in recursive name set or not ,
              if not, then uncurried application, otherwise, since 
              the uncurried version is not in scope yet, we 
              have to use the curried version
              the complexity is necessary
              think about such scenario:
              {[
                type nonrec t = A of t (* t_to_value *)
                and u = t (* t_to_value_ *)
              ]}
           *)
           :: acc 
       ) core_type_exprs [])

let destruct_constructor_declaration 
    ({pcd_name = {txt ;loc}; pcd_args} : Parsetree.constructor_declaration)  = 
  let last_i, core_type_exprs, pats = 
    List.fold_left (fun (i,core_type_exps, pats) core_type -> 
      let  txt = "a" ^ string_of_int i  in
      (i+1, (core_type, Exp.ident {txt = Lident txt  ;loc}) :: core_type_exps, 
       Pat.var {txt ; loc} :: pats )
    ) (0, [], []) pcd_args in 
  let core_type_exprs, pats  = List.rev core_type_exprs, List.rev pats in
  Pat.construct {txt = Lident txt ; loc}
    (if last_i = 0 then 
       None
     else if last_i = 1 then 
       Some (List.hd pats) 
     else
       Some (Pat.tuple pats)  ), core_type_exprs


let case_of_ctdcl (ctdcls : Parsetree.constructor_declaration list) = 
    Exp.function_ 
      (List.mapi (fun i ctdcl -> 
           let pat, core_type_exprs = destruct_constructor_declaration ctdcl in 
           Exp.case pat 
             (Exp.apply 
                (js_dyn_variant_to_value ())
                [("", Exp.ident {txt = Lident shape ; loc});
                 ("", Ast_derive_util.lift_int i);
                 ("", exp_of_core_type_exprs core_type_exprs);
                ]
             )) ctdcls
      )
let record args = 
  Exp.apply 
    (Exp.ident {txt = Ldot (Lident js_dyn, record_to_value ); loc})
    ["", Exp.ident {txt = Lident shape ; loc};
     ("",  args)
    ]      


let fun_1 name = 
  Exp.fun_ "" None ~attrs:bs_attrs 
    (Pat.var {txt = "x"; loc})
    (Exp.apply (Exp.ident name)
       ["",(Exp.ident {txt = Lident "x"; loc})])

let record_exp  name core_type  labels : Ast_structure.t = 
  let arg_name : string = "args" in
  let core_type_exprs, labels = 
    Ast_derive_util.destruct_label_declarations ~loc arg_name labels in

  [Str.value Nonrecursive @@ 
   [Vb.mk 
     (Pat.var {txt = shape;  loc}) 
     (Exp.apply (js_dyn_shape_of_record ())
        ["", (Ast_derive_util.lift_string_list_to_array labels)]
     ) ];
   Str.value Nonrecursive @@ 
   [Vb.mk (Pat.var {txt = name ^ to_value_  ; loc })
      (Ast_derive_util.mk_fun ~loc core_type arg_name 
         (record (exp_of_core_type_exprs core_type_exprs))
      )];
   Str.value Nonrecursive @@
   [Vb.mk (Pat.var {txt = name ^ to_value; loc})
      ( fun_1 { txt = Lident (name ^ to_value_) ;loc})
   ]        
  ]



let init ()  =
  Ast_derive.update 
    "dynval"
    begin fun (x : Parsetree.expression option) -> 
      match x with 
      | Some {pexp_loc = loc} 
        -> Location.raise_errorf ~loc "such configuration is not supported"
      | None -> 
        {Ast_derive.structure_gen = 
           begin  fun (tdcl  : Parsetree.type_declaration list) explict_nonrec ->
             begin match tdcl with 
               | [tdcl] -> 
                 let core_type = Ast_derive_util.core_type_of_type_declaration  tdcl in 
                 let name = tdcl.ptype_name.txt in
                 let loc = tdcl.ptype_loc in 
                 let signatures = 
                   [Sig.value ~loc 
                      (Val.mk {txt =  name ^ to_value  ; loc}
                         (js_dyn_to_value_uncurry_type core_type))
                   ] in
                 let constraint_ strs = 
                   [Ast_structure.constraint_  ~loc strs signatures] in
                 begin match tdcl with 
                   | {ptype_params = [];
                      ptype_kind  = Ptype_variant cd;
                      ptype_loc = loc;
                     } -> 
                     if explict_nonrec then 
                       let names, arities = 
                         List.fold_right 
                           (fun (ctdcl : Parsetree.constructor_declaration) 
                             (names,arities) -> 
                             ctdcl.pcd_name.txt :: names, 
                             List.length ctdcl.pcd_args :: arities
                           ) cd ([],[]) in 
                       constraint_ 
                         [
                           Str.value Nonrecursive @@ 
                           [Vb.mk (Pat.var {txt = shape ; loc})
                              (      Exp.apply (js_dyn_shape_of_variant ())
                                       [ "", (Ast_derive_util.lift_string_list_to_array names);
                                         "", (Ast_derive_util.lift_int_list_to_array arities )
                                       ])];
                           Str.value Nonrecursive @@ 
                           [Vb.mk (Pat.var {txt = name ^ to_value_  ; loc})
                              (case_of_ctdcl cd)
                           ];
                           Str.value Nonrecursive @@
                           [Vb.mk (Pat.var {txt = name ^ to_value; loc})
                              ( fun_1 { txt = Lident (name ^ to_value_) ;loc})
                           ]        
                         ]
                     else 
                       []
                   | {ptype_params = []; 
                      ptype_kind = Ptype_abstract; 
                      ptype_manifest = Some x 
                     } -> (** case {[ type t = int ]}*)
                     constraint_ 
                       [
                         Str.value Nonrecursive @@ 
                         [Vb.mk (Pat.var {txt = name ^ to_value  ; loc})
                            (exp_of_core_type to_value x)
                         ]
                       ]

                   |{ptype_params = [];
                     ptype_kind  = Ptype_record labels;
                     ptype_loc = loc;
                    } -> 
                     if explict_nonrec then constraint_ (record_exp name core_type labels) 
                     else []

                   | _ -> 
                     []
                 end
               | _ -> []
              end
            end
              ; 
           expression_gen =  Some begin fun core_type -> 
               exp_of_core_type to_value core_type
             end;
           signature_gen = 
             begin fun 
               (tdcls : Parsetree.type_declaration list)
               (explict_nonrec : bool) -> 
               let handle_tdcl tdcl = 
                 let core_type = Ast_derive_util.core_type_of_type_declaration tdcl in 
                 let name = tdcl.ptype_name.txt in
                 let loc = tdcl.ptype_loc in 
                 Sig.value ~loc (Val.mk {txt = name ^ to_value  ; loc}
                                   (js_dyn_to_value_uncurry_type core_type)) in 
               Ext_list.map handle_tdcl tdcls 

             end

         }
     end

end
module Ast_derive_projector : sig 
#1 "ast_derive_projector.mli"
val init : unit -> unit

end = struct
#1 "ast_derive_projector.ml"
open Ast_helper


let init () =
  Ast_derive.update 
    "accessors" 
    begin fun (x : Parsetree.expression option) ->
       match x with 
       | Some {pexp_loc = loc} 
         -> Location.raise_errorf ~loc "such configuration is not supported"
       | None -> 
         {structure_gen = 
            begin fun (tdcls : Parsetree.type_declaration list) _explict_nonrec ->
              let handle_tdcl tdcl = 
                let core_type = Ast_derive_util.core_type_of_type_declaration tdcl in 
                match tdcl with 
                | {ptype_kind = 
                     Ptype_record label_declarations }
                  -> 
                  label_declarations 
                  |> 
                  Ext_list.map (fun ({pld_name = {loc; txt = pld_label} as pld_name} : Parsetree.label_declaration) -> 
                      let txt = "param" in
                      Str.value Nonrecursive

                        [Vb.mk (Pat.var pld_name) @@
                         Exp.fun_ "" None
                           (Pat.constraint_ (Pat.var {txt ; loc}) core_type )
                           (Exp.field (Exp.ident {txt = Lident txt ; loc}) 
                              {txt = Longident.Lident pld_label ; loc}) ]
                    )
                | {ptype_kind = 
                     Ptype_variant constructor_declarations 
                  } 
                  -> 
                  constructor_declarations
                  |> 
                  Ext_list.map 
                    (fun
                      ( {pcd_name = {loc ; txt = con_name} ; pcd_args ; pcd_loc }:
                          Parsetree.constructor_declaration)
                      -> (* TODO: add type annotations *)
                        let little_con_name = String.uncapitalize con_name  in
                        let arity = List.length pcd_args in 
                        if arity = 0 then 
                          Str.value Nonrecursive 
                            [Vb.mk  
                               (Pat.var  {loc ; txt = little_con_name})
                               (Exp.constraint_
                                  (Exp.construct {loc ; txt = Longident.Lident con_name } None)
                                  core_type
                               )
                            ]
                        else 
                          begin 
                            let vars = 
                              Ext_list.init  arity (fun x -> "param_" ^ string_of_int x ) in 
                            let exp = 
                              Exp.constraint_
                                ( 
                                  Exp.construct {loc ; txt = Longident.Lident con_name} @@ 
                                  Some
                                    ( 
                                      if  arity = 1 then 
                                        Exp.ident { loc ; txt = Longident.Lident (List.hd vars )}
                                      else 
                                        Exp.tuple (Ext_list.map 
                                                     (fun x -> Exp.ident {loc ; txt = Longident.Lident x})
                                                     vars 
                                                  ) )) core_type
                            in 
                            let fun_ = 
                              List.fold_right  (fun var b -> 
                                  Exp.fun_ "" None  (Pat.var {loc ; txt = var}) b 
                                ) vars exp  in 

                            Str.value Nonrecursive
                              [
                                Vb.mk 
                                  (Pat.var { loc ; txt  = little_con_name} )
                                  fun_
                              ]
                          end
                    )
                | _ -> []
                (* Location.raise_errorf "projector only works with record" *)
              in Ext_list.flat_map handle_tdcl tdcls


            end;
          signature_gen = 
            begin fun (tdcls : Parsetree.type_declaration list) _explict_nonrec -> 
              let handle_tdcl tdcl = 
                let core_type = Ast_derive_util.core_type_of_type_declaration tdcl in 
                match tdcl with 
                | {ptype_kind = 
                     Ptype_record label_declarations }
                  -> 
                  label_declarations 
                  |> 
                  Ext_list.map (fun 
                             ({pld_name = {loc; txt = pld_label} as pld_name;
                               pld_type
                              } : 
                                Parsetree.label_declaration) -> 
                             Sig.value 
                               (Val.mk pld_name 
                                  (Typ.arrow "" core_type pld_type )))
                | {ptype_kind = 
                     Ptype_variant constructor_declarations 
                  } -> 
                  constructor_declarations
                  |>
                  Ext_list.map
                    (fun  ({pcd_name = {loc ; txt = con_name} ; pcd_args ; pcd_loc }:
                             Parsetree.constructor_declaration)
                      -> 
                        Sig.value 
                          (Val.mk {loc ; txt = (String.uncapitalize con_name)}
                             
                           (List.fold_right 
                              (fun x acc -> Typ.arrow "" x acc) 
                              pcd_args
                              core_type)
                          )
                    )
                           
                  | _ -> [] 
              in 
              Ext_list.flat_map handle_tdcl tdcls
            end;
          expression_gen = None
         }
    end


end
module Bs_loc : sig 
#1 "bs_loc.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type t = Location.t = {
  loc_start : Lexing.position;
  loc_end : Lexing.position ; 
  loc_ghost : bool
} 

val is_ghost : t -> bool
val merge : t -> t -> t 
val none : t 


end = struct
#1 "bs_loc.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


type t = Location.t = {
  loc_start : Lexing.position;
  loc_end : Lexing.position ; 
  loc_ghost : bool
} 

let is_ghost x = x.loc_ghost

let merge (l: t) (r : t) = 
  if is_ghost l then r 
  else if is_ghost r then l 
  else match l,r with 
  | {loc_start ; }, {loc_end; _} (* TODO: improve*)
    -> 
    {loc_start ;loc_end; loc_ghost = false}

let none = Location.none

end
module Ast_external_attributes : sig 
#1 "ast_external_attributes.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)





(**
   return value is of [pval_type, pval_prim]
*)    
val handle_attributes_as_string : 
  Bs_loc.t ->
  string  ->
  Ast_core_type.t ->
  Ast_attributes.t -> 
  string   ->
  Ast_core_type.t * string list * Ast_attributes.t





val pval_prim_of_labels : string Asttypes.loc list -> string list



end = struct
#1 "ast_external_attributes.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


[@@@ocaml.warning "+9"]



let variant_can_bs_unwrap_fields row_fields =
  let validity = (List.fold_left
     begin fun st row ->
       match st, row with
       | (* we've seen no fields or only valid fields so far *)
         (`No_fields | `Valid_fields),
         (* and this field has one constructor arg that we can unwrap to *)
         Parsetree.Rtag (label, attrs, false, ([ _ ]))
         ->
         `Valid_fields
       | (* otherwise, this field or a previous field was invalid *)
         _ ->
         `Invalid_field
     end
     `No_fields
     row_fields
  )
  in
  match validity with
  | `Valid_fields -> true
  | `No_fields
  | `Invalid_field -> false

(** Given the type of argument, process its [bs.] attribute and new type,
    The new type is currently used to reconstruct the external type 
    and result type in [@@bs.obj]
    They are not the same though, for example
    {[
      external f : hi:([ `hi | `lo ] [@bs.string]) -> unit -> _ = "" [@@bs.obj]
    ]}
    The result type would be [ hi:string ]
*)
let get_arg_type ~nolabel optional 
    (ptyp : Ast_core_type.t) : 
  Ast_arg.ty * Ast_core_type.t  = 
  let ptyp = if optional then Ast_core_type.extract_option_type_exn ptyp else ptyp in 
  if Ast_core_type.is_any ptyp then (* (_[@bs.as ])*)
    if optional then 
      Bs_syntaxerr.err ptyp.ptyp_loc Invalid_underscore_type_in_external
    else begin
      match Ast_attributes.process_bs_string_or_int_as ptyp.Parsetree.ptyp_attributes with 
      |  None, _ -> 
        Bs_syntaxerr.err ptyp.ptyp_loc Invalid_underscore_type_in_external

      | Some (`Int i), others -> 
        Ast_attributes.warn_unused_attributes others;
        Arg_cst(Ast_arg.cst_int i), Ast_literal.type_int ~loc:ptyp.ptyp_loc ()  
      | Some (`Str i), others -> 
        Ast_attributes.warn_unused_attributes others;
        Arg_cst (Ast_arg.cst_string i), Ast_literal.type_string ~loc:ptyp.ptyp_loc () 
      | Some (`Json_str s), others ->
        Ast_attributes.warn_unused_attributes others;
        Arg_cst (Ast_arg.cst_json ptyp.ptyp_loc s),
        Ast_literal.type_string ~loc:ptyp.ptyp_loc () 

    end 
  else (* ([`a|`b] [@bs.string]) *)
    match Ast_attributes.process_bs_string_int_unwrap_uncurry ptyp.ptyp_attributes, ptyp.ptyp_desc with
    | (`String, ptyp_attributes),  Ptyp_variant ( row_fields, Closed, None)
      -> 
      let case, result, row_fields  = 
        (List.fold_right (fun tag (nullary, acc, row_fields) -> 
             match nullary, tag with 
             | (`Nothing | `Null), 
               Parsetree.Rtag (label, attrs, true,  [])
               -> 
               begin match Ast_attributes.process_bs_string_as attrs with 
                 | Some name, new_attrs  -> 
                   `Null, ((Ext_pervasives.hash_variant label, name) :: acc ), 
                   Parsetree.Rtag(label, new_attrs, true, []) :: row_fields

                 | None, _ -> 
                   `Null, ((Ext_pervasives.hash_variant label, label) :: acc ), 
                   tag :: row_fields
               end
             | (`Nothing | `NonNull), Parsetree.Rtag(label, attrs, false, ([ _ ] as vs)) 
               -> 
               begin match Ast_attributes.process_bs_string_as attrs with 
                 | Some name, new_attrs -> 
                   `NonNull, ((Ext_pervasives.hash_variant label, name) :: acc),
                   Parsetree.Rtag (label, new_attrs, false, vs) :: row_fields
                 | None, _ -> 
                   `NonNull, ((Ext_pervasives.hash_variant label, label) :: acc),
                   (tag :: row_fields)
               end
             | _ -> Bs_syntaxerr.err ptyp.ptyp_loc Invalid_bs_string_type

           ) row_fields (`Nothing, [], [])) in 
      (match case with 
       | `Nothing -> Bs_syntaxerr.err ptyp.ptyp_loc Invalid_bs_string_type
       | `Null -> NullString result 
       | `NonNull -> NonNullString result) , 
      {ptyp with ptyp_desc = Ptyp_variant(row_fields, Closed, None);
                 ptyp_attributes ;
      }
    | (`String, _),  _ ->
      Bs_syntaxerr.err ptyp.ptyp_loc Invalid_bs_string_type
    | (`Ignore, ptyp_attributes), _  -> 
      (Ignore, {ptyp with ptyp_attributes})
    | (`Int , ptyp_attributes),  Ptyp_variant ( row_fields, Closed, None) -> 
      let _, acc, rev_row_fields = 
        (List.fold_left 
           (fun (i,acc, row_fields) rtag -> 
              match rtag with 
              | Parsetree.Rtag (label, attrs, true,  [])
                -> 
                begin match Ast_attributes.process_bs_int_as attrs with 
                  | Some i, new_attrs -> 
                    i + 1, ((Ext_pervasives.hash_variant label , i):: acc ), 
                    Parsetree.Rtag (label, new_attrs, true, []) :: row_fields
                  | None, _ -> 
                    i + 1 , ((Ext_pervasives.hash_variant label , i):: acc ), rtag::row_fields
                end

              | _ -> 
                Bs_syntaxerr.err ptyp.ptyp_loc Invalid_bs_int_type

           ) (0, [],[]) row_fields) in 
      Int (List.rev acc),
      {ptyp with 
       ptyp_desc = Ptyp_variant(List.rev rev_row_fields, Closed, None );
       ptyp_attributes
      }
    | (`Int, _), _ -> Bs_syntaxerr.err ptyp.ptyp_loc Invalid_bs_int_type
    | (`Unwrap, ptyp_attributes), (Ptyp_variant (row_fields, Closed, _) as ptyp_desc)
      when variant_can_bs_unwrap_fields row_fields
      ->
      Unwrap, {ptyp with ptyp_desc; ptyp_attributes}
    | (`Unwrap, _), _ ->
      Bs_syntaxerr.err ptyp.ptyp_loc Invalid_bs_unwrap_type
    | (`Uncurry opt_arity, ptyp_attributes), ptyp_desc -> 
      let real_arity =  Ast_core_type.get_uncurry_arity ptyp in 
      (begin match opt_arity, real_arity with 
         | Some arity, `Not_function -> 
           Fn_uncurry_arity arity 
         | None, `Not_function  ->
           Bs_syntaxerr.err ptyp.ptyp_loc Canot_infer_arity_by_syntax
         | None, `Arity arity  ->         
           Fn_uncurry_arity arity
         | Some arity, `Arity n -> 
           if n <> arity then
             Bs_syntaxerr.err ptyp.ptyp_loc (Inconsistent_arity (arity,n))
           else Fn_uncurry_arity arity 

       end, {ptyp with ptyp_attributes})
    | (`Nothing, ptyp_attributes),  ptyp_desc ->
      begin match ptyp_desc with
        | Ptyp_constr ({txt = Lident "bool"; _}, [])
          -> 
          Bs_warnings.prerr_warning ptyp.ptyp_loc Unsafe_ffi_bool_type;
          Nothing
        | Ptyp_constr ({txt = Lident "unit"; _}, [])
          -> if nolabel then Extern_unit else  Nothing
        | Ptyp_constr ({txt = Lident "array"; _}, [_])
          -> Array
        | Ptyp_variant _ ->
          Bs_warnings.prerr_warning ptyp.ptyp_loc Unsafe_poly_variant_type;
          Nothing           
        | _ ->
          Nothing           
      end, ptyp



(** 
   [@@bs.module "react"]
   [@@bs.module "react"]
   ---
   [@@bs.module "@" "react"]
   [@@bs.module "@" "react"]

   They should have the same module name 

   TODO: we should emit an warning if we bind 
   two external files to the same module name
*)
type bundle_source =
  [`Nm_payload of string (* from payload [@@bs.val "xx" ]*)
  |`Nm_external of string (* from "" in external *)
  | `Nm_val of string   (* from function name *)   
  ]  

let string_of_bundle_source (x : bundle_source) =
  match x with
  | `Nm_payload x
  | `Nm_external x
  | `Nm_val x -> x   
type name_source =
  [ bundle_source  
  | `Nm_na

  ]




type st = 
  { val_name : name_source;
    external_module_name : Ast_ffi_types.external_module_name option;
    module_as_val : Ast_ffi_types.external_module_name option;
    val_send : name_source ;
    val_send_pipe : Ast_core_type.t option;    
    splice : bool ; (* mutable *)
    scopes : string list ; 
    set_index : bool; (* mutable *)
    get_index : bool;
    new_name : name_source ;
    call_name : name_source ;
    set_name : name_source ;
    get_name : name_source ;

    mk_obj : bool ;
    return_wrapper : Ast_ffi_types.return_wrapper ;

  }

let init_st = 
  {
    val_name = `Nm_na; 
    external_module_name = None ;
    module_as_val = None;
    val_send = `Nm_na;
    val_send_pipe = None;    
    splice = false;
    scopes = [];
    set_index = false;
    get_index = false;
    new_name = `Nm_na;
    call_name = `Nm_na;
    set_name = `Nm_na ;
    get_name = `Nm_na ;
    mk_obj = false ; 
    return_wrapper = Return_unset; 

  }





let process_external_attributes 
    no_arguments 
    (prim_name_or_pval_prim: [< bundle_source ] as 'a)
    pval_prim
    (prim_attributes : Ast_attributes.t) : _ * Ast_attributes.t =

  (* shared by `[@@bs.val]`, `[@@bs.send]`, 
     `[@@bs.set]`, `[@@bs.get]` , `[@@bs.new]` 
     `[@@bs.send.pipe]` does not use it 
  *)
  let name_from_payload_or_prim ~loc (payload : Parsetree.payload) : name_source =
    match payload with 
    | PStr [] -> 
      (prim_name_or_pval_prim :> name_source)  
    (* It is okay to have [@@bs.val] without payload *)
    | _ -> 
      begin match Ast_payload.is_single_string payload with
        | Some  (val_name, _) ->  `Nm_payload val_name
        | None ->  
          Location.raise_errorf ~loc "Invalid payload"
      end

  in
  List.fold_left 
    (fun (st, attrs)
      (({txt ; loc}, payload) as attr : Ast_attributes.attr) 
      ->
        if Ext_string.starts_with txt "bs." then
          begin match txt with 
            | "bs.val" ->  
              if no_arguments then
                {st with val_name = name_from_payload_or_prim ~loc payload}
              else 
                {st with call_name = name_from_payload_or_prim ~loc  payload}

            | "bs.module" -> 
              begin match Ast_payload.assert_strings loc payload with 
                | [name] ->
                  {st with external_module_name =
                             Some {bundle=name; bind_name = None}}
                | [bundle;bind_name] -> 
                  {st with external_module_name =
                             Some {bundle; bind_name = Some bind_name}}
                | [] ->
                  { st with
                    module_as_val = 
                      Some
                        { bundle =
                            string_of_bundle_source
                              (prim_name_or_pval_prim :> bundle_source) ;
                          bind_name = Some pval_prim}
                  }
                | _  ->
                  Bs_syntaxerr.err loc Illegal_attribute
              end
            | "bs.scope" ->
              begin match Ast_payload.assert_strings loc payload with 
              | [] -> 
                Bs_syntaxerr.err loc Illegal_attribute 
                  (* We need err on empty scope, so we can tell the difference 
                     between unset/set
                  *)
              | scopes ->  { st with scopes = scopes }
              end
            | "bs.splice" -> {st with splice = true}
            | "bs.send" -> 
              { st with val_send = name_from_payload_or_prim ~loc payload}
            | "bs.send.pipe"
              ->
              { st with val_send_pipe = Some (Ast_payload.as_core_type loc payload)}                
            | "bs.set" -> 
              {st with set_name = name_from_payload_or_prim ~loc  payload}
            | "bs.get" -> {st with get_name = name_from_payload_or_prim ~loc payload}

            | "bs.new" -> {st with new_name = name_from_payload_or_prim ~loc payload}
            | "bs.set_index" -> {st with set_index = true}
            | "bs.get_index"-> {st with get_index = true}
            | "bs.obj" -> {st with mk_obj = true}
            | "bs.return" ->
              let aux loc txt : Ast_ffi_types.return_wrapper = 
                begin match txt with 
                  | "undefined_to_opt" -> Return_undefined_to_opt
                  | "null_to_opt" -> Return_null_to_opt
                  | "nullable"
                  | "null_undefined_to_opt" -> Return_null_undefined_to_opt
                  | "identity" -> Return_identity 
                  | _ ->
                    Bs_syntaxerr.err loc Not_supported_directive_in_bs_return
                  end in
                  let actions = 
                    Ast_payload.ident_or_record_as_config loc payload 
                  in
                  begin match actions with 
                    | [ ({txt; _ },None) ] -> 
                      { st with return_wrapper = aux loc txt}
                    | _ ->
                      Bs_syntaxerr.err loc Not_supported_directive_in_bs_return
                  end
            | _ -> (Bs_warnings.warn_unused_attribute loc txt; st)
          end, attrs
        else (st , attr :: attrs)
    )
    (init_st, []) prim_attributes 


let rec has_bs_uncurry (attrs : Ast_attributes.t) = 
  match attrs with 
  | ({txt = "bs.uncurry"; _ }, _) :: attrs -> 
    true 
  | _ :: attrs -> has_bs_uncurry attrs 
  | [] -> false 


let check_return_wrapper 
    loc (wrapper : Ast_ffi_types.return_wrapper) 
    result_type = 
  match wrapper with 
  | Return_identity -> wrapper
  | Return_unset  ->         
    if Ast_core_type.is_unit result_type then 
      Return_replaced_with_unit 
    else if Ast_core_type.is_user_bool result_type then 
      Return_to_ocaml_bool
    else 
      wrapper
  | Return_undefined_to_opt
  | Return_null_to_opt 
  | Return_null_undefined_to_opt  
    -> 
    if Ast_core_type.is_user_option result_type then 
      wrapper
    else
      Bs_syntaxerr.err loc Expect_opt_in_bs_return_to_opt
  | Return_replaced_with_unit 
  | Return_to_ocaml_bool  -> 
    assert false (* Not going to happen from user input*)




(** Note that the passed [type_annotation] is already processed by visitor pattern before 
*)
let handle_attributes 
    (loc : Bs_loc.t)
    (pval_prim : string ) 
    (type_annotation : Parsetree.core_type)
    (prim_attributes : Ast_attributes.t) (prim_name : string)
  : Ast_core_type.t * string * Ast_ffi_types.t * Ast_attributes.t =
  (** sanity check here 
      {[ int -> int -> (int -> int -> int [@bs.uncurry])]}
      It does not make sense 
  *)
  if has_bs_uncurry type_annotation.Parsetree.ptyp_attributes then 
    begin 
      Location.raise_errorf 
        ~loc "[@@bs.uncurry] can not be applied to the whole defintion"
    end; 

  let prim_name_or_pval_prim =
    if String.length prim_name = 0 then  `Nm_val pval_prim
    else  `Nm_external prim_name  (* need check name *)
  in    
  let result_type, arg_types_ty =
    Ast_core_type.list_of_arrow type_annotation in
  if has_bs_uncurry result_type.ptyp_attributes then 
    begin 
      Location.raise_errorf 
        ~loc:result_type.ptyp_loc
        "[@@bs.uncurry] can not be applied to tailed position"
    end ;
  let (st, left_attrs) = 
    process_external_attributes 
      (arg_types_ty = [])
      prim_name_or_pval_prim pval_prim prim_attributes in 


  if st.mk_obj then 
    begin match st with 
      | {
        val_name = `Nm_na; 
        external_module_name = None ;
        module_as_val = None;
        val_send = `Nm_na;
        val_send_pipe = None;    
        splice = false;
        new_name = `Nm_na;
        call_name = `Nm_na;
        set_name = `Nm_na ;
        get_name = `Nm_na ;
        get_index = false ;
        return_wrapper = Return_unset ;        
        set_index = false ; 
        mk_obj = _; 
        scopes = [];
        (* wrapper does not work with [bs.obj]
           TODO: better error message *)
      } -> 
        if String.length prim_name <> 0 then 
          Location.raise_errorf ~loc "[@@bs.obj] expect external names to be empty string";
        let arg_kinds, new_arg_types_ty, result_types = 
          List.fold_right 
            (fun (label,ty,attr,loc) ( arg_labels, arg_types, result_types) -> 
               let arg_label = Ast_core_type.label_name label in 
               let new_arg_label, new_arg_types,  output_tys = 
                 match arg_label with 
                 | Empty -> 
                   let arg_type, new_ty = get_arg_type ~nolabel:true false ty in 
                   begin match arg_type with 
                     | Extern_unit ->  
                       Ast_arg.empty_kind arg_type, (label,new_ty,attr,loc)::arg_types, result_types
                     | _ ->  
                       Location.raise_errorf ~loc "expect label, optional, or unit here"
                   end 
                 | Label name -> 
                   let arg_type, new_ty = get_arg_type ~nolabel:false false ty in 
                   begin match arg_type with 
                     | Ignore -> 
                       Ast_arg.empty_kind arg_type, 
                       (label,new_ty,attr,loc)::arg_types, result_types
                     | Arg_cst  i  -> 
                       let s = (Lam_methname.translate ~loc name) in
                       {arg_label = Ast_arg.label s (Some i);
                        arg_type }, 
                       arg_types, (* ignored in [arg_types], reserved in [result_types] *)
                       ((name , [], new_ty) :: result_types)
                     | Nothing | Array -> 
                       let s = (Lam_methname.translate ~loc name) in
                       {arg_label = Ast_arg.label s None ; arg_type },
                       (label,new_ty,attr,loc)::arg_types, 
                       ((name , [], new_ty) :: result_types)
                     | Int _  -> 
                       let s = Lam_methname.translate ~loc name in
                       {arg_label = Ast_arg.label s None; arg_type},
                       (label,new_ty,attr,loc)::arg_types, 
                       ((name, [], Ast_literal.type_int ~loc ()) :: result_types)  
                     | NullString _ -> 
                       let s = Lam_methname.translate ~loc name in
                       {arg_label = Ast_arg.label s None; arg_type}, 
                       (label,new_ty,attr,loc)::arg_types, 
                       ((name, [], Ast_literal.type_string ~loc ()) :: result_types)  
                     | Fn_uncurry_arity _ -> 
                       Location.raise_errorf ~loc
                         "The combination of [@@bs.obj], [@@bs.uncurry] is not supported yet"
                     | Extern_unit -> assert false 
                     | NonNullString _ 
                       ->  
                       Location.raise_errorf ~loc 
                         "bs.obj label %s does not support such arg type" name
                     | Unwrap ->
                       Location.raise_errorf ~loc
                         "bs.obj label %s does not support [@bs.unwrap] arguments" name
                   end
                 | Optional name -> 
                   let arg_type, new_ty_extract = get_arg_type ~nolabel:false true ty in 
                   let new_ty = Ast_core_type.lift_option_type new_ty_extract in 
                   begin match arg_type with 
                     | Ignore -> 
                       Ast_arg.empty_kind arg_type, 
                       (label,new_ty,attr,loc)::arg_types, result_types

                     | Nothing | Array -> 
                       let s = (Lam_methname.translate ~loc name) in 
                       {arg_label = Ast_arg.optional s; arg_type}, 
                       (label,new_ty,attr,loc)::arg_types, 
                       ( (name, [], Ast_comb.to_undefined_type loc new_ty_extract) ::  result_types)
                     | Int _  -> 
                       let s = Lam_methname.translate ~loc name in 
                       {arg_label = Ast_arg.optional s ; arg_type },
                       (label,new_ty,attr,loc)::arg_types,
                       ((name, [], Ast_comb.to_undefined_type loc @@ Ast_literal.type_int ~loc ()) :: result_types)                      
                     | NullString _  -> 
                       let s = Lam_methname.translate ~loc name in 
                       {arg_label = Ast_arg.optional s ; arg_type }, 
                       (label,new_ty,attr,loc)::arg_types,
                       ((name, [], Ast_comb.to_undefined_type loc @@ Ast_literal.type_string ~loc ()) :: result_types)                      
                     | Arg_cst _   
                       -> 
                       Location.raise_errorf ~loc "bs.as is not supported with optional yet"
                     | Fn_uncurry_arity _ -> 
                       Location.raise_errorf ~loc
                         "The combination of [@@bs.obj], [@@bs.uncurry] is not supported yet"                      
                     | Extern_unit   -> assert false                      
                     | NonNullString _ 
                       ->  
                       Location.raise_errorf ~loc
                         "bs.obj label %s does not support such arg type" name                        
                     | Unwrap ->
                       Location.raise_errorf ~loc
                         "bs.obj label %s does not support [@bs.unwrap] arguments" name
                   end
               in     
               (
                 new_arg_label::arg_labels,
                 new_arg_types,
                 output_tys)) arg_types_ty 
            ( [], [], []) in 

        let result = 
          if Ast_core_type.is_any  result_type then            
            Ast_core_type.make_obj ~loc result_types 
          else           
            snd @@ get_arg_type ~nolabel:true false result_type (* result type can not be labeled *)            

        in
        begin 
          (             
            List.fold_right (fun (label,ty,attrs,loc) acc -> 
                Ast_helper.Typ.arrow ~loc  ~attrs label ty acc 
              ) new_arg_types_ty result
          ) ,
          prim_name,
          Ffi_obj_create arg_kinds,
          left_attrs
        end

      | _ -> Location.raise_errorf ~loc "Attribute found that conflicts with [@@bs.obj]"  

    end  

  else   
    let splice = st.splice in 
    let arg_type_specs, new_arg_types_ty, arg_type_specs_length   = 
      List.fold_right 
        (fun (label,ty,attr,loc) (arg_type_specs, arg_types, i) -> 
           let arg_label = Ast_core_type.label_name label in 
           let arg_label, arg_type, new_arg_types = 
             match arg_label with 
             | Optional s  -> 

               let arg_type , new_ty = get_arg_type ~nolabel:false true ty in 
               begin match arg_type with 
                 | NonNullString _ -> 
                   (* ?x:([`x of int ] [@bs.string]) does not make sense *)
                   Location.raise_errorf 
                     ~loc
                     "[@@bs.string] does not work with optional when it has arities in label %s" label
                 | _ -> 
                   Ast_arg.optional s, arg_type, 
                   ((label, Ast_core_type.lift_option_type new_ty , attr,loc) :: arg_types) end
             | Label s  -> 
               begin match get_arg_type ~nolabel:false false  ty with
                 | (Arg_cst ( i) as arg_type), new_ty -> 
                   Ast_arg.label s (Some i), arg_type, arg_types
                 | arg_type, new_ty -> 
                   Ast_arg.label s None, arg_type, (label, new_ty,attr,loc) :: arg_types
               end
             | Empty -> 
               begin match get_arg_type ~nolabel:true false  ty with 
                 | (Arg_cst ( i) as arg_type), new_ty -> 
                   Ast_arg.empty_lit i , arg_type,  arg_types
                 | arg_type, new_ty -> 
                   Ast_arg.empty_label, arg_type, (label, new_ty,attr,loc) :: arg_types
               end
           in
           (if i = 0 && splice  then
              match arg_type with 
              | Array  -> ()
              | _ ->  Location.raise_errorf ~loc "[@@bs.splice] expect last type to array");
           ({ Ast_arg.arg_label  ; 
              arg_type 
            } :: arg_type_specs,
            new_arg_types,
            if arg_type = Ignore then i 
            else i + 1
            )
        ) arg_types_ty 
        (match st with
         | {val_send_pipe = Some obj; _ } ->      
           let arg_type, new_ty = get_arg_type ~nolabel:true false obj in 
           begin match arg_type with 
             | Arg_cst _ -> 
               Location.raise_errorf ~loc:obj.ptyp_loc "[@bs.as] is not supported in bs.send type "
             | _ -> 
               (* more error checking *)
               [Ast_arg.empty_kind arg_type]
               ,
               ["", new_ty, [], obj.ptyp_loc]
               ,0
           end

         | {val_send_pipe = None ; _ } -> [],[], 0) in 

    let ffi : Ast_ffi_types.ffi  = match st with           
      | {set_index = true;

         val_name = `Nm_na; 
         external_module_name = None ;
         module_as_val = None;
         val_send = `Nm_na;
         val_send_pipe = None;    
         splice = false;
         scopes ;
         get_index = false;
         new_name = `Nm_na;
         call_name = `Nm_na;
         set_name = `Nm_na ;
         get_name = `Nm_na ;

         return_wrapper = _; 
         mk_obj = _ ; 

        } 
        ->
        if String.length prim_name <> 0 then 
          Location.raise_errorf ~loc "[@@bs.set_index] expect external names to be empty string";
        if arg_type_specs_length = 3 then 
          Js_set_index {js_set_index_scopes = scopes}
        else 
          Location.raise_errorf ~loc "Ill defined attribute [@@bs.set_index](arity of 3)"

      | {set_index = true; _}
        ->
        Bs_syntaxerr.err loc (Conflict_ffi_attribute "Attribute found that conflicts with [@@bs.set_index]")


      | {get_index = true;

         val_name = `Nm_na; 
         external_module_name = None ;
         module_as_val = None;
         val_send = `Nm_na;
         val_send_pipe = None;    

         splice = false;
         scopes ;
         new_name = `Nm_na;
         call_name = `Nm_na;
         set_name = `Nm_na ;
         get_name = `Nm_na ;
         set_index = false; 
         mk_obj;
         return_wrapper ; 
        } ->
        if String.length prim_name <> 0 then 
          Location.raise_errorf ~loc "[@@bs.get_index] expect external names to be empty string";
        if arg_type_specs_length = 2 then 
          Js_get_index {js_get_index_scopes = scopes}
        else Location.raise_errorf ~loc 
        "Ill defined attribute [@@bs.get_index] (arity expected 2 : while %d)" arg_type_specs_length

      | {get_index = true; _}

        -> 
        Bs_syntaxerr.err loc (Conflict_ffi_attribute "Attribute found that conflicts with [@@bs.get_index]")




      | {module_as_val = Some external_module_name ;

         get_index = false;
         val_name ;
         new_name ;

         external_module_name = None ;
         val_send = `Nm_na;
         val_send_pipe = None;    
         scopes = []; (* module as var does not need scopes *)
         splice;
         call_name = `Nm_na;
         set_name = `Nm_na ;
         get_name = `Nm_na ;         
         set_index = false; 
         return_wrapper = _; 
         mk_obj = _ ;
         } ->
        begin match arg_types_ty, new_name, val_name  with         
          | [], `Nm_na,  _ -> Js_module_as_var external_module_name
          | _, `Nm_na, _ -> Js_module_as_fn {splice; external_module_name }
          | _, #bundle_source, #bundle_source ->
            Bs_syntaxerr.err loc (Conflict_ffi_attribute "Attribute found that conflicts with [@@bs.module].")

          | _, (`Nm_val _ | `Nm_external _) , `Nm_na
            -> Js_module_as_class external_module_name
          | _, `Nm_payload _ , `Nm_na
            ->
            Location.raise_errorf ~loc
              "Incorrect FFI attribute found: (bs.new should not carry a payload here)"
        end
      | {module_as_val = Some x; _}
        -> 
        Bs_syntaxerr.err loc (Conflict_ffi_attribute "Attribute found that conflicts with [@@bs.module].")

      | {call_name = (`Nm_val name | `Nm_external name | `Nm_payload name) ;
         splice; 
         scopes ;
         external_module_name;

         val_name = `Nm_na ;
         module_as_val = None;
         val_send = `Nm_na ;
         val_send_pipe = None;    

         set_index = false;
         get_index = false;
         new_name = `Nm_na;
         set_name = `Nm_na ;
         get_name = `Nm_na ;
         mk_obj = _ ; 
         return_wrapper = _ ; 
        } -> 
        Js_call {splice; name; external_module_name; scopes }
      | {call_name = #bundle_source ; _ } 
        ->
        Bs_syntaxerr.err loc (Conflict_ffi_attribute "Attribute found that conflicts with [@@bs.val]")


      | {val_name = (`Nm_val name | `Nm_external name | `Nm_payload name);
         external_module_name;

         call_name = `Nm_na ;
         module_as_val = None;
         val_send = `Nm_na ;
         val_send_pipe = None;    
         set_index = false;
         get_index = false;
         new_name = `Nm_na;
         set_name = `Nm_na ;
         get_name = `Nm_na;
         mk_obj = _; 
         return_wrapper = _; 
         splice = false ;
         scopes ;
        } 
        -> 
        Js_global { name; external_module_name; scopes}
      | {val_name = #bundle_source ; _ }
        ->
        Bs_syntaxerr.err loc (Conflict_ffi_attribute "Attribute found that conflicts with [@@bs.val]")

      | {splice ;
         scopes ;
         external_module_name = (Some _ as external_module_name);

         val_name = `Nm_na ;         
         call_name = `Nm_na ;
         module_as_val = None;
         val_send = `Nm_na ;
         val_send_pipe = None;             
         set_index = false;
         get_index = false;
         new_name = `Nm_na;
         set_name = `Nm_na ;
         get_name = `Nm_na ;
         mk_obj = _ ; 
         return_wrapper= _ ; 
        }
        ->
        let name = string_of_bundle_source prim_name_or_pval_prim in
        if arg_type_specs_length  = 0 then
          Js_global { name; external_module_name; scopes}
        else  Js_call {splice; name; external_module_name; scopes}                     
      | {val_send = (`Nm_val name | `Nm_external name | `Nm_payload name); 
         splice;
         scopes; 
         val_send_pipe = None;
         val_name = `Nm_na  ;
         call_name = `Nm_na ;
         module_as_val = None;
         set_index = false;
         get_index = false;
         new_name = `Nm_na;
         set_name = `Nm_na ;
         get_name = `Nm_na ;
         external_module_name = None ;
         mk_obj = _ ;
         return_wrapper = _ ; 
        } -> 
        if arg_type_specs_length > 0 then 
          Js_send {splice ; name; js_send_scopes = scopes ;  pipe = false}
        else 
          Location.raise_errorf ~loc "Ill defined attribute [@@bs.send] (at least one argument)"
      | {val_send = #bundle_source; _ } 
        -> Location.raise_errorf ~loc "You used an FFI attribute that can't be used with [@@bs.send]"

      | {val_send_pipe = Some typ; 
         (* splice = (false as splice); *)
         val_send = `Nm_na;
         val_name = `Nm_na  ;
         call_name = `Nm_na ;
         module_as_val = None;
         set_index = false;
         get_index = false;
         new_name = `Nm_na;
         set_name = `Nm_na ;
         get_name = `Nm_na ;
         external_module_name = None ;
         mk_obj = _;
         return_wrapper = _; 
         scopes;
         splice ; 
        } -> 
        (** can be one argument *)
        Js_send {splice  ;
                 name = string_of_bundle_source prim_name_or_pval_prim;
                 js_send_scopes = scopes;
                 pipe = true}

      | {val_send_pipe = Some _ ; _} 
        -> Location.raise_errorf ~loc "conflict attributes found with [@@bs.send.pipe]"

      | {new_name = (`Nm_val name | `Nm_external name | `Nm_payload name);
         external_module_name;

         val_name = `Nm_na  ;
         call_name = `Nm_na ;
         module_as_val = None;
         set_index = false;
         get_index = false;
         val_send = `Nm_na ;
         val_send_pipe = None;             
         set_name = `Nm_na ;
         get_name = `Nm_na ;
         splice ;
         scopes; 
         mk_obj = _ ; 
         return_wrapper = _ ; 

        } 
        -> Js_new {name; external_module_name; splice; scopes}
      | {new_name = #bundle_source ; _ }
        -> 
        Bs_syntaxerr.err loc (Conflict_ffi_attribute "Attribute found that conflicts with [@@bs.new]")


      | {set_name = (`Nm_val name | `Nm_external name | `Nm_payload name);

         val_name = `Nm_na  ;
         call_name = `Nm_na ;
         module_as_val = None;
         set_index = false;
         get_index = false;
         val_send = `Nm_na ;
         val_send_pipe = None;             
         new_name = `Nm_na ;
         get_name = `Nm_na ;
         external_module_name = None;
         splice = false; 
         mk_obj = _ ;
         return_wrapper = _; 
         scopes ;
        } 
        -> 
        if arg_type_specs_length = 2 then 
          Js_set { js_set_scopes = scopes ; js_set_name = name}
        else  Location.raise_errorf ~loc "Ill defined attribute [@@bs.set] (two args required)"
      
      | {set_name = #bundle_source; _}
        -> Location.raise_errorf ~loc "conflict attributes found with [@@bs.set]"

      | {get_name = (`Nm_val name | `Nm_external name | `Nm_payload name);

         val_name = `Nm_na  ;
         call_name = `Nm_na ;
         module_as_val = None;
         set_index = false;
         get_index = false;
         val_send = `Nm_na ;
         val_send_pipe = None;             
         new_name = `Nm_na ;
         set_name = `Nm_na ;
         external_module_name = None;
         splice = false ; 
         mk_obj = _;
         return_wrapper = _;
         scopes
        }
        ->
        if arg_type_specs_length = 1 then  
          Js_get { js_get_name = name; js_get_scopes = scopes }
        else 
          Location.raise_errorf ~loc "Ill defined attribute [@@bs.get] (only one argument)"
      | {get_name = #bundle_source; _}
        -> Location.raise_errorf ~loc "Attribute found that conflicts with [@@bs.get]"

      | {get_name = `Nm_na;
         val_name = `Nm_na  ;
         call_name = `Nm_na ;
         module_as_val = None;
         set_index = false;
         get_index = false;
         val_send = `Nm_na ;
         val_send_pipe = None;             
         new_name = `Nm_na ;
         set_name = `Nm_na ;
         external_module_name = None;
         splice = _ ; 
         scopes = _;
         mk_obj = _;
         return_wrapper = _;

        }       
       ->  Location.raise_errorf ~loc "Could not infer which FFI category it belongs to, maybe you forgot [%@%@bs.val]? "  in 
    begin 
      Ast_ffi_types.check_ffi ~loc ffi;
      (* result type can not be labeled *)
      (* currently we don't process attributes of 
         return type, in the future we may  *)
      let  new_result_type  =  result_type in
      (* get_arg_type ~nolabel:true false result_type in *)
      let return_wrapper : Ast_ffi_types.return_wrapper = 
        check_return_wrapper loc st.return_wrapper new_result_type
      in 
      (
        List.fold_right (fun (label,ty,attrs,loc) acc -> 
            Ast_helper.Typ.arrow ~loc  ~attrs label ty acc 
          ) new_arg_types_ty new_result_type
      ) ,

      prim_name,
      (Ffi_bs (arg_type_specs,return_wrapper ,  ffi)), left_attrs
    end

let handle_attributes_as_string 
    pval_loc
    pval_prim 
    (typ : Ast_core_type.t) attrs v = 
  let pval_type, prim_name, ffi, processed_attrs  = 
    handle_attributes pval_loc pval_prim typ attrs v  in
  pval_type, [prim_name; Ast_ffi_types.to_string ffi], processed_attrs



let pval_prim_of_labels labels = 
  let encoding = 
    let arg_kinds = 
      List.fold_right 
        (fun {Asttypes.loc ; txt } arg_kinds
          ->
            let arg_label =  Ast_arg.label (Lam_methname.translate ~loc txt) None in
            {Ast_arg.arg_type = Nothing ; 
             arg_label  } :: arg_kinds
        )
        labels [] in 
    Ast_ffi_types.to_string 
      (Ffi_obj_create arg_kinds)   in 
  [""; encoding]


end
module Ast_utf8_string : sig 
#1 "ast_utf8_string.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


type error 


type exn += Error of int  (* offset *) * error 

val pp_error :  Format.formatter -> error -> unit  


  
(* module Interp : sig *)
(*   val check_and_transform : int -> string -> int -> cxt -> unit *)
(*   val transform_test : string -> segments *)
(* end *)
val transform_test : string -> string 

val transform : Location.t -> string -> string      


end = struct
#1 "ast_utf8_string.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)



type error = 
  | Invalid_code_point 
  | Unterminated_backslash
  | Invalid_escape_code of char 
  | Invalid_hex_escape
  | Invalid_unicode_escape

let pp_error fmt err = 
  Format.pp_print_string fmt @@  match err with 
  | Invalid_code_point -> "Invalid code point"
  | Unterminated_backslash -> "\\ ended unexpectedly"
  | Invalid_escape_code c -> "Invalid escape code: " ^ String.make 1 c 
  | Invalid_hex_escape -> 
    "Invalid \\x escape"
  | Invalid_unicode_escape -> "Invalid \\u escape"



type exn += Error of int  (* offset *) * error 




let error ~loc error = 
  raise (Error (loc, error))

(** Note the [loc] really should be the utf8-offset, it has nothing to do with our 
    escaping mechanism
*)
(* we can not just print new line in ES5 
   seems we don't need 
   escape "\b" "\f" 
   we need escape "\n" "\r" since 
   ocaml multiple-line allows [\n]
   visual input while es5 string 
   does not*)

let rec check_and_transform (loc : int ) buf s byte_offset s_len =
  if byte_offset = s_len then ()
  else 
    let current_char = s.[byte_offset] in 
    match Ext_utf8.classify current_char with 
    | Single 92 (* '\\' *) -> 
      escape_code (loc + 1) buf s (byte_offset+1) s_len
    | Single 34 ->
      Buffer.add_string buf "\\\"";
      check_and_transform (loc + 1) buf s (byte_offset + 1) s_len
    | Single 39 -> 
      Buffer.add_string buf "\\'";
      check_and_transform (loc + 1) buf s (byte_offset + 1) s_len 
    | Single 10 ->          
      Buffer.add_string buf "\\n";
      check_and_transform (loc + 1) buf s (byte_offset + 1) s_len 
    | Single 13 -> 
      Buffer.add_string buf "\\r";
      check_and_transform (loc + 1) buf s (byte_offset + 1) s_len 
    | Single _ -> 
      Buffer.add_char buf current_char;
      check_and_transform (loc + 1) buf s (byte_offset + 1) s_len 

    | Invalid 
    | Cont _ -> error ~loc Invalid_code_point
    | Leading (n,_) -> 
      let i' = Ext_utf8.next s ~remaining:n  byte_offset in
      if i' < 0 then 
        error ~loc Invalid_code_point
      else 
        begin 
          for k = byte_offset to i' do 
            Buffer.add_char buf s.[k]; 
          done;   
          check_and_transform (loc + 1 ) buf s (i' + 1) s_len 
        end
(* we share the same escape sequence with js *)        
and escape_code loc buf s offset s_len = 
  if offset >= s_len then 
    error ~loc Unterminated_backslash
  else
    Buffer.add_char buf '\\'; 
  let cur_char = s.[offset] in
  match cur_char with 
  | '\\'
  | 'b' 
  | 't' 
  | 'n' 
  | 'v'
  | 'f'
  | 'r' 
  | '0' 
  | '$'
    -> 
    begin 
      Buffer.add_char buf cur_char ;
      check_and_transform (loc + 1) buf s (offset + 1) s_len 
    end 
  | 'u' -> 
    begin 
      Buffer.add_char buf cur_char;
      unicode (loc + 1) buf s (offset + 1) s_len 
    end 
  | 'x' -> begin 
      Buffer.add_char buf cur_char ; 
      two_hex (loc + 1) buf s (offset + 1) s_len 
    end 
  | _ -> error ~loc (Invalid_escape_code cur_char)
and two_hex loc buf s offset s_len = 
  if offset + 1 >= s_len then 
    error ~loc Invalid_hex_escape;
  (*Location.raise_errorf ~loc "\\x need at least two chars";*)
  let a, b = s.[offset], s.[offset + 1] in 
  if Ext_char.valid_hex a && Ext_char.valid_hex b then 
    begin 
      Buffer.add_char buf a ; 
      Buffer.add_char buf b ; 
      check_and_transform (loc + 2) buf s (offset + 2) s_len 
    end
  else
    error ~loc Invalid_hex_escape
(*Location.raise_errorf ~loc "%c%c is not a valid hex code" a b*)

and unicode loc buf s offset s_len = 
  if offset + 3 >= s_len then 
    error ~loc Invalid_unicode_escape
  (*Location.raise_errorf ~loc "\\u need at least four chars"*)
  ;
  let a0,a1,a2,a3 = s.[offset], s.[offset+1], s.[offset+2], s.[offset+3] in
  if 
    Ext_char.valid_hex a0 &&
    Ext_char.valid_hex a1 &&
    Ext_char.valid_hex a2 &&
    Ext_char.valid_hex a3 then 
    begin 
      Buffer.add_char buf a0;
      Buffer.add_char buf a1;
      Buffer.add_char buf a2;
      Buffer.add_char buf a3;  
      check_and_transform (loc + 4) buf s  (offset + 4) s_len 
    end 
  else
    error ~loc Invalid_unicode_escape 
(*Location.raise_errorf ~loc "%c%c%c%c is not a valid unicode point"
  a0 a1 a2 a3 *)
(* http://www.2ality.com/2015/01/es6-strings.html
   console.log('\uD83D\uDE80'); (* ES6*)
   console.log('\u{1F680}');
*)   









let transform_test s =
  let s_len = String.length s in 
  let buf = Buffer.create (s_len * 2) in
  check_and_transform 0 buf s 0 s_len;
  Buffer.contents buf

let transform loc s = 
  let s_len = String.length s in 
  let buf = Buffer.create (s_len * 2) in
  try
    check_and_transform 0 buf s 0 s_len;
    Buffer.contents buf 
  with
    Error (offset, error)
    ->  Location.raise_errorf ~loc "Offset: %d, %a" offset pp_error error



end
module Ast_utf8_string_interp : sig 
#1 "ast_utf8_string_interp.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


type kind =
  | String
  | Var
type error = private
  | Invalid_code_point
  | Unterminated_backslash
  | Invalid_escape_code of char
  | Invalid_hex_escape
  | Invalid_unicode_escape
  | Unterminated_variable
  | Unmatched_paren
  | Invalid_syntax_of_var of string 

(** Note the position is about code point *)
type pos = { lnum : int ; offset : int ; byte_bol : int }

type segment = {
  start : pos;
  finish : pos ;
  kind : kind;
  content : string ;
} 

type segments = segment list  

type cxt = {
  mutable segment_start : pos ;
  buf : Buffer.t ;
  s_len : int ;
  mutable segments : segments;
  mutable pos_bol : int; (* record the abs position of current beginning line *)
  mutable byte_bol : int ; 
  mutable pos_lnum : int ; (* record the line number *)
}

type exn += Error of pos *  pos * error 

val empty_segment : segment -> bool

val transform_test : string -> segment list
val transform_interp : Location.t -> string -> Parsetree.expression

end = struct
#1 "ast_utf8_string_interp.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type error = 
  | Invalid_code_point
  | Unterminated_backslash
  | Invalid_escape_code of char
  | Invalid_hex_escape
  | Invalid_unicode_escape
  | Unterminated_variable
  | Unmatched_paren
  | Invalid_syntax_of_var of string 
type kind =
  | String
  | Var


(** Note the position is about code point *)
type pos = { 
  lnum : int ; 
  offset : int ;
  byte_bol : int (* Note it actually needs to be in sync with OCaml's lexing semantics *)
}


type segment = {
  start : pos;
  finish : pos ;
  kind : kind;
  content : string ;
} 

type segments = segment list 


type cxt = {
  mutable segment_start : pos ;
  buf : Buffer.t ;
  s_len : int ;
  mutable segments : segments;
  mutable pos_bol : int; (* record the abs position of current beginning line *)
  mutable byte_bol : int ; 
  mutable pos_lnum : int ; (* record the line number *)
}


type exn += Error of pos *  pos * error 

let pp_error fmt err = 
  Format.pp_print_string fmt @@  match err with 
  | Invalid_code_point -> "Invalid code point"
  | Unterminated_backslash -> "\\ ended unexpectedly"
  | Invalid_escape_code c -> "Invalid escape code: " ^ String.make 1 c 
  | Invalid_hex_escape -> 
    "Invalid \\x escape"
  | Invalid_unicode_escape -> "Invalid \\u escape"
  | Unterminated_variable -> "$ unterminated"
  | Unmatched_paren -> "Unmatched paren"
  | Invalid_syntax_of_var s -> "`" ^s ^ "' is not a valid syntax of interpolated identifer"
let valid_lead_identifier_char x = 
  match x with
  | 'a'..'z' | '_' -> true
  | _ -> false

let valid_identifier_char x = 
  match x with
  | 'a'..'z' 
  | 'A'..'Z'
  | '0'..'9'
  | '_' | '\''-> true
  | _ -> false
(** Invariant: [valid_lead_identifier] has to be [valid_identifier] *)

let valid_identifier s =
  let s_len = String.length s in 
  if s_len = 0 then false 
  else
    valid_lead_identifier_char s.[0] &&
    Ext_string.for_all_range s ~start:0 ~finish:(s_len - 1) valid_identifier_char

      
let is_space x = 
  match x with
  | ' ' | '\n' | '\t' -> true
  | _ -> false



(**
   FIXME: multiple line offset 
   if there is no line offset. Note {|{j||} border will never trigger a new line
*)
let update_position border 
    ({lnum ; offset;byte_bol } : pos)
    (pos : Lexing.position)= 
  if lnum = 0 then 
    {pos with pos_cnum = pos.pos_cnum + border + offset  }
    (** When no newline, the column number is [border + offset] *)
  else 
    {
      pos with 
      pos_lnum = pos.pos_lnum + lnum ;
      pos_bol = pos.pos_cnum + border + byte_bol;
      pos_cnum = pos.pos_cnum + border + byte_bol + offset;
      (** when newline, the column number is [offset] *)
    }  
let update border
    (start : pos) 
    (finish : pos) (loc : Location.t) : Location.t = 
  let start_pos = loc.loc_start in 
  { loc  with 
    loc_start = 
      update_position  border start start_pos;
    loc_end = 
      update_position border finish start_pos
  }


(** Note [Var] kind can not be mpty  *)
let empty_segment {content } =
  Ext_string.is_empty content



let update_newline ~byte_bol loc  cxt = 
  cxt.pos_lnum <- cxt.pos_lnum + 1 ; 
  cxt.pos_bol <- loc;
  cxt.byte_bol <- byte_bol  

let pos_error cxt ~loc error = 
  raise (Error 
           (cxt.segment_start,
            { lnum = cxt.pos_lnum ; offset = loc - cxt.pos_bol ; byte_bol = cxt.byte_bol}, error))

let add_var_segment cxt loc  = 
  let content =  Buffer.contents cxt.buf in
  Buffer.clear cxt.buf ;
  let next_loc = {
    lnum = cxt.pos_lnum ; offset = loc - cxt.pos_bol ; 
    byte_bol = cxt.byte_bol } in
  if valid_identifier content then 
    begin 
      cxt.segments <- 
        { start = cxt.segment_start; 
          finish =  next_loc ;
          kind = Var; 
          content} :: cxt.segments ;
      cxt.segment_start <- next_loc
    end
  else pos_error cxt ~loc (Invalid_syntax_of_var content)

let add_str_segment cxt loc   =
  let content =  Buffer.contents cxt.buf in
  Buffer.clear cxt.buf ;
  let next_loc = {
    lnum = cxt.pos_lnum ; offset = loc - cxt.pos_bol ; 
    byte_bol = cxt.byte_bol } in
  cxt.segments <- 
    { start = cxt.segment_start; 
      finish =  next_loc ;
      kind = String; 
      content} :: cxt.segments ;
  cxt.segment_start <- next_loc


  


let rec check_and_transform (loc : int )  s byte_offset ({s_len; buf} as cxt : cxt) =
  if byte_offset = s_len then
    add_str_segment cxt loc 
  else 
    let current_char = s.[byte_offset] in 
    match Ext_utf8.classify current_char with 
    | Single 92 (* '\\' *) -> 
      escape_code (loc + 1)  s (byte_offset+1) cxt
    | Single 34 ->
      Buffer.add_string buf "\\\"";
      check_and_transform (loc + 1)  s (byte_offset + 1) cxt
    | Single 39 -> 
      Buffer.add_string buf "\\'";
      check_and_transform (loc + 1)  s (byte_offset + 1) cxt
    | Single 10 ->          

      Buffer.add_string buf "\\n";
      let loc = loc + 1 in 
      let byte_offset = byte_offset + 1 in 
      update_newline ~byte_bol:byte_offset loc cxt ; (* Note variable could not have new-line *)
      check_and_transform loc  s byte_offset cxt
    | Single 13 -> 
      Buffer.add_string buf "\\r";
      check_and_transform (loc + 1)  s (byte_offset + 1) cxt
    | Single 36 -> (* $ *)
      add_str_segment cxt loc  ; 
      let offset = byte_offset + 1 in
      if offset >= s_len then
        pos_error ~loc cxt  Unterminated_variable
      else
        let cur_char = s.[offset] in
        if cur_char = '(' then
          expect_var_paren  (loc + 2)  s (offset + 1) cxt
        else
          expect_simple_var (loc + 1)  s offset cxt
    | Single _ -> 
      Buffer.add_char buf current_char;
      check_and_transform (loc + 1)  s (byte_offset + 1) cxt

    | Invalid 
    | Cont _ -> pos_error ~loc cxt Invalid_code_point
    | Leading (n,_) -> 
      let i' = Ext_utf8.next s ~remaining:n  byte_offset in
      if i' < 0 then 
        pos_error cxt ~loc Invalid_code_point
      else 
        begin 
          for k = byte_offset to i' do 
            Buffer.add_char buf s.[k]; 
          done;   
          check_and_transform (loc + 1 )  s (i' + 1) cxt
        end
(**Lets keep identifier simple, so that we could generating a function easier in the future
   for example
   let f = [%fn{| $x + $y = $x_add_y |}]
*)
and expect_simple_var  loc  s offset ({buf; s_len} as cxt) =
  let v = ref offset in
  (* prerr_endline @@ Ext_pervasives.dump (s, has_paren, (is_space s.[!v]), !v); *)
  if not (offset < s_len  && valid_lead_identifier_char s.[offset]) then 
    pos_error cxt ~loc (Invalid_syntax_of_var Ext_string.empty)
  else 
    begin 
      while !v < s_len && valid_identifier_char s.[!v]  do (* TODO*)
        let cur_char = s.[!v] in
        Buffer.add_char buf cur_char;
        incr v ;
      done;
      let added_length = !v - offset in
      let loc = added_length + loc in 
      add_var_segment cxt loc  ; 
      check_and_transform loc  s (added_length + offset) cxt
    end
and expect_var_paren  loc  s offset ({buf; s_len} as cxt) =
  let v = ref offset in
  (* prerr_endline @@ Ext_pervasives.dump (s, has_paren, (is_space s.[!v]), !v); *)
  while !v < s_len &&  s.[!v] <> ')' do 
    let cur_char = s.[!v] in
    Buffer.add_char buf cur_char;
    incr v ;
  done;
  let added_length = !v - offset in
  let loc = added_length +  1 + loc  in
  if !v < s_len && s.[!v] = ')' then
    begin 
      add_var_segment cxt loc ; 
      check_and_transform loc  s (added_length + 1 + offset) cxt 
    end
  else
    pos_error cxt ~loc Unmatched_paren





(* we share the same escape sequence with js *)        
and escape_code loc  s offset ({ buf; s_len} as cxt) = 
  if offset >= s_len then 
    pos_error cxt ~loc Unterminated_backslash
  else
    Buffer.add_char buf '\\'; 
  let cur_char = s.[offset] in
  match cur_char with 
  | '\\'
  | 'b' 
  | 't' 
  | 'n' 
  | 'v'
  | 'f'
  | 'r' 
  | '0' 
  | '$'
    -> 
    begin 
      Buffer.add_char buf cur_char ;
      check_and_transform (loc + 1)  s (offset + 1) cxt
    end 
  | 'u' -> 
    begin 
      Buffer.add_char buf cur_char;
      unicode (loc + 1) s (offset + 1) cxt
    end 
  | 'x' -> begin 
      Buffer.add_char buf cur_char ; 
      two_hex (loc + 1)  s (offset + 1) cxt
    end 
  | _ -> pos_error cxt ~loc (Invalid_escape_code cur_char)
and two_hex loc  s offset ({buf ; s_len} as cxt) = 
  if offset + 1 >= s_len then 
    pos_error cxt ~loc Invalid_hex_escape;
  let a, b = s.[offset], s.[offset + 1] in 
  if Ext_char.valid_hex a && Ext_char.valid_hex b then 
    begin 
      Buffer.add_char buf a ; 
      Buffer.add_char buf b ; 
      check_and_transform (loc + 2)  s (offset + 2) cxt
    end
  else
    pos_error cxt ~loc Invalid_hex_escape


and unicode loc  s offset ({buf ; s_len} as cxt) = 
  if offset + 3 >= s_len then 
    pos_error cxt ~loc Invalid_unicode_escape
  ;
  let a0,a1,a2,a3 = s.[offset], s.[offset+1], s.[offset+2], s.[offset+3] in
  if 
    Ext_char.valid_hex a0 &&
    Ext_char.valid_hex a1 &&
    Ext_char.valid_hex a2 &&
    Ext_char.valid_hex a3 then 
    begin 
      Buffer.add_char buf a0;
      Buffer.add_char buf a1;
      Buffer.add_char buf a2;
      Buffer.add_char buf a3;  
      check_and_transform (loc + 4) s  (offset + 4) cxt
    end 
  else
    pos_error cxt ~loc Invalid_unicode_escape 
let transform_test s =
  let s_len = String.length s in
  let buf = Buffer.create (s_len * 2) in
  let cxt = 
    { segment_start = {lnum = 0; offset = 0; byte_bol = 0}; 
      buf ;
      s_len;
      segments = [];
      pos_lnum = 0;          
      byte_bol = 0;
      pos_bol = 0;

    } in 
  check_and_transform 0 s 0 cxt;
  List.rev cxt.segments


(** TODO: test empty var $() $ failure, 
    Allow identifers x.A.y *)    

open Ast_helper     

(** Longident.parse "Pervasives.^" *)
let concat_ident  : Longident.t = 
  Ldot (Lident "Pervasives", "^")
   (* JS string concatMany *)
    (* Ldot (Ldot (Lident "Js", "String"), "concat") *)

(* Longident.parse "Js.String.make"     *)
let to_string_ident : Longident.t = 
    Ldot (Ldot (Lident "Js", "String"), "make")



let escaped = Some Literals.escaped_j_delimiter 

let concat_exp 
  (a : Parsetree.expression)
  (b : Parsetree.expression) : Parsetree.expression = 
  let loc = Bs_loc.merge a.pexp_loc b.pexp_loc in 
  Exp.apply ~loc 
  (Exp.ident { txt =concat_ident; loc})
    ["",a ;
     "",b]

let border = String.length "{j|"

let aux loc (segment : segment) =  
  match segment with 
  | {start ; finish; kind ; content} 
    -> 
    let loc = update border start finish  loc in 
    begin match kind with 
      | String -> 
        Exp.constant 
          ~loc
          (Const_string (content, escaped)) 
      | Var -> 
        Exp.apply ~loc 
          (Exp.ident ~loc {loc ; txt = to_string_ident })
          [
            "",
            Exp.ident ~loc {loc ; txt = Lident content}
          ]
    end 


let transform_interp loc s = 
  let s_len = String.length s in 
  let buf = Buffer.create (s_len * 2 ) in 
  try 
    let cxt : cxt = 
      { segment_start = {lnum = 0; offset = 0; byte_bol = 0}; 
        buf ;
        s_len;
        segments = [];
        pos_lnum = 0;          
        byte_bol = 0;
        pos_bol = 0;

      } in 

    check_and_transform 0 s 0 cxt; 
    let rev_segments =  cxt.segments in 
    match rev_segments with 
    | [] -> 
      Exp.constant ~loc 
        (Const_string ("", Some Literals.escaped_j_delimiter)) 
    | [ segment] -> 
      aux loc segment 
    | a::rest -> 
      List.fold_left (fun (acc : Parsetree.expression)
       (x : segment) ->
          concat_exp (aux loc x) acc )
        (aux loc a) rest
  with 
    Error (start,pos, error) 
    -> 
    Location.raise_errorf ~loc:(update border start pos loc )
      "%a"  pp_error error 

end
module Ast_exp : sig 
#1 "ast_exp.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type t = Parsetree.expression 

end = struct
#1 "ast_exp.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type t = Parsetree.expression 

end
module Ast_external : sig 
#1 "ast_external.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


val create_local_external : Location.t ->
  ?pval_attributes:Parsetree.attributes ->
  pval_prim:string list ->
  pval_type:Parsetree.core_type ->
  ?local_module_name:string ->
  ?local_fun_name:string ->
  (string * Parsetree.expression) list -> Parsetree.expression_desc

val local_extern_cont : 
  Location.t ->
  ?pval_attributes:Parsetree.attributes ->
  pval_prim:string list ->
  pval_type:Parsetree.core_type ->
  ?local_module_name:string ->
  ?local_fun_name:string ->
  (Parsetree.expression -> Parsetree.expression) -> Parsetree.expression_desc

end = struct
#1 "ast_external.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

let create_local_external loc 
     ?(pval_attributes=[])
     ~pval_prim
     ~pval_type 
     ?(local_module_name = "J")
     ?(local_fun_name = "unsafe_expr")
     args
  : Parsetree.expression_desc = 
  Pexp_letmodule
    ({txt = local_module_name; loc},
     {pmod_desc =
        Pmod_structure
          [{pstr_desc =
              Pstr_primitive
                {pval_name = {txt = local_fun_name; loc};
                 pval_type ;
                 pval_loc = loc;
                 pval_prim ;
                 pval_attributes };
            pstr_loc = loc;
           }];
      pmod_loc = loc;
      pmod_attributes = []},
     {
       pexp_desc =
         Pexp_apply
           (({pexp_desc = Pexp_ident {txt = Ldot (Lident local_module_name, local_fun_name); 
                                      loc};
              pexp_attributes = [] ;
              pexp_loc = loc} : Parsetree.expression),
            args);
       pexp_attributes = [];
       pexp_loc = loc
     })

let local_extern_cont loc 
     ?(pval_attributes=[])
     ~pval_prim
     ~pval_type 
     ?(local_module_name = "J")
     ?(local_fun_name = "unsafe_expr")
     (cb : Parsetree.expression -> 'a) 
  : Parsetree.expression_desc = 
  Pexp_letmodule
    ({txt = local_module_name; loc},
     {pmod_desc =
        Pmod_structure
          [{pstr_desc =
              Pstr_primitive
                {pval_name = {txt = local_fun_name; loc};
                 pval_type ;
                 pval_loc = loc;
                 pval_prim ;
                 pval_attributes };
            pstr_loc = loc;
           }];
      pmod_loc = loc;
      pmod_attributes = []},
     cb {pexp_desc = Pexp_ident {txt = Ldot (Lident local_module_name, local_fun_name); 
                                 loc};
         pexp_attributes = [] ;
         pexp_loc = loc}
)

end
module Ast_pat : sig 
#1 "ast_pat.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type t = Parsetree.pattern

val is_unit_cont : yes:'a -> no:'a -> t -> 'a

(** [arity_of_fun pat e] tells the arity of 
    expression [fun pat -> e]*)
val arity_of_fun : t -> Parsetree.expression -> int


val is_single_variable_pattern_conservative : t -> bool

end = struct
#1 "ast_pat.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


type t = Parsetree.pattern


let is_unit_cont ~yes ~no (p : t)  =
  match p  with
  | {ppat_desc = Ppat_construct({txt = Lident "()"}, None)}
    -> yes 
  | _ -> no


(** [arity_of_fun pat e] tells the arity of 
    expression [fun pat -> e]
*)
let arity_of_fun
    (pat : Parsetree.pattern)
    (e : Parsetree.expression) =
  let rec aux (e : Parsetree.expression)  =
    match e.pexp_desc with
    | Pexp_fun ("", None, pat, e) ->
      1 + aux e       
    | Pexp_fun _
      -> Location.raise_errorf
           ~loc:e.pexp_loc "Label is not allowed in JS object"
    | _ -> 0 in
  is_unit_cont ~yes:0 ~no:1 pat + aux e 


let rec is_single_variable_pattern_conservative  (p : t ) =
  match p.ppat_desc with 
  | Parsetree.Ppat_any 
  | Parsetree.Ppat_var _ -> true 
  | Parsetree.Ppat_alias (p,_) 
  | Parsetree.Ppat_constraint (p, _) -> 
    is_single_variable_pattern_conservative p 
  
  | _ -> false

end
module Ast_util : sig 
#1 "ast_util.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


type args = (string * Parsetree.expression) list
type loc = Location.t 
type label_exprs = (Longident.t Asttypes.loc * Parsetree.expression) list
type 'a cxt = loc -> Ast_mapper.mapper -> 'a

(** In general three kinds of ast generation.
    - convert a curried to type to uncurried 
    - convert a curried fun to uncurried fun
    - convert a uncuried application to normal 
*)
type uncurry_expression_gen = 
  (Parsetree.pattern ->
   Parsetree.expression ->
   Parsetree.expression_desc) cxt
type uncurry_type_gen = 
  (string -> (* label for error checking *)
   Parsetree.core_type ->
   Parsetree.core_type  ->
   Parsetree.core_type) cxt

(** TODO: the interface is not reusable, it depends on too much context *)
(** syntax: {[f arg0 arg1 [@bs]]}*)
val uncurry_fn_apply : 
  (Parsetree.expression ->
  args ->
  Parsetree.expression_desc ) cxt 

(** syntax : {[f## arg0 arg1 ]}*)
val method_apply : 
  (Parsetree.expression ->
  string ->
  args ->
  Parsetree.expression_desc) cxt 

(** syntax {[f#@ arg0 arg1 ]}*)
val property_apply : 
  (Parsetree.expression ->
  string ->
  args ->
  Parsetree.expression_desc) cxt 


(** 
    [function] can only take one argument, that is the reason we did not adopt it
    syntax:
    {[ fun [@bs] pat pat1-> body ]}
    [to_uncurry_fn (fun pat -> (fun pat1 -> ...  body))]

*)
val to_uncurry_fn : uncurry_expression_gen


(** syntax: 
    {[fun [@bs.this] obj pat pat1 -> body]}    
*)
val to_method_callback : uncurry_expression_gen


(** syntax : 
    {[ int -> int -> int [@bs]]}
*)
val to_uncurry_type : uncurry_type_gen
  

(** syntax
    {[ method : int -> itn -> int ]}
*)
val to_method_type : uncurry_type_gen

(** syntax:
    {[ 'obj -> int -> int [@bs.this] ]}
*)
val to_method_callback_type : uncurry_type_gen





val record_as_js_object : 
  (label_exprs ->
   Parsetree.expression_desc) cxt 

val js_property : 
  loc ->
  Parsetree.expression -> string -> Parsetree.expression_desc

val handle_debugger : 
  loc -> Ast_payload.t -> Parsetree.expression_desc

val handle_raw : 
  ?check_js_regex: bool -> loc -> Ast_payload.t -> Parsetree.expression

val handle_external :
  loc -> string -> Parsetree.expression 
  
val handle_raw_structure : 
  loc -> Ast_payload.t -> Parsetree.structure_item

val ocaml_obj_as_js_object :
  (Parsetree.pattern ->
   Parsetree.class_field list ->
   Parsetree.expression_desc) cxt   


 val convertBsErrorFunction : 
   
   (Ast_helper.attrs -> Parsetree.case list -> Parsetree.expression) cxt

end = struct
#1 "ast_util.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

open Ast_helper 
type 'a cxt = Ast_helper.loc -> Ast_mapper.mapper -> 'a
type loc = Location.t 
type args = (string * Parsetree.expression) list
type label_exprs = (Longident.t Asttypes.loc * Parsetree.expression) list
type uncurry_expression_gen = 
  (Parsetree.pattern ->
   Parsetree.expression ->
   Parsetree.expression_desc) cxt
type uncurry_type_gen = 
  (string ->
   Parsetree.core_type ->
   Parsetree.core_type  ->
   Parsetree.core_type) cxt

let uncurry_type_id = 
  Ast_literal.Lid.js_fn

let method_id  = 
  Ast_literal.Lid.js_meth

let method_call_back_id  = 
  Ast_literal.Lid.js_meth_callback

let arity_lit = "Arity_"

let mk_args loc n tys = 
  Typ.variant ~loc 
    [ Rtag (arity_lit ^ string_of_int n, [], (n = 0),  tys)] Closed None

let generic_lift txt loc args result  = 
  let xs =
    match args with 
    | [ ] -> [mk_args loc 0   [] ; result ]
    | [ x ] -> [ mk_args loc 1 [x] ; result ] 
    | _ -> 
      [mk_args loc (List.length args ) [Typ.tuple ~loc args] ; result ]
  in 
  Typ.constr ~loc {txt ; loc} xs

let lift_curry_type  loc   = 
  generic_lift   uncurry_type_id loc

let lift_method_type loc  = 
  generic_lift  method_id loc

let lift_js_method_callback loc
  = 
  generic_lift method_call_back_id loc 
(** Note that currently there is no way to consume [Js.meth_callback]
    so it is fine to encode it with a freedom, 
    but we need make it better for error message.
    - all are encoded as 
    {[ 
      type fn =  (`Args_n of _ , 'result ) Js.fn
      type method = (`Args_n of _, 'result) Js.method
      type method_callback = (`Args_n of _, 'result) Js.method_callback
    ]}
    For [method_callback], the arity is never zero, so both [method] 
    and  [fn] requires (unit -> 'a) to encode arity zero
*)



let arrow = Typ.arrow


let js_property loc obj name =
  Parsetree.Pexp_send
    ((Exp.apply ~loc
        (Exp.ident ~loc
           {loc;
            txt = Ldot (Ast_literal.Lid.js_unsafe, Literals.unsafe_downgrade)})
        ["",obj]), name)

(* TODO: 
   have a final checking for property arities 
     [#=], 
*)


let generic_apply  kind loc 
    (self : Ast_mapper.mapper) 
    (obj : Parsetree.expression) 
    (args : args ) cb   =
  let obj = self.expr self obj in
  let args =
    Ext_list.map (fun (label,e) ->
        if label <> "" then
          Bs_syntaxerr.err loc Label_in_uncurried_bs_attribute;
        self.expr self e
      ) args in
  let len = List.length args in 
  let arity, fn, args  = 
    match args with 
    | [ {pexp_desc =
           Pexp_construct ({txt = Lident "()"}, None)}]
      -> 
      0, cb loc obj, []
    | _ -> 
      len,  cb loc obj, args in
  if arity < 10 then 
    let txt = 
      match kind with 
      | `Fn | `PropertyFn ->  
        Longident.Ldot (Ast_literal.Lid.js_unsafe, 
                        Literals.fn_run ^ string_of_int arity)
      | `Method -> 
        Longident.Ldot(Ast_literal.Lid.js_unsafe,
                       Literals.method_run ^ string_of_int arity
                      ) in 
    Parsetree.Pexp_apply (Exp.ident {txt ; loc}, ("",fn) :: Ext_list.map (fun x -> "",x) args)
  else 
    let fn_type, args_type, result_type = Ast_comb.tuple_type_pair ~loc `Run arity  in 
    let string_arity = string_of_int arity in
    let pval_prim, pval_type = 
      match kind with 
      | `Fn | `PropertyFn -> 
        ["#fn_run"; string_arity], 
        arrow ~loc ""  (lift_curry_type loc args_type result_type ) fn_type
      | `Method -> 
        ["#method_run" ; string_arity], 
        arrow ~loc "" (lift_method_type loc args_type result_type) fn_type
    in
    Ast_external.create_local_external loc ~pval_prim ~pval_type 
      (("", fn) :: Ext_list.map (fun x -> "",x) args )


let uncurry_fn_apply loc self fn args = 
  generic_apply `Fn loc self fn args (fun _ obj -> obj )

let property_apply loc self obj name (args : args) 
  =  generic_apply `PropertyFn loc self obj args 
    (fun loc obj -> Exp.mk ~loc (js_property loc obj name))

let method_apply loc self obj name args = 
  generic_apply `Method loc self obj args 
    (fun loc obj -> Exp.mk ~loc (js_property loc obj name))

let generic_to_uncurry_type  kind loc (mapper : Ast_mapper.mapper) label
    (first_arg : Parsetree.core_type) 
    (typ : Parsetree.core_type)  =
  if label <> "" then
    Bs_syntaxerr.err loc Label_in_uncurried_bs_attribute;

  let rec aux acc (typ : Parsetree.core_type) = 
    (* in general, 
       we should collect [typ] in [int -> typ] before transformation, 
       however: when attributes [bs] and [bs.this] found in typ, 
       we should stop 
    *)
    match Ast_attributes.process_attributes_rev typ.ptyp_attributes with 
    | `Nothing, _   -> 
      begin match typ.ptyp_desc with 
        | Ptyp_arrow (label, arg, body)
          -> 
          if label <> "" then
            Bs_syntaxerr.err typ.ptyp_loc Label_in_uncurried_bs_attribute;
          aux (mapper.typ mapper arg :: acc) body 
        | _ -> mapper.typ mapper typ, acc 
      end
    | _, _ -> mapper.typ mapper typ, acc  
  in 
  let first_arg = mapper.typ mapper first_arg in
  let result, rev_extra_args = aux  [first_arg] typ in 
  let args  = List.rev rev_extra_args in 
  let filter_args args  =  
    match args with 
    | [{Parsetree.ptyp_desc = 
          (Ptyp_constr ({txt = Lident "unit"}, []) 
          )}]
      -> []
    | _ -> args in
  match kind with 
  | `Fn ->
    let args = filter_args args in
    lift_curry_type loc args result 
  | `Method -> 
    let args = filter_args args in
    lift_method_type loc args result 

  | `Method_callback
    -> lift_js_method_callback loc args result 


let to_uncurry_type  = 
  generic_to_uncurry_type `Fn
let to_method_type  =
  generic_to_uncurry_type  `Method
let to_method_callback_type  = 
  generic_to_uncurry_type `Method_callback 

let generic_to_uncurry_exp kind loc (self : Ast_mapper.mapper)  pat body 
  = 
  let rec aux acc (body : Parsetree.expression) = 
    match Ast_attributes.process_attributes_rev body.pexp_attributes with 
    | `Nothing, _ -> 
      begin match body.pexp_desc with 
        | Pexp_fun (label,_, arg, body)
          -> 
          if label <> "" then
            Bs_syntaxerr.err loc Label_in_uncurried_bs_attribute;
          aux (self.pat self arg :: acc) body 
        | _ -> self.expr self body, acc 
      end 
    | _, _ -> self.expr self body, acc  
  in 
  let first_arg = self.pat self pat in  
  let () = 
    match kind with 
    | `Method_callback -> 
      if not @@ Ast_pat.is_single_variable_pattern_conservative first_arg then
        Bs_syntaxerr.err first_arg.ppat_loc  Bs_this_simple_pattern
    | _ -> ()
  in 

  let result, rev_extra_args = aux [first_arg] body in 
  let body = 
    List.fold_left (fun e p -> Ast_comb.fun_no_label ~loc p e )
      result rev_extra_args in
  let len = List.length rev_extra_args in 
  let arity = 
    match kind with 
    | `Fn  ->
      begin match rev_extra_args with 
        | [ p]
          ->
          Ast_pat.is_unit_cont ~yes:0 ~no:len p           

        | _ -> len 
      end
    | `Method_callback -> len  in 
  if arity < 10  then 
    let txt = 
      match kind with 
      | `Fn -> 
        Longident.Ldot ( Ast_literal.Lid.js_unsafe, Literals.fn_mk ^ string_of_int arity)
      | `Method_callback -> 
        Longident.Ldot (Ast_literal.Lid.js_unsafe,  Literals.fn_method ^ string_of_int arity) in
    Parsetree.Pexp_apply (Exp.ident {txt;loc} , ["",body])

  else 
    let pval_prim =
      [ (match kind with 
            | `Fn -> "#fn_mk"
            | `Method_callback -> "#fn_method"); 
        string_of_int arity]  in
    let fn_type , args_type, result_type  = Ast_comb.tuple_type_pair ~loc `Make arity  in 
    let pval_type = arrow ~loc "" fn_type (
        match kind with 
        | `Fn -> 
          lift_curry_type loc args_type result_type
        | `Method_callback -> 
          lift_js_method_callback loc args_type result_type
      ) in
    Ast_external.local_extern_cont loc ~pval_prim ~pval_type 
      (fun prim -> Exp.apply ~loc prim ["", body]) 

let to_uncurry_fn   = 
  generic_to_uncurry_exp `Fn
let to_method_callback  = 
  generic_to_uncurry_exp `Method_callback 


let handle_debugger loc payload = 
  if Ast_payload.as_empty_structure payload then
    Parsetree.Pexp_apply
      (Exp.ident {txt = Ldot(Ast_literal.Lid.js_unsafe, Literals.debugger ); loc}, 
       ["", Ast_literal.val_unit ~loc ()])
  else Location.raise_errorf ~loc "bs.raw can only be applied to a string"


let handle_raw ?(check_js_regex = false) loc payload =
  begin match Ast_payload.as_string_exp ~check_js_regex payload with
    | Not_String_Lteral ->
      Location.raise_errorf ~loc
        "bs.raw can only be applied to a string"
    | Ast_payload.JS_Regex_Check_Failed ->
      Location.raise_errorf ~loc "this is an invalid js regex"
    | Correct exp ->
      let pexp_desc = 
        Parsetree.Pexp_apply (
          Exp.ident {loc; 
                     txt = 
                       Ldot (Ast_literal.Lid.js_unsafe, 
                             Literals.raw_expr)},
          ["",exp]
        )
      in
      { exp with pexp_desc }
  end

let handle_external loc x = 
  let raw_exp : Ast_exp.t = 
    Ast_helper.Exp.apply 
    (Exp.ident ~loc 
         {loc; txt = Ldot (Ast_literal.Lid.js_unsafe, 
                           Literals.raw_expr)})
      ~loc 
      [Ext_string.empty, 
        Exp.constant ~loc (Const_string (x,Some Ext_string.empty))] in 
  let empty = 
    Exp.ident ~loc 
    {txt = Ldot (Ldot(Lident"Js", "Undefined"), "empty");loc}    
  in 
  let undefined_typeof = 
    Exp.ident {loc ; txt = Ldot (Ldot(Lident "Js","Undefined"),"to_opt")} in 
  let typeof = 
    Exp.ident {loc ; txt = Ldot(Lident "Js","typeof")} in 

  Exp.apply ~loc undefined_typeof [
    Ext_string.empty,
    Exp.ifthenelse ~loc
    (Exp.apply ~loc 
      (Exp.ident ~loc {loc ; txt = Ldot (Lident "Pervasives", "=")} )
      [ 
        Ext_string.empty,
        (Exp.apply ~loc typeof [Ext_string.empty,raw_exp]);
        Ext_string.empty, 
        Exp.constant ~loc (Const_string ("undefined",None))  
        ])      
      (empty)
      (Some raw_exp)
      ]


let handle_raw_structure loc payload = 
  begin match Ast_payload.as_string_exp payload with 
    | Correct exp 
      -> 
      let pexp_desc = 
        Parsetree.Pexp_apply(
          Exp.ident {txt = Ldot (Ast_literal.Lid.js_unsafe,  Literals.raw_stmt); loc},
          ["",exp]) in 
      Ast_helper.Str.eval 
        { exp with pexp_desc }

    | Not_String_Lteral
      -> 
      Location.raise_errorf ~loc "bs.raw can only be applied to a string"
    | JS_Regex_Check_Failed 
      ->
      Location.raise_errorf ~loc "this is an invalid js regex"
  end


let ocaml_obj_as_js_object
    loc (mapper : Ast_mapper.mapper)
    (self_pat : Parsetree.pattern)
    (clfs : Parsetree.class_field list) =
  let self_type_lit = "self_type"   in 

  (** Attention: we should avoid type variable conflict for each method  
      Since the method name is unique, there would be no conflict 
      OCaml does not allow duplicate instance variable and duplicate methods, 
      but it does allow duplicates between instance variable and method name, 
      we should enforce such rules 
      {[
        object 
          val x = 3
          method x = 3 
        end [@bs]
      ]} should not compile with a meaningful error message
  *)

  let generate_val_method_pair 
      loc (mapper : Ast_mapper.mapper)
      val_name  is_mutable = 

    let result = Typ.var ~loc val_name in 
    result , 
    ((val_name , [], result ) ::
     (if is_mutable then 
        [val_name ^ Literals.setter_suffix,[],
         to_method_type loc mapper "" result (Ast_literal.type_unit ~loc ()) ]
      else 
        []) )
  in 
  (* Note mapper is only for API compatible 
   * TODO: we should check label name to avoid conflict 
  *)  
  let self_type loc = Typ.var ~loc self_type_lit in 

  let generate_arg_type loc (mapper  : Ast_mapper.mapper)
      method_name arity : Ast_core_type.t = 
    let result = Typ.var ~loc method_name in   
    if arity = 0 then
      to_method_type loc mapper "" (Ast_literal.type_unit ~loc ()) result 

    else
      let tyvars =
        Ext_list.init arity (fun i -> Typ.var ~loc (method_name ^ string_of_int i))
      in
      begin match tyvars with
        | x :: rest ->
          let method_rest =
            List.fold_right (fun v acc -> Typ.arrow ~loc "" v acc)
              rest result in         
          to_method_type loc mapper "" x method_rest
        | _ -> assert false
      end in          

  let generate_method_type
      loc
      (mapper : Ast_mapper.mapper)
      ?alias_type method_name arity =
    let result = Typ.var ~loc method_name in   

    let self_type =
      let v = self_type loc  in
      match alias_type with 
      | None -> v 
      | Some ty -> Typ.alias ~loc ty self_type_lit
    in  
    if arity = 0 then
      to_method_callback_type loc mapper  "" self_type result      
    else
      let tyvars =
        Ext_list.init arity (fun i -> Typ.var ~loc (method_name ^ string_of_int i))
      in
      begin match tyvars with
        | x :: rest ->
          let method_rest =
            List.fold_right (fun v acc -> Typ.arrow ~loc "" v acc)
              rest result in         
          (to_method_callback_type loc mapper  "" self_type
             (Typ.arrow ~loc "" x method_rest))
        | _ -> assert false
      end in          


  (** we need calculate the real object type 
      and exposed object type, in some cases there are equivalent

      for public object type its [@bs.meth] it does not depend on itself
      while for label argument it is [@bs.this] which depends internal object
  *)
  let internal_label_attr_types, public_label_attr_types  = 
    List.fold_right
      (fun ({pcf_loc  = loc} as x  : Parsetree.class_field) 
        (label_attr_types, public_label_attr_types) ->
        match x.pcf_desc with
        | Pcf_method (
            label,
            public_flag,
            Cfk_concrete
              (Fresh, e))
          ->
          begin match e.pexp_desc with
            | Pexp_poly
                (({pexp_desc = Pexp_fun ("", None, pat, e)} ),
                 None) ->  
              let arity = Ast_pat.arity_of_fun pat e in
              let method_type =
                generate_arg_type x.pcf_loc mapper label.txt arity in 
              ((label.Asttypes.txt, [], method_type) :: label_attr_types),
              (if public_flag = Public then
                 (label.Asttypes.txt, [], method_type) :: public_label_attr_types
               else 
                 public_label_attr_types)

            | Pexp_poly( _, Some _)
              ->
              Location.raise_errorf ~loc "polymorphic type annotation not supported yet"
            | Pexp_poly (_, None) ->
              Location.raise_errorf ~loc
                "Unsupported syntax, expect syntax like `method x () = x ` "
            | _ ->
              Location.raise_errorf ~loc "Unsupported syntax in js object"               
          end
        | Pcf_val (label, mutable_flag, Cfk_concrete(Fresh, val_exp)) ->
          let  label_type, label_attr  = 
            generate_val_method_pair x.pcf_loc mapper label.txt  
              (mutable_flag = Mutable )
          in
          (Ext_list.append label_attr  label_attr_types, public_label_attr_types)
        | Pcf_val (label, mutable_flag, Cfk_concrete(Override, val_exp)) -> 
          Location.raise_errorf ~loc "override flag not support currently"
        | Pcf_val (label, mutable_flag, Cfk_virtual _) -> 
          Location.raise_errorf ~loc "virtual flag not support currently"

        | Pcf_method (_, _, Cfk_concrete(Override, _) ) -> 
          Location.raise_errorf ~loc "override flag not supported"

        | Pcf_method (_, _, Cfk_virtual _ )
          ->
          Location.raise_errorf ~loc "virtural method not supported"

        | Pcf_inherit _ 
        | Pcf_initializer _
        | Pcf_attribute _
        | Pcf_extension _
        | Pcf_constraint _ ->
          Location.raise_errorf ~loc "Only method support currently"
      ) clfs ([], []) in
  let internal_obj_type = Ast_core_type.make_obj ~loc internal_label_attr_types in
  let public_obj_type = Ast_core_type.make_obj ~loc public_label_attr_types in
  let (labels,  label_types, exprs, _) =
    List.fold_right
      (fun (x  : Parsetree.class_field)
        (labels,
         label_types,
         exprs, aliased ) ->
        match x.pcf_desc with
        | Pcf_method (
            label,
            _public_flag,
            Cfk_concrete
              (Fresh, e))
          ->
          begin match e.pexp_desc with
            | Pexp_poly
                (({pexp_desc = Pexp_fun ("", None, pat, e)} as f),
                 None) ->  
              let arity = Ast_pat.arity_of_fun pat e in
              let alias_type = 
                if aliased then None 
                else Some internal_obj_type in
              let  label_type =
                generate_method_type ?alias_type
                  x.pcf_loc mapper label.txt arity in 
              (label::labels,
               label_type::label_types,
               {f with
                pexp_desc =
                  let f = Ast_pat.is_unit_cont pat ~yes:e ~no:f in                       
                  to_method_callback loc mapper self_pat f
               } :: exprs, 
               true
              )
            | Pexp_poly( _, Some _)
              ->
              Location.raise_errorf ~loc
                "polymorphic type annotation not supported yet"

            | Pexp_poly (_, None) ->
              Location.raise_errorf
                ~loc "Unsupported syntax, expect syntax like `method x () = x ` "
            | _ ->
              Location.raise_errorf ~loc "Unsupported syntax in js object"               
          end
        | Pcf_val (label, mutable_flag, Cfk_concrete(Fresh, val_exp)) ->
          let  label_type, label_attr  = 
            generate_val_method_pair x.pcf_loc mapper label.txt  
              (mutable_flag = Mutable )
          in
          (label::labels,
           label_type :: label_types, 
           (mapper.expr mapper val_exp :: exprs), 
           aliased 
          )

        | Pcf_val (label, mutable_flag, Cfk_concrete(Override, val_exp)) -> 
          Location.raise_errorf ~loc "override flag not support currently"
        | Pcf_val (label, mutable_flag, Cfk_virtual _) -> 
          Location.raise_errorf ~loc "virtual flag not support currently"

        | Pcf_method (_, _, Cfk_concrete(Override, _) ) -> 
          Location.raise_errorf ~loc "override flag not supported"

        | Pcf_method (_, _, Cfk_virtual _ )
          ->
          Location.raise_errorf ~loc "virtural method not supported"


        | Pcf_inherit _ 
        | Pcf_initializer _
        | Pcf_attribute _
        | Pcf_extension _
        | Pcf_constraint _ ->
          Location.raise_errorf ~loc "Only method support currently"
      ) clfs  ([], [], [], false) in
  let pval_type =
    List.fold_right2
      (fun label label_type acc ->
         Typ.arrow
           ~loc:label.Asttypes.loc
           label.Asttypes.txt
           label_type acc           
      ) labels label_types public_obj_type in
  Ast_external.local_extern_cont
    loc
    ~pval_prim:(Ast_external_attributes.pval_prim_of_labels labels)
    (fun e ->
       Exp.apply ~loc e
         (List.map2 (fun l expr -> l.Asttypes.txt, expr) labels exprs) )
    ~pval_type


let record_as_js_object 
    loc 
    (self : Ast_mapper.mapper)
    (label_exprs : label_exprs)
  : Parsetree.expression_desc = 

  let labels,args, arity =
    List.fold_right (fun ({Location.txt ; loc}, e) (labels,args,i) -> 
        match txt with
        | Longident.Lident x ->
          ({Asttypes.loc = loc ; txt = x} :: labels, (x, self.expr self e) :: args, i + 1)
        | Ldot _ | Lapply _ ->  
          Location.raise_errorf ~loc "invalid js label ") label_exprs ([],[],0) in
  Ast_external.create_local_external loc 
    ~pval_prim:(Ast_external_attributes.pval_prim_of_labels labels)
    ~pval_type:(Ast_core_type.from_labels ~loc arity labels) 
    args 



let isCamlExceptionOrOpenVariant = Longident.parse "Caml_exceptions.isCamlExceptionOrOpenVariant"
let obj_magic = Longident.parse "Obj.magic"

let rec checkCases (cases : Parsetree.case list) = 
  List.iter check_case cases 
and check_case case = 
  check_pat case.pc_lhs 
and check_pat (pat : Parsetree.pattern) = 
  match pat.ppat_desc with 
  | Ppat_construct _ -> ()
  | Ppat_or (l,r) -> 
    check_pat l; check_pat r 
  | _ ->  Location.raise_errorf ~loc:pat.ppat_loc "Unsupported pattern in `bs.open`" 

let convertBsErrorFunction loc  (self : Ast_mapper.mapper) attrs (cases : Parsetree.case list ) =
  let txt  = "match" in 
  let txt_expr = Exp.ident ~loc {txt = Lident txt; loc} in 
  let none = Exp.constraint_ ~loc 
      (Exp.construct ~loc {txt = Lident "None" ; loc} None) 
      (Ast_core_type.lift_option_type (Typ.any ~loc ())) in
  let () = checkCases cases in  
  let cases = self.cases self cases in 
  Exp.fun_ ~attrs ~loc ""  None ( Pat.var ~loc  {txt; loc })
    (Exp.ifthenelse
    ~loc 
    (Exp.apply ~loc (Exp.ident ~loc {txt = isCamlExceptionOrOpenVariant ; loc}) ["", txt_expr ])
    (Exp.match_ ~loc 
       (Exp.constraint_ ~loc 
          (Exp.apply  ~loc (Exp.ident ~loc {txt =  obj_magic; loc}) ["", txt_expr])
          (Ast_literal.type_exn ~loc ())
       )
      (Ext_list.append (Ext_list.map (fun (x :Parsetree.case ) ->
           let pc_rhs = x.pc_rhs in 
           let  loc  = pc_rhs.pexp_loc in
           {
             x with pc_rhs = 
                      Exp.constraint_ ~loc 
                        (Exp.construct ~loc {txt = Lident "Some";loc} (Some pc_rhs))
                        (Ast_core_type.lift_option_type (Typ.any ~loc ())  )
           }

         ) cases) 
      [
       Exp.case  (Pat.any ~loc ()) none
     ])
    )
    (Some none))
    
                       

end
module Ext_ref : sig 
#1 "ext_ref.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

(** [non_exn_protect ref value f] assusme [f()] 
    would not raise
*)

val non_exn_protect : 'a ref -> 'a -> (unit -> 'b) -> 'b
val protect : 'a ref -> 'a -> (unit -> 'b) -> 'b

val protect2 : 'a ref -> 'b ref -> 'a -> 'b -> (unit -> 'c) -> 'c

(** [non_exn_protect2 refa refb va vb f ]
    assume [f ()] would not raise
*)
val non_exn_protect2 : 'a ref -> 'b ref -> 'a -> 'b -> (unit -> 'c) -> 'c

val protect_list : ('a ref * 'a) list -> (unit -> 'b) -> 'b

end = struct
#1 "ext_ref.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

let non_exn_protect r v body = 
  let old = !r in
  r := v;
  let res = body() in
  r := old;
  res

let protect r v body =
  let old = !r in
  try
    r := v;
    let res = body() in
    r := old;
    res
  with x ->
    r := old;
    raise x

let non_exn_protect2 r1 r2 v1 v2 body = 
  let old1 = !r1 in
  let old2 = !r2 in  
  r1 := v1;
  r2 := v2;
  let res = body() in
  r1 := old1;
  r2 := old2;
  res

let protect2 r1 r2 v1 v2 body =
  let old1 = !r1 in
  let old2 = !r2 in  
  try
    r1 := v1;
    r2 := v2;
    let res = body() in
    r1 := old1;
    r2 := old2;
    res
  with x ->
    r1 := old1;
    r2 := old2;
    raise x

let protect_list rvs body = 
  let olds =  Ext_list.map (fun (x,y) -> !x)  rvs in 
  let () = List.iter (fun (x,y) -> x:=y) rvs in 
  try 
    let res = body () in 
    List.iter2 (fun (x,_) old -> x := old) rvs olds;
    res 
  with e -> 
    List.iter2 (fun (x,_) old -> x := old) rvs olds;
    raise e 

end
module Ppx_entry : sig 
#1 "ppx_entry.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)




val rewrite_signature :   (Parsetree.signature -> Parsetree.signature) ref

val rewrite_implementation : (Parsetree.structure -> Parsetree.structure) ref





(* object 
    for setter : we can push more into [Lsend] and enclose it with a unit type

    for getter :

    (* Invariant: we expect the typechecker & lambda emitter  
       will not do agressive inlining
       Worst things could happen
    {[
      let x = y## case 3  in 
      x 2
    ]}
       in normal case, it should be compiled into Lambda
    {[
      let x = Lsend(y,case, [3]) in 
      Lapp(x,2)
    ]}

       worst:
    {[ Lsend(y, case, [3,2])
    ]}               
       for setter(include case setter), this could 
       be prevented by type system, for getter.

       solution: we can prevent this by rewrite into 
    {[
      Fn.run1  (!x# case) v 
      ]}
       *)

      *)

end = struct
#1 "ppx_entry.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)






(* When we design a ppx, we should keep it simple, and also think about 
   how it would work with other tools like merlin and ocamldep  *)

(**
   1. extension point 
   {[ 
     [%bs.raw{| blabla |}]
   ]}
   will be desugared into 
   {[ 
     let module Js = 
     struct unsafe_js : string -> 'a end 
     in Js.unsafe_js {| blabla |}
   ]}
   The major benefit is to better error reporting (with locations).
   Otherwise

   {[

     let f u = Js.unsafe_js u 
     let _ = f (1 + 2)
   ]}
   And if it is inlined some where   
*)



open Ast_helper




let record_as_js_object = ref false (* otherwise has an attribute *)
let no_export = ref false 

let () = 
  Ast_derive_dyn.init  ();
  Ast_derive_projector.init ()

let reset () = 
  record_as_js_object := false ;
  no_export  :=  false



let process_getter_setter ~no ~get ~set
    loc name
    (attrs : Ast_attributes.t)
    (ty : Parsetree.core_type) acc  =
  match Ast_attributes.process_method_attributes_rev attrs with 
  | {get = None; set = None}, _  ->  no ty :: acc 
  | st , pctf_attributes
    -> 
    let get_acc = 
      match st.set with 
      | Some `No_get -> acc 
      | None 
      | Some `Get -> 
        let lift txt = 
          Typ.constr ~loc {txt ; loc} [ty] in
        let (null,undefined) =                
          match st with 
          | {get = Some (null, undefined) } -> (null, undefined)
          | {get = None} -> (false, false ) in 
        let ty = 
          match (null,undefined) with 
          | false, false -> ty
          | true, false -> lift Ast_literal.Lid.js_null
          | false, true -> lift Ast_literal.Lid.js_undefined
          | true , true -> lift Ast_literal.Lid.js_null_undefined in
        get ty name pctf_attributes
        :: acc  
    in 
    if st.set = None then get_acc 
    else
      set ty (name ^ Literals.setter_suffix) pctf_attributes         
      :: get_acc 



let handle_class_type_field self
    ({pctf_loc = loc } as ctf : Parsetree.class_type_field)
    acc =
  match ctf.pctf_desc with 
  | Pctf_method 
      (name, private_flag, virtual_flag, ty) 
    ->
    let no (ty : Parsetree.core_type) =
      let ty = 
        match ty.ptyp_desc with 
        | Ptyp_arrow (label, args, body) 
          ->
          Ast_util.to_method_type
            ty.ptyp_loc  self label args body

        | Ptyp_poly (strs, {ptyp_desc = Ptyp_arrow (label, args, body);
                            ptyp_loc})
          ->
          {ty with ptyp_desc = 
                     Ptyp_poly(strs,             
                               Ast_util.to_method_type
                                 ptyp_loc  self label args body  )}
        | _ -> 
          self.typ self ty
      in 
      {ctf with 
       pctf_desc = 
         Pctf_method (name , private_flag, virtual_flag, ty)}
    in
    let get ty name pctf_attributes =
      {ctf with 
       pctf_desc =  
         Pctf_method (name , 
                      private_flag, 
                      virtual_flag, 
                      self.typ self ty
                     );
       pctf_attributes} in
    let set ty name pctf_attributes =
      {ctf with 
       pctf_desc =
         Pctf_method (name, 
                      private_flag,
                      virtual_flag,
                      Ast_util.to_method_type
                        loc self "" ty
                        (Ast_literal.type_unit ~loc ())
                     );
       pctf_attributes} in
    process_getter_setter ~no ~get ~set loc name ctf.pctf_attributes ty acc     

  | Pctf_inherit _ 
  | Pctf_val _ 
  | Pctf_constraint _
  | Pctf_attribute _ 
  | Pctf_extension _  -> 
    Ast_mapper.default_mapper.class_type_field self ctf :: acc 

(*
  Attributes are very hard to attribute
  (since ptyp_attributes could happen in so many places), 
  and write ppx extensions correctly, 
  we can only use it locally
*)

let handle_core_type 
    (super : Ast_mapper.mapper) 
    (self : Ast_mapper.mapper)
    (ty : Parsetree.core_type) = 
  match ty with
  | {ptyp_desc = Ptyp_extension({txt = ("bs.obj"|"obj")}, PTyp ty)}
    -> 
    Ext_ref.non_exn_protect record_as_js_object true 
      (fun _ -> self.typ self ty )
  | {ptyp_attributes ;
     ptyp_desc = Ptyp_arrow (label, args, body);
     (* let it go without regard label names, 
        it will report error later when the label is not empty
     *)     
     ptyp_loc = loc
    } ->
    begin match  Ast_attributes.process_attributes_rev ptyp_attributes with 
      | `Uncurry , ptyp_attributes ->
        Ast_util.to_uncurry_type loc self label args body 
      |  `Meth_callback, ptyp_attributes ->
        Ast_util.to_method_callback_type loc self label args body
      | `Method, ptyp_attributes ->
        Ast_util.to_method_type loc self label args body
      | `Nothing , _ -> 
        Ast_mapper.default_mapper.typ self ty
    end
  | {
    ptyp_desc =  Ptyp_object ( methods, closed_flag) ;
    ptyp_loc = loc 
  } -> 
    let (+>) attr (typ : Parsetree.core_type) =
      {typ with ptyp_attributes = attr :: typ.ptyp_attributes} in           
    let new_methods =
      List.fold_right (fun (label, ptyp_attrs, core_type) acc ->
          let get ty name attrs =
            let attrs, core_type =
              match Ast_attributes.process_attributes_rev attrs with
              | `Nothing, attrs -> attrs, ty (* #1678 *)
              | `Uncurry, attrs ->
                attrs, Ast_attributes.bs +> ty
              | `Method, _
                -> Location.raise_errorf ~loc "bs.get/set conflicts with bs.meth"
              | `Meth_callback, attrs ->
                attrs, Ast_attributes.bs_this +> ty 
            in 
            name , attrs, self.typ self core_type in
          let set ty name attrs =
            let attrs, core_type =
              match Ast_attributes.process_attributes_rev attrs with
              | `Nothing, attrs -> attrs, ty
              | `Uncurry, attrs ->
                attrs, Ast_attributes.bs +> ty 
              | `Method, _
                -> Location.raise_errorf ~loc "bs.get/set conflicts with bs.meth"
              | `Meth_callback, attrs ->
                attrs, Ast_attributes.bs_this +> ty
            in               
            name, attrs, Ast_util.to_method_type loc self "" core_type 
              (Ast_literal.type_unit ~loc ()) in
          let no ty =
            let attrs, core_type =
              match Ast_attributes.process_attributes_rev ptyp_attrs with
              | `Nothing, attrs -> attrs, ty
              | `Uncurry, attrs ->
                attrs, Ast_attributes.bs +> ty 
              | `Method, attrs -> 
                attrs, Ast_attributes.bs_method +> ty 
              | `Meth_callback, attrs ->
                attrs, Ast_attributes.bs_this +> ty  in            
            label, attrs, self.typ self core_type in
          process_getter_setter ~no ~get ~set
            loc label ptyp_attrs core_type acc
        ) methods [] in      
    let inner_type =
      { ty
        with ptyp_desc = Ptyp_object(new_methods, closed_flag);
      } in 
    if !record_as_js_object then 
      Ast_comb.to_js_type loc inner_type          
    else inner_type
  | _ -> super.typ self ty

let rec unsafe_mapper : Ast_mapper.mapper =   
  { Ast_mapper.default_mapper with 
    expr = (fun self ({ pexp_loc = loc } as e) -> 
        match e.pexp_desc with 
        (** Its output should not be rewritten anymore *)        
        | Pexp_extension (
            {txt = ("bs.raw" | "raw"); loc} , payload)
          -> 
          Ast_util.handle_raw loc payload
        | Pexp_extension (
            {txt = ("bs.re" | "re"); loc} , payload)
          ->
          Exp.constraint_ ~loc
            (Ast_util.handle_raw ~check_js_regex:true loc payload)
            (Ast_comb.to_js_re_type loc)
        | Pexp_extension ({txt = "bs.external" | "external" ; loc }, payload) -> 
          begin match Ast_payload.as_ident payload with 
          | Some {txt = Lident x}
            -> Ast_util.handle_external loc x
            (* do we need support [%external gg.xx ] 
               
               {[ Js.Undefined.to_opt (if Js.typeof x == "undefined" then x else Js.Undefined.empty ) ]}
            *)

          | None | Some _ -> 
            Location.raise_errorf ~loc 
            "external expects a single identifier"
          end 
        | Pexp_extension
            ({txt = ("bs.node" | "node"); loc},
             payload)
          ->
          let strip s =
            match s with 
            | "_module" -> "module" 
            | x -> x  in 
          begin match Ast_payload.as_ident payload with
            | Some {txt = Lident
                        ( "__filename"
                        | "__dirname"
                        | "_module"
                        | "require" as name); loc}
              ->
              let exp =
                Ast_util.handle_external loc (strip name)  in
              let typ =
                Ast_core_type.lift_option_type  
                 @@                 
                if name = "_module" then
                  Typ.constr ~loc
                    { txt = Ldot (Lident "Node", "node_module") ;
                      loc} []   
                else if name = "require" then
                  (Typ.constr ~loc
                     { txt = Ldot (Lident "Node", "node_require") ;
                       loc} [] )  
                else
                  Ast_literal.type_string ~loc () in                  
              Exp.constraint_ ~loc exp typ                
            | Some _ | None ->
              begin match payload with 
                | PTyp _ -> 
                  Location.raise_errorf 
                    ~loc "Illegal payload, expect an expression payload instead of type payload"              
                | PPat _ ->
                  Location.raise_errorf 
                    ~loc "Illegal payload, expect an expression payload instead of pattern  payload"        
                | _ -> 
                  Location.raise_errorf 
                    ~loc "Illegal payload"
              end

          end             
        |Pexp_constant (Const_string (s, (Some delim))) 
          ->         
          if Ext_string.equal delim Literals.unescaped_js_delimiter then 
            let js_str = Ast_utf8_string.transform loc s in 
            { e with pexp_desc = 
              Pexp_constant (Const_string (js_str, Some Literals.escaped_j_delimiter))}
          else if Ext_string.equal delim Literals.unescaped_j_delimiter then 
            Ast_utf8_string_interp.transform_interp loc s             
          else e 

        (** [bs.debugger], its output should not be rewritten any more*)
        | Pexp_extension ({txt = ("bs.debugger"|"debugger"); loc} , payload)
          -> {e with pexp_desc = Ast_util.handle_debugger loc payload}
        | Pexp_extension ({txt = ("bs.obj" | "obj"); loc},  payload)
          -> 
          begin match payload with 
            | PStr [{pstr_desc = Pstr_eval (e,_)}]
              -> 
              Ext_ref.non_exn_protect record_as_js_object true
                (fun () -> self.expr self e ) 
            | _ -> Location.raise_errorf ~loc "Expect an expression here"
          end
        | Pexp_extension({txt ; loc} as lid, PTyp typ) 
          when Ext_string.starts_with txt Literals.bs_deriving_dot -> 
          self.expr self @@ 
          Ast_derive.dispatch_extension lid typ

        (** End rewriting *)
        | Pexp_function cases -> 
          begin match Ast_attributes.process_pexp_fun_attributes_rev e.pexp_attributes with 
          | `Nothing, _ -> 
            Ast_mapper.default_mapper.expr self  e 
          | `Exn, pexp_attributes -> 
            Ast_util.convertBsErrorFunction loc self  pexp_attributes cases
          end
        | Pexp_fun ("", None, pat , body)
          ->
          begin match Ast_attributes.process_attributes_rev e.pexp_attributes with 
            | `Nothing, _ 
              -> Ast_mapper.default_mapper.expr self e 
            |   `Uncurry, pexp_attributes
              -> 
              {e with 
               pexp_desc = Ast_util.to_uncurry_fn loc self pat body  ;
               pexp_attributes}
            | `Method , _
              ->  Location.raise_errorf ~loc "bs.meth is not supported in function expression"
            | `Meth_callback , pexp_attributes
              -> 
              {e with pexp_desc = Ast_util.to_method_callback loc  self pat body ;
                      pexp_attributes }
          end
        | Pexp_apply (fn, args  ) ->
          begin match fn with 
            | {pexp_desc = 
                 Pexp_apply (
                   {pexp_desc = 
                      Pexp_ident  {txt = Lident "##"  ; loc} ; _},
                   [("", obj) ;
                    ("", {pexp_desc = Pexp_ident {txt = Lident name;_ } ; _} )
                   ]);
               _} ->  (* f##paint 1 2 *)
              {e with pexp_desc = Ast_util.method_apply loc self obj name args }
            | {pexp_desc = 
                 Pexp_apply (
                   {pexp_desc = 
                      Pexp_ident  {txt = Lident "#@"  ; loc} ; _},
                   [("", obj) ;
                    ("", {pexp_desc = Pexp_ident {txt = Lident name;_ } ; _} )
                   ]);
               _} ->  (* f##paint 1 2 *)
              {e with pexp_desc = Ast_util.property_apply loc self obj name args  }

            | {pexp_desc = 
                 Pexp_ident  {txt = Lident "##" ; loc} ; _} 
              -> 
              begin match args with 
                | [("", obj) ;
                   ("", {pexp_desc = Pexp_apply(
                        {pexp_desc = Pexp_ident {txt = Lident name;_ } ; _},
                        args
                      ); pexp_attributes = attrs }
                   (* we should warn when we discard attributes *)
                   )
                  ] -> (* f##(paint 1 2 ) *)
                  (* gpr#1063 foo##(bar##baz) we should rewrite (bar##baz) 
                     first  before pattern match. 
                     currently the pattern match is written in a top down style.
                     Another corner case: f##(g a b [@bs])
                  *)
                  Ast_attributes.warn_unused_attributes attrs ;  
                  {e with pexp_desc = Ast_util.method_apply loc self obj name args}
                | [("", obj) ;
                   ("", 
                    {pexp_desc = Pexp_ident {txt = Lident name;_ } ; _}
                   )  (* f##paint  *)
                  ] -> 
                  { e with pexp_desc = 
                             Ast_util.js_property loc (self.expr self obj) name  
                  }

                | _ -> 
                  Location.raise_errorf ~loc
                    "Js object ## expect syntax like obj##(paint (a,b)) "
              end
            (* we can not use [:=] for precedece cases 
               like {[i @@ x##length := 3 ]} 
               is parsed as {[ (i @@ x##length) := 3]}
               since we allow user to create Js objects in OCaml, it can be of
               ref type
               {[
                 let u = object (self)
                   val x = ref 3 
                   method setX x = self##x := 32
                   method getX () = !self##x
                 end
               ]}
            *)
            | {pexp_desc = 
                 Pexp_ident {txt = Lident  ("#=" )}
              } -> 
              begin match args with 
                | ["", 
                   {pexp_desc = 
                      Pexp_apply ({pexp_desc = Pexp_ident {txt = Lident "##"}}, 
                                  ["", obj; 
                                   "", {pexp_desc = Pexp_ident {txt = Lident name}}
                                  ]                                 
                                 )}; 
                   "", arg
                  ] -> 
                  Exp.constraint_ ~loc
                    { e with
                      pexp_desc =
                        Ast_util.method_apply loc self obj 
                          (name ^ Literals.setter_suffix) ["", arg ]  }
                    (Ast_literal.type_unit ~loc ())
                | _ -> Ast_mapper.default_mapper.expr self e 
              end
            | _ -> 

              begin match Ext_list.exclude_with_fact (function 
                  | {Location.txt = "bs"; _}, _ -> true 
                  | _ -> false) e.pexp_attributes with 
              | None, _ -> Ast_mapper.default_mapper.expr self e 
              | Some _, pexp_attributes -> 
                {e with pexp_desc = Ast_util.uncurry_fn_apply loc self fn args ;
                        pexp_attributes }
              end
          end
        | Pexp_record (label_exprs, opt_exp)  -> 
          if !record_as_js_object then
            (match opt_exp with
             | None ->              
               { e with
                 pexp_desc =  
                   Ast_util.record_as_js_object loc self label_exprs;
               }
             | Some e ->
               Location.raise_errorf
                 ~loc:e.pexp_loc "`with` construct is not supported in bs.obj ")
          else
            (* could be supported using `Object.assign`? 
               type 
               {[
                 external update : 'a Js.t -> 'b Js.t -> 'a Js.t = ""
                 constraint 'b :> 'a
               ]}
            *)
            Ast_mapper.default_mapper.expr  self e
        | Pexp_object {pcstr_self;  pcstr_fields} ->
          begin match Ast_attributes.process_bs e.pexp_attributes with
            | `Has, pexp_attributes
              ->
              {e with
               pexp_desc = 
                 Ast_util.ocaml_obj_as_js_object
                   loc self pcstr_self pcstr_fields;
               pexp_attributes               
              }                          
            | `Nothing , _ ->
              Ast_mapper.default_mapper.expr  self e              
          end            
        | _ ->  Ast_mapper.default_mapper.expr self e
      );
    typ = (fun self typ -> handle_core_type Ast_mapper.default_mapper self typ);
    class_type = 
      (fun self ({pcty_attributes; pcty_loc} as ctd) -> 
         match Ast_attributes.process_bs pcty_attributes with 
         | `Nothing,  _ -> 
           Ast_mapper.default_mapper.class_type
             self ctd 
         | `Has, pcty_attributes ->
           begin match ctd.pcty_desc with
             | Pcty_signature ({pcsig_self; pcsig_fields })
               ->
               let pcsig_self = self.typ self pcsig_self in 
               {ctd with
                pcty_desc = Pcty_signature {
                    pcsig_self ;
                    pcsig_fields = List.fold_right (handle_class_type_field self)  pcsig_fields []
                  };
                pcty_attributes                    
               }                    

             | Pcty_constr _
             | Pcty_extension _ 
             | Pcty_arrow _ ->
               Location.raise_errorf ~loc:pcty_loc "invalid or unused attribute `bs`"
               (* {[class x : int -> object 
                    end [@bs]
                  ]}
                  Actually this is not going to happpen as below is an invalid syntax
                  {[class type x = int -> object
                      end[@bs]]}
               *)
           end             
      );
    signature_item =  begin fun (self : Ast_mapper.mapper) (sigi : Parsetree.signature_item) -> 
      match sigi.psig_desc with 
      | Psig_type (_ :: _ as tdcls) -> 
        begin match Ast_attributes.process_derive_type 
                      (Ext_list.last tdcls).ptype_attributes  with 
        | {bs_deriving = `Has_deriving actions; explict_nonrec}, ptype_attributes
          -> Ast_signature.fuse 
               {sigi with 
                psig_desc = Psig_type
                    (
                      Ext_list.map_last (fun last tdcl -> 
                          if last then 
                            self.type_declaration self {tdcl with ptype_attributes}
                          else 
                            self.type_declaration self tdcl                            
                        ) tdcls
                    )
               }
               (self.signature 
                  self @@ 
                Ast_derive.type_deriving_signature tdcls actions explict_nonrec)
        | {bs_deriving = `Nothing }, _ -> 
          Ast_mapper.default_mapper.signature_item self sigi 

        end
      | Psig_value
          ({pval_attributes; 
            pval_type; 
            pval_loc;
            pval_prim;
            pval_name ;
           } as prim) 
        when Ast_attributes.process_external pval_attributes
        -> 
        let pval_type = self.typ self pval_type in
        let pval_attributes = self.attributes self pval_attributes in         
        let pval_type, pval_prim, pval_attributes = 
          match pval_prim with 
          | [ v ] -> 
            Ast_external_attributes.handle_attributes_as_string
              pval_loc 
              pval_name.txt 
              pval_type 
              pval_attributes v
          | _ -> Location.raise_errorf "only a single string is allowed in bs external" in
        {sigi with 
         psig_desc = 
           Psig_value
             {prim with
              pval_type ; 
              pval_prim ;
              pval_attributes 
             }}

      | _ -> Ast_mapper.default_mapper.signature_item self sigi
    end;
    pat = begin fun self (pat : Parsetree.pattern) -> 
      match pat with 
      | { ppat_desc = Ppat_constant(Const_string (_, Some "j")); ppat_loc = loc} -> 
        Location.raise_errorf ~loc 
          "Unicode string is not allowed in pattern match"
      | _  -> Ast_mapper.default_mapper.pat self pat

    end;
    structure_item = begin fun self (str : Parsetree.structure_item) -> 
      begin match str.pstr_desc with 
        | Pstr_extension ( ({txt = ("bs.raw"| "raw") ; loc}, payload), _attrs) 
          -> 
          Ast_util.handle_raw_structure loc payload
        | Pstr_type (_ :: _ as tdcls ) (* [ {ptype_attributes} as tdcl ] *)-> 
          begin match Ast_attributes.process_derive_type 
                        ((Ext_list.last tdcls).ptype_attributes) with 
          | {bs_deriving = `Has_deriving actions;
             explict_nonrec 
            }, ptype_attributes -> 
            Ast_structure.fuse 
              {str with 
               pstr_desc =
                 Pstr_type 
                   (Ext_list.map_last (fun last tdcl -> 
                        if last then 
                          self.type_declaration self {tdcl with ptype_attributes}
                        else 
                          self.type_declaration self tdcl) tdcls)
              }
              (self.structure self @@ Ast_derive.type_deriving_structure
                 tdcls actions explict_nonrec )
          | {bs_deriving = `Nothing}, _  -> 
            Ast_mapper.default_mapper.structure_item self str
          end
        | Pstr_primitive 
            ({pval_attributes; 
              pval_prim; 
              pval_type;
              pval_name;
              pval_loc} as prim) 
          when Ast_attributes.process_external pval_attributes
          -> 
          let pval_type = self.typ self pval_type in
          let pval_attributes = self.attributes self pval_attributes in         
          let pval_type, pval_prim, pval_attributes = 
            match pval_prim with 
            | [ v] -> 
              Ast_external_attributes.handle_attributes_as_string
                pval_loc
                pval_name.txt
                pval_type pval_attributes v

            | _ -> Location.raise_errorf "only a single string is allowed in bs external" in
          {str with 
           pstr_desc = 
             Pstr_primitive
               {prim with
                pval_type ; 
                pval_prim;
                pval_attributes 
               }}

        | _ -> Ast_mapper.default_mapper.structure_item self str 
      end
    end
  }




(** global configurations below *)
let common_actions_table : 
  (string *  (Parsetree.expression option -> unit)) list = 
  [ 
  ]


let structural_config_table  = 
  String_map.of_list 
    (( "no_export" , 
       (fun x -> 
          no_export := (
            match x with 
            |Some e -> Ast_payload.assert_bool_lit e 
            | None -> true)
       ))
     :: common_actions_table)

let signature_config_table : 
  (Parsetree.expression option -> unit) String_map.t= 
  String_map.of_list common_actions_table



let rewrite_signature : 
  (Parsetree.signature  -> Parsetree.signature) ref = 
  ref (fun  x -> 
      let result = 
        match (x : Parsetree.signature) with 
        | {psig_desc = Psig_attribute ({txt = "bs.config"; loc}, payload); _} :: rest 
          -> 
          begin 
            Ast_payload.ident_or_record_as_config loc payload 
            |> List.iter (Ast_payload.table_dispatch signature_config_table) ; 
            unsafe_mapper.signature unsafe_mapper rest
          end
        | _ -> 
          unsafe_mapper.signature  unsafe_mapper x in 
      reset (); result 
    )

let rewrite_implementation : (Parsetree.structure -> Parsetree.structure) ref = 
  ref (fun (x : Parsetree.structure) -> 
      let result = 
        match x with 
        | {pstr_desc = Pstr_attribute ({txt = "bs.config"; loc}, payload); _} :: rest 
          -> 
          begin 
            Ast_payload.ident_or_record_as_config loc payload 
            |> List.iter (Ast_payload.table_dispatch structural_config_table) ; 
            let rest = unsafe_mapper.structure unsafe_mapper rest in
            if !no_export then
              [Str.include_ ~loc  
                 (Incl.mk ~loc 
                    (Mod.constraint_ ~loc
                       (Mod.structure ~loc rest  )
                       (Mty.signature ~loc [])
                    ))]
            else rest 
          end
        | _ -> 
          unsafe_mapper.structure  unsafe_mapper x  in 
      reset (); result )


end
module Ocaml_parse : sig 
#1 "ocaml_parse.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

val parse_interface : Format.formatter -> string -> Parsetree.signature

val parse_implementation : Format.formatter -> string -> Parsetree.structure

val parse_implementation_from_string : string -> Parsetree.structure
val lazy_parse_interface : Format.formatter -> string -> Parsetree.signature lazy_t

val lazy_parse_implementation : Format.formatter -> string -> Parsetree.structure lazy_t
    
type valid_input = 
  | Ml 
  | Mli
  | Mlast    
  | Mliast 
  | Mlmap
  
val check_suffix :  string -> valid_input * string

end = struct
#1 "ocaml_parse.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

let parse_interface ppf sourcefile = 
  let ast = Pparse.parse_interface ~tool_name:Js_config.tool_name ppf sourcefile in
  if !Js_config.no_builtin_ppx_mli then ast else  !Ppx_entry.rewrite_signature ast

let lazy_parse_interface ppf sourcefile =
  lazy (parse_interface ppf sourcefile)

let parse_implementation ppf sourcefile = 
  let ast = 
    Pparse.parse_implementation ~tool_name:Js_config.tool_name ppf sourcefile in 
  if !Js_config.no_builtin_ppx_ml then ast else
    !Ppx_entry.rewrite_implementation ast 

let parse_implementation_from_string  str = 
  let lb = Lexing.from_string str in
  Location.init lb "//toplevel//";
  let ast = Parse.implementation lb  in 
  if !Js_config.no_builtin_ppx_ml then ast else 
    !Ppx_entry.rewrite_implementation ast 


let lazy_parse_implementation ppf sourcefile =
  lazy (parse_implementation ppf sourcefile)

type valid_input = 
  | Ml 
  | Mli
  | Mlast    
  | Mliast 
  | Mlmap
  
let check_suffix  name  = 
  if Filename.check_suffix name ".ml"
  || Filename.check_suffix name ".mlt" then 
    Ml,
    (** This is per-file based, 
        when [ocamlc] [-c -o another_dir/xx.cmi] 
        it will return (another_dir/xx)
    *)    
    Compenv.output_prefix name 
  else if Filename.check_suffix name !Config.interface_suffix then 
    Mli,  Compenv.output_prefix name 
  else if Filename.check_suffix name ".mlast" then 
    Mlast, Compenv.output_prefix name 
  else if Filename.check_suffix name ".mliast" then 
    Mliast, Compenv.output_prefix name 
  else if Filename.check_suffix name ".mlmap"  then 
    Mlmap, Compenv.output_prefix name 
  else 
    raise(Arg.Bad("don't know what to do with " ^ name))

end
module Pprintast : sig 
#1 "pprintast.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Hongbo Zhang (University of Pennsylvania)                *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

type space_formatter = (unit, Format.formatter, unit) format
class printer :
  unit ->
  object ('b)
    val pipe : bool
    val semi : bool
    method binding :
      Format.formatter -> Parsetree.value_binding -> unit
    method bindings:
        Format.formatter ->
          Asttypes.rec_flag * Parsetree.value_binding list ->
            unit
    method case_list :
      Format.formatter -> Parsetree.case list -> unit
    method class_expr : Format.formatter -> Parsetree.class_expr -> unit
    method class_field : Format.formatter -> Parsetree.class_field -> unit
    method class_params_def :
      Format.formatter -> (Parsetree.core_type * Asttypes.variance) list -> unit
    method class_signature :
      Format.formatter -> Parsetree.class_signature -> unit
    method class_structure :
      Format.formatter -> Parsetree.class_structure -> unit
    method class_type : Format.formatter -> Parsetree.class_type -> unit
    method class_type_declaration_list :
      Format.formatter -> Parsetree.class_type_declaration list -> unit
    method constant : Format.formatter -> Asttypes.constant -> unit
    method constant_string : Format.formatter -> string -> unit
    method core_type : Format.formatter -> Parsetree.core_type -> unit
    method core_type1 : Format.formatter -> Parsetree.core_type -> unit
    method direction_flag :
      Format.formatter -> Asttypes.direction_flag -> unit
    method directive_argument :
      Format.formatter -> Parsetree.directive_argument -> unit
    method exception_declaration :
      Format.formatter -> Parsetree.extension_constructor -> unit
    method expression : Format.formatter -> Parsetree.expression -> unit
    method expression1 : Format.formatter -> Parsetree.expression -> unit
    method expression2 : Format.formatter -> Parsetree.expression -> unit
    method extension_constructor :
      Format.formatter -> Parsetree.extension_constructor -> unit
    method label_exp :
      Format.formatter ->
      Asttypes.label * Parsetree.expression option * Parsetree.pattern ->
      unit
    method label_x_expression_param :
      Format.formatter -> Asttypes.label * Parsetree.expression -> unit
    method list :
      ?sep:space_formatter ->
      ?first:space_formatter ->
      ?last:space_formatter ->
      (Format.formatter -> 'a -> unit) -> Format.formatter -> 'a list -> unit
    method longident : Format.formatter -> Longident.t -> unit
    method longident_loc :
      Format.formatter -> Longident.t Asttypes.loc -> unit
    method module_expr : Format.formatter -> Parsetree.module_expr -> unit
    method module_type : Format.formatter -> Parsetree.module_type -> unit
    method mutable_flag : Format.formatter -> Asttypes.mutable_flag -> unit
    method option :
      ?first:space_formatter ->
      ?last:space_formatter ->
      (Format.formatter -> 'a -> unit) ->
      Format.formatter -> 'a option -> unit
    method paren :
        ?first:space_formatter -> ?last:space_formatter -> bool ->
          (Format.formatter -> 'a -> unit) -> Format.formatter -> 'a -> unit
    method pattern : Format.formatter -> Parsetree.pattern -> unit
    method pattern1 : Format.formatter -> Parsetree.pattern -> unit
    method payload : Format.formatter -> Parsetree.payload -> unit
    method private_flag : Format.formatter -> Asttypes.private_flag -> unit
    method rec_flag : Format.formatter -> Asttypes.rec_flag -> unit
    method nonrec_flag : Format.formatter -> Asttypes.rec_flag -> unit

    method reset : 'b
    method reset_semi : 'b
    method reset_ifthenelse : 'b
    method reset_pipe : 'b

    method signature :
      Format.formatter -> Parsetree.signature_item list -> unit
    method signature_item :
      Format.formatter -> Parsetree.signature_item -> unit
    method simple_expr : Format.formatter -> Parsetree.expression -> unit
    method simple_pattern : Format.formatter -> Parsetree.pattern -> unit
    method string_quot : Format.formatter -> Asttypes.label -> unit
    method structure :
      Format.formatter -> Parsetree.structure_item list -> unit
    method structure_item :
      Format.formatter -> Parsetree.structure_item -> unit
    method sugar_expr : Format.formatter -> Parsetree.expression -> bool
    method toplevel_phrase :
      Format.formatter -> Parsetree.toplevel_phrase -> unit
    method type_declaration :
      Format.formatter -> Parsetree.type_declaration -> unit
    method type_def_list :
      Format.formatter -> Parsetree.type_declaration list -> unit
    method type_extension :
      Format.formatter -> Parsetree.type_extension -> unit
    method type_param :
      Format.formatter -> Parsetree.core_type * Asttypes.variance -> unit
    method type_params :
      Format.formatter -> (Parsetree.core_type * Asttypes.variance) list -> unit
    method type_with_label :
      Format.formatter -> Asttypes.label * Parsetree.core_type -> unit
    method tyvar : Format.formatter -> string -> unit
    method under_pipe : 'b
    method under_semi : 'b
    method under_ifthenelse : 'b
    method value_description :
      Format.formatter -> Parsetree.value_description -> unit
    method virtual_flag : Format.formatter -> Asttypes.virtual_flag -> unit
    method attribute : Format.formatter -> Parsetree.attribute -> unit
    method item_attribute : Format.formatter -> Parsetree.attribute -> unit
    method floating_attribute : Format.formatter -> Parsetree.attribute -> unit
    method attributes : Format.formatter -> Parsetree.attributes -> unit
    method item_attributes : Format.formatter -> Parsetree.attributes -> unit
    method extension : Format.formatter -> Parsetree.extension -> unit
    method item_extension : Format.formatter -> Parsetree.extension -> unit
  end
val default : printer
val toplevel_phrase : Format.formatter -> Parsetree.toplevel_phrase -> unit
val expression : Format.formatter -> Parsetree.expression -> unit
val string_of_expression : Parsetree.expression -> string
val top_phrase: Format.formatter -> Parsetree.toplevel_phrase -> unit
val core_type: Format.formatter -> Parsetree.core_type -> unit
val pattern: Format.formatter -> Parsetree.pattern -> unit
val signature: Format.formatter -> Parsetree.signature -> unit
val structure: Format.formatter -> Parsetree.structure -> unit
val string_of_structure: Parsetree.structure -> string

end = struct
#1 "pprintast.ml"
(**************************************************************************)
(*                                                                        *)
(*                                OCaml                                   *)
(*                                                                        *)
(*    Thomas Gazagnaire (OCamlPro), Fabrice Le Fessant (INRIA Saclay)     *)
(*    Hongbo Zhang (University of Pennsylvania)                           *)
(*   Copyright 2007 Institut National de Recherche en Informatique et     *)
(*   en Automatique.  All rights reserved.  This file is distributed      *)
(*   under the terms of the Q Public License version 1.0.                 *)
(*                                                                        *)
(**************************************************************************)

(* Original Code from Ber-metaocaml, modified for 3.12.0 and fixed *)
(* Printing code expressions *)
(* Authors:  Ed Pizzi, Fabrice Le Fessant *)
(* Extensive Rewrite: Hongbo Zhang: University of Pennsylvania *)
(* TODO more fine-grained precedence pretty-printing *)

open Asttypes
open Format
open Location
open Longident
open Parsetree

let prefix_symbols  = [ '!'; '?'; '~' ] ;;
let infix_symbols = [ '='; '<'; '>'; '@'; '^'; '|'; '&'; '+'; '-'; '*'; '/';
                      '$'; '%' ]
let operator_chars = [ '!'; '$'; '%'; '&'; '*'; '+'; '-'; '.'; '/';
                       ':'; '<'; '='; '>'; '?'; '@'; '^'; '|'; '~' ]
let numeric_chars  = [ '0'; '1'; '2'; '3'; '4'; '5'; '6'; '7'; '8'; '9' ]

(* type fixity = Infix| Prefix  *)

let special_infix_strings =
  ["asr"; "land"; "lor"; "lsl"; "lsr"; "lxor"; "mod"; "or"; ":="; "!=" ]

(* determines if the string is an infix string.
   checks backwards, first allowing a renaming postfix ("_102") which
   may have resulted from Pexp -> Texp -> Pexp translation, then checking
   if all the characters in the beginning of the string are valid infix
   characters. *)
let fixity_of_string  = function
  | s when List.mem s special_infix_strings -> `Infix s
  | s when List.mem s.[0] infix_symbols -> `Infix s
  | s when List.mem s.[0] prefix_symbols -> `Prefix s
  | _ -> `Normal

let view_fixity_of_exp = function
  | {pexp_desc = Pexp_ident {txt=Lident l;_};_} -> fixity_of_string l
  | _ -> `Normal  ;;

let is_infix  = function  | `Infix _ -> true | _  -> false

let is_predef_option = function
  | (Ldot (Lident "*predef*","option")) -> true
  | _ -> false

(* which identifiers are in fact operators needing parentheses *)
let needs_parens txt =
  is_infix (fixity_of_string txt)
  || List.mem txt.[0] prefix_symbols

(* some infixes need spaces around parens to avoid clashes with comment
   syntax *)
let needs_spaces txt =
  txt.[0]='*' || txt.[String.length txt - 1] = '*'

(* add parentheses to binders when they are in fact infix or prefix operators *)
let protect_ident ppf txt =
  let format : (_, _, _) format =
    if not (needs_parens txt) then "%s"
    else if needs_spaces txt then "(@;%s@;)"
    else "(%s)"
  in fprintf ppf format txt

let protect_longident ppf print_longident longprefix txt =
  let format : (_, _, _) format =
    if not (needs_parens txt) then "%a.%s"
    else if needs_spaces txt then  "%a.(@;%s@;)"
    else "%a.(%s)" in
  fprintf ppf format print_longident longprefix txt

type space_formatter = (unit, Format.formatter, unit) format

let override = function
  | Override -> "!"
  | Fresh -> ""

(* variance encoding: need to sync up with the [parser.mly] *)
let type_variance = function
  | Invariant -> ""
  | Covariant -> "+"
  | Contravariant -> "-"

type construct =
  [ `cons of expression list
  | `list of expression list
  | `nil
  | `normal
  | `simple of Longident.t
  | `tuple ]

let view_expr x =
  match x.pexp_desc with
  | Pexp_construct ( {txt= Lident "()"; _},_) -> `tuple
  | Pexp_construct ( {txt= Lident "[]";_},_) -> `nil
  | Pexp_construct ( {txt= Lident"::";_},Some _) ->
      let rec loop exp acc = match exp with
          | {pexp_desc=Pexp_construct ({txt=Lident "[]";_},_);_} ->
              (List.rev acc,true)
          | {pexp_desc=
             Pexp_construct ({txt=Lident "::";_},
                             Some ({pexp_desc= Pexp_tuple([e1;e2]);_}));_} ->
              loop e2 (e1::acc)
          | e -> (List.rev (e::acc),false) in
      let (ls,b) = loop x []  in
      if b then
        `list ls
      else `cons ls
  | Pexp_construct (x,None) -> `simple (x.txt)
  | _ -> `normal

let is_simple_construct :construct -> bool = function
  | `nil | `tuple | `list _ | `simple _  -> true
  | `cons _ | `normal -> false

let pp = fprintf

class printer  ()= object(self:'self)
  val pipe = false
  val semi = false
  val ifthenelse = false
  method under_pipe = {<pipe=true>}
  method under_semi = {<semi=true>}
  method under_ifthenelse = {<ifthenelse=true>}
  method reset_semi = {<semi=false>}
  method reset_ifthenelse = {<ifthenelse=false>}
  method reset_pipe = {<pipe=false>}
  method reset = {<pipe=false;semi=false;ifthenelse=false>}
  method list : 'a . ?sep:space_formatter -> ?first:space_formatter ->
    ?last:space_formatter -> (Format.formatter -> 'a -> unit) ->
    Format.formatter -> 'a list -> unit
        = fun  ?sep ?first  ?last fu f xs ->
          let first = match first with Some x -> x |None -> ""
          and last = match last with Some x -> x |None -> ""
          and sep = match sep with Some x -> x |None -> "@ " in
          let aux f = function
            | [] -> ()
            | [x] -> fu f x
            | xs ->
                let rec loop  f = function
                  | [x] -> fu f x
                  | x::xs ->  fu f x; pp f sep; loop f xs;
                  | _ -> assert false in begin
                      pp f first; loop f xs; pp f last;
                  end in
          aux f xs
  method option : 'a. ?first:space_formatter -> ?last:space_formatter ->
    (Format.formatter -> 'a -> unit) -> Format.formatter -> 'a option -> unit =
      fun  ?first  ?last fu f a ->
        let first = match first with Some x -> x | None -> ""
        and last = match last with Some x -> x | None -> "" in
        match a with
        | None -> ()
        | Some x -> pp f first; fu f x; pp f last;
  method paren: 'a . ?first:space_formatter -> ?last:space_formatter ->
    bool -> (Format.formatter -> 'a -> unit) -> Format.formatter -> 'a -> unit =
    fun  ?(first="") ?(last="") b fu f x ->
      if b then (pp f "("; pp f first; fu f x; pp f last; pp f ")")
      else fu f x


  method longident f = function
    | Lident s -> protect_ident f s
    | Ldot(y,s) -> protect_longident f self#longident y s
    | Lapply (y,s) ->
        pp f "%a(%a)" self#longident y self#longident s
  method longident_loc f x = pp f "%a" self#longident x.txt
  method constant f  = function
    | Const_char i -> pp f "%C"  i
    | Const_string (i, None) -> pp f "%S" i
    | Const_string (i, Some delim) -> pp f "{%s|%s|%s}" delim i delim
    | Const_int i -> self#paren (i<0) (fun f -> pp f "%d") f i
    | Const_float  i -> self#paren (i.[0]='-') (fun f -> pp f "%s") f i
    | Const_int32 i -> self#paren (i<0l) (fun f -> pp f "%ldl") f i
    | Const_int64 i -> self#paren (i<0L) (fun f -> pp f "%LdL") f i
                                         (* pp f "%LdL" i *)
    | Const_nativeint i -> self#paren (i<0n) (fun f -> pp f "%ndn") f i
                                             (* pp f "%ndn" i *)

  (* trailing space*)
  method mutable_flag f   = function
    | Immutable -> ()
    | Mutable -> pp f "mutable@;"
  method virtual_flag f  = function
    | Concrete -> ()
    | Virtual -> pp f "virtual@;"

  (* trailing space added *)
  method rec_flag f rf =
    match rf with
    | Nonrecursive -> ()
    | Recursive -> pp f "rec "
  method nonrec_flag f rf =
    match rf with
    | Nonrecursive -> pp f "nonrec "
    | Recursive -> ()
  method direction_flag f = function
    | Upto -> pp f "to@ "
    | Downto -> pp f "downto@ "
  method private_flag f = function
    | Public -> ()
    | Private -> pp f "private@ "

  method constant_string f s = pp f "%S" s
  method tyvar f str = pp f "'%s" str
  method string_quot f x = pp f "`%s" x

          (* c ['a,'b] *)
  method class_params_def f =  function
    | [] -> ()
    | l ->
        pp f "[%a] " (* space *)
          (self#list self#type_param ~sep:",") l

  method type_with_label f (label,({ptyp_desc;_}as c) ) =
    match label with
    | "" ->  self#core_type1 f c (* otherwise parenthesize *)
    | s  ->
        if s.[0]='?' then
          match ptyp_desc with
          | Ptyp_constr ({txt;_}, l) ->
              assert (is_predef_option txt);
              pp f "%s:%a" s (self#list self#core_type1) l
          | _ -> failwith "invalid input in print_type_with_label"
        else pp f "%s:%a" s self#core_type1 c
  method core_type f x =
    if x.ptyp_attributes <> [] then begin
      pp f "((%a)%a)" self#core_type {x with ptyp_attributes=[]}
        self#attributes x.ptyp_attributes
    end
    else match x.ptyp_desc with
    | Ptyp_arrow (l, ct1, ct2) ->
        pp f "@[<2>%a@;->@;%a@]" (* FIXME remove parens later *)
          self#type_with_label (l,ct1) self#core_type ct2
    | Ptyp_alias (ct, s) ->
        pp f "@[<2>%a@;as@;'%s@]" self#core_type1 ct s
    | Ptyp_poly (sl, ct) ->
        pp f "@[<2>%a%a@]"
          (fun f l ->
            pp f "%a"
              (fun f l -> match l with
              | [] -> ()
              | _ ->
                  pp f "%a@;.@;"
                    (self#list self#tyvar ~sep:"@;")  l)
              l)
          sl  self#core_type ct
    | _ -> pp f "@[<2>%a@]" self#core_type1 x
  method core_type1 f x =
    if x.ptyp_attributes <> [] then self#core_type f x
    else match x.ptyp_desc with
    | Ptyp_any -> pp f "_";
    | Ptyp_var s -> self#tyvar f  s;
    | Ptyp_tuple l ->  pp f "(%a)" (self#list self#core_type1 ~sep:"*@;") l
    | Ptyp_constr (li, l) ->
        pp f (* "%a%a@;" *) "%a%a"
          (fun f l -> match l with
          |[] -> ()
          |[x]-> pp f "%a@;" self#core_type1  x
          | _ -> self#list ~first:"(" ~last:")@;" self#core_type ~sep:"," f l)
          l self#longident_loc li
    | Ptyp_variant (l, closed, low) ->
        let type_variant_helper f x =
          match x with
          | Rtag (l, attrs, _, ctl) -> pp f "@[<2>%a%a@;%a@]" self#string_quot l
                (fun f l -> match l with
                |[] -> ()
                | _ -> pp f "@;of@;%a"
                      (self#list self#core_type ~sep:"&")  ctl) ctl
                self#attributes attrs
          | Rinherit ct -> self#core_type f ct in
        pp f "@[<2>[%a%a]@]"
          (fun f l
            ->
              match l with
              | [] -> ()
              | _ ->
              pp f "%s@;%a"
                (match (closed,low) with
                | (Closed,None) -> ""
                | (Closed,Some _) -> "<" (* FIXME desugar the syntax sugar*)
                | (Open,_) -> ">")
                (self#list type_variant_helper ~sep:"@;<1 -2>| ") l) l
          (fun f low
            ->
              match low with
              |Some [] |None -> ()
              |Some xs ->
              pp f ">@ %a"
                (self#list self#string_quot) xs) low
    | Ptyp_object (l, o) ->
        let core_field_type f (s, attrs, ct) =
          pp f "@[<hov2>%s%a@ :%a@ @]" s
             self#attributes attrs self#core_type ct
        in
        let field_var f = function
          | Asttypes.Closed -> ()
          | Asttypes.Open ->
              match l with
              | [] -> pp f ".."
              | _ -> pp f " ;.."
        in
        pp f "@[<hov2><@ %a%a@ >@]" (self#list core_field_type ~sep:";") l
          field_var o
    | Ptyp_class (li, l) ->   (*FIXME*)
        pp f "@[<hov2>%a#%a@]"
          (self#list self#core_type ~sep:"," ~first:"(" ~last:")") l
          self#longident_loc li
    | Ptyp_package (lid, cstrs) ->
        let aux f (s, ct) =
          pp f "type %a@ =@ %a" self#longident_loc s self#core_type ct  in
        (match cstrs with
        |[] -> pp f "@[<hov2>(module@ %a)@]" self#longident_loc lid
        |_ ->
            pp f "@[<hov2>(module@ %a@ with@ %a)@]" self#longident_loc lid
              (self#list aux  ~sep:"@ and@ ")  cstrs)
    | Ptyp_extension e -> self#extension f e
    | _ -> self#paren true self#core_type f x
          (********************pattern********************)
          (* be cautious when use [pattern], [pattern1] is preferred *)
  method pattern f x =
    let rec list_of_pattern acc = function (* only consider ((A|B)|C)*)
      | {ppat_desc= Ppat_or (p1,p2);_} ->
          list_of_pattern  (p2::acc) p1
      | x -> x::acc in
    if x.ppat_attributes <> [] then begin
      pp f "((%a)%a)" self#pattern {x with ppat_attributes=[]}
        self#attributes x.ppat_attributes
    end
    else match x.ppat_desc with
    | Ppat_alias (p, s) -> pp f "@[<2>%a@;as@;%a@]"
          self#pattern p protect_ident s.txt (* RA*)
    | Ppat_or (p1, p2) -> (* *)
        pp f "@[<hov0>%a@]" (self#list ~sep:"@,|" self#pattern)
           (list_of_pattern [] x)
    | _ -> self#pattern1 f x
  method pattern1 (f:Format.formatter) (x:pattern) :unit =
    let rec pattern_list_helper f  =  function
      | {ppat_desc =
         Ppat_construct
           ({ txt = Lident("::") ;_},
            Some ({ppat_desc = Ppat_tuple([pat1; pat2]);_})); _}
            ->
              pp f "%a::%a"  self#simple_pattern  pat1  pattern_list_helper pat2 (*RA*)
      | p -> self#pattern1 f p in
    if x.ppat_attributes <> [] then self#pattern f x
    else match x.ppat_desc with
    | Ppat_variant (l, Some p) ->  pp f "@[<2>`%s@;%a@]" l self#simple_pattern p
    | Ppat_construct (({txt=Lident("()"|"[]");_}), _) -> self#simple_pattern f x
    | Ppat_construct (({txt;_} as li), po) -> (* FIXME The third field always false *)
        if txt = Lident "::" then
          pp f "%a" pattern_list_helper x
        else
          (match po with
          |Some x ->
              pp f "%a@;%a"  self#longident_loc li self#simple_pattern x
          | None -> pp f "%a@;"self#longident_loc li )
    | _ -> self#simple_pattern f x
  method simple_pattern (f:Format.formatter) (x:pattern) :unit =
    if x.ppat_attributes <> [] then self#pattern f x
    else match x.ppat_desc with
    | Ppat_construct (({txt=Lident ("()"|"[]" as x);_}), _) -> pp f  "%s" x
    | Ppat_any -> pp f "_";
    | Ppat_var ({txt = txt;_}) -> protect_ident f txt
    | Ppat_array l ->
        pp f "@[<2>[|%a|]@]"  (self#list self#pattern1 ~sep:";") l
    | Ppat_unpack (s) ->
        pp f "(module@ %s)@ " s.txt
    | Ppat_type li ->
        pp f "#%a" self#longident_loc li
    | Ppat_record (l, closed) ->
        let longident_x_pattern f (li, p) =
          match (li,p.ppat_desc) with
          | ({txt=Lident s;_ },Ppat_var {txt;_} ) when s = txt ->
              pp f "@[<2>%a@]"  self#longident_loc li
          | _ ->
            pp f "@[<2>%a@;=@;%a@]" self#longident_loc li self#pattern1 p in
        (match closed with
        |Closed ->
            pp f "@[<2>{@;%a@;}@]"
              (self#list longident_x_pattern ~sep:";@;") l
        | _ ->
            pp f "@[<2>{@;%a;_}@]"
              (self#list longident_x_pattern ~sep:";@;") l)
    | Ppat_tuple l -> pp f "@[<1>(%a)@]" (self#list  ~sep:"," self#pattern1)  l (* level1*)
    | Ppat_constant (c) -> pp f "%a" self#constant c
    | Ppat_interval (c1, c2) -> pp f "%a..%a" self#constant c1 self#constant c2
    | Ppat_variant (l,None) ->  pp f "`%s" l
    | Ppat_constraint (p, ct) ->
        pp f "@[<2>(%a@;:@;%a)@]" self#pattern1 p self#core_type ct
    | Ppat_lazy p ->
        pp f "@[<2>(lazy@;%a)@]" self#pattern1 p
    | Ppat_exception p ->
        pp f "@[<2>exception@;%a@]" self#pattern1 p
    | Ppat_extension e -> self#extension f e
    | _ -> self#paren true self#pattern f x

  method label_exp f (l,opt,p) =
    if l = "" then
      pp f "%a@ " self#simple_pattern p (*single case pattern parens needed here *)
    else
      if l.[0] = '?' then
        let len = String.length l - 1 in
        let rest = String.sub l 1 len in begin
          match p.ppat_desc with
          | Ppat_var {txt;_} when txt = rest ->
              (match opt with
               | Some o -> pp f "?(%s=@;%a)@;" rest  self#expression o
               | None -> pp f "?%s@ " rest)
          | _ ->
              (match opt with
               | Some o ->
                   pp f "%s:(%a=@;%a)@;" l self#pattern1 p self#expression o
               | None -> pp f "%s:%a@;" l self#simple_pattern p)
        end
      else
        (match p.ppat_desc with
        | Ppat_var {txt;_} when txt = l ->
            pp f "~%s@;" l
        | _ ->  pp f "~%s:%a@;" l self#simple_pattern p )
  method sugar_expr f e =
    if e.pexp_attributes <> [] then false
      (* should also check attributes underneath *)
    else match e.pexp_desc with
    | Pexp_apply
        ({pexp_desc=
          Pexp_ident
            {txt= Ldot (Lident (("Array"|"String") as s),"get");_};_},
         [(_,e1);(_,e2)]) -> begin
              let fmt:(_,_,_)format =
                if s= "Array" then "@[%a.(%a)@]" else "@[%a.[%a]@]" in
              pp f fmt   self#simple_expr e1 self#expression e2;
              true
            end
    |Pexp_apply
        ({pexp_desc=
          Pexp_ident
            {txt= Ldot (Lident (("Array"|"String") as s),
                        "set");_};_},[(_,e1);(_,e2);(_,e3)])
      ->
        let fmt :(_,_,_) format=
          if s= "Array" then
            "@[%a.(%a)@ <-@;%a@]"
          else
            "@[%a.[%a]@ <-@;%a@]" in  (* @;< gives error here *)
        pp f fmt self#simple_expr e1  self#expression e2  self#expression e3;
        true
    | Pexp_apply ({pexp_desc=Pexp_ident {txt=Lident "!";_};_}, [(_,e)]) -> begin
        pp f "@[<hov>!%a@]" self#simple_expr e;
        true
    end
    | Pexp_apply
        ({pexp_desc=Pexp_ident
                     {txt= Ldot (Ldot (Lident "Bigarray", array),
                                 ("get"|"set" as gs)) ;_};_},
         label_exprs) ->
           begin match array, gs, label_exprs with
           | "Genarray", "get",
             [(_,a);(_,{pexp_desc=Pexp_array ls;_})] ->
               pp f "@[%a.{%a}@]" self#simple_expr a
                 (self#list ~sep:"," self#simple_expr ) ls;
               true
           | "Genarray", "set",
             [(_,a);(_,{pexp_desc=Pexp_array ls;_});(_,c)] ->
               pp f "@[%a.{%a}@ <-@ %a@]" self#simple_expr a
                 (self#list ~sep:"," self#simple_expr ) ls self#simple_expr c;
               true
           | "Array1", "set", [(_,a);(_,i);(_,v)] ->
               pp f "@[%a.{%a}@ <-@ %a@]"
                  self#simple_expr a
                  self#simple_expr i
                  self#simple_expr v;
               true
           | "Array2", "set", [(_,a);(_,i1);(_,i2);(_,v)] ->
               pp f "@[%a.{%a,%a}@ <-@ %a@]"
                  self#simple_expr a
                  self#simple_expr i1
                  self#simple_expr i2
                  self#simple_expr v;
               true
           | "Array3", "set", [(_,a);(_,i1);(_,i2);(_,i3);(_,v)] ->
               pp f "@[%a.{%a,%a,%a}@ <-@ %a@]"
                  self#simple_expr a
                  self#simple_expr i1
                  self#simple_expr i2
                  self#simple_expr i3
                  self#simple_expr v;
               true
           | "Array1", "get", [(_,a);(_,i)] ->
               pp f "@[%a.{%a}@]"
                  self#simple_expr a
                  self#simple_expr i;
               true
           | "Array2", "get", [(_,a);(_,i1);(_,i2)] ->
               pp f "@[%a.{%a,%a}@]"
                  self#simple_expr a
                  self#simple_expr i1
                  self#simple_expr i2;
               true
           | "Array3", "get", [(_,a);(_,i1);(_,i2);(_,i3)] ->
               pp f "@[%a.{%a,%a,%a}@]"
                  self#simple_expr a
                  self#simple_expr i1
                  self#simple_expr i2
                  self#simple_expr i3;
               true
           | _ -> false
           end
    | _ -> false
  method expression f x =
    if x.pexp_attributes <> [] then begin
      pp f "((%a)%a)" self#expression {x with pexp_attributes=[]}
        self#attributes x.pexp_attributes
    end
    else match x.pexp_desc with
    | Pexp_function _ | Pexp_fun _ | Pexp_match _ | Pexp_try _ | Pexp_sequence _
      when pipe || semi ->
        self#paren true self#reset#expression f x
    | Pexp_ifthenelse _ | Pexp_sequence _ when ifthenelse ->
        self#paren true self#reset#expression f x
    | Pexp_let _ | Pexp_letmodule _ when semi ->
        self#paren true self#reset#expression f x
    | Pexp_fun (l, e0, p, e) ->
        pp f "@[<2>fun@;%a@;->@;%a@]"
          self#label_exp (l, e0, p)
          self#expression e
    | Pexp_function l ->
        pp f "@[<hv>function%a@]" self#case_list l
    | Pexp_match (e, l) ->
        pp f "@[<hv0>@[<hv0>@[<2>match %a@]@ with@]%a@]" self#reset#expression e self#case_list l

    | Pexp_try (e, l) ->
        pp f "@[<0>@[<hv2>try@ %a@]@ @[<0>with%a@]@]" (* "try@;@[<2>%a@]@\nwith@\n%a"*)
          self#reset#expression e  self#case_list l
    | Pexp_let (rf, l, e) ->
        (* pp f "@[<2>let %a%a in@;<1 -2>%a@]" (\*no identation here, a new line*\) *)
        (*   self#rec_flag rf *)
        pp f "@[<2>%a in@;<1 -2>%a@]"
          self#reset#bindings (rf,l)
          self#expression e
    | Pexp_apply (e, l) ->
        (if not (self#sugar_expr f x) then
          match view_fixity_of_exp e with
          | `Infix s ->
            (match l with
            | [ arg1; arg2 ] ->
                pp f "@[<2>%a@;%s@;%a@]" (* FIXME associativity lable_x_expression_parm*)
                  self#reset#label_x_expression_param  arg1 s  self#label_x_expression_param arg2
            | _ ->
                pp f "@[<2>%a %a@]" self#simple_expr e  (self#list self#label_x_expression_param)  l)
          | `Prefix s ->
              let s =
                if List.mem s ["~+";"~-";"~+.";"~-."] then String.sub s 1 (String.length s -1)
                else s in
            (match l with
            |[v] -> pp f "@[<2>%s@;%a@]" s self#label_x_expression_param v
            | _ -> pp f "@[<2>%s@;%a@]" s (self#list self#label_x_expression_param) l  (*FIXME assert false*)
            )
          | _ ->
            pp f "@[<hov2>%a@]" begin fun f (e,l) ->
              pp f "%a@ %a" self#expression2 e
                (self#list self#reset#label_x_expression_param)  l
               (*reset here only because [function,match,try,sequence] are lower priority*)
            end (e,l))

    | Pexp_construct (li, Some eo)
      when not (is_simple_construct (view_expr x))-> (* Not efficient FIXME*)
        (match view_expr x with
        | `cons ls -> self#list self#simple_expr f ls ~sep:"@;::@;"
        | `normal ->
            pp f "@[<2>%a@;%a@]" self#longident_loc li
              self#simple_expr  eo
        | _ -> assert false)
    | Pexp_setfield (e1, li, e2) ->
        pp f "@[<2>%a.%a@ <-@ %a@]" self#simple_expr  e1  self#longident_loc li self#expression e2;
    | Pexp_ifthenelse (e1, e2, eo) ->
        (* @;@[<2>else@ %a@]@] *)
        let fmt:(_,_,_)format ="@[<hv0>@[<2>if@ %a@]@;@[<2>then@ %a@]%a@]" in
        pp f fmt  self#under_ifthenelse#expression e1 self#under_ifthenelse#expression e2
          (fun f eo -> match eo with
          | Some x -> pp f "@;@[<2>else@;%a@]" self#under_semi#expression  x
          | None -> () (* pp f "()" *)) eo
    | Pexp_sequence _ ->
        let rec sequence_helper acc = function
          | {pexp_desc=Pexp_sequence(e1,e2);_} ->
              sequence_helper (e1::acc) e2
          | v -> List.rev (v::acc) in
        let lst = sequence_helper [] x in
        pp f "@[<hv>%a@]"
          (self#list self#under_semi#expression ~sep:";@;") lst
    | Pexp_new (li) ->
        pp f "@[<hov2>new@ %a@]" self#longident_loc li;
    | Pexp_setinstvar (s, e) ->
        pp f "@[<hov2>%s@ <-@ %a@]" s.txt self#expression e
    | Pexp_override l -> (* FIXME *)
        let string_x_expression f (s, e) =
          pp f "@[<hov2>%s@ =@ %a@]" s.txt self#expression e in
        pp f "@[<hov2>{<%a>}@]"
          (self#list string_x_expression  ~sep:";"  )  l;
    | Pexp_letmodule (s, me, e) ->
        pp f "@[<hov2>let@ module@ %s@ =@ %a@ in@ %a@]" s.txt
          self#reset#module_expr me  self#expression e
    | Pexp_assert e ->
        pp f "@[<hov2>assert@ %a@]" self#simple_expr e
    | Pexp_lazy (e) ->
        pp f "@[<hov2>lazy@ %a@]" self#simple_expr e
    (* Pexp_poly: impossible but we should print it anyway, rather than assert false *)
    | Pexp_poly (e, None) ->
        pp f "@[<hov2>!poly!@ %a@]" self#simple_expr e
    | Pexp_poly (e, Some ct) ->
        pp f "@[<hov2>(!poly!@ %a@ : %a)@]" self#simple_expr e self#core_type ct
    | Pexp_open (ovf, lid, e) ->
        pp f "@[<2>let open%s %a in@;%a@]" (override ovf) self#longident_loc lid
          self#expression  e
    | Pexp_variant (l,Some eo) ->
        pp f "@[<2>`%s@;%a@]" l  self#simple_expr eo
    | Pexp_extension e -> self#extension f e
    | _ -> self#expression1 f x
  method expression1 f x =
    if x.pexp_attributes <> [] then self#expression f x
    else match x.pexp_desc with
    | Pexp_object cs -> pp f "%a" self#class_structure cs
    | _ -> self#expression2 f x
  (* used in [Pexp_apply] *)
  method expression2 f x =
    if x.pexp_attributes <> [] then self#expression f x
    else match x.pexp_desc with
    | Pexp_field (e, li) -> pp f "@[<hov2>%a.%a@]" self#simple_expr e self#longident_loc li
    | Pexp_send (e, s) ->  pp f "@[<hov2>%a#%s@]" self#simple_expr e  s

    | _ -> self#simple_expr f x
  method simple_expr f x =
    if x.pexp_attributes <> [] then self#expression f x
    else match x.pexp_desc with
    | Pexp_construct _  when is_simple_construct (view_expr x) ->
        (match view_expr x with
        | `nil -> pp f "[]"
        | `tuple -> pp f "()"
        | `list xs -> pp f "@[<hv0>[%a]@]"  (self#list self#under_semi#expression ~sep:";@;") xs
        | `simple x -> self#longident f x
        | _ -> assert false)
    | Pexp_ident li ->
        self#longident_loc f li
        (* (match view_fixity_of_exp x with *)
        (* |`Normal -> self#longident_loc f li *)
        (* | `Prefix _ | `Infix _ -> pp f "( %a )" self#longident_loc li) *)
    | Pexp_constant c -> self#constant f c;
    | Pexp_pack me ->
        pp f "(module@;%a)"  self#module_expr me
    | Pexp_newtype (lid, e) ->
        pp f "fun@;(type@;%s)@;->@;%a"  lid  self#expression  e
    | Pexp_tuple l ->
        pp f "@[<hov2>(%a)@]"  (self#list self#simple_expr  ~sep:",@;")  l
    | Pexp_constraint (e, ct) ->
        pp f "(%a : %a)" self#expression e self#core_type ct
    | Pexp_coerce (e, cto1, ct) ->
        pp f "(%a%a :> %a)" self#expression e
          (self#option self#core_type ~first:" : " ~last:" ") cto1 (* no sep hint*)
          self#core_type ct
    | Pexp_variant (l, None) -> pp f "`%s" l
    | Pexp_record (l, eo) ->
        let longident_x_expression f ( li, e) =
          match e.pexp_desc with
          |  Pexp_ident {txt;_} when li.txt = txt ->
              pp f "@[<hov2>%a@]" self#longident_loc li
          | _ ->
              pp f "@[<hov2>%a@;=@;%a@]" self#longident_loc li self#simple_expr e in
        pp f "@[<hv0>@[<hv2>{@;%a%a@]@;}@]"(* "@[<hov2>{%a%a}@]" *)
          (self#option ~last:" with@;" self#simple_expr) eo
          (self#list longident_x_expression ~sep:";@;")  l
    | Pexp_array (l) ->
        pp f "@[<0>@[<2>[|%a|]@]@]"
          (self#list self#under_semi#simple_expr ~sep:";") l
    | Pexp_while (e1, e2) ->
        let fmt:(_,_,_)format = "@[<2>while@;%a@;do@;%a@;done@]" in
        pp f fmt self#expression e1 self#expression e2
    | Pexp_for (s, e1, e2, df, e3) ->
        let fmt:(_,_,_)format =
          "@[<hv0>@[<hv2>@[<2>for %a =@;%a@;%a%a@;do@]@;%a@]@;done@]" in
        pp f fmt self#pattern s self#expression e1 self#direction_flag df self#expression e2  self#expression e3
    | _ ->  self#paren true self#expression f x

  method attributes f l =
    List.iter (self # attribute f) l

  method item_attributes f l =
    List.iter (self # item_attribute f) l

  method attribute f (s, e) =
    pp f "@[<2>[@@%s@ %a]@]" s.txt self#payload e

  method item_attribute f (s, e) =
    pp f "@[<2>[@@@@%s@ %a]@]" s.txt self#payload e

  method floating_attribute f (s, e) =
    pp f "@[<2>[@@@@@@%s@ %a]@]" s.txt self#payload e

  method value_description f x =
    pp f "@[<hov2>%a%a@]" self#core_type x.pval_type
      (fun f x ->
        if x.pval_prim<>[] then begin
          pp f "@ =@ %a"
            (self#list self#constant_string)
            x.pval_prim ;
        end) x

  method extension f (s, e) =
    pp f "@[<2>[%%%s@ %a]@]" s.txt self#payload e

  method item_extension f (s, e) =
    pp f "@[<2>[%%%%%s@ %a]@]" s.txt self#payload e

  method exception_declaration f ext =
    pp f "@[<hov2>exception@ %a@]" self#extension_constructor ext

  method class_signature f { pcsig_self = ct; pcsig_fields = l ;_} =
    let class_type_field f x =
      match x.pctf_desc with
      | Pctf_inherit (ct) ->
          pp f "@[<2>inherit@ %a@]%a" self#class_type ct
            self#item_attributes x.pctf_attributes
      | Pctf_val (s, mf, vf, ct) ->
          pp f "@[<2>val @ %a%a%s@ :@ %a@]%a"
            self#mutable_flag mf self#virtual_flag vf s  self#core_type  ct
            self#item_attributes x.pctf_attributes
      | Pctf_method (s, pf, vf, ct) ->
          pp f "@[<2>method %a %a%s :@;%a@]%a"
            self#private_flag pf self#virtual_flag vf s self#core_type ct
            self#item_attributes x.pctf_attributes
      | Pctf_constraint (ct1, ct2) ->
          pp f "@[<2>constraint@ %a@ =@ %a@]%a"
            self#core_type ct1 self#core_type ct2
            self#item_attributes x.pctf_attributes
      | Pctf_attribute a -> self#floating_attribute f a
      | Pctf_extension e ->
          self#item_extension f e;
          self#item_attributes f x.pctf_attributes
    in
    pp f "@[<hv0>@[<hv2>object@[<1>%a@]@ %a@]@ end@]"
      (fun f ct -> match ct.ptyp_desc with
      | Ptyp_any -> ()
      | _ -> pp f " (%a)" self#core_type ct) ct
      (self#list   class_type_field ~sep:"@;") l  ;

  (* call [class_signature] called by [class_signature] *)
  method class_type f x =
    match x.pcty_desc with
    | Pcty_signature cs ->
        self#class_signature f cs;
        self#attributes f x.pcty_attributes
    | Pcty_constr (li, l) ->
        pp f "%a%a%a"
          (fun f l -> match l with
          | [] -> ()
          | _  -> pp f "[%a]@ " (self#list self#core_type ~sep:"," ) l) l
          self#longident_loc li
          self#attributes x.pcty_attributes
    | Pcty_arrow (l, co, cl) ->
        pp f "@[<2>%a@;->@;%a@]" (* FIXME remove parens later *)
          self#type_with_label (l,co)
          self#class_type cl
    | Pcty_extension e ->
        self#extension f e;
        self#attributes f x.pcty_attributes

  (* [class type a = object end] *)
  method class_type_declaration_list f  l =
    let class_type_declaration kwd f ({pci_params=ls;pci_name={txt;_};_} as x) =
      pp f "@[<2>%s %a%a%s@ =@ %a@]%a" kwd
        self#virtual_flag x.pci_virt
        self#class_params_def ls txt
        self#class_type x.pci_expr
        self#item_attributes x.pci_attributes
    in
    match l with
    | [] -> ()
    | [x] -> class_type_declaration "class type" f x
    | x :: xs ->
        pp f "@[<v>%a@,%a@]"
          (class_type_declaration "class type") x
          (self#list ~sep:"@," (class_type_declaration "and")) xs

  method class_field f x =
    match x.pcf_desc with
    | Pcf_inherit (ovf, ce, so) ->
        pp f "@[<2>inherit@ %s@ %a%a@]%a" (override ovf)
          self#class_expr ce
          (fun f so -> match so with
          | None -> ();
          | Some (s) -> pp f "@ as %s" s ) so
          self#item_attributes x.pcf_attributes
    | Pcf_val (s, mf, Cfk_concrete (ovf, e)) ->
        pp f "@[<2>val%s %a%s =@;%a@]%a" (override ovf)
          self#mutable_flag mf s.txt
          self#expression  e
          self#item_attributes x.pcf_attributes
    | Pcf_method (s, pf, Cfk_virtual ct) ->
        pp f "@[<2>method virtual %a %s :@;%a@]%a"
          self#private_flag pf s.txt
          self#core_type  ct
          self#item_attributes x.pcf_attributes
    | Pcf_val (s, mf, Cfk_virtual ct) ->
        pp f "@[<2>val virtual %a%s :@ %a@]%a"
          self#mutable_flag mf s.txt
          self#core_type  ct
          self#item_attributes x.pcf_attributes
    | Pcf_method (s, pf, Cfk_concrete (ovf, e)) ->
        let bind e =
          self#binding f
            {pvb_pat=
               {ppat_desc=Ppat_var s;ppat_loc=Location.none;ppat_attributes=[]};
             pvb_expr=e;
             pvb_attributes=[];
             pvb_loc=Location.none;
            }
        in
        pp f "@[<2>method%s %a%a@]%a"
          (override ovf)
          self#private_flag pf
          (fun f e -> match e.pexp_desc with
          | Pexp_poly (e, Some ct) ->
              pp f "%s :@;%a=@;%a"
                s.txt (self#core_type) ct self#expression e
          | Pexp_poly (e,None) -> bind e
          | _ -> bind e) e
          self#item_attributes x.pcf_attributes
    | Pcf_constraint (ct1, ct2) ->
        pp f "@[<2>constraint %a =@;%a@]%a"
          self#core_type ct1
          self#core_type ct2
          self#item_attributes x.pcf_attributes
    | Pcf_initializer (e) ->
        pp f "@[<2>initializer@ %a@]%a"
          self#expression e
          self#item_attributes x.pcf_attributes
    | Pcf_attribute a -> self#floating_attribute f a
    | Pcf_extension e ->
        self#item_extension f e;
        self#item_attributes f x.pcf_attributes

  method class_structure f { pcstr_self = p; pcstr_fields =  l } =
    pp f "@[<hv0>@[<hv2>object%a@;%a@]@;end@]"
      (fun f p -> match p.ppat_desc with
      | Ppat_any -> ()
      | Ppat_constraint _ -> pp f " %a"  self#pattern  p
      | _ -> pp f " (%a)" self#pattern p) p
      (self#list self#class_field ) l

  method class_expr f x =
    if x.pcl_attributes <> [] then begin
      pp f "((%a)%a)" self#class_expr {x with pcl_attributes=[]}
        self#attributes x.pcl_attributes
    end else
    match x.pcl_desc with
    | Pcl_structure (cs) -> self#class_structure f cs
    | Pcl_fun (l, eo, p, e) ->
        pp f "fun@ %a@ ->@ %a"
          self#label_exp (l,eo,p)
          self#class_expr e
    | Pcl_let (rf, l, ce) ->
        pp f "%a@ in@ %a"
          self#bindings  (rf,l)
          self#class_expr ce
    | Pcl_apply (ce, l) ->
        pp f "(%a@ %a)"
          self#class_expr ce
          (self#list self#label_x_expression_param) l
    | Pcl_constr (li, l) ->
        pp f "%a%a"
          (fun f l-> if l <>[] then
            pp f "[%a]@ "
              (self#list self#core_type  ~sep:"," ) l ) l
          self#longident_loc li
    | Pcl_constraint (ce, ct) ->
        pp f "(%a@ :@ %a)"
          self#class_expr ce
          self#class_type ct
    | Pcl_extension e -> self#extension f e

  method module_type f x =
    if x.pmty_attributes <> [] then begin
      pp f "((%a)%a)" self#module_type {x with pmty_attributes=[]}
        self#attributes x.pmty_attributes
    end else
    match x.pmty_desc with
    | Pmty_ident li ->
        pp f "%a" self#longident_loc li;
    | Pmty_alias li ->
        pp f "(module %a)" self#longident_loc li;
    | Pmty_signature (s) ->
        pp f "@[<hv0>@[<hv2>sig@ %a@]@ end@]" (* "@[<hov>sig@ %a@ end@]" *)
          (self#list self#signature_item  ) s (* FIXME wrong indentation*)
    | Pmty_functor (_, None, mt2) ->
        pp f "@[<hov2>functor () ->@ %a@]" self#module_type mt2
    | Pmty_functor (s, Some mt1, mt2) ->
        pp f "@[<hov2>functor@ (%s@ :@ %a)@ ->@ %a@]" s.txt
          self#module_type mt1  self#module_type mt2
    | Pmty_with (mt, l) ->
        let with_constraint f = function
          | Pwith_type (li, ({ptype_params= ls ;_} as td)) ->
              let ls = List.map fst ls in
              pp f "type@ %a %a =@ %a"
                (self#list self#core_type ~sep:"," ~first:"(" ~last:")")
                ls self#longident_loc li  self#type_declaration td
          | Pwith_module (li, li2) ->
              pp f "module %a =@ %a" self#longident_loc li self#longident_loc li2;
          | Pwith_typesubst ({ptype_params=ls;_} as td) ->
              let ls = List.map fst ls in
              pp f "type@ %a %s :=@ %a"
                (self#list self#core_type ~sep:"," ~first:"(" ~last:")")
                ls td.ptype_name.txt
                self#type_declaration  td
          | Pwith_modsubst (s, li2) ->
              pp f "module %s :=@ %a" s.txt self#longident_loc li2 in
        (match l with
        | [] -> pp f "@[<hov2>%a@]" self#module_type mt
        | _ -> pp f "@[<hov2>(%a@ with@ %a)@]"
              self#module_type mt (self#list with_constraint ~sep:"@ and@ ") l )
    | Pmty_typeof me ->
        pp f "@[<hov2>module@ type@ of@ %a@]"
          self#module_expr me
    | Pmty_extension e -> self#extension f e

  method signature f x =  self#list ~sep:"@\n" self#signature_item f x

  method signature_item f x :unit= begin
    match x.psig_desc with
    | Psig_type l ->
        self#type_def_list f l
    | Psig_value vd ->
        let intro = if vd.pval_prim = [] then "val" else "external" in
          pp f "@[<2>%s@ %a@ :@ %a@]%a" intro
             protect_ident vd.pval_name.txt
             self#value_description vd
             self#item_attributes vd.pval_attributes
    | Psig_typext te ->
        self#type_extension f te
    | Psig_exception ed ->
        self#exception_declaration f ed
    | Psig_class l ->
        let class_description kwd f ({pci_params=ls;pci_name={txt;_};_} as x) =
          pp f "@[<2>%s %a%a%s@;:@;%a@]%a" kwd
            self#virtual_flag x.pci_virt
            self#class_params_def ls txt
            self#class_type x.pci_expr
            self#item_attributes x.pci_attributes
        in begin
          match l with
          | [] -> ()
          | [x] -> class_description "class" f x
          | x :: xs ->
              pp f "@[<v>%a@,%a@]"
                 (class_description "class") x
                 (self#list ~sep:"@," (class_description "and")) xs
        end
    | Psig_module ({pmd_type={pmty_desc=Pmty_alias alias};_} as pmd) ->
        pp f "@[<hov>module@ %s@ =@ %a@]%a" pmd.pmd_name.txt
          self#longident_loc alias
          self#item_attributes pmd.pmd_attributes
    | Psig_module pmd ->
        pp f "@[<hov>module@ %s@ :@ %a@]%a"
          pmd.pmd_name.txt
          self#module_type pmd.pmd_type
          self#item_attributes pmd.pmd_attributes
    | Psig_open od ->
        pp f "@[<hov2>open%s@ %a@]%a"
           (override od.popen_override)
           self#longident_loc od.popen_lid
           self#item_attributes od.popen_attributes
    | Psig_include incl ->
        pp f "@[<hov2>include@ %a@]%a"
          self#module_type incl.pincl_mod
          self#item_attributes incl.pincl_attributes
    | Psig_modtype {pmtd_name=s; pmtd_type=md; pmtd_attributes=attrs} ->
        pp f "@[<hov2>module@ type@ %s%a@]%a"
          s.txt
          (fun f md -> match md with
          | None -> ()
          | Some mt ->
              pp_print_space f () ;
              pp f "@ =@ %a"  self#module_type mt
          ) md
          self#item_attributes attrs
    | Psig_class_type (l) ->
        self#class_type_declaration_list f l ;
    | Psig_recmodule decls ->
        let rec  string_x_module_type_list f ?(first=true) l =
          match l with
          | [] -> () ;
          | pmd :: tl ->
              if not first then
                pp f "@ @[<hov2>and@ %s:@ %a@]%a" pmd.pmd_name.txt
                  self#module_type pmd.pmd_type
                  self#item_attributes pmd.pmd_attributes
              else
                pp f "@[<hov2>module@ rec@ %s:@ %a@]%a" pmd.pmd_name.txt
                  self#module_type pmd.pmd_type
                  self#item_attributes pmd.pmd_attributes;
              string_x_module_type_list f ~first:false tl
        in
          string_x_module_type_list f decls
    | Psig_attribute a -> self#floating_attribute f a
    | Psig_extension(e, a) ->
        self#item_extension f e;
        self#item_attributes f a
  end
  method module_expr f x =
    if x.pmod_attributes <> [] then begin
      pp f "((%a)%a)" self#module_expr {x with pmod_attributes=[]}
        self#attributes x.pmod_attributes
    end else
    match x.pmod_desc with
    | Pmod_structure (s) ->
        pp f "@[<hv2>struct@;@[<0>%a@]@;<1 -2>end@]"
          (self#list self#structure_item  ~sep:"@\n") s;
    | Pmod_constraint (me, mt) ->
        pp f "@[<hov2>(%a@ :@ %a)@]"
          self#module_expr  me
          self#module_type mt
    | Pmod_ident (li) ->
        pp f "%a" self#longident_loc li;
    | Pmod_functor (_, None, me) ->
        pp f "functor ()@;->@;%a" self#module_expr me
    | Pmod_functor (s, Some mt, me) ->
        pp f "functor@ (%s@ :@ %a)@;->@;%a"
          s.txt  self#module_type mt  self#module_expr me
    | Pmod_apply (me1, me2) ->
        pp f "%a(%a)" self#module_expr me1  self#module_expr  me2
    | Pmod_unpack e ->
        pp f "(val@ %a)"  self#expression  e
    | Pmod_extension e -> self#extension f e

  method structure f x = self#list ~sep:"@\n" self#structure_item f x

  method payload f = function
    | PStr [{pstr_desc = Pstr_eval (e, attrs)}] ->
        pp f "@[<2>%a@]%a"
          self#expression e
          self#item_attributes attrs
    | PStr x -> self#structure f x
    | PTyp x -> pp f ":"; self#core_type f x
    | PPat (x, None) -> pp f "?"; self#pattern f x
    | PPat (x, Some e) ->
      pp f "?"; self#pattern f x;
      pp f " when "; self#expression f e

  (* transform [f = fun g h -> ..] to [f g h = ... ] could be improved *)
  method binding f {pvb_pat=p; pvb_expr=x; _} =
    let rec pp_print_pexp_function f x =
      if x.pexp_attributes <> [] then pp f "=@;%a" self#expression x
      else match x.pexp_desc with
      | Pexp_fun (label, eo, p, e) ->
          if label="" then
            pp f "%a@ %a" self#simple_pattern p pp_print_pexp_function e
          else
            pp f "%a@ %a" self#label_exp (label,eo,p) pp_print_pexp_function e
      | Pexp_newtype (str,e) ->
          pp f "(type@ %s)@ %a" str pp_print_pexp_function e
      | _ -> pp f "=@;%a" self#expression x in
    if x.pexp_attributes <> [] then
      pp f "%a@;=@;%a" self#pattern p self#expression x
    else match (x.pexp_desc,p.ppat_desc) with
    | ( _ , Ppat_constraint( p ,ty)) -> (* special case for the first*)
        (match ty.ptyp_desc with
        | Ptyp_poly _ ->
            pp f "%a@;:@;%a=@;%a" self#simple_pattern p
              self#core_type ty self#expression x
        | _ ->
            pp f "(%a@;:%a)=@;%a" self#simple_pattern p
              self#core_type ty self#expression x)
    | Pexp_constraint (e,t1),Ppat_var {txt;_} ->
        pp f "%s:@ %a@;=@;%a" txt self#core_type t1 self#expression e
    | (_, Ppat_var _) ->
        pp f "%a@ %a" self#simple_pattern p pp_print_pexp_function x
    | _ ->
        pp f "%a@;=@;%a" self#pattern p self#expression x
  (* [in] is not printed *)
  method bindings f (rf,l) =
    let binding kwd rf f x =
      pp f "@[<2>%s %a%a@]%a" kwd self#rec_flag rf
         self#binding x self#item_attributes x.pvb_attributes
    in
    begin match l with
    | [] -> ()
    | [x] -> binding "let" rf f x
    | x::xs ->
        pp f "@[<v>%a@,%a@]"
          (binding "let" rf) x
          (self#list ~sep:"@," (binding "and" Nonrecursive)) xs
    end

  method structure_item f x = begin
    match x.pstr_desc with
    | Pstr_eval (e, attrs) ->
        pp f "@[<hov2>let@ _ =@ %a@]%a"
          self#expression e
          self#item_attributes attrs
    | Pstr_type [] -> assert false
    | Pstr_type l  -> self#type_def_list f l
    | Pstr_value (rf, l) -> (* pp f "@[<hov2>let %a%a@]"  self#rec_flag rf self#bindings l *)
        pp f "@[<2>%a@]" self#bindings (rf,l)
    | Pstr_typext te -> self#type_extension f te
    | Pstr_exception ed -> self#exception_declaration f ed
    | Pstr_module x ->
        let rec module_helper me =
          match me.pmod_desc with
          | Pmod_functor(s,mt,me') when me.pmod_attributes = [] ->
              if mt = None then pp f "()"
              else Misc.may (pp f "(%s:%a)" s.txt self#module_type) mt;
              module_helper me'
          | _ -> me
        in
        pp f "@[<hov2>module %s%a@]%a"
          x.pmb_name.txt
          (fun f me ->
            let me = module_helper me in
            (match me.pmod_desc with
            | Pmod_constraint
                (me',
                 ({pmty_desc=(Pmty_ident (_)
                             | Pmty_signature (_));_} as mt))
              when me.pmod_attributes = [] ->
                pp f " :@;%a@;=@;%a@;"  self#module_type mt self#module_expr  me'
            | _ ->
                pp f " =@ %a"  self#module_expr  me
            )) x.pmb_expr
          self#item_attributes x.pmb_attributes
    | Pstr_open od ->
        pp f "@[<2>open%s@;%a@]%a"
           (override od.popen_override)
           self#longident_loc od.popen_lid
           self#item_attributes od.popen_attributes
    | Pstr_modtype {pmtd_name=s; pmtd_type=md; pmtd_attributes=attrs} ->
        pp f "@[<hov2>module@ type@ %s%a@]%a"
          s.txt
          (fun f md -> match md with
          | None -> ()
          | Some mt ->
              pp_print_space f () ;
              pp f "@ =@ %a"  self#module_type mt
          ) md
          self#item_attributes attrs
    | Pstr_class l ->
        let extract_class_args cl =
          let rec loop acc cl =
            match cl.pcl_desc with
            | Pcl_fun (l, eo, p, cl') when cl.pcl_attributes = [] ->
                loop ((l,eo,p) :: acc) cl'
            | _ -> List.rev acc, cl
          in
          let args, cl = loop [] cl in
          let constr, cl =
            match cl.pcl_desc with
            | Pcl_constraint (cl', ct) when cl.pcl_attributes = [] ->
                Some ct, cl'
            | _ -> None, cl
          in
            args, constr, cl
        in
        let class_constraint f ct = pp f ": @[%a@] " self#class_type ct in
        let class_declaration kwd f
            ({pci_params=ls; pci_name={txt;_}; _} as x) =
          let args, constr, cl = extract_class_args x.pci_expr in
          pp f "@[<2>%s %a%a%s %a%a=@;%a@]%a" kwd
             self#virtual_flag x.pci_virt
             self#class_params_def ls txt
             (self#list self#label_exp) args
             (self#option class_constraint) constr
             self#class_expr cl
             self#item_attributes x.pci_attributes
        in begin
          match l with
          | [] -> ()
          | [x] -> class_declaration "class" f x
          | x :: xs ->
              pp f "@[<v>%a@,%a@]"
                 (class_declaration "class") x
                 (self#list ~sep:"@," (class_declaration "and")) xs
        end
    | Pstr_class_type (l) ->
        self#class_type_declaration_list f l ;
    | Pstr_primitive vd ->
        pp f "@[<hov2>external@ %a@ :@ %a@]%a"
          protect_ident vd.pval_name.txt
          self#value_description vd
          self#item_attributes vd.pval_attributes
    | Pstr_include incl ->
        pp f "@[<hov2>include@ %a@]%a"
          self#module_expr incl.pincl_mod
          self#item_attributes incl.pincl_attributes
    | Pstr_recmodule decls -> (* 3.07 *)
        let aux f = function
          | ({pmb_expr={pmod_desc=Pmod_constraint (expr, typ)}} as pmb) ->
              pp f "@[<hov2>@ and@ %s:%a@ =@ %a@]%a" pmb.pmb_name.txt
              self#module_type typ
              self#module_expr expr
              self#item_attributes pmb.pmb_attributes
          | _ -> assert false
        in
        begin match decls with
        | ({pmb_expr={pmod_desc=Pmod_constraint (expr, typ)}} as pmb) :: l2 ->
            pp f "@[<hv>@[<hov2>module@ rec@ %s:%a@ =@ %a@]%a@ %a@]"
              pmb.pmb_name.txt
              self#module_type typ
              self#module_expr expr
              self#item_attributes pmb.pmb_attributes
              (fun f l2 -> List.iter (aux f) l2) l2
        | _ -> assert false
        end
    | Pstr_attribute a -> self#floating_attribute f a
    | Pstr_extension(e, a) ->
        self#item_extension f e;
        self#item_attributes f a
  end
  method type_param f (ct, a) =
    pp f "%s%a" (type_variance a) self#core_type ct
  method type_params f = function
    [] -> ()
  | l -> pp f "%a " (self#list self#type_param ~first:"(" ~last:")" ~sep:",") l
  method  type_def_list f l =
    let rf =
      let is_nonrec =
        List.exists
          (fun td ->
             List.exists (fun (n, _) -> n.txt = "nonrec")
               td.ptype_attributes)
          l
      in
      if is_nonrec then Nonrecursive else Recursive
    in
    let type_decl kwd rf f x =
      let eq =
        if (x.ptype_kind = Ptype_abstract)
           && (x.ptype_manifest = None) then ""
        else " ="
      in
      pp f "@[<2>%s %a%a%s%s%a@]%a" kwd
        self#nonrec_flag rf
        self#type_params x.ptype_params
        x.ptype_name.txt eq
        self#type_declaration x
        self#item_attributes x.ptype_attributes
    in
    match l with
    | [] -> assert false
    | [x] -> type_decl "type" rf f x
    | x :: xs -> pp f "@[<v>%a@,%a@]"
          (type_decl "type" rf) x
          (self#list ~sep:"@," (type_decl "and" Recursive)) xs
  method type_declaration f x =
    let priv f =
      match x.ptype_private with
        Public -> ()
      | Private -> pp f "@;private"
    in
    let manifest f =
      match x.ptype_manifest with
      | None -> ()
      | Some y -> pp f "@;%a" self#core_type y
    in
    let constructor_declaration f pcd =
      match pcd.pcd_args, pcd.pcd_res with
      | _, None ->
          pp f "|@;%s%a%a" pcd.pcd_name.txt
             (fun f -> function
              | [] -> ()
              | l -> pp f "@;of@;%a" (self#list self#core_type1 ~sep:"*@;") l)
             pcd.pcd_args
             self#attributes pcd.pcd_attributes
      | [], Some x ->
          pp f "|@;%s:@;%a%a" pcd.pcd_name.txt
             self#core_type1 x
             self#attributes pcd.pcd_attributes
      | args, Some x ->
          pp f "|@;%s:@;%a@;->@;%a%a" pcd.pcd_name.txt
            (self#list self#core_type1 ~sep:"*@;") args
            self#core_type1 x
            self#attributes pcd.pcd_attributes
    in
    let label_declaration f pld =
      pp f "@[<2>%a%s:@;%a%a;@]"
         self#mutable_flag pld.pld_mutable
         pld.pld_name.txt
         self#core_type pld.pld_type
         self#attributes pld.pld_attributes
    in
    let repr f =
      let intro f =
        if x.ptype_manifest = None then ()
        else pp f "@;="
      in
      match x.ptype_kind with
      | Ptype_variant xs ->
          pp f "%t@\n%a" intro
             (self#list ~sep:"@\n" constructor_declaration) xs
      | Ptype_abstract -> ()
      | Ptype_record l ->
          pp f "%t@;{@\n%a}" intro
             (self#list ~sep:"@\n" label_declaration)  l ;
      | Ptype_open -> pp f "%t@;.." intro
    in
    let constraints f =
      self#list ~first:"@ "
        (fun f (ct1,ct2,_) ->
           pp f "@[<hov2> constraint@ %a@ =@ %a@]"
              self#core_type ct1 self#core_type ct2)
        f x.ptype_cstrs
    in
      pp f "%t%t%t%t" priv manifest repr constraints

  method type_extension f x =
    let extension_constructor f x =
      pp f "@\n|@;%a" self#extension_constructor x
    in
      pp f "@[<2>type %a%a +=%a@]%a"
         (fun f -> function
                | [] -> ()
                | l ->  pp f "%a@;" (self#list self#type_param ~first:"(" ~last:")" ~sep:",") l)
         x.ptyext_params
         self#longident_loc x.ptyext_path
         (self#list ~sep:"" extension_constructor)
         x.ptyext_constructors
         self#item_attributes x.ptyext_attributes

  method extension_constructor f x =
    match x.pext_kind with
    | Pext_decl(l, None) ->
        pp f "%s%a%a" x.pext_name.txt
          (fun f -> function
                 | [] -> ()
                 | l -> pp f "@;of@;%a" (self#list self#core_type1 ~sep:"*@;") l) l
          self#attributes x.pext_attributes
    | Pext_decl(l, Some r) ->
        pp f "%s%a:@;%a" x.pext_name.txt
          self#attributes x.pext_attributes
          (fun f -> function
                 | [] -> self#core_type1 f r
                 | l -> pp f "%a@;->@;%a"
                           (self#list self#core_type1 ~sep:"*@;") l
                           self#core_type1 r)
          l
    | Pext_rebind li ->
        pp f "%s%a@;=@;%a" x.pext_name.txt
          self#attributes x.pext_attributes
          self#longident_loc li

  method case_list f l : unit =
    let aux f {pc_lhs; pc_guard; pc_rhs} =
      pp f "@;| @[<2>%a%a@;->@;%a@]"
        self#pattern pc_lhs (self#option self#expression ~first:"@;when@;") pc_guard self#under_pipe#expression pc_rhs in
    self#list aux f l ~sep:""
  method label_x_expression_param f (l,e) =
    match l with
    | ""  -> self#expression2 f e ; (* level 2*)
    | lbl ->
        let simple_name = match e.pexp_desc with
        | Pexp_ident {txt=Lident l;_} -> Some l
        | _ -> None in
        if  lbl.[0] = '?' then
          let str = String.sub lbl 1 (String.length lbl-1) in
          if Some str = simple_name then
            pp f "%s" lbl
          else
            pp f "%s:%a" lbl self#simple_expr e
        else
          if Some lbl = simple_name then
            pp f "~%s" lbl
          else
            pp f "~%s:%a" lbl self#simple_expr e

  method directive_argument f x =
    (match x with
    | Pdir_none -> ()
    | Pdir_string (s) -> pp f "@ %S" s
    | Pdir_int (i) -> pp f "@ %d" i
    | Pdir_ident (li) -> pp f "@ %a" self#longident li
    | Pdir_bool (b) -> pp f "@ %s" (string_of_bool b))

  method toplevel_phrase f x =
    match x with
    | Ptop_def (s) ->
        pp_open_hvbox f 0;
        self#list self#structure_item f s ;
        pp_close_box f ();
    | Ptop_dir (s, da) ->
        pp f "@[<hov2>#%s@ %a@]" s self#directive_argument da
end;;


let default = new printer ()


let toplevel_phrase f x =
  match x with
  | Ptop_def (s) ->pp f "@[<hov0>%a@]"  (default#list default#structure_item) s
   (* pp_open_hvbox f 0; *)
   (* pp_print_list structure_item f s ; *)
   (* pp_close_box f (); *)
  | Ptop_dir (s, da) ->
   pp f "@[<hov2>#%s@ %a@]" s default#directive_argument da
   (* pp f "@[<hov2>#%s@ %a@]" s directive_argument da *)

let expression f x =
  pp f "@[%a@]" default#expression x


let string_of_expression x =
  ignore (flush_str_formatter ()) ;
  let f = str_formatter in
  default#expression f x ;
  flush_str_formatter () ;;
let string_of_structure x =
  ignore (flush_str_formatter ());
  let f = str_formatter in
  default#structure f x;
  flush_str_formatter ();;

let top_phrase f x =
  pp_print_newline f () ;
  toplevel_phrase f x;
  pp f ";;" ;
  pp_print_newline f ();;

let core_type=default#core_type
let pattern=default#pattern
let signature=default#signature
let structure=default#structure

end
module Printast : sig 
#1 "printast.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*             Damien Doligez, projet Para, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1999 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Parsetree;;
open Format;;

val interface : formatter -> signature_item list -> unit;;
val implementation : formatter -> structure_item list -> unit;;
val top_phrase : formatter -> toplevel_phrase -> unit;;

val expression: int -> formatter -> expression -> unit
val structure: int -> formatter -> structure -> unit
val payload: int -> formatter -> payload -> unit

end = struct
#1 "printast.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*             Damien Doligez, projet Para, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1999 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Asttypes;;
open Format;;
open Lexing;;
open Location;;
open Parsetree;;

let fmt_position with_name f l =
  let fname = if with_name then l.pos_fname else "" in
  if l.pos_lnum = -1
  then fprintf f "%s[%d]" fname l.pos_cnum
  else fprintf f "%s[%d,%d+%d]" fname l.pos_lnum l.pos_bol
               (l.pos_cnum - l.pos_bol)
;;

let fmt_location f loc =
  let p_2nd_name = loc.loc_start.pos_fname <> loc.loc_end.pos_fname in
  fprintf f "(%a..%a)" (fmt_position true) loc.loc_start
                       (fmt_position p_2nd_name) loc.loc_end;
  if loc.loc_ghost then fprintf f " ghost";
;;

let rec fmt_longident_aux f x =
  match x with
  | Longident.Lident (s) -> fprintf f "%s" s;
  | Longident.Ldot (y, s) -> fprintf f "%a.%s" fmt_longident_aux y s;
  | Longident.Lapply (y, z) ->
      fprintf f "%a(%a)" fmt_longident_aux y fmt_longident_aux z;
;;

let fmt_longident f x = fprintf f "\"%a\"" fmt_longident_aux x;;

let fmt_longident_loc f x =
  fprintf f "\"%a\" %a" fmt_longident_aux x.txt fmt_location x.loc;
;;

let fmt_string_loc f x =
  fprintf f "\"%s\" %a" x.txt fmt_location x.loc;
;;

let fmt_constant f x =
  match x with
  | Const_int (i) -> fprintf f "Const_int %d" i;
  | Const_char (c) -> fprintf f "Const_char %02x" (Char.code c);
  | Const_string (s, None) -> fprintf f "Const_string(%S,None)" s;
  | Const_string (s, Some delim) ->
      fprintf f "Const_string (%S,Some %S)" s delim;
  | Const_float (s) -> fprintf f "Const_float %s" s;
  | Const_int32 (i) -> fprintf f "Const_int32 %ld" i;
  | Const_int64 (i) -> fprintf f "Const_int64 %Ld" i;
  | Const_nativeint (i) -> fprintf f "Const_nativeint %nd" i;
;;

let fmt_mutable_flag f x =
  match x with
  | Immutable -> fprintf f "Immutable";
  | Mutable -> fprintf f "Mutable";
;;

let fmt_virtual_flag f x =
  match x with
  | Virtual -> fprintf f "Virtual";
  | Concrete -> fprintf f "Concrete";
;;

let fmt_override_flag f x =
  match x with
  | Override -> fprintf f "Override";
  | Fresh -> fprintf f "Fresh";
;;

let fmt_closed_flag f x =
  match x with
  | Closed -> fprintf f "Closed"
  | Open -> fprintf f "Open"

let fmt_rec_flag f x =
  match x with
  | Nonrecursive -> fprintf f "Nonrec";
  | Recursive -> fprintf f "Rec";
;;

let fmt_direction_flag f x =
  match x with
  | Upto -> fprintf f "Up";
  | Downto -> fprintf f "Down";
;;

let fmt_private_flag f x =
  match x with
  | Public -> fprintf f "Public";
  | Private -> fprintf f "Private";
;;

let line i f s (*...*) =
  fprintf f "%s" (String.make ((2*i) mod 72) ' ');
  fprintf f s (*...*)
;;

let list i f ppf l =
  match l with
  | [] -> line i ppf "[]\n";
  | _ :: _ ->
     line i ppf "[\n";
     List.iter (f (i+1) ppf) l;
     line i ppf "]\n";
;;

let option i f ppf x =
  match x with
  | None -> line i ppf "None\n";
  | Some x ->
      line i ppf "Some\n";
      f (i+1) ppf x;
;;

let longident_loc i ppf li = line i ppf "%a\n" fmt_longident_loc li;;
let string i ppf s = line i ppf "\"%s\"\n" s;;
let string_loc i ppf s = line i ppf "%a\n" fmt_string_loc s;;
let bool i ppf x = line i ppf "%s\n" (string_of_bool x);;
let label i ppf x = line i ppf "label=\"%s\"\n" x;;

let rec core_type i ppf x =
  line i ppf "core_type %a\n" fmt_location x.ptyp_loc;
  attributes i ppf x.ptyp_attributes;
  let i = i+1 in
  match x.ptyp_desc with
  | Ptyp_any -> line i ppf "Ptyp_any\n";
  | Ptyp_var (s) -> line i ppf "Ptyp_var %s\n" s;
  | Ptyp_arrow (l, ct1, ct2) ->
      line i ppf "Ptyp_arrow\n";
      string i ppf l;
      core_type i ppf ct1;
      core_type i ppf ct2;
  | Ptyp_tuple l ->
      line i ppf "Ptyp_tuple\n";
      list i core_type ppf l;
  | Ptyp_constr (li, l) ->
      line i ppf "Ptyp_constr %a\n" fmt_longident_loc li;
      list i core_type ppf l;
  | Ptyp_variant (l, closed, low) ->
      line i ppf "Ptyp_variant closed=%a\n" fmt_closed_flag closed;
      list i label_x_bool_x_core_type_list ppf l;
      option i (fun i -> list i string) ppf low
  | Ptyp_object (l, c) ->
      line i ppf "Ptyp_object %a\n" fmt_closed_flag c;
      let i = i + 1 in
      List.iter
        (fun (s, attrs, t) ->
          line i ppf "method %s\n" s;
          attributes i ppf attrs;
          core_type (i + 1) ppf t
        )
        l
  | Ptyp_class (li, l) ->
      line i ppf "Ptyp_class %a\n" fmt_longident_loc li;
      list i core_type ppf l
  | Ptyp_alias (ct, s) ->
      line i ppf "Ptyp_alias \"%s\"\n" s;
      core_type i ppf ct;
  | Ptyp_poly (sl, ct) ->
      line i ppf "Ptyp_poly%a\n"
        (fun ppf -> List.iter (fun x -> fprintf ppf " '%s" x)) sl;
      core_type i ppf ct;
  | Ptyp_package (s, l) ->
      line i ppf "Ptyp_package %a\n" fmt_longident_loc s;
      list i package_with ppf l;
  | Ptyp_extension (s, arg) ->
      line i ppf "Ptyp_extension \"%s\"\n" s.txt;
      payload i ppf arg

and package_with i ppf (s, t) =
  line i ppf "with type %a\n" fmt_longident_loc s;
  core_type i ppf t

and pattern i ppf x =
  line i ppf "pattern %a\n" fmt_location x.ppat_loc;
  attributes i ppf x.ppat_attributes;
  let i = i+1 in
  match x.ppat_desc with
  | Ppat_any -> line i ppf "Ppat_any\n";
  | Ppat_var (s) -> line i ppf "Ppat_var %a\n" fmt_string_loc s;
  | Ppat_alias (p, s) ->
      line i ppf "Ppat_alias %a\n" fmt_string_loc s;
      pattern i ppf p;
  | Ppat_constant (c) -> line i ppf "Ppat_constant %a\n" fmt_constant c;
  | Ppat_interval (c1, c2) ->
      line i ppf "Ppat_interval %a..%a\n" fmt_constant c1 fmt_constant c2;
  | Ppat_tuple (l) ->
      line i ppf "Ppat_tuple\n";
      list i pattern ppf l;
  | Ppat_construct (li, po) ->
      line i ppf "Ppat_construct %a\n" fmt_longident_loc li;
      option i pattern ppf po;
  | Ppat_variant (l, po) ->
      line i ppf "Ppat_variant \"%s\"\n" l;
      option i pattern ppf po;
  | Ppat_record (l, c) ->
      line i ppf "Ppat_record %a\n" fmt_closed_flag c;
      list i longident_x_pattern ppf l;
  | Ppat_array (l) ->
      line i ppf "Ppat_array\n";
      list i pattern ppf l;
  | Ppat_or (p1, p2) ->
      line i ppf "Ppat_or\n";
      pattern i ppf p1;
      pattern i ppf p2;
  | Ppat_lazy p ->
      line i ppf "Ppat_lazy\n";
      pattern i ppf p;
  | Ppat_constraint (p, ct) ->
      line i ppf "Ppat_constraint\n";
      pattern i ppf p;
      core_type i ppf ct;
  | Ppat_type (li) ->
      line i ppf "Ppat_type\n";
      longident_loc i ppf li
  | Ppat_unpack s ->
      line i ppf "Ppat_unpack %a\n" fmt_string_loc s;
  | Ppat_exception p ->
      line i ppf "Ppat_exception\n";
      pattern i ppf p
  | Ppat_extension (s, arg) ->
      line i ppf "Ppat_extension \"%s\"\n" s.txt;
      payload i ppf arg

and expression i ppf x =
  line i ppf "expression %a\n" fmt_location x.pexp_loc;
  attributes i ppf x.pexp_attributes;
  let i = i+1 in
  match x.pexp_desc with
  | Pexp_ident (li) -> line i ppf "Pexp_ident %a\n" fmt_longident_loc li;
  | Pexp_constant (c) -> line i ppf "Pexp_constant %a\n" fmt_constant c;
  | Pexp_let (rf, l, e) ->
      line i ppf "Pexp_let %a\n" fmt_rec_flag rf;
      list i value_binding ppf l;
      expression i ppf e;
  | Pexp_function l ->
      line i ppf "Pexp_function\n";
      list i case ppf l;
  | Pexp_fun (l, eo, p, e) ->
      line i ppf "Pexp_fun \"%s\"\n" l;
      option i expression ppf eo;
      pattern i ppf p;
      expression i ppf e;
  | Pexp_apply (e, l) ->
      line i ppf "Pexp_apply\n";
      expression i ppf e;
      list i label_x_expression ppf l;
  | Pexp_match (e, l) ->
      line i ppf "Pexp_match\n";
      expression i ppf e;
      list i case ppf l;
  | Pexp_try (e, l) ->
      line i ppf "Pexp_try\n";
      expression i ppf e;
      list i case ppf l;
  | Pexp_tuple (l) ->
      line i ppf "Pexp_tuple\n";
      list i expression ppf l;
  | Pexp_construct (li, eo) ->
      line i ppf "Pexp_construct %a\n" fmt_longident_loc li;
      option i expression ppf eo;
  | Pexp_variant (l, eo) ->
      line i ppf "Pexp_variant \"%s\"\n" l;
      option i expression ppf eo;
  | Pexp_record (l, eo) ->
      line i ppf "Pexp_record\n";
      list i longident_x_expression ppf l;
      option i expression ppf eo;
  | Pexp_field (e, li) ->
      line i ppf "Pexp_field\n";
      expression i ppf e;
      longident_loc i ppf li;
  | Pexp_setfield (e1, li, e2) ->
      line i ppf "Pexp_setfield\n";
      expression i ppf e1;
      longident_loc i ppf li;
      expression i ppf e2;
  | Pexp_array (l) ->
      line i ppf "Pexp_array\n";
      list i expression ppf l;
  | Pexp_ifthenelse (e1, e2, eo) ->
      line i ppf "Pexp_ifthenelse\n";
      expression i ppf e1;
      expression i ppf e2;
      option i expression ppf eo;
  | Pexp_sequence (e1, e2) ->
      line i ppf "Pexp_sequence\n";
      expression i ppf e1;
      expression i ppf e2;
  | Pexp_while (e1, e2) ->
      line i ppf "Pexp_while\n";
      expression i ppf e1;
      expression i ppf e2;
  | Pexp_for (p, e1, e2, df, e3) ->
      line i ppf "Pexp_for %a\n" fmt_direction_flag df;
      pattern i ppf p;
      expression i ppf e1;
      expression i ppf e2;
      expression i ppf e3;
  | Pexp_constraint (e, ct) ->
      line i ppf "Pexp_constraint\n";
      expression i ppf e;
      core_type i ppf ct;
  | Pexp_coerce (e, cto1, cto2) ->
      line i ppf "Pexp_coerce\n";
      expression i ppf e;
      option i core_type ppf cto1;
      core_type i ppf cto2;
  | Pexp_send (e, s) ->
      line i ppf "Pexp_send \"%s\"\n" s;
      expression i ppf e;
  | Pexp_new (li) -> line i ppf "Pexp_new %a\n" fmt_longident_loc li;
  | Pexp_setinstvar (s, e) ->
      line i ppf "Pexp_setinstvar %a\n" fmt_string_loc s;
      expression i ppf e;
  | Pexp_override (l) ->
      line i ppf "Pexp_override\n";
      list i string_x_expression ppf l;
  | Pexp_letmodule (s, me, e) ->
      line i ppf "Pexp_letmodule %a\n" fmt_string_loc s;
      module_expr i ppf me;
      expression i ppf e;
  | Pexp_assert (e) ->
      line i ppf "Pexp_assert\n";
      expression i ppf e;
  | Pexp_lazy (e) ->
      line i ppf "Pexp_lazy\n";
      expression i ppf e;
  | Pexp_poly (e, cto) ->
      line i ppf "Pexp_poly\n";
      expression i ppf e;
      option i core_type ppf cto;
  | Pexp_object s ->
      line i ppf "Pexp_object\n";
      class_structure i ppf s
  | Pexp_newtype (s, e) ->
      line i ppf "Pexp_newtype \"%s\"\n" s;
      expression i ppf e
  | Pexp_pack me ->
      line i ppf "Pexp_pack\n";
      module_expr i ppf me
  | Pexp_open (ovf, m, e) ->
      line i ppf "Pexp_open %a \"%a\"\n" fmt_override_flag ovf
        fmt_longident_loc m;
      expression i ppf e
  | Pexp_extension (s, arg) ->
      line i ppf "Pexp_extension \"%s\"\n" s.txt;
      payload i ppf arg

and value_description i ppf x =
  line i ppf "value_description %a %a\n" fmt_string_loc
       x.pval_name fmt_location x.pval_loc;
  attributes i ppf x.pval_attributes;
  core_type (i+1) ppf x.pval_type;
  list (i+1) string ppf x.pval_prim

and type_parameter i ppf (x, _variance) = core_type i ppf x

and type_declaration i ppf x =
  line i ppf "type_declaration %a %a\n" fmt_string_loc x.ptype_name
       fmt_location x.ptype_loc;
  attributes i ppf x.ptype_attributes;
  let i = i+1 in
  line i ppf "ptype_params =\n";
  list (i+1) type_parameter ppf x.ptype_params;
  line i ppf "ptype_cstrs =\n";
  list (i+1) core_type_x_core_type_x_location ppf x.ptype_cstrs;
  line i ppf "ptype_kind =\n";
  type_kind (i+1) ppf x.ptype_kind;
  line i ppf "ptype_private = %a\n" fmt_private_flag x.ptype_private;
  line i ppf "ptype_manifest =\n";
  option (i+1) core_type ppf x.ptype_manifest

and attributes i ppf l =
  let i = i + 1 in
  List.iter
    (fun (s, arg) ->
      line i ppf "attribute \"%s\"\n" s.txt;
      payload (i + 1) ppf arg;
    )
    l

and payload i ppf = function
  | PStr x -> structure i ppf x
  | PTyp x -> core_type i ppf x
  | PPat (x, None) -> pattern i ppf x
  | PPat (x, Some g) ->
    pattern i ppf x;
    line i ppf "<when>\n";
    expression (i + 1) ppf g


and type_kind i ppf x =
  match x with
  | Ptype_abstract ->
      line i ppf "Ptype_abstract\n"
  | Ptype_variant l ->
      line i ppf "Ptype_variant\n";
      list (i+1) constructor_decl ppf l;
  | Ptype_record l ->
      line i ppf "Ptype_record\n";
      list (i+1) label_decl ppf l;
  | Ptype_open ->
      line i ppf "Ptype_open\n";

and type_extension i ppf x =
  line i ppf "type_extension\n";
  attributes i ppf x.ptyext_attributes;
  let i = i+1 in
  line i ppf "ptyext_path = %a\n" fmt_longident_loc x.ptyext_path;
  line i ppf "ptyext_params =\n";
  list (i+1) type_parameter ppf x.ptyext_params;
  line i ppf "ptyext_constructors =\n";
  list (i+1) extension_constructor ppf x.ptyext_constructors;
  line i ppf "ptyext_private = %a\n" fmt_private_flag x.ptyext_private;

and extension_constructor i ppf x =
  line i ppf "extension_constructor %a\n" fmt_location x.pext_loc;
  attributes i ppf x.pext_attributes;
  let i = i + 1 in
  line i ppf "pext_name = \"%s\"\n" x.pext_name.txt;
  line i ppf "pext_kind =\n";
  extension_constructor_kind (i + 1) ppf x.pext_kind;

and extension_constructor_kind i ppf x =
  match x with
      Pext_decl(a, r) ->
        line i ppf "Pext_decl\n";
        list (i+1) core_type ppf a;
        option (i+1) core_type ppf r;
    | Pext_rebind li ->
        line i ppf "Pext_rebind\n";
        line (i+1) ppf "%a\n" fmt_longident_loc li;

and class_type i ppf x =
  line i ppf "class_type %a\n" fmt_location x.pcty_loc;
  attributes i ppf x.pcty_attributes;
  let i = i+1 in
  match x.pcty_desc with
  | Pcty_constr (li, l) ->
      line i ppf "Pcty_constr %a\n" fmt_longident_loc li;
      list i core_type ppf l;
  | Pcty_signature (cs) ->
      line i ppf "Pcty_signature\n";
      class_signature i ppf cs;
  | Pcty_arrow (l, co, cl) ->
      line i ppf "Pcty_arrow \"%s\"\n" l;
      core_type i ppf co;
      class_type i ppf cl;
  | Pcty_extension (s, arg) ->
      line i ppf "Pcty_extension \"%s\"\n" s.txt;
      payload i ppf arg

and class_signature i ppf cs =
  line i ppf "class_signature\n";
  core_type (i+1) ppf cs.pcsig_self;
  list (i+1) class_type_field ppf cs.pcsig_fields;

and class_type_field i ppf x =
  line i ppf "class_type_field %a\n" fmt_location x.pctf_loc;
  let i = i+1 in
  attributes i ppf x.pctf_attributes;
  match x.pctf_desc with
  | Pctf_inherit (ct) ->
      line i ppf "Pctf_inherit\n";
      class_type i ppf ct;
  | Pctf_val (s, mf, vf, ct) ->
      line i ppf "Pctf_val \"%s\" %a %a\n" s fmt_mutable_flag mf
           fmt_virtual_flag vf;
      core_type (i+1) ppf ct;
  | Pctf_method (s, pf, vf, ct) ->
      line i ppf "Pctf_method \"%s\" %a %a\n" s fmt_private_flag pf
           fmt_virtual_flag vf;
      core_type (i+1) ppf ct;
  | Pctf_constraint (ct1, ct2) ->
      line i ppf "Pctf_constraint\n";
      core_type (i+1) ppf ct1;
      core_type (i+1) ppf ct2;
  | Pctf_attribute (s, arg) ->
      line i ppf "Pctf_attribute \"%s\"\n" s.txt;
      payload i ppf arg
  | Pctf_extension (s, arg) ->
      line i ppf "Pctf_extension \"%s\"\n" s.txt;
     payload i ppf arg

and class_description i ppf x =
  line i ppf "class_description %a\n" fmt_location x.pci_loc;
  attributes i ppf x.pci_attributes;
  let i = i+1 in
  line i ppf "pci_virt = %a\n" fmt_virtual_flag x.pci_virt;
  line i ppf "pci_params =\n";
  list (i+1) type_parameter ppf x.pci_params;
  line i ppf "pci_name = %a\n" fmt_string_loc x.pci_name;
  line i ppf "pci_expr =\n";
  class_type (i+1) ppf x.pci_expr;

and class_type_declaration i ppf x =
  line i ppf "class_type_declaration %a\n" fmt_location x.pci_loc;
  attributes i ppf x.pci_attributes;
  let i = i+1 in
  line i ppf "pci_virt = %a\n" fmt_virtual_flag x.pci_virt;
  line i ppf "pci_params =\n";
  list (i+1) type_parameter ppf x.pci_params;
  line i ppf "pci_name = %a\n" fmt_string_loc x.pci_name;
  line i ppf "pci_expr =\n";
  class_type (i+1) ppf x.pci_expr;

and class_expr i ppf x =
  line i ppf "class_expr %a\n" fmt_location x.pcl_loc;
  attributes i ppf x.pcl_attributes;
  let i = i+1 in
  match x.pcl_desc with
  | Pcl_constr (li, l) ->
      line i ppf "Pcl_constr %a\n" fmt_longident_loc li;
      list i core_type ppf l;
  | Pcl_structure (cs) ->
      line i ppf "Pcl_structure\n";
      class_structure i ppf cs;
  | Pcl_fun (l, eo, p, e) ->
      line i ppf "Pcl_fun\n";
      label i ppf l;
      option i expression ppf eo;
      pattern i ppf p;
      class_expr i ppf e;
  | Pcl_apply (ce, l) ->
      line i ppf "Pcl_apply\n";
      class_expr i ppf ce;
      list i label_x_expression ppf l;
  | Pcl_let (rf, l, ce) ->
      line i ppf "Pcl_let %a\n" fmt_rec_flag rf;
      list i value_binding ppf l;
      class_expr i ppf ce;
  | Pcl_constraint (ce, ct) ->
      line i ppf "Pcl_constraint\n";
      class_expr i ppf ce;
      class_type i ppf ct;
  | Pcl_extension (s, arg) ->
      line i ppf "Pcl_extension \"%s\"\n" s.txt;
      payload i ppf arg

and class_structure i ppf { pcstr_self = p; pcstr_fields = l } =
  line i ppf "class_structure\n";
  pattern (i+1) ppf p;
  list (i+1) class_field ppf l;

and class_field i ppf x =
  line i ppf "class_field %a\n" fmt_location x.pcf_loc;
  let i = i + 1 in
  attributes i ppf x.pcf_attributes;
  match x.pcf_desc with
  | Pcf_inherit (ovf, ce, so) ->
      line i ppf "Pcf_inherit %a\n" fmt_override_flag ovf;
      class_expr (i+1) ppf ce;
      option (i+1) string ppf so;
  | Pcf_val (s, mf, k) ->
      line i ppf "Pcf_val %a\n" fmt_mutable_flag mf;
      line (i+1) ppf "%a\n" fmt_string_loc s;
      class_field_kind (i+1) ppf k
  | Pcf_method (s, pf, k) ->
      line i ppf "Pcf_method %a\n" fmt_private_flag pf;
      line (i+1) ppf "%a\n" fmt_string_loc s;
      class_field_kind (i+1) ppf k
  | Pcf_constraint (ct1, ct2) ->
      line i ppf "Pcf_constraint\n";
      core_type (i+1) ppf ct1;
      core_type (i+1) ppf ct2;
  | Pcf_initializer (e) ->
      line i ppf "Pcf_initializer\n";
      expression (i+1) ppf e;
  | Pcf_attribute (s, arg) ->
      line i ppf "Pcf_attribute \"%s\"\n" s.txt;
      payload i ppf arg
  | Pcf_extension (s, arg) ->
      line i ppf "Pcf_extension \"%s\"\n" s.txt;
      payload i ppf arg

and class_field_kind i ppf = function
  | Cfk_concrete (o, e) ->
      line i ppf "Concrete %a\n" fmt_override_flag o;
      expression i ppf e
  | Cfk_virtual t ->
      line i ppf "Virtual\n";
      core_type i ppf t

and class_declaration i ppf x =
  line i ppf "class_declaration %a\n" fmt_location x.pci_loc;
  attributes i ppf x.pci_attributes;
  let i = i+1 in
  line i ppf "pci_virt = %a\n" fmt_virtual_flag x.pci_virt;
  line i ppf "pci_params =\n";
  list (i+1) type_parameter ppf x.pci_params;
  line i ppf "pci_name = %a\n" fmt_string_loc x.pci_name;
  line i ppf "pci_expr =\n";
  class_expr (i+1) ppf x.pci_expr;

and module_type i ppf x =
  line i ppf "module_type %a\n" fmt_location x.pmty_loc;
  attributes i ppf x.pmty_attributes;
  let i = i+1 in
  match x.pmty_desc with
  | Pmty_ident li -> line i ppf "Pmty_ident %a\n" fmt_longident_loc li;
  | Pmty_alias li -> line i ppf "Pmty_alias %a\n" fmt_longident_loc li;
  | Pmty_signature (s) ->
      line i ppf "Pmty_signature\n";
      signature i ppf s;
  | Pmty_functor (s, mt1, mt2) ->
      line i ppf "Pmty_functor %a\n" fmt_string_loc s;
      Misc.may (module_type i ppf) mt1;
      module_type i ppf mt2;
  | Pmty_with (mt, l) ->
      line i ppf "Pmty_with\n";
      module_type i ppf mt;
      list i with_constraint ppf l;
  | Pmty_typeof m ->
      line i ppf "Pmty_typeof\n";
      module_expr i ppf m;
  | Pmty_extension (s, arg) ->
      line i ppf "Pmod_extension \"%s\"\n" s.txt;
      payload i ppf arg

and signature i ppf x = list i signature_item ppf x

and signature_item i ppf x =
  line i ppf "signature_item %a\n" fmt_location x.psig_loc;
  let i = i+1 in
  match x.psig_desc with
  | Psig_value vd ->
      line i ppf "Psig_value\n";
      value_description i ppf vd;
  | Psig_type l ->
      line i ppf "Psig_type\n";
      list i type_declaration ppf l;
  | Psig_typext te ->
      line i ppf "Psig_typext\n";
      type_extension i ppf te
  | Psig_exception ext ->
      line i ppf "Psig_exception\n";
      extension_constructor i ppf ext;
  | Psig_module pmd ->
      line i ppf "Psig_module %a\n" fmt_string_loc pmd.pmd_name;
      attributes i ppf pmd.pmd_attributes;
      module_type i ppf pmd.pmd_type
  | Psig_recmodule decls ->
      line i ppf "Psig_recmodule\n";
      list i module_declaration ppf decls;
  | Psig_modtype x ->
      line i ppf "Psig_modtype %a\n" fmt_string_loc x.pmtd_name;
      attributes i ppf x.pmtd_attributes;
      modtype_declaration i ppf x.pmtd_type
  | Psig_open od ->
      line i ppf "Psig_open %a %a\n"
        fmt_override_flag od.popen_override
        fmt_longident_loc od.popen_lid;
      attributes i ppf od.popen_attributes
  | Psig_include incl ->
      line i ppf "Psig_include\n";
      module_type i ppf incl.pincl_mod;
      attributes i ppf incl.pincl_attributes
  | Psig_class (l) ->
      line i ppf "Psig_class\n";
      list i class_description ppf l;
  | Psig_class_type (l) ->
      line i ppf "Psig_class_type\n";
      list i class_type_declaration ppf l;
  | Psig_extension ((s, arg), attrs) ->
      line i ppf "Psig_extension \"%s\"\n" s.txt;
      attributes i ppf attrs;
      payload i ppf arg
  | Psig_attribute (s, arg) ->
      line i ppf "Psig_attribute \"%s\"\n" s.txt;
      payload i ppf arg

and modtype_declaration i ppf = function
  | None -> line i ppf "#abstract"
  | Some mt -> module_type (i+1) ppf mt

and with_constraint i ppf x =
  match x with
  | Pwith_type (lid, td) ->
      line i ppf "Pwith_type %a\n" fmt_longident_loc lid;
      type_declaration (i+1) ppf td;
  | Pwith_typesubst (td) ->
      line i ppf "Pwith_typesubst\n";
      type_declaration (i+1) ppf td;
  | Pwith_module (lid1, lid2) ->
      line i ppf "Pwith_module %a = %a\n"
        fmt_longident_loc lid1
        fmt_longident_loc lid2;
  | Pwith_modsubst (s, li) ->
      line i ppf "Pwith_modsubst %a = %a\n"
        fmt_string_loc s
        fmt_longident_loc li;

and module_expr i ppf x =
  line i ppf "module_expr %a\n" fmt_location x.pmod_loc;
  attributes i ppf x.pmod_attributes;
  let i = i+1 in
  match x.pmod_desc with
  | Pmod_ident (li) -> line i ppf "Pmod_ident %a\n" fmt_longident_loc li;
  | Pmod_structure (s) ->
      line i ppf "Pmod_structure\n";
      structure i ppf s;
  | Pmod_functor (s, mt, me) ->
      line i ppf "Pmod_functor %a\n" fmt_string_loc s;
      Misc.may (module_type i ppf) mt;
      module_expr i ppf me;
  | Pmod_apply (me1, me2) ->
      line i ppf "Pmod_apply\n";
      module_expr i ppf me1;
      module_expr i ppf me2;
  | Pmod_constraint (me, mt) ->
      line i ppf "Pmod_constraint\n";
      module_expr i ppf me;
      module_type i ppf mt;
  | Pmod_unpack (e) ->
      line i ppf "Pmod_unpack\n";
      expression i ppf e;
  | Pmod_extension (s, arg) ->
      line i ppf "Pmod_extension \"%s\"\n" s.txt;
      payload i ppf arg

and structure i ppf x = list i structure_item ppf x

and structure_item i ppf x =
  line i ppf "structure_item %a\n" fmt_location x.pstr_loc;
  let i = i+1 in
  match x.pstr_desc with
  | Pstr_eval (e, attrs) ->
      line i ppf "Pstr_eval\n";
      attributes i ppf attrs;
      expression i ppf e;
  | Pstr_value (rf, l) ->
      line i ppf "Pstr_value %a\n" fmt_rec_flag rf;
      list i value_binding ppf l;
  | Pstr_primitive vd ->
      line i ppf "Pstr_primitive\n";
      value_description i ppf vd;
  | Pstr_type l ->
      line i ppf "Pstr_type\n";
      list i type_declaration ppf l;
  | Pstr_typext te ->
      line i ppf "Pstr_typext\n";
      type_extension i ppf te
  | Pstr_exception ext ->
      line i ppf "Pstr_exception\n";
      extension_constructor i ppf ext;
  | Pstr_module x ->
      line i ppf "Pstr_module\n";
      module_binding i ppf x
  | Pstr_recmodule bindings ->
      line i ppf "Pstr_recmodule\n";
      list i module_binding ppf bindings;
  | Pstr_modtype x ->
      line i ppf "Pstr_modtype %a\n" fmt_string_loc x.pmtd_name;
      attributes i ppf x.pmtd_attributes;
      modtype_declaration i ppf x.pmtd_type
  | Pstr_open od ->
      line i ppf "Pstr_open %a %a\n"
        fmt_override_flag od.popen_override
        fmt_longident_loc od.popen_lid;
      attributes i ppf od.popen_attributes
  | Pstr_class (l) ->
      line i ppf "Pstr_class\n";
      list i class_declaration ppf l;
  | Pstr_class_type (l) ->
      line i ppf "Pstr_class_type\n";
      list i class_type_declaration ppf l;
  | Pstr_include incl ->
      line i ppf "Pstr_include";
      attributes i ppf incl.pincl_attributes;
      module_expr i ppf incl.pincl_mod
  | Pstr_extension ((s, arg), attrs) ->
      line i ppf "Pstr_extension \"%s\"\n" s.txt;
      attributes i ppf attrs;
      payload i ppf arg
  | Pstr_attribute (s, arg) ->
      line i ppf "Pstr_attribute \"%s\"\n" s.txt;
      payload i ppf arg

and module_declaration i ppf pmd =
  string_loc i ppf pmd.pmd_name;
  attributes i ppf pmd.pmd_attributes;
  module_type (i+1) ppf pmd.pmd_type;

and module_binding i ppf x =
  string_loc i ppf x.pmb_name;
  attributes i ppf x.pmb_attributes;
  module_expr (i+1) ppf x.pmb_expr

and core_type_x_core_type_x_location i ppf (ct1, ct2, l) =
  line i ppf "<constraint> %a\n" fmt_location l;
  core_type (i+1) ppf ct1;
  core_type (i+1) ppf ct2;

and constructor_decl i ppf
                     {pcd_name; pcd_args; pcd_res; pcd_loc; pcd_attributes} =
  line i ppf "%a\n" fmt_location pcd_loc;
  line (i+1) ppf "%a\n" fmt_string_loc pcd_name;
  attributes i ppf pcd_attributes;
  list (i+1) core_type ppf pcd_args;
  option (i+1) core_type ppf pcd_res

and label_decl i ppf {pld_name; pld_mutable; pld_type; pld_loc; pld_attributes}=
  line i ppf "%a\n" fmt_location pld_loc;
  attributes i ppf pld_attributes;
  line (i+1) ppf "%a\n" fmt_mutable_flag pld_mutable;
  line (i+1) ppf "%a" fmt_string_loc pld_name;
  core_type (i+1) ppf pld_type

and longident_x_pattern i ppf (li, p) =
  line i ppf "%a\n" fmt_longident_loc li;
  pattern (i+1) ppf p;

and case i ppf {pc_lhs; pc_guard; pc_rhs} =
  line i ppf "<case>\n";
  pattern (i+1) ppf pc_lhs;
  begin match pc_guard with
  | None -> ()
  | Some g -> line (i+1) ppf "<when>\n"; expression (i + 2) ppf g
  end;
  expression (i+1) ppf pc_rhs;

and value_binding i ppf x =
  line i ppf "<def>\n";
  attributes (i+1) ppf x.pvb_attributes;
  pattern (i+1) ppf x.pvb_pat;
  expression (i+1) ppf x.pvb_expr

and string_x_expression i ppf (s, e) =
  line i ppf "<override> %a\n" fmt_string_loc s;
  expression (i+1) ppf e;

and longident_x_expression i ppf (li, e) =
  line i ppf "%a\n" fmt_longident_loc li;
  expression (i+1) ppf e;

and label_x_expression i ppf (l,e) =
  line i ppf "<label> \"%s\"\n" l;
  expression (i+1) ppf e;

and label_x_bool_x_core_type_list i ppf x =
  match x with
    Rtag (l, attrs, b, ctl) ->
      line i ppf "Rtag \"%s\" %s\n" l (string_of_bool b);
      attributes (i+1) ppf attrs;
      list (i+1) core_type ppf ctl
  | Rinherit (ct) ->
      line i ppf "Rinherit\n";
      core_type (i+1) ppf ct
;;

let rec toplevel_phrase i ppf x =
  match x with
  | Ptop_def (s) ->
      line i ppf "Ptop_def\n";
      structure (i+1) ppf s;
  | Ptop_dir (s, da) ->
      line i ppf "Ptop_dir \"%s\"\n" s;
      directive_argument i ppf da;

and directive_argument i ppf x =
  match x with
  | Pdir_none -> line i ppf "Pdir_none\n"
  | Pdir_string (s) -> line i ppf "Pdir_string \"%s\"\n" s;
  | Pdir_int (n) -> line i ppf "Pdir_int %d\n" n;
  | Pdir_ident (li) -> line i ppf "Pdir_ident %a\n" fmt_longident li;
  | Pdir_bool (b) -> line i ppf "Pdir_bool %s\n" (string_of_bool b);
;;

let interface ppf x = list 0 signature_item ppf x;;

let implementation ppf x = list 0 structure_item ppf x;;

let top_phrase ppf x = toplevel_phrase 0 ppf x;;

end
module Printtyped : sig 
#1 "printtyped.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*             Damien Doligez, projet Para, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1999 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Typedtree;;
open Format;;

val interface : formatter -> signature -> unit;;
val implementation : formatter -> structure -> unit;;

val implementation_with_coercion :
    formatter -> (structure * module_coercion) -> unit;;

end = struct
#1 "printtyped.ml"
2(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*                  Fabrice Le Fessant, INRIA Saclay                   *)
(*                                                                     *)
(*  Copyright 1999 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Tublic License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

open Asttypes;;
open Format;;
open Lexing;;
open Location;;
open Typedtree;;

let fmt_position f l =
  if l.pos_lnum = -1
  then fprintf f "%s[%d]" l.pos_fname l.pos_cnum
  else fprintf f "%s[%d,%d+%d]" l.pos_fname l.pos_lnum l.pos_bol
               (l.pos_cnum - l.pos_bol)
;;

let fmt_location f loc =
  fprintf f "(%a..%a)" fmt_position loc.loc_start fmt_position loc.loc_end;
  if loc.loc_ghost then fprintf f " ghost";
;;

let rec fmt_longident_aux f x =
  match x with
  | Longident.Lident (s) -> fprintf f "%s" s;
  | Longident.Ldot (y, s) -> fprintf f "%a.%s" fmt_longident_aux y s;
  | Longident.Lapply (y, z) ->
      fprintf f "%a(%a)" fmt_longident_aux y fmt_longident_aux z;
;;

let fmt_longident_noloc f x = fprintf f "\"%a\"" fmt_longident_aux x;;
let fmt_longident f x = fprintf f "\"%a\"" fmt_longident_aux x.txt;;

let fmt_ident = Ident.print

let rec fmt_path_aux f x =
  match x with
  | Path.Pident (s) -> fprintf f "%a" fmt_ident s;
  | Path.Pdot (y, s, _pos) -> fprintf f "%a.%s" fmt_path_aux y s;
  | Path.Papply (y, z) ->
      fprintf f "%a(%a)" fmt_path_aux y fmt_path_aux z;
;;

let fmt_path f x = fprintf f "\"%a\"" fmt_path_aux x;;
let fmt_path_loc f x = fprintf f "\"%a\"" fmt_path_aux x.txt;;

let fmt_constant f x =
  match x with
  | Const_int (i) -> fprintf f "Const_int %d" i;
  | Const_char (c) -> fprintf f "Const_char %02x" (Char.code c);
  | Const_string (s, None) -> fprintf f "Const_string(%S,None)" s;
  | Const_string (s, Some delim) ->
      fprintf f "Const_string (%S,Some %S)" s delim;
  | Const_float (s) -> fprintf f "Const_float %s" s;
  | Const_int32 (i) -> fprintf f "Const_int32 %ld" i;
  | Const_int64 (i) -> fprintf f "Const_int64 %Ld" i;
  | Const_nativeint (i) -> fprintf f "Const_nativeint %nd" i;
;;

let fmt_mutable_flag f x =
  match x with
  | Immutable -> fprintf f "Immutable";
  | Mutable -> fprintf f "Mutable";
;;

let fmt_virtual_flag f x =
  match x with
  | Virtual -> fprintf f "Virtual";
  | Concrete -> fprintf f "Concrete";
;;

let fmt_override_flag f x =
  match x with
  | Override -> fprintf f "Override";
  | Fresh -> fprintf f "Fresh";
;;

let fmt_closed_flag f x =
  match x with
  | Closed -> fprintf f "Closed"
  | Open -> fprintf f "Open"

let fmt_rec_flag f x =
  match x with
  | Nonrecursive -> fprintf f "Nonrec";
  | Recursive -> fprintf f "Rec";
;;

let fmt_direction_flag f x =
  match x with
  | Upto -> fprintf f "Up";
  | Downto -> fprintf f "Down";
;;

let fmt_private_flag f x =
  match x with
  | Public -> fprintf f "Public";
  | Private -> fprintf f "Private";
;;

let line i f s (*...*) =
  fprintf f "%s" (String.make (2*i) ' ');
  fprintf f s (*...*)
;;

let list i f ppf l =
  match l with
  | [] -> line i ppf "[]\n";
  | _ :: _ ->
     line i ppf "[\n";
     List.iter (f (i+1) ppf) l;
     line i ppf "]\n";
;;

let option i f ppf x =
  match x with
  | None -> line i ppf "None\n";
  | Some x ->
      line i ppf "Some\n";
      f (i+1) ppf x;
;;

let longident i ppf li = line i ppf "%a\n" fmt_longident li;;
let path i ppf li = line i ppf "%a\n" fmt_path li;;
let ident i ppf li = line i ppf "%a\n" fmt_ident li;;
let string i ppf s = line i ppf "\"%s\"\n" s;;
let string_loc i ppf s = line i ppf "\"%s\"\n" s.txt;;
let bool i ppf x = line i ppf "%s\n" (string_of_bool x);;
let label i ppf x = line i ppf "label=\"%s\"\n" x;;

let attributes i ppf l =
  let i = i + 1 in
  List.iter
    (fun (s, arg) ->
      line i ppf "attribute \"%s\"\n" s.txt;
      Printast.payload (i + 1) ppf arg;
    )
    l

let rec core_type i ppf x =
  line i ppf "core_type %a\n" fmt_location x.ctyp_loc;
  attributes i ppf x.ctyp_attributes;
  let i = i+1 in
  match x.ctyp_desc with
  | Ttyp_any -> line i ppf "Ptyp_any\n";
  | Ttyp_var (s) -> line i ppf "Ptyp_var %s\n" s;
  | Ttyp_arrow (l, ct1, ct2) ->
      line i ppf "Ptyp_arrow\n";
      string i ppf l;
      core_type i ppf ct1;
      core_type i ppf ct2;
  | Ttyp_tuple l ->
      line i ppf "Ptyp_tuple\n";
      list i core_type ppf l;
  | Ttyp_constr (li, _, l) ->
      line i ppf "Ptyp_constr %a\n" fmt_path li;
      list i core_type ppf l;
  | Ttyp_variant (l, closed, low) ->
      line i ppf "Ptyp_variant closed=%a\n" fmt_closed_flag closed;
      list i label_x_bool_x_core_type_list ppf l;
      option i (fun i -> list i string) ppf low
  | Ttyp_object (l, c) ->
      line i ppf "Ptyp_object %a\n" fmt_closed_flag c;
      let i = i + 1 in
      List.iter
        (fun (s, attrs, t) ->
          line i ppf "method %s\n" s;
          attributes i ppf attrs;
          core_type (i + 1) ppf t
        )
        l
  | Ttyp_class (li, _, l) ->
      line i ppf "Ptyp_class %a\n" fmt_path li;
      list i core_type ppf l;
  | Ttyp_alias (ct, s) ->
      line i ppf "Ptyp_alias \"%s\"\n" s;
      core_type i ppf ct;
  | Ttyp_poly (sl, ct) ->
      line i ppf "Ptyp_poly%a\n"
        (fun ppf -> List.iter (fun x -> fprintf ppf " '%s" x)) sl;
      core_type i ppf ct;
  | Ttyp_package { pack_path = s; pack_fields = l } ->
      line i ppf "Ptyp_package %a\n" fmt_path s;
      list i package_with ppf l;

and package_with i ppf (s, t) =
  line i ppf "with type %a\n" fmt_longident s;
  core_type i ppf t

and pattern i ppf x =
  line i ppf "pattern %a\n" fmt_location x.pat_loc;
  attributes i ppf x.pat_attributes;
  let i = i+1 in
  match x.pat_extra with
    | (Tpat_unpack, _, attrs) :: rem ->
        line i ppf "Tpat_unpack\n";
        attributes i ppf attrs;
        pattern i ppf { x with pat_extra = rem }
    | (Tpat_constraint cty, _, attrs) :: rem ->
        line i ppf "Tpat_constraint\n";
        attributes i ppf attrs;
        core_type i ppf cty;
        pattern i ppf { x with pat_extra = rem }
    | (Tpat_type (id, _), _, attrs) :: rem ->
        line i ppf "Tpat_type %a\n" fmt_path id;
        attributes i ppf attrs;
        pattern i ppf { x with pat_extra = rem }
    | [] ->
  match x.pat_desc with
  | Tpat_any -> line i ppf "Ppat_any\n";
  | Tpat_var (s,_) -> line i ppf "Ppat_var \"%a\"\n" fmt_ident s;
  | Tpat_alias (p, s,_) ->
      line i ppf "Ppat_alias \"%a\"\n" fmt_ident s;
      pattern i ppf p;
  | Tpat_constant (c) -> line i ppf "Ppat_constant %a\n" fmt_constant c;
  | Tpat_tuple (l) ->
      line i ppf "Ppat_tuple\n";
      list i pattern ppf l;
  | Tpat_construct (li, _, po) ->
      line i ppf "Ppat_construct %a\n" fmt_longident li;
      list i pattern ppf po;
  | Tpat_variant (l, po, _) ->
      line i ppf "Ppat_variant \"%s\"\n" l;
      option i pattern ppf po;
  | Tpat_record (l, c) ->
      line i ppf "Ppat_record\n";
      list i longident_x_pattern ppf l;
  | Tpat_array (l) ->
      line i ppf "Ppat_array\n";
      list i pattern ppf l;
  | Tpat_or (p1, p2, _) ->
      line i ppf "Ppat_or\n";
      pattern i ppf p1;
      pattern i ppf p2;
  | Tpat_lazy p ->
      line i ppf "Ppat_lazy\n";
      pattern i ppf p;

and expression_extra i ppf x attrs =
  match x with
  | Texp_constraint ct ->
      line i ppf "Pexp_constraint\n";
      attributes i ppf attrs;
      core_type i ppf ct;
  | Texp_coerce (cto1, cto2) ->
      line i ppf "Pexp_constraint\n";
      attributes i ppf attrs;
      option i core_type ppf cto1;
      core_type i ppf cto2;
  | Texp_open (ovf, m, _, _) ->
      line i ppf "Pexp_open %a \"%a\"\n" fmt_override_flag ovf fmt_path m;
      attributes i ppf attrs;
  | Texp_poly cto ->
      line i ppf "Pexp_poly\n";
      attributes i ppf attrs;
      option i core_type ppf cto;
  | Texp_newtype s ->
      line i ppf "Pexp_newtype \"%s\"\n" s;
      attributes i ppf attrs;

and expression i ppf x =
  line i ppf "expression %a\n" fmt_location x.exp_loc;
  attributes i ppf x.exp_attributes;
  let i =
    List.fold_left (fun i (extra,_,attrs) -> expression_extra i ppf extra attrs; i+1)
      (i+1) x.exp_extra
  in
  match x.exp_desc with
  | Texp_ident (li,_,_) -> line i ppf "Pexp_ident %a\n" fmt_path li;
  | Texp_instvar (_, li,_) -> line i ppf "Pexp_instvar %a\n" fmt_path li;
  | Texp_constant (c) -> line i ppf "Pexp_constant %a\n" fmt_constant c;
  | Texp_let (rf, l, e) ->
      line i ppf "Pexp_let %a\n" fmt_rec_flag rf;
      list i value_binding ppf l;
      expression i ppf e;
  | Texp_function (p, l, _partial) ->
      line i ppf "Pexp_function \"%s\"\n" p;
(*      option i expression ppf eo; *)
      list i case ppf l;
  | Texp_apply (e, l) ->
      line i ppf "Pexp_apply\n";
      expression i ppf e;
      list i label_x_expression ppf l;
  | Texp_match (e, l1, l2, partial) ->
      line i ppf "Pexp_match\n";
      expression i ppf e;
      list i case ppf l1;
      list i case ppf l2;
  | Texp_try (e, l) ->
      line i ppf "Pexp_try\n";
      expression i ppf e;
      list i case ppf l;
  | Texp_tuple (l) ->
      line i ppf "Pexp_tuple\n";
      list i expression ppf l;
  | Texp_construct (li, _, eo) ->
      line i ppf "Pexp_construct %a\n" fmt_longident li;
      list i expression ppf eo;
  | Texp_variant (l, eo) ->
      line i ppf "Pexp_variant \"%s\"\n" l;
      option i expression ppf eo;
  | Texp_record (l, eo) ->
      line i ppf "Pexp_record\n";
      list i longident_x_expression ppf l;
      option i expression ppf eo;
  | Texp_field (e, li, _) ->
      line i ppf "Pexp_field\n";
      expression i ppf e;
      longident i ppf li;
  | Texp_setfield (e1, li, _, e2) ->
      line i ppf "Pexp_setfield\n";
      expression i ppf e1;
      longident i ppf li;
      expression i ppf e2;
  | Texp_array (l) ->
      line i ppf "Pexp_array\n";
      list i expression ppf l;
  | Texp_ifthenelse (e1, e2, eo) ->
      line i ppf "Pexp_ifthenelse\n";
      expression i ppf e1;
      expression i ppf e2;
      option i expression ppf eo;
  | Texp_sequence (e1, e2) ->
      line i ppf "Pexp_sequence\n";
      expression i ppf e1;
      expression i ppf e2;
  | Texp_while (e1, e2) ->
      line i ppf "Pexp_while\n";
      expression i ppf e1;
      expression i ppf e2;
  | Texp_for (s, _, e1, e2, df, e3) ->
      line i ppf "Pexp_for \"%a\" %a\n" fmt_ident s fmt_direction_flag df;
      expression i ppf e1;
      expression i ppf e2;
      expression i ppf e3;
  | Texp_send (e, Tmeth_name s, eo) ->
      line i ppf "Pexp_send \"%s\"\n" s;
      expression i ppf e;
      option i expression ppf eo
  | Texp_send (e, Tmeth_val s, eo) ->
      line i ppf "Pexp_send \"%a\"\n" fmt_ident s;
      expression i ppf e;
      option i expression ppf eo
  | Texp_new (li, _, _) -> line i ppf "Pexp_new %a\n" fmt_path li;
  | Texp_setinstvar (_, s, _, e) ->
      line i ppf "Pexp_setinstvar \"%a\"\n" fmt_path s;
      expression i ppf e;
  | Texp_override (_, l) ->
      line i ppf "Pexp_override\n";
      list i string_x_expression ppf l;
  | Texp_letmodule (s, _, me, e) ->
      line i ppf "Pexp_letmodule \"%a\"\n" fmt_ident s;
      module_expr i ppf me;
      expression i ppf e;
  | Texp_assert (e) ->
      line i ppf "Pexp_assert";
      expression i ppf e;
  | Texp_lazy (e) ->
      line i ppf "Pexp_lazy";
      expression i ppf e;
  | Texp_object (s, _) ->
      line i ppf "Pexp_object";
      class_structure i ppf s
  | Texp_pack me ->
      line i ppf "Pexp_pack";
      module_expr i ppf me

and value_description i ppf x =
  line i ppf "value_description %a %a\n" fmt_ident x.val_id fmt_location x.val_loc;
  attributes i ppf x.val_attributes;
  core_type (i+1) ppf x.val_desc;
  list (i+1) string ppf x.val_prim;

and type_parameter i ppf (x, _variance) = core_type i ppf x

and type_declaration i ppf x =
  line i ppf "type_declaration %a %a\n" fmt_ident x.typ_id fmt_location x.typ_loc;
  attributes i ppf x.typ_attributes;
  let i = i+1 in
  line i ppf "ptype_params =\n";
  list (i+1) type_parameter ppf x.typ_params;
  line i ppf "ptype_cstrs =\n";
  list (i+1) core_type_x_core_type_x_location ppf x.typ_cstrs;
  line i ppf "ptype_kind =\n";
  type_kind (i+1) ppf x.typ_kind;
  line i ppf "ptype_private = %a\n" fmt_private_flag x.typ_private;
  line i ppf "ptype_manifest =\n";
  option (i+1) core_type ppf x.typ_manifest;

and type_kind i ppf x =
  match x with
  | Ttype_abstract ->
      line i ppf "Ptype_abstract\n"
  | Ttype_variant l ->
      line i ppf "Ptype_variant\n";
      list (i+1) constructor_decl ppf l;
  | Ttype_record l ->
      line i ppf "Ptype_record\n";
      list (i+1) label_decl ppf l;
  | Ttype_open ->
      line i ppf "Ptype_open\n"

and type_extension i ppf x =
  line i ppf "type_extension\n";
  attributes i ppf x.tyext_attributes;
  let i = i+1 in
  line i ppf "ptyext_path = %a\n" fmt_path x.tyext_path;
  line i ppf "ptyext_params =\n";
  list (i+1) type_parameter ppf x.tyext_params;
  line i ppf "ptyext_constructors =\n";
  list (i+1) extension_constructor ppf x.tyext_constructors;
  line i ppf "ptyext_private = %a\n" fmt_private_flag x.tyext_private;

and extension_constructor i ppf x =
  line i ppf "extension_constructor %a\n" fmt_location x.ext_loc;
  attributes i ppf x.ext_attributes;
  let i = i + 1 in
  line i ppf "pext_name = \"%a\"\n" fmt_ident x.ext_id;
  line i ppf "pext_kind =\n";
  extension_constructor_kind (i + 1) ppf x.ext_kind;

and extension_constructor_kind i ppf x =
  match x with
      Text_decl(a, r) ->
        line i ppf "Pext_decl\n";
        list (i+1) core_type ppf a;
        option (i+1) core_type ppf r;
    | Text_rebind(p, _) ->
        line i ppf "Pext_rebind\n";
        line (i+1) ppf "%a\n" fmt_path p;

and class_type i ppf x =
  line i ppf "class_type %a\n" fmt_location x.cltyp_loc;
  attributes i ppf x.cltyp_attributes;
  let i = i+1 in
  match x.cltyp_desc with
  | Tcty_constr (li, _, l) ->
      line i ppf "Pcty_constr %a\n" fmt_path li;
      list i core_type ppf l;
  | Tcty_signature (cs) ->
      line i ppf "Pcty_signature\n";
      class_signature i ppf cs;
  | Tcty_arrow (l, co, cl) ->
      line i ppf "Pcty_arrow \"%s\"\n" l;
      core_type i ppf co;
      class_type i ppf cl;

and class_signature i ppf { csig_self = ct; csig_fields = l } =
  line i ppf "class_signature\n";
  core_type (i+1) ppf ct;
  list (i+1) class_type_field ppf l;

and class_type_field i ppf x =
  line i ppf "class_type_field %a\n" fmt_location x.ctf_loc;
  let i = i+1 in
  attributes i ppf x.ctf_attributes;
  match x.ctf_desc with
  | Tctf_inherit (ct) ->
      line i ppf "Pctf_inherit\n";
      class_type i ppf ct;
  | Tctf_val (s, mf, vf, ct) ->
      line i ppf "Pctf_val \"%s\" %a %a\n" s fmt_mutable_flag mf
           fmt_virtual_flag vf;
      core_type (i+1) ppf ct;
  | Tctf_method (s, pf, vf, ct) ->
      line i ppf "Pctf_method \"%s\" %a %a\n" s fmt_private_flag pf fmt_virtual_flag vf;
      core_type (i+1) ppf ct;
  | Tctf_constraint (ct1, ct2) ->
      line i ppf "Pctf_constraint\n";
      core_type (i+1) ppf ct1;
      core_type (i+1) ppf ct2;
  | Tctf_attribute (s, arg) ->
      line i ppf "Pctf_attribute \"%s\"\n" s.txt;
      Printast.payload i ppf arg

and class_description i ppf x =
  line i ppf "class_description %a\n" fmt_location x.ci_loc;
  attributes i ppf x.ci_attributes;
  let i = i+1 in
  line i ppf "pci_virt = %a\n" fmt_virtual_flag x.ci_virt;
  line i ppf "pci_params =\n";
  list (i+1) type_parameter ppf x.ci_params;
  line i ppf "pci_name = \"%s\"\n" x.ci_id_name.txt;
  line i ppf "pci_expr =\n";
  class_type (i+1) ppf x.ci_expr;

and class_type_declaration i ppf x =
  line i ppf "class_type_declaration %a\n" fmt_location x.ci_loc;
  let i = i+1 in
  line i ppf "pci_virt = %a\n" fmt_virtual_flag x.ci_virt;
  line i ppf "pci_params =\n";
  list (i+1) type_parameter ppf x.ci_params;
  line i ppf "pci_name = \"%s\"\n" x.ci_id_name.txt;
  line i ppf "pci_expr =\n";
  class_type (i+1) ppf x.ci_expr;

and class_expr i ppf x =
  line i ppf "class_expr %a\n" fmt_location x.cl_loc;
  attributes i ppf x.cl_attributes;
  let i = i+1 in
  match x.cl_desc with
  | Tcl_ident (li, _, l) ->
      line i ppf "Pcl_constr %a\n" fmt_path li;
      list i core_type ppf l;
  | Tcl_structure (cs) ->
      line i ppf "Pcl_structure\n";
      class_structure i ppf cs;
  | Tcl_fun (l, p, _, ce, _) ->
      line i ppf "Pcl_fun\n";
      label i ppf l;
      pattern i ppf p;
      class_expr i ppf ce
  | Tcl_apply (ce, l) ->
      line i ppf "Pcl_apply\n";
      class_expr i ppf ce;
      list i label_x_expression ppf l;
  | Tcl_let (rf, l1, l2, ce) ->
      line i ppf "Pcl_let %a\n" fmt_rec_flag rf;
      list i value_binding ppf l1;
      list i ident_x_loc_x_expression_def ppf l2;
      class_expr i ppf ce;
  | Tcl_constraint (ce, Some ct, _, _, _) ->
      line i ppf "Pcl_constraint\n";
      class_expr i ppf ce;
      class_type i ppf ct
  | Tcl_constraint (ce, None, _, _, _) -> class_expr i ppf ce

and class_structure i ppf { cstr_self = p; cstr_fields = l } =
  line i ppf "class_structure\n";
  pattern (i+1) ppf p;
  list (i+1) class_field ppf l;

and class_field i ppf x =
  line i ppf "class_field %a\n" fmt_location x.cf_loc;
  let i = i + 1 in
  attributes i ppf x.cf_attributes;
  match x.cf_desc with
  | Tcf_inherit (ovf, ce, so, _, _) ->
      line i ppf "Pcf_inherit %a\n" fmt_override_flag ovf;
      class_expr (i+1) ppf ce;
      option (i+1) string ppf so;
  | Tcf_val (s, mf, _, k, _) ->
      line i ppf "Pcf_val \"%s\" %a\n" s.txt fmt_mutable_flag mf;
      class_field_kind (i+1) ppf k
  | Tcf_method (s, pf, k) ->
      line i ppf "Pcf_method \"%s\" %a\n" s.txt fmt_private_flag pf;
      class_field_kind (i+1) ppf k
  | Tcf_constraint (ct1, ct2) ->
      line i ppf "Pcf_constraint\n";
      core_type (i+1) ppf ct1;
      core_type (i+1) ppf ct2;
  | Tcf_initializer (e) ->
      line i ppf "Pcf_initializer\n";
      expression (i+1) ppf e;
  | Tcf_attribute (s, arg) ->
      line i ppf "Pcf_attribute \"%s\"\n" s.txt;
      Printast.payload i ppf arg

and class_field_kind i ppf = function
  | Tcfk_concrete (o, e) ->
      line i ppf "Concrete %a\n" fmt_override_flag o;
      expression i ppf e
  | Tcfk_virtual t ->
      line i ppf "Virtual\n";
      core_type i ppf t

and class_declaration i ppf x =
  line i ppf "class_declaration %a\n" fmt_location x.ci_loc;
  let i = i+1 in
  line i ppf "pci_virt = %a\n" fmt_virtual_flag x.ci_virt;
  line i ppf "pci_params =\n";
  list (i+1) type_parameter ppf x.ci_params;
  line i ppf "pci_name = \"%s\"\n" x.ci_id_name.txt;
  line i ppf "pci_expr =\n";
  class_expr (i+1) ppf x.ci_expr;

and module_type i ppf x =
  line i ppf "module_type %a\n" fmt_location x.mty_loc;
  attributes i ppf x.mty_attributes;
  let i = i+1 in
  match x.mty_desc with
  | Tmty_ident (li,_) -> line i ppf "Pmty_ident %a\n" fmt_path li;
  | Tmty_alias (li,_) -> line i ppf "Pmty_alias %a\n" fmt_path li;
  | Tmty_signature (s) ->
      line i ppf "Pmty_signature\n";
      signature i ppf s;
  | Tmty_functor (s, _, mt1, mt2) ->
      line i ppf "Pmty_functor \"%a\"\n" fmt_ident s;
      Misc.may (module_type i ppf) mt1;
      module_type i ppf mt2;
  | Tmty_with (mt, l) ->
      line i ppf "Pmty_with\n";
      module_type i ppf mt;
      list i longident_x_with_constraint ppf l;
  | Tmty_typeof m ->
      line i ppf "Pmty_typeof\n";
      module_expr i ppf m;

and signature i ppf x = list i signature_item ppf x.sig_items

and signature_item i ppf x =
  line i ppf "signature_item %a\n" fmt_location x.sig_loc;
  let i = i+1 in
  match x.sig_desc with
  | Tsig_value vd ->
      line i ppf "Psig_value\n";
      value_description i ppf vd;
  | Tsig_type l ->
      line i ppf "Psig_type\n";
      list i type_declaration ppf l;
  | Tsig_typext e ->
      line i ppf "Psig_typext\n";
      type_extension i ppf e;
  | Tsig_exception ext ->
      line i ppf "Psig_exception\n";
      extension_constructor i ppf ext
  | Tsig_module md ->
      line i ppf "Psig_module \"%a\"\n" fmt_ident md.md_id;
      attributes i ppf md.md_attributes;
      module_type i ppf md.md_type
  | Tsig_recmodule decls ->
      line i ppf "Psig_recmodule\n";
      list i module_declaration ppf decls;
  | Tsig_modtype x ->
      line i ppf "Psig_modtype \"%a\"\n" fmt_ident x.mtd_id;
      attributes i ppf x.mtd_attributes;
      modtype_declaration i ppf x.mtd_type
  | Tsig_open od ->
      line i ppf "Psig_open %a %a\n"
           fmt_override_flag od.open_override
           fmt_path od.open_path;
      attributes i ppf od.open_attributes
  | Tsig_include incl ->
      line i ppf "Psig_include\n";
      attributes i ppf incl.incl_attributes;
      module_type i ppf incl.incl_mod
  | Tsig_class (l) ->
      line i ppf "Psig_class\n";
      list i class_description ppf l;
  | Tsig_class_type (l) ->
      line i ppf "Psig_class_type\n";
      list i class_type_declaration ppf l;
  | Tsig_attribute (s, arg) ->
      line i ppf "Psig_attribute \"%s\"\n" s.txt;
      Printast.payload i ppf arg

and module_declaration i ppf md =
  line i ppf "%a" fmt_ident md.md_id;
  attributes i ppf md.md_attributes;
  module_type (i+1) ppf md.md_type;

and module_binding i ppf x =
  line i ppf "%a\n" fmt_ident x.mb_id;
  attributes i ppf x.mb_attributes;
  module_expr (i+1) ppf x.mb_expr

and modtype_declaration i ppf = function
  | None -> line i ppf "#abstract"
  | Some mt -> module_type (i + 1) ppf mt

and with_constraint i ppf x =
  match x with
  | Twith_type (td) ->
      line i ppf "Pwith_type\n";
      type_declaration (i+1) ppf td;
  | Twith_typesubst (td) ->
      line i ppf "Pwith_typesubst\n";
      type_declaration (i+1) ppf td;
  | Twith_module (li,_) -> line i ppf "Pwith_module %a\n" fmt_path li;
  | Twith_modsubst (li,_) -> line i ppf "Pwith_modsubst %a\n" fmt_path li;

and module_expr i ppf x =
  line i ppf "module_expr %a\n" fmt_location x.mod_loc;
  attributes i ppf x.mod_attributes;
  let i = i+1 in
  match x.mod_desc with
  | Tmod_ident (li,_) -> line i ppf "Pmod_ident %a\n" fmt_path li;
  | Tmod_structure (s) ->
      line i ppf "Pmod_structure\n";
      structure i ppf s;
  | Tmod_functor (s, _, mt, me) ->
      line i ppf "Pmod_functor \"%a\"\n" fmt_ident s;
      Misc.may (module_type i ppf) mt;
      module_expr i ppf me;
  | Tmod_apply (me1, me2, _) ->
      line i ppf "Pmod_apply\n";
      module_expr i ppf me1;
      module_expr i ppf me2;
  | Tmod_constraint (me, _, Tmodtype_explicit mt, _) ->
      line i ppf "Pmod_constraint\n";
      module_expr i ppf me;
      module_type i ppf mt;
  | Tmod_constraint (me, _, Tmodtype_implicit, _) -> module_expr i ppf me
  | Tmod_unpack (e, _) ->
      line i ppf "Pmod_unpack\n";
      expression i ppf e;

and structure i ppf x = list i structure_item ppf x.str_items

and structure_item i ppf x =
  line i ppf "structure_item %a\n" fmt_location x.str_loc;
  let i = i+1 in
  match x.str_desc with
  | Tstr_eval (e, attrs) ->
      line i ppf "Pstr_eval\n";
      attributes i ppf attrs;
      expression i ppf e;
  | Tstr_value (rf, l) ->
      line i ppf "Pstr_value %a\n" fmt_rec_flag rf;
      list i value_binding ppf l;
  | Tstr_primitive vd ->
      line i ppf "Pstr_primitive\n";
      value_description i ppf vd;
  | Tstr_type l ->
      line i ppf "Pstr_type\n";
      list i type_declaration ppf l;
  | Tstr_typext te ->
      line i ppf "Pstr_typext\n";
      type_extension i ppf te
  | Tstr_exception ext ->
      line i ppf "Pstr_exception\n";
      extension_constructor i ppf ext;
  | Tstr_module x ->
      line i ppf "Pstr_module\n";
      module_binding i ppf x
  | Tstr_recmodule bindings ->
      line i ppf "Pstr_recmodule\n";
      list i module_binding ppf bindings
  | Tstr_modtype x ->
      line i ppf "Pstr_modtype \"%a\"\n" fmt_ident x.mtd_id;
      attributes i ppf x.mtd_attributes;
      modtype_declaration i ppf x.mtd_type
  | Tstr_open od ->
      line i ppf "Pstr_open %a %a\n"
           fmt_override_flag od.open_override
           fmt_path od.open_path;
      attributes i ppf od.open_attributes
  | Tstr_class (l) ->
      line i ppf "Pstr_class\n";
      list i class_declaration ppf (List.map (fun (cl, _,_) -> cl) l);
  | Tstr_class_type (l) ->
      line i ppf "Pstr_class_type\n";
      list i class_type_declaration ppf (List.map (fun (_, _, cl) -> cl) l);
  | Tstr_include incl ->
      line i ppf "Pstr_include";
      attributes i ppf incl.incl_attributes;
      module_expr i ppf incl.incl_mod;
  | Tstr_attribute (s, arg) ->
      line i ppf "Pstr_attribute \"%s\"\n" s.txt;
      Printast.payload i ppf arg

and string_x_module_type i ppf (s, _, mty) =
  ident i ppf s;
  module_type (i+1) ppf mty;

and string_x_modtype_x_module i ppf (s, _, mty, modl) =
  ident i ppf s;
  module_type (i+1) ppf mty;
  module_expr (i+1) ppf modl;

and longident_x_with_constraint i ppf (li, _, wc) =
  line i ppf "%a\n" fmt_path li;
  with_constraint (i+1) ppf wc;

and core_type_x_core_type_x_location i ppf (ct1, ct2, l) =
  line i ppf "<constraint> %a\n" fmt_location l;
  core_type (i+1) ppf ct1;
  core_type (i+1) ppf ct2;

and constructor_decl i ppf {cd_id; cd_name = _; cd_args; cd_res; cd_loc; cd_attributes} =
  line i ppf "%a\n" fmt_location cd_loc;
  line (i+1) ppf "%a\n" fmt_ident cd_id;
  attributes i ppf cd_attributes;
  list (i+1) core_type ppf cd_args;
  option (i+1) core_type ppf cd_res

and label_decl i ppf {ld_id; ld_name = _; ld_mutable; ld_type; ld_loc; ld_attributes} =
  line i ppf "%a\n" fmt_location ld_loc;
  attributes i ppf ld_attributes;
  line (i+1) ppf "%a\n" fmt_mutable_flag ld_mutable;
  line (i+1) ppf "%a" fmt_ident ld_id;
  core_type (i+1) ppf ld_type

and longident_x_pattern i ppf (li, _, p) =
  line i ppf "%a\n" fmt_longident li;
  pattern (i+1) ppf p;

and case i ppf {c_lhs; c_guard; c_rhs} =
  line i ppf "<case>\n";
  pattern (i+1) ppf c_lhs;
  begin match c_guard with
  | None -> ()
  | Some g -> line (i+1) ppf "<when>\n"; expression (i + 2) ppf g
  end;
  expression (i+1) ppf c_rhs;

and value_binding i ppf x =
  line i ppf "<def>\n";
  attributes (i+1) ppf x.vb_attributes;
  pattern (i+1) ppf x.vb_pat;
  expression (i+1) ppf x.vb_expr

and string_x_expression i ppf (s, _, e) =
  line i ppf "<override> \"%a\"\n" fmt_path s;
  expression (i+1) ppf e;

and longident_x_expression i ppf (li, _, e) =
  line i ppf "%a\n" fmt_longident li;
  expression (i+1) ppf e;

and label_x_expression i ppf (l, e, _) =
  line i ppf "<label> \"%s\"\n" l;
  (match e with None -> () | Some e -> expression (i+1) ppf e)

and ident_x_loc_x_expression_def i ppf (l,_, e) =
  line i ppf "<def> \"%a\"\n" fmt_ident l;
  expression (i+1) ppf e;

and label_x_bool_x_core_type_list i ppf x =
  match x with
    Ttag (l, attrs, b, ctl) ->
      line i ppf "Rtag \"%s\" %s\n" l (string_of_bool b);
      attributes (i+1) ppf attrs;
      list (i+1) core_type ppf ctl
  | Tinherit (ct) ->
      line i ppf "Rinherit\n";
      core_type (i+1) ppf ct
;;

let interface ppf x = list 0 signature_item ppf x.sig_items;;

let implementation ppf x = list 0 structure_item ppf x.str_items;;

let implementation_with_coercion ppf (x, _) = implementation ppf x

end
module Js_implementation : sig 
#1 "js_implementation.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)








(** High level compilation module *) 

(** This module defines a function to compile the program directly into [js]
    given [filename] and [outputprefix], 
    it will be useful if we don't care about bytecode output(generating js only).
 *)
val interface : Format.formatter -> string -> string -> unit

val interface_mliast : Format.formatter -> string -> string  -> unit
  
val after_parsing_sig : Format.formatter -> string -> string -> Parsetree.signature -> unit

val after_parsing_impl : Format.formatter -> string -> string -> Parsetree.structure -> unit
(** [after_parsing_impl ppf sourcefile outputprefix ast ]
    Make sure you need run {!Compmisc.init_path} for set up
*)

val implementation : Format.formatter -> string -> string -> unit
(** [implementation ppf sourcefile outprefix] compiles to JS directly *) 

val implementation_mlast : Format.formatter -> string -> string -> unit

val implementation_map : Format.formatter -> string -> string -> unit
end = struct
#1 "js_implementation.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 2002 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(* adapted by bucklescript from [driver/compile.ml] for convenience    *)

open Format
open Typedtree
open Compenv



let fprintf = Format.fprintf



let print_if ppf flag printer arg =
  if !flag then fprintf ppf "%a@." printer arg;
  arg



let after_parsing_sig ppf sourcefile outputprefix ast  =
  if !Js_config.binary_ast then
    begin 
      Binary_ast.write_ast
        Mli
        ~fname:sourcefile
        ~output:(outputprefix ^ Literals.suffix_mliast)
        (* to support relocate to another directory *)
        ast 

    end;
  if !Js_config.syntax_only then () else 
    begin 
      if not @@ !Js_config.no_warn_unused_bs_attribute then 
        Bs_ast_invariant.emit_external_warnings.signature Bs_ast_invariant.emit_external_warnings ast ;
      if Js_config.get_diagnose () then
        Format.fprintf Format.err_formatter "Building %s@." sourcefile;    
      let modulename = module_of_filename ppf sourcefile outputprefix in
      Lam_compile_env.reset () ;
      let initial_env = Compmisc.initial_env () in
      Env.set_unit_name modulename;
      let tsg = Typemod.type_interface initial_env ast in
      if !Clflags.dump_typedtree then fprintf ppf "%a@." Printtyped.interface tsg;
      let sg = tsg.sig_type in
      if !Clflags.print_types then
        Printtyp.wrap_printing_env initial_env (fun () ->
            fprintf std_formatter "%a@."
              Printtyp.signature (Typemod.simplify_signature sg));
      ignore (Includemod.signatures initial_env sg sg);
      Typecore.force_delayed_checks ();
      Warnings.check_fatal ();
      if not !Clflags.print_types then begin
        let sg = Env.save_signature sg modulename (outputprefix ^ ".cmi") in
        Typemod.save_signature modulename tsg outputprefix sourcefile
          initial_env sg ;
      end
    end
let interface ppf sourcefile outputprefix =
  Compmisc.init_path false;
  Ocaml_parse.parse_interface ppf sourcefile
  |> print_if ppf Clflags.dump_parsetree Printast.interface
  |> print_if ppf Clflags.dump_source Pprintast.signature 
  |> after_parsing_sig ppf sourcefile outputprefix 

let interface_mliast ppf sourcefile outputprefix  = 
  Compmisc.init_path false;
  Binary_ast.read_ast Mli sourcefile 
  |> print_if ppf Clflags.dump_parsetree Printast.interface
  |> print_if ppf Clflags.dump_source Pprintast.signature 
  |> after_parsing_sig ppf sourcefile outputprefix 

let after_parsing_impl ppf sourcefile outputprefix ast =
  if !Js_config.binary_ast then
    Binary_ast.write_ast ~fname:sourcefile 
      Ml ~output:(outputprefix ^ Literals.suffix_mlast)
      ast ;
  if !Js_config.syntax_only then () else 
    begin

      if not @@ !Js_config.no_warn_unused_bs_attribute then 
        Bs_ast_invariant.emit_external_warnings.structure Bs_ast_invariant.emit_external_warnings ast ;
      if Js_config.get_diagnose () then
        Format.fprintf Format.err_formatter "Building %s@." sourcefile;      
      let modulename = Compenv.module_of_filename ppf sourcefile outputprefix in
      Lam_compile_env.reset () ;
      let env = Compmisc.initial_env() in
      Env.set_unit_name modulename;
      try
        let (typedtree, coercion, finalenv, current_signature) =
          ast 
          |> Typemod.type_implementation_more sourcefile outputprefix modulename env 
          |> print_if ppf Clflags.dump_typedtree
            (fun fmt (ty,co,_,_) -> Printtyped.implementation_with_coercion fmt  (ty,co))
        in
        if !Clflags.print_types then begin
          Warnings.check_fatal ();
        end else begin
          (typedtree, coercion)
          |> Translmod.transl_implementation modulename
          |> print_if ppf Clflags.dump_rawlambda Printlambda.lambda
          |> (fun lambda -> 
              match           
                Lam_compile_main.lambda_as_module
                  finalenv current_signature 
                  sourcefile  outputprefix lambda  with
              | e -> e 
              | exception e -> 
                (* Save to a file instead so that it will not scare user *)
                if Js_config.get_diagnose () then
                  begin              
                    let file = "bsc.dump" in
                    Ext_pervasives.with_file_as_chan file
                      (fun ch -> output_string ch @@             
                        Printexc.raw_backtrace_to_string (Printexc.get_raw_backtrace ()));
                    Ext_log.err __LOC__
                      "Compilation fatal error, stacktrace saved into %s when compiling %s"
                      file sourcefile;
                  end;            
                raise e             
            );
          Warnings.check_fatal ()
        end;
        Stypes.dump (Some (outputprefix ^ ".annot"));
      with x ->
        Stypes.dump (Some (outputprefix ^ ".annot"));
        raise x
    end
let implementation ppf sourcefile outputprefix =
  Compmisc.init_path false;
  Ocaml_parse.parse_implementation ppf sourcefile
  |> print_if ppf Clflags.dump_parsetree Printast.implementation
  |> print_if ppf Clflags.dump_source Pprintast.structure
  |> after_parsing_impl ppf sourcefile outputprefix 

let implementation_mlast ppf sourcefile outputprefix = 
  Compmisc.init_path false;
  Binary_ast.read_ast Ml sourcefile
  |> print_if ppf Clflags.dump_parsetree Printast.implementation
  |> print_if ppf Clflags.dump_source Pprintast.structure
  |> after_parsing_impl ppf sourcefile outputprefix 







let make_structure_item ~ns cunit : Parsetree.structure_item =
  let open Ast_helper in 
  let loc = Location.none in 
  Str.module_ 
    (Mb.mk {txt = cunit; loc  }
       (Mod.ident 
          {txt = Lident 
               ( Ext_namespace.make ~ns cunit)
          ; loc}))



let implementation_map ppf sourcefile outputprefix = 
  let list_of_modules = Ext_io.rev_lines_of_file sourcefile 
  in 
  let ns = 
    Ext_string.capitalize_ascii
      (Filename.chop_extension (Filename.basename sourcefile)) in
  let ml_ast = List.fold_left (fun acc module_name -> 
      if Ext_string.is_empty module_name then acc 
      else make_structure_item ~ns module_name :: acc 
    ) [] list_of_modules in 
  Compmisc.init_path false;
  ml_ast
  |> print_if ppf Clflags.dump_parsetree Printast.implementation
  |> print_if ppf Clflags.dump_source Pprintast.structure
  |> after_parsing_impl ppf sourcefile outputprefix 


end
module Ocaml_batch_compile : sig 
#1 "ocaml_batch_compile.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

type task = 
  | Main of string
  | Eval of string 
  | None

(** reutrn value is the error code *)
val batch_compile : Format.formatter -> string list -> string list -> task ->  int

end = struct
#1 "ocaml_batch_compile.ml"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)



module String_set = Depend.StringSet

(* we can cache it, since all deps have already being processed,
   but having this functionalilty will introduce deps on {!Unix.stat}
*)
let process_result ppf  main_file ast_table result = 
  if Js_config.get_diagnose () then
    Format.fprintf Format.err_formatter
      "Order: @[%a@]@."
      (Ext_format.pp_print_queue
         ~pp_sep:Format.pp_print_space
         Format.pp_print_string)
      result ;
  Ast_extract.build_lazy_queue ppf result ast_table
    Js_implementation.after_parsing_impl
    Js_implementation.after_parsing_sig 
  ;
  if not (!Clflags.compile_only) then
    Sys.command
      ("node " ^
        Ext_namespace.js_name_of_basename (Filename.chop_extension main_file)
      )
  else 0

type task = 
  | Main of string
  | Eval of string 
  (* currently we just output JS file, 
     it is compilicated to run via node.
     1. Create a temporary file, it has to be in the same directory?
     2. Via `node -e`, we need a module to do shell escaping properly
  *)
  | None


let print_if ppf flag printer arg =
  if !flag then Format.fprintf ppf "%a@." printer arg;
  arg

let batch_compile ppf search_dirs files main_file =
  Compenv.readenv ppf Before_compile; 
  Compmisc.init_path  false;
  if files <> [] then 
    begin
      let ast_table =
        Ast_extract.collect_ast_map ppf files
          Ocaml_parse.parse_implementation
          Ocaml_parse.parse_interface in
      Ast_extract.build_queue ppf
        (Ast_extract.sort Ext_pervasives.id  Ext_pervasives.id  ast_table)
        ast_table
        Js_implementation.after_parsing_impl
        Js_implementation.after_parsing_sig        
    end        
  ;
  begin match main_file with
    | Main main_file -> 
      let main_module = (Ext_modulename.module_name_of_file main_file) in
      let ast_table, result =
        Ast_extract.collect_from_main ppf 
          ~extra_dirs:(Ext_list.map
                         (fun x -> 
                            ({ dir = x ; excludes = [] } : Ast_extract.dir_spec)) search_dirs)
          Ocaml_parse.lazy_parse_implementation
          Ocaml_parse.lazy_parse_interface         
          Lazy.force
          Lazy.force
          main_module
      in
      if Queue.is_empty result then
        Bs_exception.error (Bs_main_not_exist main_module);
      (* ; Not necessary since we will alwasy check [main_file] is valid or not,
         so if we support 
         bsc -I xx -I yy -bs-main Module_name
      *)
      process_result ppf main_file ast_table result     
    | None ->  0
    | Eval s ->
      Ext_ref.protect_list 
        [Clflags.dont_write_files , true ; 
         Clflags.annotations, false;
         Clflags.binary_annotations, false;
         Js_config.dump_js, true ;
        ]  (fun _ -> 
            Ocaml_parse.parse_implementation_from_string s 
            (* FIXME: Note in theory, the order of applying our built in ppx 
               and apply third party ppx should not matter, but in practice  
               it may.
               We should make it more consistent. 
               Thirdy party ppx may be buggy to drop annotations.
               If we always put our ppx in the beginning, it will be more robust, 
               however, the current implementation (in the batch compilation mode) 
               seems to apply our ppx after all ppx transformations
            *)
            |> Pparse.apply_rewriters_str ~tool_name:Js_config.tool_name
            |> print_if ppf Clflags.dump_parsetree Printast.implementation
            |> print_if ppf Clflags.dump_source Pprintast.structure
            |> Js_implementation.after_parsing_impl ppf "//<toplevel>//" "Bs_internal_eval" 
          ); 0
  end





end
module Ocaml_options : sig 
#1 "ocaml_options.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)



val mk_impl : (string -> unit) -> string * Arg.spec * string
val mk_intf : (string -> unit) -> string * Arg.spec * string
val mk__ : (string -> unit) -> string * Arg.spec * string
(**
   [ocaml_options] are command options inherited from ocaml 
   bytecode compiler except three options 
   [impl] [intf] and [annoymous] which is in another module 
   due to  dependencies
*)
val ocaml_options : (string * Arg.spec * string) list

end = struct
#1 "ocaml_options.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)

(** Need sync up with {!Main_args} and {!Optmain} *)
open Clflags
open Compenv

let mk_absname f =
  "-absname", Arg.Unit f, " Show absolute filenames in error messages"
;;

let mk_annot f =
  "-annot", Arg.Unit f, " Save information in <filename>.annot"
;;

let mk_binannot f =
  "-bin-annot", Arg.Unit f, " Save typedtree in <filename>.cmt"
;;

let mk_c f =
  "-c", Arg.Unit f, " Compile only (do not link)"
;;

let mk_config f =
  "-config", Arg.Unit f, " Print configuration values and exit"
;;

let mk_g_byt f =
  "-g", Arg.Unit f, " Save debugging information"
;;

let mk_i f =
  "-i", Arg.Unit f, " Print inferred interface"
;;

let mk_I f =
  "-I", Arg.String f, "<dir>  Add <dir> to the list of include directories"
;;

let mk_impl f =
  "-impl", Arg.String f, "<file>  Compile <file> as a .ml file"
;;

let mk_intf f =
  "-intf", Arg.String f, "<file>  Compile <file> as a .mli file"
;;

let mk_intf_suffix f =
  "-intf-suffix", Arg.String f,
  "<string>  Suffix for interface files (default: .mli)"
;;

let mk_keep_docs f =
  "-keep-docs", Arg.Unit f, " Keep documentation strings in .cmi files"
;;

let mk_keep_locs f =
  "-keep-locs", Arg.Unit f, " Keep locations in .cmi files"
;;

let mk_labels f =
  "-labels", Arg.Unit f, " Use commuting label mode"
;;

let mk_no_alias_deps f =
  "-no-alias-deps", Arg.Unit f,
  " Do not record dependencies for module aliases"
;;

let mk_no_app_funct f =
  "-no-app-funct", Arg.Unit f, " Deactivate applicative functors"
;;

let mk_no_check_prims f =
  "-no-check-prims", Arg.Unit f, " Do not check runtime for primitives"
;;

let mk_noassert f =
  "-noassert", Arg.Unit f, " Do not compile assertion checks"
;;

let mk_nolabels f =
  "-nolabels", Arg.Unit f, " Ignore non-optional labels in types"
;;

let mk_nostdlib f =
  "-nostdlib", Arg.Unit f,
  " Do not add default directory to the list of include directories"
;;

let mk_o f =
  "-o", Arg.String f, "<file>  Set output file name to <file>"
;;

let mk_open f =
  "-open", Arg.String f, "<module>  Opens the module <module> before typing"

let mk_pp f =
  "-pp", Arg.String f, "<command>  Pipe sources through preprocessor <command>"
;;

let mk_ppx f =
  "-ppx", Arg.String f,
  "<command>  Pipe abstract syntax trees through preprocessor <command>"
;;

let mk_principal f =
  "-principal", Arg.Unit f, " Check principality of type inference"
;;

let mk_rectypes f =
  "-rectypes", Arg.Unit f, " Allow arbitrary recursive types"
;;

let mk_safe_string f =
  "-safe-string", Arg.Unit f, " Make strings immutable"
;;

let mk_short_paths f =
  "-short-paths", Arg.Unit f, " Shorten paths in types"
;;

let mk_stdin f =
  "-stdin", Arg.Unit f, " Read script from standard input"
;;

let mk_strict_sequence f =
  "-strict-sequence", Arg.Unit f,
  " Left-hand part of a sequence must have type unit"
;;

let mk_unsafe f =
  "-unsafe", Arg.Unit f,
  " Do not compile bounds checking on array and string access"
;;

let mk_v f =
  "-v", Arg.Unit f,
  " Print compiler version and location of standard library and exit"
;;

let mk_verbose f =
  "-verbose", Arg.Unit f, " Print calls to external commands"
;;

let mk_version f =
  "-version", Arg.Unit f, " Print version and exit"
;;

let mk_vnum f =
  "-vnum", Arg.Unit f, " Print version number and exit"
;;

let mk_w f =
  "-w", Arg.String f,
  Printf.sprintf
  "<list>  Enable or disable warnings according to <list>:\n\
  \        +<spec>   enable warnings in <spec>\n\
  \        -<spec>   disable warnings in <spec>\n\
  \        @<spec>   enable warnings in <spec> and treat them as errors\n\
  \     <spec> can be:\n\
  \        <num>             a single warning number\n\
  \        <num1>..<num2>    a range of consecutive warning numbers\n\
  \        <letter>          a predefined set\n\
  \     default setting is %S" Warnings.defaults_w
;;

let mk_warn_error f =
  "-warn-error", Arg.String f,
  Printf.sprintf
  "<list>  Enable or disable error status for warnings according\n\
  \     to <list>.  See option -w for the syntax of <list>.\n\
  \     Default setting is %S" Warnings.defaults_warn_error
;;

let mk_warn_help f =
  "-warn-help", Arg.Unit f, " Show description of warning numbers"
;;

let mk_where f =
  "-where", Arg.Unit f, " Print location of standard library and exit"
;;

let mk_color f =
  "-color", Arg.Symbol (["auto"; "always"; "never"], f),
  Printf.sprintf
  "  Enable or disable colors in compiler messages\n\
  \    The following settings are supported:\n\
  \      auto    use heuristics to enable colors only if supported\n\
  \      always  enable colors\n\
  \      never   disable colors\n\
  \    The default setting is 'auto', and the current heuristic\n\
  \    checks that the TERM environment variable exists and is\n\
  \    not empty or \"dumb\", and that isatty(stderr) holds."
;;


let mk_nopervasives f =
  "-nopervasives", Arg.Unit f, " (undocumented)"
;;

let mk_dparsetree f =
  "-dparsetree", Arg.Unit f, " (undocumented)"
;;

let mk_dtypedtree f =
  "-dtypedtree", Arg.Unit f, " (undocumented)"
;;

let mk_drawlambda f =
  "-drawlambda", Arg.Unit f, " (undocumented)"
;;

let mk_dsource f =
  "-dsource", Arg.Unit f, " (undocumented)"
;;

let mk_dlambda f =
  "-dlambda", Arg.Unit f, " (undocumented)"
;;

let mk_opaque f =
  "-opaque", Arg.Unit f,
  " Does not generate cross-module optimization information\n\
  \     (reduces necessary recompilation on module change)"
;;

let mk_strict_formats f =
  "-strict-formats", Arg.Unit f,
  " Reject invalid formats accepted by legacy implementations\n\
  \     (Warning: Invalid formats may behave differently from\n\
  \      previous OCaml versions, and will become always-rejected\n\
  \      in future OCaml versions. You should use this flag\n\
  \      to detect and fix invalid formats.)"
;;

let mk__ f =
  "-", Arg.String f,
  "<file>  Treat <file> as a file name (even if it starts with `-')"
;;

let show_config () =
  Config.print_config stdout;
  exit 0;
;;

let ocaml_options = 
  let bs_version_string = 
    "BuckleScript " ^ Bs_version.version ^
    " (Using OCaml" ^ Config.version ^ " )" in

  let print_version_and_library compiler =
    Printf.printf "The OCaml %s, version " compiler;
    print_string bs_version_string; print_newline();
    print_string "Standard library directory: ";
    print_string Config.standard_library; print_newline();
    exit 0 in

  let print_standard_library = Compenv.print_standard_library in

  let print_version_string () = 
    print_string bs_version_string;
    print_newline (); 
    exit 0 in

  let set r () = r := true in 
  let unset r () = r := false in 
  let _absname = set Location.absname in 
  let _color option = 
      match Clflags.parse_color_setting option with
      | None -> ()
      | Some setting -> Clflags.color := setting in 
  let _annot = set annotations in 
  let _binannot = set binary_annotations in 
  let _c = set compile_only in 
  let _config = show_config in 
  let _g = set debug in 
  let _i () = print_types := true; compile_only := true in 
  let _I s = include_dirs := s :: !include_dirs in 
  (* let _impl = impl in  *)
  (* let _intf = intf in  *)
  let _intf_suffix s = Config.interface_suffix := s in 
  let _keep_docs = set keep_docs in 
  let _keep_locs = set keep_locs in 
  let _labels = unset classic in 
  let _no_alias_deps = set transparent_modules in 
  let _no_app_funct = unset applicative_functors in 
  let _noassert = set noassert in 
  let _nolabels = set classic in 
  let _nostdlib = set no_std_include in 
  let _o s = output_name := Some s in 
  let _open s = open_modules := s :: !open_modules in 
  let _pp s = preprocessor := Some s in 
  let _ppx s = first_ppx := s :: !first_ppx in 
  let _principal = set principal in 
  let _rectypes = set recursive_types in 
  let _safe_string = unset unsafe_string in 
  let _short_paths = unset real_paths in 
  let _strict_sequence = set strict_sequence in 
  let _strict_formats = set strict_formats in 
  let _unsafe = set fast in 
  let _unsafe_string = set unsafe_string in 
  let _v () = print_version_and_library "compiler" in 
  let _version = print_version_string in 
  let _vnum = print_version_string in 
  let _w = (Warnings.parse_options false) in
  let _warn_error = (Warnings.parse_options true) in
  let _warn_help = Warnings.help_warnings in
  let _where = print_standard_library in 
  let _verbose = set verbose in 
  let _nopervasives = set nopervasives in
  let _dsource = set dump_source in 
  let _dparsetree = set dump_parsetree in 
  let _dtypedtree = set dump_typedtree in
  let _drawlambda = set dump_rawlambda in
  let _dlambda = set dump_lambda in
  (* let anonymous = anonymous in *)

  [ mk_absname _absname;
    mk_annot _annot;
    mk_binannot _binannot;
    mk_c _c;
    mk_config _config;
    mk_g_byt _g;
    mk_i _i;
    mk_I _I;
    mk_color _color;
    (* mk_impl _impl; *)
    (* mk_intf _intf; *)
    mk_intf_suffix _intf_suffix;
    mk_keep_docs _keep_docs;
    mk_keep_locs _keep_locs;
    mk_labels _labels;
    mk_no_alias_deps _no_alias_deps;
    mk_no_app_funct _no_app_funct;
    mk_noassert _noassert;
    mk_nolabels _nolabels;
    mk_nostdlib _nostdlib;
    mk_o _o;
    mk_open _open;
    mk_pp _pp;
    mk_ppx _ppx;
    mk_principal _principal;
    mk_rectypes _rectypes;
    mk_safe_string _safe_string;
    mk_short_paths _short_paths;
    mk_strict_sequence _strict_sequence;
    mk_strict_formats _strict_formats;
    mk_unsafe _unsafe;
    mk_v _v;
    mk_verbose _verbose;
    mk_version _version;
    mk_vnum _vnum;
    mk_w _w;
    mk_warn_error _warn_error;
    mk_warn_help _warn_help;
    mk_where _where;
    mk_color _color;
    (* mk__ anonymous; *)
    mk_nopervasives _nopervasives;
    mk_dsource _dsource;
    mk_dparsetree _dparsetree;
    mk_dtypedtree _dtypedtree;
    mk_drawlambda _drawlambda;
    mk_dlambda _dlambda ]


end
module Tweaked_reason_oprint
= struct
#1 "tweaked_reason_oprint.ml"
(* Hello! Welcome to the Reason "outcome printer" logic. This logic takes the
  AST nodes and turn them into text, for Merlin, rtop and terminal errors
  reporting to be in Reason syntax.

  If you've navigated around in the Reason codebase, you might have seen the
  other printer called reason_pprint_ast, our actual, main pretty-printer. Why
  is this one separated from reason_pprint_ast? Because the outcome printer's
  use-case is a bit different and needs different entry points blablabla...
  These are mostly excuses. But for example, currently, `Js.t {. foo: bar}` by
  itself is *invalid syntax* for a pretty printer (the correct, minimal valid
  code would be `type myObject = Js.t {. foo: bar}`), but the terminal error
  report do want to provide just that snippet and have you print it. Hopefully
  OCaml can unify actual code pretty-printing and terminal type info pretty-
  printing one day.

  This also means the outcome printer doesn't use the normal Parsetree,
  Ast_helper and others you might have seen in other files. It has its own
  small AST definition here:
  https://github.com/ocaml/ocaml/blob/4.04/typing/outcometree.mli

  The rest of this file's logic is just pattern-matching on these tree node
  variants & using Format to pretty-print them nicely.
  *)

(*
  This file's shared between the Reason repo and the BuckleScript repo. In
  Reason, it's in src/reason_oprint.ml. In BuckleScript, it's in
  jscomp/reason_outcome_printer/tweaked_reason_oprint.ml. We periodically copy
  this file from Reason (the source of truth) to BuckleScript, then uncomment
  the #if #else #end cppo macros you see in the file. That's because
  BuckleScript's on OCaml 4.02 while Reason's on 4.04; so the #if macros
  surround the pieces of code that are different between the two compilers.

  When you modify this file, please make sure you're not dragging in too many
  things. You don't necessarily have to test the file on both Reason and
  BuckleScript; ping @chenglou and a few others and we'll keep them synced up by
  patching the right parts, through the power of types(tm)
*)



open Format
open Outcometree

exception Ellipsis

let cautious f ppf arg =
  try f ppf arg with
    Ellipsis -> fprintf ppf "..."

let rec print_ident ppf =
  function
    Oide_ident s -> pp_print_string ppf s
  | Oide_dot (id, s) ->
      print_ident ppf id; pp_print_char ppf '.'; pp_print_string ppf s
  | Oide_apply (id1, id2) ->
      fprintf ppf "%a(%a)" print_ident id1 print_ident id2

let parenthesized_ident name =
  (List.mem name ["or"; "mod"; "land"; "lor"; "lxor"; "lsl"; "lsr"; "asr"])
  ||
  (match name.[0] with
      'a'..'z' | 'A'..'Z' | '\223'..'\246' | '\248'..'\255' | '_' ->
        false
    | _ -> true)

let value_ident ppf name =
  if parenthesized_ident name then
    fprintf ppf "( %s )" name
  else
    pp_print_string ppf name

(* Values *)

let valid_float_lexeme s =
  let l = String.length s in
  let rec loop i =
    if i >= l then s ^ "." else
    match s.[i] with
    | '0' .. '9' | '-' -> loop (i+1)
    | _ -> s
  in loop 0

let float_repres f =
  match classify_float f with
    FP_nan -> "nan"
  | FP_infinite ->
      if f < 0.0 then "neg_infinity" else "infinity"
  | _ ->
      let float_val =
        let s1 = Printf.sprintf "%.12g" f in
        if f = float_of_string s1 then s1 else
        let s2 = Printf.sprintf "%.15g" f in
        if f = float_of_string s2 then s2 else
        Printf.sprintf "%.18g" f
      in valid_float_lexeme float_val

let parenthesize_if_neg ppf fmt v isneg =
  if isneg then pp_print_char ppf '(';
  fprintf ppf fmt v;
  if isneg then pp_print_char ppf ')'

let print_out_value ppf tree =
  let rec print_tree_1 wrap ppf =
    function
    | Oval_constr (name, [param]) ->
        if wrap then
          fprintf ppf "@[<1>(%a@ %a)@]" print_ident name print_constr_param param
        else
          fprintf ppf "@[<1>%a@ %a@]" print_ident name print_constr_param param
    | Oval_constr (name, (_ :: _ as params)) ->
        if wrap then
          fprintf ppf "@[<1>(%a@ %a)@]" print_ident name
            (print_tree_list (print_tree_1 true) "") params
        else
          fprintf ppf "@[<1>%a@ %a@]" print_ident name
            (print_tree_list (print_tree_1 true) "") params
    | Oval_variant (name, Some param) ->
        if wrap then
          fprintf ppf "@[<2>(`%s@ %a)@]" name print_constr_param param
        else
          fprintf ppf "@[<2>`%s@ %a@]" name print_constr_param param
    | tree -> print_simple_tree ppf tree
  and print_constr_param ppf = function
    | Oval_int i -> parenthesize_if_neg ppf "%i" i (i < 0)
    | Oval_int32 i -> parenthesize_if_neg ppf "%lil" i (i < 0l)
    | Oval_int64 i -> parenthesize_if_neg ppf "%LiL" i (i < 0L)
    | Oval_nativeint i -> parenthesize_if_neg ppf "%nin" i (i < 0n)
    | Oval_float f -> parenthesize_if_neg ppf "%s" (float_repres f) (f < 0.0)
    | tree -> print_simple_tree ppf tree
  and print_simple_tree ppf =
    function
      Oval_int i -> fprintf ppf "%i" i
    | Oval_int32 i -> fprintf ppf "%lil" i
    | Oval_int64 i -> fprintf ppf "%LiL" i
    | Oval_nativeint i -> fprintf ppf "%nin" i
    | Oval_float f -> pp_print_string ppf (float_repres f)
    | Oval_char c -> fprintf ppf "%C" c
    | Oval_string s ->
        begin try fprintf ppf "%S" s with
          Invalid_argument "String.create" -> fprintf ppf "<huge string>"
        end
    | Oval_list tl ->
        fprintf ppf "@[<1>[%a]@]" (print_tree_list (print_tree_1 false) ",") tl
    | Oval_array tl ->
        fprintf ppf "@[<2>[|%a|]@]" (print_tree_list (print_tree_1 false) ",") tl
    | Oval_constr (name, []) -> print_ident ppf name
    | Oval_variant (name, None) -> fprintf ppf "`%s" name
    | Oval_stuff s -> pp_print_string ppf s
    | Oval_record fel ->
        fprintf ppf "@[<1>{%a}@]" (cautious (print_fields true)) fel
    | Oval_ellipsis -> raise Ellipsis
    | Oval_printer f -> f ppf
    | Oval_tuple tree_list ->
        fprintf ppf "@[<1>(%a)@]" (print_tree_list (print_tree_1 false) ",") tree_list
    | tree -> fprintf ppf "@[<1>(%a)@]" (cautious (print_tree_1 false)) tree
  and print_fields first ppf =
    function
      [] -> ()
    | (name, tree) :: fields ->
        if not first then fprintf ppf ",@ ";
        fprintf ppf "@[<1>%a@ :@ %a@]" print_ident name (cautious (print_tree_1 false))
          tree;
        print_fields false ppf fields
  and print_tree_list print_item sep ppf tree_list =
    let rec print_list first ppf =
      function
        [] -> ()
      | tree :: tree_list ->
          if not first then fprintf ppf "%s@ " sep;
          print_item ppf tree;
          print_list false ppf tree_list
    in
    cautious (print_list true) ppf tree_list
  in
  cautious (print_tree_1 false) ppf tree

(* Types *)

let rec print_list_init pr sep ppf =
  function
    [] -> ()
  | a :: l -> sep ppf; pr ppf a; print_list_init pr sep ppf l

let rec print_list pr sep ppf =
  function
    [] -> ()
  | [a] -> pr ppf a
  | a :: l -> pr ppf a; sep ppf; print_list pr sep ppf l

let pr_present =
  print_list (fun ppf s -> fprintf ppf "`%s" s) (fun ppf -> fprintf ppf "@ ")

let pr_vars =
  print_list (fun ppf s -> fprintf ppf "'%s" s) (fun ppf -> fprintf ppf "@ ")

type label =
  | Nonlabeled
  | Labeled of string
  | Optional of string

let get_label lbl =
  if lbl = "" then Nonlabeled
  else if String.get lbl 0 = '?' then
    Optional (String.sub lbl 1 @@ String.length lbl - 1)
  else Labeled lbl

let rec print_out_type ppf =
  function
  | Otyp_alias (ty, s) ->
      fprintf ppf "@[%a@ as '%s@]" print_out_type ty s
  | Otyp_poly (sl, ty) ->
      fprintf ppf "@[<hov 2>%a.@ %a@]"
        pr_vars sl
        print_out_type ty
  | ty ->
      print_out_type_1 ppf ty

and print_out_type_1 ppf =
  function
    Otyp_arrow (lab, ty1, ty2) ->
      pp_open_box ppf 0;
      let suffix =
        match get_label lab with
        | Nonlabeled -> ""
        | Labeled lab ->
            pp_print_string ppf lab;
            pp_print_string ppf "::";
            ""
        | Optional lab ->
            pp_print_string ppf lab;
            pp_print_string ppf "::";
            "?"
      in
      print_out_type_2 ppf ty1;
      pp_print_string ppf suffix;
      pp_print_string ppf " =>";
      pp_print_space ppf ();
      print_out_type_1 ppf ty2;
      pp_close_box ppf ()
  | ty -> print_out_type_2 ppf ty
and print_out_type_2 ppf =
  function
    Otyp_tuple tyl ->
      fprintf ppf "@[<0>(%a)@]" (print_typlist print_simple_out_type ",") tyl
  | ty -> print_simple_out_type ppf ty
and print_simple_out_type ppf =
  function
    Otyp_class (ng, id, tyl) ->
      fprintf ppf "@[%s#%a%a@]" (if ng then "_" else "")
        print_ident id print_typargs tyl
  | Otyp_constr (id, tyl) ->
      pp_open_box ppf 0;
      print_ident ppf id;
      print_typargs ppf tyl;
      pp_close_box ppf ()
  | Otyp_object (fields, rest) ->
    let dot = match rest with
      Some non_gen -> (if non_gen then "_" else "") ^ ".."
    | None -> "."
    in
    fprintf ppf "@[<2>{%s %a }@]" dot print_object_fields fields
  | Otyp_stuff s -> pp_print_string ppf s
  | Otyp_var (ng, s) -> fprintf ppf "'%s%s" (if ng then "_" else "") s
  | Otyp_variant (non_gen, row_fields, closed, tags) ->
      let print_present ppf =
        function
          None | Some [] -> ()
        | Some l -> fprintf ppf "@;<1 -2>> @[<hov>%a@]" pr_present l
      in
      let print_fields ppf =
        function
          Ovar_fields fields ->
            print_list print_row_field (fun ppf -> fprintf ppf "@;<1 -2>| ")
              ppf fields
        | Ovar_name (id, tyl) ->
            fprintf ppf "@[%a%a@]" print_typargs tyl print_ident id
      in
      fprintf ppf "%s[%s@[<hv>@[<hv>%a@]%a ]@]" (if non_gen then "_" else "")
        (if closed then if tags = None then " " else "< "
         else if tags = None then "> " else "? ")
        print_fields row_fields
        print_present tags
  | Otyp_tuple _ as ty ->
      pp_open_box ppf 1;
      print_out_type ppf ty;
      pp_close_box ppf ()
  | Otyp_alias _ | Otyp_poly _ | Otyp_arrow _ as ty ->
      pp_open_box ppf 1;
      pp_print_char ppf '(';
      print_out_type ppf ty;
      pp_print_char ppf ')';
      pp_close_box ppf ()
  | Otyp_abstract | Otyp_open
  | Otyp_sum _ | Otyp_record _ | Otyp_manifest (_, _) -> ()
  | Otyp_module (p, n, tyl) ->
      fprintf ppf "@[<1>(module %s" p;
      let first = ref true in
      List.iter2
        (fun s t ->
          let sep = if !first then (first := false; "with") else "and" in
          fprintf ppf " %s type %s = %a" sep s print_out_type t
        )
        n tyl;
      fprintf ppf ")@]"


and print_object_fields ppf =
  function
    [] -> ()
  | [s, t] ->
    fprintf ppf "%s : %a" s print_out_type t;
    print_object_fields ppf []
  | (s, t) :: l ->
    fprintf ppf "%s : %a,@ %a" s print_out_type t print_object_fields l
and print_row_field ppf (l, opt_amp, tyl) =
  let pr_of ppf =
    if opt_amp then fprintf ppf " &@ "
    else if tyl <> [] then fprintf ppf " "
    else fprintf ppf ""
  in
  fprintf ppf "@[<hv 2>`%s%t%a@]" l pr_of (print_typlist print_out_type " &")
    tyl
and print_typlist print_elem sep ppf =
  function
    [] -> ()
  | [ty] -> print_elem ppf ty
  | ty :: tyl ->
      print_elem ppf ty;
      pp_print_string ppf sep;
      pp_print_space ppf ();
      print_typlist print_elem sep ppf tyl
and print_out_wrap_type ppf =
  function
  | (Otyp_constr (id, _::_)) as ty ->
      fprintf ppf "@[<0>(%a)@]" print_out_type ty
  | ty -> print_simple_out_type ppf ty
and print_typargs ppf =
  function
    [] -> ()
  | [ty1] -> pp_print_space ppf (); print_out_wrap_type ppf ty1
  | tyl ->
      pp_print_space ppf ();
      pp_open_box ppf 1;
      print_typlist print_out_wrap_type "" ppf tyl;
      pp_close_box ppf ()

let out_type = ref print_out_type

(* Class types *)

let type_parameter ppf (ty, (co, cn)) =
  fprintf ppf "%s%s"
    (if not cn then "+" else if not co then "-" else "")
    (if ty = "_" then ty else "'"^ty)

let print_out_class_params ppf =
  function
    [] -> ()
  | tyl ->
      fprintf ppf "@[<1>%a@]@ "
        (print_list type_parameter (fun ppf -> fprintf ppf " "))
        tyl

let rec print_out_class_type ppf =
  function
    Octy_constr (id, tyl) ->
      let pr_tyl ppf =
        function
          [] -> ()
        | tyl ->
            fprintf ppf "@[<1> %a@]" (print_typlist print_out_wrap_type "") tyl
      in
      fprintf ppf "@[%a%a@]" print_ident id pr_tyl tyl
  | Octy_arrow (lab, ty, cty) ->
      fprintf ppf "@[%s%a =>@ %a@]" (if lab <> "" then lab ^ ":" else "")
        print_out_type_2 ty print_out_class_type cty
  | Octy_signature (self_ty, csil) ->
      let pr_param ppf =
        function
          Some ty -> fprintf ppf "@ @[(%a)@]" print_out_type ty
        | None -> ()
      in
      fprintf ppf "@[<hv 2>@[<2>{%a@]@ %a@;<1 -2>}@]" pr_param self_ty
        (print_list print_out_class_sig_item (fun ppf -> fprintf ppf ";@ "))
        csil
and print_out_class_sig_item ppf =
  function
    Ocsg_constraint (ty1, ty2) ->
      fprintf ppf "@[<2>as %a =@ %a@]" print_out_type ty1
        print_out_type ty2
  | Ocsg_method (name, priv, virt, ty) ->
      fprintf ppf "@[<2>%s%s%s :@ %a@]"
        (if priv then "pri " else "pub ") (if virt then "virtual " else "")
        name print_out_type ty
  | Ocsg_value (name, mut, vr, ty) ->
      fprintf ppf "@[<2>val %s%s%s :@ %a@]"
        (if mut then "mutable " else "")
        (if vr then "virtual " else "")
        name print_out_type ty

(* Signature *)

let is_rec_next = function
  | Osig_class (_, _, _, _, Orec_next)::_
  | Osig_class_type (_, _, _, _, Orec_next)::_
  | Osig_module (_, _, Orec_next)::_
  | Osig_type (_, Orec_next)::_ -> true
  | _ -> false

let rec print_out_functor ppf =
  function
    Omty_functor (_, None, mty_res) ->
      fprintf ppf "() %a" print_out_functor mty_res
  | Omty_functor (name , Some mty_arg, mty_res) ->
      fprintf ppf "(%s : %a) => %a" name
        print_out_module_type mty_arg print_out_functor mty_res
  | m -> fprintf ppf "%a" print_out_module_type m
and print_out_module_type ppf =
  function
    Omty_abstract -> ()
  | Omty_functor _ as t ->
      fprintf ppf "@[<2>%a@]" print_out_functor t
  | Omty_ident id -> fprintf ppf "%a" print_ident id
  | Omty_signature sg ->
      fprintf ppf "@[<hv 2>{@ %a@;<1 -2>}@]" print_out_signature sg
  | Omty_alias id -> fprintf ppf "(module %a)" print_ident id
and print_out_signature ppf =
  function
    [] -> ()
  | [item] ->
      fprintf ppf "%a;" print_out_sig_item item
  | Osig_typext(ext, Oext_first) :: items ->
      (* Gather together the extension constructors *)
      let rec gather_extensions acc items =
        match items with
            Osig_typext(ext, Oext_next) :: items ->
              gather_extensions
                ((ext.oext_name, ext.oext_args, ext.oext_ret_type) :: acc)
                items
          | _ -> (List.rev acc, items)
      in
      let exts, items =
        gather_extensions
          [(ext.oext_name, ext.oext_args, ext.oext_ret_type)]
          items
      in
      let te =
        { otyext_name = ext.oext_type_name;
          otyext_params = ext.oext_type_params;
          otyext_constructors = exts;
          otyext_private = ext.oext_private }
      in
      let sep = if is_rec_next items then "" else ";" in
      fprintf ppf "%a%s@ %a" print_out_type_extension te sep print_out_signature items
  | item :: items ->
      let sep = if is_rec_next items then "" else ";" in
      fprintf ppf "%a%s@ %a" print_out_sig_item item sep print_out_signature items
and print_out_sig_item ppf =
  function
    Osig_class (vir_flag, name, params, clt, rs) ->
      fprintf ppf "@[<2>%s%s@ %s %a@,:@ %a@]"
        (if rs = Orec_next then "and" else "class")
        (if vir_flag then " virtual" else "") name print_out_class_params params
        print_out_class_type clt
  | Osig_class_type (vir_flag, name, params, clt, rs) ->
      fprintf ppf "@[<2>%s%s@ %s %a@,=@ %a@]"
        (if rs = Orec_next then "and" else "class type")
        (if vir_flag then " virtual" else "") name print_out_class_params params
        print_out_class_type clt
  | Osig_typext (ext, Oext_exception) ->
      fprintf ppf "@[<2>exception %a@]"
        print_out_constr (ext.oext_name, ext.oext_args, ext.oext_ret_type)
  | Osig_typext (ext, es) ->
      print_out_extension_constructor ppf ext
  | Osig_modtype (name, Omty_abstract) ->
      fprintf ppf "@[<2>module type %s@]" name
  | Osig_modtype (name, mty) ->
      fprintf ppf "@[<2>module type %s =@ %a@]" name print_out_module_type mty
  | Osig_module (name, Omty_alias id, _) ->
      fprintf ppf "@[<2>module %s =@ %a@]" name print_ident id
  | Osig_module (name, mty, rs) ->
      fprintf ppf "@[<2>%s %s :@ %a@]"
        (match rs with Orec_not -> "module"
                    | Orec_first -> "module rec"
                    | Orec_next -> "and")
        name print_out_module_type mty
  | Osig_type(td, rs) ->
      print_out_type_decl
        (match rs with
          | Orec_not   -> "type nonrec"
          | Orec_first -> "type"
          | Orec_next  -> "and")
        ppf td

  | Osig_value(oval_name, oval_type, oval_prims) ->

    let kwd = if oval_prims = [] then "let" else "external" in
    let pr_prims ppf =
      function
        [] -> ()
      | s :: sl ->
          fprintf ppf "@ = \"%s\"" s;
          List.iter (fun s -> fprintf ppf "@ \"%s\"" s) sl
    in

    fprintf ppf "@[<2>%s %a :@ %a%a@]" kwd value_ident oval_name
        !out_type oval_type pr_prims oval_prims


and print_out_type_decl kwd ppf td =
  let print_constraints ppf =
    List.iter
      (fun (ty1, ty2) ->
         fprintf ppf "@ @[<2>constraint %a =@ %a@]" print_out_type ty1
           print_out_type ty2)
      td.otype_cstrs
  in
  let type_defined ppf =
    match td.otype_params with
      [] -> pp_print_string ppf td.otype_name
    | [param] -> fprintf ppf "@[%s@ %a@]" td.otype_name type_parameter param
    | _ ->
        fprintf ppf "@[%s@ @[%a@]@]"
          td.otype_name
          (print_list type_parameter (fun ppf -> fprintf ppf "@ "))
          td.otype_params
  in
  let print_manifest ppf =
    function
      Otyp_manifest (ty, _) -> fprintf ppf " =@ %a" print_out_type ty
    | _ -> ()
  in
  let print_name_params ppf =
    fprintf ppf "%s %t%a" kwd type_defined print_manifest td.otype_type
  in
  let ty =
    match td.otype_type with
      Otyp_manifest (_, ty) -> ty
    | _ -> td.otype_type
  in
  let print_private ppf = function
    Asttypes.Private -> fprintf ppf " pri"
  | Asttypes.Public -> ()
  in
  let print_out_tkind ppf = function
  | Otyp_abstract -> ()
  | Otyp_record lbls ->
      fprintf ppf " =%a {%a@;<1 -2>}"
        print_private td.otype_private
        (print_list_init print_out_label (fun ppf -> fprintf ppf "@ ")) lbls
  | Otyp_sum constrs ->
      fprintf ppf " =%a@;<1 2>%a"
        print_private td.otype_private
        (print_list print_out_constr (fun ppf -> fprintf ppf "@ | ")) constrs
  | Otyp_open ->
      fprintf ppf " = .."
  | ty ->
      fprintf ppf " =%a@;<1 2>%a"
        print_private td.otype_private
        print_out_type ty
  in
  fprintf ppf "@[<2>@[<hv 2>%t%a@]%t@]"
    print_name_params
    print_out_tkind ty
    print_constraints

and print_out_constr ppf (name, tyl,ret_type_opt) =
  match ret_type_opt with
  | None ->
      begin match tyl with
      | [] ->
          pp_print_string ppf name
      | _ ->
          fprintf ppf "@[<2>%s %a@]" name
            (print_typlist print_simple_out_type "") tyl
      end
  | Some ret_type ->
      begin match tyl with
      | [] ->
          fprintf ppf "@[<2>%s :@ %a@]" name print_simple_out_type ret_type
      | _ ->
          fprintf ppf "@[<2>%s %a :%a@]" name
            (print_typlist print_simple_out_type "") tyl
            print_simple_out_type ret_type
      end


and print_out_label ppf (name, mut, arg) =
  fprintf ppf "@[<2>%s%s :@ %a@]," (if mut then "mutable " else "") name
    print_out_type arg

and print_out_extension_constructor ppf ext =
  let print_extended_type ppf =
    let print_type_parameter ppf ty =
      fprintf ppf "%s"
        (if ty = "_" then ty else "'"^ty)
    in
      match ext.oext_type_params with
        [] -> fprintf ppf "%s" ext.oext_type_name
      | [ty_param] ->
        fprintf ppf "@[%a@ %s@]"
          print_type_parameter
          ty_param
          ext.oext_type_name
      | _ ->
        fprintf ppf "@[(@[%a)@]@ %s@]"
          (print_list print_type_parameter (fun ppf -> fprintf ppf ",@ "))
          ext.oext_type_params
          ext.oext_type_name
  in
  fprintf ppf "@[<hv 2>type %t +=%s@;<1 2>%a@]"
    print_extended_type
    (if ext.oext_private = Asttypes.Private then " pri" else "")
    print_out_constr (ext.oext_name, ext.oext_args, ext.oext_ret_type)

and print_out_type_extension ppf te =
  let print_extended_type ppf =
    let print_type_parameter ppf ty =
      fprintf ppf "%s"
        (if ty = "_" then ty else "'"^ty)
    in
    match te.otyext_params with
      [] -> fprintf ppf "%s" te.otyext_name
    | [param] ->
      fprintf ppf "@[%a@ %s@]"
        print_type_parameter param
        te.otyext_name
    | _ ->
        fprintf ppf "@[(@[%a)@]@ %s@]"
          (print_list print_type_parameter (fun ppf -> fprintf ppf ",@ "))
          te.otyext_params
          te.otyext_name
  in
  fprintf ppf "@[<hv 2>type %t +=%s@;<1 2>%a@]"
    print_extended_type
    (if te.otyext_private = Asttypes.Private then " pri" else "")
    (print_list print_out_constr (fun ppf -> fprintf ppf "@ | "))
    te.otyext_constructors

(* Phrases *)

let print_out_exception ppf exn outv =
  match exn with
    Sys.Break -> fprintf ppf "Interrupted.@."
  | Out_of_memory -> fprintf ppf "Out of memory during evaluation.@."
  | Stack_overflow ->
      fprintf ppf "Stack overflow during evaluation (looping recursion?).@."
  | _ -> fprintf ppf "@[Exception:@ %a.@]@." print_out_value outv

let rec print_items ppf =
  function
    [] -> ()
  | (Osig_typext(ext, Oext_first), None) :: items ->
      (* Gather together extension constructors *)
      let rec gather_extensions acc items =
        match items with
            (Osig_typext(ext, Oext_next), None) :: items ->
              gather_extensions
                ((ext.oext_name, ext.oext_args, ext.oext_ret_type) :: acc)
                items
          | _ -> (List.rev acc, items)
      in
      let exts, items =
        gather_extensions
          [(ext.oext_name, ext.oext_args, ext.oext_ret_type)]
          items
      in
      let te =
        { otyext_name = ext.oext_type_name;
          otyext_params = ext.oext_type_params;
          otyext_constructors = exts;
          otyext_private = ext.oext_private }
      in
        fprintf ppf "@[%a@]" print_out_type_extension te;
        if items <> [] then fprintf ppf "@ %a" print_items items
  | (tree, valopt) :: items ->
      begin match valopt with
        Some v ->
          fprintf ppf "@[<2>%a =@ %a@]" print_out_sig_item tree
            print_out_value v
      | None -> fprintf ppf "@[%a@]" print_out_sig_item tree
      end;
      if items <> [] then fprintf ppf "@ %a" print_items items

let print_out_phrase ppf =
  function
    Ophr_eval (outv, ty) ->
      fprintf ppf "@[- : %a@ =@ %a@]@." print_out_type ty print_out_value outv
  | Ophr_signature [] -> ()
  | Ophr_signature items -> fprintf ppf "@[<v>%a@]@." print_items items
  | Ophr_exception (exn, outv) -> print_out_exception ppf exn outv

end
module Reason_outcome_printer_main
= struct
#1 "reason_outcome_printer_main.ml"
(* This is used by js_main.ml *)
let setup () =
  Oprint.out_value := Tweaked_reason_oprint.print_out_value;
  Oprint.out_type := Tweaked_reason_oprint.print_out_type;
  Oprint.out_class_type := Tweaked_reason_oprint.print_out_class_type;
  Oprint.out_module_type := Tweaked_reason_oprint.print_out_module_type;
  Oprint.out_sig_item := Tweaked_reason_oprint.print_out_sig_item;
  Oprint.out_signature := Tweaked_reason_oprint.print_out_signature;
  Oprint.out_type_extension := Tweaked_reason_oprint.print_out_type_extension;
  Oprint.out_phrase := Tweaked_reason_oprint.print_out_phrase

end
module Super_misc : sig 
#1 "super_misc.mli"
(** Range coordinates all 1-indexed, like for editors. Otherwise this code
  would have way too many off-by-one errors *)
val print_file: is_warning:bool -> range:(int * int) * (int * int) -> lines:string array -> Format.formatter -> unit -> unit

end = struct
#1 "super_misc.ml"
(* This file has nothing to do with misc.ml in ocaml's source. Just thought it'd be an appropriate parallel to call it so *)

let fprintf = Format.fprintf

let string_slice ~start str =
  let last = String.length str in
  if last <= start then "" else String.sub str start (last - start)

let sp = Printf.sprintf

let number_of_digits n =
  let digits = ref 1 in
  let nn = ref n in
  while ((!nn) / 10) > 0 do (nn := ((!nn) / 10); digits := ((!digits) + 1))
    done;
  !digits

let pad ?(ch=' ') content n =
  (String.make (n - (String.length content)) ch) ^ content

let leading_space_count str =
  let rec _leading_space_count str str_length current_index =
    if current_index == str_length then current_index
    else if (str.[current_index]) <> ' ' then current_index 
    else _leading_space_count str str_length (current_index + 1)
  in
  _leading_space_count str (String.length str) 0

type current_printed_line_status = 
  | Is_error_start_line
  | Is_error_end_line
  | Strictly_between_start_and_end
  | Only_error_line
  | Not_error_line

(* Range coordinates all 1-indexed, like for editors. Otherwise this code
  would have way too many off-by-one errors *)
let print_file 
~is_warning 
(* start_line_start_char inclusive, end_line_end_char exclusive *)
~range:((start_line, start_line_start_char), (end_line, end_line_end_char)) 
~lines
ppf 
() =
  (* show 2 lines before & after the erroring lines. if there are too many lines, trim the middle *)
  let first_shown_line = max 1 (start_line - 2) in
  let last_shown_line = min (Array.length lines) (end_line + 2) in
  let max_line_number_number_of_digits = number_of_digits last_shown_line in
  (* sometimes the code's very indented, and we'd end up displaying quite a
    few columsn of leading whitespace; left-trim these. The general spirit is
    to center the erroring spot. In this case, almost literally *)
  (* to achieve this, go through the shown lines and check the minimum number of leading whitespaces *)
  let columns_to_cut = ref None in
  for i = first_shown_line to last_shown_line do
    let current_line = lines.(i - 1) in
    (* disregard lines that are empty or are nothing but whitespace *)
    if String.length (String.trim current_line) == 0 then ()
    else
      let current_line_leading_space_count = leading_space_count current_line in
      match !columns_to_cut with
      | None ->
        columns_to_cut := Some current_line_leading_space_count
      | Some n when n > current_line_leading_space_count ->
        columns_to_cut := Some current_line_leading_space_count
      | Some n -> ()
  done;
  let columns_to_cut = match !columns_to_cut with
  | None -> 0
  | Some n -> n
  in
  (* coloring *)
  let highlighted_line_number : _ format = if is_warning then "@{<info>%s@}%a" else "@{<error>%s@}%a" in

  let print_char_maybe_highlight ~begin_highlight_line ~end_highlight_line ch =
    let highlighted_open_tag: _ format = if is_warning then "@{<info>" else "@{<error>" in
    if begin_highlight_line then fprintf ppf highlighted_open_tag;
    fprintf ppf "%c@," ch;
    if end_highlight_line then fprintf ppf "@}"
  in

  let print_separator ppf () = 
    (* these are unicode chars. They're not of length 1. Careful; we need to
      explicitly tell Format to treat them as length 1 *)
    if columns_to_cut = 0 then fprintf ppf " @{<dim>@<1>@} "
    else fprintf ppf " @{<dim>@<1>@} "
  in

  fprintf ppf "@[<v 0>";
  (* inclusive *)
  for i = first_shown_line to last_shown_line do
    (* should some lines be ellipsed from the output? If we're showing more than 5 lines, then yes *)
    if end_line - start_line >= 5 && i >= start_line + 2 && i <= end_line - 2 then begin
      if i = start_line + 2 then
        (* Insert one line that's just a dimmed "..." *)
        let padded_line_number = pad "." max_line_number_number_of_digits in
        fprintf ppf "@{<dim>%s@}%a@{<dim>...@}@," padded_line_number print_separator ()
      end
    else
      let current_line = lines.(i - 1) in
      let padded_line_number = pad (string_of_int i) max_line_number_number_of_digits in

      fprintf ppf "@[<h 0>";

      fprintf ppf "@[<h 0>";

      if i < start_line || i > end_line then begin
        (* normal, non-highlighted line *)
        fprintf ppf "%s%a" padded_line_number print_separator ()
      end else begin
        (* highlighted *)
        fprintf ppf highlighted_line_number padded_line_number print_separator ()
      end;

      fprintf ppf "@]"; (* h *)

      fprintf ppf "@[<hov 0>";

      let current_line_status = 
        if i > start_line && i < end_line then Strictly_between_start_and_end
        else if i = start_line && i = end_line then Only_error_line
        else if i = start_line then Is_error_start_line
        else if i = end_line then Is_error_end_line
        else Not_error_line
      in
      let offset_current_line = current_line |> string_slice ~start:columns_to_cut in
      let offset_current_line_length = String.length offset_current_line in
      let offset_start_line_start_char = start_line_start_char - columns_to_cut in
      (* end_line_end_char is exclusive *)
      let offset_end_line_end_char = end_line_end_char - columns_to_cut in
      (* inclusive. To be consistent with using 1-indexed indices and count and i, j will be 1-indexed too *)
      for j = 1 to offset_current_line_length do
        let current_char = offset_current_line.[j - 1] in
        match current_line_status with
        | Strictly_between_start_and_end -> 
          print_char_maybe_highlight 
            ~begin_highlight_line:(j = 1) 
            ~end_highlight_line:(j = offset_current_line_length)
            current_char 
        | Only_error_line ->
          print_char_maybe_highlight 
            ~begin_highlight_line:(j = offset_start_line_start_char) 
            ~end_highlight_line:(j = offset_end_line_end_char)
            current_char 
        | Is_error_start_line ->
          print_char_maybe_highlight 
            ~begin_highlight_line:(j = offset_start_line_start_char) 
            ~end_highlight_line:(j = offset_current_line_length)
            current_char 
        | Is_error_end_line ->
          print_char_maybe_highlight 
            ~begin_highlight_line:(j = 1) 
            ~end_highlight_line:(j = offset_end_line_end_char)
            current_char 
        | Not_error_line ->
          print_char_maybe_highlight 
            ~begin_highlight_line:false 
            ~end_highlight_line:false
            current_char 
    done;

    fprintf ppf "@]"; (* hov *)

    fprintf ppf "@]@," (* h *)

  done;
  fprintf ppf "@]" (* v *)

end
module Super_warnings
= struct
#1 "super_warnings.ml"
let fprintf = Format.fprintf
(* taken from https://github.com/BuckleScript/ocaml/blob/d4144647d1bf9bc7dc3aadc24c25a7efa3a67915/utils/warnings.ml#L251 *)
(* actual modified message branches are commented *)
let message = Warnings.(function
  | Comment_start -> "this is the start of a comment."
  | Comment_not_end -> "this is not the end of a comment."
  | Deprecated s -> s ^ " is deprecated. "
  | Fragile_match "" ->
      "this pattern-matching is fragile."
  | Fragile_match s ->
      "this pattern-matching is fragile.\n\
       It will remain exhaustive when constructors are added to type " ^ s ^ "."
  | Partial_application ->
      "this function application is partial,\n\
       maybe some arguments are missing."
  | Labels_omitted ->
      "labels were omitted in the application of this function."
  | Method_override [lab] ->
      "the method " ^ lab ^ " is overridden."
  | Method_override (cname :: slist) ->
      String.concat " "
        ("the following methods are overridden by the class"
         :: cname  :: ":\n " :: slist)
  | Method_override [] -> assert false
  | Partial_match "" ->
      (* modified *)
      "You forgot to handle a possible value here, though we don't have more information on the value."
  | Partial_match s ->
      (* modified *)
      "You forgot to handle a possible value here, for example: \n" ^ s
  | Non_closed_record_pattern s ->
      "the following labels are not bound in this record pattern:\n" ^ s ^
      "\nEither bind these labels explicitly or add '; _' to the pattern."
  | Statement_type ->
      "this expression should have type unit."
  | Unused_match -> "this match case is unused."
  | Unused_pat   -> "this sub-pattern is unused."
  | Instance_variable_override [lab] ->
      "the instance variable " ^ lab ^ " is overridden.\n" ^
      "The behaviour changed in ocaml 3.10 (previous behaviour was hiding.)"
  | Instance_variable_override (cname :: slist) ->
      String.concat " "
        ("the following instance variables are overridden by the class"
         :: cname  :: ":\n " :: slist) ^
      "\nThe behaviour changed in ocaml 3.10 (previous behaviour was hiding.)"
  | Instance_variable_override [] -> assert false
  | Illegal_backslash -> "illegal backslash escape in string."
  | Implicit_public_methods l ->
      "the following private methods were made public implicitly:\n "
      ^ String.concat " " l ^ "."
  | Unerasable_optional_argument ->
      (* modified *)
      (* TODO: better formatting *)
      String.concat "\n\n"
        ["This is an optional argument at the final position of the function; omitting it while calling the function might be confused with currying. For example:";
        "  let myTitle = displayTitle \"hello!\";";
        "if `displayTitle` accepts an optional argument at the final position, it'd be unclear whether `myTitle` is a curried function or the final result.";
        "Here's the language's rule: an optional argument is erased as soon as the 1st positional (i.e. neither labeled nor optional) argument defined after it is passed in.";
        "To solve this, you'd conventionally add an extra () argument at the end of the function declaration."]
  | Undeclared_virtual_method m -> "the virtual method "^m^" is not declared."
  | Not_principal s -> s^" is not principal."
  | Without_principality s -> s^" without principality."
  | Unused_argument -> "this argument will not be used by the function."
  | Nonreturning_statement ->
      "this statement never returns (or has an unsound type.)"
  | Preprocessor s -> s
  | Useless_record_with ->
      "all the fields are explicitly listed in this record:\n\
       the 'with' clause is useless."
  | Bad_module_name (modname) ->
      (* modified *)
      "This file's name is potentially invalid. The build systems conventionally turn a file name into a module name by upper-casing the first letter. " ^ modname ^ " isn't a valid module name.\n" ^
      "Note: some build systems might e.g. turn kebab-case into CamelCase module, which is why this isn't a hard error."
  | All_clauses_guarded ->
      "bad style, all clauses in this pattern-matching are guarded."
  | Unused_var v | Unused_var_strict v -> "unused variable " ^ v ^ "."
  | Wildcard_arg_to_constant_constr ->
     "wildcard pattern given as argument to a constant constructor"
  | Eol_in_string ->
     "unescaped end-of-line in a string constant (non-portable code)"
  | Duplicate_definitions (kind, cname, tc1, tc2) ->
      Printf.sprintf "the %s %s is defined in both types %s and %s."
        kind cname tc1 tc2
  | Multiple_definition(modname, file1, file2) ->
      Printf.sprintf
        "files %s and %s both define a module named %s"
        file1 file2 modname
  | Unused_value_declaration v -> "unused value " ^ v ^ "."
  | Unused_open s -> "unused open " ^ s ^ "."
  | Unused_type_declaration s -> "unused type " ^ s ^ "."
  | Unused_for_index s -> "unused for-loop index " ^ s ^ "."
  | Unused_ancestor s -> "unused ancestor variable " ^ s ^ "."
  | Unused_constructor (s, false, false) -> "unused constructor " ^ s ^ "."
  | Unused_constructor (s, true, _) ->
      "constructor " ^ s ^
      " is never used to build values.\n\
        (However, this constructor appears in patterns.)"
  | Unused_constructor (s, false, true) ->
      "constructor " ^ s ^
      " is never used to build values.\n\
        Its type is exported as a private type."
  | Unused_extension (s, false, false) ->
      "unused extension constructor " ^ s ^ "."
  | Unused_extension (s, true, _) ->
      "extension constructor " ^ s ^
      " is never used to build values.\n\
        (However, this constructor appears in patterns.)"
  | Unused_extension (s, false, true) ->
      "extension constructor " ^ s ^
      " is never used to build values.\n\
        It is exported or rebound as a private extension."
  | Unused_rec_flag ->
      "unused rec flag."
  | Name_out_of_scope (ty, [nm], false) ->
      nm ^ " was selected from type " ^ ty ^
      ".\nIt is not visible in the current scope, and will not \n\
       be selected if the type becomes unknown."
  | Name_out_of_scope (_, _, false) -> assert false
  | Name_out_of_scope (ty, slist, true) ->
      "this record of type "^ ty ^" contains fields that are \n\
       not visible in the current scope: "
      ^ String.concat " " slist ^ ".\n\
       They will not be selected if the type becomes unknown."
  | Ambiguous_name ([s], tl, false) ->
      s ^ " belongs to several types: " ^ String.concat " " tl ^
      "\nThe first one was selected. Please disambiguate if this is wrong."
  | Ambiguous_name (_, _, false) -> assert false
  | Ambiguous_name (slist, tl, true) ->
      "these field labels belong to several types: " ^
      String.concat " " tl ^
      "\nThe first one was selected. Please disambiguate if this is wrong."
  | Disambiguated_name s ->
      "this use of " ^ s ^ " required disambiguation."
  | Nonoptional_label s ->
      "the label " ^ s ^ " is not optional."
  | Open_shadow_identifier (kind, s) ->
      Printf.sprintf
        "this open statement shadows the %s identifier %s (which is later used)"
        kind s
  | Open_shadow_label_constructor (kind, s) ->
      Printf.sprintf
        "this open statement shadows the %s %s (which is later used)"
        kind s
  | Bad_env_variable (var, s) ->
      Printf.sprintf "illegal environment variable %s : %s" var s
  | Attribute_payload (a, s) ->
      Printf.sprintf "illegal payload for attribute '%s'.\n%s" a s
  | Eliminated_optional_arguments sl ->
      Printf.sprintf "implicit elimination of optional argument%s %s"
        (if List.length sl = 1 then "" else "s")
        (String.concat ", " sl)
  | No_cmi_file s ->
      "no cmi file was found in path for module " ^ s
  | Bad_docstring unattached ->
      if unattached then "unattached documentation comment (ignored)"
      else "ambiguous documentation comment"
);;

(* This is lifted as-is from `warnings.ml`. We've only copy-pasted here because warnings.mli doesn't expose this function *)
let number = Warnings.(function
  | Comment_start -> 1
  | Comment_not_end -> 2
  | Deprecated _ -> 3
  | Fragile_match _ -> 4
  | Partial_application -> 5
  | Labels_omitted -> 6
  | Method_override _ -> 7
  | Partial_match _ -> 8
  | Non_closed_record_pattern _ -> 9
  | Statement_type -> 10
  | Unused_match -> 11
  | Unused_pat -> 12
  | Instance_variable_override _ -> 13
  | Illegal_backslash -> 14
  | Implicit_public_methods _ -> 15
  | Unerasable_optional_argument -> 16
  | Undeclared_virtual_method _ -> 17
  | Not_principal _ -> 18
  | Without_principality _ -> 19
  | Unused_argument -> 20
  | Nonreturning_statement -> 21
  | Preprocessor _ -> 22
  | Useless_record_with -> 23
  | Bad_module_name _ -> 24
  | All_clauses_guarded -> 25
  | Unused_var _ -> 26
  | Unused_var_strict _ -> 27
  | Wildcard_arg_to_constant_constr -> 28
  | Eol_in_string -> 29
  | Duplicate_definitions _ -> 30
  | Multiple_definition _ -> 31
  | Unused_value_declaration _ -> 32
  | Unused_open _ -> 33
  | Unused_type_declaration _ -> 34
  | Unused_for_index _ -> 35
  | Unused_ancestor _ -> 36
  | Unused_constructor _ -> 37
  | Unused_extension _ -> 38
  | Unused_rec_flag -> 39
  | Name_out_of_scope _ -> 40
  | Ambiguous_name _ -> 41
  | Disambiguated_name _ -> 42
  | Nonoptional_label _ -> 43
  | Open_shadow_identifier _ -> 44
  | Open_shadow_label_constructor _ -> 45
  | Bad_env_variable _ -> 46
  | Attribute_payload _ -> 47
  | Eliminated_optional_arguments _ -> 48
  | No_cmi_file _ -> 49
  | Bad_docstring _ -> 50
);;

(* taken from https://github.com/BuckleScript/ocaml/blob/d4144647d1bf9bc7dc3aadc24c25a7efa3a67915/utils/warnings.ml#L396 *)
(* the only difference is the 2 first `let`s, where we use our own `message`
  and `number` functions, and the last line commented out because we don't use
  it (not sure what it's for, actually) *)
let print ppf w =
  let msg = message w in
  Format.fprintf ppf "%s" msg;
  Format.pp_print_flush ppf ()
  (*if (!current).error.(num) then incr nerrors*)
;;

end
module Super_location
= struct
#1 "super_location.ml"
open Misc
open Asttypes
open Parsetree
open Types
open Typedtree
open Btype
open Ctype

open Format
open Printtyp

open Location

let file_lines filePath =
  (* open_in_bin works on windows, as opposed to open_in, afaik? *)
  let chan = open_in_bin filePath in
  let lines = ref [] in
  try
    while true do
      lines := (input_line chan) :: !lines
     done;
     (* leave this here to make things type. The loop will definitly raise *)
     [||]
  with
  | End_of_file -> begin
      close_in chan;
      List.rev (!lines) |> Array.of_list
    end

let setup_colors () =
  Misc.Color.setup !Clflags.color

let print_filename ppf file =
  match file with
  (* modified *)
  | "_none_"
  | "" -> Format.fprintf ppf "(No file name)"
  | real_file -> Format.fprintf ppf "%s" (Location.show_filename real_file)

let print_loc ~normalizedRange ppf loc =
  setup_colors ();
  let (file, _, _) = Location.get_pos_info loc.loc_start in
  if file = "//toplevel//" then begin
    if highlight_locations ppf [loc] then () else
      fprintf ppf "Characters %i-%i"
              loc.loc_start.pos_cnum loc.loc_end.pos_cnum
  end else 
    let dim_loc ppf = function
    | None -> ()
    | Some ((start_line, start_line_start_char), (end_line, end_line_end_char)) ->
      if start_line = end_line then 
        if start_line_start_char = end_line_end_char then
          fprintf ppf " @{<dim>%i:%i@}" start_line start_line_start_char
        else
          fprintf ppf " @{<dim>%i:%i-%i@}" start_line start_line_start_char end_line_end_char
      else
        fprintf ppf " @{<dim>%i:%i-%i:%i@}" start_line start_line_start_char end_line end_line_end_char
    in
    fprintf ppf "@{<filename>%a@}%a" print_filename file dim_loc normalizedRange
;;

let print ~is_warning intro ppf loc =
  setup_colors ();
  if loc.loc_start.pos_fname = "//toplevel//"
  && highlight_locations ppf [loc] then ()
  else
    if is_warning then
      fprintf ppf "@[@{<info>%s@}@]@," intro
    else begin
      fprintf ppf "@[@{<error>%s@}@]@," intro
    end;

    (* ocaml's reported line/col numbering is horrible and super error-prone 
      when being handled programmatically (or humanly for that matter. If you're 
      an ocaml contributor reading this: who the heck reads the character count
      starting from the first erroring character?) *)
    let (file, start_line, start_char) = Location.get_pos_info loc.loc_start in
    let (_, end_line, end_char) = Location.get_pos_info loc.loc_end in
    (* line is 1-indexed, column is 0-indexed. We convert all of them to 1-indexed to avoid confusion *)
    (* start_char is inclusive, end_char is exclusive *)
    let normalizedRange = 
      if start_char == -1 || end_char == -1 then
        (* happens sometimes. Syntax error for example *)
        None
      else if start_line = end_line && start_char >= end_char then
        (* in some errors, starting char and ending char can be the same. But
           since ending char was supposed to be exclusive, here it might end up 
           smaller than the starting char if we naively did start_char + 1 to 
           just the starting char and forget ending char *)
        let same_char = start_char + 1 in
        Some ((start_line, same_char), (end_line, same_char))
      else
        (* again: end_char is exclusive, so +1-1=0 *)
        Some ((start_line, start_char + 1), (end_line, end_char))
    in
    fprintf ppf "@[%a@]@," (print_loc ~normalizedRange) loc;
    match normalizedRange with
    | None -> ()
    | Some range -> begin
      try
        let lines = file_lines file in
        (* we're putting the line break `@,` here rather than above, because this
           branch might not be reached (aka no inline file content display) so 
           we don't wanna end up with two line breaks in the the consequent *)
        fprintf ppf "@,%a"
          (Super_misc.print_file ~is_warning ~lines ~range)
          ()
      with
      (* this shouldn't happen, but gracefully fall back to the default reporter just in case *)
      | Sys_error _ -> Location.print ppf loc
    end
;;

(* taken from https://github.com/BuckleScript/ocaml/blob/d4144647d1bf9bc7dc3aadc24c25a7efa3a67915/parsing/location.ml#L380 *)
(* This is the error report entry point. We'll replace the default reporter with this one. *)
let rec super_error_reporter ppf ({Location.loc; msg; sub; if_highlight} as err) =
  let highlighted =
    if if_highlight <> "" then
      let rec collect_locs locs {Location.loc; sub; if_highlight; _} =
        List.fold_left collect_locs (loc :: locs) sub
      in
      let locs = collect_locs [] err in
      Location.highlight_locations ppf locs
    else
      false
  in
  if highlighted then
    Format.pp_print_string ppf if_highlight
  else begin
    (* open a vertical box. Everything in our message is indented 2 spaces *)
    Format.fprintf ppf "@[<v 2>@,%a@,%s@,@]" (print ~is_warning:false "We've found a bug for you!") loc msg;
    List.iter (Format.fprintf ppf "@,@[%a@]" super_error_reporter) sub;
    (* no need to flush here; location's report_exception (which uses this ultimately) flushes *)
  end

(* extracted from https://github.com/BuckleScript/ocaml/blob/d4144647d1bf9bc7dc3aadc24c25a7efa3a67915/parsing/location.ml#L299 *)
(* This is the warning report entry point. We'll replace the default printer with this one *)
let super_warning_printer loc ppf w =
  if Warnings.is_active w then begin
    setup_colors ();
    (* open a vertical box. Everything in our message is indented 2 spaces *)
    Format.fprintf ppf "@[<v 2>@,%a@,%a@,@]"
      (print ~is_warning:true ("Warning number " ^ (Super_warnings.number w |> string_of_int)))
      loc
      Super_warnings.print
      w
  end
;;

(* taken from https://github.com/BuckleScript/ocaml/blob/d4144647d1bf9bc7dc3aadc24c25a7efa3a67915/parsing/location.ml#L354 *)
let print_phanton_error_prefix ppf =
  (* modified from the original. We use only 2 indentations for error report
    (see super_error_reporter above) *)
  Format.pp_print_as ppf 2 ""

let errorf ?(loc = none) ?(sub = []) ?(if_highlight = "") fmt =
  Location.pp_ksprintf
    ~before:print_phanton_error_prefix
    (fun msg -> {loc; msg; sub; if_highlight})
    fmt

let error_of_printer loc print x =
  errorf ~loc "%a@?" print x

let error_of_printer_file print x =
  error_of_printer (in_file !input_name) print x

(* This will be called in super_main. This is how you override the default error and warning printers *)
let setup () =
  Location.error_reporter := super_error_reporter;
  Location.warning_printer := super_warning_printer;

end
module Super_env
= struct
#1 "super_env.ml"
let fprintf = Format.fprintf

(* taken from https://github.com/BuckleScript/ocaml/blob/d4144647d1bf9bc7dc3aadc24c25a7efa3a67915/typing/env.ml#L1842 *)
(* modified branches are commented *)
let report_error ppf = function
  | Env.Illegal_renaming(name, modname, filename) -> 
      (* modified *)
      fprintf ppf
        "@[You referred to the module %s, but we've found one called %s instead.@ \
          Is the name's casing right?@]"
        name modname
  | Inconsistent_import(name, source1, source2) -> 
      (* modified *)
     fprintf ppf "@[<v>\
        @[@{<info>It's possible that your build is stale.@}@ Try to clean the artifacts and build again?@]@,@,\
        @[@{<info>Here's the original error message@}@]@,\
      @]";
      fprintf ppf
        "@[<hov>The files %a@ and %a@ \
              make inconsistent assumptions@ over interface %s@]"
      Location.print_filename source1 Location.print_filename source2 name
  | Need_recursive_types(import, export) ->
      fprintf ppf
        "@[<hov>Unit %s imports from %s, which uses recursive types.@ %s@]"
        export import "The compilation flag -rectypes is required"
  | Missing_module(_, path1, path2) ->
      fprintf ppf "@[@[<hov>";
      if Path.same path1 path2 then
        fprintf ppf "Internal path@ %s@ is dangling." (Path.name path1)
      else
        fprintf ppf "Internal path@ %s@ expands to@ %s@ which is dangling."
          (Path.name path1) (Path.name path2);
      fprintf ppf "@]@ @[%s@ %s@ %s.@]@]"
        "The compiled interface for module" (Ident.name (Path.head path2))
        "was not found"
  | Illegal_value_name(_loc, name) ->
      fprintf ppf "'%s' is not a valid value identifier."
        name

(* This will be called in super_main. This is how you'd override the default error printer from the compiler & register new error_of_exn handlers *)
let setup () =
  Location.register_error_of_exn
    (function
      | Env.Error (Missing_module (loc, _, _)
              | Illegal_value_name (loc, _)
               as err) when loc <> Location.none ->
          Some (Super_location.error_of_printer loc report_error err)
      | Env.Error err -> Some (Super_location.error_of_printer_file report_error err)
      | _ -> None
    )

end
module Super_pparse
= struct
#1 "super_pparse.ml"
let fprintf = Format.fprintf

(* taken from https://github.com/BuckleScript/ocaml/blob/d4144647d1bf9bc7dc3aadc24c25a7efa3a67915/driver/pparse.ml#L170 *)
(* modified branches are commented *)
let report_error ppf = function
  | Pparse.CannotRun cmd ->
    (* modified *)
    if Ext_string.contain_substring cmd "refmt" then
      fprintf ppf 
        "@[<v>@{<info>There's been an error running Reason's refmt parser on a file.@}@,\
          This was the command:@,@,%s@,@,\
          @[Please file an issue on@ github.com/facebook/reason.@ Thanks!@]@]" cmd
    else 
      fprintf ppf "@[<v>@{<info>There's been an error running a preprocessor before the compilation of a file.@}@,\
                   This was the command:@,@,%s@]" cmd
  | WrongMagic cmd ->
      fprintf ppf "External preprocessor does not produce a valid file@.\
                   Command line: %s@." cmd

let setup () =
  Location.register_error_of_exn
    (function
      | Pparse.Error err -> Some (Super_location.error_of_printer_file report_error err)
      | _ -> None
    )

end
module Super_reason_react : sig 
#1 "super_reason_react.mli"
val type_is_component_spec: Types.type_expr -> bool
(** Used by super_typemod when we detect the message "... contains type variables that cannot be generalized" *)

val module_type_is_component_spec: Types.module_type -> bool
(** Used by super_typemod when we detect the message "... contains type variables that cannot be generalized" *)

val state_escape_scope: (Types.type_expr * Types.type_expr) list -> bool
(** Used by super_typecore when we detect the message "The type constructor state would escape its scope" *)

val is_array_wanted_reactElement: (Types.type_expr * Types.type_expr) list -> bool
(** Used by super_typecore when we detect the message "The type constructor state would escape its scope" *)

end = struct
#1 "super_reason_react.ml"
(* This file detects common error from
  [ReasonReact](https://reasonml.github.io/reason-react/) and provide
  situation-specific hints. See the mli file to see which heurisics we detect
  and related comments *)
open Types

let rec deconstruct_component_type t =
  match t.desc with
  | Tconstr (p, types, _) when Path.last p = "componentSpec" -> Some types
  | Tlink t
  | Tsubst t -> deconstruct_component_type t
  | _ -> None

let type_is_component_spec t =
  deconstruct_component_type t <> None

let sig_item_is_component_spec (si: Types.signature_item) = match si with
  | Sig_value (_id, value_desc) ->
      let typ = value_desc.val_type in
      type_is_component_spec typ
  | _ ->
      false

let module_type_is_component_spec (mty : Types.module_type) = match mty with
  | Mty_signature sg ->
      List.exists sig_item_is_component_spec sg
  |  _ ->
      false


(* recursively drill down the types (first item is the type alias, if any. Second is the content of the alias) *)
let rec get_to_bottom_of_aliases f = function
  | (_alias1, type1) :: (_alias2, type2) :: rest ->
    begin match get_to_bottom_of_aliases f rest with
    | false -> f (type1, type2)
    | true -> true
    end
  | _ -> false

let state_escape_scope = get_to_bottom_of_aliases (function
  (* https://github.com/BuckleScript/ocaml/blob/ddf5a739cc0978dab5e553443825791ba7b0cef9/typing/printtyp.ml?#L1348 *)
  (* so apparently that's the logic for detecting "the constructor out of scope" error *)
  | ({desc = Tconstr (p, _, _)}, {desc = Tvar _; level}) 
    when level < Path.binding_time p -> true
  | _ -> false
)

let is_array_wanted_reactElement = get_to_bottom_of_aliases (function
  | ({desc = Tconstr (path1, _, _)}, {desc = Tconstr (path2, _, _)}) 
    when Path.last path1 = "array" && Path.last path2 = "reactElement" -> true
  | _ -> false
)

end
module Super_typecore
= struct
#1 "super_typecore.ml"
open Misc
open Asttypes
open Parsetree
open Types
open Typedtree
open Btype
open Ctype

let fprintf = Format.fprintf
let sprintf = Format.sprintf
let longident = Printtyp.longident
let super_report_unification_error = Printtyp.super_report_unification_error
let reset_and_mark_loops = Printtyp.reset_and_mark_loops
let type_expr = Printtyp.type_expr

(* taken from https://github.com/BuckleScript/ocaml/blob/d4144647d1bf9bc7dc3aadc24c25a7efa3a67915/typing/typecore.ml#L3769 *)
(* modified branches are commented *)
let report_error env ppf = function
  | Typecore.Polymorphic_label lid ->
      fprintf ppf "@[The record field %a is polymorphic.@ %s@]"
        longident lid "You cannot instantiate it in a pattern."
  | Constructor_arity_mismatch(lid, expected, provided) ->
      (* modified *)
      fprintf ppf
       "@[This variant constructor, %a, expects %i %s; here, we've %sfound %i.@]"
       longident lid expected (if expected == 1 then "argument" else "arguments") (if provided < expected then "only " else "") provided
  | Label_mismatch(lid, trace) ->
      super_report_unification_error ppf env trace
        (function ppf ->
           fprintf ppf "The record field %a@ belongs to the type"
                   longident lid)
        (function ppf ->
           fprintf ppf "but is mixed here with fields of type")
  | Pattern_type_clash trace ->
      super_report_unification_error ppf env trace
        (function ppf ->
          fprintf ppf "This pattern matches values of type")
        (function ppf ->
          fprintf ppf "but a pattern was expected which matches values of type")
  | Or_pattern_type_clash (id, trace) ->
      super_report_unification_error ppf env trace
        (function ppf ->
          fprintf ppf "The variable %s on the left-hand side of this or-pattern has type" (Ident.name id))
        (function ppf ->
          fprintf ppf "but on the right-hand side it has type")
  | Multiply_bound_variable name ->
      fprintf ppf "Variable %s is bound several times in this matching" name
  | Orpat_vars id ->
      fprintf ppf "Variable %s must occur on both sides of this | pattern"
        (Ident.name id)
  | Expr_type_clash trace ->
      (* modified *)
      if Super_reason_react.state_escape_scope trace then
        fprintf ppf "@[<v>\
          @[@{<info>Is this a ReasonReact reducerComponent or component with retained props?@}@ \
          If so, is the type for state, retained props or action declared _after_ the component declaration?@ \
          Moving these types above the component declaration should resolve this!@]@,@,\
          @[@{<info>Here's the original error message@}@]@,\
        @]"
      else if Super_reason_react.is_array_wanted_reactElement trace then
        fprintf ppf "@[<v>\
          @[@{<info>Are you passing an array as a ReasonReact DOM (lower-case) component's children?@}@ If not, disregard this.@ \
          If so, please use `ReasonReact.createDomElement`:@ https://reasonml.github.io/reason-react/index.html#reason-react-working-with-children@]@,@,\
          @[@{<info>Here's the original error message@}@]@,\
        @]";
      super_report_unification_error ppf env trace
        (function ppf ->
           fprintf ppf "This is:")
        (function ppf ->
           fprintf ppf "But somewhere wanted:")
  | Apply_non_function typ ->
      (* modified *)
      reset_and_mark_loops typ;
      begin match (repr typ).desc with
        Tarrow (_, _inputType, returnType, _) ->
          let rec countNumberOfArgs count {desc} = match desc with
          | Tarrow (_, _inputType, returnType, _) -> countNumberOfArgs (count + 1) returnType
          | _ -> count
          in
          let countNumberOfArgs = countNumberOfArgs 1 in
          let acceptsCount = countNumberOfArgs returnType in
          fprintf ppf "@[<v>@[<2>This function has type@ %a@]"
            type_expr typ;
          fprintf ppf "@ @[It only accepts %i %s; here, it's called with more.@ %s@]@]"
                      acceptsCount (if acceptsCount == 1 then "argument" else "arguments") "Maybe you forgot a semicolon?"
      | _ ->
          fprintf ppf "@[<v>@[<2>This expression has type@ %a@]@ %s@]"
            type_expr typ
            "It seems to have been called like a function? Maybe you forgot a semicolon somewhere?"
      end
  | Apply_wrong_label (l, ty) ->
      let print_label ppf = function
        | "" -> fprintf ppf "without label"
        | l ->
            fprintf ppf "with label %s" (prefixed_label_name l)
      in
      reset_and_mark_loops ty;
      fprintf ppf
        "@[<v>@[<2>The function applied to this argument has type@ %a@]@.\
          This argument cannot be applied %a@]"
        type_expr ty print_label l
  | Label_multiply_defined s ->
      fprintf ppf "The record field label %s is defined several times" s
  | Label_missing labels ->
      let print_labels ppf =
        List.iter (fun lbl -> fprintf ppf "@ %s" (Ident.name lbl)) in
      fprintf ppf "@[<hov>Some record fields are undefined:%a@]"
        print_labels labels
  | Label_not_mutable lid ->
      fprintf ppf "The record field %a is not mutable" longident lid
  | Wrong_name (eorp, ty, kind, p, lid) as foo ->
      (* forwarded *)
      Typecore.report_error env ppf foo
      (* reset_and_mark_loops ty;
      fprintf ppf "@[@[<2>%s type@ %a@]@ "
        eorp type_expr ty;
      fprintf ppf "The %s %a does not belong to type %a@]"
        (if kind = "record" then "field" else "constructor")
        longident lid (*kind*) path p;
      if kind = "record" then Label.spellcheck ppf env p lid
                         else Constructor.spellcheck ppf env p lid *)
  | Name_type_mismatch (kind, lid, tp, tpl) ->
      let name = if kind = "record" then "field" else "constructor" in
      Printtyp.report_ambiguous_type_error ppf env tp tpl
        (function ppf ->
           fprintf ppf "The %s %a@ belongs to the %s type"
             name longident lid kind)
        (function ppf ->
           fprintf ppf "The %s %a@ belongs to one of the following %s types:"
             name longident lid kind)
        (function ppf ->
           fprintf ppf "but a %s was expected belonging to the %s type"
             name kind)
  | Invalid_format msg ->
      fprintf ppf "%s" msg
  | Undefined_method (ty, me) ->
      reset_and_mark_loops ty;
      fprintf ppf
        "@[<v>@[This expression has type@;<1 2>%a@]@,\
         It has no method %s@]" type_expr ty me
  | Undefined_inherited_method me ->
      fprintf ppf "This expression has no method %s" me
  | Virtual_class cl ->
      fprintf ppf "Cannot instantiate the virtual class %a"
        longident cl
  | Unbound_instance_variable v ->
      fprintf ppf "Unbound instance variable %s" v
  | Instance_variable_not_mutable (b, v) ->
      if b then
        fprintf ppf "The instance variable %s is not mutable" v
      else
        fprintf ppf "The value %s is not an instance variable" v
  | Not_subtype(tr1, tr2) ->
      Printtyp.report_subtyping_error ppf env tr1 "is not a subtype of" tr2
  | Outside_class ->
      fprintf ppf "This object duplication occurs outside a method definition"
  | Value_multiply_overridden v ->
      fprintf ppf "The instance variable %s is overridden several times" v
  | Coercion_failure (ty, ty', trace, b) ->
      super_report_unification_error ppf env trace
        (function ppf ->
           let ty, ty' = Printtyp.prepare_expansion (ty, ty') in
           fprintf ppf
             "This expression cannot be coerced to type@;<1 2>%a;@ it has type"
           (Printtyp.type_expansion ty) ty')
        (function ppf ->
           fprintf ppf "but is here used with type");
      if b then
        fprintf ppf ".@.@[<hov>%s@ %s@]"
          "This simple coercion was not fully general."
          "Consider using a double coercion."
  | Too_many_arguments (in_function, ty) ->
      reset_and_mark_loops ty;
      if in_function then begin
        fprintf ppf "This function expects too many arguments,@ ";
        fprintf ppf "it should have type@ %a"
          type_expr ty
      end else begin
        fprintf ppf "This expression should not be a function,@ ";
        fprintf ppf "the expected type is@ %a"
          type_expr ty
      end
  | Abstract_wrong_label (l, ty) ->
      let label_mark = function
        | "" -> "but its first argument is not labelled"
        |  l -> sprintf "but its first argument is labelled %s"
          (prefixed_label_name l) in
      reset_and_mark_loops ty;
      fprintf ppf "@[<v>@[<2>This function should have type@ %a@]@,%s@]"
      type_expr ty (label_mark l)
  | Scoping_let_module(id, ty) ->
      reset_and_mark_loops ty;
      fprintf ppf
       "This `let module' expression has type@ %a@ " type_expr ty;
      fprintf ppf
       "In this type, the locally bound module name %s escapes its scope" id
  | Masked_instance_variable lid ->
      fprintf ppf
        "The instance variable %a@ \
         cannot be accessed from the definition of another instance variable"
        longident lid
  | Private_type ty ->
      fprintf ppf "Cannot create values of the private type %a" type_expr ty
  | Private_label (lid, ty) ->
      fprintf ppf "Cannot assign field %a of the private type %a"
        longident lid type_expr ty
  | Not_a_variant_type lid ->
      fprintf ppf "The type %a@ is not a variant type" longident lid
  | Incoherent_label_order ->
      fprintf ppf "This function is applied to arguments@ ";
      fprintf ppf "in an order different from other calls.@ ";
      fprintf ppf "This is only allowed when the real type is known."
  | Less_general (kind, trace) ->
      super_report_unification_error ppf env trace
        (fun ppf -> fprintf ppf "This %s has type" kind)
        (fun ppf -> fprintf ppf "which is less general than")
  | Modules_not_allowed ->
      fprintf ppf "Modules are not allowed in this pattern."
  | Cannot_infer_signature ->
      fprintf ppf
        "The signature for this packaged module couldn't be inferred."
  | Not_a_packed_module ty ->
      fprintf ppf
        "This expression is packed module, but the expected type is@ %a"
        type_expr ty
  | Recursive_local_constraint trace ->
      super_report_unification_error ppf env trace
        (function ppf ->
           fprintf ppf "Recursive local constraint when unifying")
        (function ppf ->
           fprintf ppf "with")
  | Unexpected_existential ->
      fprintf ppf
        "Unexpected existential"
  | Unqualified_gadt_pattern (tpath, name) ->
      fprintf ppf "@[The GADT constructor %s of type %a@ %s.@]"
        name Printtyp.path tpath
        "must be qualified in this pattern"
  | Invalid_interval ->
      fprintf ppf "@[Only character intervals are supported in patterns.@]"
  | Invalid_for_loop_index ->
      fprintf ppf
        "@[Invalid for-loop index: only variables and _ are allowed.@]"
  | No_value_clauses ->
      fprintf ppf
        "None of the patterns in this 'match' expression match values."
  | Exception_pattern_below_toplevel ->
      fprintf ppf
        "@[Exception patterns must be at the top level of a match case.@]"

let report_error env ppf err =
  Printtyp.wrap_printing_env env (fun () -> report_error env ppf err)

(* This will be called in super_main. This is how you'd override the default error printer from the compiler & register new error_of_exn handlers *)
let setup () =
  Location.register_error_of_exn
    (function
      | Typecore.Error (loc, env, err) ->
        Some (Super_location.error_of_printer loc (report_error env) err)
      | Typecore.Error_forward err ->
        Some err
      | _ ->
        None
    )

end
module Super_typemod
= struct
#1 "super_typemod.ml"
open Printtyp

let fprintf = Format.fprintf

let pp_component_type_not_generalizable_pre ppf =
  fprintf ppf "@[<v>\
    @[@{<info>Is this a ReasonReact reducerComponent or component with retained props?@}@ \
    If so, this error will disappear after:@]@,\
    @[- Defining the component's `make` function@]@,\
    @[- Using the state once or annotating it with a type where it's used (e.g. render)@]@,\
    @[- Doing the same for action (in e.g. reducer)@]@,\
    @[- Doing the same for retained props, if any@]@,@,\
    @[@{<info>Here's the original error message@}@]\
  @]@,"

let pp_component_type_not_generalizable_post ppf () =
  fprintf ppf
  "@[This happens when the type system senses there's a mutation/side-effect, in combination with a polymorphic value.@,\
  Using or annotating that value usually solves it.@ \
  More info:@ https://realworldocaml.org/v1/en/html/imperative-programming-1.html#side-effects-and-weak-polymorphism@]"

(* taken from https://github.com/BuckleScript/ocaml/blob/d4144647d1bf9bc7dc3aadc24c25a7efa3a67915/typing/typemod.ml#L1754 *)
(* modified branches are commented *)
let report_error ppf = Typemod.(function
    Cannot_apply mty ->
      fprintf ppf
        "@[This module is not a functor; it has type@ %a@]" modtype mty
  | Not_included errs ->
      fprintf ppf
        "@[<v>Signature mismatch:@ %a@]" Includemod.report_error errs
  | Cannot_eliminate_dependency mty ->
      fprintf ppf
        "@[This functor has type@ %a@ \
           The parameter cannot be eliminated in the result type.@  \
           Please bind the argument to a module identifier.@]" modtype mty
  | Signature_expected -> fprintf ppf "This module type is not a signature"
  | Structure_expected mty ->
      fprintf ppf
        "@[This module is not a structure; it has type@ %a" modtype mty
  | With_no_component lid ->
      fprintf ppf
        "@[The signature constrained by `with' has no component named %a@]"
        longident lid
  | With_mismatch(lid, explanation) ->
      fprintf ppf
        "@[<v>\
           @[In this `with' constraint, the new definition of %a@ \
             does not match its original definition@ \
             in the constrained signature:@]@ \
           %a@]"
        longident lid Includemod.report_error explanation
  | Repeated_name(kind, name) ->
      fprintf ppf
        "@[Multiple definition of the %s name %s.@ \
           Names must be unique in a given structure or signature.@]" kind name
  | Non_generalizable typ ->
      (* modified *)
      fprintf ppf "@[<v>";
      if Super_reason_react.type_is_component_spec typ then begin
        pp_component_type_not_generalizable_pre ppf
      end;
      fprintf ppf
        "@[This expression's type contains type variables that can't be generalized:@,@{<error>%a@}@]@,@,\
         %a"        
        type_scheme typ
        pp_component_type_not_generalizable_post ();
      fprintf ppf "@]"
  | Non_generalizable_class (id, desc) ->
      fprintf ppf
        "@[The type of this class,@ %a,@ \
           contains type variables that cannot be generalized@]"
        (class_declaration id) desc
  | Non_generalizable_module mty ->
      (* modified *)
      fprintf ppf "@[<v>";
      if Super_reason_react.module_type_is_component_spec mty then begin
        pp_component_type_not_generalizable_pre ppf
      end;
      fprintf ppf
        "@[The type of this module contains type variables that cannot be generalized:@,@{<error>%a@}@]@,@,\
         %a"        
        modtype mty
        pp_component_type_not_generalizable_post ();
      fprintf ppf "@]"           
  | Implementation_is_required intf_name ->
      fprintf ppf
        "@[The interface %a@ declares values, not just types.@ \
           An implementation must be provided.@]"
        Location.print_filename intf_name
  | Interface_not_compiled intf_name ->
      fprintf ppf
        "@[Could not find the .cmi file for interface@ %a.@]"
        Location.print_filename intf_name
  | Not_allowed_in_functor_body ->
      fprintf ppf
        "@[This expression creates fresh types.@ %s@]"
        "It is not allowed inside applicative functors."
  | With_need_typeconstr ->
      fprintf ppf
        "Only type constructors with identical parameters can be substituted."
  | Not_a_packed_module ty ->
      fprintf ppf
        "This expression is not a packed module. It has type@ %a"
        type_expr ty
  | Incomplete_packed_module ty ->
      fprintf ppf
        "The type of this packed module contains variables:@ %a"
        type_expr ty
  | Scoping_pack (lid, ty) ->
      fprintf ppf
        "The type %a in this module cannot be exported.@ " longident lid;
      fprintf ppf
        "Its type contains local dependencies:@ %a" type_expr ty
  | Recursive_module_require_explicit_type ->
      fprintf ppf "Recursive modules require an explicit module type."
  | Apply_generative ->
      fprintf ppf "This is a generative functor. It can only be applied to ()"
)

let report_error env ppf err =
  Printtyp.wrap_printing_env env (fun () -> report_error ppf err)

(* This will be called in super_main. This is how you'd override the default error printer from the compiler & register new error_of_exn handlers *)
let setup () =
  Location.register_error_of_exn
    (function
      | Typemod.Error (loc, env, err) ->
        Some (Super_location.error_of_printer loc (report_error env) err)
      | Typemod.Error_forward err ->
        Some err
      | _ ->
        None
    )

end
module Super_typetexp
= struct
#1 "super_typetexp.ml"
open Misc
open Asttypes
open Parsetree
open Types
open Typedtree
open Btype
open Ctype

open Format
open Printtyp

(* taken from https://github.com/BuckleScript/ocaml/blob/d4144647d1bf9bc7dc3aadc24c25a7efa3a67915/typing/typetexp.ml#L869 *)
let spellcheck ppf fold env lid =
  let cutoff =
    match String.length (Longident.last lid) with
      | 1 | 2 -> 0
      | 3 | 4 -> 1
      | 5 | 6 -> 2
      | _ -> 3
  in
  let compare target head acc =
    let (best_choice, best_dist) = acc in
    match Misc.edit_distance target head cutoff with
      | None -> (best_choice, best_dist)
      | Some dist ->
        let choice =
          if dist < best_dist then [head]
          else if dist = best_dist then head :: best_choice
          else best_choice in
        (choice, min dist best_dist)
  in
  let init = ([], max_int) in
  let handle (choice, _dist) =
    match List.rev choice with
      | [] -> ()
      | last :: rev_rest ->
        (* the modified part *)
        fprintf ppf "@[<v 2>@,@,@{<info>Hint: Did you mean %s%s%s?@}@]"
          (String.concat ", " (List.rev rev_rest))
          (if rev_rest = [] then "" else " or ")
          last
  in
  (* flush now to get the error report early, in the (unheard of) case
     where the linear search would take a bit of time; in the worst
     case, the user has seen the error, she can interrupt the process
     before the spell-checking terminates. *)
  fprintf ppf "@?";
  match lid with
    | Longident.Lapply _ -> ()
    | Longident.Lident s ->
      handle (fold (compare s) None env init)
    | Longident.Ldot (r, s) ->
      handle (fold (compare s) (Some r) env init)

let spellcheck ppf fold =
  spellcheck ppf (fun f -> fold (fun s _ _ x -> f s x))

(* taken from https://github.com/BuckleScript/ocaml/blob/d4144647d1bf9bc7dc3aadc24c25a7efa3a67915/typing/typetexp.ml#L918 *)
(* modified branches are commented *)
let report_error env ppf = function
  | Typetexp.Unbound_type_variable name ->
    fprintf ppf "Unbound type parameter %s@." name
  | Unbound_type_constructor lid ->
    (* modified *)
    fprintf ppf "This type constructor's parameter, `%a`, can't be found. Is it a typo?" longident lid;
    spellcheck ppf Env.fold_types env lid;
  | Unbound_type_constructor_2 p ->
    fprintf ppf "The type constructor@ %a@ is not yet completely defined"
      path p
  | Type_arity_mismatch(lid, expected, provided) ->
    fprintf ppf
      "@[The type constructor %a@ expects %i argument(s),@ \
        but is here applied to %i argument(s)@]"
      longident lid expected provided
  | Bound_type_variable name ->
    fprintf ppf "Already bound type parameter '%s" name
  | Recursive_type ->
    fprintf ppf "This type is recursive"
  | Unbound_row_variable lid ->
      (* we don't use "spellcheck" here: this error is not raised
         anywhere so it's unclear how it should be handled *)
      fprintf ppf "Unbound row variable in #%a" longident lid
  | Type_mismatch trace ->
      Printtyp.super_report_unification_error ppf Env.empty trace
        (function ppf ->
           fprintf ppf "This type")
        (function ppf ->
           fprintf ppf "should be an instance of type")
  | Alias_type_mismatch trace ->
      Printtyp.super_report_unification_error ppf Env.empty trace
        (function ppf ->
           fprintf ppf "This alias is bound to type")
        (function ppf ->
           fprintf ppf "but is used as an instance of type")
  | Present_has_conjunction l ->
      fprintf ppf "The present constructor %s has a conjunctive type" l
  | Present_has_no_type l ->
      fprintf ppf "The present constructor %s has no type" l
  | Constructor_mismatch (ty, ty') ->
      wrap_printing_env env (fun ()  ->
        Printtyp.reset_and_mark_loops_list [ty; ty'];
        fprintf ppf "@[<hov>%s %a@ %s@ %a@]"
          "This variant type contains a constructor"
          Printtyp.type_expr ty
          "which should be"
          Printtyp.type_expr ty')
  | Not_a_variant ty ->
      Printtyp.reset_and_mark_loops ty;
      fprintf ppf "@[The type %a@ is not a polymorphic variant type@]"
        Printtyp.type_expr ty
  | Variant_tags (lab1, lab2) ->
      fprintf ppf
        "@[Variant tags `%s@ and `%s have the same hash value.@ %s@]"
        lab1 lab2 "Change one of them."
  | Invalid_variable_name name ->
      fprintf ppf "The type variable name %s is not allowed in programs" name
  | Cannot_quantify (name, v) ->
      fprintf ppf
        "@[<hov>The universal type variable '%s cannot be generalized:@ %s.@]"
        name
        (if Btype.is_Tvar v then "it escapes its scope" else
         if Btype.is_Tunivar v then "it is already bound to another variable"
         else "it is not a variable")
  | Multiple_constraints_on_type s ->
      fprintf ppf "Multiple constraints for type %a" longident s
  | Repeated_method_label s ->
      fprintf ppf "@[This is the second method `%s' of this object type.@ %s@]"
        s "Multiple occurences are not allowed."
  | Unbound_value lid -> 
      (* modified *)
      begin
        match lid with
        | Ldot (outer, inner) ->
          fprintf ppf "The value %s can't be found in %a"
            inner 
            Printtyp.longident outer;
        | other_ident -> fprintf ppf "The value %a can't be found" Printtyp.longident other_ident
      end;
      spellcheck ppf Env.fold_values env lid;
  | Unbound_module lid ->
      (* modified *)
      fprintf ppf "@[<v>\
          @{<info>The module or file %a can't be found.@}@,@,\
          @[<v 2>- If it's a third-party dependency:@,\
            - Did you list it in bsconfig.json?@,\
            - @[Did you run `bsb` instead of `bsb -make-world`@ (latter builds third-parties)@]?\
            @]@,\
          - Did you include the file's directory in bsconfig.json?@]\
        @]"
        longident lid;
      spellcheck ppf Env.fold_modules env lid
  | Unbound_constructor lid ->
      fprintf ppf "Unbound constructor %a" longident lid;
      Typetexp.spellcheck_simple ppf Env.fold_constructors (fun d -> d.cstr_name)
        env lid;
  | Unbound_label lid ->
      fprintf ppf "Unbound record field %a" longident lid;
      Typetexp.spellcheck_simple ppf Env.fold_labels (fun d -> d.lbl_name) env lid;
  | Unbound_class lid ->
      fprintf ppf "Unbound class %a" longident lid;
      spellcheck ppf Env.fold_classs env lid;
  | Unbound_modtype lid ->
      fprintf ppf "Unbound module type %a" longident lid;
      spellcheck ppf Env.fold_modtypes env lid;
  | Unbound_cltype lid ->
      fprintf ppf "Unbound class type %a" longident lid;
      spellcheck ppf Env.fold_cltypes env lid;
  | Ill_typed_functor_application lid ->
      fprintf ppf "Ill-typed functor application %a" longident lid
  | Illegal_reference_to_recursive_module ->
      fprintf ppf "Illegal recursive module reference"
  | Access_functor_as_structure lid ->
      fprintf ppf "The module %a is a functor, not a structure" longident lid

(* This will be called in super_main. This is how you'd override the default error printer from the compiler & register new error_of_exn handlers *)
let setup () =
  Location.register_error_of_exn
    (function
      | Typetexp.Error (loc, env, err) ->
        Some (Super_location.error_of_printer loc (report_error env) err)
      (* typetexp doesn't expose Error_forward  *)
      (* | Error_forward err ->
        Some err *)
      | _ ->
        None
    )

end
module Super_main
= struct
#1 "super_main.ml"
(* the entry point. This is used by js_main.ml *)
let setup () =
  Super_location.setup ();
  Super_typetexp.setup ();
  Super_typemod.setup ();
  Super_typecore.setup ();
  Super_env.setup ();
  Super_pparse.setup ();

end
module Js_main : sig 
#1 "js_main.mli"
(* Copyright (C) 2015-2016 Bloomberg Finance L.P.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition to the permissions granted to you by the LGPL, you may combine
 * or link a "work that uses the Library" with a publicly distributed version
 * of this file to produce a combined library or application, then distribute
 * that combined work under the terms of your choosing, with no requirement
 * to comply with the obligations normally placed on you by section 4 of the
 * LGPL version 3 (or the corresponding section of a later version of the LGPL
 * should you choose to use a later version).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)


end = struct
#1 "js_main.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the Q Public License version 1.0.               *)
(*                                                                     *)
(***********************************************************************)


let process_interface_file ppf name =
  Js_implementation.interface ppf name (Compenv.output_prefix name)
let process_implementation_file ppf name =
  Js_implementation.implementation ppf name (Compenv.output_prefix name)


let process_file ppf name = 
  match Ocaml_parse.check_suffix  name with 
  | Ml, opref ->
    Js_implementation.implementation ppf name opref 
  | Mli, opref -> 
    Js_implementation.interface ppf name opref 
  | Mliast, opref 
    -> Js_implementation.interface_mliast ppf name opref 
  | Mlast, opref 
    -> Js_implementation.implementation_mlast ppf name opref
  | Mlmap, opref 
    -> Js_implementation.implementation_map ppf name opref

let usage = "Usage: bsc <options> <files>\nOptions are:"

let ppf = Format.err_formatter

(* Error messages to standard error formatter *)
let anonymous filename =
  Compenv.readenv ppf Before_compile; process_file ppf filename;;
let impl filename =
  Compenv.readenv ppf Before_compile; process_implementation_file ppf filename;;
let intf filename =
  Compenv.readenv ppf Before_compile; process_interface_file ppf filename;;

let batch_files  = ref []
let script_dirs = ref []
let main_file  = ref ""
let eval_string = ref ""
        
let collect_file name = 
  batch_files := name :: !batch_files
let add_bs_dir v = 
  script_dirs := v :: !script_dirs

let set_main_entry name =
  if !eval_string <> "" then
    raise (Arg.Bad ("-bs-main conflicts with -bs-eval")) else 
  if Sys.file_exists name then 
    main_file := name else
  raise (Arg.Bad ("file " ^ name ^ " don't exist"))


let set_eval_string s = 
  if !main_file <> "" then 
    raise (Arg.Bad ("-bs-main conflicts with -bs-eval")) else 
  eval_string :=  s 




let (//) = Filename.concat


let set_noassert () = 
  Js_config.set_no_any_assert ();
  Clflags.noassert := true

                       
let define_variable s =
  match Ext_string.split ~keep_empty:true s '=' with
  | [key; v] -> 
    if not @@ Lexer.define_key_value key v  then 
      raise (Arg.Bad ("illegal definition: " ^ s))
  | _ -> raise (Arg.Bad ("illegal definition: " ^ s))

  
let buckle_script_flags =
  ("-bs-super-errors",
    Arg.Unit 
      (* needs to be set here instead of, say, setting a
        Js_config.better_errors flag; otherwise, when `anonymous` runs, we
        don't have time to set the custom printer before it starts outputting
        warnings *)
      Super_main.setup
     ,
   " Better error message combined with other tools "
  )
  :: 
  ("-bs-re-error",
    Arg.Unit Reason_outcome_printer_main.setup,
   " Print compiler errors in Reason syntax"
  )
  :: 
  ("-bs-no-implicit-include", Arg.Set Clflags.no_implicit_current_dir
  , " Don't include current dir implicitly")
  ::
  ("-bs-assume-has-mli", Arg.Unit (fun _ -> Clflags.assume_no_mli := Clflags.Mli_exists), 
    " (internal) Assume mli always exist ")
  ::
  ("-bs-assume-no-mli", Arg.Unit (fun _ -> Clflags.assume_no_mli := Clflags.Mli_non_exists),
  " (internal) Don't lookup whether mli exist or not")
  ::
  ("-bs-D", Arg.String define_variable,
     " Define conditional variable e.g, -D DEBUG=true"
  )
  ::
  ("-bs-list-conditionals",
   Arg.Unit (fun () -> Lexer.list_variables Format.err_formatter),
   " List existing conditional variables")
  ::
  (
    "-bs-binary-ast", Arg.Set Js_config.binary_ast,
    " Generate binary .mli_ast and ml_ast"
  )
  ::
  ("-bs-syntax-only", 
   Arg.Set Js_config.syntax_only,
   " only check syntax"
  )
  ::
  ("-bs-no-bin-annot", Arg.Clear Clflags.binary_annotations, 
   " disable binary annotations (by default on)")
  ::
  ("-bs-eval", 
   Arg.String set_eval_string, 
   " (experimental) Set the string to be evaluated, note this flag will be conflicted with -bs-main"
  )
  ::("-bs-no-error-unused-attribute",
    Arg.Set Js_config.no_error_unused_bs_attribute,
    " No error when seeing unused attribute"
    (* We introduce such flag mostly 
      for work around 
      in case some embarassing compiler bugs
    *)
  )
  ::
  (
    "-bs-sort-imports",
    Arg.Set Js_config.sort_imports,
    " Sort the imports by lexical order so the output will be more stable (default false)"
  )
  ::
  ( "-bs-no-sort-imports", 
    Arg.Clear Js_config.sort_imports,
    " No sort (see -bs-sort-imports)"
  )
  ::
  ("-bs-package-name", 
   Arg.String Js_packages_state.set_package_name, 
   " set package name, useful when you want to produce npm packages")
  ::
  ( "-bs-package-map", 
   Arg.String Js_packages_state.set_package_map, 
   " set package map, not only set package name but also use it as a namespace"    
  )
  :: 
  ("-bs-no-version-header", 
   Arg.Set Js_config.no_version_header,
   " Don't print version header"
  )
  ::
  ("-bs-package-output", 
   Arg.String 
    Js_packages_state.update_npm_package_path, 
   " set npm-output-path: [opt_module]:path, for example: 'lib/cjs', 'amdjs:lib/amdjs', 'es6:lib/es6' ")
  ::
  
  ("-bs-no-warn-unused-bs-attribute",
   Arg.Set Js_config.no_warn_unused_bs_attribute,
   " disable warnings on unused bs. attribute"
  )
  ::
  ("-bs-no-warn-ffi-type", 
   Arg.Set Js_config.no_warn_ffi_type,
   " disable warnings for ffi type"
  ) 
  ::
  ("-bs-no-builtin-ppx-ml", 
   Arg.Set Js_config.no_builtin_ppx_ml,
   "disable built-in ppx for ml files (internal use)")
  :: 
  ("-bs-no-builtin-ppx-mli",
   Arg.Set Js_config.no_builtin_ppx_mli,
   "disable built-in ppx for mli files (internal use)")
  :: 
  ("-bs-cross-module-opt", 
   Arg.Set Js_config.cross_module_inline, 
   "enable cross module inlining(experimental), default(false)")
  :: 
  ("-bs-gen-tds",
   Arg.Set Js_config.default_gen_tds, 
   " set will generate `.d.ts` file for typescript (experimental)")
  :: 
  ("-bs-diagnose",
   Arg.Set Js_config.diagnose, 
   " More verbose output")
  :: 
  ("-bs-no-check-div-by-zero",
   Arg.Clear Js_config.check_div_by_zero, 
   " unsafe mode, don't check div by zero and mod by zero")
  ::
  ("-bs-no-any-assert",
   Arg.Unit set_noassert, 
   " no code containing any assertion"
  )
  ::
  ("-bs-main",
   Arg.String set_main_entry,   
   " set the Main entry module in script mode, for example -bs-main Main")
  ::
  ("-bs-I", 
   Arg.String add_bs_dir, 
   " add source dir search path in script mode"
  )
  :: 
  ("-bs-files", 
   Arg.Rest collect_file, 
   " Provide batch of files, the compiler will sort it before compiling"
  )
  (* :: *)
  (* ("-bs-list-directives", *)
  (* ) *)
  :: Ocaml_options.mk_impl impl
  :: Ocaml_options.mk_intf intf 
  :: Ocaml_options.mk__ anonymous
  :: Ocaml_options.ocaml_options

let _ = 
  (* Default configuration: sync up with 
    {!Jsoo_main}  *)
  Clflags.unsafe_string := false;
  Clflags.debug := true;
  Clflags.record_event_when_debug := false;
  Clflags.binary_annotations := true; 
  Bs_conditional_initial.setup_env ();
  try
    Compenv.readenv ppf Before_args;
    Arg.parse buckle_script_flags anonymous usage;
    let main_file = !main_file in
    let eval_string = !eval_string in
    let task : Ocaml_batch_compile.task = 
      if main_file <> "" then 
        Main main_file
      else if eval_string <> "" then 
        Eval eval_string
      else None in
    exit (Ocaml_batch_compile.batch_compile ppf 
            (if !Clflags.no_implicit_current_dir then !script_dirs else 
               Filename.current_dir_name::!script_dirs) !batch_files task) 
  with x -> 
    begin
      Location.report_exception ppf x;
      exit 2
    end

end
